{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzY3MjcyNDEy", "number": 6911, "title": "[insteon] initial commit of insteon binding (#2982)", "bodyText": "This binding is a port of the oh 1 insteonplm binding (#2982). The code ported from the insteonplm binding is almost identical, other than minor changes to make it work with oh 2, and changes to adhere to new coding conventions, etc.\nThe files from the insteonplm are:\norg.openhab.binding.insteon.internal.InsteonBinding.java\norg.openhab.binding.insteon.internal.device.*.java\norg.openhab.binding.insteon.internal.driver.*.java\norg.openhab.binding.insteon.internal.message.*.java\norg.openhab.binding.insteon.internal.util.*.java\n\nSample things file:\nBridge insteon:network:local [port=\"/dev/ttyUSB0\"] {\n  Thing device 22F8B8 [address=\"22.F8.B8\", productKey=\"F00.00.15\"] {\n    Channels:\n      Type switch : keypadButtonA [group=3]\n      Type switch : keypadButtonB [group=4]\n      Type switch : keypadButtonC [group=5]\n      Type switch : keypadButtonD [group=6]\n  }\n  Thing device 239D93 [address=\"23.9D.93\", productKey=\"F00.00.11\"] {\n    Channels:\n      Type dimmer : dimmer [dimmermax=60]\n  }\n  Thing device 239F55 [address=\"23.9F.55\", productKey=\"F00.00.11\"] {\n    Channels:\n      Type dimmer : dimmer [related=\"23.A0.D9+23.9F.C9\"]\n  }\n  Thing device 239FC9 [address=\"23.9F.C9\", productKey=\"F00.00.11\"] {\n    Channels:\n      Type dimmer : dimmer [related=\"23.9F.55+23.A0.D9\"]\n  }\n  Thing device 23A0D9 [address=\"23.A0.D9\", productKey=\"F00.00.11\"] {\n    Channels:\n      Type dimmer : dimmer [related=\"23.9F.55+23.9F.C9\"]\n  }\n  Thing device 243181 [address=\"24.31.81\", productKey=\"F00.00.12\"]\n}\n\nSample Items file:\nSwitch switch1 {channel=\"insteon:device:local:243181:switch\"}\nDimmer dimmer1 {channel=\"insteon:device:local:239F55:dimmer\"}\nDimmer dimmer2 {channel=\"insteon:device:local:23A0D9:dimmer\"}\nDimmer dimmer3 {channel=\"insteon:device:local:239FC9:dimmer\"}\nDimmer keypad  {channel=\"insteon:device:local:22F8B8:loadDimmer\"}\nSwitch keypadA {channel=\"insteon:device:local:22F8B8:keypadButtonA\"}\nSwitch keypadB {channel=\"insteon:device:local:22F8B8:keypadButtonB\"}\nSwitch keypadC {channel=\"insteon:device:local:22F8B8:keypadButtonC\"}\nSwitch keypadD {channel=\"insteon:device:local:22F8B8:keypadButtonD\"}\nDimmer dimmer  {channel=\"insteon:device:local:239D93:dimmer\"}", "createdAt": "2020-01-26T23:19:58Z", "url": "https://github.com/openhab/openhab-addons/pull/6911", "merged": true, "mergeCommit": {"oid": "b13ee44f6539d0c09d236ec0c800675f58f14985"}, "closed": true, "closedAt": "2020-03-19T16:52:17Z", "author": {"login": "robnielsen"}, "timelineItems": {"totalCount": 14, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABb-YWn8AFqTM0ODQ4NDg1Mw==", "endCursor": "Y3Vyc29yOnYyOpPPAAABcO6y70gFqTM3NzA4NzE0Ng==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ4NDg0ODUz", "url": "https://github.com/openhab/openhab-addons/pull/6911#pullrequestreview-348484853", "createdAt": "2020-01-27T08:02:44Z", "commit": {"oid": "d8407f4d3e56f93dadba66a086ab0d3e70ef5b95"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 10, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yN1QwODowMjo0NVrOFh6L0w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yN1QwODoxODoxN1rOFh6eqg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTEwMDYyNw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        pollingJob = scheduler.scheduleWithFixedDelay(new Runnable() {\n          \n          \n            \n                            @Override\n          \n          \n            \n                            public void run() {\n          \n          \n            \n                                insteonBinding.logDeviceStatistics();\n          \n          \n            \n                            }\n          \n          \n            \n                        }, 0, insteonBinding.getDeviceStatisticsInterval(), TimeUnit.SECONDS);\n          \n          \n            \n                        pollingJob = scheduler.scheduleWithFixedDelay(insteonBinding::logDeviceStatistics,\n          \n          \n            \n                            0, insteonBinding.getDeviceStatisticsInterval(), TimeUnit.SECONDS);", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r371100627", "createdAt": "2020-01-27T08:02:45Z", "author": {"login": "Hilbrand"}, "path": "bundles/org.openhab.binding.insteon/src/main/java/org/openhab/binding/insteon/internal/handler/InsteonNetworkHandler.java", "diffHunk": "@@ -0,0 +1,124 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.insteon.internal.handler;\n+\n+import java.util.List;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseBridgeHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.insteon.internal.InsteonBinding;\n+import org.openhab.binding.insteon.internal.config.InsteonNetworkConfiguration;\n+import org.openhab.binding.insteon.internal.discovery.InsteonDeviceDiscoveryService;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link InsteonNetworkHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Rob Nielsen - Initial contribution\n+ */\n+@NonNullByDefault\n+public class InsteonNetworkHandler extends BaseBridgeHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(InsteonNetworkHandler.class);\n+\n+    private @Nullable InsteonNetworkConfiguration config;\n+    private @Nullable InsteonBinding insteonBinding;\n+    private @Nullable InsteonDeviceDiscoveryService insteonDeviceDiscoveryService;\n+    private @Nullable ScheduledFuture<?> pollingJob = null;\n+\n+    public static ClassLoader classLoader = Thread.currentThread().getContextClassLoader();\n+\n+    public InsteonNetworkHandler(Bridge bridge) {\n+        super(bridge);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.info(\"Starting Insteon bridge\");\n+        config = getConfigAs(InsteonNetworkConfiguration.class);\n+\n+        scheduler.execute(() -> {\n+            insteonBinding = new InsteonBinding(this, config.getPort(), config.getDeviceStatisticsInterval(),\n+                    config.getDeviceDeadCount(), config.getDevicePollInterval(), config.getAdditionalDevices(),\n+                    config.getAdditionalFeatures(), config.getModemDbRetryTimeout());\n+\n+            updateStatus(ThingStatus.ONLINE);\n+\n+            if (!insteonBinding.startPollingWhenReady()) {\n+                String msg = \"Initialization failed, unable to start the Insteon bridge with the port '\"\n+                        + config.getPort() + \"'.\";\n+                logger.error(msg);\n+\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, msg);\n+                return;\n+            }\n+\n+            pollingJob = scheduler.scheduleWithFixedDelay(new Runnable() {\n+                @Override\n+                public void run() {\n+                    insteonBinding.logDeviceStatistics();\n+                }\n+            }, 0, insteonBinding.getDeviceStatisticsInterval(), TimeUnit.SECONDS);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d8407f4d3e56f93dadba66a086ab0d3e70ef5b95"}, "originalPosition": 86}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTEwMTA2NQ==", "bodyText": "There is a lot of logging to error in the code. Logging to error should only be done if it's a fatal bug. For example here it should log to debug as already the status is set. Can you check all loggings and change it to the appropriate level. See also https://www.openhab.org/docs/developer/guidelines.html#f-logging", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r371101065", "createdAt": "2020-01-27T08:04:19Z", "author": {"login": "Hilbrand"}, "path": "bundles/org.openhab.binding.insteon/src/main/java/org/openhab/binding/insteon/internal/handler/InsteonNetworkHandler.java", "diffHunk": "@@ -0,0 +1,124 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.insteon.internal.handler;\n+\n+import java.util.List;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseBridgeHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.insteon.internal.InsteonBinding;\n+import org.openhab.binding.insteon.internal.config.InsteonNetworkConfiguration;\n+import org.openhab.binding.insteon.internal.discovery.InsteonDeviceDiscoveryService;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link InsteonNetworkHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Rob Nielsen - Initial contribution\n+ */\n+@NonNullByDefault\n+public class InsteonNetworkHandler extends BaseBridgeHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(InsteonNetworkHandler.class);\n+\n+    private @Nullable InsteonNetworkConfiguration config;\n+    private @Nullable InsteonBinding insteonBinding;\n+    private @Nullable InsteonDeviceDiscoveryService insteonDeviceDiscoveryService;\n+    private @Nullable ScheduledFuture<?> pollingJob = null;\n+\n+    public static ClassLoader classLoader = Thread.currentThread().getContextClassLoader();\n+\n+    public InsteonNetworkHandler(Bridge bridge) {\n+        super(bridge);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.info(\"Starting Insteon bridge\");\n+        config = getConfigAs(InsteonNetworkConfiguration.class);\n+\n+        scheduler.execute(() -> {\n+            insteonBinding = new InsteonBinding(this, config.getPort(), config.getDeviceStatisticsInterval(),\n+                    config.getDeviceDeadCount(), config.getDevicePollInterval(), config.getAdditionalDevices(),\n+                    config.getAdditionalFeatures(), config.getModemDbRetryTimeout());\n+\n+            updateStatus(ThingStatus.ONLINE);\n+\n+            if (!insteonBinding.startPollingWhenReady()) {\n+                String msg = \"Initialization failed, unable to start the Insteon bridge with the port '\"\n+                        + config.getPort() + \"'.\";\n+                logger.error(msg);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d8407f4d3e56f93dadba66a086ab0d3e70ef5b95"}, "originalPosition": 75}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTEwMTUzNg==", "bodyText": "This sleep is really bad. The scheduled threads of all bindings use a shared thread pool. If you sleep for 5 seconds it means you block a thread to be used by other bindings for 5 seconds. You should reschedule here to start after 5 seconds.", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r371101536", "createdAt": "2020-01-27T08:05:53Z", "author": {"login": "Hilbrand"}, "path": "bundles/org.openhab.binding.insteon/src/main/java/org/openhab/binding/insteon/internal/InsteonBinding.java", "diffHunk": "@@ -0,0 +1,517 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.insteon.internal;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map.Entry;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.insteon.internal.config.InsteonChannelConfiguration;\n+import org.openhab.binding.insteon.internal.device.DeviceFeature;\n+import org.openhab.binding.insteon.internal.device.DeviceFeatureListener;\n+import org.openhab.binding.insteon.internal.device.DeviceType;\n+import org.openhab.binding.insteon.internal.device.DeviceTypeLoader;\n+import org.openhab.binding.insteon.internal.device.InsteonAddress;\n+import org.openhab.binding.insteon.internal.device.InsteonDevice;\n+import org.openhab.binding.insteon.internal.device.InsteonDevice.DeviceStatus;\n+import org.openhab.binding.insteon.internal.device.RequestQueueManager;\n+import org.openhab.binding.insteon.internal.driver.Driver;\n+import org.openhab.binding.insteon.internal.driver.DriverListener;\n+import org.openhab.binding.insteon.internal.driver.ModemDBEntry;\n+import org.openhab.binding.insteon.internal.driver.Poller;\n+import org.openhab.binding.insteon.internal.handler.InsteonNetworkHandler;\n+import org.openhab.binding.insteon.internal.message.FieldException;\n+import org.openhab.binding.insteon.internal.message.Msg;\n+import org.openhab.binding.insteon.internal.message.MsgListener;\n+import org.openhab.binding.insteon.internal.utils.Utils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * A majority of the code in this file is from the OpenHAB 1 binding\n+ * org.openhab.binding.insteonplm.InsteonPLMActiveBinding. Including the comments below.\n+ *\n+ * -----------------------------------------------------------------------------------------------\n+ *\n+ * This class represents the actual implementation of the binding, and controls the high level flow\n+ * of messages to and from the InsteonModem.\n+ *\n+ * Writing this binding has been an odyssey through the quirks of the Insteon protocol\n+ * and Insteon devices. A substantial redesign was necessary at some point along the way.\n+ * Here are some of the hard learned lessons that should be considered by anyone who wants\n+ * to re-architect the binding:\n+ *\n+ * 1) The entries of the link database of the modem are not reliable. The category/subcategory entries in\n+ * particular have junk data. Forget about using the modem database to generate a list of devices.\n+ * The database should only be used to verify that a device has been linked.\n+ *\n+ * 2) Querying devices for their product information does not work either. First of all, battery operated devices\n+ * (and there are a lot of those) have their radio switched off, and may generally not respond to product\n+ * queries. Even main stream hardwired devices sold presently (like the 2477s switch and the 2477d dimmer)\n+ * don't even have a product ID. Although supposedly part of the Insteon protocol, we have yet to\n+ * encounter a device that would cough up a product id when queried, even among very recent devices. They\n+ * simply return zeros as product id. Lesson: forget about querying devices to generate a device list.\n+ *\n+ * 3) Polling is a thorny issue: too much traffic on the network, and messages will be dropped left and right,\n+ * and not just the poll related ones, but others as well. In particular sending back-to-back messages\n+ * seemed to result in the second message simply never getting sent, without flow control back pressure\n+ * (NACK) from the modem. For now the work-around is to space out the messages upon sending, and\n+ * in general poll as infrequently as acceptable.\n+ *\n+ * 4) Instantiating and tracking devices when reported by the modem (either from the database, or when\n+ * messages are received) leads to complicated state management because there is no guarantee at what\n+ * point (if at all) the binding configuration will be available. It gets even more difficult when\n+ * items are created, destroyed, and modified while the binding runs.\n+ *\n+ * For the above reasons, devices are only instantiated when they are referenced by binding information.\n+ * As nice as it would be to discover devices and their properties dynamically, we have abandoned that\n+ * path because it had led to a complicated and fragile system which due to the technical limitations\n+ * above was inherently squirrely.\n+ *\n+ *\n+ * @author Bernd Pfrommer - Initial contribution\n+ * @author Daniel Pfrommer - OpenHAB 1 insteonplm binding\n+ * @author Rob Nielsen - Port to OpenHAB 2 insteon binding\n+ */\n+@NonNullByDefault\n+public class InsteonBinding {\n+    private final Logger logger = LoggerFactory.getLogger(InsteonBinding.class);\n+\n+    private Driver m_driver = new Driver();\n+    private ConcurrentHashMap<InsteonAddress, InsteonDevice> m_devices = new ConcurrentHashMap<InsteonAddress, InsteonDevice>();\n+    private ConcurrentHashMap<String, org.openhab.binding.insteon.internal.config.InsteonChannelConfiguration> m_bindingConfigs = new ConcurrentHashMap<String, org.openhab.binding.insteon.internal.config.InsteonChannelConfiguration>();\n+    private PortListener m_portListener = new PortListener();\n+    private int m_devicePollInterval = 300000; // in milliseconds\n+    private int m_deadDeviceTimeout = -1;\n+    private int m_deviceStatisticsInterval = 600; // in seconds\n+    private int m_messagesReceived = 0;\n+    private boolean m_isActive = false; // state of binding\n+    private int m_x10HouseUnit = -1;\n+    private InsteonNetworkHandler m_handler;\n+\n+    public InsteonBinding(InsteonNetworkHandler handler, String port, @Nullable Integer deviceStatisticsInterval,\n+            @Nullable Integer deviceDeadCount, @Nullable Integer devicePollInterval, @Nullable String additionalDevices,\n+            @Nullable String additionalFeatures, @Nullable Integer modemDbRetryTimeout) {\n+\n+        this.m_handler = handler;\n+\n+        if (deviceStatisticsInterval != null) {\n+            m_deviceStatisticsInterval = deviceStatisticsInterval;\n+            logger.info(\"device statistics interval set to {} seconds\", m_deviceStatisticsInterval);\n+        }\n+\n+        int deadDeviceCount = 10;\n+        if (deviceDeadCount != null) {\n+            deadDeviceCount = deviceDeadCount;\n+            logger.info(\"device dead co- Initial contributionunt set to {}\", deadDeviceCount);\n+        }\n+\n+        if (devicePollInterval != null) {\n+            m_devicePollInterval = devicePollInterval;\n+            logger.info(\"device poll interval set to {} milliseconds\", m_devicePollInterval);\n+        }\n+\n+        if (additionalDevices != null) {\n+            try {\n+                DeviceTypeLoader.s_instance().loadDeviceTypesXML(additionalDevices);\n+                logger.info(\"read additional device definitions from {}\", additionalDevices);\n+            } catch (Exception e) {\n+                logger.error(\"error reading additional devices from {}\", additionalDevices, e);\n+            }\n+        }\n+\n+        if (additionalFeatures != null) {\n+            logger.info(\"reading additional feature templates from {}\", additionalFeatures);\n+            DeviceFeature.s_readFeatureTemplates(additionalFeatures);\n+        }\n+\n+        if (modemDbRetryTimeout != null) {\n+            int timeout = modemDbRetryTimeout;\n+            m_driver.setModemDBRetryTimeout(timeout * 1000);\n+            logger.info(\"setting modem db retry timeout to {} seconds\", timeout);\n+        }\n+\n+        m_deadDeviceTimeout = m_devicePollInterval * deadDeviceCount;\n+        logger.info(\"dead device timeout set to {} seconds\", m_deadDeviceTimeout / 1000);\n+\n+        logger.info(\"port = '{}'\", port);\n+        m_driver.addPort(\"port\", port);\n+        m_driver.addMsgListener(m_portListener, port);\n+\n+        logger.debug(\"setting driver listener\");\n+        m_driver.setDriverListener(m_portListener);\n+    }\n+\n+    public boolean startPollingWhenReady() {\n+        // hold off on starting to poll until devices have been added From the Things file\n+        int settleTime = 5000;\n+        for (int i = -1; i != m_devices.size(); i = m_devices.size()) {\n+            try {\n+                logger.debug(\"sleeping {} milliseconds...\", settleTime);\n+                Thread.sleep(settleTime);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d8407f4d3e56f93dadba66a086ab0d3e70ef5b95"}, "originalPosition": 171}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTEwMjA5Ng==", "bodyText": "Put the unit in the name of the variable to make it clear in the rest of the cod how it should be handled.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private int m_devicePollInterval = 300000; // in milliseconds\n          \n          \n            \n                private int devicePollIntervalMilliseconds = 300000; // in milliseconds", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r371102096", "createdAt": "2020-01-27T08:07:40Z", "author": {"login": "Hilbrand"}, "path": "bundles/org.openhab.binding.insteon/src/main/java/org/openhab/binding/insteon/internal/InsteonBinding.java", "diffHunk": "@@ -0,0 +1,517 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.insteon.internal;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map.Entry;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.insteon.internal.config.InsteonChannelConfiguration;\n+import org.openhab.binding.insteon.internal.device.DeviceFeature;\n+import org.openhab.binding.insteon.internal.device.DeviceFeatureListener;\n+import org.openhab.binding.insteon.internal.device.DeviceType;\n+import org.openhab.binding.insteon.internal.device.DeviceTypeLoader;\n+import org.openhab.binding.insteon.internal.device.InsteonAddress;\n+import org.openhab.binding.insteon.internal.device.InsteonDevice;\n+import org.openhab.binding.insteon.internal.device.InsteonDevice.DeviceStatus;\n+import org.openhab.binding.insteon.internal.device.RequestQueueManager;\n+import org.openhab.binding.insteon.internal.driver.Driver;\n+import org.openhab.binding.insteon.internal.driver.DriverListener;\n+import org.openhab.binding.insteon.internal.driver.ModemDBEntry;\n+import org.openhab.binding.insteon.internal.driver.Poller;\n+import org.openhab.binding.insteon.internal.handler.InsteonNetworkHandler;\n+import org.openhab.binding.insteon.internal.message.FieldException;\n+import org.openhab.binding.insteon.internal.message.Msg;\n+import org.openhab.binding.insteon.internal.message.MsgListener;\n+import org.openhab.binding.insteon.internal.utils.Utils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * A majority of the code in this file is from the OpenHAB 1 binding\n+ * org.openhab.binding.insteonplm.InsteonPLMActiveBinding. Including the comments below.\n+ *\n+ * -----------------------------------------------------------------------------------------------\n+ *\n+ * This class represents the actual implementation of the binding, and controls the high level flow\n+ * of messages to and from the InsteonModem.\n+ *\n+ * Writing this binding has been an odyssey through the quirks of the Insteon protocol\n+ * and Insteon devices. A substantial redesign was necessary at some point along the way.\n+ * Here are some of the hard learned lessons that should be considered by anyone who wants\n+ * to re-architect the binding:\n+ *\n+ * 1) The entries of the link database of the modem are not reliable. The category/subcategory entries in\n+ * particular have junk data. Forget about using the modem database to generate a list of devices.\n+ * The database should only be used to verify that a device has been linked.\n+ *\n+ * 2) Querying devices for their product information does not work either. First of all, battery operated devices\n+ * (and there are a lot of those) have their radio switched off, and may generally not respond to product\n+ * queries. Even main stream hardwired devices sold presently (like the 2477s switch and the 2477d dimmer)\n+ * don't even have a product ID. Although supposedly part of the Insteon protocol, we have yet to\n+ * encounter a device that would cough up a product id when queried, even among very recent devices. They\n+ * simply return zeros as product id. Lesson: forget about querying devices to generate a device list.\n+ *\n+ * 3) Polling is a thorny issue: too much traffic on the network, and messages will be dropped left and right,\n+ * and not just the poll related ones, but others as well. In particular sending back-to-back messages\n+ * seemed to result in the second message simply never getting sent, without flow control back pressure\n+ * (NACK) from the modem. For now the work-around is to space out the messages upon sending, and\n+ * in general poll as infrequently as acceptable.\n+ *\n+ * 4) Instantiating and tracking devices when reported by the modem (either from the database, or when\n+ * messages are received) leads to complicated state management because there is no guarantee at what\n+ * point (if at all) the binding configuration will be available. It gets even more difficult when\n+ * items are created, destroyed, and modified while the binding runs.\n+ *\n+ * For the above reasons, devices are only instantiated when they are referenced by binding information.\n+ * As nice as it would be to discover devices and their properties dynamically, we have abandoned that\n+ * path because it had led to a complicated and fragile system which due to the technical limitations\n+ * above was inherently squirrely.\n+ *\n+ *\n+ * @author Bernd Pfrommer - Initial contribution\n+ * @author Daniel Pfrommer - OpenHAB 1 insteonplm binding\n+ * @author Rob Nielsen - Port to OpenHAB 2 insteon binding\n+ */\n+@NonNullByDefault\n+public class InsteonBinding {\n+    private final Logger logger = LoggerFactory.getLogger(InsteonBinding.class);\n+\n+    private Driver m_driver = new Driver();\n+    private ConcurrentHashMap<InsteonAddress, InsteonDevice> m_devices = new ConcurrentHashMap<InsteonAddress, InsteonDevice>();\n+    private ConcurrentHashMap<String, org.openhab.binding.insteon.internal.config.InsteonChannelConfiguration> m_bindingConfigs = new ConcurrentHashMap<String, org.openhab.binding.insteon.internal.config.InsteonChannelConfiguration>();\n+    private PortListener m_portListener = new PortListener();\n+    private int m_devicePollInterval = 300000; // in milliseconds", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d8407f4d3e56f93dadba66a086ab0d3e70ef5b95"}, "originalPosition": 104}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTEwMjgzMA==", "bodyText": "Any reason not to use the openHAB httpclient component? Or was this in the oh1 version of the binding? It would be great if you could use the openHAB httpclient instead.", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r371102830", "createdAt": "2020-01-27T08:09:55Z", "author": {"login": "Hilbrand"}, "path": "bundles/org.openhab.binding.insteon/pom.xml", "diffHunk": "@@ -0,0 +1,24 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<project xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns=\"http://maven.apache.org/POM/4.0.0\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n+\n+  <modelVersion>4.0.0</modelVersion>\n+\n+  <parent>\n+    <groupId>org.openhab.addons.bundles</groupId>\n+    <artifactId>org.openhab.addons.reactor.bundles</artifactId>\n+    <version>2.5.2-SNAPSHOT</version>\n+  </parent>\n+\n+  <artifactId>org.openhab.binding.insteon</artifactId>\n+\n+  <name>openHAB Add-ons :: Bundles :: Insteon Binding</name>\n+\n+  <dependencies>\n+    <dependency>\n+      <groupId>org.apache.httpcomponents</groupId>\n+      <artifactId>httpclient</artifactId>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d8407f4d3e56f93dadba66a086ab0d3e70ef5b95"}, "originalPosition": 19}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTEwMzk3NA==", "bodyText": "If the timeout is used in seconds it might as well be set in seconds instead of milliseconds?", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r371103974", "createdAt": "2020-01-27T08:13:33Z", "author": {"login": "Hilbrand"}, "path": "bundles/org.openhab.binding.insteon/src/main/java/org/openhab/binding/insteon/internal/InsteonBinding.java", "diffHunk": "@@ -0,0 +1,517 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.insteon.internal;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map.Entry;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.insteon.internal.config.InsteonChannelConfiguration;\n+import org.openhab.binding.insteon.internal.device.DeviceFeature;\n+import org.openhab.binding.insteon.internal.device.DeviceFeatureListener;\n+import org.openhab.binding.insteon.internal.device.DeviceType;\n+import org.openhab.binding.insteon.internal.device.DeviceTypeLoader;\n+import org.openhab.binding.insteon.internal.device.InsteonAddress;\n+import org.openhab.binding.insteon.internal.device.InsteonDevice;\n+import org.openhab.binding.insteon.internal.device.InsteonDevice.DeviceStatus;\n+import org.openhab.binding.insteon.internal.device.RequestQueueManager;\n+import org.openhab.binding.insteon.internal.driver.Driver;\n+import org.openhab.binding.insteon.internal.driver.DriverListener;\n+import org.openhab.binding.insteon.internal.driver.ModemDBEntry;\n+import org.openhab.binding.insteon.internal.driver.Poller;\n+import org.openhab.binding.insteon.internal.handler.InsteonNetworkHandler;\n+import org.openhab.binding.insteon.internal.message.FieldException;\n+import org.openhab.binding.insteon.internal.message.Msg;\n+import org.openhab.binding.insteon.internal.message.MsgListener;\n+import org.openhab.binding.insteon.internal.utils.Utils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * A majority of the code in this file is from the OpenHAB 1 binding\n+ * org.openhab.binding.insteonplm.InsteonPLMActiveBinding. Including the comments below.\n+ *\n+ * -----------------------------------------------------------------------------------------------\n+ *\n+ * This class represents the actual implementation of the binding, and controls the high level flow\n+ * of messages to and from the InsteonModem.\n+ *\n+ * Writing this binding has been an odyssey through the quirks of the Insteon protocol\n+ * and Insteon devices. A substantial redesign was necessary at some point along the way.\n+ * Here are some of the hard learned lessons that should be considered by anyone who wants\n+ * to re-architect the binding:\n+ *\n+ * 1) The entries of the link database of the modem are not reliable. The category/subcategory entries in\n+ * particular have junk data. Forget about using the modem database to generate a list of devices.\n+ * The database should only be used to verify that a device has been linked.\n+ *\n+ * 2) Querying devices for their product information does not work either. First of all, battery operated devices\n+ * (and there are a lot of those) have their radio switched off, and may generally not respond to product\n+ * queries. Even main stream hardwired devices sold presently (like the 2477s switch and the 2477d dimmer)\n+ * don't even have a product ID. Although supposedly part of the Insteon protocol, we have yet to\n+ * encounter a device that would cough up a product id when queried, even among very recent devices. They\n+ * simply return zeros as product id. Lesson: forget about querying devices to generate a device list.\n+ *\n+ * 3) Polling is a thorny issue: too much traffic on the network, and messages will be dropped left and right,\n+ * and not just the poll related ones, but others as well. In particular sending back-to-back messages\n+ * seemed to result in the second message simply never getting sent, without flow control back pressure\n+ * (NACK) from the modem. For now the work-around is to space out the messages upon sending, and\n+ * in general poll as infrequently as acceptable.\n+ *\n+ * 4) Instantiating and tracking devices when reported by the modem (either from the database, or when\n+ * messages are received) leads to complicated state management because there is no guarantee at what\n+ * point (if at all) the binding configuration will be available. It gets even more difficult when\n+ * items are created, destroyed, and modified while the binding runs.\n+ *\n+ * For the above reasons, devices are only instantiated when they are referenced by binding information.\n+ * As nice as it would be to discover devices and their properties dynamically, we have abandoned that\n+ * path because it had led to a complicated and fragile system which due to the technical limitations\n+ * above was inherently squirrely.\n+ *\n+ *\n+ * @author Bernd Pfrommer - Initial contribution\n+ * @author Daniel Pfrommer - OpenHAB 1 insteonplm binding\n+ * @author Rob Nielsen - Port to OpenHAB 2 insteon binding\n+ */\n+@NonNullByDefault\n+public class InsteonBinding {\n+    private final Logger logger = LoggerFactory.getLogger(InsteonBinding.class);\n+\n+    private Driver m_driver = new Driver();\n+    private ConcurrentHashMap<InsteonAddress, InsteonDevice> m_devices = new ConcurrentHashMap<InsteonAddress, InsteonDevice>();\n+    private ConcurrentHashMap<String, org.openhab.binding.insteon.internal.config.InsteonChannelConfiguration> m_bindingConfigs = new ConcurrentHashMap<String, org.openhab.binding.insteon.internal.config.InsteonChannelConfiguration>();\n+    private PortListener m_portListener = new PortListener();\n+    private int m_devicePollInterval = 300000; // in milliseconds\n+    private int m_deadDeviceTimeout = -1;\n+    private int m_deviceStatisticsInterval = 600; // in seconds\n+    private int m_messagesReceived = 0;\n+    private boolean m_isActive = false; // state of binding\n+    private int m_x10HouseUnit = -1;\n+    private InsteonNetworkHandler m_handler;\n+\n+    public InsteonBinding(InsteonNetworkHandler handler, String port, @Nullable Integer deviceStatisticsInterval,\n+            @Nullable Integer deviceDeadCount, @Nullable Integer devicePollInterval, @Nullable String additionalDevices,\n+            @Nullable String additionalFeatures, @Nullable Integer modemDbRetryTimeout) {\n+\n+        this.m_handler = handler;\n+\n+        if (deviceStatisticsInterval != null) {\n+            m_deviceStatisticsInterval = deviceStatisticsInterval;\n+            logger.info(\"device statistics interval set to {} seconds\", m_deviceStatisticsInterval);\n+        }\n+\n+        int deadDeviceCount = 10;\n+        if (deviceDeadCount != null) {\n+            deadDeviceCount = deviceDeadCount;\n+            logger.info(\"device dead co- Initial contributionunt set to {}\", deadDeviceCount);\n+        }\n+\n+        if (devicePollInterval != null) {\n+            m_devicePollInterval = devicePollInterval;\n+            logger.info(\"device poll interval set to {} milliseconds\", m_devicePollInterval);\n+        }\n+\n+        if (additionalDevices != null) {\n+            try {\n+                DeviceTypeLoader.s_instance().loadDeviceTypesXML(additionalDevices);\n+                logger.info(\"read additional device definitions from {}\", additionalDevices);\n+            } catch (Exception e) {\n+                logger.error(\"error reading additional devices from {}\", additionalDevices, e);\n+            }\n+        }\n+\n+        if (additionalFeatures != null) {\n+            logger.info(\"reading additional feature templates from {}\", additionalFeatures);\n+            DeviceFeature.s_readFeatureTemplates(additionalFeatures);\n+        }\n+\n+        if (modemDbRetryTimeout != null) {\n+            int timeout = modemDbRetryTimeout;\n+            m_driver.setModemDBRetryTimeout(timeout * 1000);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d8407f4d3e56f93dadba66a086ab0d3e70ef5b95"}, "originalPosition": 150}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTEwNDE3Mg==", "bodyText": "A general comment. A lot of fields use the convention <character>_. This is not very common.", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r371104172", "createdAt": "2020-01-27T08:14:14Z", "author": {"login": "Hilbrand"}, "path": "bundles/org.openhab.binding.insteon/src/main/java/org/openhab/binding/insteon/internal/InsteonBinding.java", "diffHunk": "@@ -0,0 +1,517 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.insteon.internal;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map.Entry;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.insteon.internal.config.InsteonChannelConfiguration;\n+import org.openhab.binding.insteon.internal.device.DeviceFeature;\n+import org.openhab.binding.insteon.internal.device.DeviceFeatureListener;\n+import org.openhab.binding.insteon.internal.device.DeviceType;\n+import org.openhab.binding.insteon.internal.device.DeviceTypeLoader;\n+import org.openhab.binding.insteon.internal.device.InsteonAddress;\n+import org.openhab.binding.insteon.internal.device.InsteonDevice;\n+import org.openhab.binding.insteon.internal.device.InsteonDevice.DeviceStatus;\n+import org.openhab.binding.insteon.internal.device.RequestQueueManager;\n+import org.openhab.binding.insteon.internal.driver.Driver;\n+import org.openhab.binding.insteon.internal.driver.DriverListener;\n+import org.openhab.binding.insteon.internal.driver.ModemDBEntry;\n+import org.openhab.binding.insteon.internal.driver.Poller;\n+import org.openhab.binding.insteon.internal.handler.InsteonNetworkHandler;\n+import org.openhab.binding.insteon.internal.message.FieldException;\n+import org.openhab.binding.insteon.internal.message.Msg;\n+import org.openhab.binding.insteon.internal.message.MsgListener;\n+import org.openhab.binding.insteon.internal.utils.Utils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * A majority of the code in this file is from the OpenHAB 1 binding\n+ * org.openhab.binding.insteonplm.InsteonPLMActiveBinding. Including the comments below.\n+ *\n+ * -----------------------------------------------------------------------------------------------\n+ *\n+ * This class represents the actual implementation of the binding, and controls the high level flow\n+ * of messages to and from the InsteonModem.\n+ *\n+ * Writing this binding has been an odyssey through the quirks of the Insteon protocol\n+ * and Insteon devices. A substantial redesign was necessary at some point along the way.\n+ * Here are some of the hard learned lessons that should be considered by anyone who wants\n+ * to re-architect the binding:\n+ *\n+ * 1) The entries of the link database of the modem are not reliable. The category/subcategory entries in\n+ * particular have junk data. Forget about using the modem database to generate a list of devices.\n+ * The database should only be used to verify that a device has been linked.\n+ *\n+ * 2) Querying devices for their product information does not work either. First of all, battery operated devices\n+ * (and there are a lot of those) have their radio switched off, and may generally not respond to product\n+ * queries. Even main stream hardwired devices sold presently (like the 2477s switch and the 2477d dimmer)\n+ * don't even have a product ID. Although supposedly part of the Insteon protocol, we have yet to\n+ * encounter a device that would cough up a product id when queried, even among very recent devices. They\n+ * simply return zeros as product id. Lesson: forget about querying devices to generate a device list.\n+ *\n+ * 3) Polling is a thorny issue: too much traffic on the network, and messages will be dropped left and right,\n+ * and not just the poll related ones, but others as well. In particular sending back-to-back messages\n+ * seemed to result in the second message simply never getting sent, without flow control back pressure\n+ * (NACK) from the modem. For now the work-around is to space out the messages upon sending, and\n+ * in general poll as infrequently as acceptable.\n+ *\n+ * 4) Instantiating and tracking devices when reported by the modem (either from the database, or when\n+ * messages are received) leads to complicated state management because there is no guarantee at what\n+ * point (if at all) the binding configuration will be available. It gets even more difficult when\n+ * items are created, destroyed, and modified while the binding runs.\n+ *\n+ * For the above reasons, devices are only instantiated when they are referenced by binding information.\n+ * As nice as it would be to discover devices and their properties dynamically, we have abandoned that\n+ * path because it had led to a complicated and fragile system which due to the technical limitations\n+ * above was inherently squirrely.\n+ *\n+ *\n+ * @author Bernd Pfrommer - Initial contribution\n+ * @author Daniel Pfrommer - OpenHAB 1 insteonplm binding\n+ * @author Rob Nielsen - Port to OpenHAB 2 insteon binding\n+ */\n+@NonNullByDefault\n+public class InsteonBinding {\n+    private final Logger logger = LoggerFactory.getLogger(InsteonBinding.class);\n+\n+    private Driver m_driver = new Driver();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d8407f4d3e56f93dadba66a086ab0d3e70ef5b95"}, "originalPosition": 100}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTEwNDQ2Ng==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private ConcurrentHashMap<String, org.openhab.binding.insteon.internal.config.InsteonChannelConfiguration> m_bindingConfigs = new ConcurrentHashMap<String, org.openhab.binding.insteon.internal.config.InsteonChannelConfiguration>();\n          \n          \n            \n                private ConcurrentHashMap<String, InsteonChannelConfiguration> m_bindingConfigs\n          \n          \n            \n                     = new ConcurrentHashMap<>();", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r371104466", "createdAt": "2020-01-27T08:15:11Z", "author": {"login": "Hilbrand"}, "path": "bundles/org.openhab.binding.insteon/src/main/java/org/openhab/binding/insteon/internal/InsteonBinding.java", "diffHunk": "@@ -0,0 +1,517 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.insteon.internal;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map.Entry;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.insteon.internal.config.InsteonChannelConfiguration;\n+import org.openhab.binding.insteon.internal.device.DeviceFeature;\n+import org.openhab.binding.insteon.internal.device.DeviceFeatureListener;\n+import org.openhab.binding.insteon.internal.device.DeviceType;\n+import org.openhab.binding.insteon.internal.device.DeviceTypeLoader;\n+import org.openhab.binding.insteon.internal.device.InsteonAddress;\n+import org.openhab.binding.insteon.internal.device.InsteonDevice;\n+import org.openhab.binding.insteon.internal.device.InsteonDevice.DeviceStatus;\n+import org.openhab.binding.insteon.internal.device.RequestQueueManager;\n+import org.openhab.binding.insteon.internal.driver.Driver;\n+import org.openhab.binding.insteon.internal.driver.DriverListener;\n+import org.openhab.binding.insteon.internal.driver.ModemDBEntry;\n+import org.openhab.binding.insteon.internal.driver.Poller;\n+import org.openhab.binding.insteon.internal.handler.InsteonNetworkHandler;\n+import org.openhab.binding.insteon.internal.message.FieldException;\n+import org.openhab.binding.insteon.internal.message.Msg;\n+import org.openhab.binding.insteon.internal.message.MsgListener;\n+import org.openhab.binding.insteon.internal.utils.Utils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * A majority of the code in this file is from the OpenHAB 1 binding\n+ * org.openhab.binding.insteonplm.InsteonPLMActiveBinding. Including the comments below.\n+ *\n+ * -----------------------------------------------------------------------------------------------\n+ *\n+ * This class represents the actual implementation of the binding, and controls the high level flow\n+ * of messages to and from the InsteonModem.\n+ *\n+ * Writing this binding has been an odyssey through the quirks of the Insteon protocol\n+ * and Insteon devices. A substantial redesign was necessary at some point along the way.\n+ * Here are some of the hard learned lessons that should be considered by anyone who wants\n+ * to re-architect the binding:\n+ *\n+ * 1) The entries of the link database of the modem are not reliable. The category/subcategory entries in\n+ * particular have junk data. Forget about using the modem database to generate a list of devices.\n+ * The database should only be used to verify that a device has been linked.\n+ *\n+ * 2) Querying devices for their product information does not work either. First of all, battery operated devices\n+ * (and there are a lot of those) have their radio switched off, and may generally not respond to product\n+ * queries. Even main stream hardwired devices sold presently (like the 2477s switch and the 2477d dimmer)\n+ * don't even have a product ID. Although supposedly part of the Insteon protocol, we have yet to\n+ * encounter a device that would cough up a product id when queried, even among very recent devices. They\n+ * simply return zeros as product id. Lesson: forget about querying devices to generate a device list.\n+ *\n+ * 3) Polling is a thorny issue: too much traffic on the network, and messages will be dropped left and right,\n+ * and not just the poll related ones, but others as well. In particular sending back-to-back messages\n+ * seemed to result in the second message simply never getting sent, without flow control back pressure\n+ * (NACK) from the modem. For now the work-around is to space out the messages upon sending, and\n+ * in general poll as infrequently as acceptable.\n+ *\n+ * 4) Instantiating and tracking devices when reported by the modem (either from the database, or when\n+ * messages are received) leads to complicated state management because there is no guarantee at what\n+ * point (if at all) the binding configuration will be available. It gets even more difficult when\n+ * items are created, destroyed, and modified while the binding runs.\n+ *\n+ * For the above reasons, devices are only instantiated when they are referenced by binding information.\n+ * As nice as it would be to discover devices and their properties dynamically, we have abandoned that\n+ * path because it had led to a complicated and fragile system which due to the technical limitations\n+ * above was inherently squirrely.\n+ *\n+ *\n+ * @author Bernd Pfrommer - Initial contribution\n+ * @author Daniel Pfrommer - OpenHAB 1 insteonplm binding\n+ * @author Rob Nielsen - Port to OpenHAB 2 insteon binding\n+ */\n+@NonNullByDefault\n+public class InsteonBinding {\n+    private final Logger logger = LoggerFactory.getLogger(InsteonBinding.class);\n+\n+    private Driver m_driver = new Driver();\n+    private ConcurrentHashMap<InsteonAddress, InsteonDevice> m_devices = new ConcurrentHashMap<InsteonAddress, InsteonDevice>();\n+    private ConcurrentHashMap<String, org.openhab.binding.insteon.internal.config.InsteonChannelConfiguration> m_bindingConfigs = new ConcurrentHashMap<String, org.openhab.binding.insteon.internal.config.InsteonChannelConfiguration>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d8407f4d3e56f93dadba66a086ab0d3e70ef5b95"}, "originalPosition": 102}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTEwNDgyNw==", "bodyText": "May use seconds here?", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r371104827", "createdAt": "2020-01-27T08:16:10Z", "author": {"login": "Hilbrand"}, "path": "bundles/org.openhab.binding.insteon/src/main/resources/ESH-INF/thing/thing-types.xml", "diffHunk": "@@ -0,0 +1,444 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"insteon\"\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\n+\t<bridge-type id=\"network\">\n+\t\t<label>Insteon Network</label>\n+\t\t<description>An Insteon PLM or hub that is used to communicate with the Insteon devices.</description>\n+\n+\t\t<config-description>\n+\t\t\t<parameter name=\"port\" type=\"text\" required=\"true\">\n+\t\t\t\t<label>Port</label>\n+\t\t\t\t<description>Configuration information that is used to connect to PLM or hub.</description>\n+\t\t\t</parameter>\n+\n+\t\t\t<parameter name=\"devicePollInterval\" type=\"integer\" min=\"5000\" max=\"3600000\">\n+\t\t\t\t<label>Device Poll Interval</label>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d8407f4d3e56f93dadba66a086ab0d3e70ef5b95"}, "originalPosition": 18}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTEwNTQ1MA==", "bodyText": "This is better modeled as a UoM (QuantityType) type channel the there is no need for having a separate channel for Celsius and Fahrenheit.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\t<item-type>Number</item-type>\n          \n          \n            \n            \t\t<item-type>Number:Temperature</item-type>", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r371105450", "createdAt": "2020-01-27T08:18:17Z", "author": {"login": "Hilbrand"}, "path": "bundles/org.openhab.binding.insteon/src/main/resources/ESH-INF/thing/thing-types.xml", "diffHunk": "@@ -0,0 +1,444 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"insteon\"\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\n+\t<bridge-type id=\"network\">\n+\t\t<label>Insteon Network</label>\n+\t\t<description>An Insteon PLM or hub that is used to communicate with the Insteon devices.</description>\n+\n+\t\t<config-description>\n+\t\t\t<parameter name=\"port\" type=\"text\" required=\"true\">\n+\t\t\t\t<label>Port</label>\n+\t\t\t\t<description>Configuration information that is used to connect to PLM or hub.</description>\n+\t\t\t</parameter>\n+\n+\t\t\t<parameter name=\"devicePollInterval\" type=\"integer\" min=\"5000\" max=\"3600000\">\n+\t\t\t\t<label>Device Poll Interval</label>\n+\t\t\t\t<description>Device poll interval in milliseconds.</description>\n+\t\t\t</parameter>\n+\n+\t\t\t<parameter name=\"deviceStatisticsInterval\" type=\"integer\" min=\"60\">\n+\t\t\t\t<label>Device Statistics Interval</label>\n+\t\t\t\t<description>Interval to display the device statistics.</description>\n+\t\t\t</parameter>\n+\n+\t\t\t<parameter name=\"deviceDeadCount\" type=\"integer\" min=\"2\" max=\"100000\">\n+\t\t\t\t<label>Device Dead Count</label>\n+\t\t\t\t<description>Device dead count along with device poll interval is used to calculate dead device timeout.</description>\n+\t\t\t</parameter>\n+\n+\t\t\t<parameter name=\"modemDbRetryTimeout\" type=\"integer\" min=\"5\">\n+\t\t\t\t<label>Modem Database Retry Timeout</label>\n+\t\t\t\t<description>Modem database retry timeout in seconds.</description>\n+\t\t\t</parameter>\n+\n+\t\t\t<parameter name=\"additionalDevices\" type=\"text\">\n+\t\t\t\t<label>Additional Devices</label>\n+\t\t\t\t<description>Optional file with additional device types.</description>\n+\t\t\t</parameter>\n+\n+\t\t\t<parameter name=\"additionalFeatures\" type=\"text\">\n+\t\t\t\t<label>Additional Features</label>\n+\t\t\t\t<description>Optional file with additional feature templates.</description>\n+\t\t\t</parameter>\n+\t\t</config-description>\n+\t</bridge-type>\n+\n+\t<thing-type id=\"device\">\n+\t\t<supported-bridge-type-refs>\n+\t\t\t<bridge-type-ref id=\"network\" />\n+\t\t</supported-bridge-type-refs>\n+\n+\t\t<label>Insteon Device</label>\n+\t\t<description>Insteon devices such as switches, dimmers, keypads, sensors, etc.</description>\n+\n+\t\t<channels>\n+\t\t\t<channel id=\"acDelay\" typeId=\"acDelay\" />\n+\t\t\t<channel id=\"backlightDuration\" typeId=\"backlightDuration\" />\n+\t\t\t<channel id=\"bottomOutlet\" typeId=\"bottomOutlet\" />\n+\t\t\t<channel id=\"buttonA\" typeId=\"buttonA\" />\n+\t\t\t<channel id=\"buttonB\" typeId=\"buttonB\" />\n+\t\t\t<channel id=\"buttonC\" typeId=\"buttonC\" />\n+\t\t\t<channel id=\"buttonD\" typeId=\"buttonD\" />\n+\t\t\t<channel id=\"buttonE\" typeId=\"buttonE\" />\n+\t\t\t<channel id=\"buttonF\" typeId=\"buttonF\" />\n+\t\t\t<channel id=\"buttonG\" typeId=\"buttonG\" />\n+\t\t\t<channel id=\"buttonH\" typeId=\"buttonH\" />\n+\t\t\t<channel id=\"contact\" typeId=\"contact\" />\n+\t\t\t<channel id=\"coolSetPoint\" typeId=\"coolSetPoint\" />\n+\t\t\t<channel id=\"data\" typeId=\"data\" />\n+\t\t\t<channel id=\"dimmer\" typeId=\"dimmer\" />\n+\t\t\t<channel id=\"fan\" typeId=\"fan\" />\n+\t\t\t<channel id=\"fanMode\" typeId=\"fanMode\" />\n+\t\t\t<channel id=\"fastOnOff\" typeId=\"fastOnOff\" />\n+\t\t\t<channel id=\"fastOnOffButtonA\" typeId=\"fastOnOffButtonA\" />\n+\t\t\t<channel id=\"fastOnOffButtonB\" typeId=\"fastOnOffButtonB\" />\n+\t\t\t<channel id=\"fastOnOffButtonC\" typeId=\"fastOnOffButtonC\" />\n+\t\t\t<channel id=\"fastOnOffButtonD\" typeId=\"fastOnOffButtonD\" />\n+\t\t\t<channel id=\"heatSetPoint\" typeId=\"heatSetPoint\" />\n+\t\t\t<channel id=\"humidity\" typeId=\"humidity\" />\n+\t\t\t<channel id=\"humidityHigh\" typeId=\"humidityHigh\" />\n+\t\t\t<channel id=\"humidityLow\" typeId=\"humidityLow\" />\n+\t\t\t<channel id=\"isCooling\" typeId=\"isCooling\" />\n+\t\t\t<channel id=\"isHeating\" typeId=\"isHeating\" />\n+\t\t\t<channel id=\"keypadButtonA\" typeId=\"keypadButtonA\" />\n+\t\t\t<channel id=\"keypadButtonB\" typeId=\"keypadButtonB\" />\n+\t\t\t<channel id=\"keypadButtonC\" typeId=\"keypadButtonC\" />\n+\t\t\t<channel id=\"keypadButtonD\" typeId=\"keypadButtonD\" />\n+\t\t\t<channel id=\"keypadButtonE\" typeId=\"keypadButtonE\" />\n+\t\t\t<channel id=\"keypadButtonF\" typeId=\"keypadButtonF\" />\n+\t\t\t<channel id=\"keypadButtonG\" typeId=\"keypadButtonG\" />\n+\t\t\t<channel id=\"keypadButtonH\" typeId=\"keypadButtonH\" />\n+\t\t\t<channel id=\"lastHeardFrom\" typeId=\"lastHeardFrom\" />\n+\t\t\t<channel id=\"ledBrightness\" typeId=\"ledBrightness\" />\n+\t\t\t<channel id=\"lightDimmer\" typeId=\"lightDimmer\" />\n+\t\t\t<channel id=\"loadDimmer\" typeId=\"loadDimmer\" />\n+\t\t\t<channel id=\"loadSwitch\" typeId=\"loadSwitch\" />\n+\t\t\t<channel id=\"loadSwitchFastOnOff\" typeId=\"loadSwitchFastOnOff\" />\n+\t\t\t<channel id=\"loadSwitchManualChange\" typeId=\"loadSwitchManualChange\" />\n+\t\t\t<channel id=\"manualChange\" typeId=\"manualChange\" />\n+\t\t\t<channel id=\"manualChangeButtonA\" typeId=\"manualChangeButtonA\" />\n+\t\t\t<channel id=\"manualChangeButtonB\" typeId=\"manualChangeButtonB\" />\n+\t\t\t<channel id=\"manualChangeButtonC\" typeId=\"manualChangeButtonC\" />\n+\t\t\t<channel id=\"manualChangeButtonD\" typeId=\"manualChangeButtonD\" />\n+\t\t\t<channel id=\"meterKWH\" typeId=\"meterKWH\" />\n+\t\t\t<channel id=\"meterReset\" typeId=\"meterReset\" />\n+\t\t\t<channel id=\"meterUpdate\" typeId=\"meterUpdate\" />\n+\t\t\t<channel id=\"meterWatts\" typeId=\"meterWatts\" />\n+\t\t\t<channel id=\"notification\" typeId=\"notification\" />\n+\t\t\t<channel id=\"onLevel\" typeId=\"onLevel\" />\n+\t\t\t<channel id=\"rampDimmer\" typeId=\"rampDimmer\" />\n+\t\t\t<channel id=\"rampRate\" typeId=\"rampRate\" />\n+\t\t\t<channel id=\"stage1Duration\" typeId=\"stage1Duration\" />\n+\t\t\t<channel id=\"switch\" typeId=\"switch\" />\n+\t\t\t<channel id=\"systemMode\" typeId=\"systemMode\" />\n+\t\t\t<channel id=\"tempCelsius\" typeId=\"tempCelsius\" />\n+\t\t\t<channel id=\"tempFahrenheit\" typeId=\"tempFahrenheit\" />\n+\t\t\t<channel id=\"topOutlet\" typeId=\"topOutlet\" />\n+\t\t</channels>\n+\n+\t\t<config-description>\n+\t\t\t<parameter name=\"address\" type=\"text\" required=\"true\">\n+\t\t\t\t<label>Address</label>\n+\t\t\t\t<description>Insteon address of the device.</description>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"productKey\" type=\"text\" required=\"true\">\n+\t\t\t\t<label>Product Key</label>\n+\t\t\t\t<description>Insteon binding product key that is used to identify the model of the device.</description>\n+\t\t\t</parameter>\n+\t\t</config-description>\n+\t</thing-type>\n+\n+\t<channel-type id=\"acDelay\">\n+\t\t<item-type>Number</item-type>\n+\t\t<label>AC Delay</label>\n+\t</channel-type>\n+\n+\t<channel-type id=\"backlightDuration\">\n+\t\t<item-type>Number</item-type>\n+\t\t<label>Back Light Duration</label>\n+\t</channel-type>\n+\n+\t<channel-type id=\"bottomOutlet\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Bottom Outlet</label>\n+\t</channel-type>\n+\n+\t<channel-type id=\"buttonA\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Button A</label>\n+\t</channel-type>\n+\n+\t<channel-type id=\"buttonB\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Button B</label>\n+\t</channel-type>\n+\n+\t<channel-type id=\"buttonC\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Button C</label>\n+\t</channel-type>\n+\n+\t<channel-type id=\"buttonD\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Button D</label>\n+\t</channel-type>\n+\n+\t<channel-type id=\"buttonE\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Button E</label>\n+\t</channel-type>\n+\n+\t<channel-type id=\"buttonF\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Button F</label>\n+\t</channel-type>\n+\n+\t<channel-type id=\"buttonG\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Button G</label>\n+\t</channel-type>\n+\n+\t<channel-type id=\"buttonH\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Button H</label>\n+\t</channel-type>\n+\n+\t<channel-type id=\"contact\">\n+\t\t<item-type>Contact</item-type>\n+\t\t<label>Contact</label>\n+\t</channel-type>\n+\n+\t<channel-type id=\"coolSetPoint\">\n+\t\t<item-type>Number</item-type>\n+\t\t<label>Cool Set Point</label>\n+\t</channel-type>\n+\n+\t<channel-type id=\"data\">\n+\t\t<item-type>Number</item-type>\n+\t\t<label>Data</label>\n+\t</channel-type>\n+\n+\t<channel-type id=\"dimmer\">\n+\t\t<item-type>Dimmer</item-type>\n+\t\t<label>Dimmer</label>\n+\t</channel-type>\n+\n+\t<channel-type id=\"fan\">\n+\t\t<item-type>Number</item-type>\n+\t\t<label>Fan</label>\n+\t</channel-type>\n+\n+\t<channel-type id=\"fanMode\">\n+\t\t<item-type>Number</item-type>\n+\t\t<label>Fan Mode</label>\n+\t</channel-type>\n+\n+\t<channel-type id=\"fastOnOff\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Fast On/Off</label>\n+\t</channel-type>\n+\n+\t<channel-type id=\"fastOnOffButtonA\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Fast On/Off Button A</label>\n+\t</channel-type>\n+\n+\t<channel-type id=\"fastOnOffButtonB\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Fast On/Off Button B</label>\n+\t</channel-type>\n+\n+\t<channel-type id=\"fastOnOffButtonC\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Fast On/Off Button C</label>\n+\t</channel-type>\n+\n+\t<channel-type id=\"fastOnOffButtonD\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Fast On/Off Button D</label>\n+\t</channel-type>\n+\n+\t<channel-type id=\"heatSetPoint\">\n+\t\t<item-type>Number</item-type>\n+\t\t<label>Heat Set Point</label>\n+\t</channel-type>\n+\n+\t<channel-type id=\"humidity\">\n+\t\t<item-type>Number</item-type>\n+\t\t<label>Humidity</label>\n+\t</channel-type>\n+\n+\t<channel-type id=\"humidityHigh\">\n+\t\t<item-type>Number</item-type>\n+\t\t<label>Humidity High</label>\n+\t</channel-type>\n+\n+\t<channel-type id=\"humidityLow\">\n+\t\t<item-type>Number</item-type>\n+\t\t<label>Humidity Low</label>\n+\t</channel-type>\n+\n+\t<channel-type id=\"isCooling\">\n+\t\t<item-type>Number</item-type>\n+\t\t<label>Is Cooling</label>\n+\t</channel-type>\n+\n+\t<channel-type id=\"isHeating\">\n+\t\t<item-type>Number</item-type>\n+\t\t<label>Is Heating</label>\n+\t</channel-type>\n+\n+\t<channel-type id=\"keypadButtonA\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Keypad Button A</label>\n+\t</channel-type>\n+\n+\t<channel-type id=\"keypadButtonB\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Keypad Button B</label>\n+\t</channel-type>\n+\n+\t<channel-type id=\"keypadButtonC\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Keypad Button C</label>\n+\t</channel-type>\n+\n+\t<channel-type id=\"keypadButtonD\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Keypad Button D</label>\n+\t</channel-type>\n+\n+\t<channel-type id=\"keypadButtonE\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Keypad Button E</label>\n+\t</channel-type>\n+\n+\t<channel-type id=\"keypadButtonF\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Keypad Button F</label>\n+\t</channel-type>\n+\n+\t<channel-type id=\"keypadButtonG\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Keypad Button G</label>\n+\t</channel-type>\n+\n+\t<channel-type id=\"keypadButtonH\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Keypad Button H</label>\n+\t</channel-type>\n+\n+\t<channel-type id=\"lastHeardFrom\">\n+\t\t<item-type>DateTime</item-type>\n+\t\t<label>Last Heard From</label>\n+\t</channel-type>\n+\n+\t<channel-type id=\"ledBrightness\">\n+\t\t<item-type>Number</item-type>\n+\t\t<label>LED brightness</label>\n+\t</channel-type>\n+\n+\t<channel-type id=\"lightDimmer\">\n+\t\t<item-type>Dimmer</item-type>\n+\t\t<label>light Dimmer</label>\n+\t</channel-type>\n+\n+\t<channel-type id=\"loadDimmer\">\n+\t\t<item-type>Dimmer</item-type>\n+\t\t<label>Load Dimmer</label>\n+\t</channel-type>\n+\n+\t<channel-type id=\"loadSwitch\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Load Switch</label>\n+\t</channel-type>\n+\n+\t<channel-type id=\"loadSwitchFastOnOff\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Load Switch Fast On/Off</label>\n+\t</channel-type>\n+\n+\t<channel-type id=\"loadSwitchManualChange\">\n+\t\t<item-type>Number</item-type>\n+\t\t<label>Load Switch Manual Change</label>\n+\t</channel-type>\n+\n+\t<channel-type id=\"manualChange\">\n+\t\t<item-type>Number</item-type>\n+\t\t<label>Manual Change</label>\n+\t</channel-type>\n+\n+\t<channel-type id=\"manualChangeButtonA\">\n+\t\t<item-type>Number</item-type>\n+\t\t<label>Manual Change Button A</label>\n+\t</channel-type>\n+\n+\t<channel-type id=\"manualChangeButtonB\">\n+\t\t<item-type>Number</item-type>\n+\t\t<label>Manual Change Button B</label>\n+\t</channel-type>\n+\n+\t<channel-type id=\"manualChangeButtonC\">\n+\t\t<item-type>Number</item-type>\n+\t\t<label>Manual Change Button C</label>\n+\t</channel-type>\n+\n+\t<channel-type id=\"manualChangeButtonD\">\n+\t\t<item-type>Number</item-type>\n+\t\t<label>Manual Change Button D</label>\n+\t</channel-type>\n+\n+\t<channel-type id=\"meterKWH\">\n+\t\t<item-type>Number</item-type>\n+\t\t<label>Meter KWH</label>\n+\t</channel-type>\n+\n+\t<channel-type id=\"meterReset\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Meter Reset</label>\n+\t</channel-type>\n+\n+\t<channel-type id=\"meterUpdate\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Meter Update</label>\n+\t</channel-type>\n+\n+\t<channel-type id=\"meterWatts\">\n+\t\t<item-type>Number</item-type>\n+\t\t<label>Meter Watts</label>\n+\t</channel-type>\n+\n+\t<channel-type id=\"notification\">\n+\t\t<item-type>Number</item-type>\n+\t\t<label>Notification</label>\n+\t</channel-type>\n+\n+\t<channel-type id=\"onLevel\">\n+\t\t<item-type>Number</item-type>\n+\t\t<label>On Level</label>\n+\t</channel-type>\n+\n+\t<channel-type id=\"rampDimmer\">\n+\t\t<item-type>Dimmer</item-type>\n+\t\t<label>Ramp Dimmer</label>\n+\t</channel-type>\n+\n+\t<channel-type id=\"rampRate\">\n+\t\t<item-type>Number</item-type>\n+\t\t<label>Ramp Rate</label>\n+\t</channel-type>\n+\n+\t<channel-type id=\"stage1Duration\">\n+\t\t<item-type>Number</item-type>\n+\t\t<label>Stage 1 Duration</label>\n+\t</channel-type>\n+\n+\t<channel-type id=\"switch\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Switch</label>\n+\t</channel-type>\n+\n+\t<channel-type id=\"systemMode\">\n+\t\t<item-type>Number</item-type>\n+\t\t<label>System Mode</label>\n+\t</channel-type>\n+\n+\t<channel-type id=\"tempCelsius\">\n+\t\t<item-type>Number</item-type>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d8407f4d3e56f93dadba66a086ab0d3e70ef5b95"}, "originalPosition": 430}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ4NzM3OTg0", "url": "https://github.com/openhab/openhab-addons/pull/6911#pullrequestreview-348737984", "createdAt": "2020-01-27T15:13:57Z", "commit": {"oid": "7c41f7e5886c00f3db03596111e39057f9b8c467"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yN1QxNToxMzo1N1rOFiGN5Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yN1QxNToxMzo1N1rOFiGN5Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTI5Nzc2NQ==", "bodyText": "Accidental global replace error?\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        logger.info(\"device dead co- Initial contributionunt set to {}\", deadDeviceCount);\n          \n          \n            \n                        logger.info(\"device dead count set to {}\", deadDeviceCount);", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r371297765", "createdAt": "2020-01-27T15:13:57Z", "author": {"login": "Hilbrand"}, "path": "bundles/org.openhab.binding.insteon/src/main/java/org/openhab/binding/insteon/internal/InsteonBinding.java", "diffHunk": "@@ -0,0 +1,518 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.insteon.internal;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map.Entry;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.insteon.internal.config.InsteonChannelConfiguration;\n+import org.openhab.binding.insteon.internal.device.DeviceFeature;\n+import org.openhab.binding.insteon.internal.device.DeviceFeatureListener;\n+import org.openhab.binding.insteon.internal.device.DeviceType;\n+import org.openhab.binding.insteon.internal.device.DeviceTypeLoader;\n+import org.openhab.binding.insteon.internal.device.InsteonAddress;\n+import org.openhab.binding.insteon.internal.device.InsteonDevice;\n+import org.openhab.binding.insteon.internal.device.InsteonDevice.DeviceStatus;\n+import org.openhab.binding.insteon.internal.device.RequestQueueManager;\n+import org.openhab.binding.insteon.internal.driver.Driver;\n+import org.openhab.binding.insteon.internal.driver.DriverListener;\n+import org.openhab.binding.insteon.internal.driver.ModemDBEntry;\n+import org.openhab.binding.insteon.internal.driver.Poller;\n+import org.openhab.binding.insteon.internal.handler.InsteonNetworkHandler;\n+import org.openhab.binding.insteon.internal.message.FieldException;\n+import org.openhab.binding.insteon.internal.message.Msg;\n+import org.openhab.binding.insteon.internal.message.MsgListener;\n+import org.openhab.binding.insteon.internal.utils.Utils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * A majority of the code in this file is from the OpenHAB 1 binding\n+ * org.openhab.binding.insteonplm.InsteonPLMActiveBinding. Including the comments below.\n+ *\n+ * -----------------------------------------------------------------------------------------------\n+ *\n+ * This class represents the actual implementation of the binding, and controls the high level flow\n+ * of messages to and from the InsteonModem.\n+ *\n+ * Writing this binding has been an odyssey through the quirks of the Insteon protocol\n+ * and Insteon devices. A substantial redesign was necessary at some point along the way.\n+ * Here are some of the hard learned lessons that should be considered by anyone who wants\n+ * to re-architect the binding:\n+ *\n+ * 1) The entries of the link database of the modem are not reliable. The category/subcategory entries in\n+ * particular have junk data. Forget about using the modem database to generate a list of devices.\n+ * The database should only be used to verify that a device has been linked.\n+ *\n+ * 2) Querying devices for their product information does not work either. First of all, battery operated devices\n+ * (and there are a lot of those) have their radio switched off, and may generally not respond to product\n+ * queries. Even main stream hardwired devices sold presently (like the 2477s switch and the 2477d dimmer)\n+ * don't even have a product ID. Although supposedly part of the Insteon protocol, we have yet to\n+ * encounter a device that would cough up a product id when queried, even among very recent devices. They\n+ * simply return zeros as product id. Lesson: forget about querying devices to generate a device list.\n+ *\n+ * 3) Polling is a thorny issue: too much traffic on the network, and messages will be dropped left and right,\n+ * and not just the poll related ones, but others as well. In particular sending back-to-back messages\n+ * seemed to result in the second message simply never getting sent, without flow control back pressure\n+ * (NACK) from the modem. For now the work-around is to space out the messages upon sending, and\n+ * in general poll as infrequently as acceptable.\n+ *\n+ * 4) Instantiating and tracking devices when reported by the modem (either from the database, or when\n+ * messages are received) leads to complicated state management because there is no guarantee at what\n+ * point (if at all) the binding configuration will be available. It gets even more difficult when\n+ * items are created, destroyed, and modified while the binding runs.\n+ *\n+ * For the above reasons, devices are only instantiated when they are referenced by binding information.\n+ * As nice as it would be to discover devices and their properties dynamically, we have abandoned that\n+ * path because it had led to a complicated and fragile system which due to the technical limitations\n+ * above was inherently squirrely.\n+ *\n+ *\n+ * @author Bernd Pfrommer - Initial contribution\n+ * @author Daniel Pfrommer - OpenHAB 1 insteonplm binding\n+ * @author Rob Nielsen - Port to OpenHAB 2 insteon binding\n+ */\n+@NonNullByDefault\n+public class InsteonBinding {\n+    private final Logger logger = LoggerFactory.getLogger(InsteonBinding.class);\n+\n+    private Driver m_driver = new Driver();\n+    private ConcurrentHashMap<InsteonAddress, InsteonDevice> m_devices = new ConcurrentHashMap<InsteonAddress, InsteonDevice>();\n+    private ConcurrentHashMap<String, InsteonChannelConfiguration> m_bindingConfigs\n+         = new ConcurrentHashMap<>();\n+    private PortListener m_portListener = new PortListener();\n+    private int m_devicePollInterval = 300000; // in milliseconds\n+    private int m_deadDeviceTimeout = -1;\n+    private int m_deviceStatisticsInterval = 600; // in seconds\n+    private int m_messagesReceived = 0;\n+    private boolean m_isActive = false; // state of binding\n+    private int m_x10HouseUnit = -1;\n+    private InsteonNetworkHandler m_handler;\n+\n+    public InsteonBinding(InsteonNetworkHandler handler, String port, @Nullable Integer deviceStatisticsInterval,\n+            @Nullable Integer deviceDeadCount, @Nullable Integer devicePollInterval, @Nullable String additionalDevices,\n+            @Nullable String additionalFeatures, @Nullable Integer modemDbRetryTimeout) {\n+\n+        this.m_handler = handler;\n+\n+        if (deviceStatisticsInterval != null) {\n+            m_deviceStatisticsInterval = deviceStatisticsInterval;\n+            logger.info(\"device statistics interval set to {} seconds\", m_deviceStatisticsInterval);\n+        }\n+\n+        int deadDeviceCount = 10;\n+        if (deviceDeadCount != null) {\n+            deadDeviceCount = deviceDeadCount;\n+            logger.info(\"device dead co- Initial contributionunt set to {}\", deadDeviceCount);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7c41f7e5886c00f3db03596111e39057f9b8c467"}, "originalPosition": 127}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ4NzM5NTUx", "url": "https://github.com/openhab/openhab-addons/pull/6911#pullrequestreview-348739551", "createdAt": "2020-01-27T15:15:49Z", "commit": {"oid": "7c41f7e5886c00f3db03596111e39057f9b8c467"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yN1QxNToxNTo0OVrOFiGSjA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yN1QxNToxNTo0OVrOFiGSjA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTI5ODk1Ng==", "bodyText": "Does this throw a generic Exception or can it be the specific checked exception or RuntimeException?", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r371298956", "createdAt": "2020-01-27T15:15:49Z", "author": {"login": "Hilbrand"}, "path": "bundles/org.openhab.binding.insteon/src/main/java/org/openhab/binding/insteon/internal/InsteonBinding.java", "diffHunk": "@@ -0,0 +1,518 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.insteon.internal;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map.Entry;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.insteon.internal.config.InsteonChannelConfiguration;\n+import org.openhab.binding.insteon.internal.device.DeviceFeature;\n+import org.openhab.binding.insteon.internal.device.DeviceFeatureListener;\n+import org.openhab.binding.insteon.internal.device.DeviceType;\n+import org.openhab.binding.insteon.internal.device.DeviceTypeLoader;\n+import org.openhab.binding.insteon.internal.device.InsteonAddress;\n+import org.openhab.binding.insteon.internal.device.InsteonDevice;\n+import org.openhab.binding.insteon.internal.device.InsteonDevice.DeviceStatus;\n+import org.openhab.binding.insteon.internal.device.RequestQueueManager;\n+import org.openhab.binding.insteon.internal.driver.Driver;\n+import org.openhab.binding.insteon.internal.driver.DriverListener;\n+import org.openhab.binding.insteon.internal.driver.ModemDBEntry;\n+import org.openhab.binding.insteon.internal.driver.Poller;\n+import org.openhab.binding.insteon.internal.handler.InsteonNetworkHandler;\n+import org.openhab.binding.insteon.internal.message.FieldException;\n+import org.openhab.binding.insteon.internal.message.Msg;\n+import org.openhab.binding.insteon.internal.message.MsgListener;\n+import org.openhab.binding.insteon.internal.utils.Utils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * A majority of the code in this file is from the OpenHAB 1 binding\n+ * org.openhab.binding.insteonplm.InsteonPLMActiveBinding. Including the comments below.\n+ *\n+ * -----------------------------------------------------------------------------------------------\n+ *\n+ * This class represents the actual implementation of the binding, and controls the high level flow\n+ * of messages to and from the InsteonModem.\n+ *\n+ * Writing this binding has been an odyssey through the quirks of the Insteon protocol\n+ * and Insteon devices. A substantial redesign was necessary at some point along the way.\n+ * Here are some of the hard learned lessons that should be considered by anyone who wants\n+ * to re-architect the binding:\n+ *\n+ * 1) The entries of the link database of the modem are not reliable. The category/subcategory entries in\n+ * particular have junk data. Forget about using the modem database to generate a list of devices.\n+ * The database should only be used to verify that a device has been linked.\n+ *\n+ * 2) Querying devices for their product information does not work either. First of all, battery operated devices\n+ * (and there are a lot of those) have their radio switched off, and may generally not respond to product\n+ * queries. Even main stream hardwired devices sold presently (like the 2477s switch and the 2477d dimmer)\n+ * don't even have a product ID. Although supposedly part of the Insteon protocol, we have yet to\n+ * encounter a device that would cough up a product id when queried, even among very recent devices. They\n+ * simply return zeros as product id. Lesson: forget about querying devices to generate a device list.\n+ *\n+ * 3) Polling is a thorny issue: too much traffic on the network, and messages will be dropped left and right,\n+ * and not just the poll related ones, but others as well. In particular sending back-to-back messages\n+ * seemed to result in the second message simply never getting sent, without flow control back pressure\n+ * (NACK) from the modem. For now the work-around is to space out the messages upon sending, and\n+ * in general poll as infrequently as acceptable.\n+ *\n+ * 4) Instantiating and tracking devices when reported by the modem (either from the database, or when\n+ * messages are received) leads to complicated state management because there is no guarantee at what\n+ * point (if at all) the binding configuration will be available. It gets even more difficult when\n+ * items are created, destroyed, and modified while the binding runs.\n+ *\n+ * For the above reasons, devices are only instantiated when they are referenced by binding information.\n+ * As nice as it would be to discover devices and their properties dynamically, we have abandoned that\n+ * path because it had led to a complicated and fragile system which due to the technical limitations\n+ * above was inherently squirrely.\n+ *\n+ *\n+ * @author Bernd Pfrommer - Initial contribution\n+ * @author Daniel Pfrommer - OpenHAB 1 insteonplm binding\n+ * @author Rob Nielsen - Port to OpenHAB 2 insteon binding\n+ */\n+@NonNullByDefault\n+public class InsteonBinding {\n+    private final Logger logger = LoggerFactory.getLogger(InsteonBinding.class);\n+\n+    private Driver m_driver = new Driver();\n+    private ConcurrentHashMap<InsteonAddress, InsteonDevice> m_devices = new ConcurrentHashMap<InsteonAddress, InsteonDevice>();\n+    private ConcurrentHashMap<String, InsteonChannelConfiguration> m_bindingConfigs\n+         = new ConcurrentHashMap<>();\n+    private PortListener m_portListener = new PortListener();\n+    private int m_devicePollInterval = 300000; // in milliseconds\n+    private int m_deadDeviceTimeout = -1;\n+    private int m_deviceStatisticsInterval = 600; // in seconds\n+    private int m_messagesReceived = 0;\n+    private boolean m_isActive = false; // state of binding\n+    private int m_x10HouseUnit = -1;\n+    private InsteonNetworkHandler m_handler;\n+\n+    public InsteonBinding(InsteonNetworkHandler handler, String port, @Nullable Integer deviceStatisticsInterval,\n+            @Nullable Integer deviceDeadCount, @Nullable Integer devicePollInterval, @Nullable String additionalDevices,\n+            @Nullable String additionalFeatures, @Nullable Integer modemDbRetryTimeout) {\n+\n+        this.m_handler = handler;\n+\n+        if (deviceStatisticsInterval != null) {\n+            m_deviceStatisticsInterval = deviceStatisticsInterval;\n+            logger.info(\"device statistics interval set to {} seconds\", m_deviceStatisticsInterval);\n+        }\n+\n+        int deadDeviceCount = 10;\n+        if (deviceDeadCount != null) {\n+            deadDeviceCount = deviceDeadCount;\n+            logger.info(\"device dead co- Initial contributionunt set to {}\", deadDeviceCount);\n+        }\n+\n+        if (devicePollInterval != null) {\n+            m_devicePollInterval = devicePollInterval;\n+            logger.info(\"device poll interval set to {} milliseconds\", m_devicePollInterval);\n+        }\n+\n+        if (additionalDevices != null) {\n+            try {\n+                DeviceTypeLoader.s_instance().loadDeviceTypesXML(additionalDevices);\n+                logger.info(\"read additional device definitions from {}\", additionalDevices);\n+            } catch (Exception e) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7c41f7e5886c00f3db03596111e39057f9b8c467"}, "originalPosition": 139}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY3NTkwODc1", "url": "https://github.com/openhab/openhab-addons/pull/6911#pullrequestreview-367590875", "createdAt": "2020-03-02T22:56:10Z", "commit": {"oid": "ed93353c47fa5d457223c66d8f91b1c168a57e23"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 55, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wMlQyMjo1NjoxMFrOFwyYqw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wM1QwMzoxMjo1N1rOFw3Bcg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjcwMTQ4Mw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private static final Logger logger = LoggerFactory.getLogger(GroupMessageStateMachine.class);\n          \n          \n            \n                private final Logger logger = LoggerFactory.getLogger(GroupMessageStateMachine.class);", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r386701483", "createdAt": "2020-03-02T22:56:10Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.insteon/src/main/java/org/openhab/binding/insteon/internal/device/GroupMessageStateMachine.java", "diffHunk": "@@ -0,0 +1,171 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.insteon.internal.device;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Ideally, Insteon ALL LINK messages are received in this order, and\n+ * only a single one of each:\n+ *\n+ * BCAST (a broadcast message from the device to all group members)\n+ * CLEAN (a cleanup point-to-point message to ensure more reliable transmission)\n+ * SUCCESS (a broadcast report of success or failure of cleanup, with cmd1=0x06)\n+ *\n+ * But often, the BCAST, CLEAN and SUCCESS messages are retransmitted multiple times,\n+ * or (less frequently) messages are lost. The present state machine was developed\n+ * to remove duplicates, yet make sure that a single lost message does not cause\n+ * the binding to miss an update.\n+ *\n+ *\n+ * \"SUCCESS\"\n+ * EXPECT_BCAST\n+ * ^ / ^ \\\n+ * SUCCESS / / \\ \\ [BCAST]\n+ * / /['CLEAN'] 'SUCCESS'\\ \\\n+ * / / \\ \\\n+ * / V CLEAN \\ V\n+ * \"CLEAN\" EXPECT_SUCCESS <-------------- EXPECT_CLEAN \"BCAST\"\n+ * -------------->\n+ * ['BCAST']\n+ *\n+ * How to read this diagram:\n+ *\n+ * Regular, expected, non-duplicate messages do not have any quotes around them,\n+ * and lead to the obvious state transitions.\n+ *\n+ * The actions in [square brackets] are transitions that cause a state\n+ * update to be published when they occur.\n+ *\n+ * The presence of double quotes indicates a duplicate that does not lead\n+ * to any state transitions, i.e. it is simply ignored.\n+ *\n+ * Single quotes indicate a message that is the result of a single dropped\n+ * message, and leads to a state transition, in some cases even to a state\n+ * update to be published.\n+ *\n+ * For instance at the top of the diagram, if a \"SUCCESS\" message is received\n+ * when in state EXPECT_BCAST, it is considered a duplicate (it has \"\").\n+ *\n+ * When in state EXPECT_SUCCESS though, receiving a ['BCAST'] is most likely because\n+ * the SUCCESS message was missed, and therefore it is considered the result\n+ * of a single lost message (has '' around it). The state changes to EXPECT_CLEAN,\n+ * and the message should lead to publishing of a state update (it has [] around it).\n+ *\n+ * @author Bernd Pfrommer - Initial contribution\n+ * @author Rob Nielsen - Port to OpenHAB 2 insteon binding\n+ */\n+@NonNullByDefault\n+public class GroupMessageStateMachine {\n+    private static final Logger logger = LoggerFactory.getLogger(GroupMessageStateMachine.class);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ed93353c47fa5d457223c66d8f91b1c168a57e23"}, "originalPosition": 72}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjcwMjA5Ng==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private static final Logger logger = LoggerFactory.getLogger(CommandHandler.class);\n          \n          \n            \n                private final Logger logger = LoggerFactory.getLogger(CommandHandler.class);", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r386702096", "createdAt": "2020-03-02T22:57:41Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.insteon/src/main/java/org/openhab/binding/insteon/internal/device/CommandHandler.java", "diffHunk": "@@ -0,0 +1,912 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.insteon.internal.device;\n+\n+import java.io.IOException;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.Timer;\n+import java.util.TimerTask;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.IncreaseDecreaseType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.openhab.binding.insteon.internal.config.InsteonChannelConfiguration;\n+import org.openhab.binding.insteon.internal.device.DeviceFeatureListener.StateChangeType;\n+import org.openhab.binding.insteon.internal.message.FieldException;\n+import org.openhab.binding.insteon.internal.message.Msg;\n+import org.openhab.binding.insteon.internal.utils.Utils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * A command handler translates an openHAB command into a insteon message\n+ *\n+ * @author Daniel Pfrommer - Initial contribution\n+ * @author Bernd Pfrommer - OpenHAB 1 insteonplm binding\n+ * @author Rob Nielsen - Port to OpenHAB 2 insteon binding\n+ */\n+@NonNullByDefault\n+public abstract class CommandHandler {\n+    private static final Logger logger = LoggerFactory.getLogger(CommandHandler.class);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ed93353c47fa5d457223c66d8f91b1c168a57e23"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjcwNDM5NQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private static final Logger logger = LoggerFactory.getLogger(DeviceFeatureListener.class);\n          \n          \n            \n                private final Logger logger = LoggerFactory.getLogger(DeviceFeatureListener.class);", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r386704395", "createdAt": "2020-03-02T23:03:08Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.insteon/src/main/java/org/openhab/binding/insteon/internal/device/DeviceFeatureListener.java", "diffHunk": "@@ -0,0 +1,190 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.insteon.internal.device;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.insteon.internal.InsteonBinding;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * A DeviceFeatureListener essentially represents an OpenHAB item that\n+ * listens to a particular feature of an Insteon device\n+ *\n+ * @author Daniel Pfrommer - Initial contribution\n+ * @author Bernd Pfrommer - OpenHAB 1 insteonplm binding\n+ * @author Rob Nielsen - Port to OpenHAB 2 insteon binding\n+ */\n+@NonNullByDefault\n+public class DeviceFeatureListener {\n+    private static final Logger logger = LoggerFactory.getLogger(DeviceFeatureListener.class);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ed93353c47fa5d457223c66d8f91b1c168a57e23"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjcwNTAyNg==", "bodyText": "I don't think that synchronized is doing anything useful here.", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r386705026", "createdAt": "2020-03-02T23:04:56Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.insteon/src/main/java/org/openhab/binding/insteon/internal/device/DeviceFeature.java", "diffHunk": "@@ -0,0 +1,428 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.insteon.internal.device;\n+\n+import java.io.FileInputStream;\n+import java.io.FileNotFoundException;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.insteon.internal.config.InsteonChannelConfiguration;\n+import org.openhab.binding.insteon.internal.device.DeviceFeatureListener.StateChangeType;\n+import org.openhab.binding.insteon.internal.message.Msg;\n+import org.openhab.binding.insteon.internal.utils.Utils.ParsingException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * A DeviceFeature represents a certain feature (trait) of a given Insteon device, e.g. something\n+ * operating under a given InsteonAddress that can be manipulated (relay) or read (sensor).\n+ *\n+ * The DeviceFeature does the processing of incoming messages, and handles commands for the\n+ * particular feature it represents.\n+ *\n+ * It uses four mechanisms for that:\n+ *\n+ * 1) MessageDispatcher: makes high level decisions about an incoming message and then runs the\n+ * 2) MessageHandler: further processes the message, updates state etc\n+ * 3) CommandHandler: translates commands from the openhab bus into an Insteon message.\n+ * 4) PollHandler: creates an Insteon message to query the DeviceFeature\n+ *\n+ * Lastly, DeviceFeatureListeners can register with the DeviceFeature to get notifications when\n+ * the state of a feature has changed. In practice, a DeviceFeatureListener corresponds to an\n+ * OpenHAB item.\n+ *\n+ * The character of a DeviceFeature is thus given by a set of message and command handlers.\n+ * A FeatureTemplate captures exactly that: it says what set of handlers make up a DeviceFeature.\n+ *\n+ * DeviceFeatures are added to a new device by referencing a FeatureTemplate (defined in device_features.xml)\n+ * from the Device definition file (device_types.xml).\n+ *\n+ * @author Daniel Pfrommer - Initial contribution\n+ * @author Bernd Pfrommer - OpenHAB 1 insteonplm binding\n+ * @author Rob Nielsen - Port to OpenHAB 2 insteon binding\n+ */\n+@NonNullByDefault\n+public class DeviceFeature {\n+    public static enum QueryStatus {\n+        NEVER_QUERIED,\n+        QUERY_PENDING,\n+        QUERY_ANSWERED\n+    }\n+\n+    private static final Logger logger = LoggerFactory.getLogger(DeviceFeature.class);\n+\n+    private static HashMap<String, FeatureTemplate> s_features = new HashMap<String, FeatureTemplate>();\n+\n+    private InsteonDevice m_device = new InsteonDevice();\n+    private String m_name = \"INVALID_FEATURE_NAME\";\n+    private boolean m_isStatus = false;\n+    private int m_directAckTimeout = 6000;\n+    private QueryStatus m_queryStatus = QueryStatus.NEVER_QUERIED;\n+\n+    private @Nullable MessageHandler m_defaultMsgHandler = new MessageHandler.DefaultMsgHandler(this);\n+    private @Nullable CommandHandler m_defaultCommandHandler = new CommandHandler.WarnCommandHandler(this);\n+    private @Nullable PollHandler m_pollHandler = null;\n+    private @Nullable MessageDispatcher m_dispatcher = null;\n+\n+    private HashMap<Integer, @Nullable MessageHandler> m_msgHandlers = new HashMap<Integer, @Nullable MessageHandler>();\n+    private HashMap<Class<? extends Command>, @Nullable CommandHandler> m_commandHandlers = new HashMap<Class<? extends Command>, @Nullable CommandHandler>();\n+    private ArrayList<DeviceFeatureListener> m_listeners = new ArrayList<DeviceFeatureListener>();\n+    private ArrayList<DeviceFeature> m_connectedFeatures = new ArrayList<DeviceFeature>();\n+\n+    /**\n+     * Constructor\n+     *\n+     * @param device Insteon device to which this feature belongs\n+     * @param name descriptive name for that feature\n+     */\n+    public DeviceFeature(InsteonDevice device, String name) {\n+        m_name = name;\n+        setDevice(device);\n+    }\n+\n+    /**\n+     * Constructor\n+     *\n+     * @param name descriptive name of the feature\n+     */\n+    public DeviceFeature(String name) {\n+        m_name = name;\n+    }\n+\n+    // various simple getters\n+    public String getName() {\n+        return m_name;\n+    }\n+\n+    public synchronized QueryStatus getQueryStatus() {\n+        return m_queryStatus;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ed93353c47fa5d457223c66d8f91b1c168a57e23"}, "originalPosition": 116}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjcwNTUzMw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private static final Logger logger = LoggerFactory.getLogger(DeviceFeature.class);\n          \n          \n            \n                private final Logger logger = LoggerFactory.getLogger(DeviceFeature.class);", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r386705533", "createdAt": "2020-03-02T23:06:16Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.insteon/src/main/java/org/openhab/binding/insteon/internal/device/DeviceFeature.java", "diffHunk": "@@ -0,0 +1,428 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.insteon.internal.device;\n+\n+import java.io.FileInputStream;\n+import java.io.FileNotFoundException;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.insteon.internal.config.InsteonChannelConfiguration;\n+import org.openhab.binding.insteon.internal.device.DeviceFeatureListener.StateChangeType;\n+import org.openhab.binding.insteon.internal.message.Msg;\n+import org.openhab.binding.insteon.internal.utils.Utils.ParsingException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * A DeviceFeature represents a certain feature (trait) of a given Insteon device, e.g. something\n+ * operating under a given InsteonAddress that can be manipulated (relay) or read (sensor).\n+ *\n+ * The DeviceFeature does the processing of incoming messages, and handles commands for the\n+ * particular feature it represents.\n+ *\n+ * It uses four mechanisms for that:\n+ *\n+ * 1) MessageDispatcher: makes high level decisions about an incoming message and then runs the\n+ * 2) MessageHandler: further processes the message, updates state etc\n+ * 3) CommandHandler: translates commands from the openhab bus into an Insteon message.\n+ * 4) PollHandler: creates an Insteon message to query the DeviceFeature\n+ *\n+ * Lastly, DeviceFeatureListeners can register with the DeviceFeature to get notifications when\n+ * the state of a feature has changed. In practice, a DeviceFeatureListener corresponds to an\n+ * OpenHAB item.\n+ *\n+ * The character of a DeviceFeature is thus given by a set of message and command handlers.\n+ * A FeatureTemplate captures exactly that: it says what set of handlers make up a DeviceFeature.\n+ *\n+ * DeviceFeatures are added to a new device by referencing a FeatureTemplate (defined in device_features.xml)\n+ * from the Device definition file (device_types.xml).\n+ *\n+ * @author Daniel Pfrommer - Initial contribution\n+ * @author Bernd Pfrommer - OpenHAB 1 insteonplm binding\n+ * @author Rob Nielsen - Port to OpenHAB 2 insteon binding\n+ */\n+@NonNullByDefault\n+public class DeviceFeature {\n+    public static enum QueryStatus {\n+        NEVER_QUERIED,\n+        QUERY_PENDING,\n+        QUERY_ANSWERED\n+    }\n+\n+    private static final Logger logger = LoggerFactory.getLogger(DeviceFeature.class);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ed93353c47fa5d457223c66d8f91b1c168a57e23"}, "originalPosition": 70}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjcwNzMyOA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private static final Logger logger = LoggerFactory.getLogger(DeviceTypeLoader.class);\n          \n          \n            \n                private final Logger logger = LoggerFactory.getLogger(DeviceTypeLoader.class);", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r386707328", "createdAt": "2020-03-02T23:10:56Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.insteon/src/main/java/org/openhab/binding/insteon/internal/device/DeviceTypeLoader.java", "diffHunk": "@@ -0,0 +1,237 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.insteon.internal.device;\n+\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.util.HashMap;\n+import java.util.Map.Entry;\n+\n+import javax.xml.parsers.DocumentBuilder;\n+import javax.xml.parsers.DocumentBuilderFactory;\n+import javax.xml.parsers.ParserConfigurationException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.insteon.internal.device.DeviceType.FeatureGroup;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.w3c.dom.Document;\n+import org.w3c.dom.Element;\n+import org.w3c.dom.Node;\n+import org.w3c.dom.NodeList;\n+import org.xml.sax.SAXException;\n+\n+/**\n+ * Reads the device types from an xml file.\n+ *\n+ * @author Daniel Pfrommer - Initial contribution\n+ * @author Bernd Pfrommer - OpenHAB 1 insteonplm binding\n+ * @author Rob Nielsen - Port to OpenHAB 2 insteon binding\n+ */\n+@NonNullByDefault\n+public class DeviceTypeLoader {\n+    private static final Logger logger = LoggerFactory.getLogger(DeviceTypeLoader.class);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ed93353c47fa5d457223c66d8f91b1c168a57e23"}, "originalPosition": 46}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjcwODEwOA==", "bodyText": "move fields above constructor", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r386708108", "createdAt": "2020-03-02T23:13:09Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.insteon/src/main/java/org/openhab/binding/insteon/internal/device/HandlerEntry.java", "diffHunk": "@@ -0,0 +1,43 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.insteon.internal.device;\n+\n+import java.util.HashMap;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+\n+/**\n+ * Ugly little helper class to facilitate late instantiation of handlers\n+ *\n+ * @author Bernd Pfrommer - Initial contribution\n+ * @author Rob Nielsen - Port to OpenHAB 2 insteon binding\n+ */\n+@NonNullByDefault\n+public class HandlerEntry {\n+    HandlerEntry(String name, HashMap<String, @Nullable String> params) {\n+        m_hname = name;\n+        m_params = params;\n+    }\n+\n+    HashMap<String, @Nullable String> m_params;\n+    String m_hname;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ed93353c47fa5d457223c66d8f91b1c168a57e23"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjcwODQ4NA==", "bodyText": "Everything in this class is package protected. Why not the class itself?", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r386708484", "createdAt": "2020-03-02T23:14:15Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.insteon/src/main/java/org/openhab/binding/insteon/internal/device/HandlerEntry.java", "diffHunk": "@@ -0,0 +1,43 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.insteon.internal.device;\n+\n+import java.util.HashMap;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+\n+/**\n+ * Ugly little helper class to facilitate late instantiation of handlers\n+ *\n+ * @author Bernd Pfrommer - Initial contribution\n+ * @author Rob Nielsen - Port to OpenHAB 2 insteon binding\n+ */\n+@NonNullByDefault\n+public class HandlerEntry {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ed93353c47fa5d457223c66d8f91b1c168a57e23"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjcwOTE0Mg==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    } catch (Exception e) {\n          \n          \n            \n                    } catch (NumberFormatException e) {", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r386709142", "createdAt": "2020-03-02T23:16:09Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.insteon/src/main/java/org/openhab/binding/insteon/internal/device/InsteonAddress.java", "diffHunk": "@@ -0,0 +1,238 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.insteon.internal.device;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.insteon.internal.utils.Utils;\n+\n+/**\n+ * This class wraps an Insteon Address 'xx.xx.xx'\n+ *\n+ * @author Daniel Pfrommer - Initial contribution\n+ * @author Rob Nielsen - Port to OpenHAB 2 insteon binding\n+ */\n+@NonNullByDefault\n+public class InsteonAddress {\n+    private byte highByte;\n+    private byte middleByte;\n+    private byte lowByte;\n+    private boolean x10;\n+\n+    public InsteonAddress() {\n+        highByte = 0x00;\n+        middleByte = 0x00;\n+        lowByte = 0x00;\n+        x10 = false;\n+    }\n+\n+    public InsteonAddress(InsteonAddress a) {\n+        highByte = a.highByte;\n+        middleByte = a.middleByte;\n+        lowByte = a.lowByte;\n+        x10 = a.x10;\n+    }\n+\n+    public InsteonAddress(byte high, byte middle, byte low) {\n+        highByte = high;\n+        middleByte = middle;\n+        lowByte = low;\n+        x10 = false;\n+    }\n+\n+    /**\n+     * Constructor\n+     *\n+     * @param address string must have format of e.g. '2a.3c.40' or (for X10) 'H.UU'\n+     */\n+    public InsteonAddress(String address) throws IllegalArgumentException {\n+        if (X10.s_isValidAddress(address)) {\n+            highByte = 0;\n+            middleByte = 0;\n+            lowByte = X10.s_addressToByte(address);\n+            x10 = true;\n+        } else {\n+            String[] parts = address.split(\"\\\\.\");\n+            if (parts.length != 3) {\n+                throw new IllegalArgumentException(\"Address string must have 3 bytes, has: \" + parts.length);\n+            }\n+            highByte = (byte) Utils.fromHexString(parts[0]);\n+            middleByte = (byte) Utils.fromHexString(parts[1]);\n+            lowByte = (byte) Utils.fromHexString(parts[2]);\n+            x10 = false;\n+        }\n+    }\n+\n+    /**\n+     * Constructor for an InsteonAddress that wraps an X10 address.\n+     * Simply stuff the X10 address into the lowest byte.\n+     *\n+     * @param aX10HouseUnit the house & unit number as encoded by the X10 protocol\n+     */\n+    public InsteonAddress(byte aX10HouseUnit) {\n+        highByte = 0;\n+        middleByte = 0;\n+        lowByte = aX10HouseUnit;\n+        x10 = true;\n+    }\n+\n+    public void setHighByte(byte h) {\n+        highByte = h;\n+    }\n+\n+    public void setMiddleByte(byte m) {\n+        middleByte = m;\n+    }\n+\n+    public void setLowByte(byte l) {\n+        lowByte = l;\n+    }\n+\n+    public byte getHighByte() {\n+        return highByte;\n+    }\n+\n+    public byte getMiddleByte() {\n+        return middleByte;\n+    }\n+\n+    public byte getLowByte() {\n+        return lowByte;\n+    }\n+\n+    public byte getX10HouseCode() {\n+        return (byte) ((lowByte & 0xf0) >> 4);\n+    }\n+\n+    public byte getX10UnitCode() {\n+        return (byte) ((lowByte & 0x0f));\n+    }\n+\n+    public boolean isX10() {\n+        return x10;\n+    }\n+\n+    public void storeBytes(byte[] bytes, int offset) {\n+        bytes[offset] = getHighByte();\n+        bytes[offset + 1] = getMiddleByte();\n+        bytes[offset + 2] = getLowByte();\n+    }\n+\n+    public void loadBytes(byte[] bytes, int offset) {\n+        setHighByte(bytes[offset]);\n+        setMiddleByte(bytes[offset + 1]);\n+        setLowByte(bytes[offset + 2]);\n+    }\n+\n+    @Override\n+    public String toString() {\n+        String s = null;\n+        if (isX10()) {\n+            byte house = (byte) (((getLowByte() & 0xf0) >> 4) & 0xff);\n+            byte unit = (byte) ((getLowByte() & 0x0f) & 0xff);\n+            s = X10.s_houseToString(house) + \".\" + X10.s_unitToInt(unit);\n+            // s = Utils.getHexString(lowByte);\n+        } else {\n+            s = Utils.getHexString(highByte) + \".\" + Utils.getHexString(middleByte) + \".\" + Utils.getHexString(lowByte);\n+        }\n+        return s;\n+    }\n+\n+    @Override\n+    public boolean equals(@Nullable Object obj) {\n+        if (this == obj) {\n+            return true;\n+        }\n+        if (obj == null) {\n+            return false;\n+        }\n+        if (getClass() != obj.getClass()) {\n+            return false;\n+        }\n+        InsteonAddress other = (InsteonAddress) obj;\n+        if (highByte != other.highByte) {\n+            return false;\n+        }\n+        if (lowByte != other.lowByte) {\n+            return false;\n+        }\n+        if (middleByte != other.middleByte) {\n+            return false;\n+        }\n+        if (x10 != other.x10) {\n+            return false;\n+        }\n+        return true;\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        final int prime = 31;\n+        int result = 1;\n+        result = prime * result + highByte;\n+        result = prime * result + lowByte;\n+        result = prime * result + middleByte;\n+        result = prime * result + (x10 ? 1231 : 1237);\n+        return result;\n+    }\n+\n+    /**\n+     * Test if Insteon address is valid\n+     *\n+     * @return true if address is in valid AB.CD.EF or (for X10) H.UU format\n+     */\n+    public static boolean s_isValid(@Nullable String addr) {\n+        if (addr == null) {\n+            return false;\n+        }\n+        if (X10.s_isValidAddress(addr)) {\n+            return true;\n+        }\n+        String[] fields = addr.split(\"\\\\.\");\n+        if (fields.length != 3) {\n+            return false;\n+        }\n+        try {\n+            // convert the insteon xx.xx.xx address to integer to test\n+            @SuppressWarnings(\"unused\")\n+            int test = Integer.parseInt(fields[2], 16) * 65536 + Integer.parseInt(fields[1], 16) * 256\n+                    + +Integer.parseInt(fields[0], 16);\n+        } catch (Exception e) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ed93353c47fa5d457223c66d8f91b1c168a57e23"}, "originalPosition": 210}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjcwOTQxNA==", "bodyText": "either put this in a unit test or remove it", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r386709414", "createdAt": "2020-03-02T23:16:50Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.insteon/src/main/java/org/openhab/binding/insteon/internal/device/InsteonAddress.java", "diffHunk": "@@ -0,0 +1,238 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.insteon.internal.device;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.insteon.internal.utils.Utils;\n+\n+/**\n+ * This class wraps an Insteon Address 'xx.xx.xx'\n+ *\n+ * @author Daniel Pfrommer - Initial contribution\n+ * @author Rob Nielsen - Port to OpenHAB 2 insteon binding\n+ */\n+@NonNullByDefault\n+public class InsteonAddress {\n+    private byte highByte;\n+    private byte middleByte;\n+    private byte lowByte;\n+    private boolean x10;\n+\n+    public InsteonAddress() {\n+        highByte = 0x00;\n+        middleByte = 0x00;\n+        lowByte = 0x00;\n+        x10 = false;\n+    }\n+\n+    public InsteonAddress(InsteonAddress a) {\n+        highByte = a.highByte;\n+        middleByte = a.middleByte;\n+        lowByte = a.lowByte;\n+        x10 = a.x10;\n+    }\n+\n+    public InsteonAddress(byte high, byte middle, byte low) {\n+        highByte = high;\n+        middleByte = middle;\n+        lowByte = low;\n+        x10 = false;\n+    }\n+\n+    /**\n+     * Constructor\n+     *\n+     * @param address string must have format of e.g. '2a.3c.40' or (for X10) 'H.UU'\n+     */\n+    public InsteonAddress(String address) throws IllegalArgumentException {\n+        if (X10.s_isValidAddress(address)) {\n+            highByte = 0;\n+            middleByte = 0;\n+            lowByte = X10.s_addressToByte(address);\n+            x10 = true;\n+        } else {\n+            String[] parts = address.split(\"\\\\.\");\n+            if (parts.length != 3) {\n+                throw new IllegalArgumentException(\"Address string must have 3 bytes, has: \" + parts.length);\n+            }\n+            highByte = (byte) Utils.fromHexString(parts[0]);\n+            middleByte = (byte) Utils.fromHexString(parts[1]);\n+            lowByte = (byte) Utils.fromHexString(parts[2]);\n+            x10 = false;\n+        }\n+    }\n+\n+    /**\n+     * Constructor for an InsteonAddress that wraps an X10 address.\n+     * Simply stuff the X10 address into the lowest byte.\n+     *\n+     * @param aX10HouseUnit the house & unit number as encoded by the X10 protocol\n+     */\n+    public InsteonAddress(byte aX10HouseUnit) {\n+        highByte = 0;\n+        middleByte = 0;\n+        lowByte = aX10HouseUnit;\n+        x10 = true;\n+    }\n+\n+    public void setHighByte(byte h) {\n+        highByte = h;\n+    }\n+\n+    public void setMiddleByte(byte m) {\n+        middleByte = m;\n+    }\n+\n+    public void setLowByte(byte l) {\n+        lowByte = l;\n+    }\n+\n+    public byte getHighByte() {\n+        return highByte;\n+    }\n+\n+    public byte getMiddleByte() {\n+        return middleByte;\n+    }\n+\n+    public byte getLowByte() {\n+        return lowByte;\n+    }\n+\n+    public byte getX10HouseCode() {\n+        return (byte) ((lowByte & 0xf0) >> 4);\n+    }\n+\n+    public byte getX10UnitCode() {\n+        return (byte) ((lowByte & 0x0f));\n+    }\n+\n+    public boolean isX10() {\n+        return x10;\n+    }\n+\n+    public void storeBytes(byte[] bytes, int offset) {\n+        bytes[offset] = getHighByte();\n+        bytes[offset + 1] = getMiddleByte();\n+        bytes[offset + 2] = getLowByte();\n+    }\n+\n+    public void loadBytes(byte[] bytes, int offset) {\n+        setHighByte(bytes[offset]);\n+        setMiddleByte(bytes[offset + 1]);\n+        setLowByte(bytes[offset + 2]);\n+    }\n+\n+    @Override\n+    public String toString() {\n+        String s = null;\n+        if (isX10()) {\n+            byte house = (byte) (((getLowByte() & 0xf0) >> 4) & 0xff);\n+            byte unit = (byte) ((getLowByte() & 0x0f) & 0xff);\n+            s = X10.s_houseToString(house) + \".\" + X10.s_unitToInt(unit);\n+            // s = Utils.getHexString(lowByte);\n+        } else {\n+            s = Utils.getHexString(highByte) + \".\" + Utils.getHexString(middleByte) + \".\" + Utils.getHexString(lowByte);\n+        }\n+        return s;\n+    }\n+\n+    @Override\n+    public boolean equals(@Nullable Object obj) {\n+        if (this == obj) {\n+            return true;\n+        }\n+        if (obj == null) {\n+            return false;\n+        }\n+        if (getClass() != obj.getClass()) {\n+            return false;\n+        }\n+        InsteonAddress other = (InsteonAddress) obj;\n+        if (highByte != other.highByte) {\n+            return false;\n+        }\n+        if (lowByte != other.lowByte) {\n+            return false;\n+        }\n+        if (middleByte != other.middleByte) {\n+            return false;\n+        }\n+        if (x10 != other.x10) {\n+            return false;\n+        }\n+        return true;\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        final int prime = 31;\n+        int result = 1;\n+        result = prime * result + highByte;\n+        result = prime * result + lowByte;\n+        result = prime * result + middleByte;\n+        result = prime * result + (x10 ? 1231 : 1237);\n+        return result;\n+    }\n+\n+    /**\n+     * Test if Insteon address is valid\n+     *\n+     * @return true if address is in valid AB.CD.EF or (for X10) H.UU format\n+     */\n+    public static boolean s_isValid(@Nullable String addr) {\n+        if (addr == null) {\n+            return false;\n+        }\n+        if (X10.s_isValidAddress(addr)) {\n+            return true;\n+        }\n+        String[] fields = addr.split(\"\\\\.\");\n+        if (fields.length != 3) {\n+            return false;\n+        }\n+        try {\n+            // convert the insteon xx.xx.xx address to integer to test\n+            @SuppressWarnings(\"unused\")\n+            int test = Integer.parseInt(fields[2], 16) * 65536 + Integer.parseInt(fields[1], 16) * 256\n+                    + +Integer.parseInt(fields[0], 16);\n+        } catch (Exception e) {\n+            return false;\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * Turn string into address\n+     *\n+     * @param val the string to convert\n+     * @return the corresponding insteon address\n+     */\n+    public static InsteonAddress s_parseAddress(String val) {\n+        return new InsteonAddress(val);\n+    }\n+\n+    // /**\n+    // * Function for unit testing\n+    // *\n+    // * @param args ignored\n+    // */\n+    // public static void main(String[] args) {\n+    // // debug/test code\n+    // InsteonAddress a1 = new InsteonAddress();\n+    // InsteonAddress a2 = new InsteonAddress();\n+    // System.out.println(a1.equals(a2));\n+    // System.out.println(new InsteonAddress(\"0f.0f.0a\"));\n+    // }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ed93353c47fa5d457223c66d8f91b1c168a57e23"}, "originalPosition": 237}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjcwOTUxMg==", "bodyText": "either put this in a unit test or remove it", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r386709512", "createdAt": "2020-03-02T23:17:09Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.insteon/src/main/java/org/openhab/binding/insteon/internal/device/FeatureTemplateLoader.java", "diffHunk": "@@ -0,0 +1,180 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.insteon.internal.device;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+\n+import javax.xml.parsers.DocumentBuilder;\n+import javax.xml.parsers.DocumentBuilderFactory;\n+import javax.xml.parsers.ParserConfigurationException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.IncreaseDecreaseType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.openhab.binding.insteon.internal.utils.Utils;\n+import org.openhab.binding.insteon.internal.utils.Utils.ParsingException;\n+import org.w3c.dom.DOMException;\n+import org.w3c.dom.Document;\n+import org.w3c.dom.Element;\n+import org.w3c.dom.NamedNodeMap;\n+import org.w3c.dom.Node;\n+import org.w3c.dom.NodeList;\n+import org.xml.sax.SAXException;\n+\n+/**\n+ * Class that loads the device feature templates from an xml stream\n+ *\n+ * @author Daniel Pfrommer - Initial contribution\n+ * @author Rob Nielsen - Port to OpenHAB 2 insteon binding\n+ */\n+@NonNullByDefault\n+public class FeatureTemplateLoader {\n+    public static ArrayList<FeatureTemplate> s_readTemplates(InputStream input) throws IOException, ParsingException {\n+        ArrayList<FeatureTemplate> features = new ArrayList<FeatureTemplate>();\n+        try {\n+            DocumentBuilderFactory dbFactory = DocumentBuilderFactory.newInstance();\n+            DocumentBuilder dBuilder = dbFactory.newDocumentBuilder();\n+            // Parse it!\n+            Document doc = dBuilder.parse(input);\n+            doc.getDocumentElement().normalize();\n+\n+            Element root = doc.getDocumentElement();\n+\n+            NodeList nodes = root.getChildNodes();\n+\n+            for (int i = 0; i < nodes.getLength(); i++) {\n+                Node node = nodes.item(i);\n+                if (node.getNodeType() == Node.ELEMENT_NODE) {\n+                    Element e = (Element) node;\n+                    if (e.getTagName().equals(\"feature\")) {\n+                        features.add(s_parseFeature(e));\n+                    }\n+                }\n+            }\n+        } catch (SAXException e) {\n+            throw new ParsingException(\"Failed to parse XML!\", e);\n+        } catch (ParserConfigurationException e) {\n+            throw new ParsingException(\"Got parser config exception! \", e);\n+        }\n+        return features;\n+    }\n+\n+    private static FeatureTemplate s_parseFeature(Element e) throws ParsingException {\n+        String name = e.getAttribute(\"name\");\n+        boolean statusFeature = e.getAttribute(\"statusFeature\").equals(\"true\");\n+        FeatureTemplate feature = new FeatureTemplate(name, statusFeature, e.getAttribute(\"timeout\"));\n+\n+        NodeList nodes = e.getChildNodes();\n+\n+        for (int i = 0; i < nodes.getLength(); i++) {\n+            Node node = nodes.item(i);\n+            if (node.getNodeType() == Node.ELEMENT_NODE) {\n+                Element child = (Element) node;\n+                if (child.getTagName().equals(\"message-handler\")) {\n+                    s_parseMessageHandler(child, feature);\n+                } else if (child.getTagName().equals(\"command-handler\")) {\n+                    s_parseCommandHandler(child, feature);\n+                } else if (child.getTagName().equals(\"message-dispatcher\")) {\n+                    s_parseMessageDispatcher(child, feature);\n+                } else if (child.getTagName().equals(\"poll-handler\")) {\n+                    s_parsePollHandler(child, feature);\n+                }\n+            }\n+        }\n+\n+        return feature;\n+    }\n+\n+    private static HandlerEntry s_makeHandlerEntry(Element e) throws ParsingException {\n+        String handler = e.getTextContent();\n+        if (handler == null) {\n+            throw new ParsingException(\"Could not find Handler for: \" + e.getTextContent());\n+        }\n+\n+        NamedNodeMap attributes = e.getAttributes();\n+        HashMap<String, @Nullable String> params = new HashMap<String, @Nullable String>();\n+        for (int i = 0; i < attributes.getLength(); i++) {\n+            Node n = attributes.item(i);\n+            params.put(n.getNodeName(), n.getNodeValue());\n+        }\n+        return new HandlerEntry(handler, params);\n+    }\n+\n+    private static void s_parseMessageHandler(Element e, FeatureTemplate f) throws DOMException, ParsingException {\n+        HandlerEntry he = s_makeHandlerEntry(e);\n+        if (e.getAttribute(\"default\").equals(\"true\")) {\n+            f.setDefaultMessageHandler(he);\n+        } else {\n+            String attr = e.getAttribute(\"cmd\");\n+            int command = (attr == null) ? 0 : Utils.from0xHexString(attr);\n+            f.addMessageHandler(command, he);\n+        }\n+    }\n+\n+    private static void s_parseCommandHandler(Element e, FeatureTemplate f) throws ParsingException {\n+        HandlerEntry he = s_makeHandlerEntry(e);\n+        if (e.getAttribute(\"default\").equals(\"true\")) {\n+            f.setDefaultCommandHandler(he);\n+        } else {\n+            Class<? extends Command> command = s_parseCommandClass(e.getAttribute(\"command\"));\n+            f.addCommandHandler(command, he);\n+        }\n+    }\n+\n+    private static void s_parseMessageDispatcher(Element e, FeatureTemplate f) throws DOMException, ParsingException {\n+        HandlerEntry he = s_makeHandlerEntry(e);\n+        f.setMessageDispatcher(he);\n+    }\n+\n+    private static void s_parsePollHandler(Element e, FeatureTemplate f) throws ParsingException {\n+        HandlerEntry he = s_makeHandlerEntry(e);\n+        f.setPollHandler(he);\n+    }\n+\n+    private static Class<? extends Command> s_parseCommandClass(String c) throws ParsingException {\n+        if (c.equals(\"OnOffType\")) {\n+            return OnOffType.class;\n+        } else if (c.equals(\"PercentType\")) {\n+            return PercentType.class;\n+        } else if (c.equals(\"DecimalType\")) {\n+            return DecimalType.class;\n+        } else if (c.equals(\"IncreaseDecreaseType\")) {\n+            return IncreaseDecreaseType.class;\n+        } else {\n+            throw new ParsingException(\"Unknown Command Type\");\n+        }\n+    }\n+\n+    // public static void main(String[] args) throws Exception {\n+    // File f = new File(System.getProperty(\"user.home\")\n+    // + \"/workspace/openhab/bundles/binding/org.openhab.binding.insteonplm/src/main/resources/device_features.xml\");\n+    // InputStream s = new FileInputStream(f);\n+    // ArrayList<FeatureTemplate> features = s_readTemplates(s);\n+    // for (FeatureTemplate feature : features) {\n+    // System.out.println(feature);\n+    // System.out.println(\n+    // \"\\tPOLL: \" + feature.getPollHandler() + \"\\n\\tDISPATCH: \" + feature.getDispatcher().getName());\n+    // System.out.println(\n+    // \"\\tDCH: \" + feature.getDefaultCommandHandler() + \"\\n\\tDMH: \" + feature.getDefaultMessageHandler());\n+    // System.out.println(\"\\tMSG HANDLERS: \" + feature.getMessageHandlers().size());\n+    // System.out.println(\"\\tCMD HANDLERS: \" + feature.getCommandHandlers());\n+    // }\n+    // }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ed93353c47fa5d457223c66d8f91b1c168a57e23"}, "originalPosition": 179}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjcxMjQyMA==", "bodyText": "Isn't this class just implementing what a Scheduler already does? Why not delete this class and use a scheduler instead?", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r386712420", "createdAt": "2020-03-02T23:25:32Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.insteon/src/main/java/org/openhab/binding/insteon/internal/device/RequestQueueManager.java", "diffHunk": "@@ -0,0 +1,202 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.insteon.internal.device;\n+\n+import java.util.HashMap;\n+import java.util.PriorityQueue;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Class that manages all the per-device request queues using a single thread.\n+ *\n+ * - Each device has its own request queue, and the RequestQueueManager keeps a\n+ * queue of queues.\n+ * - Each entry in m_requestQueues corresponds to a single device's request queue.\n+ * A device should never be more than once in m_requestQueues.\n+ * - A hash map (m_requestQueueHash) is kept in sync with m_requestQueues for\n+ * faster lookup in case a request queue is modified and needs to be\n+ * rescheduled.\n+ *\n+ * @author Bernd Pfrommer - Initial contribution\n+ * @author Rob Nielsen - Port to OpenHAB 2 insteon binding\n+ */\n+@NonNullByDefault\n+public class RequestQueueManager {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ed93353c47fa5d457223c66d8f91b1c168a57e23"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjcxNTAzNQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    super(new HashSet<>(Arrays.asList(InsteonBindingConstants.NETWORK_THING_TYPE)), DISCOVER_TIMEOUT_SECONDS, true);\n          \n          \n            \n                    super(Collections.singleton(InsteonBindingConstants.NETWORK_THING_TYPE), DISCOVER_TIMEOUT_SECONDS, true);", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r386715035", "createdAt": "2020-03-02T23:32:49Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.insteon/src/main/java/org/openhab/binding/insteon/internal/discovery/InsteonNetworkDiscoveryService.java", "diffHunk": "@@ -0,0 +1,59 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.insteon.internal.discovery;\n+\n+import java.util.Arrays;\n+import java.util.HashSet;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.smarthome.config.discovery.AbstractDiscoveryService;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResultBuilder;\n+import org.eclipse.smarthome.config.discovery.DiscoveryService;\n+import org.eclipse.smarthome.core.thing.ThingUID;\n+import org.openhab.binding.insteon.internal.InsteonBindingConstants;\n+import org.osgi.service.component.annotations.Component;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link InsteonNetworkDiscoveryService} is responsible for device discovery.\n+ *\n+ * @author Rob Nielsen - Initial contribution\n+ */\n+@NonNullByDefault\n+@Component(service = DiscoveryService.class, immediate = true, configurationPid = \"discovery.insteon\")\n+public class InsteonNetworkDiscoveryService extends AbstractDiscoveryService {\n+    private final Logger logger = LoggerFactory.getLogger(InsteonNetworkDiscoveryService.class);\n+\n+    private static final ThingUID LOCAL_THING = new ThingUID(InsteonBindingConstants.NETWORK_THING_TYPE, \"local\");\n+\n+    private static final int DISCOVER_TIMEOUT_SECONDS = 2;\n+\n+    public InsteonNetworkDiscoveryService() {\n+        super(new HashSet<>(Arrays.asList(InsteonBindingConstants.NETWORK_THING_TYPE)), DISCOVER_TIMEOUT_SECONDS, true);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ed93353c47fa5d457223c66d8f91b1c168a57e23"}, "originalPosition": 43}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjcxNTE3NQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    super(new HashSet<>(Arrays.asList(InsteonBindingConstants.DEVICE_THING_TYPE)), 0, false);\n          \n          \n            \n                    super(Collections.singleton(InsteonBindingConstants.DEVICE_THING_TYPE), 0, false);", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r386715175", "createdAt": "2020-03-02T23:33:14Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.insteon/src/main/java/org/openhab/binding/insteon/internal/discovery/InsteonDeviceDiscoveryService.java", "diffHunk": "@@ -0,0 +1,74 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.insteon.internal.discovery;\n+\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.smarthome.config.discovery.AbstractDiscoveryService;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResultBuilder;\n+import org.eclipse.smarthome.core.thing.ThingUID;\n+import org.openhab.binding.insteon.internal.InsteonBindingConstants;\n+import org.openhab.binding.insteon.internal.handler.InsteonNetworkHandler;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link InsteonDeviceDiscoveryService} is responsible for device discovery.\n+ *\n+ * @author Rob Nielsen - Initial contribution\n+ */\n+@NonNullByDefault\n+public class InsteonDeviceDiscoveryService extends AbstractDiscoveryService {\n+    private static final String ADDRESS = \"address\";\n+\n+    private final Logger logger = LoggerFactory.getLogger(InsteonDeviceDiscoveryService.class);\n+\n+    public InsteonDeviceDiscoveryService(InsteonNetworkHandler handler) {\n+        super(new HashSet<>(Arrays.asList(InsteonBindingConstants.DEVICE_THING_TYPE)), 0, false);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ed93353c47fa5d457223c66d8f91b1c168a57e23"}, "originalPosition": 42}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjcxNTM3MQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private static final Logger logger = LoggerFactory.getLogger(Driver.class);\n          \n          \n            \n                private final Logger logger = LoggerFactory.getLogger(Driver.class);", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r386715371", "createdAt": "2020-03-02T23:33:46Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.insteon/src/main/java/org/openhab/binding/insteon/internal/driver/Driver.java", "diffHunk": "@@ -0,0 +1,200 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.insteon.internal.driver;\n+\n+import java.io.IOException;\n+import java.util.HashMap;\n+import java.util.concurrent.locks.ReentrantLock;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.insteon.internal.device.InsteonAddress;\n+import org.openhab.binding.insteon.internal.message.Msg;\n+import org.openhab.binding.insteon.internal.message.MsgListener;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The driver class manages the modem ports.\n+ * XXX: at this time, only a single modem has ever been used. Expect\n+ * the worst if you connect multiple modems. When multiple modems\n+ * are required, this code needs to be tested and fixed.\n+ *\n+ * @author Bernd Pfrommer - Initial contribution\n+ * @author Rob Nielsen - Port to OpenHAB 2 insteon binding\n+ */\n+@NonNullByDefault\n+public class Driver {\n+    private static final Logger logger = LoggerFactory.getLogger(Driver.class);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ed93353c47fa5d457223c66d8f91b1c168a57e23"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjcxNTg2NA==", "bodyText": "locking has to be done with try/finally", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r386715864", "createdAt": "2020-03-02T23:35:19Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.insteon/src/main/java/org/openhab/binding/insteon/internal/InsteonBinding.java", "diffHunk": "@@ -0,0 +1,512 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.insteon.internal;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map.Entry;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import javax.xml.parsers.ParserConfigurationException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.insteon.internal.config.InsteonChannelConfiguration;\n+import org.openhab.binding.insteon.internal.config.InsteonNetworkConfiguration;\n+import org.openhab.binding.insteon.internal.device.DeviceFeature;\n+import org.openhab.binding.insteon.internal.device.DeviceFeatureListener;\n+import org.openhab.binding.insteon.internal.device.DeviceType;\n+import org.openhab.binding.insteon.internal.device.DeviceTypeLoader;\n+import org.openhab.binding.insteon.internal.device.InsteonAddress;\n+import org.openhab.binding.insteon.internal.device.InsteonDevice;\n+import org.openhab.binding.insteon.internal.device.InsteonDevice.DeviceStatus;\n+import org.openhab.binding.insteon.internal.device.RequestQueueManager;\n+import org.openhab.binding.insteon.internal.driver.Driver;\n+import org.openhab.binding.insteon.internal.driver.DriverListener;\n+import org.openhab.binding.insteon.internal.driver.ModemDBEntry;\n+import org.openhab.binding.insteon.internal.driver.Poller;\n+import org.openhab.binding.insteon.internal.handler.InsteonNetworkHandler;\n+import org.openhab.binding.insteon.internal.message.FieldException;\n+import org.openhab.binding.insteon.internal.message.Msg;\n+import org.openhab.binding.insteon.internal.message.MsgListener;\n+import org.openhab.binding.insteon.internal.utils.Utils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.xml.sax.SAXException;\n+\n+/**\n+ * A majority of the code in this file is from the OpenHAB 1 binding\n+ * org.openhab.binding.insteonplm.InsteonPLMActiveBinding. Including the comments below.\n+ *\n+ * -----------------------------------------------------------------------------------------------\n+ *\n+ * This class represents the actual implementation of the binding, and controls the high level flow\n+ * of messages to and from the InsteonModem.\n+ *\n+ * Writing this binding has been an odyssey through the quirks of the Insteon protocol\n+ * and Insteon devices. A substantial redesign was necessary at some point along the way.\n+ * Here are some of the hard learned lessons that should be considered by anyone who wants\n+ * to re-architect the binding:\n+ *\n+ * 1) The entries of the link database of the modem are not reliable. The category/subcategory entries in\n+ * particular have junk data. Forget about using the modem database to generate a list of devices.\n+ * The database should only be used to verify that a device has been linked.\n+ *\n+ * 2) Querying devices for their product information does not work either. First of all, battery operated devices\n+ * (and there are a lot of those) have their radio switched off, and may generally not respond to product\n+ * queries. Even main stream hardwired devices sold presently (like the 2477s switch and the 2477d dimmer)\n+ * don't even have a product ID. Although supposedly part of the Insteon protocol, we have yet to\n+ * encounter a device that would cough up a product id when queried, even among very recent devices. They\n+ * simply return zeros as product id. Lesson: forget about querying devices to generate a device list.\n+ *\n+ * 3) Polling is a thorny issue: too much traffic on the network, and messages will be dropped left and right,\n+ * and not just the poll related ones, but others as well. In particular sending back-to-back messages\n+ * seemed to result in the second message simply never getting sent, without flow control back pressure\n+ * (NACK) from the modem. For now the work-around is to space out the messages upon sending, and\n+ * in general poll as infrequently as acceptable.\n+ *\n+ * 4) Instantiating and tracking devices when reported by the modem (either from the database, or when\n+ * messages are received) leads to complicated state management because there is no guarantee at what\n+ * point (if at all) the binding configuration will be available. It gets even more difficult when\n+ * items are created, destroyed, and modified while the binding runs.\n+ *\n+ * For the above reasons, devices are only instantiated when they are referenced by binding information.\n+ * As nice as it would be to discover devices and their properties dynamically, we have abandoned that\n+ * path because it had led to a complicated and fragile system which due to the technical limitations\n+ * above was inherently squirrely.\n+ *\n+ *\n+ * @author Bernd Pfrommer - Initial contribution\n+ * @author Daniel Pfrommer - OpenHAB 1 insteonplm binding\n+ * @author Rob Nielsen - Port to OpenHAB 2 insteon binding\n+ */\n+@NonNullByDefault\n+public class InsteonBinding {\n+    private static final int DEAD_DEVICE_COUNT = 10;\n+\n+    private final Logger logger = LoggerFactory.getLogger(InsteonBinding.class);\n+\n+    private Driver m_driver = new Driver();\n+    private ConcurrentHashMap<InsteonAddress, InsteonDevice> m_devices = new ConcurrentHashMap<InsteonAddress, InsteonDevice>();\n+    private ConcurrentHashMap<String, InsteonChannelConfiguration> m_bindingConfigs = new ConcurrentHashMap<>();\n+    private PortListener m_portListener = new PortListener();\n+    private int m_devicePollIntervalMilliseconds = 300000;\n+    private int m_deadDeviceTimeout = -1;\n+    private int m_messagesReceived = 0;\n+    private boolean m_isActive = false; // state of binding\n+    private int m_x10HouseUnit = -1;\n+    private InsteonNetworkHandler m_handler;\n+\n+    public InsteonBinding(InsteonNetworkHandler handler, @Nullable InsteonNetworkConfiguration config) {\n+        this.m_handler = handler;\n+\n+        Integer devicePollIntervalSeconds = config.getDevicePollIntervalSeconds();\n+        if (devicePollIntervalSeconds != null) {\n+            m_devicePollIntervalMilliseconds = devicePollIntervalSeconds * 1000;\n+        }\n+        logger.info(\"device poll interval set to {} seconds\", m_devicePollIntervalMilliseconds / 1000);\n+\n+        Integer modemDbRetryTimeoutSeconds = config.getModemDbRetryTimeoutSeconds();\n+        if (modemDbRetryTimeoutSeconds != null) {\n+            logger.info(\"setting modem db retry timeout to {} seconds\", modemDbRetryTimeoutSeconds);\n+            m_driver.setModemDBRetryTimeout(modemDbRetryTimeoutSeconds * 1000);\n+        }\n+\n+        String additionalDevices = config.getAdditionalDevices();\n+        if (additionalDevices != null) {\n+            try {\n+                DeviceTypeLoader.s_instance().loadDeviceTypesXML(additionalDevices);\n+                logger.info(\"read additional device definitions from {}\", additionalDevices);\n+            } catch (ParserConfigurationException | SAXException | IOException e) {\n+                logger.warn(\"error reading additional devices from {}\", additionalDevices, e);\n+            }\n+        }\n+\n+        String additionalFeatures = config.getAdditionalFeatures();\n+        if (additionalFeatures != null) {\n+            logger.info(\"reading additional feature templates from {}\", additionalFeatures);\n+            DeviceFeature.s_readFeatureTemplates(additionalFeatures);\n+        }\n+\n+        m_deadDeviceTimeout = m_devicePollIntervalMilliseconds * DEAD_DEVICE_COUNT;\n+        logger.info(\"dead device timeout set to {} seconds\", m_deadDeviceTimeout / 1000);\n+\n+        String port = config.getPort();\n+        logger.info(\"port = '{}'\", port);\n+        m_driver.addPort(\"port\", port);\n+        m_driver.addMsgListener(m_portListener, port);\n+\n+        logger.debug(\"setting driver listener\");\n+        m_driver.setDriverListener(m_portListener);\n+    }\n+\n+    public boolean startPolling() {\n+        logger.debug(\"starting {} ports\", m_driver.getNumberOfPorts());\n+\n+        m_driver.startAllPorts();\n+        logger.debug(\"ports started\");\n+        switch (m_driver.getNumberOfPorts()) {\n+            case 0:\n+                logger.warn(\"initialization complete, but found no ports!\");\n+                return false;\n+            case 1:\n+                logger.debug(\"initialization complete, found 1 port!\");\n+                break;\n+            default:\n+                logger.warn(\"initialization complete, found {} ports.\", m_driver.getNumberOfPorts());\n+                break;\n+        }\n+\n+        return true;\n+    }\n+\n+    public void setIsActive(boolean isActive) {\n+        m_isActive = isActive;\n+    }\n+\n+    public void sendCommand(String channelName, Command command) {\n+        if (!m_isActive) {\n+            logger.debug(\"not ready to handle commands yet, returning.\");\n+            return;\n+        }\n+\n+        InsteonChannelConfiguration bindingConfig = m_bindingConfigs.get(channelName);\n+        if (bindingConfig == null) {\n+            logger.warn(\"unable to find binding config for channel {}\", channelName);\n+            return;\n+        }\n+\n+        InsteonDevice dev = getDevice(bindingConfig.getAddress());\n+        if (dev == null) {\n+            logger.warn(\"no device found with insteon address {}\", bindingConfig.getAddress());\n+            return;\n+        }\n+\n+        dev.processCommand(m_driver, bindingConfig, command);\n+\n+        logger.debug(\"found binding config for channel {}\", channelName);\n+    }\n+\n+    public void addFeatureListener(InsteonChannelConfiguration bindingConfig) {\n+        logger.debug(\"adding listener for channel {}\", bindingConfig.getChannelName());\n+\n+        InsteonAddress address = bindingConfig.getAddress();\n+        InsteonDevice dev = getDevice(address);\n+        @Nullable\n+        DeviceFeature f = dev.getFeature(bindingConfig.getFeature());\n+        if (f == null || f.isFeatureGroup()) {\n+            StringBuffer buf = new StringBuffer();\n+            ArrayList<String> names = new ArrayList<String>(dev.getFeatures().keySet());\n+            Collections.sort(names);\n+            for (String name : names) {\n+                DeviceFeature feature = dev.getFeature(name);\n+                if (!feature.isFeatureGroup()) {\n+                    if (buf.length() > 0) {\n+                        buf.append(\", \");\n+                    }\n+                    buf.append(name);\n+                }\n+            }\n+\n+            logger.warn(\"channel {} references unknown feature: {}, it will be ignored. Known features for {} are: {}.\",\n+                    bindingConfig.getChannelName(), bindingConfig.getFeature(), bindingConfig.getProductKey(),\n+                    buf.toString());\n+            return;\n+        }\n+\n+        DeviceFeatureListener fl = new DeviceFeatureListener(this, bindingConfig.getChannelUID(),\n+                bindingConfig.getChannelName());\n+        fl.setParameters(bindingConfig.getParameters());\n+        f.addListener(fl);\n+\n+        m_bindingConfigs.put(bindingConfig.getChannelName(), bindingConfig);\n+    }\n+\n+    public void removeFeatureListener(ChannelUID channelUID) {\n+        String channelName = channelUID.getAsString();\n+\n+        logger.debug(\"removing listener for channel {}\", channelName);\n+\n+        for (Iterator<Entry<InsteonAddress, InsteonDevice>> it = m_devices.entrySet().iterator(); it.hasNext();) {\n+            InsteonDevice dev = it.next().getValue();\n+            boolean removedListener = dev.removeFeatureListener(channelName);\n+            if (removedListener) {\n+                logger.trace(\"removed feature listener {} from dev {}\", channelName, dev);\n+            }\n+        }\n+    }\n+\n+    public void updateFeatureState(ChannelUID channelUID, State state) {\n+        m_handler.updateState(channelUID, state);\n+    }\n+\n+    public InsteonDevice makeNewDevice(InsteonAddress addr, String productKey) {\n+        DeviceType dt = DeviceTypeLoader.s_instance().getDeviceType(productKey);\n+        InsteonDevice dev = InsteonDevice.s_makeDevice(dt);\n+        dev.setAddress(addr);\n+        dev.setDriver(m_driver);\n+        dev.addPort(m_driver.getDefaultPort());\n+        if (!dev.hasValidPollingInterval()) {\n+            dev.setPollInterval(m_devicePollIntervalMilliseconds);\n+        }\n+        if (m_driver.isModemDBComplete() && dev.getStatus() != DeviceStatus.POLLING) {\n+            int ndev = checkIfInModemDatabase(dev);\n+            if (dev.hasModemDBEntry()) {\n+                dev.setStatus(DeviceStatus.POLLING);\n+                Poller.s_instance().startPolling(dev, ndev);\n+            }\n+        }\n+        m_devices.put(addr, dev);\n+\n+        m_handler.insteonDeviceWasCreated();\n+\n+        return (dev);\n+    }\n+\n+    public void removeDevice(InsteonAddress addr) {\n+        InsteonDevice dev = m_devices.remove(addr);\n+        if (dev == null) {\n+            return;\n+        }\n+\n+        if (dev.getStatus() == DeviceStatus.POLLING) {\n+            Poller.s_instance().stopPolling(dev);\n+        }\n+    }\n+\n+    /**\n+     * Checks if a device is in the modem link database, and, if the database\n+     * is complete, logs a warning if the device is not present\n+     *\n+     * @param dev The device to search for in the modem database\n+     * @return number of devices in modem database\n+     */\n+    private int checkIfInModemDatabase(InsteonDevice dev) {\n+        InsteonAddress addr = dev.getAddress();\n+        HashMap<InsteonAddress, @Nullable ModemDBEntry> dbes = m_driver.lockModemDBEntries();\n+        if (dbes.containsKey(addr)) {\n+            if (!dev.hasModemDBEntry()) {\n+                logger.info(\"device {} found in the modem database and {}.\", addr, getLinkInfo(dbes, addr));\n+                dev.setHasModemDBEntry(true);\n+            }\n+        } else {\n+            if (m_driver.isModemDBComplete() && !addr.isX10()) {\n+                logger.warn(\"device {} not found in the modem database. Did you forget to link?\", addr);\n+            }\n+        }\n+        int ndev = dbes.size();\n+        m_driver.unlockModemDBEntries();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ed93353c47fa5d457223c66d8f91b1c168a57e23"}, "originalPosition": 316}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjcxNjAxNQ==", "bodyText": "locking needs to be done in a try/finally", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r386716015", "createdAt": "2020-03-02T23:35:48Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.insteon/src/main/java/org/openhab/binding/insteon/internal/InsteonBinding.java", "diffHunk": "@@ -0,0 +1,512 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.insteon.internal;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map.Entry;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import javax.xml.parsers.ParserConfigurationException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.insteon.internal.config.InsteonChannelConfiguration;\n+import org.openhab.binding.insteon.internal.config.InsteonNetworkConfiguration;\n+import org.openhab.binding.insteon.internal.device.DeviceFeature;\n+import org.openhab.binding.insteon.internal.device.DeviceFeatureListener;\n+import org.openhab.binding.insteon.internal.device.DeviceType;\n+import org.openhab.binding.insteon.internal.device.DeviceTypeLoader;\n+import org.openhab.binding.insteon.internal.device.InsteonAddress;\n+import org.openhab.binding.insteon.internal.device.InsteonDevice;\n+import org.openhab.binding.insteon.internal.device.InsteonDevice.DeviceStatus;\n+import org.openhab.binding.insteon.internal.device.RequestQueueManager;\n+import org.openhab.binding.insteon.internal.driver.Driver;\n+import org.openhab.binding.insteon.internal.driver.DriverListener;\n+import org.openhab.binding.insteon.internal.driver.ModemDBEntry;\n+import org.openhab.binding.insteon.internal.driver.Poller;\n+import org.openhab.binding.insteon.internal.handler.InsteonNetworkHandler;\n+import org.openhab.binding.insteon.internal.message.FieldException;\n+import org.openhab.binding.insteon.internal.message.Msg;\n+import org.openhab.binding.insteon.internal.message.MsgListener;\n+import org.openhab.binding.insteon.internal.utils.Utils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.xml.sax.SAXException;\n+\n+/**\n+ * A majority of the code in this file is from the OpenHAB 1 binding\n+ * org.openhab.binding.insteonplm.InsteonPLMActiveBinding. Including the comments below.\n+ *\n+ * -----------------------------------------------------------------------------------------------\n+ *\n+ * This class represents the actual implementation of the binding, and controls the high level flow\n+ * of messages to and from the InsteonModem.\n+ *\n+ * Writing this binding has been an odyssey through the quirks of the Insteon protocol\n+ * and Insteon devices. A substantial redesign was necessary at some point along the way.\n+ * Here are some of the hard learned lessons that should be considered by anyone who wants\n+ * to re-architect the binding:\n+ *\n+ * 1) The entries of the link database of the modem are not reliable. The category/subcategory entries in\n+ * particular have junk data. Forget about using the modem database to generate a list of devices.\n+ * The database should only be used to verify that a device has been linked.\n+ *\n+ * 2) Querying devices for their product information does not work either. First of all, battery operated devices\n+ * (and there are a lot of those) have their radio switched off, and may generally not respond to product\n+ * queries. Even main stream hardwired devices sold presently (like the 2477s switch and the 2477d dimmer)\n+ * don't even have a product ID. Although supposedly part of the Insteon protocol, we have yet to\n+ * encounter a device that would cough up a product id when queried, even among very recent devices. They\n+ * simply return zeros as product id. Lesson: forget about querying devices to generate a device list.\n+ *\n+ * 3) Polling is a thorny issue: too much traffic on the network, and messages will be dropped left and right,\n+ * and not just the poll related ones, but others as well. In particular sending back-to-back messages\n+ * seemed to result in the second message simply never getting sent, without flow control back pressure\n+ * (NACK) from the modem. For now the work-around is to space out the messages upon sending, and\n+ * in general poll as infrequently as acceptable.\n+ *\n+ * 4) Instantiating and tracking devices when reported by the modem (either from the database, or when\n+ * messages are received) leads to complicated state management because there is no guarantee at what\n+ * point (if at all) the binding configuration will be available. It gets even more difficult when\n+ * items are created, destroyed, and modified while the binding runs.\n+ *\n+ * For the above reasons, devices are only instantiated when they are referenced by binding information.\n+ * As nice as it would be to discover devices and their properties dynamically, we have abandoned that\n+ * path because it had led to a complicated and fragile system which due to the technical limitations\n+ * above was inherently squirrely.\n+ *\n+ *\n+ * @author Bernd Pfrommer - Initial contribution\n+ * @author Daniel Pfrommer - OpenHAB 1 insteonplm binding\n+ * @author Rob Nielsen - Port to OpenHAB 2 insteon binding\n+ */\n+@NonNullByDefault\n+public class InsteonBinding {\n+    private static final int DEAD_DEVICE_COUNT = 10;\n+\n+    private final Logger logger = LoggerFactory.getLogger(InsteonBinding.class);\n+\n+    private Driver m_driver = new Driver();\n+    private ConcurrentHashMap<InsteonAddress, InsteonDevice> m_devices = new ConcurrentHashMap<InsteonAddress, InsteonDevice>();\n+    private ConcurrentHashMap<String, InsteonChannelConfiguration> m_bindingConfigs = new ConcurrentHashMap<>();\n+    private PortListener m_portListener = new PortListener();\n+    private int m_devicePollIntervalMilliseconds = 300000;\n+    private int m_deadDeviceTimeout = -1;\n+    private int m_messagesReceived = 0;\n+    private boolean m_isActive = false; // state of binding\n+    private int m_x10HouseUnit = -1;\n+    private InsteonNetworkHandler m_handler;\n+\n+    public InsteonBinding(InsteonNetworkHandler handler, @Nullable InsteonNetworkConfiguration config) {\n+        this.m_handler = handler;\n+\n+        Integer devicePollIntervalSeconds = config.getDevicePollIntervalSeconds();\n+        if (devicePollIntervalSeconds != null) {\n+            m_devicePollIntervalMilliseconds = devicePollIntervalSeconds * 1000;\n+        }\n+        logger.info(\"device poll interval set to {} seconds\", m_devicePollIntervalMilliseconds / 1000);\n+\n+        Integer modemDbRetryTimeoutSeconds = config.getModemDbRetryTimeoutSeconds();\n+        if (modemDbRetryTimeoutSeconds != null) {\n+            logger.info(\"setting modem db retry timeout to {} seconds\", modemDbRetryTimeoutSeconds);\n+            m_driver.setModemDBRetryTimeout(modemDbRetryTimeoutSeconds * 1000);\n+        }\n+\n+        String additionalDevices = config.getAdditionalDevices();\n+        if (additionalDevices != null) {\n+            try {\n+                DeviceTypeLoader.s_instance().loadDeviceTypesXML(additionalDevices);\n+                logger.info(\"read additional device definitions from {}\", additionalDevices);\n+            } catch (ParserConfigurationException | SAXException | IOException e) {\n+                logger.warn(\"error reading additional devices from {}\", additionalDevices, e);\n+            }\n+        }\n+\n+        String additionalFeatures = config.getAdditionalFeatures();\n+        if (additionalFeatures != null) {\n+            logger.info(\"reading additional feature templates from {}\", additionalFeatures);\n+            DeviceFeature.s_readFeatureTemplates(additionalFeatures);\n+        }\n+\n+        m_deadDeviceTimeout = m_devicePollIntervalMilliseconds * DEAD_DEVICE_COUNT;\n+        logger.info(\"dead device timeout set to {} seconds\", m_deadDeviceTimeout / 1000);\n+\n+        String port = config.getPort();\n+        logger.info(\"port = '{}'\", port);\n+        m_driver.addPort(\"port\", port);\n+        m_driver.addMsgListener(m_portListener, port);\n+\n+        logger.debug(\"setting driver listener\");\n+        m_driver.setDriverListener(m_portListener);\n+    }\n+\n+    public boolean startPolling() {\n+        logger.debug(\"starting {} ports\", m_driver.getNumberOfPorts());\n+\n+        m_driver.startAllPorts();\n+        logger.debug(\"ports started\");\n+        switch (m_driver.getNumberOfPorts()) {\n+            case 0:\n+                logger.warn(\"initialization complete, but found no ports!\");\n+                return false;\n+            case 1:\n+                logger.debug(\"initialization complete, found 1 port!\");\n+                break;\n+            default:\n+                logger.warn(\"initialization complete, found {} ports.\", m_driver.getNumberOfPorts());\n+                break;\n+        }\n+\n+        return true;\n+    }\n+\n+    public void setIsActive(boolean isActive) {\n+        m_isActive = isActive;\n+    }\n+\n+    public void sendCommand(String channelName, Command command) {\n+        if (!m_isActive) {\n+            logger.debug(\"not ready to handle commands yet, returning.\");\n+            return;\n+        }\n+\n+        InsteonChannelConfiguration bindingConfig = m_bindingConfigs.get(channelName);\n+        if (bindingConfig == null) {\n+            logger.warn(\"unable to find binding config for channel {}\", channelName);\n+            return;\n+        }\n+\n+        InsteonDevice dev = getDevice(bindingConfig.getAddress());\n+        if (dev == null) {\n+            logger.warn(\"no device found with insteon address {}\", bindingConfig.getAddress());\n+            return;\n+        }\n+\n+        dev.processCommand(m_driver, bindingConfig, command);\n+\n+        logger.debug(\"found binding config for channel {}\", channelName);\n+    }\n+\n+    public void addFeatureListener(InsteonChannelConfiguration bindingConfig) {\n+        logger.debug(\"adding listener for channel {}\", bindingConfig.getChannelName());\n+\n+        InsteonAddress address = bindingConfig.getAddress();\n+        InsteonDevice dev = getDevice(address);\n+        @Nullable\n+        DeviceFeature f = dev.getFeature(bindingConfig.getFeature());\n+        if (f == null || f.isFeatureGroup()) {\n+            StringBuffer buf = new StringBuffer();\n+            ArrayList<String> names = new ArrayList<String>(dev.getFeatures().keySet());\n+            Collections.sort(names);\n+            for (String name : names) {\n+                DeviceFeature feature = dev.getFeature(name);\n+                if (!feature.isFeatureGroup()) {\n+                    if (buf.length() > 0) {\n+                        buf.append(\", \");\n+                    }\n+                    buf.append(name);\n+                }\n+            }\n+\n+            logger.warn(\"channel {} references unknown feature: {}, it will be ignored. Known features for {} are: {}.\",\n+                    bindingConfig.getChannelName(), bindingConfig.getFeature(), bindingConfig.getProductKey(),\n+                    buf.toString());\n+            return;\n+        }\n+\n+        DeviceFeatureListener fl = new DeviceFeatureListener(this, bindingConfig.getChannelUID(),\n+                bindingConfig.getChannelName());\n+        fl.setParameters(bindingConfig.getParameters());\n+        f.addListener(fl);\n+\n+        m_bindingConfigs.put(bindingConfig.getChannelName(), bindingConfig);\n+    }\n+\n+    public void removeFeatureListener(ChannelUID channelUID) {\n+        String channelName = channelUID.getAsString();\n+\n+        logger.debug(\"removing listener for channel {}\", channelName);\n+\n+        for (Iterator<Entry<InsteonAddress, InsteonDevice>> it = m_devices.entrySet().iterator(); it.hasNext();) {\n+            InsteonDevice dev = it.next().getValue();\n+            boolean removedListener = dev.removeFeatureListener(channelName);\n+            if (removedListener) {\n+                logger.trace(\"removed feature listener {} from dev {}\", channelName, dev);\n+            }\n+        }\n+    }\n+\n+    public void updateFeatureState(ChannelUID channelUID, State state) {\n+        m_handler.updateState(channelUID, state);\n+    }\n+\n+    public InsteonDevice makeNewDevice(InsteonAddress addr, String productKey) {\n+        DeviceType dt = DeviceTypeLoader.s_instance().getDeviceType(productKey);\n+        InsteonDevice dev = InsteonDevice.s_makeDevice(dt);\n+        dev.setAddress(addr);\n+        dev.setDriver(m_driver);\n+        dev.addPort(m_driver.getDefaultPort());\n+        if (!dev.hasValidPollingInterval()) {\n+            dev.setPollInterval(m_devicePollIntervalMilliseconds);\n+        }\n+        if (m_driver.isModemDBComplete() && dev.getStatus() != DeviceStatus.POLLING) {\n+            int ndev = checkIfInModemDatabase(dev);\n+            if (dev.hasModemDBEntry()) {\n+                dev.setStatus(DeviceStatus.POLLING);\n+                Poller.s_instance().startPolling(dev, ndev);\n+            }\n+        }\n+        m_devices.put(addr, dev);\n+\n+        m_handler.insteonDeviceWasCreated();\n+\n+        return (dev);\n+    }\n+\n+    public void removeDevice(InsteonAddress addr) {\n+        InsteonDevice dev = m_devices.remove(addr);\n+        if (dev == null) {\n+            return;\n+        }\n+\n+        if (dev.getStatus() == DeviceStatus.POLLING) {\n+            Poller.s_instance().stopPolling(dev);\n+        }\n+    }\n+\n+    /**\n+     * Checks if a device is in the modem link database, and, if the database\n+     * is complete, logs a warning if the device is not present\n+     *\n+     * @param dev The device to search for in the modem database\n+     * @return number of devices in modem database\n+     */\n+    private int checkIfInModemDatabase(InsteonDevice dev) {\n+        InsteonAddress addr = dev.getAddress();\n+        HashMap<InsteonAddress, @Nullable ModemDBEntry> dbes = m_driver.lockModemDBEntries();\n+        if (dbes.containsKey(addr)) {\n+            if (!dev.hasModemDBEntry()) {\n+                logger.info(\"device {} found in the modem database and {}.\", addr, getLinkInfo(dbes, addr));\n+                dev.setHasModemDBEntry(true);\n+            }\n+        } else {\n+            if (m_driver.isModemDBComplete() && !addr.isX10()) {\n+                logger.warn(\"device {} not found in the modem database. Did you forget to link?\", addr);\n+            }\n+        }\n+        int ndev = dbes.size();\n+        m_driver.unlockModemDBEntries();\n+        return ndev;\n+    }\n+\n+    /**\n+     * Everything below was copied from Insteon PLM v1\n+     */\n+\n+    /**\n+     * Clean up all state.\n+     */\n+    public void shutdown() {\n+        logger.debug(\"shutting down Insteon bridge\");\n+        m_driver.stopAllPorts();\n+        m_devices.clear();\n+        RequestQueueManager.s_destroyInstance();\n+        Poller.s_instance().stop();\n+        m_isActive = false;\n+    }\n+\n+    /**\n+     * Method to find a device by address\n+     *\n+     * @param aAddr the insteon address to search for\n+     * @return reference to the device, or null if not found\n+     */\n+    public @Nullable InsteonDevice getDevice(@Nullable InsteonAddress aAddr) {\n+        InsteonDevice dev = (aAddr == null) ? null : m_devices.get(aAddr);\n+        return (dev);\n+    }\n+\n+    private String getLinkInfo(HashMap<InsteonAddress, @Nullable ModemDBEntry> dbes, InsteonAddress a) {\n+        ModemDBEntry dbe = dbes.get(a);\n+        ArrayList<Byte> controls = dbe.getControls();\n+        ArrayList<Byte> responds = dbe.getRespondsTo();\n+\n+        StringBuffer buf = new StringBuffer(\"the modem\");\n+        if (!controls.isEmpty()) {\n+            buf.append(\" controls groups [\");\n+            buf.append(toGroupString(controls));\n+            buf.append(\"]\");\n+        }\n+\n+        if (!responds.isEmpty()) {\n+            if (!controls.isEmpty()) {\n+                buf.append(\" and\");\n+            }\n+\n+            buf.append(\" responds to groups [\");\n+            buf.append(toGroupString(responds));\n+            buf.append(\"]\");\n+        }\n+\n+        return buf.toString();\n+    }\n+\n+    private String toGroupString(ArrayList<Byte> group) {\n+        ArrayList<Byte> sorted = new ArrayList<Byte>(group);\n+        Collections.sort(sorted);\n+\n+        StringBuffer buf = new StringBuffer();\n+        for (Byte b : sorted) {\n+            if (buf.length() > 0) {\n+                buf.append(\",\");\n+            }\n+            buf.append(\"0x\");\n+            buf.append(Utils.getHexString(b));\n+        }\n+\n+        return buf.toString();\n+    }\n+\n+    public void logDeviceStatistics() {\n+        String msg = String.format(\"devices: %3d configured, %3d polling, msgs received: %5d\", m_devices.size(),\n+                Poller.s_instance().getSizeOfQueue(), m_messagesReceived);\n+        logger.info(\"{}\", msg);\n+        m_messagesReceived = 0;\n+        for (InsteonDevice dev : m_devices.values()) {\n+            if (dev.isModem()) {\n+                continue;\n+            }\n+            if (m_deadDeviceTimeout > 0 && dev.getPollOverDueTime() > m_deadDeviceTimeout) {\n+                logger.info(\"device {} has not responded to polls for {} sec\", dev.toString(),\n+                        dev.getPollOverDueTime() / 3600);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Handles messages that come in from the ports.\n+     * Will only process one message at a time.\n+     */\n+    @NonNullByDefault\n+    private class PortListener implements MsgListener, DriverListener {\n+        @Override\n+        public void msg(Msg msg, String fromPort) {\n+            if (msg.isEcho() || msg.isPureNack()) {\n+                return;\n+            }\n+            m_messagesReceived++;\n+            logger.debug(\"got msg: {}\", msg);\n+            if (msg.isX10()) {\n+                handleX10Message(msg, fromPort);\n+            } else {\n+                handleInsteonMessage(msg, fromPort);\n+            }\n+\n+        }\n+\n+        @Override\n+        public void driverCompletelyInitialized() {\n+            HashMap<InsteonAddress, @Nullable ModemDBEntry> dbes = m_driver.lockModemDBEntries();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ed93353c47fa5d457223c66d8f91b1c168a57e23"}, "originalPosition": 427}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjcxNjMwNg==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    StringBuffer buf = new StringBuffer();\n          \n          \n            \n                    StringBuilder buf = new StringBuilder();", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r386716306", "createdAt": "2020-03-02T23:36:40Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.insteon/src/main/java/org/openhab/binding/insteon/internal/InsteonBinding.java", "diffHunk": "@@ -0,0 +1,512 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.insteon.internal;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map.Entry;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import javax.xml.parsers.ParserConfigurationException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.insteon.internal.config.InsteonChannelConfiguration;\n+import org.openhab.binding.insteon.internal.config.InsteonNetworkConfiguration;\n+import org.openhab.binding.insteon.internal.device.DeviceFeature;\n+import org.openhab.binding.insteon.internal.device.DeviceFeatureListener;\n+import org.openhab.binding.insteon.internal.device.DeviceType;\n+import org.openhab.binding.insteon.internal.device.DeviceTypeLoader;\n+import org.openhab.binding.insteon.internal.device.InsteonAddress;\n+import org.openhab.binding.insteon.internal.device.InsteonDevice;\n+import org.openhab.binding.insteon.internal.device.InsteonDevice.DeviceStatus;\n+import org.openhab.binding.insteon.internal.device.RequestQueueManager;\n+import org.openhab.binding.insteon.internal.driver.Driver;\n+import org.openhab.binding.insteon.internal.driver.DriverListener;\n+import org.openhab.binding.insteon.internal.driver.ModemDBEntry;\n+import org.openhab.binding.insteon.internal.driver.Poller;\n+import org.openhab.binding.insteon.internal.handler.InsteonNetworkHandler;\n+import org.openhab.binding.insteon.internal.message.FieldException;\n+import org.openhab.binding.insteon.internal.message.Msg;\n+import org.openhab.binding.insteon.internal.message.MsgListener;\n+import org.openhab.binding.insteon.internal.utils.Utils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.xml.sax.SAXException;\n+\n+/**\n+ * A majority of the code in this file is from the OpenHAB 1 binding\n+ * org.openhab.binding.insteonplm.InsteonPLMActiveBinding. Including the comments below.\n+ *\n+ * -----------------------------------------------------------------------------------------------\n+ *\n+ * This class represents the actual implementation of the binding, and controls the high level flow\n+ * of messages to and from the InsteonModem.\n+ *\n+ * Writing this binding has been an odyssey through the quirks of the Insteon protocol\n+ * and Insteon devices. A substantial redesign was necessary at some point along the way.\n+ * Here are some of the hard learned lessons that should be considered by anyone who wants\n+ * to re-architect the binding:\n+ *\n+ * 1) The entries of the link database of the modem are not reliable. The category/subcategory entries in\n+ * particular have junk data. Forget about using the modem database to generate a list of devices.\n+ * The database should only be used to verify that a device has been linked.\n+ *\n+ * 2) Querying devices for their product information does not work either. First of all, battery operated devices\n+ * (and there are a lot of those) have their radio switched off, and may generally not respond to product\n+ * queries. Even main stream hardwired devices sold presently (like the 2477s switch and the 2477d dimmer)\n+ * don't even have a product ID. Although supposedly part of the Insteon protocol, we have yet to\n+ * encounter a device that would cough up a product id when queried, even among very recent devices. They\n+ * simply return zeros as product id. Lesson: forget about querying devices to generate a device list.\n+ *\n+ * 3) Polling is a thorny issue: too much traffic on the network, and messages will be dropped left and right,\n+ * and not just the poll related ones, but others as well. In particular sending back-to-back messages\n+ * seemed to result in the second message simply never getting sent, without flow control back pressure\n+ * (NACK) from the modem. For now the work-around is to space out the messages upon sending, and\n+ * in general poll as infrequently as acceptable.\n+ *\n+ * 4) Instantiating and tracking devices when reported by the modem (either from the database, or when\n+ * messages are received) leads to complicated state management because there is no guarantee at what\n+ * point (if at all) the binding configuration will be available. It gets even more difficult when\n+ * items are created, destroyed, and modified while the binding runs.\n+ *\n+ * For the above reasons, devices are only instantiated when they are referenced by binding information.\n+ * As nice as it would be to discover devices and their properties dynamically, we have abandoned that\n+ * path because it had led to a complicated and fragile system which due to the technical limitations\n+ * above was inherently squirrely.\n+ *\n+ *\n+ * @author Bernd Pfrommer - Initial contribution\n+ * @author Daniel Pfrommer - OpenHAB 1 insteonplm binding\n+ * @author Rob Nielsen - Port to OpenHAB 2 insteon binding\n+ */\n+@NonNullByDefault\n+public class InsteonBinding {\n+    private static final int DEAD_DEVICE_COUNT = 10;\n+\n+    private final Logger logger = LoggerFactory.getLogger(InsteonBinding.class);\n+\n+    private Driver m_driver = new Driver();\n+    private ConcurrentHashMap<InsteonAddress, InsteonDevice> m_devices = new ConcurrentHashMap<InsteonAddress, InsteonDevice>();\n+    private ConcurrentHashMap<String, InsteonChannelConfiguration> m_bindingConfigs = new ConcurrentHashMap<>();\n+    private PortListener m_portListener = new PortListener();\n+    private int m_devicePollIntervalMilliseconds = 300000;\n+    private int m_deadDeviceTimeout = -1;\n+    private int m_messagesReceived = 0;\n+    private boolean m_isActive = false; // state of binding\n+    private int m_x10HouseUnit = -1;\n+    private InsteonNetworkHandler m_handler;\n+\n+    public InsteonBinding(InsteonNetworkHandler handler, @Nullable InsteonNetworkConfiguration config) {\n+        this.m_handler = handler;\n+\n+        Integer devicePollIntervalSeconds = config.getDevicePollIntervalSeconds();\n+        if (devicePollIntervalSeconds != null) {\n+            m_devicePollIntervalMilliseconds = devicePollIntervalSeconds * 1000;\n+        }\n+        logger.info(\"device poll interval set to {} seconds\", m_devicePollIntervalMilliseconds / 1000);\n+\n+        Integer modemDbRetryTimeoutSeconds = config.getModemDbRetryTimeoutSeconds();\n+        if (modemDbRetryTimeoutSeconds != null) {\n+            logger.info(\"setting modem db retry timeout to {} seconds\", modemDbRetryTimeoutSeconds);\n+            m_driver.setModemDBRetryTimeout(modemDbRetryTimeoutSeconds * 1000);\n+        }\n+\n+        String additionalDevices = config.getAdditionalDevices();\n+        if (additionalDevices != null) {\n+            try {\n+                DeviceTypeLoader.s_instance().loadDeviceTypesXML(additionalDevices);\n+                logger.info(\"read additional device definitions from {}\", additionalDevices);\n+            } catch (ParserConfigurationException | SAXException | IOException e) {\n+                logger.warn(\"error reading additional devices from {}\", additionalDevices, e);\n+            }\n+        }\n+\n+        String additionalFeatures = config.getAdditionalFeatures();\n+        if (additionalFeatures != null) {\n+            logger.info(\"reading additional feature templates from {}\", additionalFeatures);\n+            DeviceFeature.s_readFeatureTemplates(additionalFeatures);\n+        }\n+\n+        m_deadDeviceTimeout = m_devicePollIntervalMilliseconds * DEAD_DEVICE_COUNT;\n+        logger.info(\"dead device timeout set to {} seconds\", m_deadDeviceTimeout / 1000);\n+\n+        String port = config.getPort();\n+        logger.info(\"port = '{}'\", port);\n+        m_driver.addPort(\"port\", port);\n+        m_driver.addMsgListener(m_portListener, port);\n+\n+        logger.debug(\"setting driver listener\");\n+        m_driver.setDriverListener(m_portListener);\n+    }\n+\n+    public boolean startPolling() {\n+        logger.debug(\"starting {} ports\", m_driver.getNumberOfPorts());\n+\n+        m_driver.startAllPorts();\n+        logger.debug(\"ports started\");\n+        switch (m_driver.getNumberOfPorts()) {\n+            case 0:\n+                logger.warn(\"initialization complete, but found no ports!\");\n+                return false;\n+            case 1:\n+                logger.debug(\"initialization complete, found 1 port!\");\n+                break;\n+            default:\n+                logger.warn(\"initialization complete, found {} ports.\", m_driver.getNumberOfPorts());\n+                break;\n+        }\n+\n+        return true;\n+    }\n+\n+    public void setIsActive(boolean isActive) {\n+        m_isActive = isActive;\n+    }\n+\n+    public void sendCommand(String channelName, Command command) {\n+        if (!m_isActive) {\n+            logger.debug(\"not ready to handle commands yet, returning.\");\n+            return;\n+        }\n+\n+        InsteonChannelConfiguration bindingConfig = m_bindingConfigs.get(channelName);\n+        if (bindingConfig == null) {\n+            logger.warn(\"unable to find binding config for channel {}\", channelName);\n+            return;\n+        }\n+\n+        InsteonDevice dev = getDevice(bindingConfig.getAddress());\n+        if (dev == null) {\n+            logger.warn(\"no device found with insteon address {}\", bindingConfig.getAddress());\n+            return;\n+        }\n+\n+        dev.processCommand(m_driver, bindingConfig, command);\n+\n+        logger.debug(\"found binding config for channel {}\", channelName);\n+    }\n+\n+    public void addFeatureListener(InsteonChannelConfiguration bindingConfig) {\n+        logger.debug(\"adding listener for channel {}\", bindingConfig.getChannelName());\n+\n+        InsteonAddress address = bindingConfig.getAddress();\n+        InsteonDevice dev = getDevice(address);\n+        @Nullable\n+        DeviceFeature f = dev.getFeature(bindingConfig.getFeature());\n+        if (f == null || f.isFeatureGroup()) {\n+            StringBuffer buf = new StringBuffer();\n+            ArrayList<String> names = new ArrayList<String>(dev.getFeatures().keySet());\n+            Collections.sort(names);\n+            for (String name : names) {\n+                DeviceFeature feature = dev.getFeature(name);\n+                if (!feature.isFeatureGroup()) {\n+                    if (buf.length() > 0) {\n+                        buf.append(\", \");\n+                    }\n+                    buf.append(name);\n+                }\n+            }\n+\n+            logger.warn(\"channel {} references unknown feature: {}, it will be ignored. Known features for {} are: {}.\",\n+                    bindingConfig.getChannelName(), bindingConfig.getFeature(), bindingConfig.getProductKey(),\n+                    buf.toString());\n+            return;\n+        }\n+\n+        DeviceFeatureListener fl = new DeviceFeatureListener(this, bindingConfig.getChannelUID(),\n+                bindingConfig.getChannelName());\n+        fl.setParameters(bindingConfig.getParameters());\n+        f.addListener(fl);\n+\n+        m_bindingConfigs.put(bindingConfig.getChannelName(), bindingConfig);\n+    }\n+\n+    public void removeFeatureListener(ChannelUID channelUID) {\n+        String channelName = channelUID.getAsString();\n+\n+        logger.debug(\"removing listener for channel {}\", channelName);\n+\n+        for (Iterator<Entry<InsteonAddress, InsteonDevice>> it = m_devices.entrySet().iterator(); it.hasNext();) {\n+            InsteonDevice dev = it.next().getValue();\n+            boolean removedListener = dev.removeFeatureListener(channelName);\n+            if (removedListener) {\n+                logger.trace(\"removed feature listener {} from dev {}\", channelName, dev);\n+            }\n+        }\n+    }\n+\n+    public void updateFeatureState(ChannelUID channelUID, State state) {\n+        m_handler.updateState(channelUID, state);\n+    }\n+\n+    public InsteonDevice makeNewDevice(InsteonAddress addr, String productKey) {\n+        DeviceType dt = DeviceTypeLoader.s_instance().getDeviceType(productKey);\n+        InsteonDevice dev = InsteonDevice.s_makeDevice(dt);\n+        dev.setAddress(addr);\n+        dev.setDriver(m_driver);\n+        dev.addPort(m_driver.getDefaultPort());\n+        if (!dev.hasValidPollingInterval()) {\n+            dev.setPollInterval(m_devicePollIntervalMilliseconds);\n+        }\n+        if (m_driver.isModemDBComplete() && dev.getStatus() != DeviceStatus.POLLING) {\n+            int ndev = checkIfInModemDatabase(dev);\n+            if (dev.hasModemDBEntry()) {\n+                dev.setStatus(DeviceStatus.POLLING);\n+                Poller.s_instance().startPolling(dev, ndev);\n+            }\n+        }\n+        m_devices.put(addr, dev);\n+\n+        m_handler.insteonDeviceWasCreated();\n+\n+        return (dev);\n+    }\n+\n+    public void removeDevice(InsteonAddress addr) {\n+        InsteonDevice dev = m_devices.remove(addr);\n+        if (dev == null) {\n+            return;\n+        }\n+\n+        if (dev.getStatus() == DeviceStatus.POLLING) {\n+            Poller.s_instance().stopPolling(dev);\n+        }\n+    }\n+\n+    /**\n+     * Checks if a device is in the modem link database, and, if the database\n+     * is complete, logs a warning if the device is not present\n+     *\n+     * @param dev The device to search for in the modem database\n+     * @return number of devices in modem database\n+     */\n+    private int checkIfInModemDatabase(InsteonDevice dev) {\n+        InsteonAddress addr = dev.getAddress();\n+        HashMap<InsteonAddress, @Nullable ModemDBEntry> dbes = m_driver.lockModemDBEntries();\n+        if (dbes.containsKey(addr)) {\n+            if (!dev.hasModemDBEntry()) {\n+                logger.info(\"device {} found in the modem database and {}.\", addr, getLinkInfo(dbes, addr));\n+                dev.setHasModemDBEntry(true);\n+            }\n+        } else {\n+            if (m_driver.isModemDBComplete() && !addr.isX10()) {\n+                logger.warn(\"device {} not found in the modem database. Did you forget to link?\", addr);\n+            }\n+        }\n+        int ndev = dbes.size();\n+        m_driver.unlockModemDBEntries();\n+        return ndev;\n+    }\n+\n+    /**\n+     * Everything below was copied from Insteon PLM v1\n+     */\n+\n+    /**\n+     * Clean up all state.\n+     */\n+    public void shutdown() {\n+        logger.debug(\"shutting down Insteon bridge\");\n+        m_driver.stopAllPorts();\n+        m_devices.clear();\n+        RequestQueueManager.s_destroyInstance();\n+        Poller.s_instance().stop();\n+        m_isActive = false;\n+    }\n+\n+    /**\n+     * Method to find a device by address\n+     *\n+     * @param aAddr the insteon address to search for\n+     * @return reference to the device, or null if not found\n+     */\n+    public @Nullable InsteonDevice getDevice(@Nullable InsteonAddress aAddr) {\n+        InsteonDevice dev = (aAddr == null) ? null : m_devices.get(aAddr);\n+        return (dev);\n+    }\n+\n+    private String getLinkInfo(HashMap<InsteonAddress, @Nullable ModemDBEntry> dbes, InsteonAddress a) {\n+        ModemDBEntry dbe = dbes.get(a);\n+        ArrayList<Byte> controls = dbe.getControls();\n+        ArrayList<Byte> responds = dbe.getRespondsTo();\n+\n+        StringBuffer buf = new StringBuffer(\"the modem\");\n+        if (!controls.isEmpty()) {\n+            buf.append(\" controls groups [\");\n+            buf.append(toGroupString(controls));\n+            buf.append(\"]\");\n+        }\n+\n+        if (!responds.isEmpty()) {\n+            if (!controls.isEmpty()) {\n+                buf.append(\" and\");\n+            }\n+\n+            buf.append(\" responds to groups [\");\n+            buf.append(toGroupString(responds));\n+            buf.append(\"]\");\n+        }\n+\n+        return buf.toString();\n+    }\n+\n+    private String toGroupString(ArrayList<Byte> group) {\n+        ArrayList<Byte> sorted = new ArrayList<Byte>(group);\n+        Collections.sort(sorted);\n+\n+        StringBuffer buf = new StringBuffer();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ed93353c47fa5d457223c66d8f91b1c168a57e23"}, "originalPosition": 376}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjcxODA4MA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    StringBuffer buf = new StringBuffer(\"the modem\");\n          \n          \n            \n                    StringBuilder buf = new StringBuilder(\"the modem\");", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r386718080", "createdAt": "2020-03-02T23:41:48Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.insteon/src/main/java/org/openhab/binding/insteon/internal/InsteonBinding.java", "diffHunk": "@@ -0,0 +1,512 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.insteon.internal;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map.Entry;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import javax.xml.parsers.ParserConfigurationException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.insteon.internal.config.InsteonChannelConfiguration;\n+import org.openhab.binding.insteon.internal.config.InsteonNetworkConfiguration;\n+import org.openhab.binding.insteon.internal.device.DeviceFeature;\n+import org.openhab.binding.insteon.internal.device.DeviceFeatureListener;\n+import org.openhab.binding.insteon.internal.device.DeviceType;\n+import org.openhab.binding.insteon.internal.device.DeviceTypeLoader;\n+import org.openhab.binding.insteon.internal.device.InsteonAddress;\n+import org.openhab.binding.insteon.internal.device.InsteonDevice;\n+import org.openhab.binding.insteon.internal.device.InsteonDevice.DeviceStatus;\n+import org.openhab.binding.insteon.internal.device.RequestQueueManager;\n+import org.openhab.binding.insteon.internal.driver.Driver;\n+import org.openhab.binding.insteon.internal.driver.DriverListener;\n+import org.openhab.binding.insteon.internal.driver.ModemDBEntry;\n+import org.openhab.binding.insteon.internal.driver.Poller;\n+import org.openhab.binding.insteon.internal.handler.InsteonNetworkHandler;\n+import org.openhab.binding.insteon.internal.message.FieldException;\n+import org.openhab.binding.insteon.internal.message.Msg;\n+import org.openhab.binding.insteon.internal.message.MsgListener;\n+import org.openhab.binding.insteon.internal.utils.Utils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.xml.sax.SAXException;\n+\n+/**\n+ * A majority of the code in this file is from the OpenHAB 1 binding\n+ * org.openhab.binding.insteonplm.InsteonPLMActiveBinding. Including the comments below.\n+ *\n+ * -----------------------------------------------------------------------------------------------\n+ *\n+ * This class represents the actual implementation of the binding, and controls the high level flow\n+ * of messages to and from the InsteonModem.\n+ *\n+ * Writing this binding has been an odyssey through the quirks of the Insteon protocol\n+ * and Insteon devices. A substantial redesign was necessary at some point along the way.\n+ * Here are some of the hard learned lessons that should be considered by anyone who wants\n+ * to re-architect the binding:\n+ *\n+ * 1) The entries of the link database of the modem are not reliable. The category/subcategory entries in\n+ * particular have junk data. Forget about using the modem database to generate a list of devices.\n+ * The database should only be used to verify that a device has been linked.\n+ *\n+ * 2) Querying devices for their product information does not work either. First of all, battery operated devices\n+ * (and there are a lot of those) have their radio switched off, and may generally not respond to product\n+ * queries. Even main stream hardwired devices sold presently (like the 2477s switch and the 2477d dimmer)\n+ * don't even have a product ID. Although supposedly part of the Insteon protocol, we have yet to\n+ * encounter a device that would cough up a product id when queried, even among very recent devices. They\n+ * simply return zeros as product id. Lesson: forget about querying devices to generate a device list.\n+ *\n+ * 3) Polling is a thorny issue: too much traffic on the network, and messages will be dropped left and right,\n+ * and not just the poll related ones, but others as well. In particular sending back-to-back messages\n+ * seemed to result in the second message simply never getting sent, without flow control back pressure\n+ * (NACK) from the modem. For now the work-around is to space out the messages upon sending, and\n+ * in general poll as infrequently as acceptable.\n+ *\n+ * 4) Instantiating and tracking devices when reported by the modem (either from the database, or when\n+ * messages are received) leads to complicated state management because there is no guarantee at what\n+ * point (if at all) the binding configuration will be available. It gets even more difficult when\n+ * items are created, destroyed, and modified while the binding runs.\n+ *\n+ * For the above reasons, devices are only instantiated when they are referenced by binding information.\n+ * As nice as it would be to discover devices and their properties dynamically, we have abandoned that\n+ * path because it had led to a complicated and fragile system which due to the technical limitations\n+ * above was inherently squirrely.\n+ *\n+ *\n+ * @author Bernd Pfrommer - Initial contribution\n+ * @author Daniel Pfrommer - OpenHAB 1 insteonplm binding\n+ * @author Rob Nielsen - Port to OpenHAB 2 insteon binding\n+ */\n+@NonNullByDefault\n+public class InsteonBinding {\n+    private static final int DEAD_DEVICE_COUNT = 10;\n+\n+    private final Logger logger = LoggerFactory.getLogger(InsteonBinding.class);\n+\n+    private Driver m_driver = new Driver();\n+    private ConcurrentHashMap<InsteonAddress, InsteonDevice> m_devices = new ConcurrentHashMap<InsteonAddress, InsteonDevice>();\n+    private ConcurrentHashMap<String, InsteonChannelConfiguration> m_bindingConfigs = new ConcurrentHashMap<>();\n+    private PortListener m_portListener = new PortListener();\n+    private int m_devicePollIntervalMilliseconds = 300000;\n+    private int m_deadDeviceTimeout = -1;\n+    private int m_messagesReceived = 0;\n+    private boolean m_isActive = false; // state of binding\n+    private int m_x10HouseUnit = -1;\n+    private InsteonNetworkHandler m_handler;\n+\n+    public InsteonBinding(InsteonNetworkHandler handler, @Nullable InsteonNetworkConfiguration config) {\n+        this.m_handler = handler;\n+\n+        Integer devicePollIntervalSeconds = config.getDevicePollIntervalSeconds();\n+        if (devicePollIntervalSeconds != null) {\n+            m_devicePollIntervalMilliseconds = devicePollIntervalSeconds * 1000;\n+        }\n+        logger.info(\"device poll interval set to {} seconds\", m_devicePollIntervalMilliseconds / 1000);\n+\n+        Integer modemDbRetryTimeoutSeconds = config.getModemDbRetryTimeoutSeconds();\n+        if (modemDbRetryTimeoutSeconds != null) {\n+            logger.info(\"setting modem db retry timeout to {} seconds\", modemDbRetryTimeoutSeconds);\n+            m_driver.setModemDBRetryTimeout(modemDbRetryTimeoutSeconds * 1000);\n+        }\n+\n+        String additionalDevices = config.getAdditionalDevices();\n+        if (additionalDevices != null) {\n+            try {\n+                DeviceTypeLoader.s_instance().loadDeviceTypesXML(additionalDevices);\n+                logger.info(\"read additional device definitions from {}\", additionalDevices);\n+            } catch (ParserConfigurationException | SAXException | IOException e) {\n+                logger.warn(\"error reading additional devices from {}\", additionalDevices, e);\n+            }\n+        }\n+\n+        String additionalFeatures = config.getAdditionalFeatures();\n+        if (additionalFeatures != null) {\n+            logger.info(\"reading additional feature templates from {}\", additionalFeatures);\n+            DeviceFeature.s_readFeatureTemplates(additionalFeatures);\n+        }\n+\n+        m_deadDeviceTimeout = m_devicePollIntervalMilliseconds * DEAD_DEVICE_COUNT;\n+        logger.info(\"dead device timeout set to {} seconds\", m_deadDeviceTimeout / 1000);\n+\n+        String port = config.getPort();\n+        logger.info(\"port = '{}'\", port);\n+        m_driver.addPort(\"port\", port);\n+        m_driver.addMsgListener(m_portListener, port);\n+\n+        logger.debug(\"setting driver listener\");\n+        m_driver.setDriverListener(m_portListener);\n+    }\n+\n+    public boolean startPolling() {\n+        logger.debug(\"starting {} ports\", m_driver.getNumberOfPorts());\n+\n+        m_driver.startAllPorts();\n+        logger.debug(\"ports started\");\n+        switch (m_driver.getNumberOfPorts()) {\n+            case 0:\n+                logger.warn(\"initialization complete, but found no ports!\");\n+                return false;\n+            case 1:\n+                logger.debug(\"initialization complete, found 1 port!\");\n+                break;\n+            default:\n+                logger.warn(\"initialization complete, found {} ports.\", m_driver.getNumberOfPorts());\n+                break;\n+        }\n+\n+        return true;\n+    }\n+\n+    public void setIsActive(boolean isActive) {\n+        m_isActive = isActive;\n+    }\n+\n+    public void sendCommand(String channelName, Command command) {\n+        if (!m_isActive) {\n+            logger.debug(\"not ready to handle commands yet, returning.\");\n+            return;\n+        }\n+\n+        InsteonChannelConfiguration bindingConfig = m_bindingConfigs.get(channelName);\n+        if (bindingConfig == null) {\n+            logger.warn(\"unable to find binding config for channel {}\", channelName);\n+            return;\n+        }\n+\n+        InsteonDevice dev = getDevice(bindingConfig.getAddress());\n+        if (dev == null) {\n+            logger.warn(\"no device found with insteon address {}\", bindingConfig.getAddress());\n+            return;\n+        }\n+\n+        dev.processCommand(m_driver, bindingConfig, command);\n+\n+        logger.debug(\"found binding config for channel {}\", channelName);\n+    }\n+\n+    public void addFeatureListener(InsteonChannelConfiguration bindingConfig) {\n+        logger.debug(\"adding listener for channel {}\", bindingConfig.getChannelName());\n+\n+        InsteonAddress address = bindingConfig.getAddress();\n+        InsteonDevice dev = getDevice(address);\n+        @Nullable\n+        DeviceFeature f = dev.getFeature(bindingConfig.getFeature());\n+        if (f == null || f.isFeatureGroup()) {\n+            StringBuffer buf = new StringBuffer();\n+            ArrayList<String> names = new ArrayList<String>(dev.getFeatures().keySet());\n+            Collections.sort(names);\n+            for (String name : names) {\n+                DeviceFeature feature = dev.getFeature(name);\n+                if (!feature.isFeatureGroup()) {\n+                    if (buf.length() > 0) {\n+                        buf.append(\", \");\n+                    }\n+                    buf.append(name);\n+                }\n+            }\n+\n+            logger.warn(\"channel {} references unknown feature: {}, it will be ignored. Known features for {} are: {}.\",\n+                    bindingConfig.getChannelName(), bindingConfig.getFeature(), bindingConfig.getProductKey(),\n+                    buf.toString());\n+            return;\n+        }\n+\n+        DeviceFeatureListener fl = new DeviceFeatureListener(this, bindingConfig.getChannelUID(),\n+                bindingConfig.getChannelName());\n+        fl.setParameters(bindingConfig.getParameters());\n+        f.addListener(fl);\n+\n+        m_bindingConfigs.put(bindingConfig.getChannelName(), bindingConfig);\n+    }\n+\n+    public void removeFeatureListener(ChannelUID channelUID) {\n+        String channelName = channelUID.getAsString();\n+\n+        logger.debug(\"removing listener for channel {}\", channelName);\n+\n+        for (Iterator<Entry<InsteonAddress, InsteonDevice>> it = m_devices.entrySet().iterator(); it.hasNext();) {\n+            InsteonDevice dev = it.next().getValue();\n+            boolean removedListener = dev.removeFeatureListener(channelName);\n+            if (removedListener) {\n+                logger.trace(\"removed feature listener {} from dev {}\", channelName, dev);\n+            }\n+        }\n+    }\n+\n+    public void updateFeatureState(ChannelUID channelUID, State state) {\n+        m_handler.updateState(channelUID, state);\n+    }\n+\n+    public InsteonDevice makeNewDevice(InsteonAddress addr, String productKey) {\n+        DeviceType dt = DeviceTypeLoader.s_instance().getDeviceType(productKey);\n+        InsteonDevice dev = InsteonDevice.s_makeDevice(dt);\n+        dev.setAddress(addr);\n+        dev.setDriver(m_driver);\n+        dev.addPort(m_driver.getDefaultPort());\n+        if (!dev.hasValidPollingInterval()) {\n+            dev.setPollInterval(m_devicePollIntervalMilliseconds);\n+        }\n+        if (m_driver.isModemDBComplete() && dev.getStatus() != DeviceStatus.POLLING) {\n+            int ndev = checkIfInModemDatabase(dev);\n+            if (dev.hasModemDBEntry()) {\n+                dev.setStatus(DeviceStatus.POLLING);\n+                Poller.s_instance().startPolling(dev, ndev);\n+            }\n+        }\n+        m_devices.put(addr, dev);\n+\n+        m_handler.insteonDeviceWasCreated();\n+\n+        return (dev);\n+    }\n+\n+    public void removeDevice(InsteonAddress addr) {\n+        InsteonDevice dev = m_devices.remove(addr);\n+        if (dev == null) {\n+            return;\n+        }\n+\n+        if (dev.getStatus() == DeviceStatus.POLLING) {\n+            Poller.s_instance().stopPolling(dev);\n+        }\n+    }\n+\n+    /**\n+     * Checks if a device is in the modem link database, and, if the database\n+     * is complete, logs a warning if the device is not present\n+     *\n+     * @param dev The device to search for in the modem database\n+     * @return number of devices in modem database\n+     */\n+    private int checkIfInModemDatabase(InsteonDevice dev) {\n+        InsteonAddress addr = dev.getAddress();\n+        HashMap<InsteonAddress, @Nullable ModemDBEntry> dbes = m_driver.lockModemDBEntries();\n+        if (dbes.containsKey(addr)) {\n+            if (!dev.hasModemDBEntry()) {\n+                logger.info(\"device {} found in the modem database and {}.\", addr, getLinkInfo(dbes, addr));\n+                dev.setHasModemDBEntry(true);\n+            }\n+        } else {\n+            if (m_driver.isModemDBComplete() && !addr.isX10()) {\n+                logger.warn(\"device {} not found in the modem database. Did you forget to link?\", addr);\n+            }\n+        }\n+        int ndev = dbes.size();\n+        m_driver.unlockModemDBEntries();\n+        return ndev;\n+    }\n+\n+    /**\n+     * Everything below was copied from Insteon PLM v1\n+     */\n+\n+    /**\n+     * Clean up all state.\n+     */\n+    public void shutdown() {\n+        logger.debug(\"shutting down Insteon bridge\");\n+        m_driver.stopAllPorts();\n+        m_devices.clear();\n+        RequestQueueManager.s_destroyInstance();\n+        Poller.s_instance().stop();\n+        m_isActive = false;\n+    }\n+\n+    /**\n+     * Method to find a device by address\n+     *\n+     * @param aAddr the insteon address to search for\n+     * @return reference to the device, or null if not found\n+     */\n+    public @Nullable InsteonDevice getDevice(@Nullable InsteonAddress aAddr) {\n+        InsteonDevice dev = (aAddr == null) ? null : m_devices.get(aAddr);\n+        return (dev);\n+    }\n+\n+    private String getLinkInfo(HashMap<InsteonAddress, @Nullable ModemDBEntry> dbes, InsteonAddress a) {\n+        ModemDBEntry dbe = dbes.get(a);\n+        ArrayList<Byte> controls = dbe.getControls();\n+        ArrayList<Byte> responds = dbe.getRespondsTo();\n+\n+        StringBuffer buf = new StringBuffer(\"the modem\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ed93353c47fa5d457223c66d8f91b1c168a57e23"}, "originalPosition": 352}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjcxODI0Nw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    logger.info(\"{}\", msg);\n          \n          \n            \n                    logger.debug(\"{}\", msg);", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r386718247", "createdAt": "2020-03-02T23:42:19Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.insteon/src/main/java/org/openhab/binding/insteon/internal/InsteonBinding.java", "diffHunk": "@@ -0,0 +1,512 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.insteon.internal;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map.Entry;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import javax.xml.parsers.ParserConfigurationException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.insteon.internal.config.InsteonChannelConfiguration;\n+import org.openhab.binding.insteon.internal.config.InsteonNetworkConfiguration;\n+import org.openhab.binding.insteon.internal.device.DeviceFeature;\n+import org.openhab.binding.insteon.internal.device.DeviceFeatureListener;\n+import org.openhab.binding.insteon.internal.device.DeviceType;\n+import org.openhab.binding.insteon.internal.device.DeviceTypeLoader;\n+import org.openhab.binding.insteon.internal.device.InsteonAddress;\n+import org.openhab.binding.insteon.internal.device.InsteonDevice;\n+import org.openhab.binding.insteon.internal.device.InsteonDevice.DeviceStatus;\n+import org.openhab.binding.insteon.internal.device.RequestQueueManager;\n+import org.openhab.binding.insteon.internal.driver.Driver;\n+import org.openhab.binding.insteon.internal.driver.DriverListener;\n+import org.openhab.binding.insteon.internal.driver.ModemDBEntry;\n+import org.openhab.binding.insteon.internal.driver.Poller;\n+import org.openhab.binding.insteon.internal.handler.InsteonNetworkHandler;\n+import org.openhab.binding.insteon.internal.message.FieldException;\n+import org.openhab.binding.insteon.internal.message.Msg;\n+import org.openhab.binding.insteon.internal.message.MsgListener;\n+import org.openhab.binding.insteon.internal.utils.Utils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.xml.sax.SAXException;\n+\n+/**\n+ * A majority of the code in this file is from the OpenHAB 1 binding\n+ * org.openhab.binding.insteonplm.InsteonPLMActiveBinding. Including the comments below.\n+ *\n+ * -----------------------------------------------------------------------------------------------\n+ *\n+ * This class represents the actual implementation of the binding, and controls the high level flow\n+ * of messages to and from the InsteonModem.\n+ *\n+ * Writing this binding has been an odyssey through the quirks of the Insteon protocol\n+ * and Insteon devices. A substantial redesign was necessary at some point along the way.\n+ * Here are some of the hard learned lessons that should be considered by anyone who wants\n+ * to re-architect the binding:\n+ *\n+ * 1) The entries of the link database of the modem are not reliable. The category/subcategory entries in\n+ * particular have junk data. Forget about using the modem database to generate a list of devices.\n+ * The database should only be used to verify that a device has been linked.\n+ *\n+ * 2) Querying devices for their product information does not work either. First of all, battery operated devices\n+ * (and there are a lot of those) have their radio switched off, and may generally not respond to product\n+ * queries. Even main stream hardwired devices sold presently (like the 2477s switch and the 2477d dimmer)\n+ * don't even have a product ID. Although supposedly part of the Insteon protocol, we have yet to\n+ * encounter a device that would cough up a product id when queried, even among very recent devices. They\n+ * simply return zeros as product id. Lesson: forget about querying devices to generate a device list.\n+ *\n+ * 3) Polling is a thorny issue: too much traffic on the network, and messages will be dropped left and right,\n+ * and not just the poll related ones, but others as well. In particular sending back-to-back messages\n+ * seemed to result in the second message simply never getting sent, without flow control back pressure\n+ * (NACK) from the modem. For now the work-around is to space out the messages upon sending, and\n+ * in general poll as infrequently as acceptable.\n+ *\n+ * 4) Instantiating and tracking devices when reported by the modem (either from the database, or when\n+ * messages are received) leads to complicated state management because there is no guarantee at what\n+ * point (if at all) the binding configuration will be available. It gets even more difficult when\n+ * items are created, destroyed, and modified while the binding runs.\n+ *\n+ * For the above reasons, devices are only instantiated when they are referenced by binding information.\n+ * As nice as it would be to discover devices and their properties dynamically, we have abandoned that\n+ * path because it had led to a complicated and fragile system which due to the technical limitations\n+ * above was inherently squirrely.\n+ *\n+ *\n+ * @author Bernd Pfrommer - Initial contribution\n+ * @author Daniel Pfrommer - OpenHAB 1 insteonplm binding\n+ * @author Rob Nielsen - Port to OpenHAB 2 insteon binding\n+ */\n+@NonNullByDefault\n+public class InsteonBinding {\n+    private static final int DEAD_DEVICE_COUNT = 10;\n+\n+    private final Logger logger = LoggerFactory.getLogger(InsteonBinding.class);\n+\n+    private Driver m_driver = new Driver();\n+    private ConcurrentHashMap<InsteonAddress, InsteonDevice> m_devices = new ConcurrentHashMap<InsteonAddress, InsteonDevice>();\n+    private ConcurrentHashMap<String, InsteonChannelConfiguration> m_bindingConfigs = new ConcurrentHashMap<>();\n+    private PortListener m_portListener = new PortListener();\n+    private int m_devicePollIntervalMilliseconds = 300000;\n+    private int m_deadDeviceTimeout = -1;\n+    private int m_messagesReceived = 0;\n+    private boolean m_isActive = false; // state of binding\n+    private int m_x10HouseUnit = -1;\n+    private InsteonNetworkHandler m_handler;\n+\n+    public InsteonBinding(InsteonNetworkHandler handler, @Nullable InsteonNetworkConfiguration config) {\n+        this.m_handler = handler;\n+\n+        Integer devicePollIntervalSeconds = config.getDevicePollIntervalSeconds();\n+        if (devicePollIntervalSeconds != null) {\n+            m_devicePollIntervalMilliseconds = devicePollIntervalSeconds * 1000;\n+        }\n+        logger.info(\"device poll interval set to {} seconds\", m_devicePollIntervalMilliseconds / 1000);\n+\n+        Integer modemDbRetryTimeoutSeconds = config.getModemDbRetryTimeoutSeconds();\n+        if (modemDbRetryTimeoutSeconds != null) {\n+            logger.info(\"setting modem db retry timeout to {} seconds\", modemDbRetryTimeoutSeconds);\n+            m_driver.setModemDBRetryTimeout(modemDbRetryTimeoutSeconds * 1000);\n+        }\n+\n+        String additionalDevices = config.getAdditionalDevices();\n+        if (additionalDevices != null) {\n+            try {\n+                DeviceTypeLoader.s_instance().loadDeviceTypesXML(additionalDevices);\n+                logger.info(\"read additional device definitions from {}\", additionalDevices);\n+            } catch (ParserConfigurationException | SAXException | IOException e) {\n+                logger.warn(\"error reading additional devices from {}\", additionalDevices, e);\n+            }\n+        }\n+\n+        String additionalFeatures = config.getAdditionalFeatures();\n+        if (additionalFeatures != null) {\n+            logger.info(\"reading additional feature templates from {}\", additionalFeatures);\n+            DeviceFeature.s_readFeatureTemplates(additionalFeatures);\n+        }\n+\n+        m_deadDeviceTimeout = m_devicePollIntervalMilliseconds * DEAD_DEVICE_COUNT;\n+        logger.info(\"dead device timeout set to {} seconds\", m_deadDeviceTimeout / 1000);\n+\n+        String port = config.getPort();\n+        logger.info(\"port = '{}'\", port);\n+        m_driver.addPort(\"port\", port);\n+        m_driver.addMsgListener(m_portListener, port);\n+\n+        logger.debug(\"setting driver listener\");\n+        m_driver.setDriverListener(m_portListener);\n+    }\n+\n+    public boolean startPolling() {\n+        logger.debug(\"starting {} ports\", m_driver.getNumberOfPorts());\n+\n+        m_driver.startAllPorts();\n+        logger.debug(\"ports started\");\n+        switch (m_driver.getNumberOfPorts()) {\n+            case 0:\n+                logger.warn(\"initialization complete, but found no ports!\");\n+                return false;\n+            case 1:\n+                logger.debug(\"initialization complete, found 1 port!\");\n+                break;\n+            default:\n+                logger.warn(\"initialization complete, found {} ports.\", m_driver.getNumberOfPorts());\n+                break;\n+        }\n+\n+        return true;\n+    }\n+\n+    public void setIsActive(boolean isActive) {\n+        m_isActive = isActive;\n+    }\n+\n+    public void sendCommand(String channelName, Command command) {\n+        if (!m_isActive) {\n+            logger.debug(\"not ready to handle commands yet, returning.\");\n+            return;\n+        }\n+\n+        InsteonChannelConfiguration bindingConfig = m_bindingConfigs.get(channelName);\n+        if (bindingConfig == null) {\n+            logger.warn(\"unable to find binding config for channel {}\", channelName);\n+            return;\n+        }\n+\n+        InsteonDevice dev = getDevice(bindingConfig.getAddress());\n+        if (dev == null) {\n+            logger.warn(\"no device found with insteon address {}\", bindingConfig.getAddress());\n+            return;\n+        }\n+\n+        dev.processCommand(m_driver, bindingConfig, command);\n+\n+        logger.debug(\"found binding config for channel {}\", channelName);\n+    }\n+\n+    public void addFeatureListener(InsteonChannelConfiguration bindingConfig) {\n+        logger.debug(\"adding listener for channel {}\", bindingConfig.getChannelName());\n+\n+        InsteonAddress address = bindingConfig.getAddress();\n+        InsteonDevice dev = getDevice(address);\n+        @Nullable\n+        DeviceFeature f = dev.getFeature(bindingConfig.getFeature());\n+        if (f == null || f.isFeatureGroup()) {\n+            StringBuffer buf = new StringBuffer();\n+            ArrayList<String> names = new ArrayList<String>(dev.getFeatures().keySet());\n+            Collections.sort(names);\n+            for (String name : names) {\n+                DeviceFeature feature = dev.getFeature(name);\n+                if (!feature.isFeatureGroup()) {\n+                    if (buf.length() > 0) {\n+                        buf.append(\", \");\n+                    }\n+                    buf.append(name);\n+                }\n+            }\n+\n+            logger.warn(\"channel {} references unknown feature: {}, it will be ignored. Known features for {} are: {}.\",\n+                    bindingConfig.getChannelName(), bindingConfig.getFeature(), bindingConfig.getProductKey(),\n+                    buf.toString());\n+            return;\n+        }\n+\n+        DeviceFeatureListener fl = new DeviceFeatureListener(this, bindingConfig.getChannelUID(),\n+                bindingConfig.getChannelName());\n+        fl.setParameters(bindingConfig.getParameters());\n+        f.addListener(fl);\n+\n+        m_bindingConfigs.put(bindingConfig.getChannelName(), bindingConfig);\n+    }\n+\n+    public void removeFeatureListener(ChannelUID channelUID) {\n+        String channelName = channelUID.getAsString();\n+\n+        logger.debug(\"removing listener for channel {}\", channelName);\n+\n+        for (Iterator<Entry<InsteonAddress, InsteonDevice>> it = m_devices.entrySet().iterator(); it.hasNext();) {\n+            InsteonDevice dev = it.next().getValue();\n+            boolean removedListener = dev.removeFeatureListener(channelName);\n+            if (removedListener) {\n+                logger.trace(\"removed feature listener {} from dev {}\", channelName, dev);\n+            }\n+        }\n+    }\n+\n+    public void updateFeatureState(ChannelUID channelUID, State state) {\n+        m_handler.updateState(channelUID, state);\n+    }\n+\n+    public InsteonDevice makeNewDevice(InsteonAddress addr, String productKey) {\n+        DeviceType dt = DeviceTypeLoader.s_instance().getDeviceType(productKey);\n+        InsteonDevice dev = InsteonDevice.s_makeDevice(dt);\n+        dev.setAddress(addr);\n+        dev.setDriver(m_driver);\n+        dev.addPort(m_driver.getDefaultPort());\n+        if (!dev.hasValidPollingInterval()) {\n+            dev.setPollInterval(m_devicePollIntervalMilliseconds);\n+        }\n+        if (m_driver.isModemDBComplete() && dev.getStatus() != DeviceStatus.POLLING) {\n+            int ndev = checkIfInModemDatabase(dev);\n+            if (dev.hasModemDBEntry()) {\n+                dev.setStatus(DeviceStatus.POLLING);\n+                Poller.s_instance().startPolling(dev, ndev);\n+            }\n+        }\n+        m_devices.put(addr, dev);\n+\n+        m_handler.insteonDeviceWasCreated();\n+\n+        return (dev);\n+    }\n+\n+    public void removeDevice(InsteonAddress addr) {\n+        InsteonDevice dev = m_devices.remove(addr);\n+        if (dev == null) {\n+            return;\n+        }\n+\n+        if (dev.getStatus() == DeviceStatus.POLLING) {\n+            Poller.s_instance().stopPolling(dev);\n+        }\n+    }\n+\n+    /**\n+     * Checks if a device is in the modem link database, and, if the database\n+     * is complete, logs a warning if the device is not present\n+     *\n+     * @param dev The device to search for in the modem database\n+     * @return number of devices in modem database\n+     */\n+    private int checkIfInModemDatabase(InsteonDevice dev) {\n+        InsteonAddress addr = dev.getAddress();\n+        HashMap<InsteonAddress, @Nullable ModemDBEntry> dbes = m_driver.lockModemDBEntries();\n+        if (dbes.containsKey(addr)) {\n+            if (!dev.hasModemDBEntry()) {\n+                logger.info(\"device {} found in the modem database and {}.\", addr, getLinkInfo(dbes, addr));\n+                dev.setHasModemDBEntry(true);\n+            }\n+        } else {\n+            if (m_driver.isModemDBComplete() && !addr.isX10()) {\n+                logger.warn(\"device {} not found in the modem database. Did you forget to link?\", addr);\n+            }\n+        }\n+        int ndev = dbes.size();\n+        m_driver.unlockModemDBEntries();\n+        return ndev;\n+    }\n+\n+    /**\n+     * Everything below was copied from Insteon PLM v1\n+     */\n+\n+    /**\n+     * Clean up all state.\n+     */\n+    public void shutdown() {\n+        logger.debug(\"shutting down Insteon bridge\");\n+        m_driver.stopAllPorts();\n+        m_devices.clear();\n+        RequestQueueManager.s_destroyInstance();\n+        Poller.s_instance().stop();\n+        m_isActive = false;\n+    }\n+\n+    /**\n+     * Method to find a device by address\n+     *\n+     * @param aAddr the insteon address to search for\n+     * @return reference to the device, or null if not found\n+     */\n+    public @Nullable InsteonDevice getDevice(@Nullable InsteonAddress aAddr) {\n+        InsteonDevice dev = (aAddr == null) ? null : m_devices.get(aAddr);\n+        return (dev);\n+    }\n+\n+    private String getLinkInfo(HashMap<InsteonAddress, @Nullable ModemDBEntry> dbes, InsteonAddress a) {\n+        ModemDBEntry dbe = dbes.get(a);\n+        ArrayList<Byte> controls = dbe.getControls();\n+        ArrayList<Byte> responds = dbe.getRespondsTo();\n+\n+        StringBuffer buf = new StringBuffer(\"the modem\");\n+        if (!controls.isEmpty()) {\n+            buf.append(\" controls groups [\");\n+            buf.append(toGroupString(controls));\n+            buf.append(\"]\");\n+        }\n+\n+        if (!responds.isEmpty()) {\n+            if (!controls.isEmpty()) {\n+                buf.append(\" and\");\n+            }\n+\n+            buf.append(\" responds to groups [\");\n+            buf.append(toGroupString(responds));\n+            buf.append(\"]\");\n+        }\n+\n+        return buf.toString();\n+    }\n+\n+    private String toGroupString(ArrayList<Byte> group) {\n+        ArrayList<Byte> sorted = new ArrayList<Byte>(group);\n+        Collections.sort(sorted);\n+\n+        StringBuffer buf = new StringBuffer();\n+        for (Byte b : sorted) {\n+            if (buf.length() > 0) {\n+                buf.append(\",\");\n+            }\n+            buf.append(\"0x\");\n+            buf.append(Utils.getHexString(b));\n+        }\n+\n+        return buf.toString();\n+    }\n+\n+    public void logDeviceStatistics() {\n+        String msg = String.format(\"devices: %3d configured, %3d polling, msgs received: %5d\", m_devices.size(),\n+                Poller.s_instance().getSizeOfQueue(), m_messagesReceived);\n+        logger.info(\"{}\", msg);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ed93353c47fa5d457223c66d8f91b1c168a57e23"}, "originalPosition": 391}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjcxOTA2MA==", "bodyText": "default port is random?", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r386719060", "createdAt": "2020-03-02T23:44:56Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.insteon/src/main/java/org/openhab/binding/insteon/internal/driver/Driver.java", "diffHunk": "@@ -0,0 +1,200 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.insteon.internal.driver;\n+\n+import java.io.IOException;\n+import java.util.HashMap;\n+import java.util.concurrent.locks.ReentrantLock;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.insteon.internal.device.InsteonAddress;\n+import org.openhab.binding.insteon.internal.message.Msg;\n+import org.openhab.binding.insteon.internal.message.MsgListener;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The driver class manages the modem ports.\n+ * XXX: at this time, only a single modem has ever been used. Expect\n+ * the worst if you connect multiple modems. When multiple modems\n+ * are required, this code needs to be tested and fixed.\n+ *\n+ * @author Bernd Pfrommer - Initial contribution\n+ * @author Rob Nielsen - Port to OpenHAB 2 insteon binding\n+ */\n+@NonNullByDefault\n+public class Driver {\n+    private static final Logger logger = LoggerFactory.getLogger(Driver.class);\n+\n+    // maps device name to serial port, i.e /dev/insteon -> Port object\n+    private HashMap<String, Port> m_ports = new HashMap<String, Port>();\n+    private @Nullable DriverListener m_listener = null; // single listener for notifications\n+    private HashMap<InsteonAddress, @Nullable ModemDBEntry> m_modemDBEntries = new HashMap<InsteonAddress, @Nullable ModemDBEntry>();\n+    private ReentrantLock m_modemDBEntriesLock = new ReentrantLock();\n+    private int m_modemDBRetryTimeout = 120000; // in milliseconds\n+\n+    public void setDriverListener(DriverListener listener) {\n+        m_listener = listener;\n+    }\n+\n+    public void setModemDBRetryTimeout(int timeout) {\n+        m_modemDBRetryTimeout = timeout;\n+        for (Port p : m_ports.values()) {\n+            p.setModemDBRetryTimeout(m_modemDBRetryTimeout);\n+        }\n+    }\n+\n+    public boolean isReady() {\n+        for (Port p : m_ports.values()) {\n+            if (!p.isRunning()) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    public HashMap<InsteonAddress, @Nullable ModemDBEntry> lockModemDBEntries() {\n+        m_modemDBEntriesLock.lock();\n+        return m_modemDBEntries;\n+    }\n+\n+    public void unlockModemDBEntries() {\n+        m_modemDBEntriesLock.unlock();\n+    }\n+\n+    /**\n+     * Add new port (modem) to the driver\n+     *\n+     * @param name the name of the port (from the config file, e.g. port_0, port_1, etc\n+     * @param port the device name, e.g. /dev/insteon, /dev/ttyUSB0 etc\n+     */\n+    public void addPort(String name, String port) {\n+        if (m_ports.keySet().contains(port)) {\n+            logger.warn(\"ignored attempt to add duplicate port: {} {}\", name, port);\n+        } else {\n+            Port p = new Port(port, this);\n+            p.setModemDBRetryTimeout(m_modemDBRetryTimeout);\n+            m_ports.put(port, p);\n+            logger.debug(\"added new port: {} {}\", name, port);\n+        }\n+    }\n+\n+    /**\n+     * Register a message listener with a port\n+     *\n+     * @param listener the listener who wants to listen to port messages\n+     * @param port the port (e.g. /dev/ttyUSB0) to which the listener listens\n+     */\n+    public void addMsgListener(MsgListener listener, String port) {\n+        if (m_ports.keySet().contains(port)) {\n+            m_ports.get(port).addListener(listener);\n+        } else {\n+            logger.warn(\"referencing unknown port {}!\", port);\n+        }\n+    }\n+\n+    public void startAllPorts() {\n+        for (Port p : m_ports.values()) {\n+            p.start();\n+        }\n+    }\n+\n+    public void stopAllPorts() {\n+        for (Port p : m_ports.values()) {\n+            p.stop();\n+        }\n+    }\n+\n+    /**\n+     * Write message to a port\n+     *\n+     * @param port name of the port to write to (e.g. '/dev/ttyUSB0')\n+     * @param m the message to write\n+     * @throws IOException\n+     */\n+    public void writeMessage(String port, Msg m) throws IOException {\n+        Port p = getPort(port);\n+        if (p == null) {\n+            logger.warn(\"cannot write to unknown port {}\", port);\n+            throw new IOException();\n+        }\n+        p.writeMessage(m);\n+    }\n+\n+    public @Nullable String getDefaultPort() {\n+        return (m_ports.isEmpty() ? null : m_ports.keySet().iterator().next());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ed93353c47fa5d457223c66d8f91b1c168a57e23"}, "originalPosition": 136}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjcxOTI2Ng==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private static final Logger logger = LoggerFactory.getLogger(IOStream.class);\n          \n          \n            \n                private final Logger logger = LoggerFactory.getLogger(IOStream.class);", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r386719266", "createdAt": "2020-03-02T23:45:35Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.insteon/src/main/java/org/openhab/binding/insteon/internal/driver/IOStream.java", "diffHunk": "@@ -0,0 +1,195 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.insteon.internal.driver;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.insteon.internal.driver.hub.HubIOStream;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Abstract class for implementation for I/O stream with anything that looks\n+ * like a PLM (e.g. the insteon hubs, serial/usb connection etc)\n+ *\n+ * @author Bernd Pfrommer - Initial contribution\n+ * @author Daniel Pfrommer - OpenHAB 1 insteonplm binding\n+ * @author Rob Nielsen - Port to OpenHAB 2 insteon binding\n+ */\n+@NonNullByDefault\n+public abstract class IOStream {\n+    private static final Logger logger = LoggerFactory.getLogger(IOStream.class);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ed93353c47fa5d457223c66d8f91b1c168a57e23"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjcyMDIzMw==", "bodyText": "This is really dangerous, you aren't properly handling the case when the underlying stream is closed by something other than you (e.g. hardware problem or other fault) which could result in an infinite loop.\nAlso, find a way to implement this without Thread.sleep!", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r386720233", "createdAt": "2020-03-02T23:48:38Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.insteon/src/main/java/org/openhab/binding/insteon/internal/driver/IOStream.java", "diffHunk": "@@ -0,0 +1,195 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.insteon.internal.driver;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.insteon.internal.driver.hub.HubIOStream;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Abstract class for implementation for I/O stream with anything that looks\n+ * like a PLM (e.g. the insteon hubs, serial/usb connection etc)\n+ *\n+ * @author Bernd Pfrommer - Initial contribution\n+ * @author Daniel Pfrommer - OpenHAB 1 insteonplm binding\n+ * @author Rob Nielsen - Port to OpenHAB 2 insteon binding\n+ */\n+@NonNullByDefault\n+public abstract class IOStream {\n+    private static final Logger logger = LoggerFactory.getLogger(IOStream.class);\n+    protected @Nullable InputStream m_in = null;\n+    protected @Nullable OutputStream m_out = null;\n+    private boolean stopped = false;\n+\n+    public void stop() {\n+        stopped = true;\n+    }\n+\n+    /**\n+     * read data from iostream\n+     *\n+     * @param b byte array (output)\n+     * @param offset offset for placement into byte array\n+     * @param readSize size to read\n+     * @return number of bytes read\n+     */\n+    public int read(byte[] b, int offset, int readSize) throws InterruptedException {\n+        int len = 0;\n+        while (!stopped && len < 1) {\n+            try {\n+                len = m_in.read(b, offset, readSize);\n+                if (Thread.interrupted()) {\n+                    throw new InterruptedException();\n+                }\n+            } catch (IOException e) {\n+                logger.trace(\"got exception while reading: {}\", e.getMessage());\n+                while (!stopped && !reconnect()) {\n+                    logger.trace(\"sleeping before reconnecting\");\n+                    Thread.sleep(10000);\n+                }\n+            }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ed93353c47fa5d457223c66d8f91b1c168a57e23"}, "originalPosition": 66}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjcyMTM1Mg==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    StringBuffer buf = new StringBuffer();\n          \n          \n            \n                    StringBuilder buf = new StringBuilder();", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r386721352", "createdAt": "2020-03-02T23:51:59Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.insteon/src/main/java/org/openhab/binding/insteon/internal/driver/ModemDBEntry.java", "diffHunk": "@@ -0,0 +1,100 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.insteon.internal.driver;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.insteon.internal.device.InsteonAddress;\n+import org.openhab.binding.insteon.internal.message.Msg;\n+import org.openhab.binding.insteon.internal.utils.Utils;\n+\n+/**\n+ * The ModemDBEntry class holds a modem device type record\n+ * an xml file.\n+ *\n+ * @author Bernd Pfrommer - Initial contribution\n+ * @author Rob Nielsen - Port to OpenHAB 2 insteon binding\n+ */\n+@NonNullByDefault\n+public class ModemDBEntry {\n+    private @Nullable InsteonAddress m_address = null;\n+    private @Nullable Port m_port = null;\n+    private ArrayList<Msg> m_linkRecords = new ArrayList<Msg>();\n+    private ArrayList<Byte> m_controls = new ArrayList<Byte>();\n+    private ArrayList<Byte> m_respondsTo = new ArrayList<Byte>();\n+\n+    public ModemDBEntry(InsteonAddress aAddr) {\n+        m_address = aAddr;\n+    }\n+\n+    public ArrayList<Msg> getLinkRecords() {\n+        return m_linkRecords;\n+    }\n+\n+    public void addLinkRecord(Msg m) {\n+        m_linkRecords.add(m);\n+    }\n+\n+    public void addControls(byte c) {\n+        m_controls.add(c);\n+    }\n+\n+    public ArrayList<Byte> getControls() {\n+        return m_controls;\n+    }\n+\n+    public void addRespondsTo(byte r) {\n+        m_respondsTo.add(r);\n+    }\n+\n+    public ArrayList<Byte> getRespondsTo() {\n+        return m_respondsTo;\n+    }\n+\n+    public void setPort(Port p) {\n+        m_port = p;\n+    }\n+\n+    public @Nullable Port getPort() {\n+        return m_port;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        String s = \"addr:\" + m_address + \"|controls:[\" + toGroupString(m_controls) + \"]|responds_to:[\"\n+                + toGroupString(m_respondsTo) + \"]|link_recors\";\n+        for (Msg m : m_linkRecords) {\n+            s += \":(\" + m + \")\";\n+        }\n+        return s;\n+    }\n+\n+    private String toGroupString(ArrayList<Byte> group) {\n+        ArrayList<Byte> sorted = new ArrayList<Byte>(group);\n+        Collections.sort(sorted);\n+\n+        StringBuffer buf = new StringBuffer();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ed93353c47fa5d457223c66d8f91b1c168a57e23"}, "originalPosition": 89}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjcyMjk1MA==", "bodyText": "Change this to use a CopyOnWriteArraySet, then remove all the synchronization around this field.", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r386722950", "createdAt": "2020-03-02T23:57:19Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.insteon/src/main/java/org/openhab/binding/insteon/internal/driver/Port.java", "diffHunk": "@@ -0,0 +1,509 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.insteon.internal.driver;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.Random;\n+import java.util.concurrent.LinkedBlockingQueue;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.insteon.internal.device.DeviceType;\n+import org.openhab.binding.insteon.internal.device.DeviceTypeLoader;\n+import org.openhab.binding.insteon.internal.device.InsteonAddress;\n+import org.openhab.binding.insteon.internal.device.InsteonDevice;\n+import org.openhab.binding.insteon.internal.device.ModemDBBuilder;\n+import org.openhab.binding.insteon.internal.message.FieldException;\n+import org.openhab.binding.insteon.internal.message.Msg;\n+import org.openhab.binding.insteon.internal.message.MsgFactory;\n+import org.openhab.binding.insteon.internal.message.MsgListener;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The Port class represents a port, that is a connection to either an Insteon modem either through\n+ * a serial or USB port, or via an Insteon Hub.\n+ * It does the initialization of the port, and (via its inner classes IOStreamReader and IOStreamWriter)\n+ * manages the reading/writing of messages on the Insteon network.\n+ *\n+ * The IOStreamReader and IOStreamWriter class combined implement the somewhat tricky flow control protocol.\n+ * In combination with the MsgFactory class, the incoming data stream is turned into a Msg structure\n+ * for further processing by the upper layers (MsgListeners).\n+ *\n+ * A write queue is maintained to pace the flow of outgoing messages. Sending messages back-to-back\n+ * can lead to dropped messages.\n+ *\n+ *\n+ * @author Bernd Pfrommer - Initial contribution\n+ * @author Daniel Pfrommer - OpenHAB 1 insteonplm binding\n+ * @author Rob Nielsen - Port to OpenHAB 2 insteon binding\n+ */\n+@NonNullByDefault\n+public class Port {\n+    private static final Logger logger = LoggerFactory.getLogger(Port.class);\n+\n+    /**\n+     * The ReplyType is used to keep track of the state of the serial port receiver\n+     */\n+    enum ReplyType {\n+        GOT_ACK,\n+        WAITING_FOR_ACK,\n+        GOT_NACK\n+    }\n+\n+    private IOStream m_ioStream;\n+    private String m_devName;\n+    private String m_logName;\n+    private Modem m_modem;\n+    private IOStreamReader m_reader;\n+    private IOStreamWriter m_writer;\n+    private final int m_readSize = 1024; // read buffer size\n+    private @Nullable Thread m_readThread = null;\n+    private @Nullable Thread m_writeThread = null;\n+    private boolean m_running = false;\n+    private boolean m_modemDBComplete = false;\n+    private MsgFactory m_msgFactory = new MsgFactory();\n+    private Driver m_driver;\n+    private ModemDBBuilder m_mdbb;\n+    private ArrayList<MsgListener> m_listeners = new ArrayList<MsgListener>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ed93353c47fa5d457223c66d8f91b1c168a57e23"}, "originalPosition": 80}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjcyMzA1NQ==", "bodyText": "don't use clone()", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r386723055", "createdAt": "2020-03-02T23:57:41Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.insteon/src/main/java/org/openhab/binding/insteon/internal/driver/Port.java", "diffHunk": "@@ -0,0 +1,509 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.insteon.internal.driver;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.Random;\n+import java.util.concurrent.LinkedBlockingQueue;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.insteon.internal.device.DeviceType;\n+import org.openhab.binding.insteon.internal.device.DeviceTypeLoader;\n+import org.openhab.binding.insteon.internal.device.InsteonAddress;\n+import org.openhab.binding.insteon.internal.device.InsteonDevice;\n+import org.openhab.binding.insteon.internal.device.ModemDBBuilder;\n+import org.openhab.binding.insteon.internal.message.FieldException;\n+import org.openhab.binding.insteon.internal.message.Msg;\n+import org.openhab.binding.insteon.internal.message.MsgFactory;\n+import org.openhab.binding.insteon.internal.message.MsgListener;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The Port class represents a port, that is a connection to either an Insteon modem either through\n+ * a serial or USB port, or via an Insteon Hub.\n+ * It does the initialization of the port, and (via its inner classes IOStreamReader and IOStreamWriter)\n+ * manages the reading/writing of messages on the Insteon network.\n+ *\n+ * The IOStreamReader and IOStreamWriter class combined implement the somewhat tricky flow control protocol.\n+ * In combination with the MsgFactory class, the incoming data stream is turned into a Msg structure\n+ * for further processing by the upper layers (MsgListeners).\n+ *\n+ * A write queue is maintained to pace the flow of outgoing messages. Sending messages back-to-back\n+ * can lead to dropped messages.\n+ *\n+ *\n+ * @author Bernd Pfrommer - Initial contribution\n+ * @author Daniel Pfrommer - OpenHAB 1 insteonplm binding\n+ * @author Rob Nielsen - Port to OpenHAB 2 insteon binding\n+ */\n+@NonNullByDefault\n+public class Port {\n+    private static final Logger logger = LoggerFactory.getLogger(Port.class);\n+\n+    /**\n+     * The ReplyType is used to keep track of the state of the serial port receiver\n+     */\n+    enum ReplyType {\n+        GOT_ACK,\n+        WAITING_FOR_ACK,\n+        GOT_NACK\n+    }\n+\n+    private IOStream m_ioStream;\n+    private String m_devName;\n+    private String m_logName;\n+    private Modem m_modem;\n+    private IOStreamReader m_reader;\n+    private IOStreamWriter m_writer;\n+    private final int m_readSize = 1024; // read buffer size\n+    private @Nullable Thread m_readThread = null;\n+    private @Nullable Thread m_writeThread = null;\n+    private boolean m_running = false;\n+    private boolean m_modemDBComplete = false;\n+    private MsgFactory m_msgFactory = new MsgFactory();\n+    private Driver m_driver;\n+    private ModemDBBuilder m_mdbb;\n+    private ArrayList<MsgListener> m_listeners = new ArrayList<MsgListener>();\n+    private LinkedBlockingQueue<Msg> m_writeQueue = new LinkedBlockingQueue<Msg>();\n+\n+    /**\n+     * Constructor\n+     *\n+     * @param devName the name of the port, i.e. '/dev/insteon'\n+     * @param d The Driver object that manages this port\n+     */\n+    public Port(String devName, Driver d) {\n+        m_devName = devName;\n+        m_driver = d;\n+        m_logName = devName;\n+        m_modem = new Modem();\n+        addListener(m_modem);\n+        m_ioStream = IOStream.s_create(devName);\n+        m_reader = new IOStreamReader();\n+        m_writer = new IOStreamWriter();\n+        m_mdbb = new ModemDBBuilder(this);\n+    }\n+\n+    public synchronized boolean isModemDBComplete() {\n+        return (m_modemDBComplete);\n+    }\n+\n+    public boolean isRunning() {\n+        return m_running;\n+    }\n+\n+    public InsteonAddress getAddress() {\n+        return m_modem.getAddress();\n+    }\n+\n+    public String getDeviceName() {\n+        return m_devName;\n+    }\n+\n+    public Driver getDriver() {\n+        return m_driver;\n+    }\n+\n+    public void setModemDBRetryTimeout(int timeout) {\n+        m_mdbb.setRetryTimeout(timeout);\n+    }\n+\n+    public void addListener(MsgListener l) {\n+        synchronized (m_listeners) {\n+            if (!m_listeners.contains(l)) {\n+                m_listeners.add(l);\n+            }\n+        }\n+    }\n+\n+    public void removeListener(MsgListener l) {\n+        synchronized (m_listeners) {\n+            if (m_listeners.remove(l)) {\n+                // logger.debug(\"removed listener from port\");\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Clear modem database that has been queried so far.\n+     */\n+    public void clearModemDB() {\n+        logger.debug(\"clearing modem db!\");\n+        HashMap<InsteonAddress, @Nullable ModemDBEntry> dbes = getDriver().lockModemDBEntries();\n+        dbes.clear();\n+        getDriver().unlockModemDBEntries();\n+    }\n+\n+    /**\n+     * Starts threads necessary for reading and writing\n+     */\n+    public void start() {\n+        logger.debug(\"starting port {}\", m_logName);\n+        if (m_running) {\n+            logger.debug(\"port {} already running, not started again\", m_logName);\n+        }\n+        if (!m_ioStream.open()) {\n+            logger.debug(\"failed to open port {}\", m_logName);\n+            return;\n+        }\n+        m_readThread = new Thread(m_reader);\n+        m_writeThread = new Thread(m_writer);\n+        m_readThread.setName(m_logName + \" Reader\");\n+        m_writeThread.setName(m_logName + \" Writer\");\n+        m_readThread.start();\n+        m_writeThread.start();\n+        m_modem.initialize();\n+        m_mdbb.start(); // start downloading the device list\n+        m_running = true;\n+    }\n+\n+    /**\n+     * Stops all threads\n+     */\n+    public void stop() {\n+        if (!m_running) {\n+            logger.debug(\"port {} not running, no need to stop it\", m_logName);\n+            return;\n+        }\n+\n+        m_running = false;\n+        m_ioStream.stop();\n+        m_ioStream.close();\n+\n+        if (m_readThread != null) {\n+            m_readThread.interrupt();\n+        }\n+        if (m_writeThread != null) {\n+            m_writeThread.interrupt();\n+        }\n+        logger.debug(\"waiting for read thread to exit for port {}\", m_logName);\n+        try {\n+            if (m_readThread != null) {\n+                m_readThread.join();\n+            }\n+        } catch (InterruptedException e) {\n+            logger.debug(\"got interrupted waiting for read thread to exit.\");\n+        }\n+        logger.debug(\"waiting for write thread to exit for port {}\", m_logName);\n+        try {\n+            if (m_writeThread != null) {\n+                m_writeThread.join();\n+            }\n+        } catch (InterruptedException e) {\n+            logger.debug(\"got interrupted waiting for write thread to exit.\");\n+        }\n+        logger.debug(\"all threads for port {} stopped.\", m_logName);\n+        synchronized (m_listeners) {\n+            m_listeners.clear();\n+        }\n+    }\n+\n+    /**\n+     * Adds message to the write queue\n+     *\n+     * @param m message to be added to the write queue\n+     * @throws IOException\n+     */\n+    public void writeMessage(@Nullable Msg m) throws IOException {\n+        if (m == null) {\n+            logger.warn(\"trying to write null message!\");\n+            throw new IOException(\"trying to write null message!\");\n+        }\n+        if (m.getData() == null) {\n+            logger.warn(\"trying to write message without data!\");\n+            throw new IOException(\"trying to write message without data!\");\n+        }\n+        try {\n+            m_writeQueue.add(m);\n+            logger.trace(\"enqueued msg: {}\", m);\n+        } catch (IllegalStateException e) {\n+            logger.warn(\"cannot write message {}, write queue is full!\", m);\n+        }\n+\n+    }\n+\n+    /**\n+     * Gets called by the modem database builder when the modem database is complete\n+     */\n+    public void modemDBComplete() {\n+        synchronized (this) {\n+            m_modemDBComplete = true;\n+        }\n+        m_driver.modemDBComplete(this);\n+    }\n+\n+    /**\n+     * The IOStreamReader uses the MsgFactory to turn the incoming bytes into\n+     * Msgs for the listeners. It also communicates with the IOStreamWriter\n+     * to implement flow control (tell the IOStreamWriter that it needs to retransmit,\n+     * or the reply message has been received correctly).\n+     *\n+     * @author Bernd Pfrommer - Initial contribution\n+     */\n+    @NonNullByDefault\n+    class IOStreamReader implements Runnable {\n+\n+        private ReplyType m_reply = ReplyType.GOT_ACK;\n+        private Object m_replyLock = new Object();\n+        private boolean m_dropRandomBytes = false; // set to true for fault injection\n+\n+        /**\n+         * Helper function for implementing synchronization between reader and writer\n+         *\n+         * @return reference to the RequesReplyLock\n+         */\n+        public Object getRequestReplyLock() {\n+            return m_replyLock;\n+        }\n+\n+        @Override\n+        public void run() {\n+            logger.debug(\"starting reader...\");\n+            byte[] buffer = new byte[2 * m_readSize];\n+            Random rng = new Random();\n+            try {\n+                for (int len = -1; (len = m_ioStream.read(buffer, 0, m_readSize)) > 0;) {\n+                    if (m_dropRandomBytes && rng.nextInt(100) < 20) {\n+                        len = dropBytes(buffer, len);\n+                    }\n+                    m_msgFactory.addData(buffer, len);\n+                    processMessages();\n+                }\n+            } catch (InterruptedException e) {\n+                logger.debug(\"reader thread got interrupted!\");\n+            }\n+            logger.info(\"reader thread exiting!\");\n+        }\n+\n+        private void processMessages() {\n+            try {\n+                // must call processData() until we get a null pointer back\n+                for (Msg m = m_msgFactory.processData(); m != null; m = m_msgFactory.processData()) {\n+                    toAllListeners(m);\n+                    notifyWriter(m);\n+                }\n+            } catch (IOException e) {\n+                // got bad data from modem,\n+                // unblock those waiting for ack\n+                logger.warn(\"bad data received: {}\", e.getMessage());\n+                synchronized (getRequestReplyLock()) {\n+                    if (m_reply == ReplyType.WAITING_FOR_ACK) {\n+                        logger.warn(\"got bad data back, must assume message was acked.\");\n+                        m_reply = ReplyType.GOT_ACK;\n+                        getRequestReplyLock().notify();\n+                    }\n+                }\n+            }\n+        }\n+\n+        private void notifyWriter(Msg msg) {\n+            synchronized (getRequestReplyLock()) {\n+                if (m_reply == ReplyType.WAITING_FOR_ACK) {\n+                    if (!msg.isUnsolicited()) {\n+                        m_reply = (msg.isPureNack() ? ReplyType.GOT_NACK : ReplyType.GOT_ACK);\n+                        logger.trace(\"signaling receipt of ack: {}\", (m_reply == ReplyType.GOT_ACK));\n+                        getRequestReplyLock().notify();\n+                    } else if (msg.isPureNack()) {\n+                        m_reply = ReplyType.GOT_NACK;\n+                        logger.trace(\"signaling receipt of pure nack\");\n+                        getRequestReplyLock().notify();\n+                    } else {\n+                        logger.trace(\"got unsolicited message\");\n+                    }\n+                }\n+            }\n+        }\n+\n+        /**\n+         * Drops bytes randomly from buffer to simulate errors seen\n+         * from the InsteonHub using the raw interface\n+         *\n+         * @param buffer byte buffer from which to drop bytes\n+         * @param len original number of valid bytes in buffer\n+         * @return length of byte buffer after dropping from it\n+         */\n+        private int dropBytes(byte[] buffer, int len) {\n+            final int DROP_RATE = 2; // in percent\n+            Random rng = new Random();\n+            ArrayList<Byte> l = new ArrayList<Byte>();\n+            for (int i = 0; i < len; i++) {\n+                if (rng.nextInt(100) >= DROP_RATE) {\n+                    l.add(new Byte(buffer[i]));\n+                }\n+            }\n+            for (int i = 0; i < l.size(); i++) {\n+                buffer[i] = l.get(i);\n+            }\n+            return (l.size());\n+        }\n+\n+        @SuppressWarnings(\"unchecked\")\n+        private void toAllListeners(Msg msg) {\n+            // When we deliver the message, the recipient\n+            // may in turn call removeListener() or addListener(),\n+            // thereby corrupting the very same list we are iterating\n+            // through. That's why we make a copy of it, and\n+            // iterate through the copy.\n+            ArrayList<MsgListener> tempList = null;\n+            synchronized (m_listeners) {\n+                tempList = (ArrayList<MsgListener>) m_listeners.clone();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ed93353c47fa5d457223c66d8f91b1c168a57e23"}, "originalPosition": 363}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjcyOTIyMQ==", "bodyText": "This should be changed to use org.eclipse.smarthome.io.transport.serial.SerialPort instead", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r386729221", "createdAt": "2020-03-03T00:16:31Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.insteon/src/main/java/org/openhab/binding/insteon/internal/driver/SerialIOStream.java", "diffHunk": "@@ -0,0 +1,188 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.insteon.internal.driver;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Enumeration;\n+\n+import org.apache.commons.lang.StringUtils;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import gnu.io.CommPort;\n+import gnu.io.CommPortIdentifier;\n+import gnu.io.NoSuchPortException;\n+import gnu.io.PortInUseException;\n+import gnu.io.SerialPort;\n+import gnu.io.UnsupportedCommOperationException;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ed93353c47fa5d457223c66d8f91b1c168a57e23"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjcyOTM4NQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private static final Logger logger = LoggerFactory.getLogger(SerialIOStream.class);\n          \n          \n            \n                private final Logger logger = LoggerFactory.getLogger(SerialIOStream.class);", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r386729385", "createdAt": "2020-03-03T00:17:04Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.insteon/src/main/java/org/openhab/binding/insteon/internal/driver/SerialIOStream.java", "diffHunk": "@@ -0,0 +1,188 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.insteon.internal.driver;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Enumeration;\n+\n+import org.apache.commons.lang.StringUtils;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import gnu.io.CommPort;\n+import gnu.io.CommPortIdentifier;\n+import gnu.io.NoSuchPortException;\n+import gnu.io.PortInUseException;\n+import gnu.io.SerialPort;\n+import gnu.io.UnsupportedCommOperationException;\n+\n+/**\n+ * Implements IOStream for serial devices.\n+ *\n+ * @author Bernd Pfrommer - Initial contribution\n+ * @author Daniel Pfrommer - OpenHAB 1 insteonplm binding\n+ * @author Rob Nielsen - Port to OpenHAB 2 insteon binding\n+ */\n+@NonNullByDefault\n+public class SerialIOStream extends IOStream {\n+    private static final Logger logger = LoggerFactory.getLogger(SerialIOStream.class);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ed93353c47fa5d457223c66d8f91b1c168a57e23"}, "originalPosition": 42}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjczMDE2Nw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private static final Logger logger = LoggerFactory.getLogger(TcpIOStream.class);\n          \n          \n            \n                private final Logger logger = LoggerFactory.getLogger(TcpIOStream.class);", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r386730167", "createdAt": "2020-03-03T00:19:34Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.insteon/src/main/java/org/openhab/binding/insteon/internal/driver/TcpIOStream.java", "diffHunk": "@@ -0,0 +1,87 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.insteon.internal.driver;\n+\n+import java.io.IOException;\n+import java.net.Socket;\n+import java.net.UnknownHostException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Implements IOStream for the older hubs (pre 2014).\n+ * Also works for serial ports exposed via tcp, eg. ser2net\n+ *\n+ * @author Bernd Pfrommer - Initial contribution\n+ * @author Rob Nielsen - Port to OpenHAB 2 insteon binding\n+ *\n+ */\n+@NonNullByDefault\n+public class TcpIOStream extends IOStream {\n+    private static final Logger logger = LoggerFactory.getLogger(TcpIOStream.class);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ed93353c47fa5d457223c66d8f91b1c168a57e23"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjczMTI1NA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private boolean done = false;\n          \n          \n            \n                private volatile boolean done = false;", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r386731254", "createdAt": "2020-03-03T00:23:13Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.insteon/src/main/java/org/openhab/binding/insteon/internal/driver/hub/ReadByteBuffer.java", "diffHunk": "@@ -0,0 +1,156 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.insteon.internal.driver.hub;\n+\n+import java.io.IOException;\n+import java.util.Arrays;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+\n+/**\n+ * ReadByteBuffer buffer class\n+ *\n+ * @author Daniel Pfrommer - Initial contribution\n+ * @author Rob Nielsen - Port to OpenHAB 2 insteon binding\n+ */\n+@NonNullByDefault\n+public class ReadByteBuffer {\n+    private byte m_buf[]; // the actual buffer\n+    private int m_count; // number of valid bytes\n+    private int m_index = 0; // current read index\n+    private boolean done = false;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ed93353c47fa5d457223c66d8f91b1c168a57e23"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjczMTMyNw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private byte m_buf[]; // the actual buffer\n          \n          \n            \n                private byte[] m_buf; // the actual buffer", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r386731327", "createdAt": "2020-03-03T00:23:25Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.insteon/src/main/java/org/openhab/binding/insteon/internal/driver/hub/ReadByteBuffer.java", "diffHunk": "@@ -0,0 +1,156 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.insteon.internal.driver.hub;\n+\n+import java.io.IOException;\n+import java.util.Arrays;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+\n+/**\n+ * ReadByteBuffer buffer class\n+ *\n+ * @author Daniel Pfrommer - Initial contribution\n+ * @author Rob Nielsen - Port to OpenHAB 2 insteon binding\n+ */\n+@NonNullByDefault\n+public class ReadByteBuffer {\n+    private byte m_buf[]; // the actual buffer", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ed93353c47fa5d457223c66d8f91b1c168a57e23"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Njc0MDczMA==", "bodyText": "Usage of this thread should be replaced with a scheduler", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r386740730", "createdAt": "2020-03-03T00:55:16Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.insteon/src/main/java/org/openhab/binding/insteon/internal/driver/hub/HubIOStream.java", "diffHunk": "@@ -0,0 +1,391 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.insteon.internal.driver.hub;\n+\n+import java.io.BufferedInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.net.HttpURLConnection;\n+import java.net.URL;\n+import java.nio.ByteBuffer;\n+import java.nio.charset.StandardCharsets;\n+import java.util.Base64;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.insteon.internal.driver.IOStream;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Implements IOStream for a Hub 2014 device\n+ *\n+ * @author Daniel Pfrommer - Initial contribution\n+ * @author Rob Nielsen - Port to OpenHAB 2 insteon binding\n+ *\n+ */\n+@NonNullByDefault\n+public class HubIOStream extends IOStream implements Runnable {\n+    private static final Logger logger = LoggerFactory.getLogger(HubIOStream.class);\n+\n+    private static final String BS_START = \"<BS>\";\n+    private static final String BS_END = \"</BS>\";\n+\n+    /** time between polls (in milliseconds */\n+    private int m_pollTime = 1000;\n+\n+    private String baseUrl;\n+    private @Nullable String auth = null;\n+\n+    private @Nullable Thread m_pollThread = null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ed93353c47fa5d457223c66d8f91b1c168a57e23"}, "originalPosition": 52}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Njc0MDk3Mw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private static final Logger logger = LoggerFactory.getLogger(HubIOStream.class);\n          \n          \n            \n                private final Logger logger = LoggerFactory.getLogger(HubIOStream.class);", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r386740973", "createdAt": "2020-03-03T00:56:00Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.insteon/src/main/java/org/openhab/binding/insteon/internal/driver/hub/HubIOStream.java", "diffHunk": "@@ -0,0 +1,391 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.insteon.internal.driver.hub;\n+\n+import java.io.BufferedInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.net.HttpURLConnection;\n+import java.net.URL;\n+import java.nio.ByteBuffer;\n+import java.nio.charset.StandardCharsets;\n+import java.util.Base64;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.insteon.internal.driver.IOStream;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Implements IOStream for a Hub 2014 device\n+ *\n+ * @author Daniel Pfrommer - Initial contribution\n+ * @author Rob Nielsen - Port to OpenHAB 2 insteon binding\n+ *\n+ */\n+@NonNullByDefault\n+public class HubIOStream extends IOStream implements Runnable {\n+    private static final Logger logger = LoggerFactory.getLogger(HubIOStream.class);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ed93353c47fa5d457223c66d8f91b1c168a57e23"}, "originalPosition": 41}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Njc0MTQ4Mg==", "bodyText": "Couldn't this whole class be replaced with a scheduler?", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r386741482", "createdAt": "2020-03-03T00:57:41Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.insteon/src/main/java/org/openhab/binding/insteon/internal/driver/Poller.java", "diffHunk": "@@ -0,0 +1,297 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.insteon.internal.driver;\n+\n+import java.sql.Date;\n+import java.util.Iterator;\n+import java.util.SortedSet;\n+import java.util.TreeSet;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.insteon.internal.device.InsteonDevice;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * This class manages the polling of all devices.\n+ * Between successive polls of a any device there is a quiet time of\n+ * at least MIN_MSEC_BETWEEN_POLLS. This avoids bunching up of poll messages\n+ * and keeps the network bandwidth open for other messages.\n+ *\n+ * - An entry in the poll queue corresponds to a single device, i.e. each device should\n+ * have exactly one entry in the poll queue. That entry is created when startPolling()\n+ * is called, and then re-enqueued whenever it expires.\n+ * - When a device comes up for polling, its doPoll() method is called, which in turn\n+ * puts an entry into that devices request queue. So the Poller class actually never\n+ * sends out messages directly. That is done by the device itself via its request\n+ * queue. The poller just reminds the device to poll.\n+ *\n+ * @author Bernd Pfrommer - Initial contribution\n+ * @author Rob Nielsen - Port to OpenHAB 2 insteon binding\n+ */\n+@NonNullByDefault\n+public class Poller {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ed93353c47fa5d457223c66d8f91b1c168a57e23"}, "originalPosition": 44}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Njc0NDk3MQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        logger.info(\"reader thread exiting!\");\n          \n          \n            \n                        logger.debug(\"reader thread exiting!\");", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r386744971", "createdAt": "2020-03-03T01:09:39Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.insteon/src/main/java/org/openhab/binding/insteon/internal/driver/Port.java", "diffHunk": "@@ -0,0 +1,509 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.insteon.internal.driver;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.Random;\n+import java.util.concurrent.LinkedBlockingQueue;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.insteon.internal.device.DeviceType;\n+import org.openhab.binding.insteon.internal.device.DeviceTypeLoader;\n+import org.openhab.binding.insteon.internal.device.InsteonAddress;\n+import org.openhab.binding.insteon.internal.device.InsteonDevice;\n+import org.openhab.binding.insteon.internal.device.ModemDBBuilder;\n+import org.openhab.binding.insteon.internal.message.FieldException;\n+import org.openhab.binding.insteon.internal.message.Msg;\n+import org.openhab.binding.insteon.internal.message.MsgFactory;\n+import org.openhab.binding.insteon.internal.message.MsgListener;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The Port class represents a port, that is a connection to either an Insteon modem either through\n+ * a serial or USB port, or via an Insteon Hub.\n+ * It does the initialization of the port, and (via its inner classes IOStreamReader and IOStreamWriter)\n+ * manages the reading/writing of messages on the Insteon network.\n+ *\n+ * The IOStreamReader and IOStreamWriter class combined implement the somewhat tricky flow control protocol.\n+ * In combination with the MsgFactory class, the incoming data stream is turned into a Msg structure\n+ * for further processing by the upper layers (MsgListeners).\n+ *\n+ * A write queue is maintained to pace the flow of outgoing messages. Sending messages back-to-back\n+ * can lead to dropped messages.\n+ *\n+ *\n+ * @author Bernd Pfrommer - Initial contribution\n+ * @author Daniel Pfrommer - OpenHAB 1 insteonplm binding\n+ * @author Rob Nielsen - Port to OpenHAB 2 insteon binding\n+ */\n+@NonNullByDefault\n+public class Port {\n+    private static final Logger logger = LoggerFactory.getLogger(Port.class);\n+\n+    /**\n+     * The ReplyType is used to keep track of the state of the serial port receiver\n+     */\n+    enum ReplyType {\n+        GOT_ACK,\n+        WAITING_FOR_ACK,\n+        GOT_NACK\n+    }\n+\n+    private IOStream m_ioStream;\n+    private String m_devName;\n+    private String m_logName;\n+    private Modem m_modem;\n+    private IOStreamReader m_reader;\n+    private IOStreamWriter m_writer;\n+    private final int m_readSize = 1024; // read buffer size\n+    private @Nullable Thread m_readThread = null;\n+    private @Nullable Thread m_writeThread = null;\n+    private boolean m_running = false;\n+    private boolean m_modemDBComplete = false;\n+    private MsgFactory m_msgFactory = new MsgFactory();\n+    private Driver m_driver;\n+    private ModemDBBuilder m_mdbb;\n+    private ArrayList<MsgListener> m_listeners = new ArrayList<MsgListener>();\n+    private LinkedBlockingQueue<Msg> m_writeQueue = new LinkedBlockingQueue<Msg>();\n+\n+    /**\n+     * Constructor\n+     *\n+     * @param devName the name of the port, i.e. '/dev/insteon'\n+     * @param d The Driver object that manages this port\n+     */\n+    public Port(String devName, Driver d) {\n+        m_devName = devName;\n+        m_driver = d;\n+        m_logName = devName;\n+        m_modem = new Modem();\n+        addListener(m_modem);\n+        m_ioStream = IOStream.s_create(devName);\n+        m_reader = new IOStreamReader();\n+        m_writer = new IOStreamWriter();\n+        m_mdbb = new ModemDBBuilder(this);\n+    }\n+\n+    public synchronized boolean isModemDBComplete() {\n+        return (m_modemDBComplete);\n+    }\n+\n+    public boolean isRunning() {\n+        return m_running;\n+    }\n+\n+    public InsteonAddress getAddress() {\n+        return m_modem.getAddress();\n+    }\n+\n+    public String getDeviceName() {\n+        return m_devName;\n+    }\n+\n+    public Driver getDriver() {\n+        return m_driver;\n+    }\n+\n+    public void setModemDBRetryTimeout(int timeout) {\n+        m_mdbb.setRetryTimeout(timeout);\n+    }\n+\n+    public void addListener(MsgListener l) {\n+        synchronized (m_listeners) {\n+            if (!m_listeners.contains(l)) {\n+                m_listeners.add(l);\n+            }\n+        }\n+    }\n+\n+    public void removeListener(MsgListener l) {\n+        synchronized (m_listeners) {\n+            if (m_listeners.remove(l)) {\n+                // logger.debug(\"removed listener from port\");\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Clear modem database that has been queried so far.\n+     */\n+    public void clearModemDB() {\n+        logger.debug(\"clearing modem db!\");\n+        HashMap<InsteonAddress, @Nullable ModemDBEntry> dbes = getDriver().lockModemDBEntries();\n+        dbes.clear();\n+        getDriver().unlockModemDBEntries();\n+    }\n+\n+    /**\n+     * Starts threads necessary for reading and writing\n+     */\n+    public void start() {\n+        logger.debug(\"starting port {}\", m_logName);\n+        if (m_running) {\n+            logger.debug(\"port {} already running, not started again\", m_logName);\n+        }\n+        if (!m_ioStream.open()) {\n+            logger.debug(\"failed to open port {}\", m_logName);\n+            return;\n+        }\n+        m_readThread = new Thread(m_reader);\n+        m_writeThread = new Thread(m_writer);\n+        m_readThread.setName(m_logName + \" Reader\");\n+        m_writeThread.setName(m_logName + \" Writer\");\n+        m_readThread.start();\n+        m_writeThread.start();\n+        m_modem.initialize();\n+        m_mdbb.start(); // start downloading the device list\n+        m_running = true;\n+    }\n+\n+    /**\n+     * Stops all threads\n+     */\n+    public void stop() {\n+        if (!m_running) {\n+            logger.debug(\"port {} not running, no need to stop it\", m_logName);\n+            return;\n+        }\n+\n+        m_running = false;\n+        m_ioStream.stop();\n+        m_ioStream.close();\n+\n+        if (m_readThread != null) {\n+            m_readThread.interrupt();\n+        }\n+        if (m_writeThread != null) {\n+            m_writeThread.interrupt();\n+        }\n+        logger.debug(\"waiting for read thread to exit for port {}\", m_logName);\n+        try {\n+            if (m_readThread != null) {\n+                m_readThread.join();\n+            }\n+        } catch (InterruptedException e) {\n+            logger.debug(\"got interrupted waiting for read thread to exit.\");\n+        }\n+        logger.debug(\"waiting for write thread to exit for port {}\", m_logName);\n+        try {\n+            if (m_writeThread != null) {\n+                m_writeThread.join();\n+            }\n+        } catch (InterruptedException e) {\n+            logger.debug(\"got interrupted waiting for write thread to exit.\");\n+        }\n+        logger.debug(\"all threads for port {} stopped.\", m_logName);\n+        synchronized (m_listeners) {\n+            m_listeners.clear();\n+        }\n+    }\n+\n+    /**\n+     * Adds message to the write queue\n+     *\n+     * @param m message to be added to the write queue\n+     * @throws IOException\n+     */\n+    public void writeMessage(@Nullable Msg m) throws IOException {\n+        if (m == null) {\n+            logger.warn(\"trying to write null message!\");\n+            throw new IOException(\"trying to write null message!\");\n+        }\n+        if (m.getData() == null) {\n+            logger.warn(\"trying to write message without data!\");\n+            throw new IOException(\"trying to write message without data!\");\n+        }\n+        try {\n+            m_writeQueue.add(m);\n+            logger.trace(\"enqueued msg: {}\", m);\n+        } catch (IllegalStateException e) {\n+            logger.warn(\"cannot write message {}, write queue is full!\", m);\n+        }\n+\n+    }\n+\n+    /**\n+     * Gets called by the modem database builder when the modem database is complete\n+     */\n+    public void modemDBComplete() {\n+        synchronized (this) {\n+            m_modemDBComplete = true;\n+        }\n+        m_driver.modemDBComplete(this);\n+    }\n+\n+    /**\n+     * The IOStreamReader uses the MsgFactory to turn the incoming bytes into\n+     * Msgs for the listeners. It also communicates with the IOStreamWriter\n+     * to implement flow control (tell the IOStreamWriter that it needs to retransmit,\n+     * or the reply message has been received correctly).\n+     *\n+     * @author Bernd Pfrommer - Initial contribution\n+     */\n+    @NonNullByDefault\n+    class IOStreamReader implements Runnable {\n+\n+        private ReplyType m_reply = ReplyType.GOT_ACK;\n+        private Object m_replyLock = new Object();\n+        private boolean m_dropRandomBytes = false; // set to true for fault injection\n+\n+        /**\n+         * Helper function for implementing synchronization between reader and writer\n+         *\n+         * @return reference to the RequesReplyLock\n+         */\n+        public Object getRequestReplyLock() {\n+            return m_replyLock;\n+        }\n+\n+        @Override\n+        public void run() {\n+            logger.debug(\"starting reader...\");\n+            byte[] buffer = new byte[2 * m_readSize];\n+            Random rng = new Random();\n+            try {\n+                for (int len = -1; (len = m_ioStream.read(buffer, 0, m_readSize)) > 0;) {\n+                    if (m_dropRandomBytes && rng.nextInt(100) < 20) {\n+                        len = dropBytes(buffer, len);\n+                    }\n+                    m_msgFactory.addData(buffer, len);\n+                    processMessages();\n+                }\n+            } catch (InterruptedException e) {\n+                logger.debug(\"reader thread got interrupted!\");\n+            }\n+            logger.info(\"reader thread exiting!\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ed93353c47fa5d457223c66d8f91b1c168a57e23"}, "originalPosition": 289}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Njc0NzIyMw==", "bodyText": "An InterruptException might clear the interrupt flag of the running thread and you can't expect that the running thread is going to be interrupted multiple times. I would change this logic to make sure that if it gets interrupted while joining the m_readThread that it either reinterrupts itself or it bails out early.", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r386747223", "createdAt": "2020-03-03T01:17:02Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.insteon/src/main/java/org/openhab/binding/insteon/internal/driver/Port.java", "diffHunk": "@@ -0,0 +1,509 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.insteon.internal.driver;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.Random;\n+import java.util.concurrent.LinkedBlockingQueue;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.insteon.internal.device.DeviceType;\n+import org.openhab.binding.insteon.internal.device.DeviceTypeLoader;\n+import org.openhab.binding.insteon.internal.device.InsteonAddress;\n+import org.openhab.binding.insteon.internal.device.InsteonDevice;\n+import org.openhab.binding.insteon.internal.device.ModemDBBuilder;\n+import org.openhab.binding.insteon.internal.message.FieldException;\n+import org.openhab.binding.insteon.internal.message.Msg;\n+import org.openhab.binding.insteon.internal.message.MsgFactory;\n+import org.openhab.binding.insteon.internal.message.MsgListener;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The Port class represents a port, that is a connection to either an Insteon modem either through\n+ * a serial or USB port, or via an Insteon Hub.\n+ * It does the initialization of the port, and (via its inner classes IOStreamReader and IOStreamWriter)\n+ * manages the reading/writing of messages on the Insteon network.\n+ *\n+ * The IOStreamReader and IOStreamWriter class combined implement the somewhat tricky flow control protocol.\n+ * In combination with the MsgFactory class, the incoming data stream is turned into a Msg structure\n+ * for further processing by the upper layers (MsgListeners).\n+ *\n+ * A write queue is maintained to pace the flow of outgoing messages. Sending messages back-to-back\n+ * can lead to dropped messages.\n+ *\n+ *\n+ * @author Bernd Pfrommer - Initial contribution\n+ * @author Daniel Pfrommer - OpenHAB 1 insteonplm binding\n+ * @author Rob Nielsen - Port to OpenHAB 2 insteon binding\n+ */\n+@NonNullByDefault\n+public class Port {\n+    private static final Logger logger = LoggerFactory.getLogger(Port.class);\n+\n+    /**\n+     * The ReplyType is used to keep track of the state of the serial port receiver\n+     */\n+    enum ReplyType {\n+        GOT_ACK,\n+        WAITING_FOR_ACK,\n+        GOT_NACK\n+    }\n+\n+    private IOStream m_ioStream;\n+    private String m_devName;\n+    private String m_logName;\n+    private Modem m_modem;\n+    private IOStreamReader m_reader;\n+    private IOStreamWriter m_writer;\n+    private final int m_readSize = 1024; // read buffer size\n+    private @Nullable Thread m_readThread = null;\n+    private @Nullable Thread m_writeThread = null;\n+    private boolean m_running = false;\n+    private boolean m_modemDBComplete = false;\n+    private MsgFactory m_msgFactory = new MsgFactory();\n+    private Driver m_driver;\n+    private ModemDBBuilder m_mdbb;\n+    private ArrayList<MsgListener> m_listeners = new ArrayList<MsgListener>();\n+    private LinkedBlockingQueue<Msg> m_writeQueue = new LinkedBlockingQueue<Msg>();\n+\n+    /**\n+     * Constructor\n+     *\n+     * @param devName the name of the port, i.e. '/dev/insteon'\n+     * @param d The Driver object that manages this port\n+     */\n+    public Port(String devName, Driver d) {\n+        m_devName = devName;\n+        m_driver = d;\n+        m_logName = devName;\n+        m_modem = new Modem();\n+        addListener(m_modem);\n+        m_ioStream = IOStream.s_create(devName);\n+        m_reader = new IOStreamReader();\n+        m_writer = new IOStreamWriter();\n+        m_mdbb = new ModemDBBuilder(this);\n+    }\n+\n+    public synchronized boolean isModemDBComplete() {\n+        return (m_modemDBComplete);\n+    }\n+\n+    public boolean isRunning() {\n+        return m_running;\n+    }\n+\n+    public InsteonAddress getAddress() {\n+        return m_modem.getAddress();\n+    }\n+\n+    public String getDeviceName() {\n+        return m_devName;\n+    }\n+\n+    public Driver getDriver() {\n+        return m_driver;\n+    }\n+\n+    public void setModemDBRetryTimeout(int timeout) {\n+        m_mdbb.setRetryTimeout(timeout);\n+    }\n+\n+    public void addListener(MsgListener l) {\n+        synchronized (m_listeners) {\n+            if (!m_listeners.contains(l)) {\n+                m_listeners.add(l);\n+            }\n+        }\n+    }\n+\n+    public void removeListener(MsgListener l) {\n+        synchronized (m_listeners) {\n+            if (m_listeners.remove(l)) {\n+                // logger.debug(\"removed listener from port\");\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Clear modem database that has been queried so far.\n+     */\n+    public void clearModemDB() {\n+        logger.debug(\"clearing modem db!\");\n+        HashMap<InsteonAddress, @Nullable ModemDBEntry> dbes = getDriver().lockModemDBEntries();\n+        dbes.clear();\n+        getDriver().unlockModemDBEntries();\n+    }\n+\n+    /**\n+     * Starts threads necessary for reading and writing\n+     */\n+    public void start() {\n+        logger.debug(\"starting port {}\", m_logName);\n+        if (m_running) {\n+            logger.debug(\"port {} already running, not started again\", m_logName);\n+        }\n+        if (!m_ioStream.open()) {\n+            logger.debug(\"failed to open port {}\", m_logName);\n+            return;\n+        }\n+        m_readThread = new Thread(m_reader);\n+        m_writeThread = new Thread(m_writer);\n+        m_readThread.setName(m_logName + \" Reader\");\n+        m_writeThread.setName(m_logName + \" Writer\");\n+        m_readThread.start();\n+        m_writeThread.start();\n+        m_modem.initialize();\n+        m_mdbb.start(); // start downloading the device list\n+        m_running = true;\n+    }\n+\n+    /**\n+     * Stops all threads\n+     */\n+    public void stop() {\n+        if (!m_running) {\n+            logger.debug(\"port {} not running, no need to stop it\", m_logName);\n+            return;\n+        }\n+\n+        m_running = false;\n+        m_ioStream.stop();\n+        m_ioStream.close();\n+\n+        if (m_readThread != null) {\n+            m_readThread.interrupt();\n+        }\n+        if (m_writeThread != null) {\n+            m_writeThread.interrupt();\n+        }\n+        logger.debug(\"waiting for read thread to exit for port {}\", m_logName);\n+        try {\n+            if (m_readThread != null) {\n+                m_readThread.join();\n+            }\n+        } catch (InterruptedException e) {\n+            logger.debug(\"got interrupted waiting for read thread to exit.\");\n+        }\n+        logger.debug(\"waiting for write thread to exit for port {}\", m_logName);\n+        try {\n+            if (m_writeThread != null) {\n+                m_writeThread.join();\n+            }\n+        } catch (InterruptedException e) {\n+            logger.debug(\"got interrupted waiting for write thread to exit.\");\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ed93353c47fa5d457223c66d8f91b1c168a57e23"}, "originalPosition": 208}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Njc0OTAzMw==", "bodyText": "shouldn't this be?\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        InputStream input = DeviceTypeLoader.class.getResourceAsStream(\"/device_types.xml\");\n          \n          \n            \n                        InputStream input = FrameworkUtil.getBundle(DeviceTypeLoader.class).getResource(\"/device_types.xml\").openStream();", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r386749033", "createdAt": "2020-03-03T01:23:07Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.insteon/src/main/java/org/openhab/binding/insteon/internal/device/DeviceTypeLoader.java", "diffHunk": "@@ -0,0 +1,237 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.insteon.internal.device;\n+\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.util.HashMap;\n+import java.util.Map.Entry;\n+\n+import javax.xml.parsers.DocumentBuilder;\n+import javax.xml.parsers.DocumentBuilderFactory;\n+import javax.xml.parsers.ParserConfigurationException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.insteon.internal.device.DeviceType.FeatureGroup;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.w3c.dom.Document;\n+import org.w3c.dom.Element;\n+import org.w3c.dom.Node;\n+import org.w3c.dom.NodeList;\n+import org.xml.sax.SAXException;\n+\n+/**\n+ * Reads the device types from an xml file.\n+ *\n+ * @author Daniel Pfrommer - Initial contribution\n+ * @author Bernd Pfrommer - OpenHAB 1 insteonplm binding\n+ * @author Rob Nielsen - Port to OpenHAB 2 insteon binding\n+ */\n+@NonNullByDefault\n+public class DeviceTypeLoader {\n+    private static final Logger logger = LoggerFactory.getLogger(DeviceTypeLoader.class);\n+    private HashMap<String, DeviceType> m_deviceTypes = new HashMap<String, DeviceType>();\n+    private @Nullable static DeviceTypeLoader s_deviceTypeLoader = null;\n+\n+    private DeviceTypeLoader() {\n+    } // private so nobody can call it\n+\n+    /**\n+     * Finds the device type for a given product key\n+     *\n+     * @param aProdKey product key to search for\n+     * @return the device type, or null if not found\n+     */\n+    public @Nullable DeviceType getDeviceType(String aProdKey) {\n+        return (m_deviceTypes.get(aProdKey));\n+    }\n+\n+    /**\n+     * Must call loadDeviceTypesXML() before calling this function!\n+     *\n+     * @return currently known device types\n+     */\n+    public HashMap<String, DeviceType> getDeviceTypes() {\n+        return (m_deviceTypes);\n+    }\n+\n+    /**\n+     * Reads the device types from input stream and stores them in memory for\n+     * later access.\n+     *\n+     * @param is the input stream from which to read\n+     */\n+    public void loadDeviceTypesXML(InputStream in) throws ParserConfigurationException, SAXException, IOException {\n+        DocumentBuilderFactory dbFactory = DocumentBuilderFactory.newInstance();\n+        DocumentBuilder dBuilder = dbFactory.newDocumentBuilder();\n+        Document doc = dBuilder.parse(in);\n+        doc.getDocumentElement().normalize();\n+        Node root = doc.getDocumentElement();\n+        NodeList nodes = root.getChildNodes();\n+        for (int i = 0; i < nodes.getLength(); i++) {\n+            Node node = nodes.item(i);\n+            if (node.getNodeType() == Node.ELEMENT_NODE && node.getNodeName().equals(\"device\")) {\n+                processDevice((Element) node);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Reads the device types from file and stores them in memory for later access.\n+     *\n+     * @param aFileName The name of the file to read from\n+     * @throws ParserConfigurationException\n+     * @throws SAXException\n+     * @throws IOException\n+     */\n+    public void loadDeviceTypesXML(String aFileName) throws ParserConfigurationException, SAXException, IOException {\n+        File file = new File(aFileName);\n+        InputStream in = new FileInputStream(file);\n+        loadDeviceTypesXML(in);\n+    }\n+\n+    /**\n+     * Process device node\n+     *\n+     * @param e name of the element to process\n+     * @throws SAXException\n+     */\n+    private void processDevice(Element e) throws SAXException {\n+        String productKey = e.getAttribute(\"productKey\");\n+        if (productKey.equals(\"\")) {\n+            throw new SAXException(\"device in device_types file has no product key!\");\n+        }\n+        if (m_deviceTypes.containsKey(productKey)) {\n+            logger.warn(\"overwriting previous definition of device {}\", productKey);\n+            m_deviceTypes.remove(productKey);\n+        }\n+        DeviceType devType = new DeviceType(productKey);\n+\n+        NodeList nodes = e.getChildNodes();\n+        for (int i = 0; i < nodes.getLength(); i++) {\n+            Node node = nodes.item(i);\n+            if (node.getNodeType() != Node.ELEMENT_NODE) {\n+                continue;\n+            }\n+            Element subElement = (Element) node;\n+            if (subElement.getNodeName().equals(\"model\")) {\n+                devType.setModel(subElement.getTextContent());\n+            } else if (subElement.getNodeName().equals(\"description\")) {\n+                devType.setDescription(subElement.getTextContent());\n+            } else if (subElement.getNodeName().equals(\"feature\")) {\n+                processFeature(devType, subElement);\n+            } else if (subElement.getNodeName().equals(\"feature_group\")) {\n+                processFeatureGroup(devType, subElement);\n+            }\n+            m_deviceTypes.put(productKey, devType);\n+        }\n+    }\n+\n+    private String processFeature(DeviceType devType, Element e) throws SAXException {\n+        String name = e.getAttribute(\"name\");\n+        if (name.equals(\"\")) {\n+            throw new SAXException(\"feature \" + e.getNodeName() + \" has feature without name!\");\n+        }\n+        if (!name.equals(name.toLowerCase())) {\n+            throw new SAXException(\"feature name '\" + name + \"' must be lower case\");\n+        }\n+        if (!devType.addFeature(name, e.getTextContent())) {\n+            throw new SAXException(\"duplicate feature: \" + name);\n+        }\n+        return (name);\n+    }\n+\n+    private String processFeatureGroup(DeviceType devType, Element e) throws SAXException {\n+        String name = e.getAttribute(\"name\");\n+        if (name.equals(\"\")) {\n+            throw new SAXException(\"feature group \" + e.getNodeName() + \" has no name attr!\");\n+        }\n+        String type = e.getAttribute(\"type\");\n+        if (type.equals(\"\")) {\n+            throw new SAXException(\"feature group \" + e.getNodeName() + \" has no type attr!\");\n+        }\n+        FeatureGroup fg = new FeatureGroup(name, type);\n+        NodeList nodes = e.getChildNodes();\n+        for (int i = 0; i < nodes.getLength(); i++) {\n+            Node node = nodes.item(i);\n+            if (node.getNodeType() != Node.ELEMENT_NODE) {\n+                continue;\n+            }\n+            Element subElement = (Element) node;\n+            if (subElement.getNodeName().equals(\"feature\")) {\n+                fg.addFeature(processFeature(devType, subElement));\n+            } else if (subElement.getNodeName().equals(\"feature_group\")) {\n+                fg.addFeature(processFeatureGroup(devType, subElement));\n+            }\n+        }\n+        if (!devType.addFeatureGroup(name, fg)) {\n+            throw new SAXException(\"duplicate feature group \" + name);\n+        }\n+        return (name);\n+    }\n+\n+    /**\n+     * Helper function for debugging\n+     */\n+    private void logDeviceTypes() {\n+        for (Entry<String, DeviceType> dt : getDeviceTypes().entrySet()) {\n+            String msg = String.format(\"%-10s->\", dt.getKey()) + dt.getValue();\n+            logger.debug(\"{}\", msg);\n+        }\n+    }\n+\n+    /**\n+     * Singleton instance function, creates DeviceTypeLoader\n+     *\n+     * @return DeviceTypeLoader singleton reference\n+     */\n+    @Nullable\n+    public static synchronized DeviceTypeLoader s_instance() {\n+        if (s_deviceTypeLoader == null) {\n+            s_deviceTypeLoader = new DeviceTypeLoader();\n+            InputStream input = DeviceTypeLoader.class.getResourceAsStream(\"/device_types.xml\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ed93353c47fa5d457223c66d8f91b1c168a57e23"}, "originalPosition": 206}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Njc0OTM3Ng==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    logger.info(\"channel {} unlinked \", channelUID.getAsString());\n          \n          \n            \n                    logger.debug(\"channel {} unlinked \", channelUID.getAsString());", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r386749376", "createdAt": "2020-03-03T01:24:20Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.insteon/src/main/java/org/openhab/binding/insteon/internal/handler/InsteonDeviceHandler.java", "diffHunk": "@@ -0,0 +1,329 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.insteon.internal.handler;\n+\n+import java.math.BigDecimal;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.builder.ThingBuilder;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.openhab.binding.insteon.internal.InsteonBinding;\n+import org.openhab.binding.insteon.internal.InsteonBindingConstants;\n+import org.openhab.binding.insteon.internal.config.InsteonChannelConfiguration;\n+import org.openhab.binding.insteon.internal.config.InsteonDeviceConfiguration;\n+import org.openhab.binding.insteon.internal.device.DeviceFeature;\n+import org.openhab.binding.insteon.internal.device.DeviceTypeLoader;\n+import org.openhab.binding.insteon.internal.device.InsteonAddress;\n+import org.openhab.binding.insteon.internal.device.InsteonDevice;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link InsteonDeviceHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Rob Nielsen - Initial contribution\n+ */\n+@NonNullByDefault\n+public class InsteonDeviceHandler extends BaseThingHandler {\n+\n+    private static final Set<String> DEFINED_CHANNELS = Collections.unmodifiableSet(Stream.of(\n+            InsteonBindingConstants.AC_DELAY, InsteonBindingConstants.BACKLIGHT_DURATION,\n+            InsteonBindingConstants.BATTERY_LEVEL, InsteonBindingConstants.BATTERY_WATERMARK_LEVEL,\n+            InsteonBindingConstants.BOTTOM_OUTLET, InsteonBindingConstants.BUTTON_A, InsteonBindingConstants.BUTTON_B,\n+            InsteonBindingConstants.BUTTON_C, InsteonBindingConstants.BUTTON_D, InsteonBindingConstants.BUTTON_E,\n+            InsteonBindingConstants.BUTTON_F, InsteonBindingConstants.BUTTON_G, InsteonBindingConstants.BUTTON_H,\n+            InsteonBindingConstants.BROADCAST_ON_OFF, InsteonBindingConstants.CONTACT,\n+            InsteonBindingConstants.COOL_SET_POINT, InsteonBindingConstants.DIMMER, InsteonBindingConstants.FAN,\n+            InsteonBindingConstants.FAN_MODE, InsteonBindingConstants.FAST_ON_OFF,\n+            InsteonBindingConstants.FAST_ON_OFF_BUTTON_A, InsteonBindingConstants.FAST_ON_OFF_BUTTON_B,\n+            InsteonBindingConstants.FAST_ON_OFF_BUTTON_C, InsteonBindingConstants.FAST_ON_OFF_BUTTON_D,\n+            InsteonBindingConstants.HEAT_SET_POINT, InsteonBindingConstants.HUMIDITY,\n+            InsteonBindingConstants.HUMIDITY_HIGH, InsteonBindingConstants.HUMIDITY_LOW,\n+            InsteonBindingConstants.IS_COOLING, InsteonBindingConstants.IS_HEATING,\n+            InsteonBindingConstants.KEYPAD_BUTTON_A, InsteonBindingConstants.KEYPAD_BUTTON_B,\n+            InsteonBindingConstants.KEYPAD_BUTTON_C, InsteonBindingConstants.KEYPAD_BUTTON_D,\n+            InsteonBindingConstants.KEYPAD_BUTTON_E, InsteonBindingConstants.KEYPAD_BUTTON_F,\n+            InsteonBindingConstants.KEYPAD_BUTTON_G, InsteonBindingConstants.KEYPAD_BUTTON_H,\n+            InsteonBindingConstants.KWH, InsteonBindingConstants.LAST_HEARD_FROM,\n+            InsteonBindingConstants.LED_BRIGHTNESS, InsteonBindingConstants.LIGHT_DIMMER,\n+            InsteonBindingConstants.LIGHT_LEVEL, InsteonBindingConstants.LOAD_DIMMER,\n+            InsteonBindingConstants.LOAD_SWITCH, InsteonBindingConstants.LOAD_SWITCH_FAST_ON_OFF,\n+            InsteonBindingConstants.LOAD_SWITCH_MANUAL_CHANGE, InsteonBindingConstants.MANUAL_CHANGE,\n+            InsteonBindingConstants.MANUAL_CHANGE_BUTTON_A, InsteonBindingConstants.MANUAL_CHANGE_BUTTON_B,\n+            InsteonBindingConstants.MANUAL_CHANGE_BUTTON_C, InsteonBindingConstants.MANUAL_CHANGE_BUTTON_D,\n+            InsteonBindingConstants.NOTIFICATION, InsteonBindingConstants.ON_LEVEL, InsteonBindingConstants.RAMP_DIMMER,\n+            InsteonBindingConstants.RAMP_RATE, InsteonBindingConstants.RESET, InsteonBindingConstants.STAGE1_DURATION,\n+            InsteonBindingConstants.SWITCH, InsteonBindingConstants.SYSTEM_MODE, InsteonBindingConstants.TEMP_CELSIUS,\n+            InsteonBindingConstants.TEMP_FAHRENHEIT, InsteonBindingConstants.TOP_OUTLET, InsteonBindingConstants.UPDATE,\n+            InsteonBindingConstants.WATTS).collect(Collectors.toSet()));\n+\n+    private static final String BROADCAST_ON_OFF = \"broadcastonoff\";\n+    private static final String CMD = \"cmd\";\n+    private static final String CMD_RESET = \"reset\";\n+    private static final String CMD_UPDATE = \"update\";\n+    private static final String DATA = \"data\";\n+    private static final String FIELD = \"field\";\n+    private static final String FIELD_BATTERY_LEVEL = \"battery_level\";\n+    private static final String FIELD_BATTERY_WATERMARK_LEVEL = \"battery_watermark_level\";\n+    private static final String FIELD_KWH = \"kwh\";\n+    private static final String FIELD_LIGHT_LEVEL = \"light_level\";\n+    private static final String FIELD_WATTS = \"watts\";\n+    private static final String GROUP = \"group\";\n+    private static final String METER = \"meter\";\n+\n+    private static final String HIDDEN_DOOR_SENSOR_PRODUCT_KEY = \"F00.00.03\";\n+    private static final String MOTION_SENSOR_PRODUCT_KEY = \"0x00004A\";\n+    private static final String PLM_PRODUCT_KEY = \"0x000045\";\n+    private static final String POWER_METER_PRODUCT_KEY = \"F00.00.17\";\n+\n+    private final Logger logger = LoggerFactory.getLogger(InsteonDeviceHandler.class);\n+\n+    private @Nullable InsteonDeviceConfiguration config;\n+\n+    public InsteonDeviceHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        config = getConfigAs(InsteonDeviceConfiguration.class);\n+\n+        scheduler.execute(() -> {\n+            if (getBridge() == null) {\n+                String msg = \"An Insteon network bridge has not been selected for this device.\";\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, msg);\n+                return;\n+            }\n+\n+            String address = config.getAddress();\n+            if (!InsteonAddress.s_isValid(address)) {\n+                String msg = \"Unable to start Insteon device, the insteon or X10 address '\" + address\n+                        + \"' is invalid. It must be in the format 'AB.CD.EF' or 'H.U' (X10).\";\n+                logger.warn(msg);\n+\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, msg);\n+                return;\n+            }\n+\n+            String productKey = config.getProductKey();\n+            if (DeviceTypeLoader.s_instance().getDeviceType(productKey) == null) {\n+                String msg = \"Unable to start Insteon device, invalid product key '\" + productKey + \"'.\";\n+                logger.warn(msg);\n+\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, msg);\n+                return;\n+            }\n+\n+            InsteonBinding insteonBinding = getInsteonBinding();\n+            InsteonAddress insteonAddress = new InsteonAddress(address);\n+            if (insteonBinding.getDevice(insteonAddress) != null) {\n+                String msg = \"a device already exists with the address '\" + address + \"'.\";\n+                logger.warn(msg);\n+\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, msg);\n+                return;\n+            }\n+\n+            InsteonDevice device = insteonBinding.makeNewDevice(insteonAddress, productKey);\n+\n+            // By default the device is assigned all channels. Channels are associated with a feature, cull the ones\n+            // that are supported by this device.\n+            StringBuffer channelList = new StringBuffer();\n+            List<Channel> supportedChannels = new ArrayList<Channel>();\n+            List<Channel> initialChannels = getThing().getChannels();\n+            String thingId = getThing().getUID().getAsString();\n+            for (Channel channel : initialChannels) {\n+                String channelId = channel.getUID().getId();\n+                String feature = channelId.toLowerCase();\n+\n+                if (productKey.equals(HIDDEN_DOOR_SENSOR_PRODUCT_KEY)) {\n+                    if (feature.equalsIgnoreCase(InsteonBindingConstants.BATTERY_LEVEL)\n+                            || feature.equalsIgnoreCase(InsteonBindingConstants.BATTERY_WATERMARK_LEVEL)) {\n+\n+                        feature = DATA;\n+                    }\n+                } else if (productKey.equals(MOTION_SENSOR_PRODUCT_KEY)) {\n+                    if (feature.equalsIgnoreCase(InsteonBindingConstants.BATTERY_LEVEL)\n+                            || feature.equalsIgnoreCase(InsteonBindingConstants.LIGHT_LEVEL)) {\n+\n+                        feature = DATA;\n+                    }\n+                } else if (productKey.equals(PLM_PRODUCT_KEY)) {\n+                    String parts[] = feature.split(\"#\");\n+                    if (parts.length == 2 && parts[0].equalsIgnoreCase(InsteonBindingConstants.BROADCAST_ON_OFF)\n+                            && parts[1].matches(\"^\\\\d+$\")) {\n+                        feature = BROADCAST_ON_OFF;\n+                    }\n+                } else if (productKey.equals(POWER_METER_PRODUCT_KEY)) {\n+                    if (feature.equalsIgnoreCase(InsteonBindingConstants.KWH)\n+                            || feature.equalsIgnoreCase(InsteonBindingConstants.RESET)\n+                            || feature.equalsIgnoreCase(InsteonBindingConstants.UPDATE)\n+                            || feature.equalsIgnoreCase(InsteonBindingConstants.WATTS)) {\n+\n+                        feature = METER;\n+                    }\n+                }\n+\n+                DeviceFeature f = device.getFeature(feature);\n+                if (f == null) {\n+                    if (!DEFINED_CHANNELS.contains(channelId)) {\n+                        logger.warn(\"{} includes channel {}, it is not a valid feature for {}. It has been removed.\",\n+                                thingId, channelId, productKey);\n+                    }\n+                } else if (f.isFeatureGroup()) {\n+                    logger.warn(\"{} includes channel {}, it is a feature group for {}. It has been removed.\", thingId,\n+                            channelId, productKey);\n+                } else {\n+                    supportedChannels.add(channel);\n+\n+                    if (channelList.length() > 0) {\n+                        channelList.append(\", \");\n+                    }\n+                    channelList.append(channelId);\n+\n+                    if (!DEFINED_CHANNELS.contains(channelId)) {\n+                        for (String c : DEFINED_CHANNELS) {\n+                            if (channelId.equalsIgnoreCase(c)) {\n+                                logger.warn(\"{} includes channel {}, should it be {}?\", thingId, channelId, c);\n+                                break;\n+                            }\n+                        }\n+                    }\n+                }\n+            }\n+\n+            // only update if channels were culled\n+            if (initialChannels.size() != supportedChannels.size()) {\n+                ThingBuilder thingBuilder = editThing();\n+                thingBuilder.withChannels(supportedChannels);\n+                updateThing(thingBuilder.build());\n+            }\n+\n+            logger.info(\"{} address = {} productKey = {} channels = {}\", thingId, address, productKey,\n+                    channelList.toString());\n+\n+            updateStatus(ThingStatus.ONLINE);\n+        });\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        String address = config.getAddress();\n+        if (getBridge() != null && InsteonAddress.s_isValid(address)) {\n+            getInsteonBinding().removeDevice(new InsteonAddress(address));\n+\n+            logger.info(\"removed {} address = {}\", getThing().getUID().getAsString(), address);\n+        }\n+\n+        super.dispose();\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        logger.info(\"channel {} was triggered with the command {}\", channelUID.getAsString(), command);\n+\n+        getInsteonBinding().sendCommand(channelUID.getAsString(), command);\n+    }\n+\n+    @Override\n+    public void channelLinked(ChannelUID channelUID) {\n+        HashMap<String, @Nullable String> params = new HashMap<String, @Nullable String>();\n+        Channel channel = getThing().getChannel(channelUID.getId());\n+\n+        Map<String, Object> channelProperties = channel.getConfiguration().getProperties();\n+        for (String key : channelProperties.keySet()) {\n+            Object value = channelProperties.get(key);\n+            if (value instanceof String) {\n+                params.put(key, (String) value);\n+            } else if (value instanceof BigDecimal) {\n+                String s = ((BigDecimal) value).toPlainString();\n+                params.put(key, s);\n+            } else {\n+                logger.warn(\"not a string or big decimal value key '{}' value '{}' {}\", key, value,\n+                        value.getClass().getName());\n+            }\n+        }\n+\n+        String feature = channelUID.getId().toLowerCase();\n+        String productKey = config.getProductKey();\n+        if (productKey.equals(HIDDEN_DOOR_SENSOR_PRODUCT_KEY)) {\n+            if (feature.equalsIgnoreCase(InsteonBindingConstants.BATTERY_LEVEL)) {\n+                params.put(FIELD, FIELD_BATTERY_LEVEL);\n+                feature = DATA;\n+            } else if (feature.equalsIgnoreCase(InsteonBindingConstants.BATTERY_WATERMARK_LEVEL)) {\n+                params.put(FIELD, FIELD_BATTERY_WATERMARK_LEVEL);\n+                feature = DATA;\n+            }\n+        } else if (productKey.equals(MOTION_SENSOR_PRODUCT_KEY)) {\n+            if (feature.equalsIgnoreCase(InsteonBindingConstants.BATTERY_LEVEL)) {\n+                params.put(FIELD, FIELD_BATTERY_LEVEL);\n+                feature = DATA;\n+            } else if (feature.equalsIgnoreCase(InsteonBindingConstants.LIGHT_LEVEL)) {\n+                params.put(FIELD, FIELD_LIGHT_LEVEL);\n+                feature = DATA;\n+            }\n+        } else if (productKey.equals(PLM_PRODUCT_KEY)) {\n+            String parts[] = feature.split(\"#\");\n+            if (parts.length == 2 && parts[0].equalsIgnoreCase(InsteonBindingConstants.BROADCAST_ON_OFF)\n+                    && parts[1].matches(\"^\\\\d+$\")) {\n+                params.put(GROUP, parts[1]);\n+                feature = BROADCAST_ON_OFF;\n+            }\n+        } else if (productKey.equals(POWER_METER_PRODUCT_KEY)) {\n+            if (feature.equalsIgnoreCase(InsteonBindingConstants.KWH)) {\n+                params.put(FIELD, FIELD_KWH);\n+            } else if (feature.equalsIgnoreCase(InsteonBindingConstants.WATTS)) {\n+                params.put(FIELD, FIELD_WATTS);\n+            } else if (feature.equalsIgnoreCase(InsteonBindingConstants.RESET)) {\n+                params.put(CMD, CMD_RESET);\n+            } else if (feature.equalsIgnoreCase(InsteonBindingConstants.UPDATE)) {\n+                params.put(CMD, CMD_UPDATE);\n+            }\n+\n+            feature = METER;\n+        }\n+\n+        InsteonChannelConfiguration bindingConfig = new InsteonChannelConfiguration(channelUID, feature,\n+                new InsteonAddress(config.getAddress()), productKey, params);\n+        getInsteonBinding().addFeatureListener(bindingConfig);\n+\n+        logger.info(\"channel {} linked with the feature: {} parameters: {}\", channelUID.getAsString(), feature, params);\n+    }\n+\n+    @Override\n+    public void channelUnlinked(ChannelUID channelUID) {\n+        getInsteonBinding().removeFeatureListener(channelUID);\n+\n+        logger.info(\"channel {} unlinked \", channelUID.getAsString());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ed93353c47fa5d457223c66d8f91b1c168a57e23"}, "originalPosition": 323}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Njc0OTU4OQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    logger.info(\"channel {} linked with the feature: {} parameters: {}\", channelUID.getAsString(), feature, params);\n          \n          \n            \n                    logger.debug(\"channel {} linked with the feature: {} parameters: {}\", channelUID.getAsString(), feature, params);", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r386749589", "createdAt": "2020-03-03T01:25:04Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.insteon/src/main/java/org/openhab/binding/insteon/internal/handler/InsteonDeviceHandler.java", "diffHunk": "@@ -0,0 +1,329 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.insteon.internal.handler;\n+\n+import java.math.BigDecimal;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.builder.ThingBuilder;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.openhab.binding.insteon.internal.InsteonBinding;\n+import org.openhab.binding.insteon.internal.InsteonBindingConstants;\n+import org.openhab.binding.insteon.internal.config.InsteonChannelConfiguration;\n+import org.openhab.binding.insteon.internal.config.InsteonDeviceConfiguration;\n+import org.openhab.binding.insteon.internal.device.DeviceFeature;\n+import org.openhab.binding.insteon.internal.device.DeviceTypeLoader;\n+import org.openhab.binding.insteon.internal.device.InsteonAddress;\n+import org.openhab.binding.insteon.internal.device.InsteonDevice;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link InsteonDeviceHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Rob Nielsen - Initial contribution\n+ */\n+@NonNullByDefault\n+public class InsteonDeviceHandler extends BaseThingHandler {\n+\n+    private static final Set<String> DEFINED_CHANNELS = Collections.unmodifiableSet(Stream.of(\n+            InsteonBindingConstants.AC_DELAY, InsteonBindingConstants.BACKLIGHT_DURATION,\n+            InsteonBindingConstants.BATTERY_LEVEL, InsteonBindingConstants.BATTERY_WATERMARK_LEVEL,\n+            InsteonBindingConstants.BOTTOM_OUTLET, InsteonBindingConstants.BUTTON_A, InsteonBindingConstants.BUTTON_B,\n+            InsteonBindingConstants.BUTTON_C, InsteonBindingConstants.BUTTON_D, InsteonBindingConstants.BUTTON_E,\n+            InsteonBindingConstants.BUTTON_F, InsteonBindingConstants.BUTTON_G, InsteonBindingConstants.BUTTON_H,\n+            InsteonBindingConstants.BROADCAST_ON_OFF, InsteonBindingConstants.CONTACT,\n+            InsteonBindingConstants.COOL_SET_POINT, InsteonBindingConstants.DIMMER, InsteonBindingConstants.FAN,\n+            InsteonBindingConstants.FAN_MODE, InsteonBindingConstants.FAST_ON_OFF,\n+            InsteonBindingConstants.FAST_ON_OFF_BUTTON_A, InsteonBindingConstants.FAST_ON_OFF_BUTTON_B,\n+            InsteonBindingConstants.FAST_ON_OFF_BUTTON_C, InsteonBindingConstants.FAST_ON_OFF_BUTTON_D,\n+            InsteonBindingConstants.HEAT_SET_POINT, InsteonBindingConstants.HUMIDITY,\n+            InsteonBindingConstants.HUMIDITY_HIGH, InsteonBindingConstants.HUMIDITY_LOW,\n+            InsteonBindingConstants.IS_COOLING, InsteonBindingConstants.IS_HEATING,\n+            InsteonBindingConstants.KEYPAD_BUTTON_A, InsteonBindingConstants.KEYPAD_BUTTON_B,\n+            InsteonBindingConstants.KEYPAD_BUTTON_C, InsteonBindingConstants.KEYPAD_BUTTON_D,\n+            InsteonBindingConstants.KEYPAD_BUTTON_E, InsteonBindingConstants.KEYPAD_BUTTON_F,\n+            InsteonBindingConstants.KEYPAD_BUTTON_G, InsteonBindingConstants.KEYPAD_BUTTON_H,\n+            InsteonBindingConstants.KWH, InsteonBindingConstants.LAST_HEARD_FROM,\n+            InsteonBindingConstants.LED_BRIGHTNESS, InsteonBindingConstants.LIGHT_DIMMER,\n+            InsteonBindingConstants.LIGHT_LEVEL, InsteonBindingConstants.LOAD_DIMMER,\n+            InsteonBindingConstants.LOAD_SWITCH, InsteonBindingConstants.LOAD_SWITCH_FAST_ON_OFF,\n+            InsteonBindingConstants.LOAD_SWITCH_MANUAL_CHANGE, InsteonBindingConstants.MANUAL_CHANGE,\n+            InsteonBindingConstants.MANUAL_CHANGE_BUTTON_A, InsteonBindingConstants.MANUAL_CHANGE_BUTTON_B,\n+            InsteonBindingConstants.MANUAL_CHANGE_BUTTON_C, InsteonBindingConstants.MANUAL_CHANGE_BUTTON_D,\n+            InsteonBindingConstants.NOTIFICATION, InsteonBindingConstants.ON_LEVEL, InsteonBindingConstants.RAMP_DIMMER,\n+            InsteonBindingConstants.RAMP_RATE, InsteonBindingConstants.RESET, InsteonBindingConstants.STAGE1_DURATION,\n+            InsteonBindingConstants.SWITCH, InsteonBindingConstants.SYSTEM_MODE, InsteonBindingConstants.TEMP_CELSIUS,\n+            InsteonBindingConstants.TEMP_FAHRENHEIT, InsteonBindingConstants.TOP_OUTLET, InsteonBindingConstants.UPDATE,\n+            InsteonBindingConstants.WATTS).collect(Collectors.toSet()));\n+\n+    private static final String BROADCAST_ON_OFF = \"broadcastonoff\";\n+    private static final String CMD = \"cmd\";\n+    private static final String CMD_RESET = \"reset\";\n+    private static final String CMD_UPDATE = \"update\";\n+    private static final String DATA = \"data\";\n+    private static final String FIELD = \"field\";\n+    private static final String FIELD_BATTERY_LEVEL = \"battery_level\";\n+    private static final String FIELD_BATTERY_WATERMARK_LEVEL = \"battery_watermark_level\";\n+    private static final String FIELD_KWH = \"kwh\";\n+    private static final String FIELD_LIGHT_LEVEL = \"light_level\";\n+    private static final String FIELD_WATTS = \"watts\";\n+    private static final String GROUP = \"group\";\n+    private static final String METER = \"meter\";\n+\n+    private static final String HIDDEN_DOOR_SENSOR_PRODUCT_KEY = \"F00.00.03\";\n+    private static final String MOTION_SENSOR_PRODUCT_KEY = \"0x00004A\";\n+    private static final String PLM_PRODUCT_KEY = \"0x000045\";\n+    private static final String POWER_METER_PRODUCT_KEY = \"F00.00.17\";\n+\n+    private final Logger logger = LoggerFactory.getLogger(InsteonDeviceHandler.class);\n+\n+    private @Nullable InsteonDeviceConfiguration config;\n+\n+    public InsteonDeviceHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        config = getConfigAs(InsteonDeviceConfiguration.class);\n+\n+        scheduler.execute(() -> {\n+            if (getBridge() == null) {\n+                String msg = \"An Insteon network bridge has not been selected for this device.\";\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, msg);\n+                return;\n+            }\n+\n+            String address = config.getAddress();\n+            if (!InsteonAddress.s_isValid(address)) {\n+                String msg = \"Unable to start Insteon device, the insteon or X10 address '\" + address\n+                        + \"' is invalid. It must be in the format 'AB.CD.EF' or 'H.U' (X10).\";\n+                logger.warn(msg);\n+\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, msg);\n+                return;\n+            }\n+\n+            String productKey = config.getProductKey();\n+            if (DeviceTypeLoader.s_instance().getDeviceType(productKey) == null) {\n+                String msg = \"Unable to start Insteon device, invalid product key '\" + productKey + \"'.\";\n+                logger.warn(msg);\n+\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, msg);\n+                return;\n+            }\n+\n+            InsteonBinding insteonBinding = getInsteonBinding();\n+            InsteonAddress insteonAddress = new InsteonAddress(address);\n+            if (insteonBinding.getDevice(insteonAddress) != null) {\n+                String msg = \"a device already exists with the address '\" + address + \"'.\";\n+                logger.warn(msg);\n+\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, msg);\n+                return;\n+            }\n+\n+            InsteonDevice device = insteonBinding.makeNewDevice(insteonAddress, productKey);\n+\n+            // By default the device is assigned all channels. Channels are associated with a feature, cull the ones\n+            // that are supported by this device.\n+            StringBuffer channelList = new StringBuffer();\n+            List<Channel> supportedChannels = new ArrayList<Channel>();\n+            List<Channel> initialChannels = getThing().getChannels();\n+            String thingId = getThing().getUID().getAsString();\n+            for (Channel channel : initialChannels) {\n+                String channelId = channel.getUID().getId();\n+                String feature = channelId.toLowerCase();\n+\n+                if (productKey.equals(HIDDEN_DOOR_SENSOR_PRODUCT_KEY)) {\n+                    if (feature.equalsIgnoreCase(InsteonBindingConstants.BATTERY_LEVEL)\n+                            || feature.equalsIgnoreCase(InsteonBindingConstants.BATTERY_WATERMARK_LEVEL)) {\n+\n+                        feature = DATA;\n+                    }\n+                } else if (productKey.equals(MOTION_SENSOR_PRODUCT_KEY)) {\n+                    if (feature.equalsIgnoreCase(InsteonBindingConstants.BATTERY_LEVEL)\n+                            || feature.equalsIgnoreCase(InsteonBindingConstants.LIGHT_LEVEL)) {\n+\n+                        feature = DATA;\n+                    }\n+                } else if (productKey.equals(PLM_PRODUCT_KEY)) {\n+                    String parts[] = feature.split(\"#\");\n+                    if (parts.length == 2 && parts[0].equalsIgnoreCase(InsteonBindingConstants.BROADCAST_ON_OFF)\n+                            && parts[1].matches(\"^\\\\d+$\")) {\n+                        feature = BROADCAST_ON_OFF;\n+                    }\n+                } else if (productKey.equals(POWER_METER_PRODUCT_KEY)) {\n+                    if (feature.equalsIgnoreCase(InsteonBindingConstants.KWH)\n+                            || feature.equalsIgnoreCase(InsteonBindingConstants.RESET)\n+                            || feature.equalsIgnoreCase(InsteonBindingConstants.UPDATE)\n+                            || feature.equalsIgnoreCase(InsteonBindingConstants.WATTS)) {\n+\n+                        feature = METER;\n+                    }\n+                }\n+\n+                DeviceFeature f = device.getFeature(feature);\n+                if (f == null) {\n+                    if (!DEFINED_CHANNELS.contains(channelId)) {\n+                        logger.warn(\"{} includes channel {}, it is not a valid feature for {}. It has been removed.\",\n+                                thingId, channelId, productKey);\n+                    }\n+                } else if (f.isFeatureGroup()) {\n+                    logger.warn(\"{} includes channel {}, it is a feature group for {}. It has been removed.\", thingId,\n+                            channelId, productKey);\n+                } else {\n+                    supportedChannels.add(channel);\n+\n+                    if (channelList.length() > 0) {\n+                        channelList.append(\", \");\n+                    }\n+                    channelList.append(channelId);\n+\n+                    if (!DEFINED_CHANNELS.contains(channelId)) {\n+                        for (String c : DEFINED_CHANNELS) {\n+                            if (channelId.equalsIgnoreCase(c)) {\n+                                logger.warn(\"{} includes channel {}, should it be {}?\", thingId, channelId, c);\n+                                break;\n+                            }\n+                        }\n+                    }\n+                }\n+            }\n+\n+            // only update if channels were culled\n+            if (initialChannels.size() != supportedChannels.size()) {\n+                ThingBuilder thingBuilder = editThing();\n+                thingBuilder.withChannels(supportedChannels);\n+                updateThing(thingBuilder.build());\n+            }\n+\n+            logger.info(\"{} address = {} productKey = {} channels = {}\", thingId, address, productKey,\n+                    channelList.toString());\n+\n+            updateStatus(ThingStatus.ONLINE);\n+        });\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        String address = config.getAddress();\n+        if (getBridge() != null && InsteonAddress.s_isValid(address)) {\n+            getInsteonBinding().removeDevice(new InsteonAddress(address));\n+\n+            logger.info(\"removed {} address = {}\", getThing().getUID().getAsString(), address);\n+        }\n+\n+        super.dispose();\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        logger.info(\"channel {} was triggered with the command {}\", channelUID.getAsString(), command);\n+\n+        getInsteonBinding().sendCommand(channelUID.getAsString(), command);\n+    }\n+\n+    @Override\n+    public void channelLinked(ChannelUID channelUID) {\n+        HashMap<String, @Nullable String> params = new HashMap<String, @Nullable String>();\n+        Channel channel = getThing().getChannel(channelUID.getId());\n+\n+        Map<String, Object> channelProperties = channel.getConfiguration().getProperties();\n+        for (String key : channelProperties.keySet()) {\n+            Object value = channelProperties.get(key);\n+            if (value instanceof String) {\n+                params.put(key, (String) value);\n+            } else if (value instanceof BigDecimal) {\n+                String s = ((BigDecimal) value).toPlainString();\n+                params.put(key, s);\n+            } else {\n+                logger.warn(\"not a string or big decimal value key '{}' value '{}' {}\", key, value,\n+                        value.getClass().getName());\n+            }\n+        }\n+\n+        String feature = channelUID.getId().toLowerCase();\n+        String productKey = config.getProductKey();\n+        if (productKey.equals(HIDDEN_DOOR_SENSOR_PRODUCT_KEY)) {\n+            if (feature.equalsIgnoreCase(InsteonBindingConstants.BATTERY_LEVEL)) {\n+                params.put(FIELD, FIELD_BATTERY_LEVEL);\n+                feature = DATA;\n+            } else if (feature.equalsIgnoreCase(InsteonBindingConstants.BATTERY_WATERMARK_LEVEL)) {\n+                params.put(FIELD, FIELD_BATTERY_WATERMARK_LEVEL);\n+                feature = DATA;\n+            }\n+        } else if (productKey.equals(MOTION_SENSOR_PRODUCT_KEY)) {\n+            if (feature.equalsIgnoreCase(InsteonBindingConstants.BATTERY_LEVEL)) {\n+                params.put(FIELD, FIELD_BATTERY_LEVEL);\n+                feature = DATA;\n+            } else if (feature.equalsIgnoreCase(InsteonBindingConstants.LIGHT_LEVEL)) {\n+                params.put(FIELD, FIELD_LIGHT_LEVEL);\n+                feature = DATA;\n+            }\n+        } else if (productKey.equals(PLM_PRODUCT_KEY)) {\n+            String parts[] = feature.split(\"#\");\n+            if (parts.length == 2 && parts[0].equalsIgnoreCase(InsteonBindingConstants.BROADCAST_ON_OFF)\n+                    && parts[1].matches(\"^\\\\d+$\")) {\n+                params.put(GROUP, parts[1]);\n+                feature = BROADCAST_ON_OFF;\n+            }\n+        } else if (productKey.equals(POWER_METER_PRODUCT_KEY)) {\n+            if (feature.equalsIgnoreCase(InsteonBindingConstants.KWH)) {\n+                params.put(FIELD, FIELD_KWH);\n+            } else if (feature.equalsIgnoreCase(InsteonBindingConstants.WATTS)) {\n+                params.put(FIELD, FIELD_WATTS);\n+            } else if (feature.equalsIgnoreCase(InsteonBindingConstants.RESET)) {\n+                params.put(CMD, CMD_RESET);\n+            } else if (feature.equalsIgnoreCase(InsteonBindingConstants.UPDATE)) {\n+                params.put(CMD, CMD_UPDATE);\n+            }\n+\n+            feature = METER;\n+        }\n+\n+        InsteonChannelConfiguration bindingConfig = new InsteonChannelConfiguration(channelUID, feature,\n+                new InsteonAddress(config.getAddress()), productKey, params);\n+        getInsteonBinding().addFeatureListener(bindingConfig);\n+\n+        logger.info(\"channel {} linked with the feature: {} parameters: {}\", channelUID.getAsString(), feature, params);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ed93353c47fa5d457223c66d8f91b1c168a57e23"}, "originalPosition": 316}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Njc0OTc4Mg==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        logger.info(\"{} address = {} productKey = {} channels = {}\", thingId, address, productKey,\n          \n          \n            \n                        logger.debug(\"{} address = {} productKey = {} channels = {}\", thingId, address, productKey,", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r386749782", "createdAt": "2020-03-03T01:25:37Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.insteon/src/main/java/org/openhab/binding/insteon/internal/handler/InsteonDeviceHandler.java", "diffHunk": "@@ -0,0 +1,329 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.insteon.internal.handler;\n+\n+import java.math.BigDecimal;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.builder.ThingBuilder;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.openhab.binding.insteon.internal.InsteonBinding;\n+import org.openhab.binding.insteon.internal.InsteonBindingConstants;\n+import org.openhab.binding.insteon.internal.config.InsteonChannelConfiguration;\n+import org.openhab.binding.insteon.internal.config.InsteonDeviceConfiguration;\n+import org.openhab.binding.insteon.internal.device.DeviceFeature;\n+import org.openhab.binding.insteon.internal.device.DeviceTypeLoader;\n+import org.openhab.binding.insteon.internal.device.InsteonAddress;\n+import org.openhab.binding.insteon.internal.device.InsteonDevice;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link InsteonDeviceHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Rob Nielsen - Initial contribution\n+ */\n+@NonNullByDefault\n+public class InsteonDeviceHandler extends BaseThingHandler {\n+\n+    private static final Set<String> DEFINED_CHANNELS = Collections.unmodifiableSet(Stream.of(\n+            InsteonBindingConstants.AC_DELAY, InsteonBindingConstants.BACKLIGHT_DURATION,\n+            InsteonBindingConstants.BATTERY_LEVEL, InsteonBindingConstants.BATTERY_WATERMARK_LEVEL,\n+            InsteonBindingConstants.BOTTOM_OUTLET, InsteonBindingConstants.BUTTON_A, InsteonBindingConstants.BUTTON_B,\n+            InsteonBindingConstants.BUTTON_C, InsteonBindingConstants.BUTTON_D, InsteonBindingConstants.BUTTON_E,\n+            InsteonBindingConstants.BUTTON_F, InsteonBindingConstants.BUTTON_G, InsteonBindingConstants.BUTTON_H,\n+            InsteonBindingConstants.BROADCAST_ON_OFF, InsteonBindingConstants.CONTACT,\n+            InsteonBindingConstants.COOL_SET_POINT, InsteonBindingConstants.DIMMER, InsteonBindingConstants.FAN,\n+            InsteonBindingConstants.FAN_MODE, InsteonBindingConstants.FAST_ON_OFF,\n+            InsteonBindingConstants.FAST_ON_OFF_BUTTON_A, InsteonBindingConstants.FAST_ON_OFF_BUTTON_B,\n+            InsteonBindingConstants.FAST_ON_OFF_BUTTON_C, InsteonBindingConstants.FAST_ON_OFF_BUTTON_D,\n+            InsteonBindingConstants.HEAT_SET_POINT, InsteonBindingConstants.HUMIDITY,\n+            InsteonBindingConstants.HUMIDITY_HIGH, InsteonBindingConstants.HUMIDITY_LOW,\n+            InsteonBindingConstants.IS_COOLING, InsteonBindingConstants.IS_HEATING,\n+            InsteonBindingConstants.KEYPAD_BUTTON_A, InsteonBindingConstants.KEYPAD_BUTTON_B,\n+            InsteonBindingConstants.KEYPAD_BUTTON_C, InsteonBindingConstants.KEYPAD_BUTTON_D,\n+            InsteonBindingConstants.KEYPAD_BUTTON_E, InsteonBindingConstants.KEYPAD_BUTTON_F,\n+            InsteonBindingConstants.KEYPAD_BUTTON_G, InsteonBindingConstants.KEYPAD_BUTTON_H,\n+            InsteonBindingConstants.KWH, InsteonBindingConstants.LAST_HEARD_FROM,\n+            InsteonBindingConstants.LED_BRIGHTNESS, InsteonBindingConstants.LIGHT_DIMMER,\n+            InsteonBindingConstants.LIGHT_LEVEL, InsteonBindingConstants.LOAD_DIMMER,\n+            InsteonBindingConstants.LOAD_SWITCH, InsteonBindingConstants.LOAD_SWITCH_FAST_ON_OFF,\n+            InsteonBindingConstants.LOAD_SWITCH_MANUAL_CHANGE, InsteonBindingConstants.MANUAL_CHANGE,\n+            InsteonBindingConstants.MANUAL_CHANGE_BUTTON_A, InsteonBindingConstants.MANUAL_CHANGE_BUTTON_B,\n+            InsteonBindingConstants.MANUAL_CHANGE_BUTTON_C, InsteonBindingConstants.MANUAL_CHANGE_BUTTON_D,\n+            InsteonBindingConstants.NOTIFICATION, InsteonBindingConstants.ON_LEVEL, InsteonBindingConstants.RAMP_DIMMER,\n+            InsteonBindingConstants.RAMP_RATE, InsteonBindingConstants.RESET, InsteonBindingConstants.STAGE1_DURATION,\n+            InsteonBindingConstants.SWITCH, InsteonBindingConstants.SYSTEM_MODE, InsteonBindingConstants.TEMP_CELSIUS,\n+            InsteonBindingConstants.TEMP_FAHRENHEIT, InsteonBindingConstants.TOP_OUTLET, InsteonBindingConstants.UPDATE,\n+            InsteonBindingConstants.WATTS).collect(Collectors.toSet()));\n+\n+    private static final String BROADCAST_ON_OFF = \"broadcastonoff\";\n+    private static final String CMD = \"cmd\";\n+    private static final String CMD_RESET = \"reset\";\n+    private static final String CMD_UPDATE = \"update\";\n+    private static final String DATA = \"data\";\n+    private static final String FIELD = \"field\";\n+    private static final String FIELD_BATTERY_LEVEL = \"battery_level\";\n+    private static final String FIELD_BATTERY_WATERMARK_LEVEL = \"battery_watermark_level\";\n+    private static final String FIELD_KWH = \"kwh\";\n+    private static final String FIELD_LIGHT_LEVEL = \"light_level\";\n+    private static final String FIELD_WATTS = \"watts\";\n+    private static final String GROUP = \"group\";\n+    private static final String METER = \"meter\";\n+\n+    private static final String HIDDEN_DOOR_SENSOR_PRODUCT_KEY = \"F00.00.03\";\n+    private static final String MOTION_SENSOR_PRODUCT_KEY = \"0x00004A\";\n+    private static final String PLM_PRODUCT_KEY = \"0x000045\";\n+    private static final String POWER_METER_PRODUCT_KEY = \"F00.00.17\";\n+\n+    private final Logger logger = LoggerFactory.getLogger(InsteonDeviceHandler.class);\n+\n+    private @Nullable InsteonDeviceConfiguration config;\n+\n+    public InsteonDeviceHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        config = getConfigAs(InsteonDeviceConfiguration.class);\n+\n+        scheduler.execute(() -> {\n+            if (getBridge() == null) {\n+                String msg = \"An Insteon network bridge has not been selected for this device.\";\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, msg);\n+                return;\n+            }\n+\n+            String address = config.getAddress();\n+            if (!InsteonAddress.s_isValid(address)) {\n+                String msg = \"Unable to start Insteon device, the insteon or X10 address '\" + address\n+                        + \"' is invalid. It must be in the format 'AB.CD.EF' or 'H.U' (X10).\";\n+                logger.warn(msg);\n+\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, msg);\n+                return;\n+            }\n+\n+            String productKey = config.getProductKey();\n+            if (DeviceTypeLoader.s_instance().getDeviceType(productKey) == null) {\n+                String msg = \"Unable to start Insteon device, invalid product key '\" + productKey + \"'.\";\n+                logger.warn(msg);\n+\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, msg);\n+                return;\n+            }\n+\n+            InsteonBinding insteonBinding = getInsteonBinding();\n+            InsteonAddress insteonAddress = new InsteonAddress(address);\n+            if (insteonBinding.getDevice(insteonAddress) != null) {\n+                String msg = \"a device already exists with the address '\" + address + \"'.\";\n+                logger.warn(msg);\n+\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, msg);\n+                return;\n+            }\n+\n+            InsteonDevice device = insteonBinding.makeNewDevice(insteonAddress, productKey);\n+\n+            // By default the device is assigned all channels. Channels are associated with a feature, cull the ones\n+            // that are supported by this device.\n+            StringBuffer channelList = new StringBuffer();\n+            List<Channel> supportedChannels = new ArrayList<Channel>();\n+            List<Channel> initialChannels = getThing().getChannels();\n+            String thingId = getThing().getUID().getAsString();\n+            for (Channel channel : initialChannels) {\n+                String channelId = channel.getUID().getId();\n+                String feature = channelId.toLowerCase();\n+\n+                if (productKey.equals(HIDDEN_DOOR_SENSOR_PRODUCT_KEY)) {\n+                    if (feature.equalsIgnoreCase(InsteonBindingConstants.BATTERY_LEVEL)\n+                            || feature.equalsIgnoreCase(InsteonBindingConstants.BATTERY_WATERMARK_LEVEL)) {\n+\n+                        feature = DATA;\n+                    }\n+                } else if (productKey.equals(MOTION_SENSOR_PRODUCT_KEY)) {\n+                    if (feature.equalsIgnoreCase(InsteonBindingConstants.BATTERY_LEVEL)\n+                            || feature.equalsIgnoreCase(InsteonBindingConstants.LIGHT_LEVEL)) {\n+\n+                        feature = DATA;\n+                    }\n+                } else if (productKey.equals(PLM_PRODUCT_KEY)) {\n+                    String parts[] = feature.split(\"#\");\n+                    if (parts.length == 2 && parts[0].equalsIgnoreCase(InsteonBindingConstants.BROADCAST_ON_OFF)\n+                            && parts[1].matches(\"^\\\\d+$\")) {\n+                        feature = BROADCAST_ON_OFF;\n+                    }\n+                } else if (productKey.equals(POWER_METER_PRODUCT_KEY)) {\n+                    if (feature.equalsIgnoreCase(InsteonBindingConstants.KWH)\n+                            || feature.equalsIgnoreCase(InsteonBindingConstants.RESET)\n+                            || feature.equalsIgnoreCase(InsteonBindingConstants.UPDATE)\n+                            || feature.equalsIgnoreCase(InsteonBindingConstants.WATTS)) {\n+\n+                        feature = METER;\n+                    }\n+                }\n+\n+                DeviceFeature f = device.getFeature(feature);\n+                if (f == null) {\n+                    if (!DEFINED_CHANNELS.contains(channelId)) {\n+                        logger.warn(\"{} includes channel {}, it is not a valid feature for {}. It has been removed.\",\n+                                thingId, channelId, productKey);\n+                    }\n+                } else if (f.isFeatureGroup()) {\n+                    logger.warn(\"{} includes channel {}, it is a feature group for {}. It has been removed.\", thingId,\n+                            channelId, productKey);\n+                } else {\n+                    supportedChannels.add(channel);\n+\n+                    if (channelList.length() > 0) {\n+                        channelList.append(\", \");\n+                    }\n+                    channelList.append(channelId);\n+\n+                    if (!DEFINED_CHANNELS.contains(channelId)) {\n+                        for (String c : DEFINED_CHANNELS) {\n+                            if (channelId.equalsIgnoreCase(c)) {\n+                                logger.warn(\"{} includes channel {}, should it be {}?\", thingId, channelId, c);\n+                                break;\n+                            }\n+                        }\n+                    }\n+                }\n+            }\n+\n+            // only update if channels were culled\n+            if (initialChannels.size() != supportedChannels.size()) {\n+                ThingBuilder thingBuilder = editThing();\n+                thingBuilder.withChannels(supportedChannels);\n+                updateThing(thingBuilder.build());\n+            }\n+\n+            logger.info(\"{} address = {} productKey = {} channels = {}\", thingId, address, productKey,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ed93353c47fa5d457223c66d8f91b1c168a57e23"}, "originalPosition": 228}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Njc1MDA5MA==", "bodyText": "see above", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r386750090", "createdAt": "2020-03-03T01:26:41Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.insteon/src/main/java/org/openhab/binding/insteon/internal/handler/InsteonDeviceHandler.java", "diffHunk": "@@ -0,0 +1,329 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.insteon.internal.handler;\n+\n+import java.math.BigDecimal;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.builder.ThingBuilder;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.openhab.binding.insteon.internal.InsteonBinding;\n+import org.openhab.binding.insteon.internal.InsteonBindingConstants;\n+import org.openhab.binding.insteon.internal.config.InsteonChannelConfiguration;\n+import org.openhab.binding.insteon.internal.config.InsteonDeviceConfiguration;\n+import org.openhab.binding.insteon.internal.device.DeviceFeature;\n+import org.openhab.binding.insteon.internal.device.DeviceTypeLoader;\n+import org.openhab.binding.insteon.internal.device.InsteonAddress;\n+import org.openhab.binding.insteon.internal.device.InsteonDevice;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link InsteonDeviceHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Rob Nielsen - Initial contribution\n+ */\n+@NonNullByDefault\n+public class InsteonDeviceHandler extends BaseThingHandler {\n+\n+    private static final Set<String> DEFINED_CHANNELS = Collections.unmodifiableSet(Stream.of(\n+            InsteonBindingConstants.AC_DELAY, InsteonBindingConstants.BACKLIGHT_DURATION,\n+            InsteonBindingConstants.BATTERY_LEVEL, InsteonBindingConstants.BATTERY_WATERMARK_LEVEL,\n+            InsteonBindingConstants.BOTTOM_OUTLET, InsteonBindingConstants.BUTTON_A, InsteonBindingConstants.BUTTON_B,\n+            InsteonBindingConstants.BUTTON_C, InsteonBindingConstants.BUTTON_D, InsteonBindingConstants.BUTTON_E,\n+            InsteonBindingConstants.BUTTON_F, InsteonBindingConstants.BUTTON_G, InsteonBindingConstants.BUTTON_H,\n+            InsteonBindingConstants.BROADCAST_ON_OFF, InsteonBindingConstants.CONTACT,\n+            InsteonBindingConstants.COOL_SET_POINT, InsteonBindingConstants.DIMMER, InsteonBindingConstants.FAN,\n+            InsteonBindingConstants.FAN_MODE, InsteonBindingConstants.FAST_ON_OFF,\n+            InsteonBindingConstants.FAST_ON_OFF_BUTTON_A, InsteonBindingConstants.FAST_ON_OFF_BUTTON_B,\n+            InsteonBindingConstants.FAST_ON_OFF_BUTTON_C, InsteonBindingConstants.FAST_ON_OFF_BUTTON_D,\n+            InsteonBindingConstants.HEAT_SET_POINT, InsteonBindingConstants.HUMIDITY,\n+            InsteonBindingConstants.HUMIDITY_HIGH, InsteonBindingConstants.HUMIDITY_LOW,\n+            InsteonBindingConstants.IS_COOLING, InsteonBindingConstants.IS_HEATING,\n+            InsteonBindingConstants.KEYPAD_BUTTON_A, InsteonBindingConstants.KEYPAD_BUTTON_B,\n+            InsteonBindingConstants.KEYPAD_BUTTON_C, InsteonBindingConstants.KEYPAD_BUTTON_D,\n+            InsteonBindingConstants.KEYPAD_BUTTON_E, InsteonBindingConstants.KEYPAD_BUTTON_F,\n+            InsteonBindingConstants.KEYPAD_BUTTON_G, InsteonBindingConstants.KEYPAD_BUTTON_H,\n+            InsteonBindingConstants.KWH, InsteonBindingConstants.LAST_HEARD_FROM,\n+            InsteonBindingConstants.LED_BRIGHTNESS, InsteonBindingConstants.LIGHT_DIMMER,\n+            InsteonBindingConstants.LIGHT_LEVEL, InsteonBindingConstants.LOAD_DIMMER,\n+            InsteonBindingConstants.LOAD_SWITCH, InsteonBindingConstants.LOAD_SWITCH_FAST_ON_OFF,\n+            InsteonBindingConstants.LOAD_SWITCH_MANUAL_CHANGE, InsteonBindingConstants.MANUAL_CHANGE,\n+            InsteonBindingConstants.MANUAL_CHANGE_BUTTON_A, InsteonBindingConstants.MANUAL_CHANGE_BUTTON_B,\n+            InsteonBindingConstants.MANUAL_CHANGE_BUTTON_C, InsteonBindingConstants.MANUAL_CHANGE_BUTTON_D,\n+            InsteonBindingConstants.NOTIFICATION, InsteonBindingConstants.ON_LEVEL, InsteonBindingConstants.RAMP_DIMMER,\n+            InsteonBindingConstants.RAMP_RATE, InsteonBindingConstants.RESET, InsteonBindingConstants.STAGE1_DURATION,\n+            InsteonBindingConstants.SWITCH, InsteonBindingConstants.SYSTEM_MODE, InsteonBindingConstants.TEMP_CELSIUS,\n+            InsteonBindingConstants.TEMP_FAHRENHEIT, InsteonBindingConstants.TOP_OUTLET, InsteonBindingConstants.UPDATE,\n+            InsteonBindingConstants.WATTS).collect(Collectors.toSet()));\n+\n+    private static final String BROADCAST_ON_OFF = \"broadcastonoff\";\n+    private static final String CMD = \"cmd\";\n+    private static final String CMD_RESET = \"reset\";\n+    private static final String CMD_UPDATE = \"update\";\n+    private static final String DATA = \"data\";\n+    private static final String FIELD = \"field\";\n+    private static final String FIELD_BATTERY_LEVEL = \"battery_level\";\n+    private static final String FIELD_BATTERY_WATERMARK_LEVEL = \"battery_watermark_level\";\n+    private static final String FIELD_KWH = \"kwh\";\n+    private static final String FIELD_LIGHT_LEVEL = \"light_level\";\n+    private static final String FIELD_WATTS = \"watts\";\n+    private static final String GROUP = \"group\";\n+    private static final String METER = \"meter\";\n+\n+    private static final String HIDDEN_DOOR_SENSOR_PRODUCT_KEY = \"F00.00.03\";\n+    private static final String MOTION_SENSOR_PRODUCT_KEY = \"0x00004A\";\n+    private static final String PLM_PRODUCT_KEY = \"0x000045\";\n+    private static final String POWER_METER_PRODUCT_KEY = \"F00.00.17\";\n+\n+    private final Logger logger = LoggerFactory.getLogger(InsteonDeviceHandler.class);\n+\n+    private @Nullable InsteonDeviceConfiguration config;\n+\n+    public InsteonDeviceHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        config = getConfigAs(InsteonDeviceConfiguration.class);\n+\n+        scheduler.execute(() -> {\n+            if (getBridge() == null) {\n+                String msg = \"An Insteon network bridge has not been selected for this device.\";\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, msg);\n+                return;\n+            }\n+\n+            String address = config.getAddress();\n+            if (!InsteonAddress.s_isValid(address)) {\n+                String msg = \"Unable to start Insteon device, the insteon or X10 address '\" + address\n+                        + \"' is invalid. It must be in the format 'AB.CD.EF' or 'H.U' (X10).\";\n+                logger.warn(msg);\n+\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, msg);\n+                return;\n+            }\n+\n+            String productKey = config.getProductKey();\n+            if (DeviceTypeLoader.s_instance().getDeviceType(productKey) == null) {\n+                String msg = \"Unable to start Insteon device, invalid product key '\" + productKey + \"'.\";\n+                logger.warn(msg);\n+\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, msg);\n+                return;\n+            }\n+\n+            InsteonBinding insteonBinding = getInsteonBinding();\n+            InsteonAddress insteonAddress = new InsteonAddress(address);\n+            if (insteonBinding.getDevice(insteonAddress) != null) {\n+                String msg = \"a device already exists with the address '\" + address + \"'.\";\n+                logger.warn(msg);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ed93353c47fa5d457223c66d8f91b1c168a57e23"}, "originalPosition": 147}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Njc1MDI1Mg==", "bodyText": "Please use standard slf4j log formatting", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r386750252", "createdAt": "2020-03-03T01:27:16Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.insteon/src/main/java/org/openhab/binding/insteon/internal/handler/InsteonDeviceHandler.java", "diffHunk": "@@ -0,0 +1,329 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.insteon.internal.handler;\n+\n+import java.math.BigDecimal;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.builder.ThingBuilder;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.openhab.binding.insteon.internal.InsteonBinding;\n+import org.openhab.binding.insteon.internal.InsteonBindingConstants;\n+import org.openhab.binding.insteon.internal.config.InsteonChannelConfiguration;\n+import org.openhab.binding.insteon.internal.config.InsteonDeviceConfiguration;\n+import org.openhab.binding.insteon.internal.device.DeviceFeature;\n+import org.openhab.binding.insteon.internal.device.DeviceTypeLoader;\n+import org.openhab.binding.insteon.internal.device.InsteonAddress;\n+import org.openhab.binding.insteon.internal.device.InsteonDevice;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link InsteonDeviceHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Rob Nielsen - Initial contribution\n+ */\n+@NonNullByDefault\n+public class InsteonDeviceHandler extends BaseThingHandler {\n+\n+    private static final Set<String> DEFINED_CHANNELS = Collections.unmodifiableSet(Stream.of(\n+            InsteonBindingConstants.AC_DELAY, InsteonBindingConstants.BACKLIGHT_DURATION,\n+            InsteonBindingConstants.BATTERY_LEVEL, InsteonBindingConstants.BATTERY_WATERMARK_LEVEL,\n+            InsteonBindingConstants.BOTTOM_OUTLET, InsteonBindingConstants.BUTTON_A, InsteonBindingConstants.BUTTON_B,\n+            InsteonBindingConstants.BUTTON_C, InsteonBindingConstants.BUTTON_D, InsteonBindingConstants.BUTTON_E,\n+            InsteonBindingConstants.BUTTON_F, InsteonBindingConstants.BUTTON_G, InsteonBindingConstants.BUTTON_H,\n+            InsteonBindingConstants.BROADCAST_ON_OFF, InsteonBindingConstants.CONTACT,\n+            InsteonBindingConstants.COOL_SET_POINT, InsteonBindingConstants.DIMMER, InsteonBindingConstants.FAN,\n+            InsteonBindingConstants.FAN_MODE, InsteonBindingConstants.FAST_ON_OFF,\n+            InsteonBindingConstants.FAST_ON_OFF_BUTTON_A, InsteonBindingConstants.FAST_ON_OFF_BUTTON_B,\n+            InsteonBindingConstants.FAST_ON_OFF_BUTTON_C, InsteonBindingConstants.FAST_ON_OFF_BUTTON_D,\n+            InsteonBindingConstants.HEAT_SET_POINT, InsteonBindingConstants.HUMIDITY,\n+            InsteonBindingConstants.HUMIDITY_HIGH, InsteonBindingConstants.HUMIDITY_LOW,\n+            InsteonBindingConstants.IS_COOLING, InsteonBindingConstants.IS_HEATING,\n+            InsteonBindingConstants.KEYPAD_BUTTON_A, InsteonBindingConstants.KEYPAD_BUTTON_B,\n+            InsteonBindingConstants.KEYPAD_BUTTON_C, InsteonBindingConstants.KEYPAD_BUTTON_D,\n+            InsteonBindingConstants.KEYPAD_BUTTON_E, InsteonBindingConstants.KEYPAD_BUTTON_F,\n+            InsteonBindingConstants.KEYPAD_BUTTON_G, InsteonBindingConstants.KEYPAD_BUTTON_H,\n+            InsteonBindingConstants.KWH, InsteonBindingConstants.LAST_HEARD_FROM,\n+            InsteonBindingConstants.LED_BRIGHTNESS, InsteonBindingConstants.LIGHT_DIMMER,\n+            InsteonBindingConstants.LIGHT_LEVEL, InsteonBindingConstants.LOAD_DIMMER,\n+            InsteonBindingConstants.LOAD_SWITCH, InsteonBindingConstants.LOAD_SWITCH_FAST_ON_OFF,\n+            InsteonBindingConstants.LOAD_SWITCH_MANUAL_CHANGE, InsteonBindingConstants.MANUAL_CHANGE,\n+            InsteonBindingConstants.MANUAL_CHANGE_BUTTON_A, InsteonBindingConstants.MANUAL_CHANGE_BUTTON_B,\n+            InsteonBindingConstants.MANUAL_CHANGE_BUTTON_C, InsteonBindingConstants.MANUAL_CHANGE_BUTTON_D,\n+            InsteonBindingConstants.NOTIFICATION, InsteonBindingConstants.ON_LEVEL, InsteonBindingConstants.RAMP_DIMMER,\n+            InsteonBindingConstants.RAMP_RATE, InsteonBindingConstants.RESET, InsteonBindingConstants.STAGE1_DURATION,\n+            InsteonBindingConstants.SWITCH, InsteonBindingConstants.SYSTEM_MODE, InsteonBindingConstants.TEMP_CELSIUS,\n+            InsteonBindingConstants.TEMP_FAHRENHEIT, InsteonBindingConstants.TOP_OUTLET, InsteonBindingConstants.UPDATE,\n+            InsteonBindingConstants.WATTS).collect(Collectors.toSet()));\n+\n+    private static final String BROADCAST_ON_OFF = \"broadcastonoff\";\n+    private static final String CMD = \"cmd\";\n+    private static final String CMD_RESET = \"reset\";\n+    private static final String CMD_UPDATE = \"update\";\n+    private static final String DATA = \"data\";\n+    private static final String FIELD = \"field\";\n+    private static final String FIELD_BATTERY_LEVEL = \"battery_level\";\n+    private static final String FIELD_BATTERY_WATERMARK_LEVEL = \"battery_watermark_level\";\n+    private static final String FIELD_KWH = \"kwh\";\n+    private static final String FIELD_LIGHT_LEVEL = \"light_level\";\n+    private static final String FIELD_WATTS = \"watts\";\n+    private static final String GROUP = \"group\";\n+    private static final String METER = \"meter\";\n+\n+    private static final String HIDDEN_DOOR_SENSOR_PRODUCT_KEY = \"F00.00.03\";\n+    private static final String MOTION_SENSOR_PRODUCT_KEY = \"0x00004A\";\n+    private static final String PLM_PRODUCT_KEY = \"0x000045\";\n+    private static final String POWER_METER_PRODUCT_KEY = \"F00.00.17\";\n+\n+    private final Logger logger = LoggerFactory.getLogger(InsteonDeviceHandler.class);\n+\n+    private @Nullable InsteonDeviceConfiguration config;\n+\n+    public InsteonDeviceHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        config = getConfigAs(InsteonDeviceConfiguration.class);\n+\n+        scheduler.execute(() -> {\n+            if (getBridge() == null) {\n+                String msg = \"An Insteon network bridge has not been selected for this device.\";\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, msg);\n+                return;\n+            }\n+\n+            String address = config.getAddress();\n+            if (!InsteonAddress.s_isValid(address)) {\n+                String msg = \"Unable to start Insteon device, the insteon or X10 address '\" + address\n+                        + \"' is invalid. It must be in the format 'AB.CD.EF' or 'H.U' (X10).\";\n+                logger.warn(msg);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ed93353c47fa5d457223c66d8f91b1c168a57e23"}, "originalPosition": 128}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Njc1MDMwMw==", "bodyText": "see above", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r386750303", "createdAt": "2020-03-03T01:27:31Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.insteon/src/main/java/org/openhab/binding/insteon/internal/handler/InsteonDeviceHandler.java", "diffHunk": "@@ -0,0 +1,329 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.insteon.internal.handler;\n+\n+import java.math.BigDecimal;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.builder.ThingBuilder;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.openhab.binding.insteon.internal.InsteonBinding;\n+import org.openhab.binding.insteon.internal.InsteonBindingConstants;\n+import org.openhab.binding.insteon.internal.config.InsteonChannelConfiguration;\n+import org.openhab.binding.insteon.internal.config.InsteonDeviceConfiguration;\n+import org.openhab.binding.insteon.internal.device.DeviceFeature;\n+import org.openhab.binding.insteon.internal.device.DeviceTypeLoader;\n+import org.openhab.binding.insteon.internal.device.InsteonAddress;\n+import org.openhab.binding.insteon.internal.device.InsteonDevice;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link InsteonDeviceHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Rob Nielsen - Initial contribution\n+ */\n+@NonNullByDefault\n+public class InsteonDeviceHandler extends BaseThingHandler {\n+\n+    private static final Set<String> DEFINED_CHANNELS = Collections.unmodifiableSet(Stream.of(\n+            InsteonBindingConstants.AC_DELAY, InsteonBindingConstants.BACKLIGHT_DURATION,\n+            InsteonBindingConstants.BATTERY_LEVEL, InsteonBindingConstants.BATTERY_WATERMARK_LEVEL,\n+            InsteonBindingConstants.BOTTOM_OUTLET, InsteonBindingConstants.BUTTON_A, InsteonBindingConstants.BUTTON_B,\n+            InsteonBindingConstants.BUTTON_C, InsteonBindingConstants.BUTTON_D, InsteonBindingConstants.BUTTON_E,\n+            InsteonBindingConstants.BUTTON_F, InsteonBindingConstants.BUTTON_G, InsteonBindingConstants.BUTTON_H,\n+            InsteonBindingConstants.BROADCAST_ON_OFF, InsteonBindingConstants.CONTACT,\n+            InsteonBindingConstants.COOL_SET_POINT, InsteonBindingConstants.DIMMER, InsteonBindingConstants.FAN,\n+            InsteonBindingConstants.FAN_MODE, InsteonBindingConstants.FAST_ON_OFF,\n+            InsteonBindingConstants.FAST_ON_OFF_BUTTON_A, InsteonBindingConstants.FAST_ON_OFF_BUTTON_B,\n+            InsteonBindingConstants.FAST_ON_OFF_BUTTON_C, InsteonBindingConstants.FAST_ON_OFF_BUTTON_D,\n+            InsteonBindingConstants.HEAT_SET_POINT, InsteonBindingConstants.HUMIDITY,\n+            InsteonBindingConstants.HUMIDITY_HIGH, InsteonBindingConstants.HUMIDITY_LOW,\n+            InsteonBindingConstants.IS_COOLING, InsteonBindingConstants.IS_HEATING,\n+            InsteonBindingConstants.KEYPAD_BUTTON_A, InsteonBindingConstants.KEYPAD_BUTTON_B,\n+            InsteonBindingConstants.KEYPAD_BUTTON_C, InsteonBindingConstants.KEYPAD_BUTTON_D,\n+            InsteonBindingConstants.KEYPAD_BUTTON_E, InsteonBindingConstants.KEYPAD_BUTTON_F,\n+            InsteonBindingConstants.KEYPAD_BUTTON_G, InsteonBindingConstants.KEYPAD_BUTTON_H,\n+            InsteonBindingConstants.KWH, InsteonBindingConstants.LAST_HEARD_FROM,\n+            InsteonBindingConstants.LED_BRIGHTNESS, InsteonBindingConstants.LIGHT_DIMMER,\n+            InsteonBindingConstants.LIGHT_LEVEL, InsteonBindingConstants.LOAD_DIMMER,\n+            InsteonBindingConstants.LOAD_SWITCH, InsteonBindingConstants.LOAD_SWITCH_FAST_ON_OFF,\n+            InsteonBindingConstants.LOAD_SWITCH_MANUAL_CHANGE, InsteonBindingConstants.MANUAL_CHANGE,\n+            InsteonBindingConstants.MANUAL_CHANGE_BUTTON_A, InsteonBindingConstants.MANUAL_CHANGE_BUTTON_B,\n+            InsteonBindingConstants.MANUAL_CHANGE_BUTTON_C, InsteonBindingConstants.MANUAL_CHANGE_BUTTON_D,\n+            InsteonBindingConstants.NOTIFICATION, InsteonBindingConstants.ON_LEVEL, InsteonBindingConstants.RAMP_DIMMER,\n+            InsteonBindingConstants.RAMP_RATE, InsteonBindingConstants.RESET, InsteonBindingConstants.STAGE1_DURATION,\n+            InsteonBindingConstants.SWITCH, InsteonBindingConstants.SYSTEM_MODE, InsteonBindingConstants.TEMP_CELSIUS,\n+            InsteonBindingConstants.TEMP_FAHRENHEIT, InsteonBindingConstants.TOP_OUTLET, InsteonBindingConstants.UPDATE,\n+            InsteonBindingConstants.WATTS).collect(Collectors.toSet()));\n+\n+    private static final String BROADCAST_ON_OFF = \"broadcastonoff\";\n+    private static final String CMD = \"cmd\";\n+    private static final String CMD_RESET = \"reset\";\n+    private static final String CMD_UPDATE = \"update\";\n+    private static final String DATA = \"data\";\n+    private static final String FIELD = \"field\";\n+    private static final String FIELD_BATTERY_LEVEL = \"battery_level\";\n+    private static final String FIELD_BATTERY_WATERMARK_LEVEL = \"battery_watermark_level\";\n+    private static final String FIELD_KWH = \"kwh\";\n+    private static final String FIELD_LIGHT_LEVEL = \"light_level\";\n+    private static final String FIELD_WATTS = \"watts\";\n+    private static final String GROUP = \"group\";\n+    private static final String METER = \"meter\";\n+\n+    private static final String HIDDEN_DOOR_SENSOR_PRODUCT_KEY = \"F00.00.03\";\n+    private static final String MOTION_SENSOR_PRODUCT_KEY = \"0x00004A\";\n+    private static final String PLM_PRODUCT_KEY = \"0x000045\";\n+    private static final String POWER_METER_PRODUCT_KEY = \"F00.00.17\";\n+\n+    private final Logger logger = LoggerFactory.getLogger(InsteonDeviceHandler.class);\n+\n+    private @Nullable InsteonDeviceConfiguration config;\n+\n+    public InsteonDeviceHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        config = getConfigAs(InsteonDeviceConfiguration.class);\n+\n+        scheduler.execute(() -> {\n+            if (getBridge() == null) {\n+                String msg = \"An Insteon network bridge has not been selected for this device.\";\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, msg);\n+                return;\n+            }\n+\n+            String address = config.getAddress();\n+            if (!InsteonAddress.s_isValid(address)) {\n+                String msg = \"Unable to start Insteon device, the insteon or X10 address '\" + address\n+                        + \"' is invalid. It must be in the format 'AB.CD.EF' or 'H.U' (X10).\";\n+                logger.warn(msg);\n+\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, msg);\n+                return;\n+            }\n+\n+            String productKey = config.getProductKey();\n+            if (DeviceTypeLoader.s_instance().getDeviceType(productKey) == null) {\n+                String msg = \"Unable to start Insteon device, invalid product key '\" + productKey + \"'.\";\n+                logger.warn(msg);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ed93353c47fa5d457223c66d8f91b1c168a57e23"}, "originalPosition": 137}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Njc1MTAzNw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        logger.info(\"removed {} address = {}\", getThing().getUID().getAsString(), address);\n          \n          \n            \n                        logger.debug(\"removed {} address = {}\", getThing().getUID().getAsString(), address);", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r386751037", "createdAt": "2020-03-03T01:30:08Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.insteon/src/main/java/org/openhab/binding/insteon/internal/handler/InsteonDeviceHandler.java", "diffHunk": "@@ -0,0 +1,329 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.insteon.internal.handler;\n+\n+import java.math.BigDecimal;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.builder.ThingBuilder;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.openhab.binding.insteon.internal.InsteonBinding;\n+import org.openhab.binding.insteon.internal.InsteonBindingConstants;\n+import org.openhab.binding.insteon.internal.config.InsteonChannelConfiguration;\n+import org.openhab.binding.insteon.internal.config.InsteonDeviceConfiguration;\n+import org.openhab.binding.insteon.internal.device.DeviceFeature;\n+import org.openhab.binding.insteon.internal.device.DeviceTypeLoader;\n+import org.openhab.binding.insteon.internal.device.InsteonAddress;\n+import org.openhab.binding.insteon.internal.device.InsteonDevice;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link InsteonDeviceHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Rob Nielsen - Initial contribution\n+ */\n+@NonNullByDefault\n+public class InsteonDeviceHandler extends BaseThingHandler {\n+\n+    private static final Set<String> DEFINED_CHANNELS = Collections.unmodifiableSet(Stream.of(\n+            InsteonBindingConstants.AC_DELAY, InsteonBindingConstants.BACKLIGHT_DURATION,\n+            InsteonBindingConstants.BATTERY_LEVEL, InsteonBindingConstants.BATTERY_WATERMARK_LEVEL,\n+            InsteonBindingConstants.BOTTOM_OUTLET, InsteonBindingConstants.BUTTON_A, InsteonBindingConstants.BUTTON_B,\n+            InsteonBindingConstants.BUTTON_C, InsteonBindingConstants.BUTTON_D, InsteonBindingConstants.BUTTON_E,\n+            InsteonBindingConstants.BUTTON_F, InsteonBindingConstants.BUTTON_G, InsteonBindingConstants.BUTTON_H,\n+            InsteonBindingConstants.BROADCAST_ON_OFF, InsteonBindingConstants.CONTACT,\n+            InsteonBindingConstants.COOL_SET_POINT, InsteonBindingConstants.DIMMER, InsteonBindingConstants.FAN,\n+            InsteonBindingConstants.FAN_MODE, InsteonBindingConstants.FAST_ON_OFF,\n+            InsteonBindingConstants.FAST_ON_OFF_BUTTON_A, InsteonBindingConstants.FAST_ON_OFF_BUTTON_B,\n+            InsteonBindingConstants.FAST_ON_OFF_BUTTON_C, InsteonBindingConstants.FAST_ON_OFF_BUTTON_D,\n+            InsteonBindingConstants.HEAT_SET_POINT, InsteonBindingConstants.HUMIDITY,\n+            InsteonBindingConstants.HUMIDITY_HIGH, InsteonBindingConstants.HUMIDITY_LOW,\n+            InsteonBindingConstants.IS_COOLING, InsteonBindingConstants.IS_HEATING,\n+            InsteonBindingConstants.KEYPAD_BUTTON_A, InsteonBindingConstants.KEYPAD_BUTTON_B,\n+            InsteonBindingConstants.KEYPAD_BUTTON_C, InsteonBindingConstants.KEYPAD_BUTTON_D,\n+            InsteonBindingConstants.KEYPAD_BUTTON_E, InsteonBindingConstants.KEYPAD_BUTTON_F,\n+            InsteonBindingConstants.KEYPAD_BUTTON_G, InsteonBindingConstants.KEYPAD_BUTTON_H,\n+            InsteonBindingConstants.KWH, InsteonBindingConstants.LAST_HEARD_FROM,\n+            InsteonBindingConstants.LED_BRIGHTNESS, InsteonBindingConstants.LIGHT_DIMMER,\n+            InsteonBindingConstants.LIGHT_LEVEL, InsteonBindingConstants.LOAD_DIMMER,\n+            InsteonBindingConstants.LOAD_SWITCH, InsteonBindingConstants.LOAD_SWITCH_FAST_ON_OFF,\n+            InsteonBindingConstants.LOAD_SWITCH_MANUAL_CHANGE, InsteonBindingConstants.MANUAL_CHANGE,\n+            InsteonBindingConstants.MANUAL_CHANGE_BUTTON_A, InsteonBindingConstants.MANUAL_CHANGE_BUTTON_B,\n+            InsteonBindingConstants.MANUAL_CHANGE_BUTTON_C, InsteonBindingConstants.MANUAL_CHANGE_BUTTON_D,\n+            InsteonBindingConstants.NOTIFICATION, InsteonBindingConstants.ON_LEVEL, InsteonBindingConstants.RAMP_DIMMER,\n+            InsteonBindingConstants.RAMP_RATE, InsteonBindingConstants.RESET, InsteonBindingConstants.STAGE1_DURATION,\n+            InsteonBindingConstants.SWITCH, InsteonBindingConstants.SYSTEM_MODE, InsteonBindingConstants.TEMP_CELSIUS,\n+            InsteonBindingConstants.TEMP_FAHRENHEIT, InsteonBindingConstants.TOP_OUTLET, InsteonBindingConstants.UPDATE,\n+            InsteonBindingConstants.WATTS).collect(Collectors.toSet()));\n+\n+    private static final String BROADCAST_ON_OFF = \"broadcastonoff\";\n+    private static final String CMD = \"cmd\";\n+    private static final String CMD_RESET = \"reset\";\n+    private static final String CMD_UPDATE = \"update\";\n+    private static final String DATA = \"data\";\n+    private static final String FIELD = \"field\";\n+    private static final String FIELD_BATTERY_LEVEL = \"battery_level\";\n+    private static final String FIELD_BATTERY_WATERMARK_LEVEL = \"battery_watermark_level\";\n+    private static final String FIELD_KWH = \"kwh\";\n+    private static final String FIELD_LIGHT_LEVEL = \"light_level\";\n+    private static final String FIELD_WATTS = \"watts\";\n+    private static final String GROUP = \"group\";\n+    private static final String METER = \"meter\";\n+\n+    private static final String HIDDEN_DOOR_SENSOR_PRODUCT_KEY = \"F00.00.03\";\n+    private static final String MOTION_SENSOR_PRODUCT_KEY = \"0x00004A\";\n+    private static final String PLM_PRODUCT_KEY = \"0x000045\";\n+    private static final String POWER_METER_PRODUCT_KEY = \"F00.00.17\";\n+\n+    private final Logger logger = LoggerFactory.getLogger(InsteonDeviceHandler.class);\n+\n+    private @Nullable InsteonDeviceConfiguration config;\n+\n+    public InsteonDeviceHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        config = getConfigAs(InsteonDeviceConfiguration.class);\n+\n+        scheduler.execute(() -> {\n+            if (getBridge() == null) {\n+                String msg = \"An Insteon network bridge has not been selected for this device.\";\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, msg);\n+                return;\n+            }\n+\n+            String address = config.getAddress();\n+            if (!InsteonAddress.s_isValid(address)) {\n+                String msg = \"Unable to start Insteon device, the insteon or X10 address '\" + address\n+                        + \"' is invalid. It must be in the format 'AB.CD.EF' or 'H.U' (X10).\";\n+                logger.warn(msg);\n+\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, msg);\n+                return;\n+            }\n+\n+            String productKey = config.getProductKey();\n+            if (DeviceTypeLoader.s_instance().getDeviceType(productKey) == null) {\n+                String msg = \"Unable to start Insteon device, invalid product key '\" + productKey + \"'.\";\n+                logger.warn(msg);\n+\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, msg);\n+                return;\n+            }\n+\n+            InsteonBinding insteonBinding = getInsteonBinding();\n+            InsteonAddress insteonAddress = new InsteonAddress(address);\n+            if (insteonBinding.getDevice(insteonAddress) != null) {\n+                String msg = \"a device already exists with the address '\" + address + \"'.\";\n+                logger.warn(msg);\n+\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, msg);\n+                return;\n+            }\n+\n+            InsteonDevice device = insteonBinding.makeNewDevice(insteonAddress, productKey);\n+\n+            // By default the device is assigned all channels. Channels are associated with a feature, cull the ones\n+            // that are supported by this device.\n+            StringBuffer channelList = new StringBuffer();\n+            List<Channel> supportedChannels = new ArrayList<Channel>();\n+            List<Channel> initialChannels = getThing().getChannels();\n+            String thingId = getThing().getUID().getAsString();\n+            for (Channel channel : initialChannels) {\n+                String channelId = channel.getUID().getId();\n+                String feature = channelId.toLowerCase();\n+\n+                if (productKey.equals(HIDDEN_DOOR_SENSOR_PRODUCT_KEY)) {\n+                    if (feature.equalsIgnoreCase(InsteonBindingConstants.BATTERY_LEVEL)\n+                            || feature.equalsIgnoreCase(InsteonBindingConstants.BATTERY_WATERMARK_LEVEL)) {\n+\n+                        feature = DATA;\n+                    }\n+                } else if (productKey.equals(MOTION_SENSOR_PRODUCT_KEY)) {\n+                    if (feature.equalsIgnoreCase(InsteonBindingConstants.BATTERY_LEVEL)\n+                            || feature.equalsIgnoreCase(InsteonBindingConstants.LIGHT_LEVEL)) {\n+\n+                        feature = DATA;\n+                    }\n+                } else if (productKey.equals(PLM_PRODUCT_KEY)) {\n+                    String parts[] = feature.split(\"#\");\n+                    if (parts.length == 2 && parts[0].equalsIgnoreCase(InsteonBindingConstants.BROADCAST_ON_OFF)\n+                            && parts[1].matches(\"^\\\\d+$\")) {\n+                        feature = BROADCAST_ON_OFF;\n+                    }\n+                } else if (productKey.equals(POWER_METER_PRODUCT_KEY)) {\n+                    if (feature.equalsIgnoreCase(InsteonBindingConstants.KWH)\n+                            || feature.equalsIgnoreCase(InsteonBindingConstants.RESET)\n+                            || feature.equalsIgnoreCase(InsteonBindingConstants.UPDATE)\n+                            || feature.equalsIgnoreCase(InsteonBindingConstants.WATTS)) {\n+\n+                        feature = METER;\n+                    }\n+                }\n+\n+                DeviceFeature f = device.getFeature(feature);\n+                if (f == null) {\n+                    if (!DEFINED_CHANNELS.contains(channelId)) {\n+                        logger.warn(\"{} includes channel {}, it is not a valid feature for {}. It has been removed.\",\n+                                thingId, channelId, productKey);\n+                    }\n+                } else if (f.isFeatureGroup()) {\n+                    logger.warn(\"{} includes channel {}, it is a feature group for {}. It has been removed.\", thingId,\n+                            channelId, productKey);\n+                } else {\n+                    supportedChannels.add(channel);\n+\n+                    if (channelList.length() > 0) {\n+                        channelList.append(\", \");\n+                    }\n+                    channelList.append(channelId);\n+\n+                    if (!DEFINED_CHANNELS.contains(channelId)) {\n+                        for (String c : DEFINED_CHANNELS) {\n+                            if (channelId.equalsIgnoreCase(c)) {\n+                                logger.warn(\"{} includes channel {}, should it be {}?\", thingId, channelId, c);\n+                                break;\n+                            }\n+                        }\n+                    }\n+                }\n+            }\n+\n+            // only update if channels were culled\n+            if (initialChannels.size() != supportedChannels.size()) {\n+                ThingBuilder thingBuilder = editThing();\n+                thingBuilder.withChannels(supportedChannels);\n+                updateThing(thingBuilder.build());\n+            }\n+\n+            logger.info(\"{} address = {} productKey = {} channels = {}\", thingId, address, productKey,\n+                    channelList.toString());\n+\n+            updateStatus(ThingStatus.ONLINE);\n+        });\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        String address = config.getAddress();\n+        if (getBridge() != null && InsteonAddress.s_isValid(address)) {\n+            getInsteonBinding().removeDevice(new InsteonAddress(address));\n+\n+            logger.info(\"removed {} address = {}\", getThing().getUID().getAsString(), address);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ed93353c47fa5d457223c66d8f91b1c168a57e23"}, "originalPosition": 241}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Njc1MjE1NA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    Integer i = new Integer((b & 0xe0));\n          \n          \n            \n                    int i = b & 0xe0;", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r386752154", "createdAt": "2020-03-03T01:34:09Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.insteon/src/main/java/org/openhab/binding/insteon/internal/message/MsgType.java", "diffHunk": "@@ -0,0 +1,84 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.insteon.internal.message;\n+\n+import java.util.HashMap;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+\n+/**\n+ * Represents insteon message type flags\n+ *\n+ * @author Daniel Pfrommer - Initial contribution\n+ * @author Rob Nielsen - Port to OpenHAB 2 insteon binding\n+ */\n+@NonNullByDefault\n+public enum MsgType {\n+    /*\n+     * From the official Insteon docs: the message flags are as follows:\n+     *\n+     * Bit 0 max hops low bit\n+     * Bit 1 max hops high bit\n+     * Bit 2 hops left low bit\n+     * Bit 3 hops left high bit\n+     * Bit 4 0: is standard message, 1: is extended message\n+     * Bit 5 ACK\n+     * Bit 6 0: not link related, 1: is ALL-Link message\n+     * Bit 7 Broadcast/NAK\n+     */\n+    BROADCAST(0x80),\n+    DIRECT(0x00),\n+    ACK_OF_DIRECT(0x20),\n+    NACK_OF_DIRECT(0xa0),\n+    ALL_LINK_BROADCAST(0xc0),\n+    ALL_LINK_CLEANUP(0x40),\n+    ALL_LINK_CLEANUP_ACK(0x60),\n+    ALL_LINK_CLEANUP_NACK(0xe0),\n+    INVALID(0xff); // should never happen\n+\n+    private static HashMap<Integer, @Nullable MsgType> s_hash = new HashMap<Integer, @Nullable MsgType>();\n+\n+    private byte m_byteValue = 0;\n+\n+    /**\n+     * Constructor\n+     *\n+     * @param b byte with insteon message type flags set\n+     */\n+    MsgType(int b) {\n+        m_byteValue = (byte) b;\n+    }\n+\n+    static {\n+        for (MsgType t : MsgType.values()) {\n+            Integer i = new Integer(t.getByteValue() & 0xff);\n+            s_hash.put(i, t);\n+        }\n+    }\n+\n+    private int getByteValue() {\n+        return m_byteValue;\n+    }\n+\n+    public static MsgType s_fromValue(byte b) throws IllegalArgumentException {\n+        Integer i = new Integer((b & 0xe0));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ed93353c47fa5d457223c66d8f91b1c168a57e23"}, "originalPosition": 75}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Njc1MjQxMA==", "bodyText": "move to unit test or remove", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r386752410", "createdAt": "2020-03-03T01:35:04Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.insteon/src/main/java/org/openhab/binding/insteon/internal/message/XMLMessageReader.java", "diffHunk": "@@ -0,0 +1,186 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.insteon.internal.message;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.util.HashMap;\n+import java.util.LinkedHashMap;\n+import java.util.Map.Entry;\n+\n+import javax.xml.parsers.DocumentBuilder;\n+import javax.xml.parsers.DocumentBuilderFactory;\n+import javax.xml.parsers.ParserConfigurationException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.insteon.internal.utils.Pair;\n+import org.openhab.binding.insteon.internal.utils.Utils.DataTypeParser;\n+import org.openhab.binding.insteon.internal.utils.Utils.ParsingException;\n+import org.w3c.dom.Document;\n+import org.w3c.dom.Element;\n+import org.w3c.dom.Node;\n+import org.w3c.dom.NodeList;\n+import org.xml.sax.SAXException;\n+\n+/**\n+ * Reads the Msg definitions from an XML file\n+ *\n+ * @author Daniel Pfrommer - Initial contribution\n+ * @author Rob Nielsen - Port to OpenHAB 2 insteon binding\n+ */\n+@NonNullByDefault\n+public class XMLMessageReader {\n+    /**\n+     * Reads the message definitions from an xml file\n+     *\n+     * @param input input stream from which to read\n+     * @return what was read from file: the map between clear text string and Msg objects\n+     * @throws IOException couldn't read file etc\n+     * @throws ParsingException something wrong with the file format\n+     * @throws FieldException something wrong with the field definition\n+     */\n+    public static HashMap<String, Msg> s_readMessageDefinitions(InputStream input)\n+            throws IOException, ParsingException, FieldException {\n+        HashMap<String, Msg> messageMap = new HashMap<String, Msg>();\n+        try {\n+            DocumentBuilderFactory dbFactory = DocumentBuilderFactory.newInstance();\n+            DocumentBuilder dBuilder = dbFactory.newDocumentBuilder();\n+            // Parse it!\n+            Document doc = dBuilder.parse(input);\n+            doc.getDocumentElement().normalize();\n+\n+            Node root = doc.getDocumentElement();\n+\n+            NodeList nodes = root.getChildNodes();\n+\n+            for (int i = 0; i < nodes.getLength(); i++) {\n+                Node node = nodes.item(i);\n+                if (node.getNodeType() == Node.ELEMENT_NODE) {\n+                    if (node.getNodeName().equals(\"msg\")) {\n+                        Pair<String, Msg> msgDef = s_readMessageDefinition((Element) node);\n+                        messageMap.put(msgDef.getKey(), msgDef.getValue());\n+                    }\n+                }\n+            }\n+        } catch (SAXException e) {\n+            throw new ParsingException(\"Failed to parse XML!\", e);\n+        } catch (ParserConfigurationException e) {\n+            throw new ParsingException(\"Got parser config exception! \", e);\n+        }\n+        return messageMap;\n+    }\n+\n+    private static Pair<String, Msg> s_readMessageDefinition(Element msg) throws FieldException, ParsingException {\n+        int length = 0;\n+        int hlength = 0;\n+        LinkedHashMap<Field, Object> fieldMap = new LinkedHashMap<Field, Object>();\n+        String dir = msg.getAttribute(\"direction\");\n+        String name = msg.getAttribute(\"name\");\n+        Msg.Direction direction = Msg.Direction.s_getDirectionFromString(dir);\n+\n+        if (msg.hasAttribute(\"length\")) {\n+            length = Integer.parseInt(msg.getAttribute(\"length\"));\n+        }\n+\n+        NodeList nodes = msg.getChildNodes();\n+\n+        int offset = 0;\n+\n+        for (int i = 0; i < nodes.getLength(); i++) {\n+            Node node = nodes.item(i);\n+            if (node.getNodeType() == Node.ELEMENT_NODE) {\n+                if (node.getNodeName().equals(\"header\")) {\n+                    int o = s_readHeaderElement((Element) node, fieldMap);\n+                    hlength = o;\n+                    // Increment the offset by the header length\n+                    offset += o;\n+                } else {\n+                    Pair<Field, Object> field = s_readField((Element) node, offset);\n+                    fieldMap.put(field.getKey(), field.getValue());\n+                    // Increment the offset\n+                    offset += field.getKey().getType().getSize();\n+                }\n+            }\n+        }\n+        if (offset != length) {\n+            throw new ParsingException(\n+                    \"Actual msg length \" + offset + \" differs from given msg length \" + length + \"!\");\n+        }\n+        if (length == 0) {\n+            length = offset;\n+        }\n+\n+        return new Pair<String, Msg>(name, s_createMsg(fieldMap, length, hlength, direction));\n+    }\n+\n+    private static int s_readHeaderElement(Element header, LinkedHashMap<Field, Object> fields)\n+            throws ParsingException {\n+        int offset = 0;\n+        int headerLen = Integer.parseInt(header.getAttribute(\"length\"));\n+\n+        NodeList nodes = header.getChildNodes();\n+        for (int i = 0; i < nodes.getLength(); i++) {\n+            Node node = nodes.item(i);\n+            if (node.getNodeType() == Node.ELEMENT_NODE) {\n+                @Nullable\n+                Pair<Field, Object> definition = s_readField((Element) node, offset);\n+                if (definition != null) {\n+                    offset += definition.getKey().getType().getSize();\n+                    fields.put(definition.getKey(), definition.getValue());\n+                }\n+            }\n+        }\n+        if (headerLen != offset) {\n+            throw new ParsingException(\n+                    \"Actual header length \" + offset + \" differs from given length \" + headerLen + \"!\");\n+        }\n+        return headerLen;\n+    }\n+\n+    private static Pair<Field, Object> s_readField(Element field, int offset) {\n+        DataType dType = DataType.s_getDataType(field.getTagName());\n+        // Will return blank if no name attribute\n+        String name = field.getAttribute(\"name\");\n+        Field f = new Field(name, dType, offset);\n+        // Now we have field, only need value\n+        String sVal = field.getTextContent();\n+        Object val = DataTypeParser.s_parseDataType(dType, sVal);\n+        Pair<Field, Object> pair = new Pair<Field, Object>(f, val);\n+        return pair;\n+    }\n+\n+    private static Msg s_createMsg(HashMap<Field, Object> values, int length, int headerLength, Msg.Direction dir)\n+            throws FieldException {\n+        Msg msg = new Msg(headerLength, new byte[length], length, dir);\n+        for (Entry<Field, Object> e : values.entrySet()) {\n+            Field f = e.getKey();\n+            f.set(msg.getData(), e.getValue());\n+            if (f.getName() != null && !f.getName().equals(\"\")) {\n+                msg.addField(f);\n+            }\n+        }\n+        return msg;\n+    }\n+\n+    // public static void main(String[] args) throws Exception {\n+    // // for local testing\n+    // File f = new File(System.getProperty(\"user.home\")\n+    // + \"/workspace/openhab/bundles/binding/org.openhab.binding.insteonplm/src/main/resources/msg_definitions.xml\");\n+    // InputStream s = new FileInputStream(f);\n+    // HashMap<String, Msg> msgs = XMLMessageReader.s_readMessageDefinitions(s);\n+    // for (Msg msg : msgs.values()) {\n+    // System.out.println(msg);\n+    // }\n+    // }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ed93353c47fa5d457223c66d8f91b1c168a57e23"}, "originalPosition": 185}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Njc1MzQ2MQ==", "bodyText": "might be useful to format the byte as hex in the exception", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r386753461", "createdAt": "2020-03-03T01:38:59Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.insteon/src/main/java/org/openhab/binding/insteon/internal/message/MsgType.java", "diffHunk": "@@ -0,0 +1,84 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.insteon.internal.message;\n+\n+import java.util.HashMap;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+\n+/**\n+ * Represents insteon message type flags\n+ *\n+ * @author Daniel Pfrommer - Initial contribution\n+ * @author Rob Nielsen - Port to OpenHAB 2 insteon binding\n+ */\n+@NonNullByDefault\n+public enum MsgType {\n+    /*\n+     * From the official Insteon docs: the message flags are as follows:\n+     *\n+     * Bit 0 max hops low bit\n+     * Bit 1 max hops high bit\n+     * Bit 2 hops left low bit\n+     * Bit 3 hops left high bit\n+     * Bit 4 0: is standard message, 1: is extended message\n+     * Bit 5 ACK\n+     * Bit 6 0: not link related, 1: is ALL-Link message\n+     * Bit 7 Broadcast/NAK\n+     */\n+    BROADCAST(0x80),\n+    DIRECT(0x00),\n+    ACK_OF_DIRECT(0x20),\n+    NACK_OF_DIRECT(0xa0),\n+    ALL_LINK_BROADCAST(0xc0),\n+    ALL_LINK_CLEANUP(0x40),\n+    ALL_LINK_CLEANUP_ACK(0x60),\n+    ALL_LINK_CLEANUP_NACK(0xe0),\n+    INVALID(0xff); // should never happen\n+\n+    private static HashMap<Integer, @Nullable MsgType> s_hash = new HashMap<Integer, @Nullable MsgType>();\n+\n+    private byte m_byteValue = 0;\n+\n+    /**\n+     * Constructor\n+     *\n+     * @param b byte with insteon message type flags set\n+     */\n+    MsgType(int b) {\n+        m_byteValue = (byte) b;\n+    }\n+\n+    static {\n+        for (MsgType t : MsgType.values()) {\n+            Integer i = new Integer(t.getByteValue() & 0xff);\n+            s_hash.put(i, t);\n+        }\n+    }\n+\n+    private int getByteValue() {\n+        return m_byteValue;\n+    }\n+\n+    public static MsgType s_fromValue(byte b) throws IllegalArgumentException {\n+        Integer i = new Integer((b & 0xe0));\n+        @Nullable\n+        MsgType mt = s_hash.get(i);\n+        if (mt == null) {\n+            throw new IllegalArgumentException(\"msg type of byte value \" + i + \" not found\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ed93353c47fa5d457223c66d8f91b1c168a57e23"}, "originalPosition": 79}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Njc1MzYxNg==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        Integer i = new Integer(t.getByteValue() & 0xff);\n          \n          \n            \n                        int i = t.getByteValue() & 0xff;", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r386753616", "createdAt": "2020-03-03T01:39:33Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.insteon/src/main/java/org/openhab/binding/insteon/internal/message/MsgType.java", "diffHunk": "@@ -0,0 +1,84 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.insteon.internal.message;\n+\n+import java.util.HashMap;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+\n+/**\n+ * Represents insteon message type flags\n+ *\n+ * @author Daniel Pfrommer - Initial contribution\n+ * @author Rob Nielsen - Port to OpenHAB 2 insteon binding\n+ */\n+@NonNullByDefault\n+public enum MsgType {\n+    /*\n+     * From the official Insteon docs: the message flags are as follows:\n+     *\n+     * Bit 0 max hops low bit\n+     * Bit 1 max hops high bit\n+     * Bit 2 hops left low bit\n+     * Bit 3 hops left high bit\n+     * Bit 4 0: is standard message, 1: is extended message\n+     * Bit 5 ACK\n+     * Bit 6 0: not link related, 1: is ALL-Link message\n+     * Bit 7 Broadcast/NAK\n+     */\n+    BROADCAST(0x80),\n+    DIRECT(0x00),\n+    ACK_OF_DIRECT(0x20),\n+    NACK_OF_DIRECT(0xa0),\n+    ALL_LINK_BROADCAST(0xc0),\n+    ALL_LINK_CLEANUP(0x40),\n+    ALL_LINK_CLEANUP_ACK(0x60),\n+    ALL_LINK_CLEANUP_NACK(0xe0),\n+    INVALID(0xff); // should never happen\n+\n+    private static HashMap<Integer, @Nullable MsgType> s_hash = new HashMap<Integer, @Nullable MsgType>();\n+\n+    private byte m_byteValue = 0;\n+\n+    /**\n+     * Constructor\n+     *\n+     * @param b byte with insteon message type flags set\n+     */\n+    MsgType(int b) {\n+        m_byteValue = (byte) b;\n+    }\n+\n+    static {\n+        for (MsgType t : MsgType.values()) {\n+            Integer i = new Integer(t.getByteValue() & 0xff);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ed93353c47fa5d457223c66d8f91b1c168a57e23"}, "originalPosition": 65}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Njc1NDEzOQ==", "bodyText": "Please change this to use StringBuilder instead", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r386754139", "createdAt": "2020-03-03T01:41:31Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.insteon/src/main/java/org/openhab/binding/insteon/internal/driver/ModemDBEntry.java", "diffHunk": "@@ -0,0 +1,100 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.insteon.internal.driver;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.insteon.internal.device.InsteonAddress;\n+import org.openhab.binding.insteon.internal.message.Msg;\n+import org.openhab.binding.insteon.internal.utils.Utils;\n+\n+/**\n+ * The ModemDBEntry class holds a modem device type record\n+ * an xml file.\n+ *\n+ * @author Bernd Pfrommer - Initial contribution\n+ * @author Rob Nielsen - Port to OpenHAB 2 insteon binding\n+ */\n+@NonNullByDefault\n+public class ModemDBEntry {\n+    private @Nullable InsteonAddress m_address = null;\n+    private @Nullable Port m_port = null;\n+    private ArrayList<Msg> m_linkRecords = new ArrayList<Msg>();\n+    private ArrayList<Byte> m_controls = new ArrayList<Byte>();\n+    private ArrayList<Byte> m_respondsTo = new ArrayList<Byte>();\n+\n+    public ModemDBEntry(InsteonAddress aAddr) {\n+        m_address = aAddr;\n+    }\n+\n+    public ArrayList<Msg> getLinkRecords() {\n+        return m_linkRecords;\n+    }\n+\n+    public void addLinkRecord(Msg m) {\n+        m_linkRecords.add(m);\n+    }\n+\n+    public void addControls(byte c) {\n+        m_controls.add(c);\n+    }\n+\n+    public ArrayList<Byte> getControls() {\n+        return m_controls;\n+    }\n+\n+    public void addRespondsTo(byte r) {\n+        m_respondsTo.add(r);\n+    }\n+\n+    public ArrayList<Byte> getRespondsTo() {\n+        return m_respondsTo;\n+    }\n+\n+    public void setPort(Port p) {\n+        m_port = p;\n+    }\n+\n+    public @Nullable Port getPort() {\n+        return m_port;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        String s = \"addr:\" + m_address + \"|controls:[\" + toGroupString(m_controls) + \"]|responds_to:[\"\n+                + toGroupString(m_respondsTo) + \"]|link_recors\";\n+        for (Msg m : m_linkRecords) {\n+            s += \":(\" + m + \")\";\n+        }\n+        return s;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ed93353c47fa5d457223c66d8f91b1c168a57e23"}, "originalPosition": 82}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Njc1NzMyNw==", "bodyText": "This makes me sad\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        String s = \"\";\n          \n          \n            \n                        for (String g : m_features) {\n          \n          \n            \n                            s += g + \",\";\n          \n          \n            \n                        }\n          \n          \n            \n                        return (s.replaceAll(\",$\", \"\"));\n          \n          \n            \n                        return StringUtils.join(m_features, \",\");", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r386757327", "createdAt": "2020-03-03T01:52:54Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.insteon/src/main/java/org/openhab/binding/insteon/internal/device/DeviceType.java", "diffHunk": "@@ -0,0 +1,166 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.insteon.internal.device;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.Map.Entry;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+\n+/**\n+ * The DeviceType class holds device type definitions that are read from\n+ * an xml file.\n+ *\n+ * @author Bernd Pfrommer - Initial contribution\n+ * @author Rob Nielsen - Port to OpenHAB 2 insteon binding\n+ */\n+@NonNullByDefault\n+public class DeviceType {\n+    private String m_productKey;\n+    private String m_model = \"\";\n+    private String m_description = \"\";\n+    private HashMap<String, String> m_features = new HashMap<String, String>();\n+    private HashMap<String, FeatureGroup> m_featureGroups = new HashMap<String, FeatureGroup>();\n+\n+    /**\n+     * Constructor\n+     *\n+     * @param aProductKey the product key for this device type\n+     */\n+    public DeviceType(String aProductKey) {\n+        m_productKey = aProductKey;\n+    }\n+\n+    /**\n+     * Get supported features\n+     *\n+     * @return all features that this device type supports\n+     */\n+    public HashMap<String, String> getFeatures() {\n+        return m_features;\n+    }\n+\n+    /**\n+     * Get all feature groups\n+     *\n+     * @return all feature groups of this device type\n+     */\n+    public HashMap<String, FeatureGroup> getFeatureGroups() {\n+        return m_featureGroups;\n+    }\n+\n+    /**\n+     * Sets the descriptive model string\n+     *\n+     * @param aModel descriptive model string\n+     */\n+    public void setModel(String aModel) {\n+        m_model = aModel;\n+    }\n+\n+    /**\n+     * Sets free text description\n+     *\n+     * @param aDesc free text description\n+     */\n+    public void setDescription(String aDesc) {\n+        m_description = aDesc;\n+    }\n+\n+    /**\n+     * Adds feature to this device type\n+     *\n+     * @param aKey the key (e.g. \"switch\") under which this feature can be referenced in the item binding config\n+     * @param aFeatureName the name (e.g. \"GenericSwitch\") under which the feature has been defined\n+     * @return false if feature was already there\n+     */\n+    public boolean addFeature(String aKey, String aFeatureName) {\n+        if (m_features.containsKey(aKey)) {\n+            return false;\n+        }\n+        m_features.put(aKey, aFeatureName);\n+        return true;\n+    }\n+\n+    /**\n+     * Adds feature group to device type\n+     *\n+     * @param aKey name of the feature group, which acts as key for lookup later\n+     * @param fg feature group to add\n+     * @return true if add succeeded, false if group was already there\n+     */\n+    public boolean addFeatureGroup(String aKey, FeatureGroup fg) {\n+        if (m_features.containsKey(aKey)) {\n+            return false;\n+        }\n+        m_featureGroups.put(aKey, fg);\n+        return true;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        String s = \"pk:\" + m_productKey + \"|model:\" + m_model + \"|desc:\" + m_description + \"|features\";\n+        for (Entry<String, String> f : m_features.entrySet()) {\n+            s += \":\" + f.getKey() + \"=\" + f.getValue();\n+        }\n+        s += \"|groups\";\n+        for (Entry<String, FeatureGroup> f : m_featureGroups.entrySet()) {\n+            s += \":\" + f.getKey() + \"=\" + f.getValue();\n+        }\n+        return s;\n+    }\n+\n+    /**\n+     * Class that reflects feature group association\n+     *\n+     * @author Bernd Pfrommer - Initial contribution\n+     */\n+    @NonNullByDefault\n+    public static class FeatureGroup {\n+        private String m_name;\n+        private String m_type;\n+        private ArrayList<String> m_features = new ArrayList<String>();\n+\n+        FeatureGroup(String name, String type) {\n+            m_name = name;\n+            m_type = type;\n+        }\n+\n+        public void addFeature(String f) {\n+            m_features.add(f);\n+        }\n+\n+        public ArrayList<String> getFeatures() {\n+            return m_features;\n+        }\n+\n+        public String getName() {\n+            return m_name;\n+        }\n+\n+        public String getType() {\n+            return m_type;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            String s = \"\";\n+            for (String g : m_features) {\n+                s += g + \",\";\n+            }\n+            return (s.replaceAll(\",$\", \"\"));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ed93353c47fa5d457223c66d8f91b1c168a57e23"}, "originalPosition": 162}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Njc1ODA1MQ==", "bodyText": "Can't you make this final?", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r386758051", "createdAt": "2020-03-03T01:55:34Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.insteon/src/main/java/org/openhab/binding/insteon/internal/device/DeviceFeature.java", "diffHunk": "@@ -0,0 +1,428 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.insteon.internal.device;\n+\n+import java.io.FileInputStream;\n+import java.io.FileNotFoundException;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.insteon.internal.config.InsteonChannelConfiguration;\n+import org.openhab.binding.insteon.internal.device.DeviceFeatureListener.StateChangeType;\n+import org.openhab.binding.insteon.internal.message.Msg;\n+import org.openhab.binding.insteon.internal.utils.Utils.ParsingException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * A DeviceFeature represents a certain feature (trait) of a given Insteon device, e.g. something\n+ * operating under a given InsteonAddress that can be manipulated (relay) or read (sensor).\n+ *\n+ * The DeviceFeature does the processing of incoming messages, and handles commands for the\n+ * particular feature it represents.\n+ *\n+ * It uses four mechanisms for that:\n+ *\n+ * 1) MessageDispatcher: makes high level decisions about an incoming message and then runs the\n+ * 2) MessageHandler: further processes the message, updates state etc\n+ * 3) CommandHandler: translates commands from the openhab bus into an Insteon message.\n+ * 4) PollHandler: creates an Insteon message to query the DeviceFeature\n+ *\n+ * Lastly, DeviceFeatureListeners can register with the DeviceFeature to get notifications when\n+ * the state of a feature has changed. In practice, a DeviceFeatureListener corresponds to an\n+ * OpenHAB item.\n+ *\n+ * The character of a DeviceFeature is thus given by a set of message and command handlers.\n+ * A FeatureTemplate captures exactly that: it says what set of handlers make up a DeviceFeature.\n+ *\n+ * DeviceFeatures are added to a new device by referencing a FeatureTemplate (defined in device_features.xml)\n+ * from the Device definition file (device_types.xml).\n+ *\n+ * @author Daniel Pfrommer - Initial contribution\n+ * @author Bernd Pfrommer - OpenHAB 1 insteonplm binding\n+ * @author Rob Nielsen - Port to OpenHAB 2 insteon binding\n+ */\n+@NonNullByDefault\n+public class DeviceFeature {\n+    public static enum QueryStatus {\n+        NEVER_QUERIED,\n+        QUERY_PENDING,\n+        QUERY_ANSWERED\n+    }\n+\n+    private static final Logger logger = LoggerFactory.getLogger(DeviceFeature.class);\n+\n+    private static HashMap<String, FeatureTemplate> s_features = new HashMap<String, FeatureTemplate>();\n+\n+    private InsteonDevice m_device = new InsteonDevice();\n+    private String m_name = \"INVALID_FEATURE_NAME\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ed93353c47fa5d457223c66d8f91b1c168a57e23"}, "originalPosition": 75}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Njc1ODM4NQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    return (m_parameters.get(key) == null ? def : m_parameters.get(key));\n          \n          \n            \n                    return m_parameters.getOrDefault(key, def);", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r386758385", "createdAt": "2020-03-03T01:56:49Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.insteon/src/main/java/org/openhab/binding/insteon/internal/device/CommandHandler.java", "diffHunk": "@@ -0,0 +1,912 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.insteon.internal.device;\n+\n+import java.io.IOException;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.Timer;\n+import java.util.TimerTask;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.IncreaseDecreaseType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.openhab.binding.insteon.internal.config.InsteonChannelConfiguration;\n+import org.openhab.binding.insteon.internal.device.DeviceFeatureListener.StateChangeType;\n+import org.openhab.binding.insteon.internal.message.FieldException;\n+import org.openhab.binding.insteon.internal.message.Msg;\n+import org.openhab.binding.insteon.internal.utils.Utils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * A command handler translates an openHAB command into a insteon message\n+ *\n+ * @author Daniel Pfrommer - Initial contribution\n+ * @author Bernd Pfrommer - OpenHAB 1 insteonplm binding\n+ * @author Rob Nielsen - Port to OpenHAB 2 insteon binding\n+ */\n+@NonNullByDefault\n+public abstract class CommandHandler {\n+    private static final Logger logger = LoggerFactory.getLogger(CommandHandler.class);\n+    DeviceFeature m_feature; // related DeviceFeature\n+    @Nullable\n+    HashMap<String, @Nullable String> m_parameters = new HashMap<String, @Nullable String>();\n+\n+    /**\n+     * Constructor\n+     *\n+     * @param feature The DeviceFeature for which this command was intended.\n+     *            The openHAB commands are issued on an openhab item. The .items files bind\n+     *            an openHAB item to a DeviceFeature.\n+     */\n+    CommandHandler(DeviceFeature feature) {\n+        m_feature = feature;\n+    }\n+\n+    /**\n+     * Implements what to do when an openHAB command is received\n+     *\n+     * @param config the configuration for the item that generated the command\n+     * @param cmd the openhab command issued\n+     * @param device the Insteon device to which this command applies\n+     */\n+    public abstract void handleCommand(InsteonChannelConfiguration conf, Command cmd, InsteonDevice device);\n+\n+    /**\n+     * Returns parameter as integer\n+     *\n+     * @param key key of parameter\n+     * @param def default\n+     * @return value of parameter\n+     */\n+    protected int getIntParameter(String key, int def) {\n+        String val = m_parameters.get(key);\n+        if (val == null) {\n+            return (def); // param not found\n+        }\n+        int ret = def;\n+        try {\n+            ret = Utils.strToInt(val);\n+        } catch (NumberFormatException e) {\n+            logger.warn(\"malformed int parameter in command handler: {}\", key);\n+        }\n+        return ret;\n+    }\n+\n+    /**\n+     * Returns parameter as String\n+     *\n+     * @param key key of parameter\n+     * @param def default\n+     * @return value of parameter\n+     */\n+    protected @Nullable String getStringParameter(String key, String def) {\n+        return (m_parameters.get(key) == null ? def : m_parameters.get(key));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ed93353c47fa5d457223c66d8f91b1c168a57e23"}, "originalPosition": 99}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Njc3NjA4OA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        StringBuffer buf = new StringBuffer();\n          \n          \n            \n                        StringBuilder buf = new StringBuilder();", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r386776088", "createdAt": "2020-03-03T03:06:43Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.insteon/src/main/java/org/openhab/binding/insteon/internal/InsteonBinding.java", "diffHunk": "@@ -0,0 +1,512 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.insteon.internal;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map.Entry;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import javax.xml.parsers.ParserConfigurationException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.insteon.internal.config.InsteonChannelConfiguration;\n+import org.openhab.binding.insteon.internal.config.InsteonNetworkConfiguration;\n+import org.openhab.binding.insteon.internal.device.DeviceFeature;\n+import org.openhab.binding.insteon.internal.device.DeviceFeatureListener;\n+import org.openhab.binding.insteon.internal.device.DeviceType;\n+import org.openhab.binding.insteon.internal.device.DeviceTypeLoader;\n+import org.openhab.binding.insteon.internal.device.InsteonAddress;\n+import org.openhab.binding.insteon.internal.device.InsteonDevice;\n+import org.openhab.binding.insteon.internal.device.InsteonDevice.DeviceStatus;\n+import org.openhab.binding.insteon.internal.device.RequestQueueManager;\n+import org.openhab.binding.insteon.internal.driver.Driver;\n+import org.openhab.binding.insteon.internal.driver.DriverListener;\n+import org.openhab.binding.insteon.internal.driver.ModemDBEntry;\n+import org.openhab.binding.insteon.internal.driver.Poller;\n+import org.openhab.binding.insteon.internal.handler.InsteonNetworkHandler;\n+import org.openhab.binding.insteon.internal.message.FieldException;\n+import org.openhab.binding.insteon.internal.message.Msg;\n+import org.openhab.binding.insteon.internal.message.MsgListener;\n+import org.openhab.binding.insteon.internal.utils.Utils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.xml.sax.SAXException;\n+\n+/**\n+ * A majority of the code in this file is from the OpenHAB 1 binding\n+ * org.openhab.binding.insteonplm.InsteonPLMActiveBinding. Including the comments below.\n+ *\n+ * -----------------------------------------------------------------------------------------------\n+ *\n+ * This class represents the actual implementation of the binding, and controls the high level flow\n+ * of messages to and from the InsteonModem.\n+ *\n+ * Writing this binding has been an odyssey through the quirks of the Insteon protocol\n+ * and Insteon devices. A substantial redesign was necessary at some point along the way.\n+ * Here are some of the hard learned lessons that should be considered by anyone who wants\n+ * to re-architect the binding:\n+ *\n+ * 1) The entries of the link database of the modem are not reliable. The category/subcategory entries in\n+ * particular have junk data. Forget about using the modem database to generate a list of devices.\n+ * The database should only be used to verify that a device has been linked.\n+ *\n+ * 2) Querying devices for their product information does not work either. First of all, battery operated devices\n+ * (and there are a lot of those) have their radio switched off, and may generally not respond to product\n+ * queries. Even main stream hardwired devices sold presently (like the 2477s switch and the 2477d dimmer)\n+ * don't even have a product ID. Although supposedly part of the Insteon protocol, we have yet to\n+ * encounter a device that would cough up a product id when queried, even among very recent devices. They\n+ * simply return zeros as product id. Lesson: forget about querying devices to generate a device list.\n+ *\n+ * 3) Polling is a thorny issue: too much traffic on the network, and messages will be dropped left and right,\n+ * and not just the poll related ones, but others as well. In particular sending back-to-back messages\n+ * seemed to result in the second message simply never getting sent, without flow control back pressure\n+ * (NACK) from the modem. For now the work-around is to space out the messages upon sending, and\n+ * in general poll as infrequently as acceptable.\n+ *\n+ * 4) Instantiating and tracking devices when reported by the modem (either from the database, or when\n+ * messages are received) leads to complicated state management because there is no guarantee at what\n+ * point (if at all) the binding configuration will be available. It gets even more difficult when\n+ * items are created, destroyed, and modified while the binding runs.\n+ *\n+ * For the above reasons, devices are only instantiated when they are referenced by binding information.\n+ * As nice as it would be to discover devices and their properties dynamically, we have abandoned that\n+ * path because it had led to a complicated and fragile system which due to the technical limitations\n+ * above was inherently squirrely.\n+ *\n+ *\n+ * @author Bernd Pfrommer - Initial contribution\n+ * @author Daniel Pfrommer - OpenHAB 1 insteonplm binding\n+ * @author Rob Nielsen - Port to OpenHAB 2 insteon binding\n+ */\n+@NonNullByDefault\n+public class InsteonBinding {\n+    private static final int DEAD_DEVICE_COUNT = 10;\n+\n+    private final Logger logger = LoggerFactory.getLogger(InsteonBinding.class);\n+\n+    private Driver m_driver = new Driver();\n+    private ConcurrentHashMap<InsteonAddress, InsteonDevice> m_devices = new ConcurrentHashMap<InsteonAddress, InsteonDevice>();\n+    private ConcurrentHashMap<String, InsteonChannelConfiguration> m_bindingConfigs = new ConcurrentHashMap<>();\n+    private PortListener m_portListener = new PortListener();\n+    private int m_devicePollIntervalMilliseconds = 300000;\n+    private int m_deadDeviceTimeout = -1;\n+    private int m_messagesReceived = 0;\n+    private boolean m_isActive = false; // state of binding\n+    private int m_x10HouseUnit = -1;\n+    private InsteonNetworkHandler m_handler;\n+\n+    public InsteonBinding(InsteonNetworkHandler handler, @Nullable InsteonNetworkConfiguration config) {\n+        this.m_handler = handler;\n+\n+        Integer devicePollIntervalSeconds = config.getDevicePollIntervalSeconds();\n+        if (devicePollIntervalSeconds != null) {\n+            m_devicePollIntervalMilliseconds = devicePollIntervalSeconds * 1000;\n+        }\n+        logger.info(\"device poll interval set to {} seconds\", m_devicePollIntervalMilliseconds / 1000);\n+\n+        Integer modemDbRetryTimeoutSeconds = config.getModemDbRetryTimeoutSeconds();\n+        if (modemDbRetryTimeoutSeconds != null) {\n+            logger.info(\"setting modem db retry timeout to {} seconds\", modemDbRetryTimeoutSeconds);\n+            m_driver.setModemDBRetryTimeout(modemDbRetryTimeoutSeconds * 1000);\n+        }\n+\n+        String additionalDevices = config.getAdditionalDevices();\n+        if (additionalDevices != null) {\n+            try {\n+                DeviceTypeLoader.s_instance().loadDeviceTypesXML(additionalDevices);\n+                logger.info(\"read additional device definitions from {}\", additionalDevices);\n+            } catch (ParserConfigurationException | SAXException | IOException e) {\n+                logger.warn(\"error reading additional devices from {}\", additionalDevices, e);\n+            }\n+        }\n+\n+        String additionalFeatures = config.getAdditionalFeatures();\n+        if (additionalFeatures != null) {\n+            logger.info(\"reading additional feature templates from {}\", additionalFeatures);\n+            DeviceFeature.s_readFeatureTemplates(additionalFeatures);\n+        }\n+\n+        m_deadDeviceTimeout = m_devicePollIntervalMilliseconds * DEAD_DEVICE_COUNT;\n+        logger.info(\"dead device timeout set to {} seconds\", m_deadDeviceTimeout / 1000);\n+\n+        String port = config.getPort();\n+        logger.info(\"port = '{}'\", port);\n+        m_driver.addPort(\"port\", port);\n+        m_driver.addMsgListener(m_portListener, port);\n+\n+        logger.debug(\"setting driver listener\");\n+        m_driver.setDriverListener(m_portListener);\n+    }\n+\n+    public boolean startPolling() {\n+        logger.debug(\"starting {} ports\", m_driver.getNumberOfPorts());\n+\n+        m_driver.startAllPorts();\n+        logger.debug(\"ports started\");\n+        switch (m_driver.getNumberOfPorts()) {\n+            case 0:\n+                logger.warn(\"initialization complete, but found no ports!\");\n+                return false;\n+            case 1:\n+                logger.debug(\"initialization complete, found 1 port!\");\n+                break;\n+            default:\n+                logger.warn(\"initialization complete, found {} ports.\", m_driver.getNumberOfPorts());\n+                break;\n+        }\n+\n+        return true;\n+    }\n+\n+    public void setIsActive(boolean isActive) {\n+        m_isActive = isActive;\n+    }\n+\n+    public void sendCommand(String channelName, Command command) {\n+        if (!m_isActive) {\n+            logger.debug(\"not ready to handle commands yet, returning.\");\n+            return;\n+        }\n+\n+        InsteonChannelConfiguration bindingConfig = m_bindingConfigs.get(channelName);\n+        if (bindingConfig == null) {\n+            logger.warn(\"unable to find binding config for channel {}\", channelName);\n+            return;\n+        }\n+\n+        InsteonDevice dev = getDevice(bindingConfig.getAddress());\n+        if (dev == null) {\n+            logger.warn(\"no device found with insteon address {}\", bindingConfig.getAddress());\n+            return;\n+        }\n+\n+        dev.processCommand(m_driver, bindingConfig, command);\n+\n+        logger.debug(\"found binding config for channel {}\", channelName);\n+    }\n+\n+    public void addFeatureListener(InsteonChannelConfiguration bindingConfig) {\n+        logger.debug(\"adding listener for channel {}\", bindingConfig.getChannelName());\n+\n+        InsteonAddress address = bindingConfig.getAddress();\n+        InsteonDevice dev = getDevice(address);\n+        @Nullable\n+        DeviceFeature f = dev.getFeature(bindingConfig.getFeature());\n+        if (f == null || f.isFeatureGroup()) {\n+            StringBuffer buf = new StringBuffer();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ed93353c47fa5d457223c66d8f91b1c168a57e23"}, "originalPosition": 216}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Njc3NjIwNQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    logger.info(\"dead device timeout set to {} seconds\", m_deadDeviceTimeout / 1000);\n          \n          \n            \n                    logger.debug(\"dead device timeout set to {} seconds\", m_deadDeviceTimeout / 1000);", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r386776205", "createdAt": "2020-03-03T03:07:21Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.insteon/src/main/java/org/openhab/binding/insteon/internal/InsteonBinding.java", "diffHunk": "@@ -0,0 +1,512 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.insteon.internal;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map.Entry;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import javax.xml.parsers.ParserConfigurationException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.insteon.internal.config.InsteonChannelConfiguration;\n+import org.openhab.binding.insteon.internal.config.InsteonNetworkConfiguration;\n+import org.openhab.binding.insteon.internal.device.DeviceFeature;\n+import org.openhab.binding.insteon.internal.device.DeviceFeatureListener;\n+import org.openhab.binding.insteon.internal.device.DeviceType;\n+import org.openhab.binding.insteon.internal.device.DeviceTypeLoader;\n+import org.openhab.binding.insteon.internal.device.InsteonAddress;\n+import org.openhab.binding.insteon.internal.device.InsteonDevice;\n+import org.openhab.binding.insteon.internal.device.InsteonDevice.DeviceStatus;\n+import org.openhab.binding.insteon.internal.device.RequestQueueManager;\n+import org.openhab.binding.insteon.internal.driver.Driver;\n+import org.openhab.binding.insteon.internal.driver.DriverListener;\n+import org.openhab.binding.insteon.internal.driver.ModemDBEntry;\n+import org.openhab.binding.insteon.internal.driver.Poller;\n+import org.openhab.binding.insteon.internal.handler.InsteonNetworkHandler;\n+import org.openhab.binding.insteon.internal.message.FieldException;\n+import org.openhab.binding.insteon.internal.message.Msg;\n+import org.openhab.binding.insteon.internal.message.MsgListener;\n+import org.openhab.binding.insteon.internal.utils.Utils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.xml.sax.SAXException;\n+\n+/**\n+ * A majority of the code in this file is from the OpenHAB 1 binding\n+ * org.openhab.binding.insteonplm.InsteonPLMActiveBinding. Including the comments below.\n+ *\n+ * -----------------------------------------------------------------------------------------------\n+ *\n+ * This class represents the actual implementation of the binding, and controls the high level flow\n+ * of messages to and from the InsteonModem.\n+ *\n+ * Writing this binding has been an odyssey through the quirks of the Insteon protocol\n+ * and Insteon devices. A substantial redesign was necessary at some point along the way.\n+ * Here are some of the hard learned lessons that should be considered by anyone who wants\n+ * to re-architect the binding:\n+ *\n+ * 1) The entries of the link database of the modem are not reliable. The category/subcategory entries in\n+ * particular have junk data. Forget about using the modem database to generate a list of devices.\n+ * The database should only be used to verify that a device has been linked.\n+ *\n+ * 2) Querying devices for their product information does not work either. First of all, battery operated devices\n+ * (and there are a lot of those) have their radio switched off, and may generally not respond to product\n+ * queries. Even main stream hardwired devices sold presently (like the 2477s switch and the 2477d dimmer)\n+ * don't even have a product ID. Although supposedly part of the Insteon protocol, we have yet to\n+ * encounter a device that would cough up a product id when queried, even among very recent devices. They\n+ * simply return zeros as product id. Lesson: forget about querying devices to generate a device list.\n+ *\n+ * 3) Polling is a thorny issue: too much traffic on the network, and messages will be dropped left and right,\n+ * and not just the poll related ones, but others as well. In particular sending back-to-back messages\n+ * seemed to result in the second message simply never getting sent, without flow control back pressure\n+ * (NACK) from the modem. For now the work-around is to space out the messages upon sending, and\n+ * in general poll as infrequently as acceptable.\n+ *\n+ * 4) Instantiating and tracking devices when reported by the modem (either from the database, or when\n+ * messages are received) leads to complicated state management because there is no guarantee at what\n+ * point (if at all) the binding configuration will be available. It gets even more difficult when\n+ * items are created, destroyed, and modified while the binding runs.\n+ *\n+ * For the above reasons, devices are only instantiated when they are referenced by binding information.\n+ * As nice as it would be to discover devices and their properties dynamically, we have abandoned that\n+ * path because it had led to a complicated and fragile system which due to the technical limitations\n+ * above was inherently squirrely.\n+ *\n+ *\n+ * @author Bernd Pfrommer - Initial contribution\n+ * @author Daniel Pfrommer - OpenHAB 1 insteonplm binding\n+ * @author Rob Nielsen - Port to OpenHAB 2 insteon binding\n+ */\n+@NonNullByDefault\n+public class InsteonBinding {\n+    private static final int DEAD_DEVICE_COUNT = 10;\n+\n+    private final Logger logger = LoggerFactory.getLogger(InsteonBinding.class);\n+\n+    private Driver m_driver = new Driver();\n+    private ConcurrentHashMap<InsteonAddress, InsteonDevice> m_devices = new ConcurrentHashMap<InsteonAddress, InsteonDevice>();\n+    private ConcurrentHashMap<String, InsteonChannelConfiguration> m_bindingConfigs = new ConcurrentHashMap<>();\n+    private PortListener m_portListener = new PortListener();\n+    private int m_devicePollIntervalMilliseconds = 300000;\n+    private int m_deadDeviceTimeout = -1;\n+    private int m_messagesReceived = 0;\n+    private boolean m_isActive = false; // state of binding\n+    private int m_x10HouseUnit = -1;\n+    private InsteonNetworkHandler m_handler;\n+\n+    public InsteonBinding(InsteonNetworkHandler handler, @Nullable InsteonNetworkConfiguration config) {\n+        this.m_handler = handler;\n+\n+        Integer devicePollIntervalSeconds = config.getDevicePollIntervalSeconds();\n+        if (devicePollIntervalSeconds != null) {\n+            m_devicePollIntervalMilliseconds = devicePollIntervalSeconds * 1000;\n+        }\n+        logger.info(\"device poll interval set to {} seconds\", m_devicePollIntervalMilliseconds / 1000);\n+\n+        Integer modemDbRetryTimeoutSeconds = config.getModemDbRetryTimeoutSeconds();\n+        if (modemDbRetryTimeoutSeconds != null) {\n+            logger.info(\"setting modem db retry timeout to {} seconds\", modemDbRetryTimeoutSeconds);\n+            m_driver.setModemDBRetryTimeout(modemDbRetryTimeoutSeconds * 1000);\n+        }\n+\n+        String additionalDevices = config.getAdditionalDevices();\n+        if (additionalDevices != null) {\n+            try {\n+                DeviceTypeLoader.s_instance().loadDeviceTypesXML(additionalDevices);\n+                logger.info(\"read additional device definitions from {}\", additionalDevices);\n+            } catch (ParserConfigurationException | SAXException | IOException e) {\n+                logger.warn(\"error reading additional devices from {}\", additionalDevices, e);\n+            }\n+        }\n+\n+        String additionalFeatures = config.getAdditionalFeatures();\n+        if (additionalFeatures != null) {\n+            logger.info(\"reading additional feature templates from {}\", additionalFeatures);\n+            DeviceFeature.s_readFeatureTemplates(additionalFeatures);\n+        }\n+\n+        m_deadDeviceTimeout = m_devicePollIntervalMilliseconds * DEAD_DEVICE_COUNT;\n+        logger.info(\"dead device timeout set to {} seconds\", m_deadDeviceTimeout / 1000);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ed93353c47fa5d457223c66d8f91b1c168a57e23"}, "originalPosition": 150}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Njc3NzQ1OA==", "bodyText": "needs try/finally for locking", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r386777458", "createdAt": "2020-03-03T03:12:57Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.insteon/src/main/java/org/openhab/binding/insteon/internal/device/ModemDBBuilder.java", "diffHunk": "@@ -0,0 +1,189 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.insteon.internal.device;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.Map.Entry;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.insteon.internal.driver.ModemDBEntry;\n+import org.openhab.binding.insteon.internal.driver.Port;\n+import org.openhab.binding.insteon.internal.message.FieldException;\n+import org.openhab.binding.insteon.internal.message.Msg;\n+import org.openhab.binding.insteon.internal.message.MsgListener;\n+import org.openhab.binding.insteon.internal.utils.Utils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Builds the modem database from incoming link record messages\n+ *\n+ * @author Bernd Pfrommer - Initial contribution\n+ * @author Rob Nielsen - Port to OpenHAB 2 insteon binding\n+ */\n+@NonNullByDefault\n+public class ModemDBBuilder implements MsgListener, Runnable {\n+    private static final Logger logger = LoggerFactory.getLogger(ModemDBBuilder.class);\n+    private boolean m_isComplete = false;\n+    private Port m_port;\n+    private @Nullable Thread m_writeThread = null;\n+    private int m_timeoutMillis = 120000;\n+\n+    public ModemDBBuilder(Port port) {\n+        m_port = port;\n+    }\n+\n+    public void setRetryTimeout(int timeout) {\n+        m_timeoutMillis = timeout;\n+    }\n+\n+    public void start() {\n+        m_port.addListener(this);\n+        m_writeThread = new Thread(this);\n+        m_writeThread.setName(\"DBBuilder\");\n+        m_writeThread.start();\n+        logger.debug(\"querying port for first link record\");\n+    }\n+\n+    public void startDownload() {\n+        logger.trace(\"starting modem database download\");\n+        m_port.clearModemDB();\n+        getFirstLinkRecord();\n+    }\n+\n+    public synchronized boolean isComplete() {\n+        return (m_isComplete);\n+    }\n+\n+    @Override\n+    public void run() {\n+        logger.trace(\"starting modem db builder thread\");\n+        while (!isComplete()) {\n+            startDownload();\n+            try {\n+                Thread.sleep(m_timeoutMillis); // wait for download to complete\n+            } catch (InterruptedException e) {\n+                logger.warn(\"modem db builder thread interrupted\");\n+                break;\n+            }\n+            if (!isComplete()) {\n+                logger.warn(\"modem database download unsuccessful, restarting!\");\n+            }\n+        }\n+        logger.trace(\"exiting modem db builder thread\");\n+    }\n+\n+    private void getFirstLinkRecord() {\n+        try {\n+            m_port.writeMessage(Msg.s_makeMessage(\"GetFirstALLLinkRecord\"));\n+        } catch (IOException e) {\n+            logger.warn(\"error sending link record query \", e);\n+        }\n+\n+    }\n+\n+    /**\n+     * processes link record messages from the modem to build database\n+     * and request more link records if not finished.\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public void msg(Msg msg, String fromPort) {\n+        if (msg.isPureNack()) {\n+            return;\n+        }\n+        try {\n+            if (msg.getByte(\"Cmd\") == 0x69 || msg.getByte(\"Cmd\") == 0x6a) {\n+                // If the flag is \"ACK/NACK\", a record response\n+                // will follow, so we do nothing here.\n+                // If its \"NACK\", there are none\n+                if (msg.getByte(\"ACK/NACK\") == 0x15) {\n+                    logger.debug(\"got all link records.\");\n+                    done();\n+                }\n+            } else if (msg.getByte(\"Cmd\") == 0x57) {\n+                // we got the link record response\n+                updateModemDB(msg.getAddress(\"LinkAddr\"), m_port, msg);\n+                m_port.writeMessage(Msg.s_makeMessage(\"GetNextALLLinkRecord\"));\n+            }\n+        } catch (FieldException e) {\n+            logger.debug(\"bad field handling link records {}\", e.getMessage());\n+        } catch (IOException e) {\n+            logger.debug(\"got IO exception handling link records {}\", e.getMessage());\n+        } catch (IllegalStateException e) {\n+            logger.debug(\"got exception requesting link records {}\", e.getMessage());\n+        }\n+    }\n+\n+    private synchronized void done() {\n+        m_isComplete = true;\n+        logModemDB();\n+        m_port.removeListener(this);\n+        m_port.modemDBComplete();\n+    }\n+\n+    private void logModemDB() {\n+        try {\n+            logger.debug(\"MDB ------- start of modem link records ------------------\");\n+            HashMap<InsteonAddress, @Nullable ModemDBEntry> dbes = m_port.getDriver().lockModemDBEntries();\n+            for (Entry<InsteonAddress, @Nullable ModemDBEntry> db : dbes.entrySet()) {\n+                ArrayList<Msg> lrs = db.getValue().getLinkRecords();\n+                for (Msg m : lrs) {\n+                    int recordFlags = m.getByte(\"RecordFlags\") & 0xff;\n+                    String ms = ((recordFlags & (0x1 << 6)) != 0) ? \"CTRL\" : \"RESP\";\n+                    logger.debug(\"MDB {}: {} group: {} data1: {} data2: {} data3: {}\", db.getKey(), ms,\n+                            toHex(m.getByte(\"ALLLinkGroup\")), toHex(m.getByte(\"LinkData1\")),\n+                            toHex(m.getByte(\"LinkData2\")), toHex(m.getByte(\"LinkData2\")));\n+                }\n+                logger.debug(\"MDB -----\");\n+            }\n+            logger.debug(\"MDB ---------------- end of modem link records -----------\");\n+        } catch (FieldException e) {\n+            logger.warn(\"cannot access field:\", e);\n+        } finally {\n+            m_port.getDriver().unlockModemDBEntries();\n+        }\n+    }\n+\n+    public static String toHex(byte b) {\n+        return Utils.getHexString(b);\n+    }\n+\n+    public void updateModemDB(InsteonAddress linkAddr, Port port, @Nullable Msg m) {\n+        HashMap<InsteonAddress, @Nullable ModemDBEntry> dbes = port.getDriver().lockModemDBEntries();\n+        ModemDBEntry dbe = dbes.get(linkAddr);\n+        if (dbe == null) {\n+            dbe = new ModemDBEntry(linkAddr);\n+            dbes.put(linkAddr, dbe);\n+        }\n+        dbe.setPort(port);\n+        if (m != null) {\n+            dbe.addLinkRecord(m);\n+            try {\n+                byte group = m.getByte(\"ALLLinkGroup\");\n+                int recordFlags = m.getByte(\"RecordFlags\") & 0xff;\n+                if ((recordFlags & (0x1 << 6)) != 0) {\n+                    dbe.addControls(group);\n+                } else {\n+                    dbe.addRespondsTo(group);\n+                }\n+            } catch (FieldException e) {\n+                logger.warn(\"cannot access field:\", e);\n+            }\n+        }\n+        port.getDriver().unlockModemDBEntries();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ed93353c47fa5d457223c66d8f91b1c168a57e23"}, "originalPosition": 187}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY3NjgwNDU2", "url": "https://github.com/openhab/openhab-addons/pull/6911#pullrequestreview-367680456", "createdAt": "2020-03-03T03:23:30Z", "commit": {"oid": "ed93353c47fa5d457223c66d8f91b1c168a57e23"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY4NDg3MDM5", "url": "https://github.com/openhab/openhab-addons/pull/6911#pullrequestreview-368487039", "createdAt": "2020-03-04T03:43:11Z", "commit": {"oid": "c7145825da480ffe00ceee1c54e253bfc879b555"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 12, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNFQwMzo0NToxNVrOFxfIuQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNFQwNDo1MzowNlrOFxf9cw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzQzNDY4MQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private HashMap<String, DeviceType> m_deviceTypes = new HashMap<String, DeviceType>();\n          \n          \n            \n                private final HashMap<String, DeviceType> m_deviceTypes = new HashMap<String, DeviceType>();", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r387434681", "createdAt": "2020-03-04T03:45:15Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.insteon/src/main/java/org/openhab/binding/insteon/internal/device/DeviceTypeLoader.java", "diffHunk": "@@ -0,0 +1,238 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.insteon.internal.device;\n+\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.util.HashMap;\n+import java.util.Map.Entry;\n+\n+import javax.xml.parsers.DocumentBuilder;\n+import javax.xml.parsers.DocumentBuilderFactory;\n+import javax.xml.parsers.ParserConfigurationException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.insteon.internal.device.DeviceType.FeatureGroup;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.w3c.dom.Document;\n+import org.w3c.dom.Element;\n+import org.w3c.dom.Node;\n+import org.w3c.dom.NodeList;\n+import org.xml.sax.SAXException;\n+\n+/**\n+ * Reads the device types from an xml file.\n+ *\n+ * @author Daniel Pfrommer - Initial contribution\n+ * @author Bernd Pfrommer - OpenHAB 1 insteonplm binding\n+ * @author Rob Nielsen - Port to OpenHAB 2 insteon binding\n+ */\n+@NonNullByDefault\n+@SuppressWarnings(\"null\")\n+public class DeviceTypeLoader {\n+    private static final Logger logger = LoggerFactory.getLogger(DeviceTypeLoader.class);\n+    private HashMap<String, DeviceType> m_deviceTypes = new HashMap<String, DeviceType>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c7145825da480ffe00ceee1c54e253bfc879b555"}, "originalPosition": 48}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzQzNTgwNQ==", "bodyText": "I found your post regarding getResourceAsStream issues. Did you never experience the same issue here?", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r387435805", "createdAt": "2020-03-04T03:50:35Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.insteon/src/main/java/org/openhab/binding/insteon/internal/device/DeviceTypeLoader.java", "diffHunk": "@@ -0,0 +1,237 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.insteon.internal.device;\n+\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.util.HashMap;\n+import java.util.Map.Entry;\n+\n+import javax.xml.parsers.DocumentBuilder;\n+import javax.xml.parsers.DocumentBuilderFactory;\n+import javax.xml.parsers.ParserConfigurationException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.insteon.internal.device.DeviceType.FeatureGroup;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.w3c.dom.Document;\n+import org.w3c.dom.Element;\n+import org.w3c.dom.Node;\n+import org.w3c.dom.NodeList;\n+import org.xml.sax.SAXException;\n+\n+/**\n+ * Reads the device types from an xml file.\n+ *\n+ * @author Daniel Pfrommer - Initial contribution\n+ * @author Bernd Pfrommer - OpenHAB 1 insteonplm binding\n+ * @author Rob Nielsen - Port to OpenHAB 2 insteon binding\n+ */\n+@NonNullByDefault\n+public class DeviceTypeLoader {\n+    private static final Logger logger = LoggerFactory.getLogger(DeviceTypeLoader.class);\n+    private HashMap<String, DeviceType> m_deviceTypes = new HashMap<String, DeviceType>();\n+    private @Nullable static DeviceTypeLoader s_deviceTypeLoader = null;\n+\n+    private DeviceTypeLoader() {\n+    } // private so nobody can call it\n+\n+    /**\n+     * Finds the device type for a given product key\n+     *\n+     * @param aProdKey product key to search for\n+     * @return the device type, or null if not found\n+     */\n+    public @Nullable DeviceType getDeviceType(String aProdKey) {\n+        return (m_deviceTypes.get(aProdKey));\n+    }\n+\n+    /**\n+     * Must call loadDeviceTypesXML() before calling this function!\n+     *\n+     * @return currently known device types\n+     */\n+    public HashMap<String, DeviceType> getDeviceTypes() {\n+        return (m_deviceTypes);\n+    }\n+\n+    /**\n+     * Reads the device types from input stream and stores them in memory for\n+     * later access.\n+     *\n+     * @param is the input stream from which to read\n+     */\n+    public void loadDeviceTypesXML(InputStream in) throws ParserConfigurationException, SAXException, IOException {\n+        DocumentBuilderFactory dbFactory = DocumentBuilderFactory.newInstance();\n+        DocumentBuilder dBuilder = dbFactory.newDocumentBuilder();\n+        Document doc = dBuilder.parse(in);\n+        doc.getDocumentElement().normalize();\n+        Node root = doc.getDocumentElement();\n+        NodeList nodes = root.getChildNodes();\n+        for (int i = 0; i < nodes.getLength(); i++) {\n+            Node node = nodes.item(i);\n+            if (node.getNodeType() == Node.ELEMENT_NODE && node.getNodeName().equals(\"device\")) {\n+                processDevice((Element) node);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Reads the device types from file and stores them in memory for later access.\n+     *\n+     * @param aFileName The name of the file to read from\n+     * @throws ParserConfigurationException\n+     * @throws SAXException\n+     * @throws IOException\n+     */\n+    public void loadDeviceTypesXML(String aFileName) throws ParserConfigurationException, SAXException, IOException {\n+        File file = new File(aFileName);\n+        InputStream in = new FileInputStream(file);\n+        loadDeviceTypesXML(in);\n+    }\n+\n+    /**\n+     * Process device node\n+     *\n+     * @param e name of the element to process\n+     * @throws SAXException\n+     */\n+    private void processDevice(Element e) throws SAXException {\n+        String productKey = e.getAttribute(\"productKey\");\n+        if (productKey.equals(\"\")) {\n+            throw new SAXException(\"device in device_types file has no product key!\");\n+        }\n+        if (m_deviceTypes.containsKey(productKey)) {\n+            logger.warn(\"overwriting previous definition of device {}\", productKey);\n+            m_deviceTypes.remove(productKey);\n+        }\n+        DeviceType devType = new DeviceType(productKey);\n+\n+        NodeList nodes = e.getChildNodes();\n+        for (int i = 0; i < nodes.getLength(); i++) {\n+            Node node = nodes.item(i);\n+            if (node.getNodeType() != Node.ELEMENT_NODE) {\n+                continue;\n+            }\n+            Element subElement = (Element) node;\n+            if (subElement.getNodeName().equals(\"model\")) {\n+                devType.setModel(subElement.getTextContent());\n+            } else if (subElement.getNodeName().equals(\"description\")) {\n+                devType.setDescription(subElement.getTextContent());\n+            } else if (subElement.getNodeName().equals(\"feature\")) {\n+                processFeature(devType, subElement);\n+            } else if (subElement.getNodeName().equals(\"feature_group\")) {\n+                processFeatureGroup(devType, subElement);\n+            }\n+            m_deviceTypes.put(productKey, devType);\n+        }\n+    }\n+\n+    private String processFeature(DeviceType devType, Element e) throws SAXException {\n+        String name = e.getAttribute(\"name\");\n+        if (name.equals(\"\")) {\n+            throw new SAXException(\"feature \" + e.getNodeName() + \" has feature without name!\");\n+        }\n+        if (!name.equals(name.toLowerCase())) {\n+            throw new SAXException(\"feature name '\" + name + \"' must be lower case\");\n+        }\n+        if (!devType.addFeature(name, e.getTextContent())) {\n+            throw new SAXException(\"duplicate feature: \" + name);\n+        }\n+        return (name);\n+    }\n+\n+    private String processFeatureGroup(DeviceType devType, Element e) throws SAXException {\n+        String name = e.getAttribute(\"name\");\n+        if (name.equals(\"\")) {\n+            throw new SAXException(\"feature group \" + e.getNodeName() + \" has no name attr!\");\n+        }\n+        String type = e.getAttribute(\"type\");\n+        if (type.equals(\"\")) {\n+            throw new SAXException(\"feature group \" + e.getNodeName() + \" has no type attr!\");\n+        }\n+        FeatureGroup fg = new FeatureGroup(name, type);\n+        NodeList nodes = e.getChildNodes();\n+        for (int i = 0; i < nodes.getLength(); i++) {\n+            Node node = nodes.item(i);\n+            if (node.getNodeType() != Node.ELEMENT_NODE) {\n+                continue;\n+            }\n+            Element subElement = (Element) node;\n+            if (subElement.getNodeName().equals(\"feature\")) {\n+                fg.addFeature(processFeature(devType, subElement));\n+            } else if (subElement.getNodeName().equals(\"feature_group\")) {\n+                fg.addFeature(processFeatureGroup(devType, subElement));\n+            }\n+        }\n+        if (!devType.addFeatureGroup(name, fg)) {\n+            throw new SAXException(\"duplicate feature group \" + name);\n+        }\n+        return (name);\n+    }\n+\n+    /**\n+     * Helper function for debugging\n+     */\n+    private void logDeviceTypes() {\n+        for (Entry<String, DeviceType> dt : getDeviceTypes().entrySet()) {\n+            String msg = String.format(\"%-10s->\", dt.getKey()) + dt.getValue();\n+            logger.debug(\"{}\", msg);\n+        }\n+    }\n+\n+    /**\n+     * Singleton instance function, creates DeviceTypeLoader\n+     *\n+     * @return DeviceTypeLoader singleton reference\n+     */\n+    @Nullable\n+    public static synchronized DeviceTypeLoader s_instance() {\n+        if (s_deviceTypeLoader == null) {\n+            s_deviceTypeLoader = new DeviceTypeLoader();\n+            InputStream input = DeviceTypeLoader.class.getResourceAsStream(\"/device_types.xml\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Njc0OTAzMw=="}, "originalCommit": {"oid": "ed93353c47fa5d457223c66d8f91b1c168a57e23"}, "originalPosition": 206}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzQzNjg2Mg==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    private String m_name;\n          \n          \n            \n                    private String m_type;\n          \n          \n            \n                    private final String m_name;\n          \n          \n            \n                    private final String m_type;", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r387436862", "createdAt": "2020-03-04T03:55:27Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.insteon/src/main/java/org/openhab/binding/insteon/internal/device/DeviceType.java", "diffHunk": "@@ -0,0 +1,167 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.insteon.internal.device;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.Map.Entry;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+\n+/**\n+ * The DeviceType class holds device type definitions that are read from\n+ * an xml file.\n+ *\n+ * @author Bernd Pfrommer - Initial contribution\n+ * @author Rob Nielsen - Port to OpenHAB 2 insteon binding\n+ */\n+@NonNullByDefault\n+@SuppressWarnings(\"null\")\n+public class DeviceType {\n+    private String m_productKey;\n+    private String m_model = \"\";\n+    private String m_description = \"\";\n+    private HashMap<String, String> m_features = new HashMap<String, String>();\n+    private HashMap<String, FeatureGroup> m_featureGroups = new HashMap<String, FeatureGroup>();\n+\n+    /**\n+     * Constructor\n+     *\n+     * @param aProductKey the product key for this device type\n+     */\n+    public DeviceType(String aProductKey) {\n+        m_productKey = aProductKey;\n+    }\n+\n+    /**\n+     * Get supported features\n+     *\n+     * @return all features that this device type supports\n+     */\n+    public HashMap<String, String> getFeatures() {\n+        return m_features;\n+    }\n+\n+    /**\n+     * Get all feature groups\n+     *\n+     * @return all feature groups of this device type\n+     */\n+    public HashMap<String, FeatureGroup> getFeatureGroups() {\n+        return m_featureGroups;\n+    }\n+\n+    /**\n+     * Sets the descriptive model string\n+     *\n+     * @param aModel descriptive model string\n+     */\n+    public void setModel(String aModel) {\n+        m_model = aModel;\n+    }\n+\n+    /**\n+     * Sets free text description\n+     *\n+     * @param aDesc free text description\n+     */\n+    public void setDescription(String aDesc) {\n+        m_description = aDesc;\n+    }\n+\n+    /**\n+     * Adds feature to this device type\n+     *\n+     * @param aKey the key (e.g. \"switch\") under which this feature can be referenced in the item binding config\n+     * @param aFeatureName the name (e.g. \"GenericSwitch\") under which the feature has been defined\n+     * @return false if feature was already there\n+     */\n+    public boolean addFeature(String aKey, String aFeatureName) {\n+        if (m_features.containsKey(aKey)) {\n+            return false;\n+        }\n+        m_features.put(aKey, aFeatureName);\n+        return true;\n+    }\n+\n+    /**\n+     * Adds feature group to device type\n+     *\n+     * @param aKey name of the feature group, which acts as key for lookup later\n+     * @param fg feature group to add\n+     * @return true if add succeeded, false if group was already there\n+     */\n+    public boolean addFeatureGroup(String aKey, FeatureGroup fg) {\n+        if (m_features.containsKey(aKey)) {\n+            return false;\n+        }\n+        m_featureGroups.put(aKey, fg);\n+        return true;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        String s = \"pk:\" + m_productKey + \"|model:\" + m_model + \"|desc:\" + m_description + \"|features\";\n+        for (Entry<String, String> f : m_features.entrySet()) {\n+            s += \":\" + f.getKey() + \"=\" + f.getValue();\n+        }\n+        s += \"|groups\";\n+        for (Entry<String, FeatureGroup> f : m_featureGroups.entrySet()) {\n+            s += \":\" + f.getKey() + \"=\" + f.getValue();\n+        }\n+        return s;\n+    }\n+\n+    /**\n+     * Class that reflects feature group association\n+     *\n+     * @author Bernd Pfrommer - Initial contribution\n+     */\n+    @NonNullByDefault\n+    public static class FeatureGroup {\n+        private String m_name;\n+        private String m_type;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c7145825da480ffe00ceee1c54e253bfc879b555"}, "originalPosition": 133}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzQzNjk0Mg==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private String m_productKey;\n          \n          \n            \n                private final String m_productKey;", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r387436942", "createdAt": "2020-03-04T03:55:46Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.insteon/src/main/java/org/openhab/binding/insteon/internal/device/DeviceType.java", "diffHunk": "@@ -0,0 +1,167 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.insteon.internal.device;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.Map.Entry;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+\n+/**\n+ * The DeviceType class holds device type definitions that are read from\n+ * an xml file.\n+ *\n+ * @author Bernd Pfrommer - Initial contribution\n+ * @author Rob Nielsen - Port to OpenHAB 2 insteon binding\n+ */\n+@NonNullByDefault\n+@SuppressWarnings(\"null\")\n+public class DeviceType {\n+    private String m_productKey;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c7145825da480ffe00ceee1c54e253bfc879b555"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzQzNzEyOA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private HashMap<String, String> m_features = new HashMap<String, String>();\n          \n          \n            \n                private HashMap<String, FeatureGroup> m_featureGroups = new HashMap<String, FeatureGroup>();\n          \n          \n            \n                private final HashMap<String, String> m_features = new HashMap<String, String>();\n          \n          \n            \n                private final HashMap<String, FeatureGroup> m_featureGroups = new HashMap<String, FeatureGroup>();", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r387437128", "createdAt": "2020-03-04T03:56:46Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.insteon/src/main/java/org/openhab/binding/insteon/internal/device/DeviceType.java", "diffHunk": "@@ -0,0 +1,167 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.insteon.internal.device;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.Map.Entry;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+\n+/**\n+ * The DeviceType class holds device type definitions that are read from\n+ * an xml file.\n+ *\n+ * @author Bernd Pfrommer - Initial contribution\n+ * @author Rob Nielsen - Port to OpenHAB 2 insteon binding\n+ */\n+@NonNullByDefault\n+@SuppressWarnings(\"null\")\n+public class DeviceType {\n+    private String m_productKey;\n+    private String m_model = \"\";\n+    private String m_description = \"\";\n+    private HashMap<String, String> m_features = new HashMap<String, String>();\n+    private HashMap<String, FeatureGroup> m_featureGroups = new HashMap<String, FeatureGroup>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c7145825da480ffe00ceee1c54e253bfc879b555"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzQzNzMwMA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private String m_itemName;\n          \n          \n            \n                private ChannelUID m_channelUID;\n          \n          \n            \n                private HashMap<String, @Nullable String> m_parameters = new HashMap<String, @Nullable String>();\n          \n          \n            \n                private HashMap<Class<?>, @Nullable State> m_state = new HashMap<Class<?>, @Nullable State>();\n          \n          \n            \n                private ArrayList<InsteonAddress> m_relatedDevices = new ArrayList<InsteonAddress>();\n          \n          \n            \n                private InsteonBinding m_binding;\n          \n          \n            \n                private final String m_itemName;\n          \n          \n            \n                private final ChannelUID m_channelUID;\n          \n          \n            \n                private final HashMap<String, @Nullable String> m_parameters = new HashMap<String, @Nullable String>();\n          \n          \n            \n                private final HashMap<Class<?>, @Nullable State> m_state = new HashMap<Class<?>, @Nullable State>();\n          \n          \n            \n                private final ArrayList<InsteonAddress> m_relatedDevices = new ArrayList<InsteonAddress>();\n          \n          \n            \n                private final InsteonBinding m_binding;", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r387437300", "createdAt": "2020-03-04T03:57:46Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.insteon/src/main/java/org/openhab/binding/insteon/internal/device/DeviceFeatureListener.java", "diffHunk": "@@ -0,0 +1,190 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.insteon.internal.device;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.insteon.internal.InsteonBinding;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * A DeviceFeatureListener essentially represents an OpenHAB item that\n+ * listens to a particular feature of an Insteon device\n+ *\n+ * @author Daniel Pfrommer - Initial contribution\n+ * @author Bernd Pfrommer - OpenHAB 1 insteonplm binding\n+ * @author Rob Nielsen - Port to OpenHAB 2 insteon binding\n+ */\n+@NonNullByDefault\n+public class DeviceFeatureListener {\n+    private final Logger logger = LoggerFactory.getLogger(DeviceFeatureListener.class);\n+\n+    public enum StateChangeType {\n+        ALWAYS,\n+        CHANGED\n+    };\n+\n+    private String m_itemName;\n+    private ChannelUID m_channelUID;\n+    private HashMap<String, @Nullable String> m_parameters = new HashMap<String, @Nullable String>();\n+    private HashMap<Class<?>, @Nullable State> m_state = new HashMap<Class<?>, @Nullable State>();\n+    private ArrayList<InsteonAddress> m_relatedDevices = new ArrayList<InsteonAddress>();\n+    private InsteonBinding m_binding;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c7145825da480ffe00ceee1c54e253bfc879b555"}, "originalPosition": 50}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzQzOTE2Ng==", "bodyText": "you forgot to call setDaemon(true) on the threads", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r387439166", "createdAt": "2020-03-04T04:07:37Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.insteon/src/main/java/org/openhab/binding/insteon/internal/driver/Port.java", "diffHunk": "@@ -161,10 +161,10 @@ public void start() {\n             return;\n         }\n         m_readThread = new Thread(m_reader);\n-        m_writeThread = new Thread(m_writer);\n-        m_readThread.setName(m_logName + \" Reader\");\n-        m_writeThread.setName(m_logName + \" Writer\");\n+        m_readThread.setName(\"Insteon \" + m_logName + \" Reader\");\n         m_readThread.start();\n+        m_writeThread = new Thread(m_writer);\n+        m_writeThread.setName(\"Insteon \" + m_logName + \" Writer\");\n         m_writeThread.start();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9c45d84e5fc09e1ff59474c5e9a2f5dde141d337"}, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzQzOTI5MQ==", "bodyText": "set thread to daemon too", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r387439291", "createdAt": "2020-03-04T04:08:20Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.insteon/src/main/java/org/openhab/binding/insteon/internal/driver/hub/HubIOStream.java", "diffHunk": "@@ -95,6 +95,7 @@ public boolean open() {\n \n         polling = true;\n         m_pollThread = new Thread(this);\n+        m_pollThread.setName(\"Insteon Hub Poller\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9c45d84e5fc09e1ff59474c5e9a2f5dde141d337"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzQzOTYzMQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private String m_name;\n          \n          \n            \n                private String m_timeout;\n          \n          \n            \n                private boolean m_isStatus;\n          \n          \n            \n                private @Nullable HandlerEntry m_dispatcher = null;\n          \n          \n            \n                private @Nullable HandlerEntry m_pollHandler = null;\n          \n          \n            \n                private @Nullable HandlerEntry m_defaultMsgHandler = null;\n          \n          \n            \n                private @Nullable HandlerEntry m_defaultCmdHandler = null;\n          \n          \n            \n                private HashMap<Integer, HandlerEntry> m_messageHandlers = new HashMap<Integer, HandlerEntry>();\n          \n          \n            \n                private HashMap<Class<? extends Command>, HandlerEntry> m_commandHandlers = new HashMap<Class<? extends Command>, HandlerEntry>();\n          \n          \n            \n                private final String m_name;\n          \n          \n            \n                private final String m_timeout;\n          \n          \n            \n                private final boolean m_isStatus;\n          \n          \n            \n                private @Nullable HandlerEntry m_dispatcher = null;\n          \n          \n            \n                private @Nullable HandlerEntry m_pollHandler = null;\n          \n          \n            \n                private @Nullable HandlerEntry m_defaultMsgHandler = null;\n          \n          \n            \n                private @Nullable HandlerEntry m_defaultCmdHandler = null;\n          \n          \n            \n                private final HashMap<Integer, HandlerEntry> m_messageHandlers = new HashMap<Integer, HandlerEntry>();\n          \n          \n            \n                private final HashMap<Class<? extends Command>, HandlerEntry> m_commandHandlers = new HashMap<Class<? extends Command>, HandlerEntry>();", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r387439631", "createdAt": "2020-03-04T04:10:03Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.insteon/src/main/java/org/openhab/binding/insteon/internal/device/FeatureTemplate.java", "diffHunk": "@@ -0,0 +1,174 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.insteon.internal.device;\n+\n+import java.util.HashMap;\n+import java.util.Map.Entry;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.types.Command;\n+\n+/**\n+ * A simple class which contains the basic info needed to create a device feature.\n+ * Here, all handlers are represented as strings. The actual device feature\n+ * is then instantiated from the template by calling the build() function.\n+ *\n+ * @author Daniel Pfrommer - Initial contribution\n+ * @author Rob Nielsen - Port to OpenHAB 2 insteon binding\n+ */\n+@NonNullByDefault\n+@SuppressWarnings(\"null\")\n+public class FeatureTemplate {\n+    private String m_name;\n+    private String m_timeout;\n+    private boolean m_isStatus;\n+    private @Nullable HandlerEntry m_dispatcher = null;\n+    private @Nullable HandlerEntry m_pollHandler = null;\n+    private @Nullable HandlerEntry m_defaultMsgHandler = null;\n+    private @Nullable HandlerEntry m_defaultCmdHandler = null;\n+    private HashMap<Integer, HandlerEntry> m_messageHandlers = new HashMap<Integer, HandlerEntry>();\n+    private HashMap<Class<? extends Command>, HandlerEntry> m_commandHandlers = new HashMap<Class<? extends Command>, HandlerEntry>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c7145825da480ffe00ceee1c54e253bfc879b555"}, "originalPosition": 41}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzQ0MDM4NQ==", "bodyText": "missed this one", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r387440385", "createdAt": "2020-03-04T04:13:37Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.insteon/src/main/java/org/openhab/binding/insteon/internal/driver/ModemDBEntry.java", "diffHunk": "@@ -0,0 +1,100 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.insteon.internal.driver;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.insteon.internal.device.InsteonAddress;\n+import org.openhab.binding.insteon.internal.message.Msg;\n+import org.openhab.binding.insteon.internal.utils.Utils;\n+\n+/**\n+ * The ModemDBEntry class holds a modem device type record\n+ * an xml file.\n+ *\n+ * @author Bernd Pfrommer - Initial contribution\n+ * @author Rob Nielsen - Port to OpenHAB 2 insteon binding\n+ */\n+@NonNullByDefault\n+public class ModemDBEntry {\n+    private @Nullable InsteonAddress m_address = null;\n+    private @Nullable Port m_port = null;\n+    private ArrayList<Msg> m_linkRecords = new ArrayList<Msg>();\n+    private ArrayList<Byte> m_controls = new ArrayList<Byte>();\n+    private ArrayList<Byte> m_respondsTo = new ArrayList<Byte>();\n+\n+    public ModemDBEntry(InsteonAddress aAddr) {\n+        m_address = aAddr;\n+    }\n+\n+    public ArrayList<Msg> getLinkRecords() {\n+        return m_linkRecords;\n+    }\n+\n+    public void addLinkRecord(Msg m) {\n+        m_linkRecords.add(m);\n+    }\n+\n+    public void addControls(byte c) {\n+        m_controls.add(c);\n+    }\n+\n+    public ArrayList<Byte> getControls() {\n+        return m_controls;\n+    }\n+\n+    public void addRespondsTo(byte r) {\n+        m_respondsTo.add(r);\n+    }\n+\n+    public ArrayList<Byte> getRespondsTo() {\n+        return m_respondsTo;\n+    }\n+\n+    public void setPort(Port p) {\n+        m_port = p;\n+    }\n+\n+    public @Nullable Port getPort() {\n+        return m_port;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        String s = \"addr:\" + m_address + \"|controls:[\" + toGroupString(m_controls) + \"]|responds_to:[\"\n+                + toGroupString(m_respondsTo) + \"]|link_recors\";\n+        for (Msg m : m_linkRecords) {\n+            s += \":(\" + m + \")\";\n+        }\n+        return s;\n+    }\n+\n+    private String toGroupString(ArrayList<Byte> group) {\n+        ArrayList<Byte> sorted = new ArrayList<Byte>(group);\n+        Collections.sort(sorted);\n+\n+        StringBuffer buf = new StringBuffer();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjcyMTM1Mg=="}, "originalCommit": {"oid": "ed93353c47fa5d457223c66d8f91b1c168a57e23"}, "originalPosition": 89}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzQ0Nzk0OA==", "bodyText": "missed this", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r387447948", "createdAt": "2020-03-04T04:52:10Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.insteon/src/main/java/org/openhab/binding/insteon/internal/InsteonBinding.java", "diffHunk": "@@ -0,0 +1,512 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.insteon.internal;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map.Entry;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import javax.xml.parsers.ParserConfigurationException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.insteon.internal.config.InsteonChannelConfiguration;\n+import org.openhab.binding.insteon.internal.config.InsteonNetworkConfiguration;\n+import org.openhab.binding.insteon.internal.device.DeviceFeature;\n+import org.openhab.binding.insteon.internal.device.DeviceFeatureListener;\n+import org.openhab.binding.insteon.internal.device.DeviceType;\n+import org.openhab.binding.insteon.internal.device.DeviceTypeLoader;\n+import org.openhab.binding.insteon.internal.device.InsteonAddress;\n+import org.openhab.binding.insteon.internal.device.InsteonDevice;\n+import org.openhab.binding.insteon.internal.device.InsteonDevice.DeviceStatus;\n+import org.openhab.binding.insteon.internal.device.RequestQueueManager;\n+import org.openhab.binding.insteon.internal.driver.Driver;\n+import org.openhab.binding.insteon.internal.driver.DriverListener;\n+import org.openhab.binding.insteon.internal.driver.ModemDBEntry;\n+import org.openhab.binding.insteon.internal.driver.Poller;\n+import org.openhab.binding.insteon.internal.handler.InsteonNetworkHandler;\n+import org.openhab.binding.insteon.internal.message.FieldException;\n+import org.openhab.binding.insteon.internal.message.Msg;\n+import org.openhab.binding.insteon.internal.message.MsgListener;\n+import org.openhab.binding.insteon.internal.utils.Utils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.xml.sax.SAXException;\n+\n+/**\n+ * A majority of the code in this file is from the OpenHAB 1 binding\n+ * org.openhab.binding.insteonplm.InsteonPLMActiveBinding. Including the comments below.\n+ *\n+ * -----------------------------------------------------------------------------------------------\n+ *\n+ * This class represents the actual implementation of the binding, and controls the high level flow\n+ * of messages to and from the InsteonModem.\n+ *\n+ * Writing this binding has been an odyssey through the quirks of the Insteon protocol\n+ * and Insteon devices. A substantial redesign was necessary at some point along the way.\n+ * Here are some of the hard learned lessons that should be considered by anyone who wants\n+ * to re-architect the binding:\n+ *\n+ * 1) The entries of the link database of the modem are not reliable. The category/subcategory entries in\n+ * particular have junk data. Forget about using the modem database to generate a list of devices.\n+ * The database should only be used to verify that a device has been linked.\n+ *\n+ * 2) Querying devices for their product information does not work either. First of all, battery operated devices\n+ * (and there are a lot of those) have their radio switched off, and may generally not respond to product\n+ * queries. Even main stream hardwired devices sold presently (like the 2477s switch and the 2477d dimmer)\n+ * don't even have a product ID. Although supposedly part of the Insteon protocol, we have yet to\n+ * encounter a device that would cough up a product id when queried, even among very recent devices. They\n+ * simply return zeros as product id. Lesson: forget about querying devices to generate a device list.\n+ *\n+ * 3) Polling is a thorny issue: too much traffic on the network, and messages will be dropped left and right,\n+ * and not just the poll related ones, but others as well. In particular sending back-to-back messages\n+ * seemed to result in the second message simply never getting sent, without flow control back pressure\n+ * (NACK) from the modem. For now the work-around is to space out the messages upon sending, and\n+ * in general poll as infrequently as acceptable.\n+ *\n+ * 4) Instantiating and tracking devices when reported by the modem (either from the database, or when\n+ * messages are received) leads to complicated state management because there is no guarantee at what\n+ * point (if at all) the binding configuration will be available. It gets even more difficult when\n+ * items are created, destroyed, and modified while the binding runs.\n+ *\n+ * For the above reasons, devices are only instantiated when they are referenced by binding information.\n+ * As nice as it would be to discover devices and their properties dynamically, we have abandoned that\n+ * path because it had led to a complicated and fragile system which due to the technical limitations\n+ * above was inherently squirrely.\n+ *\n+ *\n+ * @author Bernd Pfrommer - Initial contribution\n+ * @author Daniel Pfrommer - OpenHAB 1 insteonplm binding\n+ * @author Rob Nielsen - Port to OpenHAB 2 insteon binding\n+ */\n+@NonNullByDefault\n+public class InsteonBinding {\n+    private static final int DEAD_DEVICE_COUNT = 10;\n+\n+    private final Logger logger = LoggerFactory.getLogger(InsteonBinding.class);\n+\n+    private Driver m_driver = new Driver();\n+    private ConcurrentHashMap<InsteonAddress, InsteonDevice> m_devices = new ConcurrentHashMap<InsteonAddress, InsteonDevice>();\n+    private ConcurrentHashMap<String, InsteonChannelConfiguration> m_bindingConfigs = new ConcurrentHashMap<>();\n+    private PortListener m_portListener = new PortListener();\n+    private int m_devicePollIntervalMilliseconds = 300000;\n+    private int m_deadDeviceTimeout = -1;\n+    private int m_messagesReceived = 0;\n+    private boolean m_isActive = false; // state of binding\n+    private int m_x10HouseUnit = -1;\n+    private InsteonNetworkHandler m_handler;\n+\n+    public InsteonBinding(InsteonNetworkHandler handler, @Nullable InsteonNetworkConfiguration config) {\n+        this.m_handler = handler;\n+\n+        Integer devicePollIntervalSeconds = config.getDevicePollIntervalSeconds();\n+        if (devicePollIntervalSeconds != null) {\n+            m_devicePollIntervalMilliseconds = devicePollIntervalSeconds * 1000;\n+        }\n+        logger.info(\"device poll interval set to {} seconds\", m_devicePollIntervalMilliseconds / 1000);\n+\n+        Integer modemDbRetryTimeoutSeconds = config.getModemDbRetryTimeoutSeconds();\n+        if (modemDbRetryTimeoutSeconds != null) {\n+            logger.info(\"setting modem db retry timeout to {} seconds\", modemDbRetryTimeoutSeconds);\n+            m_driver.setModemDBRetryTimeout(modemDbRetryTimeoutSeconds * 1000);\n+        }\n+\n+        String additionalDevices = config.getAdditionalDevices();\n+        if (additionalDevices != null) {\n+            try {\n+                DeviceTypeLoader.s_instance().loadDeviceTypesXML(additionalDevices);\n+                logger.info(\"read additional device definitions from {}\", additionalDevices);\n+            } catch (ParserConfigurationException | SAXException | IOException e) {\n+                logger.warn(\"error reading additional devices from {}\", additionalDevices, e);\n+            }\n+        }\n+\n+        String additionalFeatures = config.getAdditionalFeatures();\n+        if (additionalFeatures != null) {\n+            logger.info(\"reading additional feature templates from {}\", additionalFeatures);\n+            DeviceFeature.s_readFeatureTemplates(additionalFeatures);\n+        }\n+\n+        m_deadDeviceTimeout = m_devicePollIntervalMilliseconds * DEAD_DEVICE_COUNT;\n+        logger.info(\"dead device timeout set to {} seconds\", m_deadDeviceTimeout / 1000);\n+\n+        String port = config.getPort();\n+        logger.info(\"port = '{}'\", port);\n+        m_driver.addPort(\"port\", port);\n+        m_driver.addMsgListener(m_portListener, port);\n+\n+        logger.debug(\"setting driver listener\");\n+        m_driver.setDriverListener(m_portListener);\n+    }\n+\n+    public boolean startPolling() {\n+        logger.debug(\"starting {} ports\", m_driver.getNumberOfPorts());\n+\n+        m_driver.startAllPorts();\n+        logger.debug(\"ports started\");\n+        switch (m_driver.getNumberOfPorts()) {\n+            case 0:\n+                logger.warn(\"initialization complete, but found no ports!\");\n+                return false;\n+            case 1:\n+                logger.debug(\"initialization complete, found 1 port!\");\n+                break;\n+            default:\n+                logger.warn(\"initialization complete, found {} ports.\", m_driver.getNumberOfPorts());\n+                break;\n+        }\n+\n+        return true;\n+    }\n+\n+    public void setIsActive(boolean isActive) {\n+        m_isActive = isActive;\n+    }\n+\n+    public void sendCommand(String channelName, Command command) {\n+        if (!m_isActive) {\n+            logger.debug(\"not ready to handle commands yet, returning.\");\n+            return;\n+        }\n+\n+        InsteonChannelConfiguration bindingConfig = m_bindingConfigs.get(channelName);\n+        if (bindingConfig == null) {\n+            logger.warn(\"unable to find binding config for channel {}\", channelName);\n+            return;\n+        }\n+\n+        InsteonDevice dev = getDevice(bindingConfig.getAddress());\n+        if (dev == null) {\n+            logger.warn(\"no device found with insteon address {}\", bindingConfig.getAddress());\n+            return;\n+        }\n+\n+        dev.processCommand(m_driver, bindingConfig, command);\n+\n+        logger.debug(\"found binding config for channel {}\", channelName);\n+    }\n+\n+    public void addFeatureListener(InsteonChannelConfiguration bindingConfig) {\n+        logger.debug(\"adding listener for channel {}\", bindingConfig.getChannelName());\n+\n+        InsteonAddress address = bindingConfig.getAddress();\n+        InsteonDevice dev = getDevice(address);\n+        @Nullable\n+        DeviceFeature f = dev.getFeature(bindingConfig.getFeature());\n+        if (f == null || f.isFeatureGroup()) {\n+            StringBuffer buf = new StringBuffer();\n+            ArrayList<String> names = new ArrayList<String>(dev.getFeatures().keySet());\n+            Collections.sort(names);\n+            for (String name : names) {\n+                DeviceFeature feature = dev.getFeature(name);\n+                if (!feature.isFeatureGroup()) {\n+                    if (buf.length() > 0) {\n+                        buf.append(\", \");\n+                    }\n+                    buf.append(name);\n+                }\n+            }\n+\n+            logger.warn(\"channel {} references unknown feature: {}, it will be ignored. Known features for {} are: {}.\",\n+                    bindingConfig.getChannelName(), bindingConfig.getFeature(), bindingConfig.getProductKey(),\n+                    buf.toString());\n+            return;\n+        }\n+\n+        DeviceFeatureListener fl = new DeviceFeatureListener(this, bindingConfig.getChannelUID(),\n+                bindingConfig.getChannelName());\n+        fl.setParameters(bindingConfig.getParameters());\n+        f.addListener(fl);\n+\n+        m_bindingConfigs.put(bindingConfig.getChannelName(), bindingConfig);\n+    }\n+\n+    public void removeFeatureListener(ChannelUID channelUID) {\n+        String channelName = channelUID.getAsString();\n+\n+        logger.debug(\"removing listener for channel {}\", channelName);\n+\n+        for (Iterator<Entry<InsteonAddress, InsteonDevice>> it = m_devices.entrySet().iterator(); it.hasNext();) {\n+            InsteonDevice dev = it.next().getValue();\n+            boolean removedListener = dev.removeFeatureListener(channelName);\n+            if (removedListener) {\n+                logger.trace(\"removed feature listener {} from dev {}\", channelName, dev);\n+            }\n+        }\n+    }\n+\n+    public void updateFeatureState(ChannelUID channelUID, State state) {\n+        m_handler.updateState(channelUID, state);\n+    }\n+\n+    public InsteonDevice makeNewDevice(InsteonAddress addr, String productKey) {\n+        DeviceType dt = DeviceTypeLoader.s_instance().getDeviceType(productKey);\n+        InsteonDevice dev = InsteonDevice.s_makeDevice(dt);\n+        dev.setAddress(addr);\n+        dev.setDriver(m_driver);\n+        dev.addPort(m_driver.getDefaultPort());\n+        if (!dev.hasValidPollingInterval()) {\n+            dev.setPollInterval(m_devicePollIntervalMilliseconds);\n+        }\n+        if (m_driver.isModemDBComplete() && dev.getStatus() != DeviceStatus.POLLING) {\n+            int ndev = checkIfInModemDatabase(dev);\n+            if (dev.hasModemDBEntry()) {\n+                dev.setStatus(DeviceStatus.POLLING);\n+                Poller.s_instance().startPolling(dev, ndev);\n+            }\n+        }\n+        m_devices.put(addr, dev);\n+\n+        m_handler.insteonDeviceWasCreated();\n+\n+        return (dev);\n+    }\n+\n+    public void removeDevice(InsteonAddress addr) {\n+        InsteonDevice dev = m_devices.remove(addr);\n+        if (dev == null) {\n+            return;\n+        }\n+\n+        if (dev.getStatus() == DeviceStatus.POLLING) {\n+            Poller.s_instance().stopPolling(dev);\n+        }\n+    }\n+\n+    /**\n+     * Checks if a device is in the modem link database, and, if the database\n+     * is complete, logs a warning if the device is not present\n+     *\n+     * @param dev The device to search for in the modem database\n+     * @return number of devices in modem database\n+     */\n+    private int checkIfInModemDatabase(InsteonDevice dev) {\n+        InsteonAddress addr = dev.getAddress();\n+        HashMap<InsteonAddress, @Nullable ModemDBEntry> dbes = m_driver.lockModemDBEntries();\n+        if (dbes.containsKey(addr)) {\n+            if (!dev.hasModemDBEntry()) {\n+                logger.info(\"device {} found in the modem database and {}.\", addr, getLinkInfo(dbes, addr));\n+                dev.setHasModemDBEntry(true);\n+            }\n+        } else {\n+            if (m_driver.isModemDBComplete() && !addr.isX10()) {\n+                logger.warn(\"device {} not found in the modem database. Did you forget to link?\", addr);\n+            }\n+        }\n+        int ndev = dbes.size();\n+        m_driver.unlockModemDBEntries();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjcxNTg2NA=="}, "originalCommit": {"oid": "ed93353c47fa5d457223c66d8f91b1c168a57e23"}, "originalPosition": 316}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzQ0ODE3OQ==", "bodyText": "missed this", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r387448179", "createdAt": "2020-03-04T04:53:06Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.insteon/src/main/java/org/openhab/binding/insteon/internal/InsteonBinding.java", "diffHunk": "@@ -0,0 +1,512 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.insteon.internal;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map.Entry;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import javax.xml.parsers.ParserConfigurationException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.insteon.internal.config.InsteonChannelConfiguration;\n+import org.openhab.binding.insteon.internal.config.InsteonNetworkConfiguration;\n+import org.openhab.binding.insteon.internal.device.DeviceFeature;\n+import org.openhab.binding.insteon.internal.device.DeviceFeatureListener;\n+import org.openhab.binding.insteon.internal.device.DeviceType;\n+import org.openhab.binding.insteon.internal.device.DeviceTypeLoader;\n+import org.openhab.binding.insteon.internal.device.InsteonAddress;\n+import org.openhab.binding.insteon.internal.device.InsteonDevice;\n+import org.openhab.binding.insteon.internal.device.InsteonDevice.DeviceStatus;\n+import org.openhab.binding.insteon.internal.device.RequestQueueManager;\n+import org.openhab.binding.insteon.internal.driver.Driver;\n+import org.openhab.binding.insteon.internal.driver.DriverListener;\n+import org.openhab.binding.insteon.internal.driver.ModemDBEntry;\n+import org.openhab.binding.insteon.internal.driver.Poller;\n+import org.openhab.binding.insteon.internal.handler.InsteonNetworkHandler;\n+import org.openhab.binding.insteon.internal.message.FieldException;\n+import org.openhab.binding.insteon.internal.message.Msg;\n+import org.openhab.binding.insteon.internal.message.MsgListener;\n+import org.openhab.binding.insteon.internal.utils.Utils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.xml.sax.SAXException;\n+\n+/**\n+ * A majority of the code in this file is from the OpenHAB 1 binding\n+ * org.openhab.binding.insteonplm.InsteonPLMActiveBinding. Including the comments below.\n+ *\n+ * -----------------------------------------------------------------------------------------------\n+ *\n+ * This class represents the actual implementation of the binding, and controls the high level flow\n+ * of messages to and from the InsteonModem.\n+ *\n+ * Writing this binding has been an odyssey through the quirks of the Insteon protocol\n+ * and Insteon devices. A substantial redesign was necessary at some point along the way.\n+ * Here are some of the hard learned lessons that should be considered by anyone who wants\n+ * to re-architect the binding:\n+ *\n+ * 1) The entries of the link database of the modem are not reliable. The category/subcategory entries in\n+ * particular have junk data. Forget about using the modem database to generate a list of devices.\n+ * The database should only be used to verify that a device has been linked.\n+ *\n+ * 2) Querying devices for their product information does not work either. First of all, battery operated devices\n+ * (and there are a lot of those) have their radio switched off, and may generally not respond to product\n+ * queries. Even main stream hardwired devices sold presently (like the 2477s switch and the 2477d dimmer)\n+ * don't even have a product ID. Although supposedly part of the Insteon protocol, we have yet to\n+ * encounter a device that would cough up a product id when queried, even among very recent devices. They\n+ * simply return zeros as product id. Lesson: forget about querying devices to generate a device list.\n+ *\n+ * 3) Polling is a thorny issue: too much traffic on the network, and messages will be dropped left and right,\n+ * and not just the poll related ones, but others as well. In particular sending back-to-back messages\n+ * seemed to result in the second message simply never getting sent, without flow control back pressure\n+ * (NACK) from the modem. For now the work-around is to space out the messages upon sending, and\n+ * in general poll as infrequently as acceptable.\n+ *\n+ * 4) Instantiating and tracking devices when reported by the modem (either from the database, or when\n+ * messages are received) leads to complicated state management because there is no guarantee at what\n+ * point (if at all) the binding configuration will be available. It gets even more difficult when\n+ * items are created, destroyed, and modified while the binding runs.\n+ *\n+ * For the above reasons, devices are only instantiated when they are referenced by binding information.\n+ * As nice as it would be to discover devices and their properties dynamically, we have abandoned that\n+ * path because it had led to a complicated and fragile system which due to the technical limitations\n+ * above was inherently squirrely.\n+ *\n+ *\n+ * @author Bernd Pfrommer - Initial contribution\n+ * @author Daniel Pfrommer - OpenHAB 1 insteonplm binding\n+ * @author Rob Nielsen - Port to OpenHAB 2 insteon binding\n+ */\n+@NonNullByDefault\n+public class InsteonBinding {\n+    private static final int DEAD_DEVICE_COUNT = 10;\n+\n+    private final Logger logger = LoggerFactory.getLogger(InsteonBinding.class);\n+\n+    private Driver m_driver = new Driver();\n+    private ConcurrentHashMap<InsteonAddress, InsteonDevice> m_devices = new ConcurrentHashMap<InsteonAddress, InsteonDevice>();\n+    private ConcurrentHashMap<String, InsteonChannelConfiguration> m_bindingConfigs = new ConcurrentHashMap<>();\n+    private PortListener m_portListener = new PortListener();\n+    private int m_devicePollIntervalMilliseconds = 300000;\n+    private int m_deadDeviceTimeout = -1;\n+    private int m_messagesReceived = 0;\n+    private boolean m_isActive = false; // state of binding\n+    private int m_x10HouseUnit = -1;\n+    private InsteonNetworkHandler m_handler;\n+\n+    public InsteonBinding(InsteonNetworkHandler handler, @Nullable InsteonNetworkConfiguration config) {\n+        this.m_handler = handler;\n+\n+        Integer devicePollIntervalSeconds = config.getDevicePollIntervalSeconds();\n+        if (devicePollIntervalSeconds != null) {\n+            m_devicePollIntervalMilliseconds = devicePollIntervalSeconds * 1000;\n+        }\n+        logger.info(\"device poll interval set to {} seconds\", m_devicePollIntervalMilliseconds / 1000);\n+\n+        Integer modemDbRetryTimeoutSeconds = config.getModemDbRetryTimeoutSeconds();\n+        if (modemDbRetryTimeoutSeconds != null) {\n+            logger.info(\"setting modem db retry timeout to {} seconds\", modemDbRetryTimeoutSeconds);\n+            m_driver.setModemDBRetryTimeout(modemDbRetryTimeoutSeconds * 1000);\n+        }\n+\n+        String additionalDevices = config.getAdditionalDevices();\n+        if (additionalDevices != null) {\n+            try {\n+                DeviceTypeLoader.s_instance().loadDeviceTypesXML(additionalDevices);\n+                logger.info(\"read additional device definitions from {}\", additionalDevices);\n+            } catch (ParserConfigurationException | SAXException | IOException e) {\n+                logger.warn(\"error reading additional devices from {}\", additionalDevices, e);\n+            }\n+        }\n+\n+        String additionalFeatures = config.getAdditionalFeatures();\n+        if (additionalFeatures != null) {\n+            logger.info(\"reading additional feature templates from {}\", additionalFeatures);\n+            DeviceFeature.s_readFeatureTemplates(additionalFeatures);\n+        }\n+\n+        m_deadDeviceTimeout = m_devicePollIntervalMilliseconds * DEAD_DEVICE_COUNT;\n+        logger.info(\"dead device timeout set to {} seconds\", m_deadDeviceTimeout / 1000);\n+\n+        String port = config.getPort();\n+        logger.info(\"port = '{}'\", port);\n+        m_driver.addPort(\"port\", port);\n+        m_driver.addMsgListener(m_portListener, port);\n+\n+        logger.debug(\"setting driver listener\");\n+        m_driver.setDriverListener(m_portListener);\n+    }\n+\n+    public boolean startPolling() {\n+        logger.debug(\"starting {} ports\", m_driver.getNumberOfPorts());\n+\n+        m_driver.startAllPorts();\n+        logger.debug(\"ports started\");\n+        switch (m_driver.getNumberOfPorts()) {\n+            case 0:\n+                logger.warn(\"initialization complete, but found no ports!\");\n+                return false;\n+            case 1:\n+                logger.debug(\"initialization complete, found 1 port!\");\n+                break;\n+            default:\n+                logger.warn(\"initialization complete, found {} ports.\", m_driver.getNumberOfPorts());\n+                break;\n+        }\n+\n+        return true;\n+    }\n+\n+    public void setIsActive(boolean isActive) {\n+        m_isActive = isActive;\n+    }\n+\n+    public void sendCommand(String channelName, Command command) {\n+        if (!m_isActive) {\n+            logger.debug(\"not ready to handle commands yet, returning.\");\n+            return;\n+        }\n+\n+        InsteonChannelConfiguration bindingConfig = m_bindingConfigs.get(channelName);\n+        if (bindingConfig == null) {\n+            logger.warn(\"unable to find binding config for channel {}\", channelName);\n+            return;\n+        }\n+\n+        InsteonDevice dev = getDevice(bindingConfig.getAddress());\n+        if (dev == null) {\n+            logger.warn(\"no device found with insteon address {}\", bindingConfig.getAddress());\n+            return;\n+        }\n+\n+        dev.processCommand(m_driver, bindingConfig, command);\n+\n+        logger.debug(\"found binding config for channel {}\", channelName);\n+    }\n+\n+    public void addFeatureListener(InsteonChannelConfiguration bindingConfig) {\n+        logger.debug(\"adding listener for channel {}\", bindingConfig.getChannelName());\n+\n+        InsteonAddress address = bindingConfig.getAddress();\n+        InsteonDevice dev = getDevice(address);\n+        @Nullable\n+        DeviceFeature f = dev.getFeature(bindingConfig.getFeature());\n+        if (f == null || f.isFeatureGroup()) {\n+            StringBuffer buf = new StringBuffer();\n+            ArrayList<String> names = new ArrayList<String>(dev.getFeatures().keySet());\n+            Collections.sort(names);\n+            for (String name : names) {\n+                DeviceFeature feature = dev.getFeature(name);\n+                if (!feature.isFeatureGroup()) {\n+                    if (buf.length() > 0) {\n+                        buf.append(\", \");\n+                    }\n+                    buf.append(name);\n+                }\n+            }\n+\n+            logger.warn(\"channel {} references unknown feature: {}, it will be ignored. Known features for {} are: {}.\",\n+                    bindingConfig.getChannelName(), bindingConfig.getFeature(), bindingConfig.getProductKey(),\n+                    buf.toString());\n+            return;\n+        }\n+\n+        DeviceFeatureListener fl = new DeviceFeatureListener(this, bindingConfig.getChannelUID(),\n+                bindingConfig.getChannelName());\n+        fl.setParameters(bindingConfig.getParameters());\n+        f.addListener(fl);\n+\n+        m_bindingConfigs.put(bindingConfig.getChannelName(), bindingConfig);\n+    }\n+\n+    public void removeFeatureListener(ChannelUID channelUID) {\n+        String channelName = channelUID.getAsString();\n+\n+        logger.debug(\"removing listener for channel {}\", channelName);\n+\n+        for (Iterator<Entry<InsteonAddress, InsteonDevice>> it = m_devices.entrySet().iterator(); it.hasNext();) {\n+            InsteonDevice dev = it.next().getValue();\n+            boolean removedListener = dev.removeFeatureListener(channelName);\n+            if (removedListener) {\n+                logger.trace(\"removed feature listener {} from dev {}\", channelName, dev);\n+            }\n+        }\n+    }\n+\n+    public void updateFeatureState(ChannelUID channelUID, State state) {\n+        m_handler.updateState(channelUID, state);\n+    }\n+\n+    public InsteonDevice makeNewDevice(InsteonAddress addr, String productKey) {\n+        DeviceType dt = DeviceTypeLoader.s_instance().getDeviceType(productKey);\n+        InsteonDevice dev = InsteonDevice.s_makeDevice(dt);\n+        dev.setAddress(addr);\n+        dev.setDriver(m_driver);\n+        dev.addPort(m_driver.getDefaultPort());\n+        if (!dev.hasValidPollingInterval()) {\n+            dev.setPollInterval(m_devicePollIntervalMilliseconds);\n+        }\n+        if (m_driver.isModemDBComplete() && dev.getStatus() != DeviceStatus.POLLING) {\n+            int ndev = checkIfInModemDatabase(dev);\n+            if (dev.hasModemDBEntry()) {\n+                dev.setStatus(DeviceStatus.POLLING);\n+                Poller.s_instance().startPolling(dev, ndev);\n+            }\n+        }\n+        m_devices.put(addr, dev);\n+\n+        m_handler.insteonDeviceWasCreated();\n+\n+        return (dev);\n+    }\n+\n+    public void removeDevice(InsteonAddress addr) {\n+        InsteonDevice dev = m_devices.remove(addr);\n+        if (dev == null) {\n+            return;\n+        }\n+\n+        if (dev.getStatus() == DeviceStatus.POLLING) {\n+            Poller.s_instance().stopPolling(dev);\n+        }\n+    }\n+\n+    /**\n+     * Checks if a device is in the modem link database, and, if the database\n+     * is complete, logs a warning if the device is not present\n+     *\n+     * @param dev The device to search for in the modem database\n+     * @return number of devices in modem database\n+     */\n+    private int checkIfInModemDatabase(InsteonDevice dev) {\n+        InsteonAddress addr = dev.getAddress();\n+        HashMap<InsteonAddress, @Nullable ModemDBEntry> dbes = m_driver.lockModemDBEntries();\n+        if (dbes.containsKey(addr)) {\n+            if (!dev.hasModemDBEntry()) {\n+                logger.info(\"device {} found in the modem database and {}.\", addr, getLinkInfo(dbes, addr));\n+                dev.setHasModemDBEntry(true);\n+            }\n+        } else {\n+            if (m_driver.isModemDBComplete() && !addr.isX10()) {\n+                logger.warn(\"device {} not found in the modem database. Did you forget to link?\", addr);\n+            }\n+        }\n+        int ndev = dbes.size();\n+        m_driver.unlockModemDBEntries();\n+        return ndev;\n+    }\n+\n+    /**\n+     * Everything below was copied from Insteon PLM v1\n+     */\n+\n+    /**\n+     * Clean up all state.\n+     */\n+    public void shutdown() {\n+        logger.debug(\"shutting down Insteon bridge\");\n+        m_driver.stopAllPorts();\n+        m_devices.clear();\n+        RequestQueueManager.s_destroyInstance();\n+        Poller.s_instance().stop();\n+        m_isActive = false;\n+    }\n+\n+    /**\n+     * Method to find a device by address\n+     *\n+     * @param aAddr the insteon address to search for\n+     * @return reference to the device, or null if not found\n+     */\n+    public @Nullable InsteonDevice getDevice(@Nullable InsteonAddress aAddr) {\n+        InsteonDevice dev = (aAddr == null) ? null : m_devices.get(aAddr);\n+        return (dev);\n+    }\n+\n+    private String getLinkInfo(HashMap<InsteonAddress, @Nullable ModemDBEntry> dbes, InsteonAddress a) {\n+        ModemDBEntry dbe = dbes.get(a);\n+        ArrayList<Byte> controls = dbe.getControls();\n+        ArrayList<Byte> responds = dbe.getRespondsTo();\n+\n+        StringBuffer buf = new StringBuffer(\"the modem\");\n+        if (!controls.isEmpty()) {\n+            buf.append(\" controls groups [\");\n+            buf.append(toGroupString(controls));\n+            buf.append(\"]\");\n+        }\n+\n+        if (!responds.isEmpty()) {\n+            if (!controls.isEmpty()) {\n+                buf.append(\" and\");\n+            }\n+\n+            buf.append(\" responds to groups [\");\n+            buf.append(toGroupString(responds));\n+            buf.append(\"]\");\n+        }\n+\n+        return buf.toString();\n+    }\n+\n+    private String toGroupString(ArrayList<Byte> group) {\n+        ArrayList<Byte> sorted = new ArrayList<Byte>(group);\n+        Collections.sort(sorted);\n+\n+        StringBuffer buf = new StringBuffer();\n+        for (Byte b : sorted) {\n+            if (buf.length() > 0) {\n+                buf.append(\",\");\n+            }\n+            buf.append(\"0x\");\n+            buf.append(Utils.getHexString(b));\n+        }\n+\n+        return buf.toString();\n+    }\n+\n+    public void logDeviceStatistics() {\n+        String msg = String.format(\"devices: %3d configured, %3d polling, msgs received: %5d\", m_devices.size(),\n+                Poller.s_instance().getSizeOfQueue(), m_messagesReceived);\n+        logger.info(\"{}\", msg);\n+        m_messagesReceived = 0;\n+        for (InsteonDevice dev : m_devices.values()) {\n+            if (dev.isModem()) {\n+                continue;\n+            }\n+            if (m_deadDeviceTimeout > 0 && dev.getPollOverDueTime() > m_deadDeviceTimeout) {\n+                logger.info(\"device {} has not responded to polls for {} sec\", dev.toString(),\n+                        dev.getPollOverDueTime() / 3600);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Handles messages that come in from the ports.\n+     * Will only process one message at a time.\n+     */\n+    @NonNullByDefault\n+    private class PortListener implements MsgListener, DriverListener {\n+        @Override\n+        public void msg(Msg msg, String fromPort) {\n+            if (msg.isEcho() || msg.isPureNack()) {\n+                return;\n+            }\n+            m_messagesReceived++;\n+            logger.debug(\"got msg: {}\", msg);\n+            if (msg.isX10()) {\n+                handleX10Message(msg, fromPort);\n+            } else {\n+                handleInsteonMessage(msg, fromPort);\n+            }\n+\n+        }\n+\n+        @Override\n+        public void driverCompletelyInitialized() {\n+            HashMap<InsteonAddress, @Nullable ModemDBEntry> dbes = m_driver.lockModemDBEntries();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjcxNjAxNQ=="}, "originalCommit": {"oid": "ed93353c47fa5d457223c66d8f91b1c168a57e23"}, "originalPosition": 427}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzcwNjQ3MTkw", "url": "https://github.com/openhab/openhab-addons/pull/6911#pullrequestreview-370647190", "createdAt": "2020-03-06T21:48:03Z", "commit": {"oid": "94f7f27e5dc60b3961fd689b57f8c0c54fd764b7"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNlQyMTo0ODowM1rOFzIeaA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNlQyMTo0ODowM1rOFzIeaA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTE2MDU1Mg==", "bodyText": "Could you please do a bulk search+replace to fix the spelling of \"OpenHAB\" to the correct \"openHAB\"? Thanks!", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r389160552", "createdAt": "2020-03-06T21:48:03Z", "author": {"login": "kaikreuzer"}, "path": "bundles/org.openhab.binding.insteon/src/main/java/org/openhab/binding/insteon/internal/device/DeviceFeatureListener.java", "diffHunk": "@@ -0,0 +1,190 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.insteon.internal.device;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.insteon.internal.InsteonBinding;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * A DeviceFeatureListener essentially represents an OpenHAB item that\n+ * listens to a particular feature of an Insteon device\n+ *\n+ * @author Daniel Pfrommer - Initial contribution\n+ * @author Bernd Pfrommer - OpenHAB 1 insteonplm binding", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "94f7f27e5dc60b3961fd689b57f8c0c54fd764b7"}, "originalPosition": 33}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzcwNzkyMDY4", "url": "https://github.com/openhab/openhab-addons/pull/6911#pullrequestreview-370792068", "createdAt": "2020-03-07T22:18:08Z", "commit": {"oid": "04a9796d14dfbc5f3ff997d872f04b6d03ee411d"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 42, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wN1QyMjoxODowOVrOFzR-vw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wN1QyMzowMzoxMFrOFzSICA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTMxNjI4Nw==", "bodyText": "Please add a line break after every sentence. It won't make any difference on the rendering, but makes it easier to diff future changes.", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r389316287", "createdAt": "2020-03-07T22:18:09Z", "author": {"login": "kaikreuzer"}, "path": "bundles/org.openhab.binding.insteon/README.md", "diffHunk": "@@ -0,0 +1,719 @@\n+# Insteon Binding\n+\n+Insteon is a home area networking technology developed primarily for connecting light switches and loads. Insteon devices send messages either via the power line, or by means of radio frequency (RF) waves, or both (dual-band). A considerable number of Insteon compatible devices such as switchable relays, thermostats, sensors etc are available. More about Insteon can be found on [Wikipedia](http://en.wikipedia.org/wiki/Insteon).", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "04a9796d14dfbc5f3ff997d872f04b6d03ee411d"}, "originalPosition": 3}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTMxNjQ2Nw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            The binding will automatically add the network bridge called local to the Paper UI inbox. Upon proper configuration of the network bridge, the network device database will be downloaded. Any Insteon device that exists in the database and is not currently configured will get added to the inbox.  The naming convention is **Insteon Device AABBCC**, where AA, BB and CC are from the Insteon device address.  X10 devices are not auto discovered. \n          \n          \n            \n            The binding automatically adds the network bridge called `local` to the inbox.\n          \n          \n            \n            Upon proper configuration of the network bridge, the network device database is downloaded.\n          \n          \n            \n            Any Insteon device that exists in the database and is not currently configured is added to the inbox.\n          \n          \n            \n            The naming convention is **Insteon Device AABBCC**, where AA, BB and CC are from the Insteon device address.\n          \n          \n            \n            X10 devices are not auto discovered.", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r389316467", "createdAt": "2020-03-07T22:21:19Z", "author": {"login": "kaikreuzer"}, "path": "bundles/org.openhab.binding.insteon/README.md", "diffHunk": "@@ -0,0 +1,719 @@\n+# Insteon Binding\n+\n+Insteon is a home area networking technology developed primarily for connecting light switches and loads. Insteon devices send messages either via the power line, or by means of radio frequency (RF) waves, or both (dual-band). A considerable number of Insteon compatible devices such as switchable relays, thermostats, sensors etc are available. More about Insteon can be found on [Wikipedia](http://en.wikipedia.org/wiki/Insteon).\n+\n+This binding provides access to the Insteon network by means of either an Insteon PowerLinc Modem (PLM), a legacy Insteon Hub 2242-222 or the current 2245-222 Insteon Hub. The modem can be connected to the openHAB server either via a serial port (Model 2413S) or a USB port (Model 2413U). The Insteon PowerLinc Controller (Model 2414U) is not supported since it is a PLC not a PLM. The modem can also be connected via TCP (such as ser2net).  The binding translates openHAB commands into Insteon messages and sends them on the Insteon network. Relevant messages from the Insteon network (like notifications about switches being toggled) are picked up by the modem and converted to openHAB status updates by the binding. The binding also supports sending and receiving of legacy X10 messages.\n+\n+The binding does not support linking new devices on the fly, i.e. all devices must be linked with the modem *before* starting the Insteon binding.\n+\n+openHAB is not a configuration tool! To configure and set up your devices, link the devices manually via the set buttons, or use the free [Insteon Terminal](https://github.com/pfrommerd/insteon-terminal) software. The free HouseLinc software from Insteon can also be used for configuration, but it wipes the modem link database clean on its initial use, requiring to re-link the modem to all devices.\n+\n+## Supported Things\n+\n+| Thing  | Type   | Description                  |\n+|----------|--------|------------------------------|\n+| network  | Bridge | An insteon PLM or hub that is used to communicate with the Insteon devices |\n+|device| Thing | Insteon devices such as dimmers, keypads, sensors, etc. |\n+\n+## Discovery\n+\n+The binding will automatically add the network bridge called local to the Paper UI inbox. Upon proper configuration of the network bridge, the network device database will be downloaded. Any Insteon device that exists in the database and is not currently configured will get added to the inbox.  The naming convention is **Insteon Device AABBCC**, where AA, BB and CC are from the Insteon device address.  X10 devices are not auto discovered. ", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "04a9796d14dfbc5f3ff997d872f04b6d03ee411d"}, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTMxNjUzMA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            The Insteon PLM or hub is configured with the following:\n          \n          \n            \n            The Insteon PLM or hub is configured with the following parameters:", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r389316530", "createdAt": "2020-03-07T22:22:38Z", "author": {"login": "kaikreuzer"}, "path": "bundles/org.openhab.binding.insteon/README.md", "diffHunk": "@@ -0,0 +1,719 @@\n+# Insteon Binding\n+\n+Insteon is a home area networking technology developed primarily for connecting light switches and loads. Insteon devices send messages either via the power line, or by means of radio frequency (RF) waves, or both (dual-band). A considerable number of Insteon compatible devices such as switchable relays, thermostats, sensors etc are available. More about Insteon can be found on [Wikipedia](http://en.wikipedia.org/wiki/Insteon).\n+\n+This binding provides access to the Insteon network by means of either an Insteon PowerLinc Modem (PLM), a legacy Insteon Hub 2242-222 or the current 2245-222 Insteon Hub. The modem can be connected to the openHAB server either via a serial port (Model 2413S) or a USB port (Model 2413U). The Insteon PowerLinc Controller (Model 2414U) is not supported since it is a PLC not a PLM. The modem can also be connected via TCP (such as ser2net).  The binding translates openHAB commands into Insteon messages and sends them on the Insteon network. Relevant messages from the Insteon network (like notifications about switches being toggled) are picked up by the modem and converted to openHAB status updates by the binding. The binding also supports sending and receiving of legacy X10 messages.\n+\n+The binding does not support linking new devices on the fly, i.e. all devices must be linked with the modem *before* starting the Insteon binding.\n+\n+openHAB is not a configuration tool! To configure and set up your devices, link the devices manually via the set buttons, or use the free [Insteon Terminal](https://github.com/pfrommerd/insteon-terminal) software. The free HouseLinc software from Insteon can also be used for configuration, but it wipes the modem link database clean on its initial use, requiring to re-link the modem to all devices.\n+\n+## Supported Things\n+\n+| Thing  | Type   | Description                  |\n+|----------|--------|------------------------------|\n+| network  | Bridge | An insteon PLM or hub that is used to communicate with the Insteon devices |\n+|device| Thing | Insteon devices such as dimmers, keypads, sensors, etc. |\n+\n+## Discovery\n+\n+The binding will automatically add the network bridge called local to the Paper UI inbox. Upon proper configuration of the network bridge, the network device database will be downloaded. Any Insteon device that exists in the database and is not currently configured will get added to the inbox.  The naming convention is **Insteon Device AABBCC**, where AA, BB and CC are from the Insteon device address.  X10 devices are not auto discovered. \n+\n+## Thing Configuration\n+\n+###### Network Configuration\n+\n+The Insteon PLM or hub is configured with the following:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "04a9796d14dfbc5f3ff997d872f04b6d03ee411d"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTMxNjYyOQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            Below is the list of possible channels for the Insteon devices. In order to determing which channels a device supports, you can either look at the device in Paper UI, or find it in the openhab log file.\n          \n          \n            \n            Below is the list of possible channels for the Insteon devices.\n          \n          \n            \n            In order to determing which channels a device supports, you can either look at the device in the UI, or find it in the openhab log file.", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r389316629", "createdAt": "2020-03-07T22:23:43Z", "author": {"login": "kaikreuzer"}, "path": "bundles/org.openhab.binding.insteon/README.md", "diffHunk": "@@ -0,0 +1,719 @@\n+# Insteon Binding\n+\n+Insteon is a home area networking technology developed primarily for connecting light switches and loads. Insteon devices send messages either via the power line, or by means of radio frequency (RF) waves, or both (dual-band). A considerable number of Insteon compatible devices such as switchable relays, thermostats, sensors etc are available. More about Insteon can be found on [Wikipedia](http://en.wikipedia.org/wiki/Insteon).\n+\n+This binding provides access to the Insteon network by means of either an Insteon PowerLinc Modem (PLM), a legacy Insteon Hub 2242-222 or the current 2245-222 Insteon Hub. The modem can be connected to the openHAB server either via a serial port (Model 2413S) or a USB port (Model 2413U). The Insteon PowerLinc Controller (Model 2414U) is not supported since it is a PLC not a PLM. The modem can also be connected via TCP (such as ser2net).  The binding translates openHAB commands into Insteon messages and sends them on the Insteon network. Relevant messages from the Insteon network (like notifications about switches being toggled) are picked up by the modem and converted to openHAB status updates by the binding. The binding also supports sending and receiving of legacy X10 messages.\n+\n+The binding does not support linking new devices on the fly, i.e. all devices must be linked with the modem *before* starting the Insteon binding.\n+\n+openHAB is not a configuration tool! To configure and set up your devices, link the devices manually via the set buttons, or use the free [Insteon Terminal](https://github.com/pfrommerd/insteon-terminal) software. The free HouseLinc software from Insteon can also be used for configuration, but it wipes the modem link database clean on its initial use, requiring to re-link the modem to all devices.\n+\n+## Supported Things\n+\n+| Thing  | Type   | Description                  |\n+|----------|--------|------------------------------|\n+| network  | Bridge | An insteon PLM or hub that is used to communicate with the Insteon devices |\n+|device| Thing | Insteon devices such as dimmers, keypads, sensors, etc. |\n+\n+## Discovery\n+\n+The binding will automatically add the network bridge called local to the Paper UI inbox. Upon proper configuration of the network bridge, the network device database will be downloaded. Any Insteon device that exists in the database and is not currently configured will get added to the inbox.  The naming convention is **Insteon Device AABBCC**, where AA, BB and CC are from the Insteon device address.  X10 devices are not auto discovered. \n+\n+## Thing Configuration\n+\n+###### Network Configuration\n+\n+The Insteon PLM or hub is configured with the following:\n+\n+| Parameter | Default | Required | Description |\n+|----------|---------:|--------:|-------------|\n+| port   |         |   Yes    | **Examples:**<br>- PLM on  Linux: `/dev/ttyS0` or `/dev/ttyUSB0`<br>- Smartenit ZBPLM on Linux: `/dev/ttyUSB0,baudRate=115200`<br>- PLM on Windows: `COM1`<br>- Current  hub (2245-222) at 192.168.1.100 on port 25105, with a poll interval of 1000 ms (1 second): `/hub2/my_user_name:my_password@192.168.1.100:25105,poll_time=1000`<br>- Legacy hub (2242-222) at 192.168.1.100 on port 9761:`/hub/192.168.1.100:9761`<br>- Networked PLM using ser2net at 192.168.1.100 on port 9761:`/tcp/192.168.1.100:9761` |\n+| devicePollIntervalSeconds | 300 |  No  | Poll interval of devices in seconds. Poll too often and you will overload the insteon network, leading to sluggish or no response when trying to send messages to devices. The default poll interval of 300 seconds has been tested and found to be a good compromise in a configuration of about 110 switches/dimmers. |\n+|modemDbRetryTimeoutSeconds|120|No|The number of seconds to wait for the modem database to completely download before retrying again.  Under normal circumstances this will not need to be modified.|\n+| additionalDevices | |       No     | Optional file with additional device types. The syntax of the file is identical to the `device_types.xml` file in the source tree. Please remember to post successfully added device types to the openhab group so the developers can include them into the `device_types.xml` file! |\n+| additionalFeatures | |      No     | Optional file with additional feature templates, like in the `device_features.xml` file in the source tree. |\n+\n+>NOTE: For users upgrading from InsteonPLM, The parameter port_1 is now port. \n+\n+###### Device Configuration\n+\n+The Insteon device is configured with the following required parameters:\n+\n+| Parameter | Description |\n+|----------|-------------|\n+|address|Insteon or X10 address of the device. Insteon device addresses are in the format 'xx.xx.xx', and can be found on the device. X10 device address are in the format 'x.y' and are typically configured on the device.|\n+|productKey|Insteon binding product key that is used to identy the device. Every Insteon device type is uniquely identified by its Insteon product key, typically a six digit hex number. For some of the older device types (in particular the SwitchLinc switches and dimmers), Insteon does not give a product key, so an arbitrary fake one of the format Fxx.xx.xx (or Xxx.xx.xx for X10 devices) is assigned by the binding.|\n+\n+The following is a list of the product keys and associated devices. These have been tested and should work out of the box:\n+\n+| Model | Description | Product Key | tested by |\n+|-------|-------------|-------------|-----------|\n+| 2477D | SwitchLinc Dimmer | F00.00.01 | Bernd Pfrommer |\n+| 2477S | SwitchLinc Switch | F00.00.02 | Bernd Pfrommer |\n+| 2845-222 | Hidden Door Sensor | F00.00.03 | Josenivaldo Benito |\n+| 2876S | ICON Switch | F00.00.04 | Patrick Giasson |\n+| 2456D3 | LampLinc V2 | F00.00.05 | Patrick Giasson |\n+| 2442-222 | Micro Dimmer | F00.00.06 | Josenivaldo Benito |\n+| 2453-222 | DIN Rail On/Off | F00.00.07 | Josenivaldo Benito |\n+| 2452-222 | DIN Rail Dimmer | F00.00.08 | Josenivaldo Benito |\n+| 2458-A1 | MorningLinc RF Lock Controller | F00.00.09 | cdeadlock |\n+| 2852-222 | Leak Sensor | F00.00.0A | Kirk McCann |\n+| 2672-422 | LED Dimmer | F00.00.0B | ??? |\n+| 2476D | SwitchLinc Dimmer | F00.00.0C | LiberatorUSA |\n+| 2634-222 | On/Off Dual-Band Outdoor Module | F00.00.0D | LiberatorUSA |\n+| 2342-2 | Mini Remote | F00.00.10 | Bernd Pfrommer |\n+| 2663-222 | On/Off Outlet | 0x000039 | SwissKid |\n+| 2466D | ToggleLinc Dimmer | F00.00.11 | Rob Nielsen |\n+| 2466S | ToggleLinc Switch | F00.00.12 | Rob Nielsen |\n+| 2672-222 | LED Bulb | F00.00.13 | Rob Nielsen |\n+| 2487S | KeypadLinc On/Off 6-Button | F00.00.14 | Bernd Pfrommer |\n+| 2334-232 | KeypadLink Dimmer 6-Button | F00.00.15 | Rob Nielsen |\n+| 2334-232 | KeypadLink Dimmer 8-Button | F00.00.16 | Rob Nielsen |\n+| 2423A1 | iMeter Solo Power Meter | F00.00.17 | Rob Nielsen |\n+| 2423A1 | Thermostat 2441TH | F00.00.18 | Daniel Campbell, Bernd Pfrommer |\n+| 2457D2 | LampLinc Dimmer | F00.00.19 | Jonathan Huizingh |\n+| 2475SDB | In-LineLinc Relay | F00.00.1A | Jim Howard |\n+| 2635-222 | On/Off Module | F00.00.1B | Jonathan Huizingh |\n+| 2475F | FanLinc Module | F00.00.1C | Brian Tillman |\n+| 2456S3 | ApplianceLinc | F00.00.1D | ??? |\n+| 2674-222 | LED Bulb (recessed) | F00.00.1E | Steve Bate |\n+| 2477SA1 | 220V 30-amp Load Controller N/O | F00.00.1F | Shawn R. |\n+| 2342-222 | Mini Remote (8 Button) | F00.00.20 | Bernd Pfrommer |\n+| 2441V | Insteon Thermostat Adaptor for Venstar | F00.00.21 | Bernd Pfrommer |\n+| 2982-222 | Insteon Smoke Bridge | F00.00.22 | Bernd Pfrommer |\n+| 2450 | IO Link | 0x00001A | Bernd Pfrommer |\n+| 2486D | KeypadLinc Dimmer | 0x000037 | Patrick Giasson, Joe Barnum |\n+| 2484DWH8 | KeypadLinc Countdown Timer | 0x000041 | Rob Nielsen |\n+| 2413U | PowerLinc 2413U USB modem | 0x000045 | Bernd Pfrommer |\n+| 2843-222 | Wireless Open/Close Sensor | 0x000049 | Josenivaldo Benito |\n+| 2842-222 | Motion Sensor | 0x00004A | Bernd Pfrommer |\n+| 2486DWH8 | KeypadLinc Dimmer | 0x000051 | Chris Graham |\n+| 2472D | OutletLincDimmer | 0x000068 | Chris Graham |\n+| X10 switch | generic X10 switch | X00.00.01 | Bernd Pfrommer |\n+| X10 dimmer | generic X10 dimmer | X00.00.02 | Bernd Pfrommer |\n+| X10 motion | generic X10 motion sensor | X00.00.03 | Bernd Pfrommer |\n+\n+## Channels\n+\n+Below is the list of possible channels for the Insteon devices. In order to determing which channels a device supports, you can either look at the device in Paper UI, or find it in the openhab log file.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "04a9796d14dfbc5f3ff997d872f04b6d03ee411d"}, "originalPosition": 98}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTMxNjY2NQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            ## Insteon binding process\n          \n          \n            \n            ## Insteon Binding Process", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r389316665", "createdAt": "2020-03-07T22:24:42Z", "author": {"login": "kaikreuzer"}, "path": "bundles/org.openhab.binding.insteon/README.md", "diffHunk": "@@ -0,0 +1,719 @@\n+# Insteon Binding\n+\n+Insteon is a home area networking technology developed primarily for connecting light switches and loads. Insteon devices send messages either via the power line, or by means of radio frequency (RF) waves, or both (dual-band). A considerable number of Insteon compatible devices such as switchable relays, thermostats, sensors etc are available. More about Insteon can be found on [Wikipedia](http://en.wikipedia.org/wiki/Insteon).\n+\n+This binding provides access to the Insteon network by means of either an Insteon PowerLinc Modem (PLM), a legacy Insteon Hub 2242-222 or the current 2245-222 Insteon Hub. The modem can be connected to the openHAB server either via a serial port (Model 2413S) or a USB port (Model 2413U). The Insteon PowerLinc Controller (Model 2414U) is not supported since it is a PLC not a PLM. The modem can also be connected via TCP (such as ser2net).  The binding translates openHAB commands into Insteon messages and sends them on the Insteon network. Relevant messages from the Insteon network (like notifications about switches being toggled) are picked up by the modem and converted to openHAB status updates by the binding. The binding also supports sending and receiving of legacy X10 messages.\n+\n+The binding does not support linking new devices on the fly, i.e. all devices must be linked with the modem *before* starting the Insteon binding.\n+\n+openHAB is not a configuration tool! To configure and set up your devices, link the devices manually via the set buttons, or use the free [Insteon Terminal](https://github.com/pfrommerd/insteon-terminal) software. The free HouseLinc software from Insteon can also be used for configuration, but it wipes the modem link database clean on its initial use, requiring to re-link the modem to all devices.\n+\n+## Supported Things\n+\n+| Thing  | Type   | Description                  |\n+|----------|--------|------------------------------|\n+| network  | Bridge | An insteon PLM or hub that is used to communicate with the Insteon devices |\n+|device| Thing | Insteon devices such as dimmers, keypads, sensors, etc. |\n+\n+## Discovery\n+\n+The binding will automatically add the network bridge called local to the Paper UI inbox. Upon proper configuration of the network bridge, the network device database will be downloaded. Any Insteon device that exists in the database and is not currently configured will get added to the inbox.  The naming convention is **Insteon Device AABBCC**, where AA, BB and CC are from the Insteon device address.  X10 devices are not auto discovered. \n+\n+## Thing Configuration\n+\n+###### Network Configuration\n+\n+The Insteon PLM or hub is configured with the following:\n+\n+| Parameter | Default | Required | Description |\n+|----------|---------:|--------:|-------------|\n+| port   |         |   Yes    | **Examples:**<br>- PLM on  Linux: `/dev/ttyS0` or `/dev/ttyUSB0`<br>- Smartenit ZBPLM on Linux: `/dev/ttyUSB0,baudRate=115200`<br>- PLM on Windows: `COM1`<br>- Current  hub (2245-222) at 192.168.1.100 on port 25105, with a poll interval of 1000 ms (1 second): `/hub2/my_user_name:my_password@192.168.1.100:25105,poll_time=1000`<br>- Legacy hub (2242-222) at 192.168.1.100 on port 9761:`/hub/192.168.1.100:9761`<br>- Networked PLM using ser2net at 192.168.1.100 on port 9761:`/tcp/192.168.1.100:9761` |\n+| devicePollIntervalSeconds | 300 |  No  | Poll interval of devices in seconds. Poll too often and you will overload the insteon network, leading to sluggish or no response when trying to send messages to devices. The default poll interval of 300 seconds has been tested and found to be a good compromise in a configuration of about 110 switches/dimmers. |\n+|modemDbRetryTimeoutSeconds|120|No|The number of seconds to wait for the modem database to completely download before retrying again.  Under normal circumstances this will not need to be modified.|\n+| additionalDevices | |       No     | Optional file with additional device types. The syntax of the file is identical to the `device_types.xml` file in the source tree. Please remember to post successfully added device types to the openhab group so the developers can include them into the `device_types.xml` file! |\n+| additionalFeatures | |      No     | Optional file with additional feature templates, like in the `device_features.xml` file in the source tree. |\n+\n+>NOTE: For users upgrading from InsteonPLM, The parameter port_1 is now port. \n+\n+###### Device Configuration\n+\n+The Insteon device is configured with the following required parameters:\n+\n+| Parameter | Description |\n+|----------|-------------|\n+|address|Insteon or X10 address of the device. Insteon device addresses are in the format 'xx.xx.xx', and can be found on the device. X10 device address are in the format 'x.y' and are typically configured on the device.|\n+|productKey|Insteon binding product key that is used to identy the device. Every Insteon device type is uniquely identified by its Insteon product key, typically a six digit hex number. For some of the older device types (in particular the SwitchLinc switches and dimmers), Insteon does not give a product key, so an arbitrary fake one of the format Fxx.xx.xx (or Xxx.xx.xx for X10 devices) is assigned by the binding.|\n+\n+The following is a list of the product keys and associated devices. These have been tested and should work out of the box:\n+\n+| Model | Description | Product Key | tested by |\n+|-------|-------------|-------------|-----------|\n+| 2477D | SwitchLinc Dimmer | F00.00.01 | Bernd Pfrommer |\n+| 2477S | SwitchLinc Switch | F00.00.02 | Bernd Pfrommer |\n+| 2845-222 | Hidden Door Sensor | F00.00.03 | Josenivaldo Benito |\n+| 2876S | ICON Switch | F00.00.04 | Patrick Giasson |\n+| 2456D3 | LampLinc V2 | F00.00.05 | Patrick Giasson |\n+| 2442-222 | Micro Dimmer | F00.00.06 | Josenivaldo Benito |\n+| 2453-222 | DIN Rail On/Off | F00.00.07 | Josenivaldo Benito |\n+| 2452-222 | DIN Rail Dimmer | F00.00.08 | Josenivaldo Benito |\n+| 2458-A1 | MorningLinc RF Lock Controller | F00.00.09 | cdeadlock |\n+| 2852-222 | Leak Sensor | F00.00.0A | Kirk McCann |\n+| 2672-422 | LED Dimmer | F00.00.0B | ??? |\n+| 2476D | SwitchLinc Dimmer | F00.00.0C | LiberatorUSA |\n+| 2634-222 | On/Off Dual-Band Outdoor Module | F00.00.0D | LiberatorUSA |\n+| 2342-2 | Mini Remote | F00.00.10 | Bernd Pfrommer |\n+| 2663-222 | On/Off Outlet | 0x000039 | SwissKid |\n+| 2466D | ToggleLinc Dimmer | F00.00.11 | Rob Nielsen |\n+| 2466S | ToggleLinc Switch | F00.00.12 | Rob Nielsen |\n+| 2672-222 | LED Bulb | F00.00.13 | Rob Nielsen |\n+| 2487S | KeypadLinc On/Off 6-Button | F00.00.14 | Bernd Pfrommer |\n+| 2334-232 | KeypadLink Dimmer 6-Button | F00.00.15 | Rob Nielsen |\n+| 2334-232 | KeypadLink Dimmer 8-Button | F00.00.16 | Rob Nielsen |\n+| 2423A1 | iMeter Solo Power Meter | F00.00.17 | Rob Nielsen |\n+| 2423A1 | Thermostat 2441TH | F00.00.18 | Daniel Campbell, Bernd Pfrommer |\n+| 2457D2 | LampLinc Dimmer | F00.00.19 | Jonathan Huizingh |\n+| 2475SDB | In-LineLinc Relay | F00.00.1A | Jim Howard |\n+| 2635-222 | On/Off Module | F00.00.1B | Jonathan Huizingh |\n+| 2475F | FanLinc Module | F00.00.1C | Brian Tillman |\n+| 2456S3 | ApplianceLinc | F00.00.1D | ??? |\n+| 2674-222 | LED Bulb (recessed) | F00.00.1E | Steve Bate |\n+| 2477SA1 | 220V 30-amp Load Controller N/O | F00.00.1F | Shawn R. |\n+| 2342-222 | Mini Remote (8 Button) | F00.00.20 | Bernd Pfrommer |\n+| 2441V | Insteon Thermostat Adaptor for Venstar | F00.00.21 | Bernd Pfrommer |\n+| 2982-222 | Insteon Smoke Bridge | F00.00.22 | Bernd Pfrommer |\n+| 2450 | IO Link | 0x00001A | Bernd Pfrommer |\n+| 2486D | KeypadLinc Dimmer | 0x000037 | Patrick Giasson, Joe Barnum |\n+| 2484DWH8 | KeypadLinc Countdown Timer | 0x000041 | Rob Nielsen |\n+| 2413U | PowerLinc 2413U USB modem | 0x000045 | Bernd Pfrommer |\n+| 2843-222 | Wireless Open/Close Sensor | 0x000049 | Josenivaldo Benito |\n+| 2842-222 | Motion Sensor | 0x00004A | Bernd Pfrommer |\n+| 2486DWH8 | KeypadLinc Dimmer | 0x000051 | Chris Graham |\n+| 2472D | OutletLincDimmer | 0x000068 | Chris Graham |\n+| X10 switch | generic X10 switch | X00.00.01 | Bernd Pfrommer |\n+| X10 dimmer | generic X10 dimmer | X00.00.02 | Bernd Pfrommer |\n+| X10 motion | generic X10 motion sensor | X00.00.03 | Bernd Pfrommer |\n+\n+## Channels\n+\n+Below is the list of possible channels for the Insteon devices. In order to determing which channels a device supports, you can either look at the device in Paper UI, or find it in the openhab log file.\n+\n+| channel  | type   | description                  |\n+|----------|--------|------------------------------|\n+| acDelay | Number | AC Delay |\n+| backlightDuration | Number | Back Light Duration |\n+| batteryLevel | Number | Battery Level |\n+| batteryWatermarkLevel | Number | Battery Watermark Level |\n+| bottomOutlet | Switch | Bottom Outlet |\n+| buttonA | Switch | Button A |\n+| buttonB | Switch | Button B |\n+| buttonC | Switch | Button C |\n+| buttonD | Switch | Button D |\n+| buttonE | Switch | Button E |\n+| buttonF | Switch | Button F |\n+| buttonG | Switch | Button G |\n+| buttonH | Switch | Button H |\n+| broadcastOnOff | Switch | Broadcast On/Off |\n+| contact | Contact | Contact |\n+| coolSetPoint | Number | Cool Set Point |\n+| dimmer | Dimmer | Dimmer |\n+| fan | Number | Fan |\n+| fanMode | Number | Fan Mode |\n+| fastOnOff | Switch | Fast On/Off |\n+| fastOnOffButtonA | Switch | Fast On/Off Button A |\n+| fastOnOffButtonB | Switch | Fast On/Off Button B |\n+| fastOnOffButtonC | Switch | Fast On/Off Button C |\n+| fastOnOffButtonD | Switch | Fast On/Off Button D |\n+| heatSetPoint | Number | Heat Set Point |\n+| humidity | Number | Humidity |\n+| humidityHigh | Number | Humidity High |\n+| humidityLow | Number | Humidity Low |\n+| isCooling | Number | Is Cooling |\n+| isHeating | Number | Is Heating |\n+| keypadButtonA | Switch | Keypad Button A |\n+| keypadButtonB | Switch | Keypad Button B |\n+| keypadButtonC | Switch | Keypad Button C |\n+| keypadButtonD | Switch | Keypad Button D |\n+| keypadButtonE | Switch | Keypad Button E |\n+| keypadButtonF | Switch | Keypad Button F |\n+| keypadButtonG | Switch | Keypad Button G |\n+| keypadButtonH | Switch | Keypad Button H |\n+| kWh | Number | Kilowatt Hour |\n+| lastHeardFrom | DateTime | Last Heard From |\n+| ledBrightness | Number | LED brightness |\n+| lightDimmer | Dimmer | light Dimmer |\n+| lightLevel | Number | Light Level |\n+| loadDimmer | Dimmer | Load Dimmer |\n+| loadSwitch | Switch | Load Switch |\n+| loadSwitchFastOnOff | Switch | Load Switch Fast On/Off |\n+| loadSwitchManualChange | Number | Load Switch Manual Change |\n+| manualChange | Number | Manual Change |\n+| manualChangeButtonA | Number | Manual Change Button A |\n+| manualChangeButtonB | Number | Manual Change Button B |\n+| manualChangeButtonC | Number | Manual Change Button C |\n+| manualChangeButtonD | Number | Manual Change Button D |\n+| notification | Number | Notification |\n+| onLevel | Number | On Level |\n+| rampDimmer | Dimmer | Ramp Dimmer |\n+| rampRate | Number | Ramp Rate |\n+| reset | Switch | Reset |\n+| stage1Duration | Number | Stage 1 Duration |\n+| switch | Switch | Switch |\n+| systemMode | Number | System Mode |\n+| tempCelsius | Number | Temperature Celsius |\n+| tempFahrenheit | Number | Temperature Fahrenheit |\n+| topOutlet | Switch | Top Outlet |\n+| update | Switch | Update |\n+| watts | Number | Watts |\n+\n+\n+## Full Example\n+\n+Sample things file:\n+\n+```\n+Bridge insteon:network:local [port=\"/dev/ttyUSB0\"] {\n+  Thing device 22F8A8 [address=\"22.F8.A8\", productKey=\"F00.00.15\"] {\n+    Channels:\n+      Type switch : keypadButtonA [ group=3 ]\n+      Type switch : keypadButtonB [ group=4 ]\n+      Type switch : keypadButtonC [ group=5 ]\n+      Type switch : keypadButtonD [ group=6 ]\n+  }\n+  Thing device 238D93 [address=\"23.8D.93\", productKey=\"F00.00.12\"]\n+  Thing device 238F55 [address=\"23.8F.55\", productKey=\"F00.00.11\"] {\n+    Channels:\n+      Type dimmer : dimmer [related=\"23.B0.D9+23.8F.C9\"]\n+  }\n+  Thing device 238FC9 [address=\"23.8F.C9\", productKey=\"F00.00.11\"] {\n+    Channels:\n+      Type dimmer : dimmer [related=\"23.8F.55+23.B0.D9\"]\n+  }\n+  Thing device 23B0D9 [address=\"23.B0.D9\", productKey=\"F00.00.11\"] {\n+    Channels:\n+      Type dimmer : dimmer [related=\"23.8F.55+23.8F.C9\"]\n+  }\n+  Thing device 243141 [address=\"24.31.41\", productKey=\"F00.00.11\"]  {\n+    Channels:\n+      Type dimmer : dimmer [dimmermax=60]\n+  }\n+}\n+```\n+\n+Sample items file:\n+\n+```\n+Switch switch1 { channel=\"insteon:device:local:243141:switch\" }\n+Dimmer dimmer1 { channel=\"insteon:device:local:238F55:dimmer\" }\n+Dimmer dimmer2 { channel=\"insteon:device:local:23B0D9:dimmer\" }\n+Dimmer dimmer3 { channel=\"insteon:device:local:238FC9:dimmer\" }\n+Dimmer keypad  { channel=\"insteon:device:local:22F8A8:loadDimmer\" }\n+Switch keypadA { channel=\"insteon:device:local:22F8A8:keypadButtonA\" }\n+Switch keypadB { channel=\"insteon:device:local:22F8A8:keypadButtonB\" }\n+Switch keypadC { channel=\"insteon:device:local:22F8A8:keypadButtonC\" }\n+Switch keypadD { channel=\"insteon:device:local:22F8A8:keypadButtonD\" }\n+Dimmer dimmer  { channel=\"insteon:device:local:238D93:dimmer\" }\n+```\n+\n+## Insteon Groups and Scenes\n+\n+How do Insteon devices tell other devices on the network that their state has changed? They send out a broadcast message, labeled with a specific *group* number. All devices (called *responders*) that are configured to listen to this message will then go into a pre-defined state. For instance when light switch A is switched to \"ON\", it will send out a message to group #1, and all responders will react to it, e.g they may go into the \"ON\" position as well. Since more than one device can participate, the sending out of the broadcast message and the subsequent state change of the responders is referred to as \"triggering a scene\". At the device and PLM level, the concept of a \"scene\" does not exist, so you will find it notably absent in the binding code and this document. A scene is strictly a higher level concept, introduced to shield the user from the details of how the communication is implemented.\n+\n+Many Insteon devices send out messages on different group numbers, depending on what happens to them. A leak sensor may send out a message on group #1 when dry, and on group #2 when wet. The default group used for e.g. linking two light switches is usually group #1.\n+\n+## Insteon binding process", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "04a9796d14dfbc5f3ff997d872f04b6d03ee411d"}, "originalPosition": 223}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTMxNjY3Nw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            ### Simple light switches\n          \n          \n            \n            ### Simple Light Switches", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r389316677", "createdAt": "2020-03-07T22:25:03Z", "author": {"login": "kaikreuzer"}, "path": "bundles/org.openhab.binding.insteon/README.md", "diffHunk": "@@ -0,0 +1,719 @@\n+# Insteon Binding\n+\n+Insteon is a home area networking technology developed primarily for connecting light switches and loads. Insteon devices send messages either via the power line, or by means of radio frequency (RF) waves, or both (dual-band). A considerable number of Insteon compatible devices such as switchable relays, thermostats, sensors etc are available. More about Insteon can be found on [Wikipedia](http://en.wikipedia.org/wiki/Insteon).\n+\n+This binding provides access to the Insteon network by means of either an Insteon PowerLinc Modem (PLM), a legacy Insteon Hub 2242-222 or the current 2245-222 Insteon Hub. The modem can be connected to the openHAB server either via a serial port (Model 2413S) or a USB port (Model 2413U). The Insteon PowerLinc Controller (Model 2414U) is not supported since it is a PLC not a PLM. The modem can also be connected via TCP (such as ser2net).  The binding translates openHAB commands into Insteon messages and sends them on the Insteon network. Relevant messages from the Insteon network (like notifications about switches being toggled) are picked up by the modem and converted to openHAB status updates by the binding. The binding also supports sending and receiving of legacy X10 messages.\n+\n+The binding does not support linking new devices on the fly, i.e. all devices must be linked with the modem *before* starting the Insteon binding.\n+\n+openHAB is not a configuration tool! To configure and set up your devices, link the devices manually via the set buttons, or use the free [Insteon Terminal](https://github.com/pfrommerd/insteon-terminal) software. The free HouseLinc software from Insteon can also be used for configuration, but it wipes the modem link database clean on its initial use, requiring to re-link the modem to all devices.\n+\n+## Supported Things\n+\n+| Thing  | Type   | Description                  |\n+|----------|--------|------------------------------|\n+| network  | Bridge | An insteon PLM or hub that is used to communicate with the Insteon devices |\n+|device| Thing | Insteon devices such as dimmers, keypads, sensors, etc. |\n+\n+## Discovery\n+\n+The binding will automatically add the network bridge called local to the Paper UI inbox. Upon proper configuration of the network bridge, the network device database will be downloaded. Any Insteon device that exists in the database and is not currently configured will get added to the inbox.  The naming convention is **Insteon Device AABBCC**, where AA, BB and CC are from the Insteon device address.  X10 devices are not auto discovered. \n+\n+## Thing Configuration\n+\n+###### Network Configuration\n+\n+The Insteon PLM or hub is configured with the following:\n+\n+| Parameter | Default | Required | Description |\n+|----------|---------:|--------:|-------------|\n+| port   |         |   Yes    | **Examples:**<br>- PLM on  Linux: `/dev/ttyS0` or `/dev/ttyUSB0`<br>- Smartenit ZBPLM on Linux: `/dev/ttyUSB0,baudRate=115200`<br>- PLM on Windows: `COM1`<br>- Current  hub (2245-222) at 192.168.1.100 on port 25105, with a poll interval of 1000 ms (1 second): `/hub2/my_user_name:my_password@192.168.1.100:25105,poll_time=1000`<br>- Legacy hub (2242-222) at 192.168.1.100 on port 9761:`/hub/192.168.1.100:9761`<br>- Networked PLM using ser2net at 192.168.1.100 on port 9761:`/tcp/192.168.1.100:9761` |\n+| devicePollIntervalSeconds | 300 |  No  | Poll interval of devices in seconds. Poll too often and you will overload the insteon network, leading to sluggish or no response when trying to send messages to devices. The default poll interval of 300 seconds has been tested and found to be a good compromise in a configuration of about 110 switches/dimmers. |\n+|modemDbRetryTimeoutSeconds|120|No|The number of seconds to wait for the modem database to completely download before retrying again.  Under normal circumstances this will not need to be modified.|\n+| additionalDevices | |       No     | Optional file with additional device types. The syntax of the file is identical to the `device_types.xml` file in the source tree. Please remember to post successfully added device types to the openhab group so the developers can include them into the `device_types.xml` file! |\n+| additionalFeatures | |      No     | Optional file with additional feature templates, like in the `device_features.xml` file in the source tree. |\n+\n+>NOTE: For users upgrading from InsteonPLM, The parameter port_1 is now port. \n+\n+###### Device Configuration\n+\n+The Insteon device is configured with the following required parameters:\n+\n+| Parameter | Description |\n+|----------|-------------|\n+|address|Insteon or X10 address of the device. Insteon device addresses are in the format 'xx.xx.xx', and can be found on the device. X10 device address are in the format 'x.y' and are typically configured on the device.|\n+|productKey|Insteon binding product key that is used to identy the device. Every Insteon device type is uniquely identified by its Insteon product key, typically a six digit hex number. For some of the older device types (in particular the SwitchLinc switches and dimmers), Insteon does not give a product key, so an arbitrary fake one of the format Fxx.xx.xx (or Xxx.xx.xx for X10 devices) is assigned by the binding.|\n+\n+The following is a list of the product keys and associated devices. These have been tested and should work out of the box:\n+\n+| Model | Description | Product Key | tested by |\n+|-------|-------------|-------------|-----------|\n+| 2477D | SwitchLinc Dimmer | F00.00.01 | Bernd Pfrommer |\n+| 2477S | SwitchLinc Switch | F00.00.02 | Bernd Pfrommer |\n+| 2845-222 | Hidden Door Sensor | F00.00.03 | Josenivaldo Benito |\n+| 2876S | ICON Switch | F00.00.04 | Patrick Giasson |\n+| 2456D3 | LampLinc V2 | F00.00.05 | Patrick Giasson |\n+| 2442-222 | Micro Dimmer | F00.00.06 | Josenivaldo Benito |\n+| 2453-222 | DIN Rail On/Off | F00.00.07 | Josenivaldo Benito |\n+| 2452-222 | DIN Rail Dimmer | F00.00.08 | Josenivaldo Benito |\n+| 2458-A1 | MorningLinc RF Lock Controller | F00.00.09 | cdeadlock |\n+| 2852-222 | Leak Sensor | F00.00.0A | Kirk McCann |\n+| 2672-422 | LED Dimmer | F00.00.0B | ??? |\n+| 2476D | SwitchLinc Dimmer | F00.00.0C | LiberatorUSA |\n+| 2634-222 | On/Off Dual-Band Outdoor Module | F00.00.0D | LiberatorUSA |\n+| 2342-2 | Mini Remote | F00.00.10 | Bernd Pfrommer |\n+| 2663-222 | On/Off Outlet | 0x000039 | SwissKid |\n+| 2466D | ToggleLinc Dimmer | F00.00.11 | Rob Nielsen |\n+| 2466S | ToggleLinc Switch | F00.00.12 | Rob Nielsen |\n+| 2672-222 | LED Bulb | F00.00.13 | Rob Nielsen |\n+| 2487S | KeypadLinc On/Off 6-Button | F00.00.14 | Bernd Pfrommer |\n+| 2334-232 | KeypadLink Dimmer 6-Button | F00.00.15 | Rob Nielsen |\n+| 2334-232 | KeypadLink Dimmer 8-Button | F00.00.16 | Rob Nielsen |\n+| 2423A1 | iMeter Solo Power Meter | F00.00.17 | Rob Nielsen |\n+| 2423A1 | Thermostat 2441TH | F00.00.18 | Daniel Campbell, Bernd Pfrommer |\n+| 2457D2 | LampLinc Dimmer | F00.00.19 | Jonathan Huizingh |\n+| 2475SDB | In-LineLinc Relay | F00.00.1A | Jim Howard |\n+| 2635-222 | On/Off Module | F00.00.1B | Jonathan Huizingh |\n+| 2475F | FanLinc Module | F00.00.1C | Brian Tillman |\n+| 2456S3 | ApplianceLinc | F00.00.1D | ??? |\n+| 2674-222 | LED Bulb (recessed) | F00.00.1E | Steve Bate |\n+| 2477SA1 | 220V 30-amp Load Controller N/O | F00.00.1F | Shawn R. |\n+| 2342-222 | Mini Remote (8 Button) | F00.00.20 | Bernd Pfrommer |\n+| 2441V | Insteon Thermostat Adaptor for Venstar | F00.00.21 | Bernd Pfrommer |\n+| 2982-222 | Insteon Smoke Bridge | F00.00.22 | Bernd Pfrommer |\n+| 2450 | IO Link | 0x00001A | Bernd Pfrommer |\n+| 2486D | KeypadLinc Dimmer | 0x000037 | Patrick Giasson, Joe Barnum |\n+| 2484DWH8 | KeypadLinc Countdown Timer | 0x000041 | Rob Nielsen |\n+| 2413U | PowerLinc 2413U USB modem | 0x000045 | Bernd Pfrommer |\n+| 2843-222 | Wireless Open/Close Sensor | 0x000049 | Josenivaldo Benito |\n+| 2842-222 | Motion Sensor | 0x00004A | Bernd Pfrommer |\n+| 2486DWH8 | KeypadLinc Dimmer | 0x000051 | Chris Graham |\n+| 2472D | OutletLincDimmer | 0x000068 | Chris Graham |\n+| X10 switch | generic X10 switch | X00.00.01 | Bernd Pfrommer |\n+| X10 dimmer | generic X10 dimmer | X00.00.02 | Bernd Pfrommer |\n+| X10 motion | generic X10 motion sensor | X00.00.03 | Bernd Pfrommer |\n+\n+## Channels\n+\n+Below is the list of possible channels for the Insteon devices. In order to determing which channels a device supports, you can either look at the device in Paper UI, or find it in the openhab log file.\n+\n+| channel  | type   | description                  |\n+|----------|--------|------------------------------|\n+| acDelay | Number | AC Delay |\n+| backlightDuration | Number | Back Light Duration |\n+| batteryLevel | Number | Battery Level |\n+| batteryWatermarkLevel | Number | Battery Watermark Level |\n+| bottomOutlet | Switch | Bottom Outlet |\n+| buttonA | Switch | Button A |\n+| buttonB | Switch | Button B |\n+| buttonC | Switch | Button C |\n+| buttonD | Switch | Button D |\n+| buttonE | Switch | Button E |\n+| buttonF | Switch | Button F |\n+| buttonG | Switch | Button G |\n+| buttonH | Switch | Button H |\n+| broadcastOnOff | Switch | Broadcast On/Off |\n+| contact | Contact | Contact |\n+| coolSetPoint | Number | Cool Set Point |\n+| dimmer | Dimmer | Dimmer |\n+| fan | Number | Fan |\n+| fanMode | Number | Fan Mode |\n+| fastOnOff | Switch | Fast On/Off |\n+| fastOnOffButtonA | Switch | Fast On/Off Button A |\n+| fastOnOffButtonB | Switch | Fast On/Off Button B |\n+| fastOnOffButtonC | Switch | Fast On/Off Button C |\n+| fastOnOffButtonD | Switch | Fast On/Off Button D |\n+| heatSetPoint | Number | Heat Set Point |\n+| humidity | Number | Humidity |\n+| humidityHigh | Number | Humidity High |\n+| humidityLow | Number | Humidity Low |\n+| isCooling | Number | Is Cooling |\n+| isHeating | Number | Is Heating |\n+| keypadButtonA | Switch | Keypad Button A |\n+| keypadButtonB | Switch | Keypad Button B |\n+| keypadButtonC | Switch | Keypad Button C |\n+| keypadButtonD | Switch | Keypad Button D |\n+| keypadButtonE | Switch | Keypad Button E |\n+| keypadButtonF | Switch | Keypad Button F |\n+| keypadButtonG | Switch | Keypad Button G |\n+| keypadButtonH | Switch | Keypad Button H |\n+| kWh | Number | Kilowatt Hour |\n+| lastHeardFrom | DateTime | Last Heard From |\n+| ledBrightness | Number | LED brightness |\n+| lightDimmer | Dimmer | light Dimmer |\n+| lightLevel | Number | Light Level |\n+| loadDimmer | Dimmer | Load Dimmer |\n+| loadSwitch | Switch | Load Switch |\n+| loadSwitchFastOnOff | Switch | Load Switch Fast On/Off |\n+| loadSwitchManualChange | Number | Load Switch Manual Change |\n+| manualChange | Number | Manual Change |\n+| manualChangeButtonA | Number | Manual Change Button A |\n+| manualChangeButtonB | Number | Manual Change Button B |\n+| manualChangeButtonC | Number | Manual Change Button C |\n+| manualChangeButtonD | Number | Manual Change Button D |\n+| notification | Number | Notification |\n+| onLevel | Number | On Level |\n+| rampDimmer | Dimmer | Ramp Dimmer |\n+| rampRate | Number | Ramp Rate |\n+| reset | Switch | Reset |\n+| stage1Duration | Number | Stage 1 Duration |\n+| switch | Switch | Switch |\n+| systemMode | Number | System Mode |\n+| tempCelsius | Number | Temperature Celsius |\n+| tempFahrenheit | Number | Temperature Fahrenheit |\n+| topOutlet | Switch | Top Outlet |\n+| update | Switch | Update |\n+| watts | Number | Watts |\n+\n+\n+## Full Example\n+\n+Sample things file:\n+\n+```\n+Bridge insteon:network:local [port=\"/dev/ttyUSB0\"] {\n+  Thing device 22F8A8 [address=\"22.F8.A8\", productKey=\"F00.00.15\"] {\n+    Channels:\n+      Type switch : keypadButtonA [ group=3 ]\n+      Type switch : keypadButtonB [ group=4 ]\n+      Type switch : keypadButtonC [ group=5 ]\n+      Type switch : keypadButtonD [ group=6 ]\n+  }\n+  Thing device 238D93 [address=\"23.8D.93\", productKey=\"F00.00.12\"]\n+  Thing device 238F55 [address=\"23.8F.55\", productKey=\"F00.00.11\"] {\n+    Channels:\n+      Type dimmer : dimmer [related=\"23.B0.D9+23.8F.C9\"]\n+  }\n+  Thing device 238FC9 [address=\"23.8F.C9\", productKey=\"F00.00.11\"] {\n+    Channels:\n+      Type dimmer : dimmer [related=\"23.8F.55+23.B0.D9\"]\n+  }\n+  Thing device 23B0D9 [address=\"23.B0.D9\", productKey=\"F00.00.11\"] {\n+    Channels:\n+      Type dimmer : dimmer [related=\"23.8F.55+23.8F.C9\"]\n+  }\n+  Thing device 243141 [address=\"24.31.41\", productKey=\"F00.00.11\"]  {\n+    Channels:\n+      Type dimmer : dimmer [dimmermax=60]\n+  }\n+}\n+```\n+\n+Sample items file:\n+\n+```\n+Switch switch1 { channel=\"insteon:device:local:243141:switch\" }\n+Dimmer dimmer1 { channel=\"insteon:device:local:238F55:dimmer\" }\n+Dimmer dimmer2 { channel=\"insteon:device:local:23B0D9:dimmer\" }\n+Dimmer dimmer3 { channel=\"insteon:device:local:238FC9:dimmer\" }\n+Dimmer keypad  { channel=\"insteon:device:local:22F8A8:loadDimmer\" }\n+Switch keypadA { channel=\"insteon:device:local:22F8A8:keypadButtonA\" }\n+Switch keypadB { channel=\"insteon:device:local:22F8A8:keypadButtonB\" }\n+Switch keypadC { channel=\"insteon:device:local:22F8A8:keypadButtonC\" }\n+Switch keypadD { channel=\"insteon:device:local:22F8A8:keypadButtonD\" }\n+Dimmer dimmer  { channel=\"insteon:device:local:238D93:dimmer\" }\n+```\n+\n+## Insteon Groups and Scenes\n+\n+How do Insteon devices tell other devices on the network that their state has changed? They send out a broadcast message, labeled with a specific *group* number. All devices (called *responders*) that are configured to listen to this message will then go into a pre-defined state. For instance when light switch A is switched to \"ON\", it will send out a message to group #1, and all responders will react to it, e.g they may go into the \"ON\" position as well. Since more than one device can participate, the sending out of the broadcast message and the subsequent state change of the responders is referred to as \"triggering a scene\". At the device and PLM level, the concept of a \"scene\" does not exist, so you will find it notably absent in the binding code and this document. A scene is strictly a higher level concept, introduced to shield the user from the details of how the communication is implemented.\n+\n+Many Insteon devices send out messages on different group numbers, depending on what happens to them. A leak sensor may send out a message on group #1 when dry, and on group #2 when wet. The default group used for e.g. linking two light switches is usually group #1.\n+\n+## Insteon binding process\n+\n+Before Insteon devices communicate with one another, they must be linked. During the linking process, one of the devices will be the \"Controller\", the other the \"Responder\" (see e.g. the [SwitchLinc Instructions](https://www.insteon.com/pdf/2477S.pdf)).\n+\n+The responder listens to messages from the controller, and reacts to them. Note that except for the case of a motion detector (which is just a controller to the modem), the modem controls the device (e.g. send on/off messages to it), and the device controls the modem (so the modem learns about the switch being toggled). For this reason, most devices and in particular switches/dimmers should be linked twice, with one taking the role of controller during the first linking, and the other acting as controller during the second linking process. To do so, first press and hold the \"Set\" button on the modem until the light starts blinking. Then press and hold the \"Set\" button on the remote device,\n+e.g. the light switch, until it double beeps (the light on the modem should go off as well). Now do exactly the reverse: press and hold the \"Set\" button on the remote device until its light starts blinking, then press and hold the \"Set\" button on the modem until it double beeps, and the light of the remote device (switch) goes off. Done.\n+\n+For some of the more sophisticated devices the complete linking process can no longer be done with the set buttons, but requires software like e.g. [Insteon Terminal](https://github.com/pfrommerd/insteon-terminal).\n+\n+## Insteon Features\n+\n+Since Insteon devices can have multiple features (for instance a switchable relay and a contact sensor) under a single Insteon address, an openHAB item is not bound to a device, but to a given feature of a device. For example, the following lines would create two Number items referring to the same thermostat device, but to different features of it:\n+\n+```\n+Number  thermostatCoolPoint \"cool point [%.1f \u00b0F]\" { channel=\"insteon:device:local:32F422:coolSetPoint\" }\n+Number  thermostatHeatPoint \"heat point [%.1f \u00b0F]\" { channel=\"insteon:device:local:32F422:heatSetPoint\" }\n+```\n+\n+### Simple light switches", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "04a9796d14dfbc5f3ff997d872f04b6d03ee411d"}, "originalPosition": 241}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTMxNjY4MQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            ### Simple dimmers\n          \n          \n            \n            ### Simple Dimmers", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r389316681", "createdAt": "2020-03-07T22:25:11Z", "author": {"login": "kaikreuzer"}, "path": "bundles/org.openhab.binding.insteon/README.md", "diffHunk": "@@ -0,0 +1,719 @@\n+# Insteon Binding\n+\n+Insteon is a home area networking technology developed primarily for connecting light switches and loads. Insteon devices send messages either via the power line, or by means of radio frequency (RF) waves, or both (dual-band). A considerable number of Insteon compatible devices such as switchable relays, thermostats, sensors etc are available. More about Insteon can be found on [Wikipedia](http://en.wikipedia.org/wiki/Insteon).\n+\n+This binding provides access to the Insteon network by means of either an Insteon PowerLinc Modem (PLM), a legacy Insteon Hub 2242-222 or the current 2245-222 Insteon Hub. The modem can be connected to the openHAB server either via a serial port (Model 2413S) or a USB port (Model 2413U). The Insteon PowerLinc Controller (Model 2414U) is not supported since it is a PLC not a PLM. The modem can also be connected via TCP (such as ser2net).  The binding translates openHAB commands into Insteon messages and sends them on the Insteon network. Relevant messages from the Insteon network (like notifications about switches being toggled) are picked up by the modem and converted to openHAB status updates by the binding. The binding also supports sending and receiving of legacy X10 messages.\n+\n+The binding does not support linking new devices on the fly, i.e. all devices must be linked with the modem *before* starting the Insteon binding.\n+\n+openHAB is not a configuration tool! To configure and set up your devices, link the devices manually via the set buttons, or use the free [Insteon Terminal](https://github.com/pfrommerd/insteon-terminal) software. The free HouseLinc software from Insteon can also be used for configuration, but it wipes the modem link database clean on its initial use, requiring to re-link the modem to all devices.\n+\n+## Supported Things\n+\n+| Thing  | Type   | Description                  |\n+|----------|--------|------------------------------|\n+| network  | Bridge | An insteon PLM or hub that is used to communicate with the Insteon devices |\n+|device| Thing | Insteon devices such as dimmers, keypads, sensors, etc. |\n+\n+## Discovery\n+\n+The binding will automatically add the network bridge called local to the Paper UI inbox. Upon proper configuration of the network bridge, the network device database will be downloaded. Any Insteon device that exists in the database and is not currently configured will get added to the inbox.  The naming convention is **Insteon Device AABBCC**, where AA, BB and CC are from the Insteon device address.  X10 devices are not auto discovered. \n+\n+## Thing Configuration\n+\n+###### Network Configuration\n+\n+The Insteon PLM or hub is configured with the following:\n+\n+| Parameter | Default | Required | Description |\n+|----------|---------:|--------:|-------------|\n+| port   |         |   Yes    | **Examples:**<br>- PLM on  Linux: `/dev/ttyS0` or `/dev/ttyUSB0`<br>- Smartenit ZBPLM on Linux: `/dev/ttyUSB0,baudRate=115200`<br>- PLM on Windows: `COM1`<br>- Current  hub (2245-222) at 192.168.1.100 on port 25105, with a poll interval of 1000 ms (1 second): `/hub2/my_user_name:my_password@192.168.1.100:25105,poll_time=1000`<br>- Legacy hub (2242-222) at 192.168.1.100 on port 9761:`/hub/192.168.1.100:9761`<br>- Networked PLM using ser2net at 192.168.1.100 on port 9761:`/tcp/192.168.1.100:9761` |\n+| devicePollIntervalSeconds | 300 |  No  | Poll interval of devices in seconds. Poll too often and you will overload the insteon network, leading to sluggish or no response when trying to send messages to devices. The default poll interval of 300 seconds has been tested and found to be a good compromise in a configuration of about 110 switches/dimmers. |\n+|modemDbRetryTimeoutSeconds|120|No|The number of seconds to wait for the modem database to completely download before retrying again.  Under normal circumstances this will not need to be modified.|\n+| additionalDevices | |       No     | Optional file with additional device types. The syntax of the file is identical to the `device_types.xml` file in the source tree. Please remember to post successfully added device types to the openhab group so the developers can include them into the `device_types.xml` file! |\n+| additionalFeatures | |      No     | Optional file with additional feature templates, like in the `device_features.xml` file in the source tree. |\n+\n+>NOTE: For users upgrading from InsteonPLM, The parameter port_1 is now port. \n+\n+###### Device Configuration\n+\n+The Insteon device is configured with the following required parameters:\n+\n+| Parameter | Description |\n+|----------|-------------|\n+|address|Insteon or X10 address of the device. Insteon device addresses are in the format 'xx.xx.xx', and can be found on the device. X10 device address are in the format 'x.y' and are typically configured on the device.|\n+|productKey|Insteon binding product key that is used to identy the device. Every Insteon device type is uniquely identified by its Insteon product key, typically a six digit hex number. For some of the older device types (in particular the SwitchLinc switches and dimmers), Insteon does not give a product key, so an arbitrary fake one of the format Fxx.xx.xx (or Xxx.xx.xx for X10 devices) is assigned by the binding.|\n+\n+The following is a list of the product keys and associated devices. These have been tested and should work out of the box:\n+\n+| Model | Description | Product Key | tested by |\n+|-------|-------------|-------------|-----------|\n+| 2477D | SwitchLinc Dimmer | F00.00.01 | Bernd Pfrommer |\n+| 2477S | SwitchLinc Switch | F00.00.02 | Bernd Pfrommer |\n+| 2845-222 | Hidden Door Sensor | F00.00.03 | Josenivaldo Benito |\n+| 2876S | ICON Switch | F00.00.04 | Patrick Giasson |\n+| 2456D3 | LampLinc V2 | F00.00.05 | Patrick Giasson |\n+| 2442-222 | Micro Dimmer | F00.00.06 | Josenivaldo Benito |\n+| 2453-222 | DIN Rail On/Off | F00.00.07 | Josenivaldo Benito |\n+| 2452-222 | DIN Rail Dimmer | F00.00.08 | Josenivaldo Benito |\n+| 2458-A1 | MorningLinc RF Lock Controller | F00.00.09 | cdeadlock |\n+| 2852-222 | Leak Sensor | F00.00.0A | Kirk McCann |\n+| 2672-422 | LED Dimmer | F00.00.0B | ??? |\n+| 2476D | SwitchLinc Dimmer | F00.00.0C | LiberatorUSA |\n+| 2634-222 | On/Off Dual-Band Outdoor Module | F00.00.0D | LiberatorUSA |\n+| 2342-2 | Mini Remote | F00.00.10 | Bernd Pfrommer |\n+| 2663-222 | On/Off Outlet | 0x000039 | SwissKid |\n+| 2466D | ToggleLinc Dimmer | F00.00.11 | Rob Nielsen |\n+| 2466S | ToggleLinc Switch | F00.00.12 | Rob Nielsen |\n+| 2672-222 | LED Bulb | F00.00.13 | Rob Nielsen |\n+| 2487S | KeypadLinc On/Off 6-Button | F00.00.14 | Bernd Pfrommer |\n+| 2334-232 | KeypadLink Dimmer 6-Button | F00.00.15 | Rob Nielsen |\n+| 2334-232 | KeypadLink Dimmer 8-Button | F00.00.16 | Rob Nielsen |\n+| 2423A1 | iMeter Solo Power Meter | F00.00.17 | Rob Nielsen |\n+| 2423A1 | Thermostat 2441TH | F00.00.18 | Daniel Campbell, Bernd Pfrommer |\n+| 2457D2 | LampLinc Dimmer | F00.00.19 | Jonathan Huizingh |\n+| 2475SDB | In-LineLinc Relay | F00.00.1A | Jim Howard |\n+| 2635-222 | On/Off Module | F00.00.1B | Jonathan Huizingh |\n+| 2475F | FanLinc Module | F00.00.1C | Brian Tillman |\n+| 2456S3 | ApplianceLinc | F00.00.1D | ??? |\n+| 2674-222 | LED Bulb (recessed) | F00.00.1E | Steve Bate |\n+| 2477SA1 | 220V 30-amp Load Controller N/O | F00.00.1F | Shawn R. |\n+| 2342-222 | Mini Remote (8 Button) | F00.00.20 | Bernd Pfrommer |\n+| 2441V | Insteon Thermostat Adaptor for Venstar | F00.00.21 | Bernd Pfrommer |\n+| 2982-222 | Insteon Smoke Bridge | F00.00.22 | Bernd Pfrommer |\n+| 2450 | IO Link | 0x00001A | Bernd Pfrommer |\n+| 2486D | KeypadLinc Dimmer | 0x000037 | Patrick Giasson, Joe Barnum |\n+| 2484DWH8 | KeypadLinc Countdown Timer | 0x000041 | Rob Nielsen |\n+| 2413U | PowerLinc 2413U USB modem | 0x000045 | Bernd Pfrommer |\n+| 2843-222 | Wireless Open/Close Sensor | 0x000049 | Josenivaldo Benito |\n+| 2842-222 | Motion Sensor | 0x00004A | Bernd Pfrommer |\n+| 2486DWH8 | KeypadLinc Dimmer | 0x000051 | Chris Graham |\n+| 2472D | OutletLincDimmer | 0x000068 | Chris Graham |\n+| X10 switch | generic X10 switch | X00.00.01 | Bernd Pfrommer |\n+| X10 dimmer | generic X10 dimmer | X00.00.02 | Bernd Pfrommer |\n+| X10 motion | generic X10 motion sensor | X00.00.03 | Bernd Pfrommer |\n+\n+## Channels\n+\n+Below is the list of possible channels for the Insteon devices. In order to determing which channels a device supports, you can either look at the device in Paper UI, or find it in the openhab log file.\n+\n+| channel  | type   | description                  |\n+|----------|--------|------------------------------|\n+| acDelay | Number | AC Delay |\n+| backlightDuration | Number | Back Light Duration |\n+| batteryLevel | Number | Battery Level |\n+| batteryWatermarkLevel | Number | Battery Watermark Level |\n+| bottomOutlet | Switch | Bottom Outlet |\n+| buttonA | Switch | Button A |\n+| buttonB | Switch | Button B |\n+| buttonC | Switch | Button C |\n+| buttonD | Switch | Button D |\n+| buttonE | Switch | Button E |\n+| buttonF | Switch | Button F |\n+| buttonG | Switch | Button G |\n+| buttonH | Switch | Button H |\n+| broadcastOnOff | Switch | Broadcast On/Off |\n+| contact | Contact | Contact |\n+| coolSetPoint | Number | Cool Set Point |\n+| dimmer | Dimmer | Dimmer |\n+| fan | Number | Fan |\n+| fanMode | Number | Fan Mode |\n+| fastOnOff | Switch | Fast On/Off |\n+| fastOnOffButtonA | Switch | Fast On/Off Button A |\n+| fastOnOffButtonB | Switch | Fast On/Off Button B |\n+| fastOnOffButtonC | Switch | Fast On/Off Button C |\n+| fastOnOffButtonD | Switch | Fast On/Off Button D |\n+| heatSetPoint | Number | Heat Set Point |\n+| humidity | Number | Humidity |\n+| humidityHigh | Number | Humidity High |\n+| humidityLow | Number | Humidity Low |\n+| isCooling | Number | Is Cooling |\n+| isHeating | Number | Is Heating |\n+| keypadButtonA | Switch | Keypad Button A |\n+| keypadButtonB | Switch | Keypad Button B |\n+| keypadButtonC | Switch | Keypad Button C |\n+| keypadButtonD | Switch | Keypad Button D |\n+| keypadButtonE | Switch | Keypad Button E |\n+| keypadButtonF | Switch | Keypad Button F |\n+| keypadButtonG | Switch | Keypad Button G |\n+| keypadButtonH | Switch | Keypad Button H |\n+| kWh | Number | Kilowatt Hour |\n+| lastHeardFrom | DateTime | Last Heard From |\n+| ledBrightness | Number | LED brightness |\n+| lightDimmer | Dimmer | light Dimmer |\n+| lightLevel | Number | Light Level |\n+| loadDimmer | Dimmer | Load Dimmer |\n+| loadSwitch | Switch | Load Switch |\n+| loadSwitchFastOnOff | Switch | Load Switch Fast On/Off |\n+| loadSwitchManualChange | Number | Load Switch Manual Change |\n+| manualChange | Number | Manual Change |\n+| manualChangeButtonA | Number | Manual Change Button A |\n+| manualChangeButtonB | Number | Manual Change Button B |\n+| manualChangeButtonC | Number | Manual Change Button C |\n+| manualChangeButtonD | Number | Manual Change Button D |\n+| notification | Number | Notification |\n+| onLevel | Number | On Level |\n+| rampDimmer | Dimmer | Ramp Dimmer |\n+| rampRate | Number | Ramp Rate |\n+| reset | Switch | Reset |\n+| stage1Duration | Number | Stage 1 Duration |\n+| switch | Switch | Switch |\n+| systemMode | Number | System Mode |\n+| tempCelsius | Number | Temperature Celsius |\n+| tempFahrenheit | Number | Temperature Fahrenheit |\n+| topOutlet | Switch | Top Outlet |\n+| update | Switch | Update |\n+| watts | Number | Watts |\n+\n+\n+## Full Example\n+\n+Sample things file:\n+\n+```\n+Bridge insteon:network:local [port=\"/dev/ttyUSB0\"] {\n+  Thing device 22F8A8 [address=\"22.F8.A8\", productKey=\"F00.00.15\"] {\n+    Channels:\n+      Type switch : keypadButtonA [ group=3 ]\n+      Type switch : keypadButtonB [ group=4 ]\n+      Type switch : keypadButtonC [ group=5 ]\n+      Type switch : keypadButtonD [ group=6 ]\n+  }\n+  Thing device 238D93 [address=\"23.8D.93\", productKey=\"F00.00.12\"]\n+  Thing device 238F55 [address=\"23.8F.55\", productKey=\"F00.00.11\"] {\n+    Channels:\n+      Type dimmer : dimmer [related=\"23.B0.D9+23.8F.C9\"]\n+  }\n+  Thing device 238FC9 [address=\"23.8F.C9\", productKey=\"F00.00.11\"] {\n+    Channels:\n+      Type dimmer : dimmer [related=\"23.8F.55+23.B0.D9\"]\n+  }\n+  Thing device 23B0D9 [address=\"23.B0.D9\", productKey=\"F00.00.11\"] {\n+    Channels:\n+      Type dimmer : dimmer [related=\"23.8F.55+23.8F.C9\"]\n+  }\n+  Thing device 243141 [address=\"24.31.41\", productKey=\"F00.00.11\"]  {\n+    Channels:\n+      Type dimmer : dimmer [dimmermax=60]\n+  }\n+}\n+```\n+\n+Sample items file:\n+\n+```\n+Switch switch1 { channel=\"insteon:device:local:243141:switch\" }\n+Dimmer dimmer1 { channel=\"insteon:device:local:238F55:dimmer\" }\n+Dimmer dimmer2 { channel=\"insteon:device:local:23B0D9:dimmer\" }\n+Dimmer dimmer3 { channel=\"insteon:device:local:238FC9:dimmer\" }\n+Dimmer keypad  { channel=\"insteon:device:local:22F8A8:loadDimmer\" }\n+Switch keypadA { channel=\"insteon:device:local:22F8A8:keypadButtonA\" }\n+Switch keypadB { channel=\"insteon:device:local:22F8A8:keypadButtonB\" }\n+Switch keypadC { channel=\"insteon:device:local:22F8A8:keypadButtonC\" }\n+Switch keypadD { channel=\"insteon:device:local:22F8A8:keypadButtonD\" }\n+Dimmer dimmer  { channel=\"insteon:device:local:238D93:dimmer\" }\n+```\n+\n+## Insteon Groups and Scenes\n+\n+How do Insteon devices tell other devices on the network that their state has changed? They send out a broadcast message, labeled with a specific *group* number. All devices (called *responders*) that are configured to listen to this message will then go into a pre-defined state. For instance when light switch A is switched to \"ON\", it will send out a message to group #1, and all responders will react to it, e.g they may go into the \"ON\" position as well. Since more than one device can participate, the sending out of the broadcast message and the subsequent state change of the responders is referred to as \"triggering a scene\". At the device and PLM level, the concept of a \"scene\" does not exist, so you will find it notably absent in the binding code and this document. A scene is strictly a higher level concept, introduced to shield the user from the details of how the communication is implemented.\n+\n+Many Insteon devices send out messages on different group numbers, depending on what happens to them. A leak sensor may send out a message on group #1 when dry, and on group #2 when wet. The default group used for e.g. linking two light switches is usually group #1.\n+\n+## Insteon binding process\n+\n+Before Insteon devices communicate with one another, they must be linked. During the linking process, one of the devices will be the \"Controller\", the other the \"Responder\" (see e.g. the [SwitchLinc Instructions](https://www.insteon.com/pdf/2477S.pdf)).\n+\n+The responder listens to messages from the controller, and reacts to them. Note that except for the case of a motion detector (which is just a controller to the modem), the modem controls the device (e.g. send on/off messages to it), and the device controls the modem (so the modem learns about the switch being toggled). For this reason, most devices and in particular switches/dimmers should be linked twice, with one taking the role of controller during the first linking, and the other acting as controller during the second linking process. To do so, first press and hold the \"Set\" button on the modem until the light starts blinking. Then press and hold the \"Set\" button on the remote device,\n+e.g. the light switch, until it double beeps (the light on the modem should go off as well). Now do exactly the reverse: press and hold the \"Set\" button on the remote device until its light starts blinking, then press and hold the \"Set\" button on the modem until it double beeps, and the light of the remote device (switch) goes off. Done.\n+\n+For some of the more sophisticated devices the complete linking process can no longer be done with the set buttons, but requires software like e.g. [Insteon Terminal](https://github.com/pfrommerd/insteon-terminal).\n+\n+## Insteon Features\n+\n+Since Insteon devices can have multiple features (for instance a switchable relay and a contact sensor) under a single Insteon address, an openHAB item is not bound to a device, but to a given feature of a device. For example, the following lines would create two Number items referring to the same thermostat device, but to different features of it:\n+\n+```\n+Number  thermostatCoolPoint \"cool point [%.1f \u00b0F]\" { channel=\"insteon:device:local:32F422:coolSetPoint\" }\n+Number  thermostatHeatPoint \"heat point [%.1f \u00b0F]\" { channel=\"insteon:device:local:32F422:heatSetPoint\" }\n+```\n+\n+### Simple light switches\n+\n+The following example shows how to configure a simple light switch (2477S) in the .items file:\n+\n+```\n+Switch officeLight \"office light\"  { channel=\"insteon:device:local:AABBCC:switch\" }\n+```\n+\n+### Simple dimmers", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "04a9796d14dfbc5f3ff997d872f04b6d03ee411d"}, "originalPosition": 249}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTMxNjY4Ng==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            ### Mini remotes\n          \n          \n            \n            ### Mini Remotes", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r389316686", "createdAt": "2020-03-07T22:25:22Z", "author": {"login": "kaikreuzer"}, "path": "bundles/org.openhab.binding.insteon/README.md", "diffHunk": "@@ -0,0 +1,719 @@\n+# Insteon Binding\n+\n+Insteon is a home area networking technology developed primarily for connecting light switches and loads. Insteon devices send messages either via the power line, or by means of radio frequency (RF) waves, or both (dual-band). A considerable number of Insteon compatible devices such as switchable relays, thermostats, sensors etc are available. More about Insteon can be found on [Wikipedia](http://en.wikipedia.org/wiki/Insteon).\n+\n+This binding provides access to the Insteon network by means of either an Insteon PowerLinc Modem (PLM), a legacy Insteon Hub 2242-222 or the current 2245-222 Insteon Hub. The modem can be connected to the openHAB server either via a serial port (Model 2413S) or a USB port (Model 2413U). The Insteon PowerLinc Controller (Model 2414U) is not supported since it is a PLC not a PLM. The modem can also be connected via TCP (such as ser2net).  The binding translates openHAB commands into Insteon messages and sends them on the Insteon network. Relevant messages from the Insteon network (like notifications about switches being toggled) are picked up by the modem and converted to openHAB status updates by the binding. The binding also supports sending and receiving of legacy X10 messages.\n+\n+The binding does not support linking new devices on the fly, i.e. all devices must be linked with the modem *before* starting the Insteon binding.\n+\n+openHAB is not a configuration tool! To configure and set up your devices, link the devices manually via the set buttons, or use the free [Insteon Terminal](https://github.com/pfrommerd/insteon-terminal) software. The free HouseLinc software from Insteon can also be used for configuration, but it wipes the modem link database clean on its initial use, requiring to re-link the modem to all devices.\n+\n+## Supported Things\n+\n+| Thing  | Type   | Description                  |\n+|----------|--------|------------------------------|\n+| network  | Bridge | An insteon PLM or hub that is used to communicate with the Insteon devices |\n+|device| Thing | Insteon devices such as dimmers, keypads, sensors, etc. |\n+\n+## Discovery\n+\n+The binding will automatically add the network bridge called local to the Paper UI inbox. Upon proper configuration of the network bridge, the network device database will be downloaded. Any Insteon device that exists in the database and is not currently configured will get added to the inbox.  The naming convention is **Insteon Device AABBCC**, where AA, BB and CC are from the Insteon device address.  X10 devices are not auto discovered. \n+\n+## Thing Configuration\n+\n+###### Network Configuration\n+\n+The Insteon PLM or hub is configured with the following:\n+\n+| Parameter | Default | Required | Description |\n+|----------|---------:|--------:|-------------|\n+| port   |         |   Yes    | **Examples:**<br>- PLM on  Linux: `/dev/ttyS0` or `/dev/ttyUSB0`<br>- Smartenit ZBPLM on Linux: `/dev/ttyUSB0,baudRate=115200`<br>- PLM on Windows: `COM1`<br>- Current  hub (2245-222) at 192.168.1.100 on port 25105, with a poll interval of 1000 ms (1 second): `/hub2/my_user_name:my_password@192.168.1.100:25105,poll_time=1000`<br>- Legacy hub (2242-222) at 192.168.1.100 on port 9761:`/hub/192.168.1.100:9761`<br>- Networked PLM using ser2net at 192.168.1.100 on port 9761:`/tcp/192.168.1.100:9761` |\n+| devicePollIntervalSeconds | 300 |  No  | Poll interval of devices in seconds. Poll too often and you will overload the insteon network, leading to sluggish or no response when trying to send messages to devices. The default poll interval of 300 seconds has been tested and found to be a good compromise in a configuration of about 110 switches/dimmers. |\n+|modemDbRetryTimeoutSeconds|120|No|The number of seconds to wait for the modem database to completely download before retrying again.  Under normal circumstances this will not need to be modified.|\n+| additionalDevices | |       No     | Optional file with additional device types. The syntax of the file is identical to the `device_types.xml` file in the source tree. Please remember to post successfully added device types to the openhab group so the developers can include them into the `device_types.xml` file! |\n+| additionalFeatures | |      No     | Optional file with additional feature templates, like in the `device_features.xml` file in the source tree. |\n+\n+>NOTE: For users upgrading from InsteonPLM, The parameter port_1 is now port. \n+\n+###### Device Configuration\n+\n+The Insteon device is configured with the following required parameters:\n+\n+| Parameter | Description |\n+|----------|-------------|\n+|address|Insteon or X10 address of the device. Insteon device addresses are in the format 'xx.xx.xx', and can be found on the device. X10 device address are in the format 'x.y' and are typically configured on the device.|\n+|productKey|Insteon binding product key that is used to identy the device. Every Insteon device type is uniquely identified by its Insteon product key, typically a six digit hex number. For some of the older device types (in particular the SwitchLinc switches and dimmers), Insteon does not give a product key, so an arbitrary fake one of the format Fxx.xx.xx (or Xxx.xx.xx for X10 devices) is assigned by the binding.|\n+\n+The following is a list of the product keys and associated devices. These have been tested and should work out of the box:\n+\n+| Model | Description | Product Key | tested by |\n+|-------|-------------|-------------|-----------|\n+| 2477D | SwitchLinc Dimmer | F00.00.01 | Bernd Pfrommer |\n+| 2477S | SwitchLinc Switch | F00.00.02 | Bernd Pfrommer |\n+| 2845-222 | Hidden Door Sensor | F00.00.03 | Josenivaldo Benito |\n+| 2876S | ICON Switch | F00.00.04 | Patrick Giasson |\n+| 2456D3 | LampLinc V2 | F00.00.05 | Patrick Giasson |\n+| 2442-222 | Micro Dimmer | F00.00.06 | Josenivaldo Benito |\n+| 2453-222 | DIN Rail On/Off | F00.00.07 | Josenivaldo Benito |\n+| 2452-222 | DIN Rail Dimmer | F00.00.08 | Josenivaldo Benito |\n+| 2458-A1 | MorningLinc RF Lock Controller | F00.00.09 | cdeadlock |\n+| 2852-222 | Leak Sensor | F00.00.0A | Kirk McCann |\n+| 2672-422 | LED Dimmer | F00.00.0B | ??? |\n+| 2476D | SwitchLinc Dimmer | F00.00.0C | LiberatorUSA |\n+| 2634-222 | On/Off Dual-Band Outdoor Module | F00.00.0D | LiberatorUSA |\n+| 2342-2 | Mini Remote | F00.00.10 | Bernd Pfrommer |\n+| 2663-222 | On/Off Outlet | 0x000039 | SwissKid |\n+| 2466D | ToggleLinc Dimmer | F00.00.11 | Rob Nielsen |\n+| 2466S | ToggleLinc Switch | F00.00.12 | Rob Nielsen |\n+| 2672-222 | LED Bulb | F00.00.13 | Rob Nielsen |\n+| 2487S | KeypadLinc On/Off 6-Button | F00.00.14 | Bernd Pfrommer |\n+| 2334-232 | KeypadLink Dimmer 6-Button | F00.00.15 | Rob Nielsen |\n+| 2334-232 | KeypadLink Dimmer 8-Button | F00.00.16 | Rob Nielsen |\n+| 2423A1 | iMeter Solo Power Meter | F00.00.17 | Rob Nielsen |\n+| 2423A1 | Thermostat 2441TH | F00.00.18 | Daniel Campbell, Bernd Pfrommer |\n+| 2457D2 | LampLinc Dimmer | F00.00.19 | Jonathan Huizingh |\n+| 2475SDB | In-LineLinc Relay | F00.00.1A | Jim Howard |\n+| 2635-222 | On/Off Module | F00.00.1B | Jonathan Huizingh |\n+| 2475F | FanLinc Module | F00.00.1C | Brian Tillman |\n+| 2456S3 | ApplianceLinc | F00.00.1D | ??? |\n+| 2674-222 | LED Bulb (recessed) | F00.00.1E | Steve Bate |\n+| 2477SA1 | 220V 30-amp Load Controller N/O | F00.00.1F | Shawn R. |\n+| 2342-222 | Mini Remote (8 Button) | F00.00.20 | Bernd Pfrommer |\n+| 2441V | Insteon Thermostat Adaptor for Venstar | F00.00.21 | Bernd Pfrommer |\n+| 2982-222 | Insteon Smoke Bridge | F00.00.22 | Bernd Pfrommer |\n+| 2450 | IO Link | 0x00001A | Bernd Pfrommer |\n+| 2486D | KeypadLinc Dimmer | 0x000037 | Patrick Giasson, Joe Barnum |\n+| 2484DWH8 | KeypadLinc Countdown Timer | 0x000041 | Rob Nielsen |\n+| 2413U | PowerLinc 2413U USB modem | 0x000045 | Bernd Pfrommer |\n+| 2843-222 | Wireless Open/Close Sensor | 0x000049 | Josenivaldo Benito |\n+| 2842-222 | Motion Sensor | 0x00004A | Bernd Pfrommer |\n+| 2486DWH8 | KeypadLinc Dimmer | 0x000051 | Chris Graham |\n+| 2472D | OutletLincDimmer | 0x000068 | Chris Graham |\n+| X10 switch | generic X10 switch | X00.00.01 | Bernd Pfrommer |\n+| X10 dimmer | generic X10 dimmer | X00.00.02 | Bernd Pfrommer |\n+| X10 motion | generic X10 motion sensor | X00.00.03 | Bernd Pfrommer |\n+\n+## Channels\n+\n+Below is the list of possible channels for the Insteon devices. In order to determing which channels a device supports, you can either look at the device in Paper UI, or find it in the openhab log file.\n+\n+| channel  | type   | description                  |\n+|----------|--------|------------------------------|\n+| acDelay | Number | AC Delay |\n+| backlightDuration | Number | Back Light Duration |\n+| batteryLevel | Number | Battery Level |\n+| batteryWatermarkLevel | Number | Battery Watermark Level |\n+| bottomOutlet | Switch | Bottom Outlet |\n+| buttonA | Switch | Button A |\n+| buttonB | Switch | Button B |\n+| buttonC | Switch | Button C |\n+| buttonD | Switch | Button D |\n+| buttonE | Switch | Button E |\n+| buttonF | Switch | Button F |\n+| buttonG | Switch | Button G |\n+| buttonH | Switch | Button H |\n+| broadcastOnOff | Switch | Broadcast On/Off |\n+| contact | Contact | Contact |\n+| coolSetPoint | Number | Cool Set Point |\n+| dimmer | Dimmer | Dimmer |\n+| fan | Number | Fan |\n+| fanMode | Number | Fan Mode |\n+| fastOnOff | Switch | Fast On/Off |\n+| fastOnOffButtonA | Switch | Fast On/Off Button A |\n+| fastOnOffButtonB | Switch | Fast On/Off Button B |\n+| fastOnOffButtonC | Switch | Fast On/Off Button C |\n+| fastOnOffButtonD | Switch | Fast On/Off Button D |\n+| heatSetPoint | Number | Heat Set Point |\n+| humidity | Number | Humidity |\n+| humidityHigh | Number | Humidity High |\n+| humidityLow | Number | Humidity Low |\n+| isCooling | Number | Is Cooling |\n+| isHeating | Number | Is Heating |\n+| keypadButtonA | Switch | Keypad Button A |\n+| keypadButtonB | Switch | Keypad Button B |\n+| keypadButtonC | Switch | Keypad Button C |\n+| keypadButtonD | Switch | Keypad Button D |\n+| keypadButtonE | Switch | Keypad Button E |\n+| keypadButtonF | Switch | Keypad Button F |\n+| keypadButtonG | Switch | Keypad Button G |\n+| keypadButtonH | Switch | Keypad Button H |\n+| kWh | Number | Kilowatt Hour |\n+| lastHeardFrom | DateTime | Last Heard From |\n+| ledBrightness | Number | LED brightness |\n+| lightDimmer | Dimmer | light Dimmer |\n+| lightLevel | Number | Light Level |\n+| loadDimmer | Dimmer | Load Dimmer |\n+| loadSwitch | Switch | Load Switch |\n+| loadSwitchFastOnOff | Switch | Load Switch Fast On/Off |\n+| loadSwitchManualChange | Number | Load Switch Manual Change |\n+| manualChange | Number | Manual Change |\n+| manualChangeButtonA | Number | Manual Change Button A |\n+| manualChangeButtonB | Number | Manual Change Button B |\n+| manualChangeButtonC | Number | Manual Change Button C |\n+| manualChangeButtonD | Number | Manual Change Button D |\n+| notification | Number | Notification |\n+| onLevel | Number | On Level |\n+| rampDimmer | Dimmer | Ramp Dimmer |\n+| rampRate | Number | Ramp Rate |\n+| reset | Switch | Reset |\n+| stage1Duration | Number | Stage 1 Duration |\n+| switch | Switch | Switch |\n+| systemMode | Number | System Mode |\n+| tempCelsius | Number | Temperature Celsius |\n+| tempFahrenheit | Number | Temperature Fahrenheit |\n+| topOutlet | Switch | Top Outlet |\n+| update | Switch | Update |\n+| watts | Number | Watts |\n+\n+\n+## Full Example\n+\n+Sample things file:\n+\n+```\n+Bridge insteon:network:local [port=\"/dev/ttyUSB0\"] {\n+  Thing device 22F8A8 [address=\"22.F8.A8\", productKey=\"F00.00.15\"] {\n+    Channels:\n+      Type switch : keypadButtonA [ group=3 ]\n+      Type switch : keypadButtonB [ group=4 ]\n+      Type switch : keypadButtonC [ group=5 ]\n+      Type switch : keypadButtonD [ group=6 ]\n+  }\n+  Thing device 238D93 [address=\"23.8D.93\", productKey=\"F00.00.12\"]\n+  Thing device 238F55 [address=\"23.8F.55\", productKey=\"F00.00.11\"] {\n+    Channels:\n+      Type dimmer : dimmer [related=\"23.B0.D9+23.8F.C9\"]\n+  }\n+  Thing device 238FC9 [address=\"23.8F.C9\", productKey=\"F00.00.11\"] {\n+    Channels:\n+      Type dimmer : dimmer [related=\"23.8F.55+23.B0.D9\"]\n+  }\n+  Thing device 23B0D9 [address=\"23.B0.D9\", productKey=\"F00.00.11\"] {\n+    Channels:\n+      Type dimmer : dimmer [related=\"23.8F.55+23.8F.C9\"]\n+  }\n+  Thing device 243141 [address=\"24.31.41\", productKey=\"F00.00.11\"]  {\n+    Channels:\n+      Type dimmer : dimmer [dimmermax=60]\n+  }\n+}\n+```\n+\n+Sample items file:\n+\n+```\n+Switch switch1 { channel=\"insteon:device:local:243141:switch\" }\n+Dimmer dimmer1 { channel=\"insteon:device:local:238F55:dimmer\" }\n+Dimmer dimmer2 { channel=\"insteon:device:local:23B0D9:dimmer\" }\n+Dimmer dimmer3 { channel=\"insteon:device:local:238FC9:dimmer\" }\n+Dimmer keypad  { channel=\"insteon:device:local:22F8A8:loadDimmer\" }\n+Switch keypadA { channel=\"insteon:device:local:22F8A8:keypadButtonA\" }\n+Switch keypadB { channel=\"insteon:device:local:22F8A8:keypadButtonB\" }\n+Switch keypadC { channel=\"insteon:device:local:22F8A8:keypadButtonC\" }\n+Switch keypadD { channel=\"insteon:device:local:22F8A8:keypadButtonD\" }\n+Dimmer dimmer  { channel=\"insteon:device:local:238D93:dimmer\" }\n+```\n+\n+## Insteon Groups and Scenes\n+\n+How do Insteon devices tell other devices on the network that their state has changed? They send out a broadcast message, labeled with a specific *group* number. All devices (called *responders*) that are configured to listen to this message will then go into a pre-defined state. For instance when light switch A is switched to \"ON\", it will send out a message to group #1, and all responders will react to it, e.g they may go into the \"ON\" position as well. Since more than one device can participate, the sending out of the broadcast message and the subsequent state change of the responders is referred to as \"triggering a scene\". At the device and PLM level, the concept of a \"scene\" does not exist, so you will find it notably absent in the binding code and this document. A scene is strictly a higher level concept, introduced to shield the user from the details of how the communication is implemented.\n+\n+Many Insteon devices send out messages on different group numbers, depending on what happens to them. A leak sensor may send out a message on group #1 when dry, and on group #2 when wet. The default group used for e.g. linking two light switches is usually group #1.\n+\n+## Insteon binding process\n+\n+Before Insteon devices communicate with one another, they must be linked. During the linking process, one of the devices will be the \"Controller\", the other the \"Responder\" (see e.g. the [SwitchLinc Instructions](https://www.insteon.com/pdf/2477S.pdf)).\n+\n+The responder listens to messages from the controller, and reacts to them. Note that except for the case of a motion detector (which is just a controller to the modem), the modem controls the device (e.g. send on/off messages to it), and the device controls the modem (so the modem learns about the switch being toggled). For this reason, most devices and in particular switches/dimmers should be linked twice, with one taking the role of controller during the first linking, and the other acting as controller during the second linking process. To do so, first press and hold the \"Set\" button on the modem until the light starts blinking. Then press and hold the \"Set\" button on the remote device,\n+e.g. the light switch, until it double beeps (the light on the modem should go off as well). Now do exactly the reverse: press and hold the \"Set\" button on the remote device until its light starts blinking, then press and hold the \"Set\" button on the modem until it double beeps, and the light of the remote device (switch) goes off. Done.\n+\n+For some of the more sophisticated devices the complete linking process can no longer be done with the set buttons, but requires software like e.g. [Insteon Terminal](https://github.com/pfrommerd/insteon-terminal).\n+\n+## Insteon Features\n+\n+Since Insteon devices can have multiple features (for instance a switchable relay and a contact sensor) under a single Insteon address, an openHAB item is not bound to a device, but to a given feature of a device. For example, the following lines would create two Number items referring to the same thermostat device, but to different features of it:\n+\n+```\n+Number  thermostatCoolPoint \"cool point [%.1f \u00b0F]\" { channel=\"insteon:device:local:32F422:coolSetPoint\" }\n+Number  thermostatHeatPoint \"heat point [%.1f \u00b0F]\" { channel=\"insteon:device:local:32F422:heatSetPoint\" }\n+```\n+\n+### Simple light switches\n+\n+The following example shows how to configure a simple light switch (2477S) in the .items file:\n+\n+```\n+Switch officeLight \"office light\"  { channel=\"insteon:device:local:AABBCC:switch\" }\n+```\n+\n+### Simple dimmers\n+\n+Here is how to configure a simple dimmer (2477D) in the .items file:\n+\n+```\n+Dimmer kitchenChandelier \"kitchen chandelier\" { channel=\"insteon:device:local:AABBCC:dimmer\" }\n+```\n+\n+Dimmers can be configured with a maximum level when turning a device on or setting a percentage level. If a maximum level is configured, openHAB will never set the level of the dimmer above the level specified. The parameter dimmermax must be defined for the channel. The below example sets a maximum level of 70% for dim 1 and 60% for dim 2:\n+\n+**Things**\n+\n+```\n+Bridge insteon:network:local [port=\"/dev/ttyUSB0\"] {\n+  Thing device AABBCC [address=\"AA.BB.CC\", productKey=\"F00.00.11\"]  {\n+    Channels:\n+      Type dimmer : dimmer [dimmermax=70]\n+  }\n+  Thing device AABBCD [address=\"AA.BB.CD\", productKey=\"F00.00.15\"]  {\n+    Channels:\n+      Type dimmer : loadDimmer [dimmermax=60]\n+  }\n+}\n+```\n+\n+**Items**\n+\n+```\n+Dimmer d1 \"dimmer 1\" { channel=\"insteon:device:local:AABBCC:dimmer\"}\n+Dimmer d2 \"dimmer 2\" { channel=\"insteon:device:local:AABBCD:loadDimmer\"}\n+```\n+\n+Setting a maximum level does not affect manual turning on or dimming a switch.\n+\n+### On/Off Outlets\n+\n+Here's how to configure the top and bottom outlet of the in-wall 2 outlet controller:\n+\n+```\n+Switch fOutTop \"Front Outlet Top\"    <socket> { channel=\"insteon:device:local:AABBCC:topOutlet\" }\n+Switch fOutBot \"Front Outlet Bottom\" <socket> { channel=\"insteon:device:local:AABBCC:bottomOutlet\" }\n+```\n+\n+This will give you individual control of each outlet.\n+    \n+### Mini remotes", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "04a9796d14dfbc5f3ff997d872f04b6d03ee411d"}, "originalPosition": 294}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTMxNjY5NQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            ### Motion sensors\n          \n          \n            \n            ### Motion Sensors", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r389316695", "createdAt": "2020-03-07T22:25:35Z", "author": {"login": "kaikreuzer"}, "path": "bundles/org.openhab.binding.insteon/README.md", "diffHunk": "@@ -0,0 +1,719 @@\n+# Insteon Binding\n+\n+Insteon is a home area networking technology developed primarily for connecting light switches and loads. Insteon devices send messages either via the power line, or by means of radio frequency (RF) waves, or both (dual-band). A considerable number of Insteon compatible devices such as switchable relays, thermostats, sensors etc are available. More about Insteon can be found on [Wikipedia](http://en.wikipedia.org/wiki/Insteon).\n+\n+This binding provides access to the Insteon network by means of either an Insteon PowerLinc Modem (PLM), a legacy Insteon Hub 2242-222 or the current 2245-222 Insteon Hub. The modem can be connected to the openHAB server either via a serial port (Model 2413S) or a USB port (Model 2413U). The Insteon PowerLinc Controller (Model 2414U) is not supported since it is a PLC not a PLM. The modem can also be connected via TCP (such as ser2net).  The binding translates openHAB commands into Insteon messages and sends them on the Insteon network. Relevant messages from the Insteon network (like notifications about switches being toggled) are picked up by the modem and converted to openHAB status updates by the binding. The binding also supports sending and receiving of legacy X10 messages.\n+\n+The binding does not support linking new devices on the fly, i.e. all devices must be linked with the modem *before* starting the Insteon binding.\n+\n+openHAB is not a configuration tool! To configure and set up your devices, link the devices manually via the set buttons, or use the free [Insteon Terminal](https://github.com/pfrommerd/insteon-terminal) software. The free HouseLinc software from Insteon can also be used for configuration, but it wipes the modem link database clean on its initial use, requiring to re-link the modem to all devices.\n+\n+## Supported Things\n+\n+| Thing  | Type   | Description                  |\n+|----------|--------|------------------------------|\n+| network  | Bridge | An insteon PLM or hub that is used to communicate with the Insteon devices |\n+|device| Thing | Insteon devices such as dimmers, keypads, sensors, etc. |\n+\n+## Discovery\n+\n+The binding will automatically add the network bridge called local to the Paper UI inbox. Upon proper configuration of the network bridge, the network device database will be downloaded. Any Insteon device that exists in the database and is not currently configured will get added to the inbox.  The naming convention is **Insteon Device AABBCC**, where AA, BB and CC are from the Insteon device address.  X10 devices are not auto discovered. \n+\n+## Thing Configuration\n+\n+###### Network Configuration\n+\n+The Insteon PLM or hub is configured with the following:\n+\n+| Parameter | Default | Required | Description |\n+|----------|---------:|--------:|-------------|\n+| port   |         |   Yes    | **Examples:**<br>- PLM on  Linux: `/dev/ttyS0` or `/dev/ttyUSB0`<br>- Smartenit ZBPLM on Linux: `/dev/ttyUSB0,baudRate=115200`<br>- PLM on Windows: `COM1`<br>- Current  hub (2245-222) at 192.168.1.100 on port 25105, with a poll interval of 1000 ms (1 second): `/hub2/my_user_name:my_password@192.168.1.100:25105,poll_time=1000`<br>- Legacy hub (2242-222) at 192.168.1.100 on port 9761:`/hub/192.168.1.100:9761`<br>- Networked PLM using ser2net at 192.168.1.100 on port 9761:`/tcp/192.168.1.100:9761` |\n+| devicePollIntervalSeconds | 300 |  No  | Poll interval of devices in seconds. Poll too often and you will overload the insteon network, leading to sluggish or no response when trying to send messages to devices. The default poll interval of 300 seconds has been tested and found to be a good compromise in a configuration of about 110 switches/dimmers. |\n+|modemDbRetryTimeoutSeconds|120|No|The number of seconds to wait for the modem database to completely download before retrying again.  Under normal circumstances this will not need to be modified.|\n+| additionalDevices | |       No     | Optional file with additional device types. The syntax of the file is identical to the `device_types.xml` file in the source tree. Please remember to post successfully added device types to the openhab group so the developers can include them into the `device_types.xml` file! |\n+| additionalFeatures | |      No     | Optional file with additional feature templates, like in the `device_features.xml` file in the source tree. |\n+\n+>NOTE: For users upgrading from InsteonPLM, The parameter port_1 is now port. \n+\n+###### Device Configuration\n+\n+The Insteon device is configured with the following required parameters:\n+\n+| Parameter | Description |\n+|----------|-------------|\n+|address|Insteon or X10 address of the device. Insteon device addresses are in the format 'xx.xx.xx', and can be found on the device. X10 device address are in the format 'x.y' and are typically configured on the device.|\n+|productKey|Insteon binding product key that is used to identy the device. Every Insteon device type is uniquely identified by its Insteon product key, typically a six digit hex number. For some of the older device types (in particular the SwitchLinc switches and dimmers), Insteon does not give a product key, so an arbitrary fake one of the format Fxx.xx.xx (or Xxx.xx.xx for X10 devices) is assigned by the binding.|\n+\n+The following is a list of the product keys and associated devices. These have been tested and should work out of the box:\n+\n+| Model | Description | Product Key | tested by |\n+|-------|-------------|-------------|-----------|\n+| 2477D | SwitchLinc Dimmer | F00.00.01 | Bernd Pfrommer |\n+| 2477S | SwitchLinc Switch | F00.00.02 | Bernd Pfrommer |\n+| 2845-222 | Hidden Door Sensor | F00.00.03 | Josenivaldo Benito |\n+| 2876S | ICON Switch | F00.00.04 | Patrick Giasson |\n+| 2456D3 | LampLinc V2 | F00.00.05 | Patrick Giasson |\n+| 2442-222 | Micro Dimmer | F00.00.06 | Josenivaldo Benito |\n+| 2453-222 | DIN Rail On/Off | F00.00.07 | Josenivaldo Benito |\n+| 2452-222 | DIN Rail Dimmer | F00.00.08 | Josenivaldo Benito |\n+| 2458-A1 | MorningLinc RF Lock Controller | F00.00.09 | cdeadlock |\n+| 2852-222 | Leak Sensor | F00.00.0A | Kirk McCann |\n+| 2672-422 | LED Dimmer | F00.00.0B | ??? |\n+| 2476D | SwitchLinc Dimmer | F00.00.0C | LiberatorUSA |\n+| 2634-222 | On/Off Dual-Band Outdoor Module | F00.00.0D | LiberatorUSA |\n+| 2342-2 | Mini Remote | F00.00.10 | Bernd Pfrommer |\n+| 2663-222 | On/Off Outlet | 0x000039 | SwissKid |\n+| 2466D | ToggleLinc Dimmer | F00.00.11 | Rob Nielsen |\n+| 2466S | ToggleLinc Switch | F00.00.12 | Rob Nielsen |\n+| 2672-222 | LED Bulb | F00.00.13 | Rob Nielsen |\n+| 2487S | KeypadLinc On/Off 6-Button | F00.00.14 | Bernd Pfrommer |\n+| 2334-232 | KeypadLink Dimmer 6-Button | F00.00.15 | Rob Nielsen |\n+| 2334-232 | KeypadLink Dimmer 8-Button | F00.00.16 | Rob Nielsen |\n+| 2423A1 | iMeter Solo Power Meter | F00.00.17 | Rob Nielsen |\n+| 2423A1 | Thermostat 2441TH | F00.00.18 | Daniel Campbell, Bernd Pfrommer |\n+| 2457D2 | LampLinc Dimmer | F00.00.19 | Jonathan Huizingh |\n+| 2475SDB | In-LineLinc Relay | F00.00.1A | Jim Howard |\n+| 2635-222 | On/Off Module | F00.00.1B | Jonathan Huizingh |\n+| 2475F | FanLinc Module | F00.00.1C | Brian Tillman |\n+| 2456S3 | ApplianceLinc | F00.00.1D | ??? |\n+| 2674-222 | LED Bulb (recessed) | F00.00.1E | Steve Bate |\n+| 2477SA1 | 220V 30-amp Load Controller N/O | F00.00.1F | Shawn R. |\n+| 2342-222 | Mini Remote (8 Button) | F00.00.20 | Bernd Pfrommer |\n+| 2441V | Insteon Thermostat Adaptor for Venstar | F00.00.21 | Bernd Pfrommer |\n+| 2982-222 | Insteon Smoke Bridge | F00.00.22 | Bernd Pfrommer |\n+| 2450 | IO Link | 0x00001A | Bernd Pfrommer |\n+| 2486D | KeypadLinc Dimmer | 0x000037 | Patrick Giasson, Joe Barnum |\n+| 2484DWH8 | KeypadLinc Countdown Timer | 0x000041 | Rob Nielsen |\n+| 2413U | PowerLinc 2413U USB modem | 0x000045 | Bernd Pfrommer |\n+| 2843-222 | Wireless Open/Close Sensor | 0x000049 | Josenivaldo Benito |\n+| 2842-222 | Motion Sensor | 0x00004A | Bernd Pfrommer |\n+| 2486DWH8 | KeypadLinc Dimmer | 0x000051 | Chris Graham |\n+| 2472D | OutletLincDimmer | 0x000068 | Chris Graham |\n+| X10 switch | generic X10 switch | X00.00.01 | Bernd Pfrommer |\n+| X10 dimmer | generic X10 dimmer | X00.00.02 | Bernd Pfrommer |\n+| X10 motion | generic X10 motion sensor | X00.00.03 | Bernd Pfrommer |\n+\n+## Channels\n+\n+Below is the list of possible channels for the Insteon devices. In order to determing which channels a device supports, you can either look at the device in Paper UI, or find it in the openhab log file.\n+\n+| channel  | type   | description                  |\n+|----------|--------|------------------------------|\n+| acDelay | Number | AC Delay |\n+| backlightDuration | Number | Back Light Duration |\n+| batteryLevel | Number | Battery Level |\n+| batteryWatermarkLevel | Number | Battery Watermark Level |\n+| bottomOutlet | Switch | Bottom Outlet |\n+| buttonA | Switch | Button A |\n+| buttonB | Switch | Button B |\n+| buttonC | Switch | Button C |\n+| buttonD | Switch | Button D |\n+| buttonE | Switch | Button E |\n+| buttonF | Switch | Button F |\n+| buttonG | Switch | Button G |\n+| buttonH | Switch | Button H |\n+| broadcastOnOff | Switch | Broadcast On/Off |\n+| contact | Contact | Contact |\n+| coolSetPoint | Number | Cool Set Point |\n+| dimmer | Dimmer | Dimmer |\n+| fan | Number | Fan |\n+| fanMode | Number | Fan Mode |\n+| fastOnOff | Switch | Fast On/Off |\n+| fastOnOffButtonA | Switch | Fast On/Off Button A |\n+| fastOnOffButtonB | Switch | Fast On/Off Button B |\n+| fastOnOffButtonC | Switch | Fast On/Off Button C |\n+| fastOnOffButtonD | Switch | Fast On/Off Button D |\n+| heatSetPoint | Number | Heat Set Point |\n+| humidity | Number | Humidity |\n+| humidityHigh | Number | Humidity High |\n+| humidityLow | Number | Humidity Low |\n+| isCooling | Number | Is Cooling |\n+| isHeating | Number | Is Heating |\n+| keypadButtonA | Switch | Keypad Button A |\n+| keypadButtonB | Switch | Keypad Button B |\n+| keypadButtonC | Switch | Keypad Button C |\n+| keypadButtonD | Switch | Keypad Button D |\n+| keypadButtonE | Switch | Keypad Button E |\n+| keypadButtonF | Switch | Keypad Button F |\n+| keypadButtonG | Switch | Keypad Button G |\n+| keypadButtonH | Switch | Keypad Button H |\n+| kWh | Number | Kilowatt Hour |\n+| lastHeardFrom | DateTime | Last Heard From |\n+| ledBrightness | Number | LED brightness |\n+| lightDimmer | Dimmer | light Dimmer |\n+| lightLevel | Number | Light Level |\n+| loadDimmer | Dimmer | Load Dimmer |\n+| loadSwitch | Switch | Load Switch |\n+| loadSwitchFastOnOff | Switch | Load Switch Fast On/Off |\n+| loadSwitchManualChange | Number | Load Switch Manual Change |\n+| manualChange | Number | Manual Change |\n+| manualChangeButtonA | Number | Manual Change Button A |\n+| manualChangeButtonB | Number | Manual Change Button B |\n+| manualChangeButtonC | Number | Manual Change Button C |\n+| manualChangeButtonD | Number | Manual Change Button D |\n+| notification | Number | Notification |\n+| onLevel | Number | On Level |\n+| rampDimmer | Dimmer | Ramp Dimmer |\n+| rampRate | Number | Ramp Rate |\n+| reset | Switch | Reset |\n+| stage1Duration | Number | Stage 1 Duration |\n+| switch | Switch | Switch |\n+| systemMode | Number | System Mode |\n+| tempCelsius | Number | Temperature Celsius |\n+| tempFahrenheit | Number | Temperature Fahrenheit |\n+| topOutlet | Switch | Top Outlet |\n+| update | Switch | Update |\n+| watts | Number | Watts |\n+\n+\n+## Full Example\n+\n+Sample things file:\n+\n+```\n+Bridge insteon:network:local [port=\"/dev/ttyUSB0\"] {\n+  Thing device 22F8A8 [address=\"22.F8.A8\", productKey=\"F00.00.15\"] {\n+    Channels:\n+      Type switch : keypadButtonA [ group=3 ]\n+      Type switch : keypadButtonB [ group=4 ]\n+      Type switch : keypadButtonC [ group=5 ]\n+      Type switch : keypadButtonD [ group=6 ]\n+  }\n+  Thing device 238D93 [address=\"23.8D.93\", productKey=\"F00.00.12\"]\n+  Thing device 238F55 [address=\"23.8F.55\", productKey=\"F00.00.11\"] {\n+    Channels:\n+      Type dimmer : dimmer [related=\"23.B0.D9+23.8F.C9\"]\n+  }\n+  Thing device 238FC9 [address=\"23.8F.C9\", productKey=\"F00.00.11\"] {\n+    Channels:\n+      Type dimmer : dimmer [related=\"23.8F.55+23.B0.D9\"]\n+  }\n+  Thing device 23B0D9 [address=\"23.B0.D9\", productKey=\"F00.00.11\"] {\n+    Channels:\n+      Type dimmer : dimmer [related=\"23.8F.55+23.8F.C9\"]\n+  }\n+  Thing device 243141 [address=\"24.31.41\", productKey=\"F00.00.11\"]  {\n+    Channels:\n+      Type dimmer : dimmer [dimmermax=60]\n+  }\n+}\n+```\n+\n+Sample items file:\n+\n+```\n+Switch switch1 { channel=\"insteon:device:local:243141:switch\" }\n+Dimmer dimmer1 { channel=\"insteon:device:local:238F55:dimmer\" }\n+Dimmer dimmer2 { channel=\"insteon:device:local:23B0D9:dimmer\" }\n+Dimmer dimmer3 { channel=\"insteon:device:local:238FC9:dimmer\" }\n+Dimmer keypad  { channel=\"insteon:device:local:22F8A8:loadDimmer\" }\n+Switch keypadA { channel=\"insteon:device:local:22F8A8:keypadButtonA\" }\n+Switch keypadB { channel=\"insteon:device:local:22F8A8:keypadButtonB\" }\n+Switch keypadC { channel=\"insteon:device:local:22F8A8:keypadButtonC\" }\n+Switch keypadD { channel=\"insteon:device:local:22F8A8:keypadButtonD\" }\n+Dimmer dimmer  { channel=\"insteon:device:local:238D93:dimmer\" }\n+```\n+\n+## Insteon Groups and Scenes\n+\n+How do Insteon devices tell other devices on the network that their state has changed? They send out a broadcast message, labeled with a specific *group* number. All devices (called *responders*) that are configured to listen to this message will then go into a pre-defined state. For instance when light switch A is switched to \"ON\", it will send out a message to group #1, and all responders will react to it, e.g they may go into the \"ON\" position as well. Since more than one device can participate, the sending out of the broadcast message and the subsequent state change of the responders is referred to as \"triggering a scene\". At the device and PLM level, the concept of a \"scene\" does not exist, so you will find it notably absent in the binding code and this document. A scene is strictly a higher level concept, introduced to shield the user from the details of how the communication is implemented.\n+\n+Many Insteon devices send out messages on different group numbers, depending on what happens to them. A leak sensor may send out a message on group #1 when dry, and on group #2 when wet. The default group used for e.g. linking two light switches is usually group #1.\n+\n+## Insteon binding process\n+\n+Before Insteon devices communicate with one another, they must be linked. During the linking process, one of the devices will be the \"Controller\", the other the \"Responder\" (see e.g. the [SwitchLinc Instructions](https://www.insteon.com/pdf/2477S.pdf)).\n+\n+The responder listens to messages from the controller, and reacts to them. Note that except for the case of a motion detector (which is just a controller to the modem), the modem controls the device (e.g. send on/off messages to it), and the device controls the modem (so the modem learns about the switch being toggled). For this reason, most devices and in particular switches/dimmers should be linked twice, with one taking the role of controller during the first linking, and the other acting as controller during the second linking process. To do so, first press and hold the \"Set\" button on the modem until the light starts blinking. Then press and hold the \"Set\" button on the remote device,\n+e.g. the light switch, until it double beeps (the light on the modem should go off as well). Now do exactly the reverse: press and hold the \"Set\" button on the remote device until its light starts blinking, then press and hold the \"Set\" button on the modem until it double beeps, and the light of the remote device (switch) goes off. Done.\n+\n+For some of the more sophisticated devices the complete linking process can no longer be done with the set buttons, but requires software like e.g. [Insteon Terminal](https://github.com/pfrommerd/insteon-terminal).\n+\n+## Insteon Features\n+\n+Since Insteon devices can have multiple features (for instance a switchable relay and a contact sensor) under a single Insteon address, an openHAB item is not bound to a device, but to a given feature of a device. For example, the following lines would create two Number items referring to the same thermostat device, but to different features of it:\n+\n+```\n+Number  thermostatCoolPoint \"cool point [%.1f \u00b0F]\" { channel=\"insteon:device:local:32F422:coolSetPoint\" }\n+Number  thermostatHeatPoint \"heat point [%.1f \u00b0F]\" { channel=\"insteon:device:local:32F422:heatSetPoint\" }\n+```\n+\n+### Simple light switches\n+\n+The following example shows how to configure a simple light switch (2477S) in the .items file:\n+\n+```\n+Switch officeLight \"office light\"  { channel=\"insteon:device:local:AABBCC:switch\" }\n+```\n+\n+### Simple dimmers\n+\n+Here is how to configure a simple dimmer (2477D) in the .items file:\n+\n+```\n+Dimmer kitchenChandelier \"kitchen chandelier\" { channel=\"insteon:device:local:AABBCC:dimmer\" }\n+```\n+\n+Dimmers can be configured with a maximum level when turning a device on or setting a percentage level. If a maximum level is configured, openHAB will never set the level of the dimmer above the level specified. The parameter dimmermax must be defined for the channel. The below example sets a maximum level of 70% for dim 1 and 60% for dim 2:\n+\n+**Things**\n+\n+```\n+Bridge insteon:network:local [port=\"/dev/ttyUSB0\"] {\n+  Thing device AABBCC [address=\"AA.BB.CC\", productKey=\"F00.00.11\"]  {\n+    Channels:\n+      Type dimmer : dimmer [dimmermax=70]\n+  }\n+  Thing device AABBCD [address=\"AA.BB.CD\", productKey=\"F00.00.15\"]  {\n+    Channels:\n+      Type dimmer : loadDimmer [dimmermax=60]\n+  }\n+}\n+```\n+\n+**Items**\n+\n+```\n+Dimmer d1 \"dimmer 1\" { channel=\"insteon:device:local:AABBCC:dimmer\"}\n+Dimmer d2 \"dimmer 2\" { channel=\"insteon:device:local:AABBCD:loadDimmer\"}\n+```\n+\n+Setting a maximum level does not affect manual turning on or dimming a switch.\n+\n+### On/Off Outlets\n+\n+Here's how to configure the top and bottom outlet of the in-wall 2 outlet controller:\n+\n+```\n+Switch fOutTop \"Front Outlet Top\"    <socket> { channel=\"insteon:device:local:AABBCC:topOutlet\" }\n+Switch fOutBot \"Front Outlet Bottom\" <socket> { channel=\"insteon:device:local:AABBCC:bottomOutlet\" }\n+```\n+\n+This will give you individual control of each outlet.\n+    \n+### Mini remotes\n+\n+Link the mini remote to be a controller of the modem by using the set button. Link all buttons, one after the other. The 4-button mini remote sends out messages on groups 0x01 - 0x04, each corresponding to one button. The modem's link database (see [Insteon Terminal](https://github.com/pfrommerd/insteon-terminal)) should look like this:\n+\n+```\n+    0000 xx.xx.xx                       xx.xx.xx  RESP  10100010 group: 01 data: 02 2c 41\n+    0000 xx.xx.xx                       xx.xx.xx  RESP  10100010 group: 02 data: 02 2c 41\n+    0000 xx.xx.xx                       xx.xx.xx  RESP  10100010 group: 03 data: 02 2c 41\n+    0000 xx.xx.xx                       xx.xx.xx  RESP  10100010 group: 04 data: 02 2c 41\n+```\n+\n+**Items**\n+This goes into the items file:\n+\n+```\n+    Switch miniRemoteButtonA \"mini remote button a\" { channel=\"insteon:device:local:AABBCC:buttonA\", autoupdate=\"false\" }\n+    Switch miniRemoteButtonB \"mini remote button b\" { channel=\"insteon:device:local:AABBCC:buttonB\", autoupdate=\"false\" }\n+    Switch miniRemoteButtonC \"mini remote button c\" { channel=\"insteon:device:local:AABBCC:buttonC\", autoupdate=\"false\" }\n+    Switch miniRemoteButtonD \"mini remote button d\" { channel=\"insteon:device:local:AABBCC:buttonD\", autoupdate=\"false\" }\n+```\n+\n+**Sitemap**\n+This goes into the sitemap file:\n+\n+```\n+    Switch item=miniRemoteButtonA label=\"mini remote button a\" mappings=[ OFF=\"Off\", ON=\"On\"]\n+    Switch item=miniRemoteButtonB label=\"mini remote button b\" mappings=[ OFF=\"Off\", ON=\"On\"]\n+    Switch item=miniRemoteButtonC label=\"mini remote button c\" mappings=[ OFF=\"Off\", ON=\"On\"]\n+    Switch item=miniRemoteButtonD label=\"mini remote button d\" mappings=[ OFF=\"Off\", ON=\"On\"]\n+```\n+\n+The switches in the GUI just display the mini remote's most recent button presses. They are not operable because the PLM cannot trigger the mini remotes scenes.\n+\n+### Motion sensors", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "04a9796d14dfbc5f3ff997d872f04b6d03ee411d"}, "originalPosition": 327}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTMxNjcxMQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            ### Hidden door sensors\n          \n          \n            \n            ### Hidden Door Sensors", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r389316711", "createdAt": "2020-03-07T22:25:48Z", "author": {"login": "kaikreuzer"}, "path": "bundles/org.openhab.binding.insteon/README.md", "diffHunk": "@@ -0,0 +1,719 @@\n+# Insteon Binding\n+\n+Insteon is a home area networking technology developed primarily for connecting light switches and loads. Insteon devices send messages either via the power line, or by means of radio frequency (RF) waves, or both (dual-band). A considerable number of Insteon compatible devices such as switchable relays, thermostats, sensors etc are available. More about Insteon can be found on [Wikipedia](http://en.wikipedia.org/wiki/Insteon).\n+\n+This binding provides access to the Insteon network by means of either an Insteon PowerLinc Modem (PLM), a legacy Insteon Hub 2242-222 or the current 2245-222 Insteon Hub. The modem can be connected to the openHAB server either via a serial port (Model 2413S) or a USB port (Model 2413U). The Insteon PowerLinc Controller (Model 2414U) is not supported since it is a PLC not a PLM. The modem can also be connected via TCP (such as ser2net).  The binding translates openHAB commands into Insteon messages and sends them on the Insteon network. Relevant messages from the Insteon network (like notifications about switches being toggled) are picked up by the modem and converted to openHAB status updates by the binding. The binding also supports sending and receiving of legacy X10 messages.\n+\n+The binding does not support linking new devices on the fly, i.e. all devices must be linked with the modem *before* starting the Insteon binding.\n+\n+openHAB is not a configuration tool! To configure and set up your devices, link the devices manually via the set buttons, or use the free [Insteon Terminal](https://github.com/pfrommerd/insteon-terminal) software. The free HouseLinc software from Insteon can also be used for configuration, but it wipes the modem link database clean on its initial use, requiring to re-link the modem to all devices.\n+\n+## Supported Things\n+\n+| Thing  | Type   | Description                  |\n+|----------|--------|------------------------------|\n+| network  | Bridge | An insteon PLM or hub that is used to communicate with the Insteon devices |\n+|device| Thing | Insteon devices such as dimmers, keypads, sensors, etc. |\n+\n+## Discovery\n+\n+The binding will automatically add the network bridge called local to the Paper UI inbox. Upon proper configuration of the network bridge, the network device database will be downloaded. Any Insteon device that exists in the database and is not currently configured will get added to the inbox.  The naming convention is **Insteon Device AABBCC**, where AA, BB and CC are from the Insteon device address.  X10 devices are not auto discovered. \n+\n+## Thing Configuration\n+\n+###### Network Configuration\n+\n+The Insteon PLM or hub is configured with the following:\n+\n+| Parameter | Default | Required | Description |\n+|----------|---------:|--------:|-------------|\n+| port   |         |   Yes    | **Examples:**<br>- PLM on  Linux: `/dev/ttyS0` or `/dev/ttyUSB0`<br>- Smartenit ZBPLM on Linux: `/dev/ttyUSB0,baudRate=115200`<br>- PLM on Windows: `COM1`<br>- Current  hub (2245-222) at 192.168.1.100 on port 25105, with a poll interval of 1000 ms (1 second): `/hub2/my_user_name:my_password@192.168.1.100:25105,poll_time=1000`<br>- Legacy hub (2242-222) at 192.168.1.100 on port 9761:`/hub/192.168.1.100:9761`<br>- Networked PLM using ser2net at 192.168.1.100 on port 9761:`/tcp/192.168.1.100:9761` |\n+| devicePollIntervalSeconds | 300 |  No  | Poll interval of devices in seconds. Poll too often and you will overload the insteon network, leading to sluggish or no response when trying to send messages to devices. The default poll interval of 300 seconds has been tested and found to be a good compromise in a configuration of about 110 switches/dimmers. |\n+|modemDbRetryTimeoutSeconds|120|No|The number of seconds to wait for the modem database to completely download before retrying again.  Under normal circumstances this will not need to be modified.|\n+| additionalDevices | |       No     | Optional file with additional device types. The syntax of the file is identical to the `device_types.xml` file in the source tree. Please remember to post successfully added device types to the openhab group so the developers can include them into the `device_types.xml` file! |\n+| additionalFeatures | |      No     | Optional file with additional feature templates, like in the `device_features.xml` file in the source tree. |\n+\n+>NOTE: For users upgrading from InsteonPLM, The parameter port_1 is now port. \n+\n+###### Device Configuration\n+\n+The Insteon device is configured with the following required parameters:\n+\n+| Parameter | Description |\n+|----------|-------------|\n+|address|Insteon or X10 address of the device. Insteon device addresses are in the format 'xx.xx.xx', and can be found on the device. X10 device address are in the format 'x.y' and are typically configured on the device.|\n+|productKey|Insteon binding product key that is used to identy the device. Every Insteon device type is uniquely identified by its Insteon product key, typically a six digit hex number. For some of the older device types (in particular the SwitchLinc switches and dimmers), Insteon does not give a product key, so an arbitrary fake one of the format Fxx.xx.xx (or Xxx.xx.xx for X10 devices) is assigned by the binding.|\n+\n+The following is a list of the product keys and associated devices. These have been tested and should work out of the box:\n+\n+| Model | Description | Product Key | tested by |\n+|-------|-------------|-------------|-----------|\n+| 2477D | SwitchLinc Dimmer | F00.00.01 | Bernd Pfrommer |\n+| 2477S | SwitchLinc Switch | F00.00.02 | Bernd Pfrommer |\n+| 2845-222 | Hidden Door Sensor | F00.00.03 | Josenivaldo Benito |\n+| 2876S | ICON Switch | F00.00.04 | Patrick Giasson |\n+| 2456D3 | LampLinc V2 | F00.00.05 | Patrick Giasson |\n+| 2442-222 | Micro Dimmer | F00.00.06 | Josenivaldo Benito |\n+| 2453-222 | DIN Rail On/Off | F00.00.07 | Josenivaldo Benito |\n+| 2452-222 | DIN Rail Dimmer | F00.00.08 | Josenivaldo Benito |\n+| 2458-A1 | MorningLinc RF Lock Controller | F00.00.09 | cdeadlock |\n+| 2852-222 | Leak Sensor | F00.00.0A | Kirk McCann |\n+| 2672-422 | LED Dimmer | F00.00.0B | ??? |\n+| 2476D | SwitchLinc Dimmer | F00.00.0C | LiberatorUSA |\n+| 2634-222 | On/Off Dual-Band Outdoor Module | F00.00.0D | LiberatorUSA |\n+| 2342-2 | Mini Remote | F00.00.10 | Bernd Pfrommer |\n+| 2663-222 | On/Off Outlet | 0x000039 | SwissKid |\n+| 2466D | ToggleLinc Dimmer | F00.00.11 | Rob Nielsen |\n+| 2466S | ToggleLinc Switch | F00.00.12 | Rob Nielsen |\n+| 2672-222 | LED Bulb | F00.00.13 | Rob Nielsen |\n+| 2487S | KeypadLinc On/Off 6-Button | F00.00.14 | Bernd Pfrommer |\n+| 2334-232 | KeypadLink Dimmer 6-Button | F00.00.15 | Rob Nielsen |\n+| 2334-232 | KeypadLink Dimmer 8-Button | F00.00.16 | Rob Nielsen |\n+| 2423A1 | iMeter Solo Power Meter | F00.00.17 | Rob Nielsen |\n+| 2423A1 | Thermostat 2441TH | F00.00.18 | Daniel Campbell, Bernd Pfrommer |\n+| 2457D2 | LampLinc Dimmer | F00.00.19 | Jonathan Huizingh |\n+| 2475SDB | In-LineLinc Relay | F00.00.1A | Jim Howard |\n+| 2635-222 | On/Off Module | F00.00.1B | Jonathan Huizingh |\n+| 2475F | FanLinc Module | F00.00.1C | Brian Tillman |\n+| 2456S3 | ApplianceLinc | F00.00.1D | ??? |\n+| 2674-222 | LED Bulb (recessed) | F00.00.1E | Steve Bate |\n+| 2477SA1 | 220V 30-amp Load Controller N/O | F00.00.1F | Shawn R. |\n+| 2342-222 | Mini Remote (8 Button) | F00.00.20 | Bernd Pfrommer |\n+| 2441V | Insteon Thermostat Adaptor for Venstar | F00.00.21 | Bernd Pfrommer |\n+| 2982-222 | Insteon Smoke Bridge | F00.00.22 | Bernd Pfrommer |\n+| 2450 | IO Link | 0x00001A | Bernd Pfrommer |\n+| 2486D | KeypadLinc Dimmer | 0x000037 | Patrick Giasson, Joe Barnum |\n+| 2484DWH8 | KeypadLinc Countdown Timer | 0x000041 | Rob Nielsen |\n+| 2413U | PowerLinc 2413U USB modem | 0x000045 | Bernd Pfrommer |\n+| 2843-222 | Wireless Open/Close Sensor | 0x000049 | Josenivaldo Benito |\n+| 2842-222 | Motion Sensor | 0x00004A | Bernd Pfrommer |\n+| 2486DWH8 | KeypadLinc Dimmer | 0x000051 | Chris Graham |\n+| 2472D | OutletLincDimmer | 0x000068 | Chris Graham |\n+| X10 switch | generic X10 switch | X00.00.01 | Bernd Pfrommer |\n+| X10 dimmer | generic X10 dimmer | X00.00.02 | Bernd Pfrommer |\n+| X10 motion | generic X10 motion sensor | X00.00.03 | Bernd Pfrommer |\n+\n+## Channels\n+\n+Below is the list of possible channels for the Insteon devices. In order to determing which channels a device supports, you can either look at the device in Paper UI, or find it in the openhab log file.\n+\n+| channel  | type   | description                  |\n+|----------|--------|------------------------------|\n+| acDelay | Number | AC Delay |\n+| backlightDuration | Number | Back Light Duration |\n+| batteryLevel | Number | Battery Level |\n+| batteryWatermarkLevel | Number | Battery Watermark Level |\n+| bottomOutlet | Switch | Bottom Outlet |\n+| buttonA | Switch | Button A |\n+| buttonB | Switch | Button B |\n+| buttonC | Switch | Button C |\n+| buttonD | Switch | Button D |\n+| buttonE | Switch | Button E |\n+| buttonF | Switch | Button F |\n+| buttonG | Switch | Button G |\n+| buttonH | Switch | Button H |\n+| broadcastOnOff | Switch | Broadcast On/Off |\n+| contact | Contact | Contact |\n+| coolSetPoint | Number | Cool Set Point |\n+| dimmer | Dimmer | Dimmer |\n+| fan | Number | Fan |\n+| fanMode | Number | Fan Mode |\n+| fastOnOff | Switch | Fast On/Off |\n+| fastOnOffButtonA | Switch | Fast On/Off Button A |\n+| fastOnOffButtonB | Switch | Fast On/Off Button B |\n+| fastOnOffButtonC | Switch | Fast On/Off Button C |\n+| fastOnOffButtonD | Switch | Fast On/Off Button D |\n+| heatSetPoint | Number | Heat Set Point |\n+| humidity | Number | Humidity |\n+| humidityHigh | Number | Humidity High |\n+| humidityLow | Number | Humidity Low |\n+| isCooling | Number | Is Cooling |\n+| isHeating | Number | Is Heating |\n+| keypadButtonA | Switch | Keypad Button A |\n+| keypadButtonB | Switch | Keypad Button B |\n+| keypadButtonC | Switch | Keypad Button C |\n+| keypadButtonD | Switch | Keypad Button D |\n+| keypadButtonE | Switch | Keypad Button E |\n+| keypadButtonF | Switch | Keypad Button F |\n+| keypadButtonG | Switch | Keypad Button G |\n+| keypadButtonH | Switch | Keypad Button H |\n+| kWh | Number | Kilowatt Hour |\n+| lastHeardFrom | DateTime | Last Heard From |\n+| ledBrightness | Number | LED brightness |\n+| lightDimmer | Dimmer | light Dimmer |\n+| lightLevel | Number | Light Level |\n+| loadDimmer | Dimmer | Load Dimmer |\n+| loadSwitch | Switch | Load Switch |\n+| loadSwitchFastOnOff | Switch | Load Switch Fast On/Off |\n+| loadSwitchManualChange | Number | Load Switch Manual Change |\n+| manualChange | Number | Manual Change |\n+| manualChangeButtonA | Number | Manual Change Button A |\n+| manualChangeButtonB | Number | Manual Change Button B |\n+| manualChangeButtonC | Number | Manual Change Button C |\n+| manualChangeButtonD | Number | Manual Change Button D |\n+| notification | Number | Notification |\n+| onLevel | Number | On Level |\n+| rampDimmer | Dimmer | Ramp Dimmer |\n+| rampRate | Number | Ramp Rate |\n+| reset | Switch | Reset |\n+| stage1Duration | Number | Stage 1 Duration |\n+| switch | Switch | Switch |\n+| systemMode | Number | System Mode |\n+| tempCelsius | Number | Temperature Celsius |\n+| tempFahrenheit | Number | Temperature Fahrenheit |\n+| topOutlet | Switch | Top Outlet |\n+| update | Switch | Update |\n+| watts | Number | Watts |\n+\n+\n+## Full Example\n+\n+Sample things file:\n+\n+```\n+Bridge insteon:network:local [port=\"/dev/ttyUSB0\"] {\n+  Thing device 22F8A8 [address=\"22.F8.A8\", productKey=\"F00.00.15\"] {\n+    Channels:\n+      Type switch : keypadButtonA [ group=3 ]\n+      Type switch : keypadButtonB [ group=4 ]\n+      Type switch : keypadButtonC [ group=5 ]\n+      Type switch : keypadButtonD [ group=6 ]\n+  }\n+  Thing device 238D93 [address=\"23.8D.93\", productKey=\"F00.00.12\"]\n+  Thing device 238F55 [address=\"23.8F.55\", productKey=\"F00.00.11\"] {\n+    Channels:\n+      Type dimmer : dimmer [related=\"23.B0.D9+23.8F.C9\"]\n+  }\n+  Thing device 238FC9 [address=\"23.8F.C9\", productKey=\"F00.00.11\"] {\n+    Channels:\n+      Type dimmer : dimmer [related=\"23.8F.55+23.B0.D9\"]\n+  }\n+  Thing device 23B0D9 [address=\"23.B0.D9\", productKey=\"F00.00.11\"] {\n+    Channels:\n+      Type dimmer : dimmer [related=\"23.8F.55+23.8F.C9\"]\n+  }\n+  Thing device 243141 [address=\"24.31.41\", productKey=\"F00.00.11\"]  {\n+    Channels:\n+      Type dimmer : dimmer [dimmermax=60]\n+  }\n+}\n+```\n+\n+Sample items file:\n+\n+```\n+Switch switch1 { channel=\"insteon:device:local:243141:switch\" }\n+Dimmer dimmer1 { channel=\"insteon:device:local:238F55:dimmer\" }\n+Dimmer dimmer2 { channel=\"insteon:device:local:23B0D9:dimmer\" }\n+Dimmer dimmer3 { channel=\"insteon:device:local:238FC9:dimmer\" }\n+Dimmer keypad  { channel=\"insteon:device:local:22F8A8:loadDimmer\" }\n+Switch keypadA { channel=\"insteon:device:local:22F8A8:keypadButtonA\" }\n+Switch keypadB { channel=\"insteon:device:local:22F8A8:keypadButtonB\" }\n+Switch keypadC { channel=\"insteon:device:local:22F8A8:keypadButtonC\" }\n+Switch keypadD { channel=\"insteon:device:local:22F8A8:keypadButtonD\" }\n+Dimmer dimmer  { channel=\"insteon:device:local:238D93:dimmer\" }\n+```\n+\n+## Insteon Groups and Scenes\n+\n+How do Insteon devices tell other devices on the network that their state has changed? They send out a broadcast message, labeled with a specific *group* number. All devices (called *responders*) that are configured to listen to this message will then go into a pre-defined state. For instance when light switch A is switched to \"ON\", it will send out a message to group #1, and all responders will react to it, e.g they may go into the \"ON\" position as well. Since more than one device can participate, the sending out of the broadcast message and the subsequent state change of the responders is referred to as \"triggering a scene\". At the device and PLM level, the concept of a \"scene\" does not exist, so you will find it notably absent in the binding code and this document. A scene is strictly a higher level concept, introduced to shield the user from the details of how the communication is implemented.\n+\n+Many Insteon devices send out messages on different group numbers, depending on what happens to them. A leak sensor may send out a message on group #1 when dry, and on group #2 when wet. The default group used for e.g. linking two light switches is usually group #1.\n+\n+## Insteon binding process\n+\n+Before Insteon devices communicate with one another, they must be linked. During the linking process, one of the devices will be the \"Controller\", the other the \"Responder\" (see e.g. the [SwitchLinc Instructions](https://www.insteon.com/pdf/2477S.pdf)).\n+\n+The responder listens to messages from the controller, and reacts to them. Note that except for the case of a motion detector (which is just a controller to the modem), the modem controls the device (e.g. send on/off messages to it), and the device controls the modem (so the modem learns about the switch being toggled). For this reason, most devices and in particular switches/dimmers should be linked twice, with one taking the role of controller during the first linking, and the other acting as controller during the second linking process. To do so, first press and hold the \"Set\" button on the modem until the light starts blinking. Then press and hold the \"Set\" button on the remote device,\n+e.g. the light switch, until it double beeps (the light on the modem should go off as well). Now do exactly the reverse: press and hold the \"Set\" button on the remote device until its light starts blinking, then press and hold the \"Set\" button on the modem until it double beeps, and the light of the remote device (switch) goes off. Done.\n+\n+For some of the more sophisticated devices the complete linking process can no longer be done with the set buttons, but requires software like e.g. [Insteon Terminal](https://github.com/pfrommerd/insteon-terminal).\n+\n+## Insteon Features\n+\n+Since Insteon devices can have multiple features (for instance a switchable relay and a contact sensor) under a single Insteon address, an openHAB item is not bound to a device, but to a given feature of a device. For example, the following lines would create two Number items referring to the same thermostat device, but to different features of it:\n+\n+```\n+Number  thermostatCoolPoint \"cool point [%.1f \u00b0F]\" { channel=\"insteon:device:local:32F422:coolSetPoint\" }\n+Number  thermostatHeatPoint \"heat point [%.1f \u00b0F]\" { channel=\"insteon:device:local:32F422:heatSetPoint\" }\n+```\n+\n+### Simple light switches\n+\n+The following example shows how to configure a simple light switch (2477S) in the .items file:\n+\n+```\n+Switch officeLight \"office light\"  { channel=\"insteon:device:local:AABBCC:switch\" }\n+```\n+\n+### Simple dimmers\n+\n+Here is how to configure a simple dimmer (2477D) in the .items file:\n+\n+```\n+Dimmer kitchenChandelier \"kitchen chandelier\" { channel=\"insteon:device:local:AABBCC:dimmer\" }\n+```\n+\n+Dimmers can be configured with a maximum level when turning a device on or setting a percentage level. If a maximum level is configured, openHAB will never set the level of the dimmer above the level specified. The parameter dimmermax must be defined for the channel. The below example sets a maximum level of 70% for dim 1 and 60% for dim 2:\n+\n+**Things**\n+\n+```\n+Bridge insteon:network:local [port=\"/dev/ttyUSB0\"] {\n+  Thing device AABBCC [address=\"AA.BB.CC\", productKey=\"F00.00.11\"]  {\n+    Channels:\n+      Type dimmer : dimmer [dimmermax=70]\n+  }\n+  Thing device AABBCD [address=\"AA.BB.CD\", productKey=\"F00.00.15\"]  {\n+    Channels:\n+      Type dimmer : loadDimmer [dimmermax=60]\n+  }\n+}\n+```\n+\n+**Items**\n+\n+```\n+Dimmer d1 \"dimmer 1\" { channel=\"insteon:device:local:AABBCC:dimmer\"}\n+Dimmer d2 \"dimmer 2\" { channel=\"insteon:device:local:AABBCD:loadDimmer\"}\n+```\n+\n+Setting a maximum level does not affect manual turning on or dimming a switch.\n+\n+### On/Off Outlets\n+\n+Here's how to configure the top and bottom outlet of the in-wall 2 outlet controller:\n+\n+```\n+Switch fOutTop \"Front Outlet Top\"    <socket> { channel=\"insteon:device:local:AABBCC:topOutlet\" }\n+Switch fOutBot \"Front Outlet Bottom\" <socket> { channel=\"insteon:device:local:AABBCC:bottomOutlet\" }\n+```\n+\n+This will give you individual control of each outlet.\n+    \n+### Mini remotes\n+\n+Link the mini remote to be a controller of the modem by using the set button. Link all buttons, one after the other. The 4-button mini remote sends out messages on groups 0x01 - 0x04, each corresponding to one button. The modem's link database (see [Insteon Terminal](https://github.com/pfrommerd/insteon-terminal)) should look like this:\n+\n+```\n+    0000 xx.xx.xx                       xx.xx.xx  RESP  10100010 group: 01 data: 02 2c 41\n+    0000 xx.xx.xx                       xx.xx.xx  RESP  10100010 group: 02 data: 02 2c 41\n+    0000 xx.xx.xx                       xx.xx.xx  RESP  10100010 group: 03 data: 02 2c 41\n+    0000 xx.xx.xx                       xx.xx.xx  RESP  10100010 group: 04 data: 02 2c 41\n+```\n+\n+**Items**\n+This goes into the items file:\n+\n+```\n+    Switch miniRemoteButtonA \"mini remote button a\" { channel=\"insteon:device:local:AABBCC:buttonA\", autoupdate=\"false\" }\n+    Switch miniRemoteButtonB \"mini remote button b\" { channel=\"insteon:device:local:AABBCC:buttonB\", autoupdate=\"false\" }\n+    Switch miniRemoteButtonC \"mini remote button c\" { channel=\"insteon:device:local:AABBCC:buttonC\", autoupdate=\"false\" }\n+    Switch miniRemoteButtonD \"mini remote button d\" { channel=\"insteon:device:local:AABBCC:buttonD\", autoupdate=\"false\" }\n+```\n+\n+**Sitemap**\n+This goes into the sitemap file:\n+\n+```\n+    Switch item=miniRemoteButtonA label=\"mini remote button a\" mappings=[ OFF=\"Off\", ON=\"On\"]\n+    Switch item=miniRemoteButtonB label=\"mini remote button b\" mappings=[ OFF=\"Off\", ON=\"On\"]\n+    Switch item=miniRemoteButtonC label=\"mini remote button c\" mappings=[ OFF=\"Off\", ON=\"On\"]\n+    Switch item=miniRemoteButtonD label=\"mini remote button d\" mappings=[ OFF=\"Off\", ON=\"On\"]\n+```\n+\n+The switches in the GUI just display the mini remote's most recent button presses. They are not operable because the PLM cannot trigger the mini remotes scenes.\n+\n+### Motion sensors\n+\n+Link such that the modem is a responder to the motion sensor. Create a contact.map file in the transforms directory as described elsewhere in this document. Then create entries in the .items file like this:\n+\n+**Items**\n+\n+```\n+    Contact motionSensor             \"motion sensor [MAP(contact.map):%s]\" { channel=\"insteon:device:local:AABBCC:contact\"}\n+    Number  motionSensorBatteryLevel \"motion sensor battery level [%.1f]\"  { channel=\"insteon:device:local:AABBCC:batteryLevel\" }\n+    Number  motionSensorLightLevel   \"motion sensor light level [%.1f]\"    { channel=\"insteon:device:local:AABBCC:lightLevel\" }\n+```\n+\n+This will give you a contact, the battery level, and the light level. Note that battery and light level are only updated when either there is motion, or the sensor battery runs low.\n+\n+### Hidden door sensors", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "04a9796d14dfbc5f3ff997d872f04b6d03ee411d"}, "originalPosition": 341}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTMxNjczNA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            #### Keypad switches\n          \n          \n            \n            #### Keypad Switches", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r389316734", "createdAt": "2020-03-07T22:26:12Z", "author": {"login": "kaikreuzer"}, "path": "bundles/org.openhab.binding.insteon/README.md", "diffHunk": "@@ -0,0 +1,719 @@\n+# Insteon Binding\n+\n+Insteon is a home area networking technology developed primarily for connecting light switches and loads. Insteon devices send messages either via the power line, or by means of radio frequency (RF) waves, or both (dual-band). A considerable number of Insteon compatible devices such as switchable relays, thermostats, sensors etc are available. More about Insteon can be found on [Wikipedia](http://en.wikipedia.org/wiki/Insteon).\n+\n+This binding provides access to the Insteon network by means of either an Insteon PowerLinc Modem (PLM), a legacy Insteon Hub 2242-222 or the current 2245-222 Insteon Hub. The modem can be connected to the openHAB server either via a serial port (Model 2413S) or a USB port (Model 2413U). The Insteon PowerLinc Controller (Model 2414U) is not supported since it is a PLC not a PLM. The modem can also be connected via TCP (such as ser2net).  The binding translates openHAB commands into Insteon messages and sends them on the Insteon network. Relevant messages from the Insteon network (like notifications about switches being toggled) are picked up by the modem and converted to openHAB status updates by the binding. The binding also supports sending and receiving of legacy X10 messages.\n+\n+The binding does not support linking new devices on the fly, i.e. all devices must be linked with the modem *before* starting the Insteon binding.\n+\n+openHAB is not a configuration tool! To configure and set up your devices, link the devices manually via the set buttons, or use the free [Insteon Terminal](https://github.com/pfrommerd/insteon-terminal) software. The free HouseLinc software from Insteon can also be used for configuration, but it wipes the modem link database clean on its initial use, requiring to re-link the modem to all devices.\n+\n+## Supported Things\n+\n+| Thing  | Type   | Description                  |\n+|----------|--------|------------------------------|\n+| network  | Bridge | An insteon PLM or hub that is used to communicate with the Insteon devices |\n+|device| Thing | Insteon devices such as dimmers, keypads, sensors, etc. |\n+\n+## Discovery\n+\n+The binding will automatically add the network bridge called local to the Paper UI inbox. Upon proper configuration of the network bridge, the network device database will be downloaded. Any Insteon device that exists in the database and is not currently configured will get added to the inbox.  The naming convention is **Insteon Device AABBCC**, where AA, BB and CC are from the Insteon device address.  X10 devices are not auto discovered. \n+\n+## Thing Configuration\n+\n+###### Network Configuration\n+\n+The Insteon PLM or hub is configured with the following:\n+\n+| Parameter | Default | Required | Description |\n+|----------|---------:|--------:|-------------|\n+| port   |         |   Yes    | **Examples:**<br>- PLM on  Linux: `/dev/ttyS0` or `/dev/ttyUSB0`<br>- Smartenit ZBPLM on Linux: `/dev/ttyUSB0,baudRate=115200`<br>- PLM on Windows: `COM1`<br>- Current  hub (2245-222) at 192.168.1.100 on port 25105, with a poll interval of 1000 ms (1 second): `/hub2/my_user_name:my_password@192.168.1.100:25105,poll_time=1000`<br>- Legacy hub (2242-222) at 192.168.1.100 on port 9761:`/hub/192.168.1.100:9761`<br>- Networked PLM using ser2net at 192.168.1.100 on port 9761:`/tcp/192.168.1.100:9761` |\n+| devicePollIntervalSeconds | 300 |  No  | Poll interval of devices in seconds. Poll too often and you will overload the insteon network, leading to sluggish or no response when trying to send messages to devices. The default poll interval of 300 seconds has been tested and found to be a good compromise in a configuration of about 110 switches/dimmers. |\n+|modemDbRetryTimeoutSeconds|120|No|The number of seconds to wait for the modem database to completely download before retrying again.  Under normal circumstances this will not need to be modified.|\n+| additionalDevices | |       No     | Optional file with additional device types. The syntax of the file is identical to the `device_types.xml` file in the source tree. Please remember to post successfully added device types to the openhab group so the developers can include them into the `device_types.xml` file! |\n+| additionalFeatures | |      No     | Optional file with additional feature templates, like in the `device_features.xml` file in the source tree. |\n+\n+>NOTE: For users upgrading from InsteonPLM, The parameter port_1 is now port. \n+\n+###### Device Configuration\n+\n+The Insteon device is configured with the following required parameters:\n+\n+| Parameter | Description |\n+|----------|-------------|\n+|address|Insteon or X10 address of the device. Insteon device addresses are in the format 'xx.xx.xx', and can be found on the device. X10 device address are in the format 'x.y' and are typically configured on the device.|\n+|productKey|Insteon binding product key that is used to identy the device. Every Insteon device type is uniquely identified by its Insteon product key, typically a six digit hex number. For some of the older device types (in particular the SwitchLinc switches and dimmers), Insteon does not give a product key, so an arbitrary fake one of the format Fxx.xx.xx (or Xxx.xx.xx for X10 devices) is assigned by the binding.|\n+\n+The following is a list of the product keys and associated devices. These have been tested and should work out of the box:\n+\n+| Model | Description | Product Key | tested by |\n+|-------|-------------|-------------|-----------|\n+| 2477D | SwitchLinc Dimmer | F00.00.01 | Bernd Pfrommer |\n+| 2477S | SwitchLinc Switch | F00.00.02 | Bernd Pfrommer |\n+| 2845-222 | Hidden Door Sensor | F00.00.03 | Josenivaldo Benito |\n+| 2876S | ICON Switch | F00.00.04 | Patrick Giasson |\n+| 2456D3 | LampLinc V2 | F00.00.05 | Patrick Giasson |\n+| 2442-222 | Micro Dimmer | F00.00.06 | Josenivaldo Benito |\n+| 2453-222 | DIN Rail On/Off | F00.00.07 | Josenivaldo Benito |\n+| 2452-222 | DIN Rail Dimmer | F00.00.08 | Josenivaldo Benito |\n+| 2458-A1 | MorningLinc RF Lock Controller | F00.00.09 | cdeadlock |\n+| 2852-222 | Leak Sensor | F00.00.0A | Kirk McCann |\n+| 2672-422 | LED Dimmer | F00.00.0B | ??? |\n+| 2476D | SwitchLinc Dimmer | F00.00.0C | LiberatorUSA |\n+| 2634-222 | On/Off Dual-Band Outdoor Module | F00.00.0D | LiberatorUSA |\n+| 2342-2 | Mini Remote | F00.00.10 | Bernd Pfrommer |\n+| 2663-222 | On/Off Outlet | 0x000039 | SwissKid |\n+| 2466D | ToggleLinc Dimmer | F00.00.11 | Rob Nielsen |\n+| 2466S | ToggleLinc Switch | F00.00.12 | Rob Nielsen |\n+| 2672-222 | LED Bulb | F00.00.13 | Rob Nielsen |\n+| 2487S | KeypadLinc On/Off 6-Button | F00.00.14 | Bernd Pfrommer |\n+| 2334-232 | KeypadLink Dimmer 6-Button | F00.00.15 | Rob Nielsen |\n+| 2334-232 | KeypadLink Dimmer 8-Button | F00.00.16 | Rob Nielsen |\n+| 2423A1 | iMeter Solo Power Meter | F00.00.17 | Rob Nielsen |\n+| 2423A1 | Thermostat 2441TH | F00.00.18 | Daniel Campbell, Bernd Pfrommer |\n+| 2457D2 | LampLinc Dimmer | F00.00.19 | Jonathan Huizingh |\n+| 2475SDB | In-LineLinc Relay | F00.00.1A | Jim Howard |\n+| 2635-222 | On/Off Module | F00.00.1B | Jonathan Huizingh |\n+| 2475F | FanLinc Module | F00.00.1C | Brian Tillman |\n+| 2456S3 | ApplianceLinc | F00.00.1D | ??? |\n+| 2674-222 | LED Bulb (recessed) | F00.00.1E | Steve Bate |\n+| 2477SA1 | 220V 30-amp Load Controller N/O | F00.00.1F | Shawn R. |\n+| 2342-222 | Mini Remote (8 Button) | F00.00.20 | Bernd Pfrommer |\n+| 2441V | Insteon Thermostat Adaptor for Venstar | F00.00.21 | Bernd Pfrommer |\n+| 2982-222 | Insteon Smoke Bridge | F00.00.22 | Bernd Pfrommer |\n+| 2450 | IO Link | 0x00001A | Bernd Pfrommer |\n+| 2486D | KeypadLinc Dimmer | 0x000037 | Patrick Giasson, Joe Barnum |\n+| 2484DWH8 | KeypadLinc Countdown Timer | 0x000041 | Rob Nielsen |\n+| 2413U | PowerLinc 2413U USB modem | 0x000045 | Bernd Pfrommer |\n+| 2843-222 | Wireless Open/Close Sensor | 0x000049 | Josenivaldo Benito |\n+| 2842-222 | Motion Sensor | 0x00004A | Bernd Pfrommer |\n+| 2486DWH8 | KeypadLinc Dimmer | 0x000051 | Chris Graham |\n+| 2472D | OutletLincDimmer | 0x000068 | Chris Graham |\n+| X10 switch | generic X10 switch | X00.00.01 | Bernd Pfrommer |\n+| X10 dimmer | generic X10 dimmer | X00.00.02 | Bernd Pfrommer |\n+| X10 motion | generic X10 motion sensor | X00.00.03 | Bernd Pfrommer |\n+\n+## Channels\n+\n+Below is the list of possible channels for the Insteon devices. In order to determing which channels a device supports, you can either look at the device in Paper UI, or find it in the openhab log file.\n+\n+| channel  | type   | description                  |\n+|----------|--------|------------------------------|\n+| acDelay | Number | AC Delay |\n+| backlightDuration | Number | Back Light Duration |\n+| batteryLevel | Number | Battery Level |\n+| batteryWatermarkLevel | Number | Battery Watermark Level |\n+| bottomOutlet | Switch | Bottom Outlet |\n+| buttonA | Switch | Button A |\n+| buttonB | Switch | Button B |\n+| buttonC | Switch | Button C |\n+| buttonD | Switch | Button D |\n+| buttonE | Switch | Button E |\n+| buttonF | Switch | Button F |\n+| buttonG | Switch | Button G |\n+| buttonH | Switch | Button H |\n+| broadcastOnOff | Switch | Broadcast On/Off |\n+| contact | Contact | Contact |\n+| coolSetPoint | Number | Cool Set Point |\n+| dimmer | Dimmer | Dimmer |\n+| fan | Number | Fan |\n+| fanMode | Number | Fan Mode |\n+| fastOnOff | Switch | Fast On/Off |\n+| fastOnOffButtonA | Switch | Fast On/Off Button A |\n+| fastOnOffButtonB | Switch | Fast On/Off Button B |\n+| fastOnOffButtonC | Switch | Fast On/Off Button C |\n+| fastOnOffButtonD | Switch | Fast On/Off Button D |\n+| heatSetPoint | Number | Heat Set Point |\n+| humidity | Number | Humidity |\n+| humidityHigh | Number | Humidity High |\n+| humidityLow | Number | Humidity Low |\n+| isCooling | Number | Is Cooling |\n+| isHeating | Number | Is Heating |\n+| keypadButtonA | Switch | Keypad Button A |\n+| keypadButtonB | Switch | Keypad Button B |\n+| keypadButtonC | Switch | Keypad Button C |\n+| keypadButtonD | Switch | Keypad Button D |\n+| keypadButtonE | Switch | Keypad Button E |\n+| keypadButtonF | Switch | Keypad Button F |\n+| keypadButtonG | Switch | Keypad Button G |\n+| keypadButtonH | Switch | Keypad Button H |\n+| kWh | Number | Kilowatt Hour |\n+| lastHeardFrom | DateTime | Last Heard From |\n+| ledBrightness | Number | LED brightness |\n+| lightDimmer | Dimmer | light Dimmer |\n+| lightLevel | Number | Light Level |\n+| loadDimmer | Dimmer | Load Dimmer |\n+| loadSwitch | Switch | Load Switch |\n+| loadSwitchFastOnOff | Switch | Load Switch Fast On/Off |\n+| loadSwitchManualChange | Number | Load Switch Manual Change |\n+| manualChange | Number | Manual Change |\n+| manualChangeButtonA | Number | Manual Change Button A |\n+| manualChangeButtonB | Number | Manual Change Button B |\n+| manualChangeButtonC | Number | Manual Change Button C |\n+| manualChangeButtonD | Number | Manual Change Button D |\n+| notification | Number | Notification |\n+| onLevel | Number | On Level |\n+| rampDimmer | Dimmer | Ramp Dimmer |\n+| rampRate | Number | Ramp Rate |\n+| reset | Switch | Reset |\n+| stage1Duration | Number | Stage 1 Duration |\n+| switch | Switch | Switch |\n+| systemMode | Number | System Mode |\n+| tempCelsius | Number | Temperature Celsius |\n+| tempFahrenheit | Number | Temperature Fahrenheit |\n+| topOutlet | Switch | Top Outlet |\n+| update | Switch | Update |\n+| watts | Number | Watts |\n+\n+\n+## Full Example\n+\n+Sample things file:\n+\n+```\n+Bridge insteon:network:local [port=\"/dev/ttyUSB0\"] {\n+  Thing device 22F8A8 [address=\"22.F8.A8\", productKey=\"F00.00.15\"] {\n+    Channels:\n+      Type switch : keypadButtonA [ group=3 ]\n+      Type switch : keypadButtonB [ group=4 ]\n+      Type switch : keypadButtonC [ group=5 ]\n+      Type switch : keypadButtonD [ group=6 ]\n+  }\n+  Thing device 238D93 [address=\"23.8D.93\", productKey=\"F00.00.12\"]\n+  Thing device 238F55 [address=\"23.8F.55\", productKey=\"F00.00.11\"] {\n+    Channels:\n+      Type dimmer : dimmer [related=\"23.B0.D9+23.8F.C9\"]\n+  }\n+  Thing device 238FC9 [address=\"23.8F.C9\", productKey=\"F00.00.11\"] {\n+    Channels:\n+      Type dimmer : dimmer [related=\"23.8F.55+23.B0.D9\"]\n+  }\n+  Thing device 23B0D9 [address=\"23.B0.D9\", productKey=\"F00.00.11\"] {\n+    Channels:\n+      Type dimmer : dimmer [related=\"23.8F.55+23.8F.C9\"]\n+  }\n+  Thing device 243141 [address=\"24.31.41\", productKey=\"F00.00.11\"]  {\n+    Channels:\n+      Type dimmer : dimmer [dimmermax=60]\n+  }\n+}\n+```\n+\n+Sample items file:\n+\n+```\n+Switch switch1 { channel=\"insteon:device:local:243141:switch\" }\n+Dimmer dimmer1 { channel=\"insteon:device:local:238F55:dimmer\" }\n+Dimmer dimmer2 { channel=\"insteon:device:local:23B0D9:dimmer\" }\n+Dimmer dimmer3 { channel=\"insteon:device:local:238FC9:dimmer\" }\n+Dimmer keypad  { channel=\"insteon:device:local:22F8A8:loadDimmer\" }\n+Switch keypadA { channel=\"insteon:device:local:22F8A8:keypadButtonA\" }\n+Switch keypadB { channel=\"insteon:device:local:22F8A8:keypadButtonB\" }\n+Switch keypadC { channel=\"insteon:device:local:22F8A8:keypadButtonC\" }\n+Switch keypadD { channel=\"insteon:device:local:22F8A8:keypadButtonD\" }\n+Dimmer dimmer  { channel=\"insteon:device:local:238D93:dimmer\" }\n+```\n+\n+## Insteon Groups and Scenes\n+\n+How do Insteon devices tell other devices on the network that their state has changed? They send out a broadcast message, labeled with a specific *group* number. All devices (called *responders*) that are configured to listen to this message will then go into a pre-defined state. For instance when light switch A is switched to \"ON\", it will send out a message to group #1, and all responders will react to it, e.g they may go into the \"ON\" position as well. Since more than one device can participate, the sending out of the broadcast message and the subsequent state change of the responders is referred to as \"triggering a scene\". At the device and PLM level, the concept of a \"scene\" does not exist, so you will find it notably absent in the binding code and this document. A scene is strictly a higher level concept, introduced to shield the user from the details of how the communication is implemented.\n+\n+Many Insteon devices send out messages on different group numbers, depending on what happens to them. A leak sensor may send out a message on group #1 when dry, and on group #2 when wet. The default group used for e.g. linking two light switches is usually group #1.\n+\n+## Insteon binding process\n+\n+Before Insteon devices communicate with one another, they must be linked. During the linking process, one of the devices will be the \"Controller\", the other the \"Responder\" (see e.g. the [SwitchLinc Instructions](https://www.insteon.com/pdf/2477S.pdf)).\n+\n+The responder listens to messages from the controller, and reacts to them. Note that except for the case of a motion detector (which is just a controller to the modem), the modem controls the device (e.g. send on/off messages to it), and the device controls the modem (so the modem learns about the switch being toggled). For this reason, most devices and in particular switches/dimmers should be linked twice, with one taking the role of controller during the first linking, and the other acting as controller during the second linking process. To do so, first press and hold the \"Set\" button on the modem until the light starts blinking. Then press and hold the \"Set\" button on the remote device,\n+e.g. the light switch, until it double beeps (the light on the modem should go off as well). Now do exactly the reverse: press and hold the \"Set\" button on the remote device until its light starts blinking, then press and hold the \"Set\" button on the modem until it double beeps, and the light of the remote device (switch) goes off. Done.\n+\n+For some of the more sophisticated devices the complete linking process can no longer be done with the set buttons, but requires software like e.g. [Insteon Terminal](https://github.com/pfrommerd/insteon-terminal).\n+\n+## Insteon Features\n+\n+Since Insteon devices can have multiple features (for instance a switchable relay and a contact sensor) under a single Insteon address, an openHAB item is not bound to a device, but to a given feature of a device. For example, the following lines would create two Number items referring to the same thermostat device, but to different features of it:\n+\n+```\n+Number  thermostatCoolPoint \"cool point [%.1f \u00b0F]\" { channel=\"insteon:device:local:32F422:coolSetPoint\" }\n+Number  thermostatHeatPoint \"heat point [%.1f \u00b0F]\" { channel=\"insteon:device:local:32F422:heatSetPoint\" }\n+```\n+\n+### Simple light switches\n+\n+The following example shows how to configure a simple light switch (2477S) in the .items file:\n+\n+```\n+Switch officeLight \"office light\"  { channel=\"insteon:device:local:AABBCC:switch\" }\n+```\n+\n+### Simple dimmers\n+\n+Here is how to configure a simple dimmer (2477D) in the .items file:\n+\n+```\n+Dimmer kitchenChandelier \"kitchen chandelier\" { channel=\"insteon:device:local:AABBCC:dimmer\" }\n+```\n+\n+Dimmers can be configured with a maximum level when turning a device on or setting a percentage level. If a maximum level is configured, openHAB will never set the level of the dimmer above the level specified. The parameter dimmermax must be defined for the channel. The below example sets a maximum level of 70% for dim 1 and 60% for dim 2:\n+\n+**Things**\n+\n+```\n+Bridge insteon:network:local [port=\"/dev/ttyUSB0\"] {\n+  Thing device AABBCC [address=\"AA.BB.CC\", productKey=\"F00.00.11\"]  {\n+    Channels:\n+      Type dimmer : dimmer [dimmermax=70]\n+  }\n+  Thing device AABBCD [address=\"AA.BB.CD\", productKey=\"F00.00.15\"]  {\n+    Channels:\n+      Type dimmer : loadDimmer [dimmermax=60]\n+  }\n+}\n+```\n+\n+**Items**\n+\n+```\n+Dimmer d1 \"dimmer 1\" { channel=\"insteon:device:local:AABBCC:dimmer\"}\n+Dimmer d2 \"dimmer 2\" { channel=\"insteon:device:local:AABBCD:loadDimmer\"}\n+```\n+\n+Setting a maximum level does not affect manual turning on or dimming a switch.\n+\n+### On/Off Outlets\n+\n+Here's how to configure the top and bottom outlet of the in-wall 2 outlet controller:\n+\n+```\n+Switch fOutTop \"Front Outlet Top\"    <socket> { channel=\"insteon:device:local:AABBCC:topOutlet\" }\n+Switch fOutBot \"Front Outlet Bottom\" <socket> { channel=\"insteon:device:local:AABBCC:bottomOutlet\" }\n+```\n+\n+This will give you individual control of each outlet.\n+    \n+### Mini remotes\n+\n+Link the mini remote to be a controller of the modem by using the set button. Link all buttons, one after the other. The 4-button mini remote sends out messages on groups 0x01 - 0x04, each corresponding to one button. The modem's link database (see [Insteon Terminal](https://github.com/pfrommerd/insteon-terminal)) should look like this:\n+\n+```\n+    0000 xx.xx.xx                       xx.xx.xx  RESP  10100010 group: 01 data: 02 2c 41\n+    0000 xx.xx.xx                       xx.xx.xx  RESP  10100010 group: 02 data: 02 2c 41\n+    0000 xx.xx.xx                       xx.xx.xx  RESP  10100010 group: 03 data: 02 2c 41\n+    0000 xx.xx.xx                       xx.xx.xx  RESP  10100010 group: 04 data: 02 2c 41\n+```\n+\n+**Items**\n+This goes into the items file:\n+\n+```\n+    Switch miniRemoteButtonA \"mini remote button a\" { channel=\"insteon:device:local:AABBCC:buttonA\", autoupdate=\"false\" }\n+    Switch miniRemoteButtonB \"mini remote button b\" { channel=\"insteon:device:local:AABBCC:buttonB\", autoupdate=\"false\" }\n+    Switch miniRemoteButtonC \"mini remote button c\" { channel=\"insteon:device:local:AABBCC:buttonC\", autoupdate=\"false\" }\n+    Switch miniRemoteButtonD \"mini remote button d\" { channel=\"insteon:device:local:AABBCC:buttonD\", autoupdate=\"false\" }\n+```\n+\n+**Sitemap**\n+This goes into the sitemap file:\n+\n+```\n+    Switch item=miniRemoteButtonA label=\"mini remote button a\" mappings=[ OFF=\"Off\", ON=\"On\"]\n+    Switch item=miniRemoteButtonB label=\"mini remote button b\" mappings=[ OFF=\"Off\", ON=\"On\"]\n+    Switch item=miniRemoteButtonC label=\"mini remote button c\" mappings=[ OFF=\"Off\", ON=\"On\"]\n+    Switch item=miniRemoteButtonD label=\"mini remote button d\" mappings=[ OFF=\"Off\", ON=\"On\"]\n+```\n+\n+The switches in the GUI just display the mini remote's most recent button presses. They are not operable because the PLM cannot trigger the mini remotes scenes.\n+\n+### Motion sensors\n+\n+Link such that the modem is a responder to the motion sensor. Create a contact.map file in the transforms directory as described elsewhere in this document. Then create entries in the .items file like this:\n+\n+**Items**\n+\n+```\n+    Contact motionSensor             \"motion sensor [MAP(contact.map):%s]\" { channel=\"insteon:device:local:AABBCC:contact\"}\n+    Number  motionSensorBatteryLevel \"motion sensor battery level [%.1f]\"  { channel=\"insteon:device:local:AABBCC:batteryLevel\" }\n+    Number  motionSensorLightLevel   \"motion sensor light level [%.1f]\"    { channel=\"insteon:device:local:AABBCC:lightLevel\" }\n+```\n+\n+This will give you a contact, the battery level, and the light level. Note that battery and light level are only updated when either there is motion, or the sensor battery runs low.\n+\n+### Hidden door sensors\n+\n+Similar in operation to the motion sensor above.  Link such that the modem is a responder to the motion sensor. Create a contact.map file in the transforms directory like the following:\n+\n+```\n+    OPEN=open\n+    CLOSED=closed\n+    -=unknown\n+```\n+\n+**Items**\n+Then create entries in the .items file like this:\n+\n+```\n+    Contact doorSensor             \"Door sensor [MAP(contact.map):%s]\" { channel=\"insteon:device:local:AABBCC:contact\" }\n+    Number  doorSensorBatteryLevel \"Door sensor battery level [%.1f]\"  { channel=\"insteon:device:local:AABBCC:batteryLevel\" }\n+```\n+\n+This will give you a contact and the battery level. Note that battery level is only updated when either there is motion, or the sensor battery runs low.\n+\n+### Locks\n+\n+Read the instructions very carefully: sync with lock within 5 feet to avoid bad connection, link twice for both ON and OFF functionality.\n+\n+**Items**\n+Put something like this into your .items file:\n+\n+```\n+    Switch doorLock \"Front Door [MAP(lock.map):%s]\"  { channel=\"insteon:device:local:AABBCC:switch\" }\n+```\n+\n+and create a file \"lock.map\" in the transforms directory with these entries: \n+\n+```\n+    ON=Lock\n+    OFF=Unlock\n+    -=unknown\n+```\n+\n+### I/O Linc (garage door openers)\n+\n+The I/O Linc devices are really two devices in one: a relay and a contact. Link the modem both ways, as responder and controller using the set buttons as described in the instructions.\n+\n+Add this map into your transforms directory as \"contact.map\":\n+\n+```\n+    OPEN=open\n+    CLOSED=closed\n+    -=unknown\n+```\n+\n+**Items**\n+Along with this into your .items file:\n+\n+```\n+    Switch  garageDoorOpener  \"garage door opener\"                        <garagedoor>  { channel=\"insteon:device:local:AABBCC:switch\", autoupdate=\"false\" }\n+    Contact garageDoorContact \"garage door contact [MAP(contact.map):%s]\"               { channel=\"insteon:device:local:AABBCC:contact\" }\n+```\n+\n+**Sitemap**\n+To make it visible in the GUI, put this into your sitemap file:\n+\n+```\n+    Switch item=garageDoorOpener label=\"garage door opener\" mappings=[ ON=\"OPEN/CLOSE\"]\n+    Text item=garageDoorContact\n+```\n+\n+For safety reasons, only close the garage door if you have visual contact to make sure there is no obstruction! The use of automated rules for closing garage doors is dangerous.\n+\n+> NOTE: If the I/O Linc returns the wrong value when the device is polled (For example you open the garage door and the state correctly shows OPEN, but during polling it shows CLOSED), you probably linked the device with the PLM or hub when the door was in the wrong position. You need unlink and then link again with the door in the opposite position. Please see the Insteon I/O Linc documentation for further details.\n+\n+### Keypads\n+\n+Before you attempt to configure the keypads, please familiarize yourself with the concept of an Insteon group.\n+\n+The Insteon keypad devices typically control one main load and have a number of buttons that will send out group broadcast messages to trigger a scene. If you just want to use the main load switch within openhab just link modem and device with the set buttons as usual, no complicated linking is necessary. But if you want to get the buttons to work, read on.\n+\n+Each button will send out a message for a different, predefined group. Complicating matters further, the button numbering used internally by the device must be mapped to whatever labels are printed on the physical buttons of the device. Here is an example correspondence table:\n+\n+| Group | Button Number | 2487S Label |\n+|-------|---------------|-------------|\n+|  0x01 |        1      |   (Load)    |\n+|  0x03 |        3      |     A       |\n+|  0x04 |        4      |     B       |\n+|  0x05 |        5      |     C       |\n+|  0x06 |        6      |     D       |\n+\n+When e.g. the \"A\" button is pressed (that's button #3 internally) a broadcast message will be sent out to all responders configured to listen to Insteon group #3. This means you must configure the modem as a responder to group #3 (and #4, #5, #6) messages coming from your keypad. For instructions how to do this, check out the [Insteon Terminal](https://github.com/pfrommerd/insteon-terminal). You can even do that with the set buttons (see instructions that come with the keypad).\n+\n+While capturing the messages that the buttons emit is pretty straight forward, controlling the buttons is  another matter. They cannot be simply toggled with a direct command to the device, but instead a broadcast message must be sent on a group number that the button has been programmed to listen to. This means you need to pick a set of unused groups that is globally unique (if you have multiple keypads, each one of them has to use different groups), one group for each button. The example configuration below uses groups 0xf3, 0xf4, 0xf5, and 0xf6. Then link the buttons such that they respond to those groups, and link the modem as a controller for them (see [Insteon Terminal](https://github.com/pfrommerd/insteon-terminal) documentation). In your items file you specify these groups with the \"group=\" parameters such that the binding knows what group number to put on the outgoing message.\n+\n+\n+#### Keypad switches", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "04a9796d14dfbc5f3ff997d872f04b6d03ee411d"}, "originalPosition": 433}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTMxNjc1MA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            #### Keypad dimmers\n          \n          \n            \n            #### Keypad Dimmers", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r389316750", "createdAt": "2020-03-07T22:26:24Z", "author": {"login": "kaikreuzer"}, "path": "bundles/org.openhab.binding.insteon/README.md", "diffHunk": "@@ -0,0 +1,719 @@\n+# Insteon Binding\n+\n+Insteon is a home area networking technology developed primarily for connecting light switches and loads. Insteon devices send messages either via the power line, or by means of radio frequency (RF) waves, or both (dual-band). A considerable number of Insteon compatible devices such as switchable relays, thermostats, sensors etc are available. More about Insteon can be found on [Wikipedia](http://en.wikipedia.org/wiki/Insteon).\n+\n+This binding provides access to the Insteon network by means of either an Insteon PowerLinc Modem (PLM), a legacy Insteon Hub 2242-222 or the current 2245-222 Insteon Hub. The modem can be connected to the openHAB server either via a serial port (Model 2413S) or a USB port (Model 2413U). The Insteon PowerLinc Controller (Model 2414U) is not supported since it is a PLC not a PLM. The modem can also be connected via TCP (such as ser2net).  The binding translates openHAB commands into Insteon messages and sends them on the Insteon network. Relevant messages from the Insteon network (like notifications about switches being toggled) are picked up by the modem and converted to openHAB status updates by the binding. The binding also supports sending and receiving of legacy X10 messages.\n+\n+The binding does not support linking new devices on the fly, i.e. all devices must be linked with the modem *before* starting the Insteon binding.\n+\n+openHAB is not a configuration tool! To configure and set up your devices, link the devices manually via the set buttons, or use the free [Insteon Terminal](https://github.com/pfrommerd/insteon-terminal) software. The free HouseLinc software from Insteon can also be used for configuration, but it wipes the modem link database clean on its initial use, requiring to re-link the modem to all devices.\n+\n+## Supported Things\n+\n+| Thing  | Type   | Description                  |\n+|----------|--------|------------------------------|\n+| network  | Bridge | An insteon PLM or hub that is used to communicate with the Insteon devices |\n+|device| Thing | Insteon devices such as dimmers, keypads, sensors, etc. |\n+\n+## Discovery\n+\n+The binding will automatically add the network bridge called local to the Paper UI inbox. Upon proper configuration of the network bridge, the network device database will be downloaded. Any Insteon device that exists in the database and is not currently configured will get added to the inbox.  The naming convention is **Insteon Device AABBCC**, where AA, BB and CC are from the Insteon device address.  X10 devices are not auto discovered. \n+\n+## Thing Configuration\n+\n+###### Network Configuration\n+\n+The Insteon PLM or hub is configured with the following:\n+\n+| Parameter | Default | Required | Description |\n+|----------|---------:|--------:|-------------|\n+| port   |         |   Yes    | **Examples:**<br>- PLM on  Linux: `/dev/ttyS0` or `/dev/ttyUSB0`<br>- Smartenit ZBPLM on Linux: `/dev/ttyUSB0,baudRate=115200`<br>- PLM on Windows: `COM1`<br>- Current  hub (2245-222) at 192.168.1.100 on port 25105, with a poll interval of 1000 ms (1 second): `/hub2/my_user_name:my_password@192.168.1.100:25105,poll_time=1000`<br>- Legacy hub (2242-222) at 192.168.1.100 on port 9761:`/hub/192.168.1.100:9761`<br>- Networked PLM using ser2net at 192.168.1.100 on port 9761:`/tcp/192.168.1.100:9761` |\n+| devicePollIntervalSeconds | 300 |  No  | Poll interval of devices in seconds. Poll too often and you will overload the insteon network, leading to sluggish or no response when trying to send messages to devices. The default poll interval of 300 seconds has been tested and found to be a good compromise in a configuration of about 110 switches/dimmers. |\n+|modemDbRetryTimeoutSeconds|120|No|The number of seconds to wait for the modem database to completely download before retrying again.  Under normal circumstances this will not need to be modified.|\n+| additionalDevices | |       No     | Optional file with additional device types. The syntax of the file is identical to the `device_types.xml` file in the source tree. Please remember to post successfully added device types to the openhab group so the developers can include them into the `device_types.xml` file! |\n+| additionalFeatures | |      No     | Optional file with additional feature templates, like in the `device_features.xml` file in the source tree. |\n+\n+>NOTE: For users upgrading from InsteonPLM, The parameter port_1 is now port. \n+\n+###### Device Configuration\n+\n+The Insteon device is configured with the following required parameters:\n+\n+| Parameter | Description |\n+|----------|-------------|\n+|address|Insteon or X10 address of the device. Insteon device addresses are in the format 'xx.xx.xx', and can be found on the device. X10 device address are in the format 'x.y' and are typically configured on the device.|\n+|productKey|Insteon binding product key that is used to identy the device. Every Insteon device type is uniquely identified by its Insteon product key, typically a six digit hex number. For some of the older device types (in particular the SwitchLinc switches and dimmers), Insteon does not give a product key, so an arbitrary fake one of the format Fxx.xx.xx (or Xxx.xx.xx for X10 devices) is assigned by the binding.|\n+\n+The following is a list of the product keys and associated devices. These have been tested and should work out of the box:\n+\n+| Model | Description | Product Key | tested by |\n+|-------|-------------|-------------|-----------|\n+| 2477D | SwitchLinc Dimmer | F00.00.01 | Bernd Pfrommer |\n+| 2477S | SwitchLinc Switch | F00.00.02 | Bernd Pfrommer |\n+| 2845-222 | Hidden Door Sensor | F00.00.03 | Josenivaldo Benito |\n+| 2876S | ICON Switch | F00.00.04 | Patrick Giasson |\n+| 2456D3 | LampLinc V2 | F00.00.05 | Patrick Giasson |\n+| 2442-222 | Micro Dimmer | F00.00.06 | Josenivaldo Benito |\n+| 2453-222 | DIN Rail On/Off | F00.00.07 | Josenivaldo Benito |\n+| 2452-222 | DIN Rail Dimmer | F00.00.08 | Josenivaldo Benito |\n+| 2458-A1 | MorningLinc RF Lock Controller | F00.00.09 | cdeadlock |\n+| 2852-222 | Leak Sensor | F00.00.0A | Kirk McCann |\n+| 2672-422 | LED Dimmer | F00.00.0B | ??? |\n+| 2476D | SwitchLinc Dimmer | F00.00.0C | LiberatorUSA |\n+| 2634-222 | On/Off Dual-Band Outdoor Module | F00.00.0D | LiberatorUSA |\n+| 2342-2 | Mini Remote | F00.00.10 | Bernd Pfrommer |\n+| 2663-222 | On/Off Outlet | 0x000039 | SwissKid |\n+| 2466D | ToggleLinc Dimmer | F00.00.11 | Rob Nielsen |\n+| 2466S | ToggleLinc Switch | F00.00.12 | Rob Nielsen |\n+| 2672-222 | LED Bulb | F00.00.13 | Rob Nielsen |\n+| 2487S | KeypadLinc On/Off 6-Button | F00.00.14 | Bernd Pfrommer |\n+| 2334-232 | KeypadLink Dimmer 6-Button | F00.00.15 | Rob Nielsen |\n+| 2334-232 | KeypadLink Dimmer 8-Button | F00.00.16 | Rob Nielsen |\n+| 2423A1 | iMeter Solo Power Meter | F00.00.17 | Rob Nielsen |\n+| 2423A1 | Thermostat 2441TH | F00.00.18 | Daniel Campbell, Bernd Pfrommer |\n+| 2457D2 | LampLinc Dimmer | F00.00.19 | Jonathan Huizingh |\n+| 2475SDB | In-LineLinc Relay | F00.00.1A | Jim Howard |\n+| 2635-222 | On/Off Module | F00.00.1B | Jonathan Huizingh |\n+| 2475F | FanLinc Module | F00.00.1C | Brian Tillman |\n+| 2456S3 | ApplianceLinc | F00.00.1D | ??? |\n+| 2674-222 | LED Bulb (recessed) | F00.00.1E | Steve Bate |\n+| 2477SA1 | 220V 30-amp Load Controller N/O | F00.00.1F | Shawn R. |\n+| 2342-222 | Mini Remote (8 Button) | F00.00.20 | Bernd Pfrommer |\n+| 2441V | Insteon Thermostat Adaptor for Venstar | F00.00.21 | Bernd Pfrommer |\n+| 2982-222 | Insteon Smoke Bridge | F00.00.22 | Bernd Pfrommer |\n+| 2450 | IO Link | 0x00001A | Bernd Pfrommer |\n+| 2486D | KeypadLinc Dimmer | 0x000037 | Patrick Giasson, Joe Barnum |\n+| 2484DWH8 | KeypadLinc Countdown Timer | 0x000041 | Rob Nielsen |\n+| 2413U | PowerLinc 2413U USB modem | 0x000045 | Bernd Pfrommer |\n+| 2843-222 | Wireless Open/Close Sensor | 0x000049 | Josenivaldo Benito |\n+| 2842-222 | Motion Sensor | 0x00004A | Bernd Pfrommer |\n+| 2486DWH8 | KeypadLinc Dimmer | 0x000051 | Chris Graham |\n+| 2472D | OutletLincDimmer | 0x000068 | Chris Graham |\n+| X10 switch | generic X10 switch | X00.00.01 | Bernd Pfrommer |\n+| X10 dimmer | generic X10 dimmer | X00.00.02 | Bernd Pfrommer |\n+| X10 motion | generic X10 motion sensor | X00.00.03 | Bernd Pfrommer |\n+\n+## Channels\n+\n+Below is the list of possible channels for the Insteon devices. In order to determing which channels a device supports, you can either look at the device in Paper UI, or find it in the openhab log file.\n+\n+| channel  | type   | description                  |\n+|----------|--------|------------------------------|\n+| acDelay | Number | AC Delay |\n+| backlightDuration | Number | Back Light Duration |\n+| batteryLevel | Number | Battery Level |\n+| batteryWatermarkLevel | Number | Battery Watermark Level |\n+| bottomOutlet | Switch | Bottom Outlet |\n+| buttonA | Switch | Button A |\n+| buttonB | Switch | Button B |\n+| buttonC | Switch | Button C |\n+| buttonD | Switch | Button D |\n+| buttonE | Switch | Button E |\n+| buttonF | Switch | Button F |\n+| buttonG | Switch | Button G |\n+| buttonH | Switch | Button H |\n+| broadcastOnOff | Switch | Broadcast On/Off |\n+| contact | Contact | Contact |\n+| coolSetPoint | Number | Cool Set Point |\n+| dimmer | Dimmer | Dimmer |\n+| fan | Number | Fan |\n+| fanMode | Number | Fan Mode |\n+| fastOnOff | Switch | Fast On/Off |\n+| fastOnOffButtonA | Switch | Fast On/Off Button A |\n+| fastOnOffButtonB | Switch | Fast On/Off Button B |\n+| fastOnOffButtonC | Switch | Fast On/Off Button C |\n+| fastOnOffButtonD | Switch | Fast On/Off Button D |\n+| heatSetPoint | Number | Heat Set Point |\n+| humidity | Number | Humidity |\n+| humidityHigh | Number | Humidity High |\n+| humidityLow | Number | Humidity Low |\n+| isCooling | Number | Is Cooling |\n+| isHeating | Number | Is Heating |\n+| keypadButtonA | Switch | Keypad Button A |\n+| keypadButtonB | Switch | Keypad Button B |\n+| keypadButtonC | Switch | Keypad Button C |\n+| keypadButtonD | Switch | Keypad Button D |\n+| keypadButtonE | Switch | Keypad Button E |\n+| keypadButtonF | Switch | Keypad Button F |\n+| keypadButtonG | Switch | Keypad Button G |\n+| keypadButtonH | Switch | Keypad Button H |\n+| kWh | Number | Kilowatt Hour |\n+| lastHeardFrom | DateTime | Last Heard From |\n+| ledBrightness | Number | LED brightness |\n+| lightDimmer | Dimmer | light Dimmer |\n+| lightLevel | Number | Light Level |\n+| loadDimmer | Dimmer | Load Dimmer |\n+| loadSwitch | Switch | Load Switch |\n+| loadSwitchFastOnOff | Switch | Load Switch Fast On/Off |\n+| loadSwitchManualChange | Number | Load Switch Manual Change |\n+| manualChange | Number | Manual Change |\n+| manualChangeButtonA | Number | Manual Change Button A |\n+| manualChangeButtonB | Number | Manual Change Button B |\n+| manualChangeButtonC | Number | Manual Change Button C |\n+| manualChangeButtonD | Number | Manual Change Button D |\n+| notification | Number | Notification |\n+| onLevel | Number | On Level |\n+| rampDimmer | Dimmer | Ramp Dimmer |\n+| rampRate | Number | Ramp Rate |\n+| reset | Switch | Reset |\n+| stage1Duration | Number | Stage 1 Duration |\n+| switch | Switch | Switch |\n+| systemMode | Number | System Mode |\n+| tempCelsius | Number | Temperature Celsius |\n+| tempFahrenheit | Number | Temperature Fahrenheit |\n+| topOutlet | Switch | Top Outlet |\n+| update | Switch | Update |\n+| watts | Number | Watts |\n+\n+\n+## Full Example\n+\n+Sample things file:\n+\n+```\n+Bridge insteon:network:local [port=\"/dev/ttyUSB0\"] {\n+  Thing device 22F8A8 [address=\"22.F8.A8\", productKey=\"F00.00.15\"] {\n+    Channels:\n+      Type switch : keypadButtonA [ group=3 ]\n+      Type switch : keypadButtonB [ group=4 ]\n+      Type switch : keypadButtonC [ group=5 ]\n+      Type switch : keypadButtonD [ group=6 ]\n+  }\n+  Thing device 238D93 [address=\"23.8D.93\", productKey=\"F00.00.12\"]\n+  Thing device 238F55 [address=\"23.8F.55\", productKey=\"F00.00.11\"] {\n+    Channels:\n+      Type dimmer : dimmer [related=\"23.B0.D9+23.8F.C9\"]\n+  }\n+  Thing device 238FC9 [address=\"23.8F.C9\", productKey=\"F00.00.11\"] {\n+    Channels:\n+      Type dimmer : dimmer [related=\"23.8F.55+23.B0.D9\"]\n+  }\n+  Thing device 23B0D9 [address=\"23.B0.D9\", productKey=\"F00.00.11\"] {\n+    Channels:\n+      Type dimmer : dimmer [related=\"23.8F.55+23.8F.C9\"]\n+  }\n+  Thing device 243141 [address=\"24.31.41\", productKey=\"F00.00.11\"]  {\n+    Channels:\n+      Type dimmer : dimmer [dimmermax=60]\n+  }\n+}\n+```\n+\n+Sample items file:\n+\n+```\n+Switch switch1 { channel=\"insteon:device:local:243141:switch\" }\n+Dimmer dimmer1 { channel=\"insteon:device:local:238F55:dimmer\" }\n+Dimmer dimmer2 { channel=\"insteon:device:local:23B0D9:dimmer\" }\n+Dimmer dimmer3 { channel=\"insteon:device:local:238FC9:dimmer\" }\n+Dimmer keypad  { channel=\"insteon:device:local:22F8A8:loadDimmer\" }\n+Switch keypadA { channel=\"insteon:device:local:22F8A8:keypadButtonA\" }\n+Switch keypadB { channel=\"insteon:device:local:22F8A8:keypadButtonB\" }\n+Switch keypadC { channel=\"insteon:device:local:22F8A8:keypadButtonC\" }\n+Switch keypadD { channel=\"insteon:device:local:22F8A8:keypadButtonD\" }\n+Dimmer dimmer  { channel=\"insteon:device:local:238D93:dimmer\" }\n+```\n+\n+## Insteon Groups and Scenes\n+\n+How do Insteon devices tell other devices on the network that their state has changed? They send out a broadcast message, labeled with a specific *group* number. All devices (called *responders*) that are configured to listen to this message will then go into a pre-defined state. For instance when light switch A is switched to \"ON\", it will send out a message to group #1, and all responders will react to it, e.g they may go into the \"ON\" position as well. Since more than one device can participate, the sending out of the broadcast message and the subsequent state change of the responders is referred to as \"triggering a scene\". At the device and PLM level, the concept of a \"scene\" does not exist, so you will find it notably absent in the binding code and this document. A scene is strictly a higher level concept, introduced to shield the user from the details of how the communication is implemented.\n+\n+Many Insteon devices send out messages on different group numbers, depending on what happens to them. A leak sensor may send out a message on group #1 when dry, and on group #2 when wet. The default group used for e.g. linking two light switches is usually group #1.\n+\n+## Insteon binding process\n+\n+Before Insteon devices communicate with one another, they must be linked. During the linking process, one of the devices will be the \"Controller\", the other the \"Responder\" (see e.g. the [SwitchLinc Instructions](https://www.insteon.com/pdf/2477S.pdf)).\n+\n+The responder listens to messages from the controller, and reacts to them. Note that except for the case of a motion detector (which is just a controller to the modem), the modem controls the device (e.g. send on/off messages to it), and the device controls the modem (so the modem learns about the switch being toggled). For this reason, most devices and in particular switches/dimmers should be linked twice, with one taking the role of controller during the first linking, and the other acting as controller during the second linking process. To do so, first press and hold the \"Set\" button on the modem until the light starts blinking. Then press and hold the \"Set\" button on the remote device,\n+e.g. the light switch, until it double beeps (the light on the modem should go off as well). Now do exactly the reverse: press and hold the \"Set\" button on the remote device until its light starts blinking, then press and hold the \"Set\" button on the modem until it double beeps, and the light of the remote device (switch) goes off. Done.\n+\n+For some of the more sophisticated devices the complete linking process can no longer be done with the set buttons, but requires software like e.g. [Insteon Terminal](https://github.com/pfrommerd/insteon-terminal).\n+\n+## Insteon Features\n+\n+Since Insteon devices can have multiple features (for instance a switchable relay and a contact sensor) under a single Insteon address, an openHAB item is not bound to a device, but to a given feature of a device. For example, the following lines would create two Number items referring to the same thermostat device, but to different features of it:\n+\n+```\n+Number  thermostatCoolPoint \"cool point [%.1f \u00b0F]\" { channel=\"insteon:device:local:32F422:coolSetPoint\" }\n+Number  thermostatHeatPoint \"heat point [%.1f \u00b0F]\" { channel=\"insteon:device:local:32F422:heatSetPoint\" }\n+```\n+\n+### Simple light switches\n+\n+The following example shows how to configure a simple light switch (2477S) in the .items file:\n+\n+```\n+Switch officeLight \"office light\"  { channel=\"insteon:device:local:AABBCC:switch\" }\n+```\n+\n+### Simple dimmers\n+\n+Here is how to configure a simple dimmer (2477D) in the .items file:\n+\n+```\n+Dimmer kitchenChandelier \"kitchen chandelier\" { channel=\"insteon:device:local:AABBCC:dimmer\" }\n+```\n+\n+Dimmers can be configured with a maximum level when turning a device on or setting a percentage level. If a maximum level is configured, openHAB will never set the level of the dimmer above the level specified. The parameter dimmermax must be defined for the channel. The below example sets a maximum level of 70% for dim 1 and 60% for dim 2:\n+\n+**Things**\n+\n+```\n+Bridge insteon:network:local [port=\"/dev/ttyUSB0\"] {\n+  Thing device AABBCC [address=\"AA.BB.CC\", productKey=\"F00.00.11\"]  {\n+    Channels:\n+      Type dimmer : dimmer [dimmermax=70]\n+  }\n+  Thing device AABBCD [address=\"AA.BB.CD\", productKey=\"F00.00.15\"]  {\n+    Channels:\n+      Type dimmer : loadDimmer [dimmermax=60]\n+  }\n+}\n+```\n+\n+**Items**\n+\n+```\n+Dimmer d1 \"dimmer 1\" { channel=\"insteon:device:local:AABBCC:dimmer\"}\n+Dimmer d2 \"dimmer 2\" { channel=\"insteon:device:local:AABBCD:loadDimmer\"}\n+```\n+\n+Setting a maximum level does not affect manual turning on or dimming a switch.\n+\n+### On/Off Outlets\n+\n+Here's how to configure the top and bottom outlet of the in-wall 2 outlet controller:\n+\n+```\n+Switch fOutTop \"Front Outlet Top\"    <socket> { channel=\"insteon:device:local:AABBCC:topOutlet\" }\n+Switch fOutBot \"Front Outlet Bottom\" <socket> { channel=\"insteon:device:local:AABBCC:bottomOutlet\" }\n+```\n+\n+This will give you individual control of each outlet.\n+    \n+### Mini remotes\n+\n+Link the mini remote to be a controller of the modem by using the set button. Link all buttons, one after the other. The 4-button mini remote sends out messages on groups 0x01 - 0x04, each corresponding to one button. The modem's link database (see [Insteon Terminal](https://github.com/pfrommerd/insteon-terminal)) should look like this:\n+\n+```\n+    0000 xx.xx.xx                       xx.xx.xx  RESP  10100010 group: 01 data: 02 2c 41\n+    0000 xx.xx.xx                       xx.xx.xx  RESP  10100010 group: 02 data: 02 2c 41\n+    0000 xx.xx.xx                       xx.xx.xx  RESP  10100010 group: 03 data: 02 2c 41\n+    0000 xx.xx.xx                       xx.xx.xx  RESP  10100010 group: 04 data: 02 2c 41\n+```\n+\n+**Items**\n+This goes into the items file:\n+\n+```\n+    Switch miniRemoteButtonA \"mini remote button a\" { channel=\"insteon:device:local:AABBCC:buttonA\", autoupdate=\"false\" }\n+    Switch miniRemoteButtonB \"mini remote button b\" { channel=\"insteon:device:local:AABBCC:buttonB\", autoupdate=\"false\" }\n+    Switch miniRemoteButtonC \"mini remote button c\" { channel=\"insteon:device:local:AABBCC:buttonC\", autoupdate=\"false\" }\n+    Switch miniRemoteButtonD \"mini remote button d\" { channel=\"insteon:device:local:AABBCC:buttonD\", autoupdate=\"false\" }\n+```\n+\n+**Sitemap**\n+This goes into the sitemap file:\n+\n+```\n+    Switch item=miniRemoteButtonA label=\"mini remote button a\" mappings=[ OFF=\"Off\", ON=\"On\"]\n+    Switch item=miniRemoteButtonB label=\"mini remote button b\" mappings=[ OFF=\"Off\", ON=\"On\"]\n+    Switch item=miniRemoteButtonC label=\"mini remote button c\" mappings=[ OFF=\"Off\", ON=\"On\"]\n+    Switch item=miniRemoteButtonD label=\"mini remote button d\" mappings=[ OFF=\"Off\", ON=\"On\"]\n+```\n+\n+The switches in the GUI just display the mini remote's most recent button presses. They are not operable because the PLM cannot trigger the mini remotes scenes.\n+\n+### Motion sensors\n+\n+Link such that the modem is a responder to the motion sensor. Create a contact.map file in the transforms directory as described elsewhere in this document. Then create entries in the .items file like this:\n+\n+**Items**\n+\n+```\n+    Contact motionSensor             \"motion sensor [MAP(contact.map):%s]\" { channel=\"insteon:device:local:AABBCC:contact\"}\n+    Number  motionSensorBatteryLevel \"motion sensor battery level [%.1f]\"  { channel=\"insteon:device:local:AABBCC:batteryLevel\" }\n+    Number  motionSensorLightLevel   \"motion sensor light level [%.1f]\"    { channel=\"insteon:device:local:AABBCC:lightLevel\" }\n+```\n+\n+This will give you a contact, the battery level, and the light level. Note that battery and light level are only updated when either there is motion, or the sensor battery runs low.\n+\n+### Hidden door sensors\n+\n+Similar in operation to the motion sensor above.  Link such that the modem is a responder to the motion sensor. Create a contact.map file in the transforms directory like the following:\n+\n+```\n+    OPEN=open\n+    CLOSED=closed\n+    -=unknown\n+```\n+\n+**Items**\n+Then create entries in the .items file like this:\n+\n+```\n+    Contact doorSensor             \"Door sensor [MAP(contact.map):%s]\" { channel=\"insteon:device:local:AABBCC:contact\" }\n+    Number  doorSensorBatteryLevel \"Door sensor battery level [%.1f]\"  { channel=\"insteon:device:local:AABBCC:batteryLevel\" }\n+```\n+\n+This will give you a contact and the battery level. Note that battery level is only updated when either there is motion, or the sensor battery runs low.\n+\n+### Locks\n+\n+Read the instructions very carefully: sync with lock within 5 feet to avoid bad connection, link twice for both ON and OFF functionality.\n+\n+**Items**\n+Put something like this into your .items file:\n+\n+```\n+    Switch doorLock \"Front Door [MAP(lock.map):%s]\"  { channel=\"insteon:device:local:AABBCC:switch\" }\n+```\n+\n+and create a file \"lock.map\" in the transforms directory with these entries: \n+\n+```\n+    ON=Lock\n+    OFF=Unlock\n+    -=unknown\n+```\n+\n+### I/O Linc (garage door openers)\n+\n+The I/O Linc devices are really two devices in one: a relay and a contact. Link the modem both ways, as responder and controller using the set buttons as described in the instructions.\n+\n+Add this map into your transforms directory as \"contact.map\":\n+\n+```\n+    OPEN=open\n+    CLOSED=closed\n+    -=unknown\n+```\n+\n+**Items**\n+Along with this into your .items file:\n+\n+```\n+    Switch  garageDoorOpener  \"garage door opener\"                        <garagedoor>  { channel=\"insteon:device:local:AABBCC:switch\", autoupdate=\"false\" }\n+    Contact garageDoorContact \"garage door contact [MAP(contact.map):%s]\"               { channel=\"insteon:device:local:AABBCC:contact\" }\n+```\n+\n+**Sitemap**\n+To make it visible in the GUI, put this into your sitemap file:\n+\n+```\n+    Switch item=garageDoorOpener label=\"garage door opener\" mappings=[ ON=\"OPEN/CLOSE\"]\n+    Text item=garageDoorContact\n+```\n+\n+For safety reasons, only close the garage door if you have visual contact to make sure there is no obstruction! The use of automated rules for closing garage doors is dangerous.\n+\n+> NOTE: If the I/O Linc returns the wrong value when the device is polled (For example you open the garage door and the state correctly shows OPEN, but during polling it shows CLOSED), you probably linked the device with the PLM or hub when the door was in the wrong position. You need unlink and then link again with the door in the opposite position. Please see the Insteon I/O Linc documentation for further details.\n+\n+### Keypads\n+\n+Before you attempt to configure the keypads, please familiarize yourself with the concept of an Insteon group.\n+\n+The Insteon keypad devices typically control one main load and have a number of buttons that will send out group broadcast messages to trigger a scene. If you just want to use the main load switch within openhab just link modem and device with the set buttons as usual, no complicated linking is necessary. But if you want to get the buttons to work, read on.\n+\n+Each button will send out a message for a different, predefined group. Complicating matters further, the button numbering used internally by the device must be mapped to whatever labels are printed on the physical buttons of the device. Here is an example correspondence table:\n+\n+| Group | Button Number | 2487S Label |\n+|-------|---------------|-------------|\n+|  0x01 |        1      |   (Load)    |\n+|  0x03 |        3      |     A       |\n+|  0x04 |        4      |     B       |\n+|  0x05 |        5      |     C       |\n+|  0x06 |        6      |     D       |\n+\n+When e.g. the \"A\" button is pressed (that's button #3 internally) a broadcast message will be sent out to all responders configured to listen to Insteon group #3. This means you must configure the modem as a responder to group #3 (and #4, #5, #6) messages coming from your keypad. For instructions how to do this, check out the [Insteon Terminal](https://github.com/pfrommerd/insteon-terminal). You can even do that with the set buttons (see instructions that come with the keypad).\n+\n+While capturing the messages that the buttons emit is pretty straight forward, controlling the buttons is  another matter. They cannot be simply toggled with a direct command to the device, but instead a broadcast message must be sent on a group number that the button has been programmed to listen to. This means you need to pick a set of unused groups that is globally unique (if you have multiple keypads, each one of them has to use different groups), one group for each button. The example configuration below uses groups 0xf3, 0xf4, 0xf5, and 0xf6. Then link the buttons such that they respond to those groups, and link the modem as a controller for them (see [Insteon Terminal](https://github.com/pfrommerd/insteon-terminal) documentation). In your items file you specify these groups with the \"group=\" parameters such that the binding knows what group number to put on the outgoing message.\n+\n+\n+#### Keypad switches\n+\n+**Items**\n+\n+Here is a simple example, just using the load (main) switch:\n+\n+```\n+    Switch keypadSwitch             \"main load\"          { channel=\"insteon:device:local:AABBCC:loadSwitch\" }\n+    Number keypadSwitchManualChange \"main manual change\" { channel=\"insteon:device:local:AABBCC:loadSwitchManualChange\" }\n+    Switch keypadSwitchFastOnOff    \"main fast on/off\"   { channel=\"insteon:device:local:AABBCC:loadSwitchFastOnOff\" }\n+```\n+\n+Most people will not use the fast on/off features or the manual change feature, so you really only need the first line. To make the buttons available, add the following:\n+\n+**Things**\n+\n+```\n+Bridge insteon:network:local [port=\"/dev/ttyUSB0\"] {\n+  Thing device AABBCC [address=\"AA.BB.CC\", productKey=\"F00.00.15\"] {\n+    Channels:\n+      Type switch : keypadButtonA [ group=\"0xf3\" ]\n+      Type switch : keypadButtonB [ group=\"0xf4\" ]\n+      Type switch : keypadButtonC [ group=\"0xf5\" ]\n+      Type switch : keypadButtonD [ group=\"0xf6\" ]\n+  }\n+}\n+```\n+\n+The value after group must either be a number or string. The hexadecimal value 0xf3 can either converted to a numeric value 243 or the string value \"0xf3\".\n+\n+**Items**\n+\n+```\n+    Switch keypadSwitchA \"keypad button A\" { channel=\"insteon:device:local:AABBCC:keypadButtonA\"}\n+    Switch keypadSwitchB \"keypad button B\" { channel=\"insteon:device:local:AABBCC:keypadButtonB\"}\n+    Switch keypadSwitchC \"keypad button C\" { channel=\"insteon:device:local:AABBCC:keypadButtonC\"}\n+    Switch keypadSwitchD \"keypad button D\" { channel=\"insteon:device:local:AABBCC:keypadButtonD\"}\n+```\n+\n+**Sitemap**\n+\n+The following sitemap will bring the items to life in the GUI:\n+\n+```\n+    Frame label=\"Keypad\" {\n+          Switch item=keypadSwitch label=\"main\"\n+          Switch item=keypadSwitchFastOnOff label=\"fast on/off\"\n+          Switch item=keypadSwitchManualChange label=\"manual change\" mappings=[ 0=\"DOWN\", 1=\"STOP\",  2=\"UP\"]\n+          Switch item=keypadSwitchA label=\"button A\"\n+          Switch item=keypadSwitchB label=\"button B\"\n+          Switch item=keypadSwitchC label=\"button C\"\n+          Switch item=keypadSwitchD label=\"button D\"\n+    }\n+```\n+\n+#### Keypad dimmers", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "04a9796d14dfbc5f3ff997d872f04b6d03ee411d"}, "originalPosition": 488}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTMxNjc2OA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            ### X10 devices\n          \n          \n            \n            ### X10 Devices", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r389316768", "createdAt": "2020-03-07T22:26:40Z", "author": {"login": "kaikreuzer"}, "path": "bundles/org.openhab.binding.insteon/README.md", "diffHunk": "@@ -0,0 +1,719 @@\n+# Insteon Binding\n+\n+Insteon is a home area networking technology developed primarily for connecting light switches and loads. Insteon devices send messages either via the power line, or by means of radio frequency (RF) waves, or both (dual-band). A considerable number of Insteon compatible devices such as switchable relays, thermostats, sensors etc are available. More about Insteon can be found on [Wikipedia](http://en.wikipedia.org/wiki/Insteon).\n+\n+This binding provides access to the Insteon network by means of either an Insteon PowerLinc Modem (PLM), a legacy Insteon Hub 2242-222 or the current 2245-222 Insteon Hub. The modem can be connected to the openHAB server either via a serial port (Model 2413S) or a USB port (Model 2413U). The Insteon PowerLinc Controller (Model 2414U) is not supported since it is a PLC not a PLM. The modem can also be connected via TCP (such as ser2net).  The binding translates openHAB commands into Insteon messages and sends them on the Insteon network. Relevant messages from the Insteon network (like notifications about switches being toggled) are picked up by the modem and converted to openHAB status updates by the binding. The binding also supports sending and receiving of legacy X10 messages.\n+\n+The binding does not support linking new devices on the fly, i.e. all devices must be linked with the modem *before* starting the Insteon binding.\n+\n+openHAB is not a configuration tool! To configure and set up your devices, link the devices manually via the set buttons, or use the free [Insteon Terminal](https://github.com/pfrommerd/insteon-terminal) software. The free HouseLinc software from Insteon can also be used for configuration, but it wipes the modem link database clean on its initial use, requiring to re-link the modem to all devices.\n+\n+## Supported Things\n+\n+| Thing  | Type   | Description                  |\n+|----------|--------|------------------------------|\n+| network  | Bridge | An insteon PLM or hub that is used to communicate with the Insteon devices |\n+|device| Thing | Insteon devices such as dimmers, keypads, sensors, etc. |\n+\n+## Discovery\n+\n+The binding will automatically add the network bridge called local to the Paper UI inbox. Upon proper configuration of the network bridge, the network device database will be downloaded. Any Insteon device that exists in the database and is not currently configured will get added to the inbox.  The naming convention is **Insteon Device AABBCC**, where AA, BB and CC are from the Insteon device address.  X10 devices are not auto discovered. \n+\n+## Thing Configuration\n+\n+###### Network Configuration\n+\n+The Insteon PLM or hub is configured with the following:\n+\n+| Parameter | Default | Required | Description |\n+|----------|---------:|--------:|-------------|\n+| port   |         |   Yes    | **Examples:**<br>- PLM on  Linux: `/dev/ttyS0` or `/dev/ttyUSB0`<br>- Smartenit ZBPLM on Linux: `/dev/ttyUSB0,baudRate=115200`<br>- PLM on Windows: `COM1`<br>- Current  hub (2245-222) at 192.168.1.100 on port 25105, with a poll interval of 1000 ms (1 second): `/hub2/my_user_name:my_password@192.168.1.100:25105,poll_time=1000`<br>- Legacy hub (2242-222) at 192.168.1.100 on port 9761:`/hub/192.168.1.100:9761`<br>- Networked PLM using ser2net at 192.168.1.100 on port 9761:`/tcp/192.168.1.100:9761` |\n+| devicePollIntervalSeconds | 300 |  No  | Poll interval of devices in seconds. Poll too often and you will overload the insteon network, leading to sluggish or no response when trying to send messages to devices. The default poll interval of 300 seconds has been tested and found to be a good compromise in a configuration of about 110 switches/dimmers. |\n+|modemDbRetryTimeoutSeconds|120|No|The number of seconds to wait for the modem database to completely download before retrying again.  Under normal circumstances this will not need to be modified.|\n+| additionalDevices | |       No     | Optional file with additional device types. The syntax of the file is identical to the `device_types.xml` file in the source tree. Please remember to post successfully added device types to the openhab group so the developers can include them into the `device_types.xml` file! |\n+| additionalFeatures | |      No     | Optional file with additional feature templates, like in the `device_features.xml` file in the source tree. |\n+\n+>NOTE: For users upgrading from InsteonPLM, The parameter port_1 is now port. \n+\n+###### Device Configuration\n+\n+The Insteon device is configured with the following required parameters:\n+\n+| Parameter | Description |\n+|----------|-------------|\n+|address|Insteon or X10 address of the device. Insteon device addresses are in the format 'xx.xx.xx', and can be found on the device. X10 device address are in the format 'x.y' and are typically configured on the device.|\n+|productKey|Insteon binding product key that is used to identy the device. Every Insteon device type is uniquely identified by its Insteon product key, typically a six digit hex number. For some of the older device types (in particular the SwitchLinc switches and dimmers), Insteon does not give a product key, so an arbitrary fake one of the format Fxx.xx.xx (or Xxx.xx.xx for X10 devices) is assigned by the binding.|\n+\n+The following is a list of the product keys and associated devices. These have been tested and should work out of the box:\n+\n+| Model | Description | Product Key | tested by |\n+|-------|-------------|-------------|-----------|\n+| 2477D | SwitchLinc Dimmer | F00.00.01 | Bernd Pfrommer |\n+| 2477S | SwitchLinc Switch | F00.00.02 | Bernd Pfrommer |\n+| 2845-222 | Hidden Door Sensor | F00.00.03 | Josenivaldo Benito |\n+| 2876S | ICON Switch | F00.00.04 | Patrick Giasson |\n+| 2456D3 | LampLinc V2 | F00.00.05 | Patrick Giasson |\n+| 2442-222 | Micro Dimmer | F00.00.06 | Josenivaldo Benito |\n+| 2453-222 | DIN Rail On/Off | F00.00.07 | Josenivaldo Benito |\n+| 2452-222 | DIN Rail Dimmer | F00.00.08 | Josenivaldo Benito |\n+| 2458-A1 | MorningLinc RF Lock Controller | F00.00.09 | cdeadlock |\n+| 2852-222 | Leak Sensor | F00.00.0A | Kirk McCann |\n+| 2672-422 | LED Dimmer | F00.00.0B | ??? |\n+| 2476D | SwitchLinc Dimmer | F00.00.0C | LiberatorUSA |\n+| 2634-222 | On/Off Dual-Band Outdoor Module | F00.00.0D | LiberatorUSA |\n+| 2342-2 | Mini Remote | F00.00.10 | Bernd Pfrommer |\n+| 2663-222 | On/Off Outlet | 0x000039 | SwissKid |\n+| 2466D | ToggleLinc Dimmer | F00.00.11 | Rob Nielsen |\n+| 2466S | ToggleLinc Switch | F00.00.12 | Rob Nielsen |\n+| 2672-222 | LED Bulb | F00.00.13 | Rob Nielsen |\n+| 2487S | KeypadLinc On/Off 6-Button | F00.00.14 | Bernd Pfrommer |\n+| 2334-232 | KeypadLink Dimmer 6-Button | F00.00.15 | Rob Nielsen |\n+| 2334-232 | KeypadLink Dimmer 8-Button | F00.00.16 | Rob Nielsen |\n+| 2423A1 | iMeter Solo Power Meter | F00.00.17 | Rob Nielsen |\n+| 2423A1 | Thermostat 2441TH | F00.00.18 | Daniel Campbell, Bernd Pfrommer |\n+| 2457D2 | LampLinc Dimmer | F00.00.19 | Jonathan Huizingh |\n+| 2475SDB | In-LineLinc Relay | F00.00.1A | Jim Howard |\n+| 2635-222 | On/Off Module | F00.00.1B | Jonathan Huizingh |\n+| 2475F | FanLinc Module | F00.00.1C | Brian Tillman |\n+| 2456S3 | ApplianceLinc | F00.00.1D | ??? |\n+| 2674-222 | LED Bulb (recessed) | F00.00.1E | Steve Bate |\n+| 2477SA1 | 220V 30-amp Load Controller N/O | F00.00.1F | Shawn R. |\n+| 2342-222 | Mini Remote (8 Button) | F00.00.20 | Bernd Pfrommer |\n+| 2441V | Insteon Thermostat Adaptor for Venstar | F00.00.21 | Bernd Pfrommer |\n+| 2982-222 | Insteon Smoke Bridge | F00.00.22 | Bernd Pfrommer |\n+| 2450 | IO Link | 0x00001A | Bernd Pfrommer |\n+| 2486D | KeypadLinc Dimmer | 0x000037 | Patrick Giasson, Joe Barnum |\n+| 2484DWH8 | KeypadLinc Countdown Timer | 0x000041 | Rob Nielsen |\n+| 2413U | PowerLinc 2413U USB modem | 0x000045 | Bernd Pfrommer |\n+| 2843-222 | Wireless Open/Close Sensor | 0x000049 | Josenivaldo Benito |\n+| 2842-222 | Motion Sensor | 0x00004A | Bernd Pfrommer |\n+| 2486DWH8 | KeypadLinc Dimmer | 0x000051 | Chris Graham |\n+| 2472D | OutletLincDimmer | 0x000068 | Chris Graham |\n+| X10 switch | generic X10 switch | X00.00.01 | Bernd Pfrommer |\n+| X10 dimmer | generic X10 dimmer | X00.00.02 | Bernd Pfrommer |\n+| X10 motion | generic X10 motion sensor | X00.00.03 | Bernd Pfrommer |\n+\n+## Channels\n+\n+Below is the list of possible channels for the Insteon devices. In order to determing which channels a device supports, you can either look at the device in Paper UI, or find it in the openhab log file.\n+\n+| channel  | type   | description                  |\n+|----------|--------|------------------------------|\n+| acDelay | Number | AC Delay |\n+| backlightDuration | Number | Back Light Duration |\n+| batteryLevel | Number | Battery Level |\n+| batteryWatermarkLevel | Number | Battery Watermark Level |\n+| bottomOutlet | Switch | Bottom Outlet |\n+| buttonA | Switch | Button A |\n+| buttonB | Switch | Button B |\n+| buttonC | Switch | Button C |\n+| buttonD | Switch | Button D |\n+| buttonE | Switch | Button E |\n+| buttonF | Switch | Button F |\n+| buttonG | Switch | Button G |\n+| buttonH | Switch | Button H |\n+| broadcastOnOff | Switch | Broadcast On/Off |\n+| contact | Contact | Contact |\n+| coolSetPoint | Number | Cool Set Point |\n+| dimmer | Dimmer | Dimmer |\n+| fan | Number | Fan |\n+| fanMode | Number | Fan Mode |\n+| fastOnOff | Switch | Fast On/Off |\n+| fastOnOffButtonA | Switch | Fast On/Off Button A |\n+| fastOnOffButtonB | Switch | Fast On/Off Button B |\n+| fastOnOffButtonC | Switch | Fast On/Off Button C |\n+| fastOnOffButtonD | Switch | Fast On/Off Button D |\n+| heatSetPoint | Number | Heat Set Point |\n+| humidity | Number | Humidity |\n+| humidityHigh | Number | Humidity High |\n+| humidityLow | Number | Humidity Low |\n+| isCooling | Number | Is Cooling |\n+| isHeating | Number | Is Heating |\n+| keypadButtonA | Switch | Keypad Button A |\n+| keypadButtonB | Switch | Keypad Button B |\n+| keypadButtonC | Switch | Keypad Button C |\n+| keypadButtonD | Switch | Keypad Button D |\n+| keypadButtonE | Switch | Keypad Button E |\n+| keypadButtonF | Switch | Keypad Button F |\n+| keypadButtonG | Switch | Keypad Button G |\n+| keypadButtonH | Switch | Keypad Button H |\n+| kWh | Number | Kilowatt Hour |\n+| lastHeardFrom | DateTime | Last Heard From |\n+| ledBrightness | Number | LED brightness |\n+| lightDimmer | Dimmer | light Dimmer |\n+| lightLevel | Number | Light Level |\n+| loadDimmer | Dimmer | Load Dimmer |\n+| loadSwitch | Switch | Load Switch |\n+| loadSwitchFastOnOff | Switch | Load Switch Fast On/Off |\n+| loadSwitchManualChange | Number | Load Switch Manual Change |\n+| manualChange | Number | Manual Change |\n+| manualChangeButtonA | Number | Manual Change Button A |\n+| manualChangeButtonB | Number | Manual Change Button B |\n+| manualChangeButtonC | Number | Manual Change Button C |\n+| manualChangeButtonD | Number | Manual Change Button D |\n+| notification | Number | Notification |\n+| onLevel | Number | On Level |\n+| rampDimmer | Dimmer | Ramp Dimmer |\n+| rampRate | Number | Ramp Rate |\n+| reset | Switch | Reset |\n+| stage1Duration | Number | Stage 1 Duration |\n+| switch | Switch | Switch |\n+| systemMode | Number | System Mode |\n+| tempCelsius | Number | Temperature Celsius |\n+| tempFahrenheit | Number | Temperature Fahrenheit |\n+| topOutlet | Switch | Top Outlet |\n+| update | Switch | Update |\n+| watts | Number | Watts |\n+\n+\n+## Full Example\n+\n+Sample things file:\n+\n+```\n+Bridge insteon:network:local [port=\"/dev/ttyUSB0\"] {\n+  Thing device 22F8A8 [address=\"22.F8.A8\", productKey=\"F00.00.15\"] {\n+    Channels:\n+      Type switch : keypadButtonA [ group=3 ]\n+      Type switch : keypadButtonB [ group=4 ]\n+      Type switch : keypadButtonC [ group=5 ]\n+      Type switch : keypadButtonD [ group=6 ]\n+  }\n+  Thing device 238D93 [address=\"23.8D.93\", productKey=\"F00.00.12\"]\n+  Thing device 238F55 [address=\"23.8F.55\", productKey=\"F00.00.11\"] {\n+    Channels:\n+      Type dimmer : dimmer [related=\"23.B0.D9+23.8F.C9\"]\n+  }\n+  Thing device 238FC9 [address=\"23.8F.C9\", productKey=\"F00.00.11\"] {\n+    Channels:\n+      Type dimmer : dimmer [related=\"23.8F.55+23.B0.D9\"]\n+  }\n+  Thing device 23B0D9 [address=\"23.B0.D9\", productKey=\"F00.00.11\"] {\n+    Channels:\n+      Type dimmer : dimmer [related=\"23.8F.55+23.8F.C9\"]\n+  }\n+  Thing device 243141 [address=\"24.31.41\", productKey=\"F00.00.11\"]  {\n+    Channels:\n+      Type dimmer : dimmer [dimmermax=60]\n+  }\n+}\n+```\n+\n+Sample items file:\n+\n+```\n+Switch switch1 { channel=\"insteon:device:local:243141:switch\" }\n+Dimmer dimmer1 { channel=\"insteon:device:local:238F55:dimmer\" }\n+Dimmer dimmer2 { channel=\"insteon:device:local:23B0D9:dimmer\" }\n+Dimmer dimmer3 { channel=\"insteon:device:local:238FC9:dimmer\" }\n+Dimmer keypad  { channel=\"insteon:device:local:22F8A8:loadDimmer\" }\n+Switch keypadA { channel=\"insteon:device:local:22F8A8:keypadButtonA\" }\n+Switch keypadB { channel=\"insteon:device:local:22F8A8:keypadButtonB\" }\n+Switch keypadC { channel=\"insteon:device:local:22F8A8:keypadButtonC\" }\n+Switch keypadD { channel=\"insteon:device:local:22F8A8:keypadButtonD\" }\n+Dimmer dimmer  { channel=\"insteon:device:local:238D93:dimmer\" }\n+```\n+\n+## Insteon Groups and Scenes\n+\n+How do Insteon devices tell other devices on the network that their state has changed? They send out a broadcast message, labeled with a specific *group* number. All devices (called *responders*) that are configured to listen to this message will then go into a pre-defined state. For instance when light switch A is switched to \"ON\", it will send out a message to group #1, and all responders will react to it, e.g they may go into the \"ON\" position as well. Since more than one device can participate, the sending out of the broadcast message and the subsequent state change of the responders is referred to as \"triggering a scene\". At the device and PLM level, the concept of a \"scene\" does not exist, so you will find it notably absent in the binding code and this document. A scene is strictly a higher level concept, introduced to shield the user from the details of how the communication is implemented.\n+\n+Many Insteon devices send out messages on different group numbers, depending on what happens to them. A leak sensor may send out a message on group #1 when dry, and on group #2 when wet. The default group used for e.g. linking two light switches is usually group #1.\n+\n+## Insteon binding process\n+\n+Before Insteon devices communicate with one another, they must be linked. During the linking process, one of the devices will be the \"Controller\", the other the \"Responder\" (see e.g. the [SwitchLinc Instructions](https://www.insteon.com/pdf/2477S.pdf)).\n+\n+The responder listens to messages from the controller, and reacts to them. Note that except for the case of a motion detector (which is just a controller to the modem), the modem controls the device (e.g. send on/off messages to it), and the device controls the modem (so the modem learns about the switch being toggled). For this reason, most devices and in particular switches/dimmers should be linked twice, with one taking the role of controller during the first linking, and the other acting as controller during the second linking process. To do so, first press and hold the \"Set\" button on the modem until the light starts blinking. Then press and hold the \"Set\" button on the remote device,\n+e.g. the light switch, until it double beeps (the light on the modem should go off as well). Now do exactly the reverse: press and hold the \"Set\" button on the remote device until its light starts blinking, then press and hold the \"Set\" button on the modem until it double beeps, and the light of the remote device (switch) goes off. Done.\n+\n+For some of the more sophisticated devices the complete linking process can no longer be done with the set buttons, but requires software like e.g. [Insteon Terminal](https://github.com/pfrommerd/insteon-terminal).\n+\n+## Insteon Features\n+\n+Since Insteon devices can have multiple features (for instance a switchable relay and a contact sensor) under a single Insteon address, an openHAB item is not bound to a device, but to a given feature of a device. For example, the following lines would create two Number items referring to the same thermostat device, but to different features of it:\n+\n+```\n+Number  thermostatCoolPoint \"cool point [%.1f \u00b0F]\" { channel=\"insteon:device:local:32F422:coolSetPoint\" }\n+Number  thermostatHeatPoint \"heat point [%.1f \u00b0F]\" { channel=\"insteon:device:local:32F422:heatSetPoint\" }\n+```\n+\n+### Simple light switches\n+\n+The following example shows how to configure a simple light switch (2477S) in the .items file:\n+\n+```\n+Switch officeLight \"office light\"  { channel=\"insteon:device:local:AABBCC:switch\" }\n+```\n+\n+### Simple dimmers\n+\n+Here is how to configure a simple dimmer (2477D) in the .items file:\n+\n+```\n+Dimmer kitchenChandelier \"kitchen chandelier\" { channel=\"insteon:device:local:AABBCC:dimmer\" }\n+```\n+\n+Dimmers can be configured with a maximum level when turning a device on or setting a percentage level. If a maximum level is configured, openHAB will never set the level of the dimmer above the level specified. The parameter dimmermax must be defined for the channel. The below example sets a maximum level of 70% for dim 1 and 60% for dim 2:\n+\n+**Things**\n+\n+```\n+Bridge insteon:network:local [port=\"/dev/ttyUSB0\"] {\n+  Thing device AABBCC [address=\"AA.BB.CC\", productKey=\"F00.00.11\"]  {\n+    Channels:\n+      Type dimmer : dimmer [dimmermax=70]\n+  }\n+  Thing device AABBCD [address=\"AA.BB.CD\", productKey=\"F00.00.15\"]  {\n+    Channels:\n+      Type dimmer : loadDimmer [dimmermax=60]\n+  }\n+}\n+```\n+\n+**Items**\n+\n+```\n+Dimmer d1 \"dimmer 1\" { channel=\"insteon:device:local:AABBCC:dimmer\"}\n+Dimmer d2 \"dimmer 2\" { channel=\"insteon:device:local:AABBCD:loadDimmer\"}\n+```\n+\n+Setting a maximum level does not affect manual turning on or dimming a switch.\n+\n+### On/Off Outlets\n+\n+Here's how to configure the top and bottom outlet of the in-wall 2 outlet controller:\n+\n+```\n+Switch fOutTop \"Front Outlet Top\"    <socket> { channel=\"insteon:device:local:AABBCC:topOutlet\" }\n+Switch fOutBot \"Front Outlet Bottom\" <socket> { channel=\"insteon:device:local:AABBCC:bottomOutlet\" }\n+```\n+\n+This will give you individual control of each outlet.\n+    \n+### Mini remotes\n+\n+Link the mini remote to be a controller of the modem by using the set button. Link all buttons, one after the other. The 4-button mini remote sends out messages on groups 0x01 - 0x04, each corresponding to one button. The modem's link database (see [Insteon Terminal](https://github.com/pfrommerd/insteon-terminal)) should look like this:\n+\n+```\n+    0000 xx.xx.xx                       xx.xx.xx  RESP  10100010 group: 01 data: 02 2c 41\n+    0000 xx.xx.xx                       xx.xx.xx  RESP  10100010 group: 02 data: 02 2c 41\n+    0000 xx.xx.xx                       xx.xx.xx  RESP  10100010 group: 03 data: 02 2c 41\n+    0000 xx.xx.xx                       xx.xx.xx  RESP  10100010 group: 04 data: 02 2c 41\n+```\n+\n+**Items**\n+This goes into the items file:\n+\n+```\n+    Switch miniRemoteButtonA \"mini remote button a\" { channel=\"insteon:device:local:AABBCC:buttonA\", autoupdate=\"false\" }\n+    Switch miniRemoteButtonB \"mini remote button b\" { channel=\"insteon:device:local:AABBCC:buttonB\", autoupdate=\"false\" }\n+    Switch miniRemoteButtonC \"mini remote button c\" { channel=\"insteon:device:local:AABBCC:buttonC\", autoupdate=\"false\" }\n+    Switch miniRemoteButtonD \"mini remote button d\" { channel=\"insteon:device:local:AABBCC:buttonD\", autoupdate=\"false\" }\n+```\n+\n+**Sitemap**\n+This goes into the sitemap file:\n+\n+```\n+    Switch item=miniRemoteButtonA label=\"mini remote button a\" mappings=[ OFF=\"Off\", ON=\"On\"]\n+    Switch item=miniRemoteButtonB label=\"mini remote button b\" mappings=[ OFF=\"Off\", ON=\"On\"]\n+    Switch item=miniRemoteButtonC label=\"mini remote button c\" mappings=[ OFF=\"Off\", ON=\"On\"]\n+    Switch item=miniRemoteButtonD label=\"mini remote button d\" mappings=[ OFF=\"Off\", ON=\"On\"]\n+```\n+\n+The switches in the GUI just display the mini remote's most recent button presses. They are not operable because the PLM cannot trigger the mini remotes scenes.\n+\n+### Motion sensors\n+\n+Link such that the modem is a responder to the motion sensor. Create a contact.map file in the transforms directory as described elsewhere in this document. Then create entries in the .items file like this:\n+\n+**Items**\n+\n+```\n+    Contact motionSensor             \"motion sensor [MAP(contact.map):%s]\" { channel=\"insteon:device:local:AABBCC:contact\"}\n+    Number  motionSensorBatteryLevel \"motion sensor battery level [%.1f]\"  { channel=\"insteon:device:local:AABBCC:batteryLevel\" }\n+    Number  motionSensorLightLevel   \"motion sensor light level [%.1f]\"    { channel=\"insteon:device:local:AABBCC:lightLevel\" }\n+```\n+\n+This will give you a contact, the battery level, and the light level. Note that battery and light level are only updated when either there is motion, or the sensor battery runs low.\n+\n+### Hidden door sensors\n+\n+Similar in operation to the motion sensor above.  Link such that the modem is a responder to the motion sensor. Create a contact.map file in the transforms directory like the following:\n+\n+```\n+    OPEN=open\n+    CLOSED=closed\n+    -=unknown\n+```\n+\n+**Items**\n+Then create entries in the .items file like this:\n+\n+```\n+    Contact doorSensor             \"Door sensor [MAP(contact.map):%s]\" { channel=\"insteon:device:local:AABBCC:contact\" }\n+    Number  doorSensorBatteryLevel \"Door sensor battery level [%.1f]\"  { channel=\"insteon:device:local:AABBCC:batteryLevel\" }\n+```\n+\n+This will give you a contact and the battery level. Note that battery level is only updated when either there is motion, or the sensor battery runs low.\n+\n+### Locks\n+\n+Read the instructions very carefully: sync with lock within 5 feet to avoid bad connection, link twice for both ON and OFF functionality.\n+\n+**Items**\n+Put something like this into your .items file:\n+\n+```\n+    Switch doorLock \"Front Door [MAP(lock.map):%s]\"  { channel=\"insteon:device:local:AABBCC:switch\" }\n+```\n+\n+and create a file \"lock.map\" in the transforms directory with these entries: \n+\n+```\n+    ON=Lock\n+    OFF=Unlock\n+    -=unknown\n+```\n+\n+### I/O Linc (garage door openers)\n+\n+The I/O Linc devices are really two devices in one: a relay and a contact. Link the modem both ways, as responder and controller using the set buttons as described in the instructions.\n+\n+Add this map into your transforms directory as \"contact.map\":\n+\n+```\n+    OPEN=open\n+    CLOSED=closed\n+    -=unknown\n+```\n+\n+**Items**\n+Along with this into your .items file:\n+\n+```\n+    Switch  garageDoorOpener  \"garage door opener\"                        <garagedoor>  { channel=\"insteon:device:local:AABBCC:switch\", autoupdate=\"false\" }\n+    Contact garageDoorContact \"garage door contact [MAP(contact.map):%s]\"               { channel=\"insteon:device:local:AABBCC:contact\" }\n+```\n+\n+**Sitemap**\n+To make it visible in the GUI, put this into your sitemap file:\n+\n+```\n+    Switch item=garageDoorOpener label=\"garage door opener\" mappings=[ ON=\"OPEN/CLOSE\"]\n+    Text item=garageDoorContact\n+```\n+\n+For safety reasons, only close the garage door if you have visual contact to make sure there is no obstruction! The use of automated rules for closing garage doors is dangerous.\n+\n+> NOTE: If the I/O Linc returns the wrong value when the device is polled (For example you open the garage door and the state correctly shows OPEN, but during polling it shows CLOSED), you probably linked the device with the PLM or hub when the door was in the wrong position. You need unlink and then link again with the door in the opposite position. Please see the Insteon I/O Linc documentation for further details.\n+\n+### Keypads\n+\n+Before you attempt to configure the keypads, please familiarize yourself with the concept of an Insteon group.\n+\n+The Insteon keypad devices typically control one main load and have a number of buttons that will send out group broadcast messages to trigger a scene. If you just want to use the main load switch within openhab just link modem and device with the set buttons as usual, no complicated linking is necessary. But if you want to get the buttons to work, read on.\n+\n+Each button will send out a message for a different, predefined group. Complicating matters further, the button numbering used internally by the device must be mapped to whatever labels are printed on the physical buttons of the device. Here is an example correspondence table:\n+\n+| Group | Button Number | 2487S Label |\n+|-------|---------------|-------------|\n+|  0x01 |        1      |   (Load)    |\n+|  0x03 |        3      |     A       |\n+|  0x04 |        4      |     B       |\n+|  0x05 |        5      |     C       |\n+|  0x06 |        6      |     D       |\n+\n+When e.g. the \"A\" button is pressed (that's button #3 internally) a broadcast message will be sent out to all responders configured to listen to Insteon group #3. This means you must configure the modem as a responder to group #3 (and #4, #5, #6) messages coming from your keypad. For instructions how to do this, check out the [Insteon Terminal](https://github.com/pfrommerd/insteon-terminal). You can even do that with the set buttons (see instructions that come with the keypad).\n+\n+While capturing the messages that the buttons emit is pretty straight forward, controlling the buttons is  another matter. They cannot be simply toggled with a direct command to the device, but instead a broadcast message must be sent on a group number that the button has been programmed to listen to. This means you need to pick a set of unused groups that is globally unique (if you have multiple keypads, each one of them has to use different groups), one group for each button. The example configuration below uses groups 0xf3, 0xf4, 0xf5, and 0xf6. Then link the buttons such that they respond to those groups, and link the modem as a controller for them (see [Insteon Terminal](https://github.com/pfrommerd/insteon-terminal) documentation). In your items file you specify these groups with the \"group=\" parameters such that the binding knows what group number to put on the outgoing message.\n+\n+\n+#### Keypad switches\n+\n+**Items**\n+\n+Here is a simple example, just using the load (main) switch:\n+\n+```\n+    Switch keypadSwitch             \"main load\"          { channel=\"insteon:device:local:AABBCC:loadSwitch\" }\n+    Number keypadSwitchManualChange \"main manual change\" { channel=\"insteon:device:local:AABBCC:loadSwitchManualChange\" }\n+    Switch keypadSwitchFastOnOff    \"main fast on/off\"   { channel=\"insteon:device:local:AABBCC:loadSwitchFastOnOff\" }\n+```\n+\n+Most people will not use the fast on/off features or the manual change feature, so you really only need the first line. To make the buttons available, add the following:\n+\n+**Things**\n+\n+```\n+Bridge insteon:network:local [port=\"/dev/ttyUSB0\"] {\n+  Thing device AABBCC [address=\"AA.BB.CC\", productKey=\"F00.00.15\"] {\n+    Channels:\n+      Type switch : keypadButtonA [ group=\"0xf3\" ]\n+      Type switch : keypadButtonB [ group=\"0xf4\" ]\n+      Type switch : keypadButtonC [ group=\"0xf5\" ]\n+      Type switch : keypadButtonD [ group=\"0xf6\" ]\n+  }\n+}\n+```\n+\n+The value after group must either be a number or string. The hexadecimal value 0xf3 can either converted to a numeric value 243 or the string value \"0xf3\".\n+\n+**Items**\n+\n+```\n+    Switch keypadSwitchA \"keypad button A\" { channel=\"insteon:device:local:AABBCC:keypadButtonA\"}\n+    Switch keypadSwitchB \"keypad button B\" { channel=\"insteon:device:local:AABBCC:keypadButtonB\"}\n+    Switch keypadSwitchC \"keypad button C\" { channel=\"insteon:device:local:AABBCC:keypadButtonC\"}\n+    Switch keypadSwitchD \"keypad button D\" { channel=\"insteon:device:local:AABBCC:keypadButtonD\"}\n+```\n+\n+**Sitemap**\n+\n+The following sitemap will bring the items to life in the GUI:\n+\n+```\n+    Frame label=\"Keypad\" {\n+          Switch item=keypadSwitch label=\"main\"\n+          Switch item=keypadSwitchFastOnOff label=\"fast on/off\"\n+          Switch item=keypadSwitchManualChange label=\"manual change\" mappings=[ 0=\"DOWN\", 1=\"STOP\",  2=\"UP\"]\n+          Switch item=keypadSwitchA label=\"button A\"\n+          Switch item=keypadSwitchB label=\"button B\"\n+          Switch item=keypadSwitchC label=\"button C\"\n+          Switch item=keypadSwitchD label=\"button D\"\n+    }\n+```\n+\n+#### Keypad dimmers\n+\n+The keypad dimmers are like keypad switches, except that the main load is dimmable.\n+\n+**Items**\n+\n+```\n+    Dimmer keypadDimmer           \"dimmer\"                          { channel=\"insteon:device:local:AABBCC:loadDimmer\" }\n+    Switch keypadDimmerButtonA    \"keypad dimmer button A [%d %%]\"  { channel=\"insteon:device:local:AABBCC:keypadButtonA\" }\n+```\n+\n+**Sitemap**\n+\n+```\n+    Slider item=keypadDimmer switchSupport\n+    Switch item=keypadDimmerButtonA label=\"buttonA\"\n+```\n+\n+### Thermostats\n+\n+The thermostat (2441TH) is one of the most complex Insteon devices available. It must first be properly linked to the modem using configuration software like [Insteon Terminal](https://github.com/pfrommerd/insteon-terminal). The Insteon Terminal wiki describes in detail how to link the thermostat, and how to make it publish status update reports.\n+\n+When all is set and done the modem must be configured as a controller to group 0 (not sure why), and a responder to groups 1-5 such that it picks up when the thermostat switches on/off heating and cooling etc, and it must be a responder to special group 0xEF to get status update reports when measured values (temperature) change. Symmetrically, the thermostat must be a responder to group 0, and a controller for groups 1-5 and 0xEF. The linking process is not difficult but needs some persistence. Again, refer to the [Insteon Terminal](https://github.com/pfrommerd/insteon-terminal) documentation.\n+\n+**Items**\n+\n+This is an example of what to put into your .items file:\n+\n+```\n+    Number  thermostatCoolPoint   \"cool point [%.1f \u00b0F]\"  { channel=\"insteon:device:local:AABBCC:coolSetPoint\" }\n+    Number  thermostatHeatPoint   \"heat point [%.1f \u00b0F]\"  { channel=\"insteon:device:local:AABBCC:heatSetPoint\" }\n+    Number  thermostatSystemMode  \"system mode [%d]\"      { channel=\"insteon:device:local:AABBCC:systemMode\" }\n+    Number  thermostatFanMode     \"fan mode [%d]\"         { channel=\"insteon:device:local:AABBCC:fanMode\" }\n+    Number  thermostatIsHeating   \"is heating [%d]\"       { channel=\"insteon:device:local:AABBCC:isHeating\"}\n+    Number  thermostatIsCooling   \"is cooling [%d]\"       { channel=\"insteon:device:local:AABBCC:isCooling\" }\n+    Number  thermostatTempFahren  \"temperature [%.1f \u00b0F]\" { channel=\"insteon:device:local:AABBCC:tempFahrenheit\" }\n+    Number  thermostatTempCelsius \"temperature [%.1f \u00b0C]\" { channel=\"insteon:device:local:AABBCC:tempCelsius\" }\n+    Number  thermostatHumidity    \"humidity [%.0f %%]\"    { channel=\"insteon:device:local:AABBCC:humidity\" }\n+```\n+\n+Add this as well for some more exotic features:\n+\n+```\n+    Number  thermostatACDelay      \"A/C delay [%d min]\"        { channel=\"insteon:device:local:AABBCC:acDelay\" }\n+    Number  thermostatBacklight    \"backlight [%d sec]\"        { channel=\"insteon:device:local:AABBCC:backlightDuration\" }\n+    Number  thermostatStage1       \"A/C stage 1 time [%d min]\" { channel=\"insteon:device:local:AABBCC:stage1Duration\" }\n+    Number  thermostatHumidityHigh \"humidity high [%d %%]\"     { channel=\"insteon:device:local:AABBCC:humidityHigh\" }\n+    Number  thermostatHumidityLow  \"humidity low [%d %%]\"      { channel=\"insteon:device:local:AABBCC:humidityLow\" }\n+```\n+\n+**Sitemap**\n+\n+For the thermostat to display in the GUI, add this to the sitemap file:\n+\n+```\n+    Text   item=thermostatTempCelsius icon=\"temperature\"\n+    Text   item=thermostatTempFahren icon=\"temperature\"\n+    Text   item=thermostatHumidity\n+    Setpoint item=thermostatCoolPoint icon=\"temperature\" minValue=63 maxValue=90 step=1\n+    Setpoint item=thermostatHeatPoint icon=\"temperature\" minValue=50 maxValue=80 step=1\n+    Switch item=thermostatSystemMode  label=\"system mode\" mappings=[ 0=\"OFF\",  1=\"HEAT\", 2=\"COOL\", 3=\"AUTO\", 4=\"PROGRAM\"]\n+    Switch item=thermostatFanMode  label=\"fan mode\" mappings=[ 0=\"AUTO\",  1=\"ALWAYS ON\"]\n+    Switch item=thermostatIsHeating  label=\"is heating\" mappings=[ 0=\"OFF\",  1=\"HEATING\"]\n+    Switch item=thermostatIsCooling  label=\"is cooling\" mappings=[ 0=\"OFF\",  1=\"COOLING\"]\n+    Setpoint item=thermostatACDelay  minValue=2 maxValue=20 step=1\n+    Setpoint item=thermostatBacklight  minValue=0 maxValue=100 step=1\n+    Setpoint item=thermostatHumidityHigh  minValue=0 maxValue=100 step=1\n+    Setpoint item=thermostatHumidityLow   minValue=0 maxValue=100 step=1\n+    Setpoint item=thermostatStage1  minValue=1 maxValue=60 step=1\n+```\n+\n+### Power Meters\n+\n+The iMeter Solo reports both wattage and kilowatt hours, and is updated during the normal polling process of the devices. You can also manually update the current values from the device and reset the device. See the example below:\n+\n+**Items**\n+\n+``` \n+    Number iMeterWatts   \"iMeter [%d watts]\"   { channel=\"insteon:device:local:AABBCC:watts\" }\n+    Number iMeterKwh     \"iMeter [%.04f kwh]\"  { channel=\"insteon:device:local:AABBCC:kwh\" }\n+    Switch iMeterUpdate  \"iMeter Update\"       { channel=\"insteon:device:local:AABBCC:update\" }\n+    Switch iMeterReset   \"iMeter Reset\"        { channel=\"insteon:device:local:AABBCC:reset\" }\n+```\n+\n+### Fan Controllers\n+\n+Here is an example configuration for a FanLinc module, which has a dimmable light and a variable speed fan:\n+\n+**Items**\n+\n+```\n+    Dimmer fanLincDimmer \"fanlinc dimmer [%d %%]\" { channel=\"insteon:device:local:AABBCC:lightDimmer\" }\n+    Number fanLincFan    \"fanlinc fan\"            { channel=\"insteon:device:local:AABBCC:fan\"}\n+```\n+\n+**Sitemap**\n+\n+```\n+    Slider item=fanLincDimmer switchSupport\n+    Switch item=fanLincFan label=\"fan speed\" mappings=[ 0=\"OFF\",  1=\"LOW\", 2=\"MEDIUM\", 3=\"HIGH\"]\n+```\n+\n+### X10 devices", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "04a9796d14dfbc5f3ff997d872f04b6d03ee411d"}, "originalPosition": 590}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTMxNjc5Ng==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            ## Direct sending of group broadcasts (triggering scenes)\n          \n          \n            \n            ## Direct Sending of Group Broadcasts (Triggering Scenes)", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r389316796", "createdAt": "2020-03-07T22:27:31Z", "author": {"login": "kaikreuzer"}, "path": "bundles/org.openhab.binding.insteon/README.md", "diffHunk": "@@ -0,0 +1,719 @@\n+# Insteon Binding\n+\n+Insteon is a home area networking technology developed primarily for connecting light switches and loads. Insteon devices send messages either via the power line, or by means of radio frequency (RF) waves, or both (dual-band). A considerable number of Insteon compatible devices such as switchable relays, thermostats, sensors etc are available. More about Insteon can be found on [Wikipedia](http://en.wikipedia.org/wiki/Insteon).\n+\n+This binding provides access to the Insteon network by means of either an Insteon PowerLinc Modem (PLM), a legacy Insteon Hub 2242-222 or the current 2245-222 Insteon Hub. The modem can be connected to the openHAB server either via a serial port (Model 2413S) or a USB port (Model 2413U). The Insteon PowerLinc Controller (Model 2414U) is not supported since it is a PLC not a PLM. The modem can also be connected via TCP (such as ser2net).  The binding translates openHAB commands into Insteon messages and sends them on the Insteon network. Relevant messages from the Insteon network (like notifications about switches being toggled) are picked up by the modem and converted to openHAB status updates by the binding. The binding also supports sending and receiving of legacy X10 messages.\n+\n+The binding does not support linking new devices on the fly, i.e. all devices must be linked with the modem *before* starting the Insteon binding.\n+\n+openHAB is not a configuration tool! To configure and set up your devices, link the devices manually via the set buttons, or use the free [Insteon Terminal](https://github.com/pfrommerd/insteon-terminal) software. The free HouseLinc software from Insteon can also be used for configuration, but it wipes the modem link database clean on its initial use, requiring to re-link the modem to all devices.\n+\n+## Supported Things\n+\n+| Thing  | Type   | Description                  |\n+|----------|--------|------------------------------|\n+| network  | Bridge | An insteon PLM or hub that is used to communicate with the Insteon devices |\n+|device| Thing | Insteon devices such as dimmers, keypads, sensors, etc. |\n+\n+## Discovery\n+\n+The binding will automatically add the network bridge called local to the Paper UI inbox. Upon proper configuration of the network bridge, the network device database will be downloaded. Any Insteon device that exists in the database and is not currently configured will get added to the inbox.  The naming convention is **Insteon Device AABBCC**, where AA, BB and CC are from the Insteon device address.  X10 devices are not auto discovered. \n+\n+## Thing Configuration\n+\n+###### Network Configuration\n+\n+The Insteon PLM or hub is configured with the following:\n+\n+| Parameter | Default | Required | Description |\n+|----------|---------:|--------:|-------------|\n+| port   |         |   Yes    | **Examples:**<br>- PLM on  Linux: `/dev/ttyS0` or `/dev/ttyUSB0`<br>- Smartenit ZBPLM on Linux: `/dev/ttyUSB0,baudRate=115200`<br>- PLM on Windows: `COM1`<br>- Current  hub (2245-222) at 192.168.1.100 on port 25105, with a poll interval of 1000 ms (1 second): `/hub2/my_user_name:my_password@192.168.1.100:25105,poll_time=1000`<br>- Legacy hub (2242-222) at 192.168.1.100 on port 9761:`/hub/192.168.1.100:9761`<br>- Networked PLM using ser2net at 192.168.1.100 on port 9761:`/tcp/192.168.1.100:9761` |\n+| devicePollIntervalSeconds | 300 |  No  | Poll interval of devices in seconds. Poll too often and you will overload the insteon network, leading to sluggish or no response when trying to send messages to devices. The default poll interval of 300 seconds has been tested and found to be a good compromise in a configuration of about 110 switches/dimmers. |\n+|modemDbRetryTimeoutSeconds|120|No|The number of seconds to wait for the modem database to completely download before retrying again.  Under normal circumstances this will not need to be modified.|\n+| additionalDevices | |       No     | Optional file with additional device types. The syntax of the file is identical to the `device_types.xml` file in the source tree. Please remember to post successfully added device types to the openhab group so the developers can include them into the `device_types.xml` file! |\n+| additionalFeatures | |      No     | Optional file with additional feature templates, like in the `device_features.xml` file in the source tree. |\n+\n+>NOTE: For users upgrading from InsteonPLM, The parameter port_1 is now port. \n+\n+###### Device Configuration\n+\n+The Insteon device is configured with the following required parameters:\n+\n+| Parameter | Description |\n+|----------|-------------|\n+|address|Insteon or X10 address of the device. Insteon device addresses are in the format 'xx.xx.xx', and can be found on the device. X10 device address are in the format 'x.y' and are typically configured on the device.|\n+|productKey|Insteon binding product key that is used to identy the device. Every Insteon device type is uniquely identified by its Insteon product key, typically a six digit hex number. For some of the older device types (in particular the SwitchLinc switches and dimmers), Insteon does not give a product key, so an arbitrary fake one of the format Fxx.xx.xx (or Xxx.xx.xx for X10 devices) is assigned by the binding.|\n+\n+The following is a list of the product keys and associated devices. These have been tested and should work out of the box:\n+\n+| Model | Description | Product Key | tested by |\n+|-------|-------------|-------------|-----------|\n+| 2477D | SwitchLinc Dimmer | F00.00.01 | Bernd Pfrommer |\n+| 2477S | SwitchLinc Switch | F00.00.02 | Bernd Pfrommer |\n+| 2845-222 | Hidden Door Sensor | F00.00.03 | Josenivaldo Benito |\n+| 2876S | ICON Switch | F00.00.04 | Patrick Giasson |\n+| 2456D3 | LampLinc V2 | F00.00.05 | Patrick Giasson |\n+| 2442-222 | Micro Dimmer | F00.00.06 | Josenivaldo Benito |\n+| 2453-222 | DIN Rail On/Off | F00.00.07 | Josenivaldo Benito |\n+| 2452-222 | DIN Rail Dimmer | F00.00.08 | Josenivaldo Benito |\n+| 2458-A1 | MorningLinc RF Lock Controller | F00.00.09 | cdeadlock |\n+| 2852-222 | Leak Sensor | F00.00.0A | Kirk McCann |\n+| 2672-422 | LED Dimmer | F00.00.0B | ??? |\n+| 2476D | SwitchLinc Dimmer | F00.00.0C | LiberatorUSA |\n+| 2634-222 | On/Off Dual-Band Outdoor Module | F00.00.0D | LiberatorUSA |\n+| 2342-2 | Mini Remote | F00.00.10 | Bernd Pfrommer |\n+| 2663-222 | On/Off Outlet | 0x000039 | SwissKid |\n+| 2466D | ToggleLinc Dimmer | F00.00.11 | Rob Nielsen |\n+| 2466S | ToggleLinc Switch | F00.00.12 | Rob Nielsen |\n+| 2672-222 | LED Bulb | F00.00.13 | Rob Nielsen |\n+| 2487S | KeypadLinc On/Off 6-Button | F00.00.14 | Bernd Pfrommer |\n+| 2334-232 | KeypadLink Dimmer 6-Button | F00.00.15 | Rob Nielsen |\n+| 2334-232 | KeypadLink Dimmer 8-Button | F00.00.16 | Rob Nielsen |\n+| 2423A1 | iMeter Solo Power Meter | F00.00.17 | Rob Nielsen |\n+| 2423A1 | Thermostat 2441TH | F00.00.18 | Daniel Campbell, Bernd Pfrommer |\n+| 2457D2 | LampLinc Dimmer | F00.00.19 | Jonathan Huizingh |\n+| 2475SDB | In-LineLinc Relay | F00.00.1A | Jim Howard |\n+| 2635-222 | On/Off Module | F00.00.1B | Jonathan Huizingh |\n+| 2475F | FanLinc Module | F00.00.1C | Brian Tillman |\n+| 2456S3 | ApplianceLinc | F00.00.1D | ??? |\n+| 2674-222 | LED Bulb (recessed) | F00.00.1E | Steve Bate |\n+| 2477SA1 | 220V 30-amp Load Controller N/O | F00.00.1F | Shawn R. |\n+| 2342-222 | Mini Remote (8 Button) | F00.00.20 | Bernd Pfrommer |\n+| 2441V | Insteon Thermostat Adaptor for Venstar | F00.00.21 | Bernd Pfrommer |\n+| 2982-222 | Insteon Smoke Bridge | F00.00.22 | Bernd Pfrommer |\n+| 2450 | IO Link | 0x00001A | Bernd Pfrommer |\n+| 2486D | KeypadLinc Dimmer | 0x000037 | Patrick Giasson, Joe Barnum |\n+| 2484DWH8 | KeypadLinc Countdown Timer | 0x000041 | Rob Nielsen |\n+| 2413U | PowerLinc 2413U USB modem | 0x000045 | Bernd Pfrommer |\n+| 2843-222 | Wireless Open/Close Sensor | 0x000049 | Josenivaldo Benito |\n+| 2842-222 | Motion Sensor | 0x00004A | Bernd Pfrommer |\n+| 2486DWH8 | KeypadLinc Dimmer | 0x000051 | Chris Graham |\n+| 2472D | OutletLincDimmer | 0x000068 | Chris Graham |\n+| X10 switch | generic X10 switch | X00.00.01 | Bernd Pfrommer |\n+| X10 dimmer | generic X10 dimmer | X00.00.02 | Bernd Pfrommer |\n+| X10 motion | generic X10 motion sensor | X00.00.03 | Bernd Pfrommer |\n+\n+## Channels\n+\n+Below is the list of possible channels for the Insteon devices. In order to determing which channels a device supports, you can either look at the device in Paper UI, or find it in the openhab log file.\n+\n+| channel  | type   | description                  |\n+|----------|--------|------------------------------|\n+| acDelay | Number | AC Delay |\n+| backlightDuration | Number | Back Light Duration |\n+| batteryLevel | Number | Battery Level |\n+| batteryWatermarkLevel | Number | Battery Watermark Level |\n+| bottomOutlet | Switch | Bottom Outlet |\n+| buttonA | Switch | Button A |\n+| buttonB | Switch | Button B |\n+| buttonC | Switch | Button C |\n+| buttonD | Switch | Button D |\n+| buttonE | Switch | Button E |\n+| buttonF | Switch | Button F |\n+| buttonG | Switch | Button G |\n+| buttonH | Switch | Button H |\n+| broadcastOnOff | Switch | Broadcast On/Off |\n+| contact | Contact | Contact |\n+| coolSetPoint | Number | Cool Set Point |\n+| dimmer | Dimmer | Dimmer |\n+| fan | Number | Fan |\n+| fanMode | Number | Fan Mode |\n+| fastOnOff | Switch | Fast On/Off |\n+| fastOnOffButtonA | Switch | Fast On/Off Button A |\n+| fastOnOffButtonB | Switch | Fast On/Off Button B |\n+| fastOnOffButtonC | Switch | Fast On/Off Button C |\n+| fastOnOffButtonD | Switch | Fast On/Off Button D |\n+| heatSetPoint | Number | Heat Set Point |\n+| humidity | Number | Humidity |\n+| humidityHigh | Number | Humidity High |\n+| humidityLow | Number | Humidity Low |\n+| isCooling | Number | Is Cooling |\n+| isHeating | Number | Is Heating |\n+| keypadButtonA | Switch | Keypad Button A |\n+| keypadButtonB | Switch | Keypad Button B |\n+| keypadButtonC | Switch | Keypad Button C |\n+| keypadButtonD | Switch | Keypad Button D |\n+| keypadButtonE | Switch | Keypad Button E |\n+| keypadButtonF | Switch | Keypad Button F |\n+| keypadButtonG | Switch | Keypad Button G |\n+| keypadButtonH | Switch | Keypad Button H |\n+| kWh | Number | Kilowatt Hour |\n+| lastHeardFrom | DateTime | Last Heard From |\n+| ledBrightness | Number | LED brightness |\n+| lightDimmer | Dimmer | light Dimmer |\n+| lightLevel | Number | Light Level |\n+| loadDimmer | Dimmer | Load Dimmer |\n+| loadSwitch | Switch | Load Switch |\n+| loadSwitchFastOnOff | Switch | Load Switch Fast On/Off |\n+| loadSwitchManualChange | Number | Load Switch Manual Change |\n+| manualChange | Number | Manual Change |\n+| manualChangeButtonA | Number | Manual Change Button A |\n+| manualChangeButtonB | Number | Manual Change Button B |\n+| manualChangeButtonC | Number | Manual Change Button C |\n+| manualChangeButtonD | Number | Manual Change Button D |\n+| notification | Number | Notification |\n+| onLevel | Number | On Level |\n+| rampDimmer | Dimmer | Ramp Dimmer |\n+| rampRate | Number | Ramp Rate |\n+| reset | Switch | Reset |\n+| stage1Duration | Number | Stage 1 Duration |\n+| switch | Switch | Switch |\n+| systemMode | Number | System Mode |\n+| tempCelsius | Number | Temperature Celsius |\n+| tempFahrenheit | Number | Temperature Fahrenheit |\n+| topOutlet | Switch | Top Outlet |\n+| update | Switch | Update |\n+| watts | Number | Watts |\n+\n+\n+## Full Example\n+\n+Sample things file:\n+\n+```\n+Bridge insteon:network:local [port=\"/dev/ttyUSB0\"] {\n+  Thing device 22F8A8 [address=\"22.F8.A8\", productKey=\"F00.00.15\"] {\n+    Channels:\n+      Type switch : keypadButtonA [ group=3 ]\n+      Type switch : keypadButtonB [ group=4 ]\n+      Type switch : keypadButtonC [ group=5 ]\n+      Type switch : keypadButtonD [ group=6 ]\n+  }\n+  Thing device 238D93 [address=\"23.8D.93\", productKey=\"F00.00.12\"]\n+  Thing device 238F55 [address=\"23.8F.55\", productKey=\"F00.00.11\"] {\n+    Channels:\n+      Type dimmer : dimmer [related=\"23.B0.D9+23.8F.C9\"]\n+  }\n+  Thing device 238FC9 [address=\"23.8F.C9\", productKey=\"F00.00.11\"] {\n+    Channels:\n+      Type dimmer : dimmer [related=\"23.8F.55+23.B0.D9\"]\n+  }\n+  Thing device 23B0D9 [address=\"23.B0.D9\", productKey=\"F00.00.11\"] {\n+    Channels:\n+      Type dimmer : dimmer [related=\"23.8F.55+23.8F.C9\"]\n+  }\n+  Thing device 243141 [address=\"24.31.41\", productKey=\"F00.00.11\"]  {\n+    Channels:\n+      Type dimmer : dimmer [dimmermax=60]\n+  }\n+}\n+```\n+\n+Sample items file:\n+\n+```\n+Switch switch1 { channel=\"insteon:device:local:243141:switch\" }\n+Dimmer dimmer1 { channel=\"insteon:device:local:238F55:dimmer\" }\n+Dimmer dimmer2 { channel=\"insteon:device:local:23B0D9:dimmer\" }\n+Dimmer dimmer3 { channel=\"insteon:device:local:238FC9:dimmer\" }\n+Dimmer keypad  { channel=\"insteon:device:local:22F8A8:loadDimmer\" }\n+Switch keypadA { channel=\"insteon:device:local:22F8A8:keypadButtonA\" }\n+Switch keypadB { channel=\"insteon:device:local:22F8A8:keypadButtonB\" }\n+Switch keypadC { channel=\"insteon:device:local:22F8A8:keypadButtonC\" }\n+Switch keypadD { channel=\"insteon:device:local:22F8A8:keypadButtonD\" }\n+Dimmer dimmer  { channel=\"insteon:device:local:238D93:dimmer\" }\n+```\n+\n+## Insteon Groups and Scenes\n+\n+How do Insteon devices tell other devices on the network that their state has changed? They send out a broadcast message, labeled with a specific *group* number. All devices (called *responders*) that are configured to listen to this message will then go into a pre-defined state. For instance when light switch A is switched to \"ON\", it will send out a message to group #1, and all responders will react to it, e.g they may go into the \"ON\" position as well. Since more than one device can participate, the sending out of the broadcast message and the subsequent state change of the responders is referred to as \"triggering a scene\". At the device and PLM level, the concept of a \"scene\" does not exist, so you will find it notably absent in the binding code and this document. A scene is strictly a higher level concept, introduced to shield the user from the details of how the communication is implemented.\n+\n+Many Insteon devices send out messages on different group numbers, depending on what happens to them. A leak sensor may send out a message on group #1 when dry, and on group #2 when wet. The default group used for e.g. linking two light switches is usually group #1.\n+\n+## Insteon binding process\n+\n+Before Insteon devices communicate with one another, they must be linked. During the linking process, one of the devices will be the \"Controller\", the other the \"Responder\" (see e.g. the [SwitchLinc Instructions](https://www.insteon.com/pdf/2477S.pdf)).\n+\n+The responder listens to messages from the controller, and reacts to them. Note that except for the case of a motion detector (which is just a controller to the modem), the modem controls the device (e.g. send on/off messages to it), and the device controls the modem (so the modem learns about the switch being toggled). For this reason, most devices and in particular switches/dimmers should be linked twice, with one taking the role of controller during the first linking, and the other acting as controller during the second linking process. To do so, first press and hold the \"Set\" button on the modem until the light starts blinking. Then press and hold the \"Set\" button on the remote device,\n+e.g. the light switch, until it double beeps (the light on the modem should go off as well). Now do exactly the reverse: press and hold the \"Set\" button on the remote device until its light starts blinking, then press and hold the \"Set\" button on the modem until it double beeps, and the light of the remote device (switch) goes off. Done.\n+\n+For some of the more sophisticated devices the complete linking process can no longer be done with the set buttons, but requires software like e.g. [Insteon Terminal](https://github.com/pfrommerd/insteon-terminal).\n+\n+## Insteon Features\n+\n+Since Insteon devices can have multiple features (for instance a switchable relay and a contact sensor) under a single Insteon address, an openHAB item is not bound to a device, but to a given feature of a device. For example, the following lines would create two Number items referring to the same thermostat device, but to different features of it:\n+\n+```\n+Number  thermostatCoolPoint \"cool point [%.1f \u00b0F]\" { channel=\"insteon:device:local:32F422:coolSetPoint\" }\n+Number  thermostatHeatPoint \"heat point [%.1f \u00b0F]\" { channel=\"insteon:device:local:32F422:heatSetPoint\" }\n+```\n+\n+### Simple light switches\n+\n+The following example shows how to configure a simple light switch (2477S) in the .items file:\n+\n+```\n+Switch officeLight \"office light\"  { channel=\"insteon:device:local:AABBCC:switch\" }\n+```\n+\n+### Simple dimmers\n+\n+Here is how to configure a simple dimmer (2477D) in the .items file:\n+\n+```\n+Dimmer kitchenChandelier \"kitchen chandelier\" { channel=\"insteon:device:local:AABBCC:dimmer\" }\n+```\n+\n+Dimmers can be configured with a maximum level when turning a device on or setting a percentage level. If a maximum level is configured, openHAB will never set the level of the dimmer above the level specified. The parameter dimmermax must be defined for the channel. The below example sets a maximum level of 70% for dim 1 and 60% for dim 2:\n+\n+**Things**\n+\n+```\n+Bridge insteon:network:local [port=\"/dev/ttyUSB0\"] {\n+  Thing device AABBCC [address=\"AA.BB.CC\", productKey=\"F00.00.11\"]  {\n+    Channels:\n+      Type dimmer : dimmer [dimmermax=70]\n+  }\n+  Thing device AABBCD [address=\"AA.BB.CD\", productKey=\"F00.00.15\"]  {\n+    Channels:\n+      Type dimmer : loadDimmer [dimmermax=60]\n+  }\n+}\n+```\n+\n+**Items**\n+\n+```\n+Dimmer d1 \"dimmer 1\" { channel=\"insteon:device:local:AABBCC:dimmer\"}\n+Dimmer d2 \"dimmer 2\" { channel=\"insteon:device:local:AABBCD:loadDimmer\"}\n+```\n+\n+Setting a maximum level does not affect manual turning on or dimming a switch.\n+\n+### On/Off Outlets\n+\n+Here's how to configure the top and bottom outlet of the in-wall 2 outlet controller:\n+\n+```\n+Switch fOutTop \"Front Outlet Top\"    <socket> { channel=\"insteon:device:local:AABBCC:topOutlet\" }\n+Switch fOutBot \"Front Outlet Bottom\" <socket> { channel=\"insteon:device:local:AABBCC:bottomOutlet\" }\n+```\n+\n+This will give you individual control of each outlet.\n+    \n+### Mini remotes\n+\n+Link the mini remote to be a controller of the modem by using the set button. Link all buttons, one after the other. The 4-button mini remote sends out messages on groups 0x01 - 0x04, each corresponding to one button. The modem's link database (see [Insteon Terminal](https://github.com/pfrommerd/insteon-terminal)) should look like this:\n+\n+```\n+    0000 xx.xx.xx                       xx.xx.xx  RESP  10100010 group: 01 data: 02 2c 41\n+    0000 xx.xx.xx                       xx.xx.xx  RESP  10100010 group: 02 data: 02 2c 41\n+    0000 xx.xx.xx                       xx.xx.xx  RESP  10100010 group: 03 data: 02 2c 41\n+    0000 xx.xx.xx                       xx.xx.xx  RESP  10100010 group: 04 data: 02 2c 41\n+```\n+\n+**Items**\n+This goes into the items file:\n+\n+```\n+    Switch miniRemoteButtonA \"mini remote button a\" { channel=\"insteon:device:local:AABBCC:buttonA\", autoupdate=\"false\" }\n+    Switch miniRemoteButtonB \"mini remote button b\" { channel=\"insteon:device:local:AABBCC:buttonB\", autoupdate=\"false\" }\n+    Switch miniRemoteButtonC \"mini remote button c\" { channel=\"insteon:device:local:AABBCC:buttonC\", autoupdate=\"false\" }\n+    Switch miniRemoteButtonD \"mini remote button d\" { channel=\"insteon:device:local:AABBCC:buttonD\", autoupdate=\"false\" }\n+```\n+\n+**Sitemap**\n+This goes into the sitemap file:\n+\n+```\n+    Switch item=miniRemoteButtonA label=\"mini remote button a\" mappings=[ OFF=\"Off\", ON=\"On\"]\n+    Switch item=miniRemoteButtonB label=\"mini remote button b\" mappings=[ OFF=\"Off\", ON=\"On\"]\n+    Switch item=miniRemoteButtonC label=\"mini remote button c\" mappings=[ OFF=\"Off\", ON=\"On\"]\n+    Switch item=miniRemoteButtonD label=\"mini remote button d\" mappings=[ OFF=\"Off\", ON=\"On\"]\n+```\n+\n+The switches in the GUI just display the mini remote's most recent button presses. They are not operable because the PLM cannot trigger the mini remotes scenes.\n+\n+### Motion sensors\n+\n+Link such that the modem is a responder to the motion sensor. Create a contact.map file in the transforms directory as described elsewhere in this document. Then create entries in the .items file like this:\n+\n+**Items**\n+\n+```\n+    Contact motionSensor             \"motion sensor [MAP(contact.map):%s]\" { channel=\"insteon:device:local:AABBCC:contact\"}\n+    Number  motionSensorBatteryLevel \"motion sensor battery level [%.1f]\"  { channel=\"insteon:device:local:AABBCC:batteryLevel\" }\n+    Number  motionSensorLightLevel   \"motion sensor light level [%.1f]\"    { channel=\"insteon:device:local:AABBCC:lightLevel\" }\n+```\n+\n+This will give you a contact, the battery level, and the light level. Note that battery and light level are only updated when either there is motion, or the sensor battery runs low.\n+\n+### Hidden door sensors\n+\n+Similar in operation to the motion sensor above.  Link such that the modem is a responder to the motion sensor. Create a contact.map file in the transforms directory like the following:\n+\n+```\n+    OPEN=open\n+    CLOSED=closed\n+    -=unknown\n+```\n+\n+**Items**\n+Then create entries in the .items file like this:\n+\n+```\n+    Contact doorSensor             \"Door sensor [MAP(contact.map):%s]\" { channel=\"insteon:device:local:AABBCC:contact\" }\n+    Number  doorSensorBatteryLevel \"Door sensor battery level [%.1f]\"  { channel=\"insteon:device:local:AABBCC:batteryLevel\" }\n+```\n+\n+This will give you a contact and the battery level. Note that battery level is only updated when either there is motion, or the sensor battery runs low.\n+\n+### Locks\n+\n+Read the instructions very carefully: sync with lock within 5 feet to avoid bad connection, link twice for both ON and OFF functionality.\n+\n+**Items**\n+Put something like this into your .items file:\n+\n+```\n+    Switch doorLock \"Front Door [MAP(lock.map):%s]\"  { channel=\"insteon:device:local:AABBCC:switch\" }\n+```\n+\n+and create a file \"lock.map\" in the transforms directory with these entries: \n+\n+```\n+    ON=Lock\n+    OFF=Unlock\n+    -=unknown\n+```\n+\n+### I/O Linc (garage door openers)\n+\n+The I/O Linc devices are really two devices in one: a relay and a contact. Link the modem both ways, as responder and controller using the set buttons as described in the instructions.\n+\n+Add this map into your transforms directory as \"contact.map\":\n+\n+```\n+    OPEN=open\n+    CLOSED=closed\n+    -=unknown\n+```\n+\n+**Items**\n+Along with this into your .items file:\n+\n+```\n+    Switch  garageDoorOpener  \"garage door opener\"                        <garagedoor>  { channel=\"insteon:device:local:AABBCC:switch\", autoupdate=\"false\" }\n+    Contact garageDoorContact \"garage door contact [MAP(contact.map):%s]\"               { channel=\"insteon:device:local:AABBCC:contact\" }\n+```\n+\n+**Sitemap**\n+To make it visible in the GUI, put this into your sitemap file:\n+\n+```\n+    Switch item=garageDoorOpener label=\"garage door opener\" mappings=[ ON=\"OPEN/CLOSE\"]\n+    Text item=garageDoorContact\n+```\n+\n+For safety reasons, only close the garage door if you have visual contact to make sure there is no obstruction! The use of automated rules for closing garage doors is dangerous.\n+\n+> NOTE: If the I/O Linc returns the wrong value when the device is polled (For example you open the garage door and the state correctly shows OPEN, but during polling it shows CLOSED), you probably linked the device with the PLM or hub when the door was in the wrong position. You need unlink and then link again with the door in the opposite position. Please see the Insteon I/O Linc documentation for further details.\n+\n+### Keypads\n+\n+Before you attempt to configure the keypads, please familiarize yourself with the concept of an Insteon group.\n+\n+The Insteon keypad devices typically control one main load and have a number of buttons that will send out group broadcast messages to trigger a scene. If you just want to use the main load switch within openhab just link modem and device with the set buttons as usual, no complicated linking is necessary. But if you want to get the buttons to work, read on.\n+\n+Each button will send out a message for a different, predefined group. Complicating matters further, the button numbering used internally by the device must be mapped to whatever labels are printed on the physical buttons of the device. Here is an example correspondence table:\n+\n+| Group | Button Number | 2487S Label |\n+|-------|---------------|-------------|\n+|  0x01 |        1      |   (Load)    |\n+|  0x03 |        3      |     A       |\n+|  0x04 |        4      |     B       |\n+|  0x05 |        5      |     C       |\n+|  0x06 |        6      |     D       |\n+\n+When e.g. the \"A\" button is pressed (that's button #3 internally) a broadcast message will be sent out to all responders configured to listen to Insteon group #3. This means you must configure the modem as a responder to group #3 (and #4, #5, #6) messages coming from your keypad. For instructions how to do this, check out the [Insteon Terminal](https://github.com/pfrommerd/insteon-terminal). You can even do that with the set buttons (see instructions that come with the keypad).\n+\n+While capturing the messages that the buttons emit is pretty straight forward, controlling the buttons is  another matter. They cannot be simply toggled with a direct command to the device, but instead a broadcast message must be sent on a group number that the button has been programmed to listen to. This means you need to pick a set of unused groups that is globally unique (if you have multiple keypads, each one of them has to use different groups), one group for each button. The example configuration below uses groups 0xf3, 0xf4, 0xf5, and 0xf6. Then link the buttons such that they respond to those groups, and link the modem as a controller for them (see [Insteon Terminal](https://github.com/pfrommerd/insteon-terminal) documentation). In your items file you specify these groups with the \"group=\" parameters such that the binding knows what group number to put on the outgoing message.\n+\n+\n+#### Keypad switches\n+\n+**Items**\n+\n+Here is a simple example, just using the load (main) switch:\n+\n+```\n+    Switch keypadSwitch             \"main load\"          { channel=\"insteon:device:local:AABBCC:loadSwitch\" }\n+    Number keypadSwitchManualChange \"main manual change\" { channel=\"insteon:device:local:AABBCC:loadSwitchManualChange\" }\n+    Switch keypadSwitchFastOnOff    \"main fast on/off\"   { channel=\"insteon:device:local:AABBCC:loadSwitchFastOnOff\" }\n+```\n+\n+Most people will not use the fast on/off features or the manual change feature, so you really only need the first line. To make the buttons available, add the following:\n+\n+**Things**\n+\n+```\n+Bridge insteon:network:local [port=\"/dev/ttyUSB0\"] {\n+  Thing device AABBCC [address=\"AA.BB.CC\", productKey=\"F00.00.15\"] {\n+    Channels:\n+      Type switch : keypadButtonA [ group=\"0xf3\" ]\n+      Type switch : keypadButtonB [ group=\"0xf4\" ]\n+      Type switch : keypadButtonC [ group=\"0xf5\" ]\n+      Type switch : keypadButtonD [ group=\"0xf6\" ]\n+  }\n+}\n+```\n+\n+The value after group must either be a number or string. The hexadecimal value 0xf3 can either converted to a numeric value 243 or the string value \"0xf3\".\n+\n+**Items**\n+\n+```\n+    Switch keypadSwitchA \"keypad button A\" { channel=\"insteon:device:local:AABBCC:keypadButtonA\"}\n+    Switch keypadSwitchB \"keypad button B\" { channel=\"insteon:device:local:AABBCC:keypadButtonB\"}\n+    Switch keypadSwitchC \"keypad button C\" { channel=\"insteon:device:local:AABBCC:keypadButtonC\"}\n+    Switch keypadSwitchD \"keypad button D\" { channel=\"insteon:device:local:AABBCC:keypadButtonD\"}\n+```\n+\n+**Sitemap**\n+\n+The following sitemap will bring the items to life in the GUI:\n+\n+```\n+    Frame label=\"Keypad\" {\n+          Switch item=keypadSwitch label=\"main\"\n+          Switch item=keypadSwitchFastOnOff label=\"fast on/off\"\n+          Switch item=keypadSwitchManualChange label=\"manual change\" mappings=[ 0=\"DOWN\", 1=\"STOP\",  2=\"UP\"]\n+          Switch item=keypadSwitchA label=\"button A\"\n+          Switch item=keypadSwitchB label=\"button B\"\n+          Switch item=keypadSwitchC label=\"button C\"\n+          Switch item=keypadSwitchD label=\"button D\"\n+    }\n+```\n+\n+#### Keypad dimmers\n+\n+The keypad dimmers are like keypad switches, except that the main load is dimmable.\n+\n+**Items**\n+\n+```\n+    Dimmer keypadDimmer           \"dimmer\"                          { channel=\"insteon:device:local:AABBCC:loadDimmer\" }\n+    Switch keypadDimmerButtonA    \"keypad dimmer button A [%d %%]\"  { channel=\"insteon:device:local:AABBCC:keypadButtonA\" }\n+```\n+\n+**Sitemap**\n+\n+```\n+    Slider item=keypadDimmer switchSupport\n+    Switch item=keypadDimmerButtonA label=\"buttonA\"\n+```\n+\n+### Thermostats\n+\n+The thermostat (2441TH) is one of the most complex Insteon devices available. It must first be properly linked to the modem using configuration software like [Insteon Terminal](https://github.com/pfrommerd/insteon-terminal). The Insteon Terminal wiki describes in detail how to link the thermostat, and how to make it publish status update reports.\n+\n+When all is set and done the modem must be configured as a controller to group 0 (not sure why), and a responder to groups 1-5 such that it picks up when the thermostat switches on/off heating and cooling etc, and it must be a responder to special group 0xEF to get status update reports when measured values (temperature) change. Symmetrically, the thermostat must be a responder to group 0, and a controller for groups 1-5 and 0xEF. The linking process is not difficult but needs some persistence. Again, refer to the [Insteon Terminal](https://github.com/pfrommerd/insteon-terminal) documentation.\n+\n+**Items**\n+\n+This is an example of what to put into your .items file:\n+\n+```\n+    Number  thermostatCoolPoint   \"cool point [%.1f \u00b0F]\"  { channel=\"insteon:device:local:AABBCC:coolSetPoint\" }\n+    Number  thermostatHeatPoint   \"heat point [%.1f \u00b0F]\"  { channel=\"insteon:device:local:AABBCC:heatSetPoint\" }\n+    Number  thermostatSystemMode  \"system mode [%d]\"      { channel=\"insteon:device:local:AABBCC:systemMode\" }\n+    Number  thermostatFanMode     \"fan mode [%d]\"         { channel=\"insteon:device:local:AABBCC:fanMode\" }\n+    Number  thermostatIsHeating   \"is heating [%d]\"       { channel=\"insteon:device:local:AABBCC:isHeating\"}\n+    Number  thermostatIsCooling   \"is cooling [%d]\"       { channel=\"insteon:device:local:AABBCC:isCooling\" }\n+    Number  thermostatTempFahren  \"temperature [%.1f \u00b0F]\" { channel=\"insteon:device:local:AABBCC:tempFahrenheit\" }\n+    Number  thermostatTempCelsius \"temperature [%.1f \u00b0C]\" { channel=\"insteon:device:local:AABBCC:tempCelsius\" }\n+    Number  thermostatHumidity    \"humidity [%.0f %%]\"    { channel=\"insteon:device:local:AABBCC:humidity\" }\n+```\n+\n+Add this as well for some more exotic features:\n+\n+```\n+    Number  thermostatACDelay      \"A/C delay [%d min]\"        { channel=\"insteon:device:local:AABBCC:acDelay\" }\n+    Number  thermostatBacklight    \"backlight [%d sec]\"        { channel=\"insteon:device:local:AABBCC:backlightDuration\" }\n+    Number  thermostatStage1       \"A/C stage 1 time [%d min]\" { channel=\"insteon:device:local:AABBCC:stage1Duration\" }\n+    Number  thermostatHumidityHigh \"humidity high [%d %%]\"     { channel=\"insteon:device:local:AABBCC:humidityHigh\" }\n+    Number  thermostatHumidityLow  \"humidity low [%d %%]\"      { channel=\"insteon:device:local:AABBCC:humidityLow\" }\n+```\n+\n+**Sitemap**\n+\n+For the thermostat to display in the GUI, add this to the sitemap file:\n+\n+```\n+    Text   item=thermostatTempCelsius icon=\"temperature\"\n+    Text   item=thermostatTempFahren icon=\"temperature\"\n+    Text   item=thermostatHumidity\n+    Setpoint item=thermostatCoolPoint icon=\"temperature\" minValue=63 maxValue=90 step=1\n+    Setpoint item=thermostatHeatPoint icon=\"temperature\" minValue=50 maxValue=80 step=1\n+    Switch item=thermostatSystemMode  label=\"system mode\" mappings=[ 0=\"OFF\",  1=\"HEAT\", 2=\"COOL\", 3=\"AUTO\", 4=\"PROGRAM\"]\n+    Switch item=thermostatFanMode  label=\"fan mode\" mappings=[ 0=\"AUTO\",  1=\"ALWAYS ON\"]\n+    Switch item=thermostatIsHeating  label=\"is heating\" mappings=[ 0=\"OFF\",  1=\"HEATING\"]\n+    Switch item=thermostatIsCooling  label=\"is cooling\" mappings=[ 0=\"OFF\",  1=\"COOLING\"]\n+    Setpoint item=thermostatACDelay  minValue=2 maxValue=20 step=1\n+    Setpoint item=thermostatBacklight  minValue=0 maxValue=100 step=1\n+    Setpoint item=thermostatHumidityHigh  minValue=0 maxValue=100 step=1\n+    Setpoint item=thermostatHumidityLow   minValue=0 maxValue=100 step=1\n+    Setpoint item=thermostatStage1  minValue=1 maxValue=60 step=1\n+```\n+\n+### Power Meters\n+\n+The iMeter Solo reports both wattage and kilowatt hours, and is updated during the normal polling process of the devices. You can also manually update the current values from the device and reset the device. See the example below:\n+\n+**Items**\n+\n+``` \n+    Number iMeterWatts   \"iMeter [%d watts]\"   { channel=\"insteon:device:local:AABBCC:watts\" }\n+    Number iMeterKwh     \"iMeter [%.04f kwh]\"  { channel=\"insteon:device:local:AABBCC:kwh\" }\n+    Switch iMeterUpdate  \"iMeter Update\"       { channel=\"insteon:device:local:AABBCC:update\" }\n+    Switch iMeterReset   \"iMeter Reset\"        { channel=\"insteon:device:local:AABBCC:reset\" }\n+```\n+\n+### Fan Controllers\n+\n+Here is an example configuration for a FanLinc module, which has a dimmable light and a variable speed fan:\n+\n+**Items**\n+\n+```\n+    Dimmer fanLincDimmer \"fanlinc dimmer [%d %%]\" { channel=\"insteon:device:local:AABBCC:lightDimmer\" }\n+    Number fanLincFan    \"fanlinc fan\"            { channel=\"insteon:device:local:AABBCC:fan\"}\n+```\n+\n+**Sitemap**\n+\n+```\n+    Slider item=fanLincDimmer switchSupport\n+    Switch item=fanLincFan label=\"fan speed\" mappings=[ 0=\"OFF\",  1=\"LOW\", 2=\"MEDIUM\", 3=\"HIGH\"]\n+```\n+\n+### X10 devices\n+\n+It is worth noting that both the Inseon PLM and the 2014 Hub can both command X10 devices over the powerline, and also set switch stats based on X10 signals received over the powerline.  This allows openHAB not only control X10 devices without the need for other hardwaare, but it can also have rules that react to incoming X10 powerline commands.  While you cannot bind the the X10 devices to the Insteon PLM/HUB, here are some examples for configuring X10 devices. Be aware that most X10 switches/dimmers send no status updates, i.e. openHAB will not learn about switches that are toggled manually. Further note that\n+X10 devices are addressed with `houseCode.unitCode`, e.g. `A.2`.\n+\n+**Items**\n+\n+```\n+    Switch x10Switch  \"X10 switch\" { channel=\"insteon:device:local:AABB:switch\" }\n+    Dimmer x10Dimmer  \"X10 dimmer\" { channel=\"insteon:device:local:AABB:dimmer\" }\n+    Contact x10Motion \"X10 motion\" { channel=\"insteon:device:local:AABB:contact\" }\n+```\n+\n+## Direct sending of group broadcasts (triggering scenes)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "04a9796d14dfbc5f3ff997d872f04b6d03ee411d"}, "originalPosition": 603}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTMxNjgxOQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            ## 3-way switch configurations and the \"related\" keyword\n          \n          \n            \n            ## 3-way Switch Configurations and the \"related\" Keyword", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r389316819", "createdAt": "2020-03-07T22:28:06Z", "author": {"login": "kaikreuzer"}, "path": "bundles/org.openhab.binding.insteon/README.md", "diffHunk": "@@ -0,0 +1,719 @@\n+# Insteon Binding\n+\n+Insteon is a home area networking technology developed primarily for connecting light switches and loads. Insteon devices send messages either via the power line, or by means of radio frequency (RF) waves, or both (dual-band). A considerable number of Insteon compatible devices such as switchable relays, thermostats, sensors etc are available. More about Insteon can be found on [Wikipedia](http://en.wikipedia.org/wiki/Insteon).\n+\n+This binding provides access to the Insteon network by means of either an Insteon PowerLinc Modem (PLM), a legacy Insteon Hub 2242-222 or the current 2245-222 Insteon Hub. The modem can be connected to the openHAB server either via a serial port (Model 2413S) or a USB port (Model 2413U). The Insteon PowerLinc Controller (Model 2414U) is not supported since it is a PLC not a PLM. The modem can also be connected via TCP (such as ser2net).  The binding translates openHAB commands into Insteon messages and sends them on the Insteon network. Relevant messages from the Insteon network (like notifications about switches being toggled) are picked up by the modem and converted to openHAB status updates by the binding. The binding also supports sending and receiving of legacy X10 messages.\n+\n+The binding does not support linking new devices on the fly, i.e. all devices must be linked with the modem *before* starting the Insteon binding.\n+\n+openHAB is not a configuration tool! To configure and set up your devices, link the devices manually via the set buttons, or use the free [Insteon Terminal](https://github.com/pfrommerd/insteon-terminal) software. The free HouseLinc software from Insteon can also be used for configuration, but it wipes the modem link database clean on its initial use, requiring to re-link the modem to all devices.\n+\n+## Supported Things\n+\n+| Thing  | Type   | Description                  |\n+|----------|--------|------------------------------|\n+| network  | Bridge | An insteon PLM or hub that is used to communicate with the Insteon devices |\n+|device| Thing | Insteon devices such as dimmers, keypads, sensors, etc. |\n+\n+## Discovery\n+\n+The binding will automatically add the network bridge called local to the Paper UI inbox. Upon proper configuration of the network bridge, the network device database will be downloaded. Any Insteon device that exists in the database and is not currently configured will get added to the inbox.  The naming convention is **Insteon Device AABBCC**, where AA, BB and CC are from the Insteon device address.  X10 devices are not auto discovered. \n+\n+## Thing Configuration\n+\n+###### Network Configuration\n+\n+The Insteon PLM or hub is configured with the following:\n+\n+| Parameter | Default | Required | Description |\n+|----------|---------:|--------:|-------------|\n+| port   |         |   Yes    | **Examples:**<br>- PLM on  Linux: `/dev/ttyS0` or `/dev/ttyUSB0`<br>- Smartenit ZBPLM on Linux: `/dev/ttyUSB0,baudRate=115200`<br>- PLM on Windows: `COM1`<br>- Current  hub (2245-222) at 192.168.1.100 on port 25105, with a poll interval of 1000 ms (1 second): `/hub2/my_user_name:my_password@192.168.1.100:25105,poll_time=1000`<br>- Legacy hub (2242-222) at 192.168.1.100 on port 9761:`/hub/192.168.1.100:9761`<br>- Networked PLM using ser2net at 192.168.1.100 on port 9761:`/tcp/192.168.1.100:9761` |\n+| devicePollIntervalSeconds | 300 |  No  | Poll interval of devices in seconds. Poll too often and you will overload the insteon network, leading to sluggish or no response when trying to send messages to devices. The default poll interval of 300 seconds has been tested and found to be a good compromise in a configuration of about 110 switches/dimmers. |\n+|modemDbRetryTimeoutSeconds|120|No|The number of seconds to wait for the modem database to completely download before retrying again.  Under normal circumstances this will not need to be modified.|\n+| additionalDevices | |       No     | Optional file with additional device types. The syntax of the file is identical to the `device_types.xml` file in the source tree. Please remember to post successfully added device types to the openhab group so the developers can include them into the `device_types.xml` file! |\n+| additionalFeatures | |      No     | Optional file with additional feature templates, like in the `device_features.xml` file in the source tree. |\n+\n+>NOTE: For users upgrading from InsteonPLM, The parameter port_1 is now port. \n+\n+###### Device Configuration\n+\n+The Insteon device is configured with the following required parameters:\n+\n+| Parameter | Description |\n+|----------|-------------|\n+|address|Insteon or X10 address of the device. Insteon device addresses are in the format 'xx.xx.xx', and can be found on the device. X10 device address are in the format 'x.y' and are typically configured on the device.|\n+|productKey|Insteon binding product key that is used to identy the device. Every Insteon device type is uniquely identified by its Insteon product key, typically a six digit hex number. For some of the older device types (in particular the SwitchLinc switches and dimmers), Insteon does not give a product key, so an arbitrary fake one of the format Fxx.xx.xx (or Xxx.xx.xx for X10 devices) is assigned by the binding.|\n+\n+The following is a list of the product keys and associated devices. These have been tested and should work out of the box:\n+\n+| Model | Description | Product Key | tested by |\n+|-------|-------------|-------------|-----------|\n+| 2477D | SwitchLinc Dimmer | F00.00.01 | Bernd Pfrommer |\n+| 2477S | SwitchLinc Switch | F00.00.02 | Bernd Pfrommer |\n+| 2845-222 | Hidden Door Sensor | F00.00.03 | Josenivaldo Benito |\n+| 2876S | ICON Switch | F00.00.04 | Patrick Giasson |\n+| 2456D3 | LampLinc V2 | F00.00.05 | Patrick Giasson |\n+| 2442-222 | Micro Dimmer | F00.00.06 | Josenivaldo Benito |\n+| 2453-222 | DIN Rail On/Off | F00.00.07 | Josenivaldo Benito |\n+| 2452-222 | DIN Rail Dimmer | F00.00.08 | Josenivaldo Benito |\n+| 2458-A1 | MorningLinc RF Lock Controller | F00.00.09 | cdeadlock |\n+| 2852-222 | Leak Sensor | F00.00.0A | Kirk McCann |\n+| 2672-422 | LED Dimmer | F00.00.0B | ??? |\n+| 2476D | SwitchLinc Dimmer | F00.00.0C | LiberatorUSA |\n+| 2634-222 | On/Off Dual-Band Outdoor Module | F00.00.0D | LiberatorUSA |\n+| 2342-2 | Mini Remote | F00.00.10 | Bernd Pfrommer |\n+| 2663-222 | On/Off Outlet | 0x000039 | SwissKid |\n+| 2466D | ToggleLinc Dimmer | F00.00.11 | Rob Nielsen |\n+| 2466S | ToggleLinc Switch | F00.00.12 | Rob Nielsen |\n+| 2672-222 | LED Bulb | F00.00.13 | Rob Nielsen |\n+| 2487S | KeypadLinc On/Off 6-Button | F00.00.14 | Bernd Pfrommer |\n+| 2334-232 | KeypadLink Dimmer 6-Button | F00.00.15 | Rob Nielsen |\n+| 2334-232 | KeypadLink Dimmer 8-Button | F00.00.16 | Rob Nielsen |\n+| 2423A1 | iMeter Solo Power Meter | F00.00.17 | Rob Nielsen |\n+| 2423A1 | Thermostat 2441TH | F00.00.18 | Daniel Campbell, Bernd Pfrommer |\n+| 2457D2 | LampLinc Dimmer | F00.00.19 | Jonathan Huizingh |\n+| 2475SDB | In-LineLinc Relay | F00.00.1A | Jim Howard |\n+| 2635-222 | On/Off Module | F00.00.1B | Jonathan Huizingh |\n+| 2475F | FanLinc Module | F00.00.1C | Brian Tillman |\n+| 2456S3 | ApplianceLinc | F00.00.1D | ??? |\n+| 2674-222 | LED Bulb (recessed) | F00.00.1E | Steve Bate |\n+| 2477SA1 | 220V 30-amp Load Controller N/O | F00.00.1F | Shawn R. |\n+| 2342-222 | Mini Remote (8 Button) | F00.00.20 | Bernd Pfrommer |\n+| 2441V | Insteon Thermostat Adaptor for Venstar | F00.00.21 | Bernd Pfrommer |\n+| 2982-222 | Insteon Smoke Bridge | F00.00.22 | Bernd Pfrommer |\n+| 2450 | IO Link | 0x00001A | Bernd Pfrommer |\n+| 2486D | KeypadLinc Dimmer | 0x000037 | Patrick Giasson, Joe Barnum |\n+| 2484DWH8 | KeypadLinc Countdown Timer | 0x000041 | Rob Nielsen |\n+| 2413U | PowerLinc 2413U USB modem | 0x000045 | Bernd Pfrommer |\n+| 2843-222 | Wireless Open/Close Sensor | 0x000049 | Josenivaldo Benito |\n+| 2842-222 | Motion Sensor | 0x00004A | Bernd Pfrommer |\n+| 2486DWH8 | KeypadLinc Dimmer | 0x000051 | Chris Graham |\n+| 2472D | OutletLincDimmer | 0x000068 | Chris Graham |\n+| X10 switch | generic X10 switch | X00.00.01 | Bernd Pfrommer |\n+| X10 dimmer | generic X10 dimmer | X00.00.02 | Bernd Pfrommer |\n+| X10 motion | generic X10 motion sensor | X00.00.03 | Bernd Pfrommer |\n+\n+## Channels\n+\n+Below is the list of possible channels for the Insteon devices. In order to determing which channels a device supports, you can either look at the device in Paper UI, or find it in the openhab log file.\n+\n+| channel  | type   | description                  |\n+|----------|--------|------------------------------|\n+| acDelay | Number | AC Delay |\n+| backlightDuration | Number | Back Light Duration |\n+| batteryLevel | Number | Battery Level |\n+| batteryWatermarkLevel | Number | Battery Watermark Level |\n+| bottomOutlet | Switch | Bottom Outlet |\n+| buttonA | Switch | Button A |\n+| buttonB | Switch | Button B |\n+| buttonC | Switch | Button C |\n+| buttonD | Switch | Button D |\n+| buttonE | Switch | Button E |\n+| buttonF | Switch | Button F |\n+| buttonG | Switch | Button G |\n+| buttonH | Switch | Button H |\n+| broadcastOnOff | Switch | Broadcast On/Off |\n+| contact | Contact | Contact |\n+| coolSetPoint | Number | Cool Set Point |\n+| dimmer | Dimmer | Dimmer |\n+| fan | Number | Fan |\n+| fanMode | Number | Fan Mode |\n+| fastOnOff | Switch | Fast On/Off |\n+| fastOnOffButtonA | Switch | Fast On/Off Button A |\n+| fastOnOffButtonB | Switch | Fast On/Off Button B |\n+| fastOnOffButtonC | Switch | Fast On/Off Button C |\n+| fastOnOffButtonD | Switch | Fast On/Off Button D |\n+| heatSetPoint | Number | Heat Set Point |\n+| humidity | Number | Humidity |\n+| humidityHigh | Number | Humidity High |\n+| humidityLow | Number | Humidity Low |\n+| isCooling | Number | Is Cooling |\n+| isHeating | Number | Is Heating |\n+| keypadButtonA | Switch | Keypad Button A |\n+| keypadButtonB | Switch | Keypad Button B |\n+| keypadButtonC | Switch | Keypad Button C |\n+| keypadButtonD | Switch | Keypad Button D |\n+| keypadButtonE | Switch | Keypad Button E |\n+| keypadButtonF | Switch | Keypad Button F |\n+| keypadButtonG | Switch | Keypad Button G |\n+| keypadButtonH | Switch | Keypad Button H |\n+| kWh | Number | Kilowatt Hour |\n+| lastHeardFrom | DateTime | Last Heard From |\n+| ledBrightness | Number | LED brightness |\n+| lightDimmer | Dimmer | light Dimmer |\n+| lightLevel | Number | Light Level |\n+| loadDimmer | Dimmer | Load Dimmer |\n+| loadSwitch | Switch | Load Switch |\n+| loadSwitchFastOnOff | Switch | Load Switch Fast On/Off |\n+| loadSwitchManualChange | Number | Load Switch Manual Change |\n+| manualChange | Number | Manual Change |\n+| manualChangeButtonA | Number | Manual Change Button A |\n+| manualChangeButtonB | Number | Manual Change Button B |\n+| manualChangeButtonC | Number | Manual Change Button C |\n+| manualChangeButtonD | Number | Manual Change Button D |\n+| notification | Number | Notification |\n+| onLevel | Number | On Level |\n+| rampDimmer | Dimmer | Ramp Dimmer |\n+| rampRate | Number | Ramp Rate |\n+| reset | Switch | Reset |\n+| stage1Duration | Number | Stage 1 Duration |\n+| switch | Switch | Switch |\n+| systemMode | Number | System Mode |\n+| tempCelsius | Number | Temperature Celsius |\n+| tempFahrenheit | Number | Temperature Fahrenheit |\n+| topOutlet | Switch | Top Outlet |\n+| update | Switch | Update |\n+| watts | Number | Watts |\n+\n+\n+## Full Example\n+\n+Sample things file:\n+\n+```\n+Bridge insteon:network:local [port=\"/dev/ttyUSB0\"] {\n+  Thing device 22F8A8 [address=\"22.F8.A8\", productKey=\"F00.00.15\"] {\n+    Channels:\n+      Type switch : keypadButtonA [ group=3 ]\n+      Type switch : keypadButtonB [ group=4 ]\n+      Type switch : keypadButtonC [ group=5 ]\n+      Type switch : keypadButtonD [ group=6 ]\n+  }\n+  Thing device 238D93 [address=\"23.8D.93\", productKey=\"F00.00.12\"]\n+  Thing device 238F55 [address=\"23.8F.55\", productKey=\"F00.00.11\"] {\n+    Channels:\n+      Type dimmer : dimmer [related=\"23.B0.D9+23.8F.C9\"]\n+  }\n+  Thing device 238FC9 [address=\"23.8F.C9\", productKey=\"F00.00.11\"] {\n+    Channels:\n+      Type dimmer : dimmer [related=\"23.8F.55+23.B0.D9\"]\n+  }\n+  Thing device 23B0D9 [address=\"23.B0.D9\", productKey=\"F00.00.11\"] {\n+    Channels:\n+      Type dimmer : dimmer [related=\"23.8F.55+23.8F.C9\"]\n+  }\n+  Thing device 243141 [address=\"24.31.41\", productKey=\"F00.00.11\"]  {\n+    Channels:\n+      Type dimmer : dimmer [dimmermax=60]\n+  }\n+}\n+```\n+\n+Sample items file:\n+\n+```\n+Switch switch1 { channel=\"insteon:device:local:243141:switch\" }\n+Dimmer dimmer1 { channel=\"insteon:device:local:238F55:dimmer\" }\n+Dimmer dimmer2 { channel=\"insteon:device:local:23B0D9:dimmer\" }\n+Dimmer dimmer3 { channel=\"insteon:device:local:238FC9:dimmer\" }\n+Dimmer keypad  { channel=\"insteon:device:local:22F8A8:loadDimmer\" }\n+Switch keypadA { channel=\"insteon:device:local:22F8A8:keypadButtonA\" }\n+Switch keypadB { channel=\"insteon:device:local:22F8A8:keypadButtonB\" }\n+Switch keypadC { channel=\"insteon:device:local:22F8A8:keypadButtonC\" }\n+Switch keypadD { channel=\"insteon:device:local:22F8A8:keypadButtonD\" }\n+Dimmer dimmer  { channel=\"insteon:device:local:238D93:dimmer\" }\n+```\n+\n+## Insteon Groups and Scenes\n+\n+How do Insteon devices tell other devices on the network that their state has changed? They send out a broadcast message, labeled with a specific *group* number. All devices (called *responders*) that are configured to listen to this message will then go into a pre-defined state. For instance when light switch A is switched to \"ON\", it will send out a message to group #1, and all responders will react to it, e.g they may go into the \"ON\" position as well. Since more than one device can participate, the sending out of the broadcast message and the subsequent state change of the responders is referred to as \"triggering a scene\". At the device and PLM level, the concept of a \"scene\" does not exist, so you will find it notably absent in the binding code and this document. A scene is strictly a higher level concept, introduced to shield the user from the details of how the communication is implemented.\n+\n+Many Insteon devices send out messages on different group numbers, depending on what happens to them. A leak sensor may send out a message on group #1 when dry, and on group #2 when wet. The default group used for e.g. linking two light switches is usually group #1.\n+\n+## Insteon binding process\n+\n+Before Insteon devices communicate with one another, they must be linked. During the linking process, one of the devices will be the \"Controller\", the other the \"Responder\" (see e.g. the [SwitchLinc Instructions](https://www.insteon.com/pdf/2477S.pdf)).\n+\n+The responder listens to messages from the controller, and reacts to them. Note that except for the case of a motion detector (which is just a controller to the modem), the modem controls the device (e.g. send on/off messages to it), and the device controls the modem (so the modem learns about the switch being toggled). For this reason, most devices and in particular switches/dimmers should be linked twice, with one taking the role of controller during the first linking, and the other acting as controller during the second linking process. To do so, first press and hold the \"Set\" button on the modem until the light starts blinking. Then press and hold the \"Set\" button on the remote device,\n+e.g. the light switch, until it double beeps (the light on the modem should go off as well). Now do exactly the reverse: press and hold the \"Set\" button on the remote device until its light starts blinking, then press and hold the \"Set\" button on the modem until it double beeps, and the light of the remote device (switch) goes off. Done.\n+\n+For some of the more sophisticated devices the complete linking process can no longer be done with the set buttons, but requires software like e.g. [Insteon Terminal](https://github.com/pfrommerd/insteon-terminal).\n+\n+## Insteon Features\n+\n+Since Insteon devices can have multiple features (for instance a switchable relay and a contact sensor) under a single Insteon address, an openHAB item is not bound to a device, but to a given feature of a device. For example, the following lines would create two Number items referring to the same thermostat device, but to different features of it:\n+\n+```\n+Number  thermostatCoolPoint \"cool point [%.1f \u00b0F]\" { channel=\"insteon:device:local:32F422:coolSetPoint\" }\n+Number  thermostatHeatPoint \"heat point [%.1f \u00b0F]\" { channel=\"insteon:device:local:32F422:heatSetPoint\" }\n+```\n+\n+### Simple light switches\n+\n+The following example shows how to configure a simple light switch (2477S) in the .items file:\n+\n+```\n+Switch officeLight \"office light\"  { channel=\"insteon:device:local:AABBCC:switch\" }\n+```\n+\n+### Simple dimmers\n+\n+Here is how to configure a simple dimmer (2477D) in the .items file:\n+\n+```\n+Dimmer kitchenChandelier \"kitchen chandelier\" { channel=\"insteon:device:local:AABBCC:dimmer\" }\n+```\n+\n+Dimmers can be configured with a maximum level when turning a device on or setting a percentage level. If a maximum level is configured, openHAB will never set the level of the dimmer above the level specified. The parameter dimmermax must be defined for the channel. The below example sets a maximum level of 70% for dim 1 and 60% for dim 2:\n+\n+**Things**\n+\n+```\n+Bridge insteon:network:local [port=\"/dev/ttyUSB0\"] {\n+  Thing device AABBCC [address=\"AA.BB.CC\", productKey=\"F00.00.11\"]  {\n+    Channels:\n+      Type dimmer : dimmer [dimmermax=70]\n+  }\n+  Thing device AABBCD [address=\"AA.BB.CD\", productKey=\"F00.00.15\"]  {\n+    Channels:\n+      Type dimmer : loadDimmer [dimmermax=60]\n+  }\n+}\n+```\n+\n+**Items**\n+\n+```\n+Dimmer d1 \"dimmer 1\" { channel=\"insteon:device:local:AABBCC:dimmer\"}\n+Dimmer d2 \"dimmer 2\" { channel=\"insteon:device:local:AABBCD:loadDimmer\"}\n+```\n+\n+Setting a maximum level does not affect manual turning on or dimming a switch.\n+\n+### On/Off Outlets\n+\n+Here's how to configure the top and bottom outlet of the in-wall 2 outlet controller:\n+\n+```\n+Switch fOutTop \"Front Outlet Top\"    <socket> { channel=\"insteon:device:local:AABBCC:topOutlet\" }\n+Switch fOutBot \"Front Outlet Bottom\" <socket> { channel=\"insteon:device:local:AABBCC:bottomOutlet\" }\n+```\n+\n+This will give you individual control of each outlet.\n+    \n+### Mini remotes\n+\n+Link the mini remote to be a controller of the modem by using the set button. Link all buttons, one after the other. The 4-button mini remote sends out messages on groups 0x01 - 0x04, each corresponding to one button. The modem's link database (see [Insteon Terminal](https://github.com/pfrommerd/insteon-terminal)) should look like this:\n+\n+```\n+    0000 xx.xx.xx                       xx.xx.xx  RESP  10100010 group: 01 data: 02 2c 41\n+    0000 xx.xx.xx                       xx.xx.xx  RESP  10100010 group: 02 data: 02 2c 41\n+    0000 xx.xx.xx                       xx.xx.xx  RESP  10100010 group: 03 data: 02 2c 41\n+    0000 xx.xx.xx                       xx.xx.xx  RESP  10100010 group: 04 data: 02 2c 41\n+```\n+\n+**Items**\n+This goes into the items file:\n+\n+```\n+    Switch miniRemoteButtonA \"mini remote button a\" { channel=\"insteon:device:local:AABBCC:buttonA\", autoupdate=\"false\" }\n+    Switch miniRemoteButtonB \"mini remote button b\" { channel=\"insteon:device:local:AABBCC:buttonB\", autoupdate=\"false\" }\n+    Switch miniRemoteButtonC \"mini remote button c\" { channel=\"insteon:device:local:AABBCC:buttonC\", autoupdate=\"false\" }\n+    Switch miniRemoteButtonD \"mini remote button d\" { channel=\"insteon:device:local:AABBCC:buttonD\", autoupdate=\"false\" }\n+```\n+\n+**Sitemap**\n+This goes into the sitemap file:\n+\n+```\n+    Switch item=miniRemoteButtonA label=\"mini remote button a\" mappings=[ OFF=\"Off\", ON=\"On\"]\n+    Switch item=miniRemoteButtonB label=\"mini remote button b\" mappings=[ OFF=\"Off\", ON=\"On\"]\n+    Switch item=miniRemoteButtonC label=\"mini remote button c\" mappings=[ OFF=\"Off\", ON=\"On\"]\n+    Switch item=miniRemoteButtonD label=\"mini remote button d\" mappings=[ OFF=\"Off\", ON=\"On\"]\n+```\n+\n+The switches in the GUI just display the mini remote's most recent button presses. They are not operable because the PLM cannot trigger the mini remotes scenes.\n+\n+### Motion sensors\n+\n+Link such that the modem is a responder to the motion sensor. Create a contact.map file in the transforms directory as described elsewhere in this document. Then create entries in the .items file like this:\n+\n+**Items**\n+\n+```\n+    Contact motionSensor             \"motion sensor [MAP(contact.map):%s]\" { channel=\"insteon:device:local:AABBCC:contact\"}\n+    Number  motionSensorBatteryLevel \"motion sensor battery level [%.1f]\"  { channel=\"insteon:device:local:AABBCC:batteryLevel\" }\n+    Number  motionSensorLightLevel   \"motion sensor light level [%.1f]\"    { channel=\"insteon:device:local:AABBCC:lightLevel\" }\n+```\n+\n+This will give you a contact, the battery level, and the light level. Note that battery and light level are only updated when either there is motion, or the sensor battery runs low.\n+\n+### Hidden door sensors\n+\n+Similar in operation to the motion sensor above.  Link such that the modem is a responder to the motion sensor. Create a contact.map file in the transforms directory like the following:\n+\n+```\n+    OPEN=open\n+    CLOSED=closed\n+    -=unknown\n+```\n+\n+**Items**\n+Then create entries in the .items file like this:\n+\n+```\n+    Contact doorSensor             \"Door sensor [MAP(contact.map):%s]\" { channel=\"insteon:device:local:AABBCC:contact\" }\n+    Number  doorSensorBatteryLevel \"Door sensor battery level [%.1f]\"  { channel=\"insteon:device:local:AABBCC:batteryLevel\" }\n+```\n+\n+This will give you a contact and the battery level. Note that battery level is only updated when either there is motion, or the sensor battery runs low.\n+\n+### Locks\n+\n+Read the instructions very carefully: sync with lock within 5 feet to avoid bad connection, link twice for both ON and OFF functionality.\n+\n+**Items**\n+Put something like this into your .items file:\n+\n+```\n+    Switch doorLock \"Front Door [MAP(lock.map):%s]\"  { channel=\"insteon:device:local:AABBCC:switch\" }\n+```\n+\n+and create a file \"lock.map\" in the transforms directory with these entries: \n+\n+```\n+    ON=Lock\n+    OFF=Unlock\n+    -=unknown\n+```\n+\n+### I/O Linc (garage door openers)\n+\n+The I/O Linc devices are really two devices in one: a relay and a contact. Link the modem both ways, as responder and controller using the set buttons as described in the instructions.\n+\n+Add this map into your transforms directory as \"contact.map\":\n+\n+```\n+    OPEN=open\n+    CLOSED=closed\n+    -=unknown\n+```\n+\n+**Items**\n+Along with this into your .items file:\n+\n+```\n+    Switch  garageDoorOpener  \"garage door opener\"                        <garagedoor>  { channel=\"insteon:device:local:AABBCC:switch\", autoupdate=\"false\" }\n+    Contact garageDoorContact \"garage door contact [MAP(contact.map):%s]\"               { channel=\"insteon:device:local:AABBCC:contact\" }\n+```\n+\n+**Sitemap**\n+To make it visible in the GUI, put this into your sitemap file:\n+\n+```\n+    Switch item=garageDoorOpener label=\"garage door opener\" mappings=[ ON=\"OPEN/CLOSE\"]\n+    Text item=garageDoorContact\n+```\n+\n+For safety reasons, only close the garage door if you have visual contact to make sure there is no obstruction! The use of automated rules for closing garage doors is dangerous.\n+\n+> NOTE: If the I/O Linc returns the wrong value when the device is polled (For example you open the garage door and the state correctly shows OPEN, but during polling it shows CLOSED), you probably linked the device with the PLM or hub when the door was in the wrong position. You need unlink and then link again with the door in the opposite position. Please see the Insteon I/O Linc documentation for further details.\n+\n+### Keypads\n+\n+Before you attempt to configure the keypads, please familiarize yourself with the concept of an Insteon group.\n+\n+The Insteon keypad devices typically control one main load and have a number of buttons that will send out group broadcast messages to trigger a scene. If you just want to use the main load switch within openhab just link modem and device with the set buttons as usual, no complicated linking is necessary. But if you want to get the buttons to work, read on.\n+\n+Each button will send out a message for a different, predefined group. Complicating matters further, the button numbering used internally by the device must be mapped to whatever labels are printed on the physical buttons of the device. Here is an example correspondence table:\n+\n+| Group | Button Number | 2487S Label |\n+|-------|---------------|-------------|\n+|  0x01 |        1      |   (Load)    |\n+|  0x03 |        3      |     A       |\n+|  0x04 |        4      |     B       |\n+|  0x05 |        5      |     C       |\n+|  0x06 |        6      |     D       |\n+\n+When e.g. the \"A\" button is pressed (that's button #3 internally) a broadcast message will be sent out to all responders configured to listen to Insteon group #3. This means you must configure the modem as a responder to group #3 (and #4, #5, #6) messages coming from your keypad. For instructions how to do this, check out the [Insteon Terminal](https://github.com/pfrommerd/insteon-terminal). You can even do that with the set buttons (see instructions that come with the keypad).\n+\n+While capturing the messages that the buttons emit is pretty straight forward, controlling the buttons is  another matter. They cannot be simply toggled with a direct command to the device, but instead a broadcast message must be sent on a group number that the button has been programmed to listen to. This means you need to pick a set of unused groups that is globally unique (if you have multiple keypads, each one of them has to use different groups), one group for each button. The example configuration below uses groups 0xf3, 0xf4, 0xf5, and 0xf6. Then link the buttons such that they respond to those groups, and link the modem as a controller for them (see [Insteon Terminal](https://github.com/pfrommerd/insteon-terminal) documentation). In your items file you specify these groups with the \"group=\" parameters such that the binding knows what group number to put on the outgoing message.\n+\n+\n+#### Keypad switches\n+\n+**Items**\n+\n+Here is a simple example, just using the load (main) switch:\n+\n+```\n+    Switch keypadSwitch             \"main load\"          { channel=\"insteon:device:local:AABBCC:loadSwitch\" }\n+    Number keypadSwitchManualChange \"main manual change\" { channel=\"insteon:device:local:AABBCC:loadSwitchManualChange\" }\n+    Switch keypadSwitchFastOnOff    \"main fast on/off\"   { channel=\"insteon:device:local:AABBCC:loadSwitchFastOnOff\" }\n+```\n+\n+Most people will not use the fast on/off features or the manual change feature, so you really only need the first line. To make the buttons available, add the following:\n+\n+**Things**\n+\n+```\n+Bridge insteon:network:local [port=\"/dev/ttyUSB0\"] {\n+  Thing device AABBCC [address=\"AA.BB.CC\", productKey=\"F00.00.15\"] {\n+    Channels:\n+      Type switch : keypadButtonA [ group=\"0xf3\" ]\n+      Type switch : keypadButtonB [ group=\"0xf4\" ]\n+      Type switch : keypadButtonC [ group=\"0xf5\" ]\n+      Type switch : keypadButtonD [ group=\"0xf6\" ]\n+  }\n+}\n+```\n+\n+The value after group must either be a number or string. The hexadecimal value 0xf3 can either converted to a numeric value 243 or the string value \"0xf3\".\n+\n+**Items**\n+\n+```\n+    Switch keypadSwitchA \"keypad button A\" { channel=\"insteon:device:local:AABBCC:keypadButtonA\"}\n+    Switch keypadSwitchB \"keypad button B\" { channel=\"insteon:device:local:AABBCC:keypadButtonB\"}\n+    Switch keypadSwitchC \"keypad button C\" { channel=\"insteon:device:local:AABBCC:keypadButtonC\"}\n+    Switch keypadSwitchD \"keypad button D\" { channel=\"insteon:device:local:AABBCC:keypadButtonD\"}\n+```\n+\n+**Sitemap**\n+\n+The following sitemap will bring the items to life in the GUI:\n+\n+```\n+    Frame label=\"Keypad\" {\n+          Switch item=keypadSwitch label=\"main\"\n+          Switch item=keypadSwitchFastOnOff label=\"fast on/off\"\n+          Switch item=keypadSwitchManualChange label=\"manual change\" mappings=[ 0=\"DOWN\", 1=\"STOP\",  2=\"UP\"]\n+          Switch item=keypadSwitchA label=\"button A\"\n+          Switch item=keypadSwitchB label=\"button B\"\n+          Switch item=keypadSwitchC label=\"button C\"\n+          Switch item=keypadSwitchD label=\"button D\"\n+    }\n+```\n+\n+#### Keypad dimmers\n+\n+The keypad dimmers are like keypad switches, except that the main load is dimmable.\n+\n+**Items**\n+\n+```\n+    Dimmer keypadDimmer           \"dimmer\"                          { channel=\"insteon:device:local:AABBCC:loadDimmer\" }\n+    Switch keypadDimmerButtonA    \"keypad dimmer button A [%d %%]\"  { channel=\"insteon:device:local:AABBCC:keypadButtonA\" }\n+```\n+\n+**Sitemap**\n+\n+```\n+    Slider item=keypadDimmer switchSupport\n+    Switch item=keypadDimmerButtonA label=\"buttonA\"\n+```\n+\n+### Thermostats\n+\n+The thermostat (2441TH) is one of the most complex Insteon devices available. It must first be properly linked to the modem using configuration software like [Insteon Terminal](https://github.com/pfrommerd/insteon-terminal). The Insteon Terminal wiki describes in detail how to link the thermostat, and how to make it publish status update reports.\n+\n+When all is set and done the modem must be configured as a controller to group 0 (not sure why), and a responder to groups 1-5 such that it picks up when the thermostat switches on/off heating and cooling etc, and it must be a responder to special group 0xEF to get status update reports when measured values (temperature) change. Symmetrically, the thermostat must be a responder to group 0, and a controller for groups 1-5 and 0xEF. The linking process is not difficult but needs some persistence. Again, refer to the [Insteon Terminal](https://github.com/pfrommerd/insteon-terminal) documentation.\n+\n+**Items**\n+\n+This is an example of what to put into your .items file:\n+\n+```\n+    Number  thermostatCoolPoint   \"cool point [%.1f \u00b0F]\"  { channel=\"insteon:device:local:AABBCC:coolSetPoint\" }\n+    Number  thermostatHeatPoint   \"heat point [%.1f \u00b0F]\"  { channel=\"insteon:device:local:AABBCC:heatSetPoint\" }\n+    Number  thermostatSystemMode  \"system mode [%d]\"      { channel=\"insteon:device:local:AABBCC:systemMode\" }\n+    Number  thermostatFanMode     \"fan mode [%d]\"         { channel=\"insteon:device:local:AABBCC:fanMode\" }\n+    Number  thermostatIsHeating   \"is heating [%d]\"       { channel=\"insteon:device:local:AABBCC:isHeating\"}\n+    Number  thermostatIsCooling   \"is cooling [%d]\"       { channel=\"insteon:device:local:AABBCC:isCooling\" }\n+    Number  thermostatTempFahren  \"temperature [%.1f \u00b0F]\" { channel=\"insteon:device:local:AABBCC:tempFahrenheit\" }\n+    Number  thermostatTempCelsius \"temperature [%.1f \u00b0C]\" { channel=\"insteon:device:local:AABBCC:tempCelsius\" }\n+    Number  thermostatHumidity    \"humidity [%.0f %%]\"    { channel=\"insteon:device:local:AABBCC:humidity\" }\n+```\n+\n+Add this as well for some more exotic features:\n+\n+```\n+    Number  thermostatACDelay      \"A/C delay [%d min]\"        { channel=\"insteon:device:local:AABBCC:acDelay\" }\n+    Number  thermostatBacklight    \"backlight [%d sec]\"        { channel=\"insteon:device:local:AABBCC:backlightDuration\" }\n+    Number  thermostatStage1       \"A/C stage 1 time [%d min]\" { channel=\"insteon:device:local:AABBCC:stage1Duration\" }\n+    Number  thermostatHumidityHigh \"humidity high [%d %%]\"     { channel=\"insteon:device:local:AABBCC:humidityHigh\" }\n+    Number  thermostatHumidityLow  \"humidity low [%d %%]\"      { channel=\"insteon:device:local:AABBCC:humidityLow\" }\n+```\n+\n+**Sitemap**\n+\n+For the thermostat to display in the GUI, add this to the sitemap file:\n+\n+```\n+    Text   item=thermostatTempCelsius icon=\"temperature\"\n+    Text   item=thermostatTempFahren icon=\"temperature\"\n+    Text   item=thermostatHumidity\n+    Setpoint item=thermostatCoolPoint icon=\"temperature\" minValue=63 maxValue=90 step=1\n+    Setpoint item=thermostatHeatPoint icon=\"temperature\" minValue=50 maxValue=80 step=1\n+    Switch item=thermostatSystemMode  label=\"system mode\" mappings=[ 0=\"OFF\",  1=\"HEAT\", 2=\"COOL\", 3=\"AUTO\", 4=\"PROGRAM\"]\n+    Switch item=thermostatFanMode  label=\"fan mode\" mappings=[ 0=\"AUTO\",  1=\"ALWAYS ON\"]\n+    Switch item=thermostatIsHeating  label=\"is heating\" mappings=[ 0=\"OFF\",  1=\"HEATING\"]\n+    Switch item=thermostatIsCooling  label=\"is cooling\" mappings=[ 0=\"OFF\",  1=\"COOLING\"]\n+    Setpoint item=thermostatACDelay  minValue=2 maxValue=20 step=1\n+    Setpoint item=thermostatBacklight  minValue=0 maxValue=100 step=1\n+    Setpoint item=thermostatHumidityHigh  minValue=0 maxValue=100 step=1\n+    Setpoint item=thermostatHumidityLow   minValue=0 maxValue=100 step=1\n+    Setpoint item=thermostatStage1  minValue=1 maxValue=60 step=1\n+```\n+\n+### Power Meters\n+\n+The iMeter Solo reports both wattage and kilowatt hours, and is updated during the normal polling process of the devices. You can also manually update the current values from the device and reset the device. See the example below:\n+\n+**Items**\n+\n+``` \n+    Number iMeterWatts   \"iMeter [%d watts]\"   { channel=\"insteon:device:local:AABBCC:watts\" }\n+    Number iMeterKwh     \"iMeter [%.04f kwh]\"  { channel=\"insteon:device:local:AABBCC:kwh\" }\n+    Switch iMeterUpdate  \"iMeter Update\"       { channel=\"insteon:device:local:AABBCC:update\" }\n+    Switch iMeterReset   \"iMeter Reset\"        { channel=\"insteon:device:local:AABBCC:reset\" }\n+```\n+\n+### Fan Controllers\n+\n+Here is an example configuration for a FanLinc module, which has a dimmable light and a variable speed fan:\n+\n+**Items**\n+\n+```\n+    Dimmer fanLincDimmer \"fanlinc dimmer [%d %%]\" { channel=\"insteon:device:local:AABBCC:lightDimmer\" }\n+    Number fanLincFan    \"fanlinc fan\"            { channel=\"insteon:device:local:AABBCC:fan\"}\n+```\n+\n+**Sitemap**\n+\n+```\n+    Slider item=fanLincDimmer switchSupport\n+    Switch item=fanLincFan label=\"fan speed\" mappings=[ 0=\"OFF\",  1=\"LOW\", 2=\"MEDIUM\", 3=\"HIGH\"]\n+```\n+\n+### X10 devices\n+\n+It is worth noting that both the Inseon PLM and the 2014 Hub can both command X10 devices over the powerline, and also set switch stats based on X10 signals received over the powerline.  This allows openHAB not only control X10 devices without the need for other hardwaare, but it can also have rules that react to incoming X10 powerline commands.  While you cannot bind the the X10 devices to the Insteon PLM/HUB, here are some examples for configuring X10 devices. Be aware that most X10 switches/dimmers send no status updates, i.e. openHAB will not learn about switches that are toggled manually. Further note that\n+X10 devices are addressed with `houseCode.unitCode`, e.g. `A.2`.\n+\n+**Items**\n+\n+```\n+    Switch x10Switch  \"X10 switch\" { channel=\"insteon:device:local:AABB:switch\" }\n+    Dimmer x10Dimmer  \"X10 dimmer\" { channel=\"insteon:device:local:AABB:dimmer\" }\n+    Contact x10Motion \"X10 motion\" { channel=\"insteon:device:local:AABB:contact\" }\n+```\n+\n+## Direct sending of group broadcasts (triggering scenes)\n+\n+The binding can command the modem to send broadcasts to a given Insteon group. Since it is a broadcast message, the corresponding item does *not* take the address of any device, but of the modem itself. The format is broadcastOnOff#X where X is the group that you want to be able to broadcast messages to:\n+\n+**Things**\n+\n+```\n+Bridge insteon:network:local      [port=\"/dev/ttyUSB0\"] {\n+  Thing device AABBCC             [address=\"AA.BB.CC\", productKey=\"0x000045\"] {\n+    Channels:\n+      Type switch : broadcastOnOff#2\n+  }\n+}\n+\n+```\n+\n+**Items**\n+\n+```\n+    Switch  broadcastOnOff \"group on/off\"  { channel=\"insteon:device:local:AABBCC:broadcastOnOff#2\" }\n+```\n+\n+Flipping this switch to \"ON\" will cause the modem to send a broadcast message with group=2, and all devices that are configured to respond to it should react.\n+\n+## 3-way switch configurations and the \"related\" keyword", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "04a9796d14dfbc5f3ff997d872f04b6d03ee411d"}, "originalPosition": 627}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTMxNjg2Nw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            ### Adding new device types (using existing device features)\n          \n          \n            \n            ### Adding New Device Types (Using Existing Device Features)", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r389316867", "createdAt": "2020-03-07T22:28:30Z", "author": {"login": "kaikreuzer"}, "path": "bundles/org.openhab.binding.insteon/README.md", "diffHunk": "@@ -0,0 +1,719 @@\n+# Insteon Binding\n+\n+Insteon is a home area networking technology developed primarily for connecting light switches and loads. Insteon devices send messages either via the power line, or by means of radio frequency (RF) waves, or both (dual-band). A considerable number of Insteon compatible devices such as switchable relays, thermostats, sensors etc are available. More about Insteon can be found on [Wikipedia](http://en.wikipedia.org/wiki/Insteon).\n+\n+This binding provides access to the Insteon network by means of either an Insteon PowerLinc Modem (PLM), a legacy Insteon Hub 2242-222 or the current 2245-222 Insteon Hub. The modem can be connected to the openHAB server either via a serial port (Model 2413S) or a USB port (Model 2413U). The Insteon PowerLinc Controller (Model 2414U) is not supported since it is a PLC not a PLM. The modem can also be connected via TCP (such as ser2net).  The binding translates openHAB commands into Insteon messages and sends them on the Insteon network. Relevant messages from the Insteon network (like notifications about switches being toggled) are picked up by the modem and converted to openHAB status updates by the binding. The binding also supports sending and receiving of legacy X10 messages.\n+\n+The binding does not support linking new devices on the fly, i.e. all devices must be linked with the modem *before* starting the Insteon binding.\n+\n+openHAB is not a configuration tool! To configure and set up your devices, link the devices manually via the set buttons, or use the free [Insteon Terminal](https://github.com/pfrommerd/insteon-terminal) software. The free HouseLinc software from Insteon can also be used for configuration, but it wipes the modem link database clean on its initial use, requiring to re-link the modem to all devices.\n+\n+## Supported Things\n+\n+| Thing  | Type   | Description                  |\n+|----------|--------|------------------------------|\n+| network  | Bridge | An insteon PLM or hub that is used to communicate with the Insteon devices |\n+|device| Thing | Insteon devices such as dimmers, keypads, sensors, etc. |\n+\n+## Discovery\n+\n+The binding will automatically add the network bridge called local to the Paper UI inbox. Upon proper configuration of the network bridge, the network device database will be downloaded. Any Insteon device that exists in the database and is not currently configured will get added to the inbox.  The naming convention is **Insteon Device AABBCC**, where AA, BB and CC are from the Insteon device address.  X10 devices are not auto discovered. \n+\n+## Thing Configuration\n+\n+###### Network Configuration\n+\n+The Insteon PLM or hub is configured with the following:\n+\n+| Parameter | Default | Required | Description |\n+|----------|---------:|--------:|-------------|\n+| port   |         |   Yes    | **Examples:**<br>- PLM on  Linux: `/dev/ttyS0` or `/dev/ttyUSB0`<br>- Smartenit ZBPLM on Linux: `/dev/ttyUSB0,baudRate=115200`<br>- PLM on Windows: `COM1`<br>- Current  hub (2245-222) at 192.168.1.100 on port 25105, with a poll interval of 1000 ms (1 second): `/hub2/my_user_name:my_password@192.168.1.100:25105,poll_time=1000`<br>- Legacy hub (2242-222) at 192.168.1.100 on port 9761:`/hub/192.168.1.100:9761`<br>- Networked PLM using ser2net at 192.168.1.100 on port 9761:`/tcp/192.168.1.100:9761` |\n+| devicePollIntervalSeconds | 300 |  No  | Poll interval of devices in seconds. Poll too often and you will overload the insteon network, leading to sluggish or no response when trying to send messages to devices. The default poll interval of 300 seconds has been tested and found to be a good compromise in a configuration of about 110 switches/dimmers. |\n+|modemDbRetryTimeoutSeconds|120|No|The number of seconds to wait for the modem database to completely download before retrying again.  Under normal circumstances this will not need to be modified.|\n+| additionalDevices | |       No     | Optional file with additional device types. The syntax of the file is identical to the `device_types.xml` file in the source tree. Please remember to post successfully added device types to the openhab group so the developers can include them into the `device_types.xml` file! |\n+| additionalFeatures | |      No     | Optional file with additional feature templates, like in the `device_features.xml` file in the source tree. |\n+\n+>NOTE: For users upgrading from InsteonPLM, The parameter port_1 is now port. \n+\n+###### Device Configuration\n+\n+The Insteon device is configured with the following required parameters:\n+\n+| Parameter | Description |\n+|----------|-------------|\n+|address|Insteon or X10 address of the device. Insteon device addresses are in the format 'xx.xx.xx', and can be found on the device. X10 device address are in the format 'x.y' and are typically configured on the device.|\n+|productKey|Insteon binding product key that is used to identy the device. Every Insteon device type is uniquely identified by its Insteon product key, typically a six digit hex number. For some of the older device types (in particular the SwitchLinc switches and dimmers), Insteon does not give a product key, so an arbitrary fake one of the format Fxx.xx.xx (or Xxx.xx.xx for X10 devices) is assigned by the binding.|\n+\n+The following is a list of the product keys and associated devices. These have been tested and should work out of the box:\n+\n+| Model | Description | Product Key | tested by |\n+|-------|-------------|-------------|-----------|\n+| 2477D | SwitchLinc Dimmer | F00.00.01 | Bernd Pfrommer |\n+| 2477S | SwitchLinc Switch | F00.00.02 | Bernd Pfrommer |\n+| 2845-222 | Hidden Door Sensor | F00.00.03 | Josenivaldo Benito |\n+| 2876S | ICON Switch | F00.00.04 | Patrick Giasson |\n+| 2456D3 | LampLinc V2 | F00.00.05 | Patrick Giasson |\n+| 2442-222 | Micro Dimmer | F00.00.06 | Josenivaldo Benito |\n+| 2453-222 | DIN Rail On/Off | F00.00.07 | Josenivaldo Benito |\n+| 2452-222 | DIN Rail Dimmer | F00.00.08 | Josenivaldo Benito |\n+| 2458-A1 | MorningLinc RF Lock Controller | F00.00.09 | cdeadlock |\n+| 2852-222 | Leak Sensor | F00.00.0A | Kirk McCann |\n+| 2672-422 | LED Dimmer | F00.00.0B | ??? |\n+| 2476D | SwitchLinc Dimmer | F00.00.0C | LiberatorUSA |\n+| 2634-222 | On/Off Dual-Band Outdoor Module | F00.00.0D | LiberatorUSA |\n+| 2342-2 | Mini Remote | F00.00.10 | Bernd Pfrommer |\n+| 2663-222 | On/Off Outlet | 0x000039 | SwissKid |\n+| 2466D | ToggleLinc Dimmer | F00.00.11 | Rob Nielsen |\n+| 2466S | ToggleLinc Switch | F00.00.12 | Rob Nielsen |\n+| 2672-222 | LED Bulb | F00.00.13 | Rob Nielsen |\n+| 2487S | KeypadLinc On/Off 6-Button | F00.00.14 | Bernd Pfrommer |\n+| 2334-232 | KeypadLink Dimmer 6-Button | F00.00.15 | Rob Nielsen |\n+| 2334-232 | KeypadLink Dimmer 8-Button | F00.00.16 | Rob Nielsen |\n+| 2423A1 | iMeter Solo Power Meter | F00.00.17 | Rob Nielsen |\n+| 2423A1 | Thermostat 2441TH | F00.00.18 | Daniel Campbell, Bernd Pfrommer |\n+| 2457D2 | LampLinc Dimmer | F00.00.19 | Jonathan Huizingh |\n+| 2475SDB | In-LineLinc Relay | F00.00.1A | Jim Howard |\n+| 2635-222 | On/Off Module | F00.00.1B | Jonathan Huizingh |\n+| 2475F | FanLinc Module | F00.00.1C | Brian Tillman |\n+| 2456S3 | ApplianceLinc | F00.00.1D | ??? |\n+| 2674-222 | LED Bulb (recessed) | F00.00.1E | Steve Bate |\n+| 2477SA1 | 220V 30-amp Load Controller N/O | F00.00.1F | Shawn R. |\n+| 2342-222 | Mini Remote (8 Button) | F00.00.20 | Bernd Pfrommer |\n+| 2441V | Insteon Thermostat Adaptor for Venstar | F00.00.21 | Bernd Pfrommer |\n+| 2982-222 | Insteon Smoke Bridge | F00.00.22 | Bernd Pfrommer |\n+| 2450 | IO Link | 0x00001A | Bernd Pfrommer |\n+| 2486D | KeypadLinc Dimmer | 0x000037 | Patrick Giasson, Joe Barnum |\n+| 2484DWH8 | KeypadLinc Countdown Timer | 0x000041 | Rob Nielsen |\n+| 2413U | PowerLinc 2413U USB modem | 0x000045 | Bernd Pfrommer |\n+| 2843-222 | Wireless Open/Close Sensor | 0x000049 | Josenivaldo Benito |\n+| 2842-222 | Motion Sensor | 0x00004A | Bernd Pfrommer |\n+| 2486DWH8 | KeypadLinc Dimmer | 0x000051 | Chris Graham |\n+| 2472D | OutletLincDimmer | 0x000068 | Chris Graham |\n+| X10 switch | generic X10 switch | X00.00.01 | Bernd Pfrommer |\n+| X10 dimmer | generic X10 dimmer | X00.00.02 | Bernd Pfrommer |\n+| X10 motion | generic X10 motion sensor | X00.00.03 | Bernd Pfrommer |\n+\n+## Channels\n+\n+Below is the list of possible channels for the Insteon devices. In order to determing which channels a device supports, you can either look at the device in Paper UI, or find it in the openhab log file.\n+\n+| channel  | type   | description                  |\n+|----------|--------|------------------------------|\n+| acDelay | Number | AC Delay |\n+| backlightDuration | Number | Back Light Duration |\n+| batteryLevel | Number | Battery Level |\n+| batteryWatermarkLevel | Number | Battery Watermark Level |\n+| bottomOutlet | Switch | Bottom Outlet |\n+| buttonA | Switch | Button A |\n+| buttonB | Switch | Button B |\n+| buttonC | Switch | Button C |\n+| buttonD | Switch | Button D |\n+| buttonE | Switch | Button E |\n+| buttonF | Switch | Button F |\n+| buttonG | Switch | Button G |\n+| buttonH | Switch | Button H |\n+| broadcastOnOff | Switch | Broadcast On/Off |\n+| contact | Contact | Contact |\n+| coolSetPoint | Number | Cool Set Point |\n+| dimmer | Dimmer | Dimmer |\n+| fan | Number | Fan |\n+| fanMode | Number | Fan Mode |\n+| fastOnOff | Switch | Fast On/Off |\n+| fastOnOffButtonA | Switch | Fast On/Off Button A |\n+| fastOnOffButtonB | Switch | Fast On/Off Button B |\n+| fastOnOffButtonC | Switch | Fast On/Off Button C |\n+| fastOnOffButtonD | Switch | Fast On/Off Button D |\n+| heatSetPoint | Number | Heat Set Point |\n+| humidity | Number | Humidity |\n+| humidityHigh | Number | Humidity High |\n+| humidityLow | Number | Humidity Low |\n+| isCooling | Number | Is Cooling |\n+| isHeating | Number | Is Heating |\n+| keypadButtonA | Switch | Keypad Button A |\n+| keypadButtonB | Switch | Keypad Button B |\n+| keypadButtonC | Switch | Keypad Button C |\n+| keypadButtonD | Switch | Keypad Button D |\n+| keypadButtonE | Switch | Keypad Button E |\n+| keypadButtonF | Switch | Keypad Button F |\n+| keypadButtonG | Switch | Keypad Button G |\n+| keypadButtonH | Switch | Keypad Button H |\n+| kWh | Number | Kilowatt Hour |\n+| lastHeardFrom | DateTime | Last Heard From |\n+| ledBrightness | Number | LED brightness |\n+| lightDimmer | Dimmer | light Dimmer |\n+| lightLevel | Number | Light Level |\n+| loadDimmer | Dimmer | Load Dimmer |\n+| loadSwitch | Switch | Load Switch |\n+| loadSwitchFastOnOff | Switch | Load Switch Fast On/Off |\n+| loadSwitchManualChange | Number | Load Switch Manual Change |\n+| manualChange | Number | Manual Change |\n+| manualChangeButtonA | Number | Manual Change Button A |\n+| manualChangeButtonB | Number | Manual Change Button B |\n+| manualChangeButtonC | Number | Manual Change Button C |\n+| manualChangeButtonD | Number | Manual Change Button D |\n+| notification | Number | Notification |\n+| onLevel | Number | On Level |\n+| rampDimmer | Dimmer | Ramp Dimmer |\n+| rampRate | Number | Ramp Rate |\n+| reset | Switch | Reset |\n+| stage1Duration | Number | Stage 1 Duration |\n+| switch | Switch | Switch |\n+| systemMode | Number | System Mode |\n+| tempCelsius | Number | Temperature Celsius |\n+| tempFahrenheit | Number | Temperature Fahrenheit |\n+| topOutlet | Switch | Top Outlet |\n+| update | Switch | Update |\n+| watts | Number | Watts |\n+\n+\n+## Full Example\n+\n+Sample things file:\n+\n+```\n+Bridge insteon:network:local [port=\"/dev/ttyUSB0\"] {\n+  Thing device 22F8A8 [address=\"22.F8.A8\", productKey=\"F00.00.15\"] {\n+    Channels:\n+      Type switch : keypadButtonA [ group=3 ]\n+      Type switch : keypadButtonB [ group=4 ]\n+      Type switch : keypadButtonC [ group=5 ]\n+      Type switch : keypadButtonD [ group=6 ]\n+  }\n+  Thing device 238D93 [address=\"23.8D.93\", productKey=\"F00.00.12\"]\n+  Thing device 238F55 [address=\"23.8F.55\", productKey=\"F00.00.11\"] {\n+    Channels:\n+      Type dimmer : dimmer [related=\"23.B0.D9+23.8F.C9\"]\n+  }\n+  Thing device 238FC9 [address=\"23.8F.C9\", productKey=\"F00.00.11\"] {\n+    Channels:\n+      Type dimmer : dimmer [related=\"23.8F.55+23.B0.D9\"]\n+  }\n+  Thing device 23B0D9 [address=\"23.B0.D9\", productKey=\"F00.00.11\"] {\n+    Channels:\n+      Type dimmer : dimmer [related=\"23.8F.55+23.8F.C9\"]\n+  }\n+  Thing device 243141 [address=\"24.31.41\", productKey=\"F00.00.11\"]  {\n+    Channels:\n+      Type dimmer : dimmer [dimmermax=60]\n+  }\n+}\n+```\n+\n+Sample items file:\n+\n+```\n+Switch switch1 { channel=\"insteon:device:local:243141:switch\" }\n+Dimmer dimmer1 { channel=\"insteon:device:local:238F55:dimmer\" }\n+Dimmer dimmer2 { channel=\"insteon:device:local:23B0D9:dimmer\" }\n+Dimmer dimmer3 { channel=\"insteon:device:local:238FC9:dimmer\" }\n+Dimmer keypad  { channel=\"insteon:device:local:22F8A8:loadDimmer\" }\n+Switch keypadA { channel=\"insteon:device:local:22F8A8:keypadButtonA\" }\n+Switch keypadB { channel=\"insteon:device:local:22F8A8:keypadButtonB\" }\n+Switch keypadC { channel=\"insteon:device:local:22F8A8:keypadButtonC\" }\n+Switch keypadD { channel=\"insteon:device:local:22F8A8:keypadButtonD\" }\n+Dimmer dimmer  { channel=\"insteon:device:local:238D93:dimmer\" }\n+```\n+\n+## Insteon Groups and Scenes\n+\n+How do Insteon devices tell other devices on the network that their state has changed? They send out a broadcast message, labeled with a specific *group* number. All devices (called *responders*) that are configured to listen to this message will then go into a pre-defined state. For instance when light switch A is switched to \"ON\", it will send out a message to group #1, and all responders will react to it, e.g they may go into the \"ON\" position as well. Since more than one device can participate, the sending out of the broadcast message and the subsequent state change of the responders is referred to as \"triggering a scene\". At the device and PLM level, the concept of a \"scene\" does not exist, so you will find it notably absent in the binding code and this document. A scene is strictly a higher level concept, introduced to shield the user from the details of how the communication is implemented.\n+\n+Many Insteon devices send out messages on different group numbers, depending on what happens to them. A leak sensor may send out a message on group #1 when dry, and on group #2 when wet. The default group used for e.g. linking two light switches is usually group #1.\n+\n+## Insteon binding process\n+\n+Before Insteon devices communicate with one another, they must be linked. During the linking process, one of the devices will be the \"Controller\", the other the \"Responder\" (see e.g. the [SwitchLinc Instructions](https://www.insteon.com/pdf/2477S.pdf)).\n+\n+The responder listens to messages from the controller, and reacts to them. Note that except for the case of a motion detector (which is just a controller to the modem), the modem controls the device (e.g. send on/off messages to it), and the device controls the modem (so the modem learns about the switch being toggled). For this reason, most devices and in particular switches/dimmers should be linked twice, with one taking the role of controller during the first linking, and the other acting as controller during the second linking process. To do so, first press and hold the \"Set\" button on the modem until the light starts blinking. Then press and hold the \"Set\" button on the remote device,\n+e.g. the light switch, until it double beeps (the light on the modem should go off as well). Now do exactly the reverse: press and hold the \"Set\" button on the remote device until its light starts blinking, then press and hold the \"Set\" button on the modem until it double beeps, and the light of the remote device (switch) goes off. Done.\n+\n+For some of the more sophisticated devices the complete linking process can no longer be done with the set buttons, but requires software like e.g. [Insteon Terminal](https://github.com/pfrommerd/insteon-terminal).\n+\n+## Insteon Features\n+\n+Since Insteon devices can have multiple features (for instance a switchable relay and a contact sensor) under a single Insteon address, an openHAB item is not bound to a device, but to a given feature of a device. For example, the following lines would create two Number items referring to the same thermostat device, but to different features of it:\n+\n+```\n+Number  thermostatCoolPoint \"cool point [%.1f \u00b0F]\" { channel=\"insteon:device:local:32F422:coolSetPoint\" }\n+Number  thermostatHeatPoint \"heat point [%.1f \u00b0F]\" { channel=\"insteon:device:local:32F422:heatSetPoint\" }\n+```\n+\n+### Simple light switches\n+\n+The following example shows how to configure a simple light switch (2477S) in the .items file:\n+\n+```\n+Switch officeLight \"office light\"  { channel=\"insteon:device:local:AABBCC:switch\" }\n+```\n+\n+### Simple dimmers\n+\n+Here is how to configure a simple dimmer (2477D) in the .items file:\n+\n+```\n+Dimmer kitchenChandelier \"kitchen chandelier\" { channel=\"insteon:device:local:AABBCC:dimmer\" }\n+```\n+\n+Dimmers can be configured with a maximum level when turning a device on or setting a percentage level. If a maximum level is configured, openHAB will never set the level of the dimmer above the level specified. The parameter dimmermax must be defined for the channel. The below example sets a maximum level of 70% for dim 1 and 60% for dim 2:\n+\n+**Things**\n+\n+```\n+Bridge insteon:network:local [port=\"/dev/ttyUSB0\"] {\n+  Thing device AABBCC [address=\"AA.BB.CC\", productKey=\"F00.00.11\"]  {\n+    Channels:\n+      Type dimmer : dimmer [dimmermax=70]\n+  }\n+  Thing device AABBCD [address=\"AA.BB.CD\", productKey=\"F00.00.15\"]  {\n+    Channels:\n+      Type dimmer : loadDimmer [dimmermax=60]\n+  }\n+}\n+```\n+\n+**Items**\n+\n+```\n+Dimmer d1 \"dimmer 1\" { channel=\"insteon:device:local:AABBCC:dimmer\"}\n+Dimmer d2 \"dimmer 2\" { channel=\"insteon:device:local:AABBCD:loadDimmer\"}\n+```\n+\n+Setting a maximum level does not affect manual turning on or dimming a switch.\n+\n+### On/Off Outlets\n+\n+Here's how to configure the top and bottom outlet of the in-wall 2 outlet controller:\n+\n+```\n+Switch fOutTop \"Front Outlet Top\"    <socket> { channel=\"insteon:device:local:AABBCC:topOutlet\" }\n+Switch fOutBot \"Front Outlet Bottom\" <socket> { channel=\"insteon:device:local:AABBCC:bottomOutlet\" }\n+```\n+\n+This will give you individual control of each outlet.\n+    \n+### Mini remotes\n+\n+Link the mini remote to be a controller of the modem by using the set button. Link all buttons, one after the other. The 4-button mini remote sends out messages on groups 0x01 - 0x04, each corresponding to one button. The modem's link database (see [Insteon Terminal](https://github.com/pfrommerd/insteon-terminal)) should look like this:\n+\n+```\n+    0000 xx.xx.xx                       xx.xx.xx  RESP  10100010 group: 01 data: 02 2c 41\n+    0000 xx.xx.xx                       xx.xx.xx  RESP  10100010 group: 02 data: 02 2c 41\n+    0000 xx.xx.xx                       xx.xx.xx  RESP  10100010 group: 03 data: 02 2c 41\n+    0000 xx.xx.xx                       xx.xx.xx  RESP  10100010 group: 04 data: 02 2c 41\n+```\n+\n+**Items**\n+This goes into the items file:\n+\n+```\n+    Switch miniRemoteButtonA \"mini remote button a\" { channel=\"insteon:device:local:AABBCC:buttonA\", autoupdate=\"false\" }\n+    Switch miniRemoteButtonB \"mini remote button b\" { channel=\"insteon:device:local:AABBCC:buttonB\", autoupdate=\"false\" }\n+    Switch miniRemoteButtonC \"mini remote button c\" { channel=\"insteon:device:local:AABBCC:buttonC\", autoupdate=\"false\" }\n+    Switch miniRemoteButtonD \"mini remote button d\" { channel=\"insteon:device:local:AABBCC:buttonD\", autoupdate=\"false\" }\n+```\n+\n+**Sitemap**\n+This goes into the sitemap file:\n+\n+```\n+    Switch item=miniRemoteButtonA label=\"mini remote button a\" mappings=[ OFF=\"Off\", ON=\"On\"]\n+    Switch item=miniRemoteButtonB label=\"mini remote button b\" mappings=[ OFF=\"Off\", ON=\"On\"]\n+    Switch item=miniRemoteButtonC label=\"mini remote button c\" mappings=[ OFF=\"Off\", ON=\"On\"]\n+    Switch item=miniRemoteButtonD label=\"mini remote button d\" mappings=[ OFF=\"Off\", ON=\"On\"]\n+```\n+\n+The switches in the GUI just display the mini remote's most recent button presses. They are not operable because the PLM cannot trigger the mini remotes scenes.\n+\n+### Motion sensors\n+\n+Link such that the modem is a responder to the motion sensor. Create a contact.map file in the transforms directory as described elsewhere in this document. Then create entries in the .items file like this:\n+\n+**Items**\n+\n+```\n+    Contact motionSensor             \"motion sensor [MAP(contact.map):%s]\" { channel=\"insteon:device:local:AABBCC:contact\"}\n+    Number  motionSensorBatteryLevel \"motion sensor battery level [%.1f]\"  { channel=\"insteon:device:local:AABBCC:batteryLevel\" }\n+    Number  motionSensorLightLevel   \"motion sensor light level [%.1f]\"    { channel=\"insteon:device:local:AABBCC:lightLevel\" }\n+```\n+\n+This will give you a contact, the battery level, and the light level. Note that battery and light level are only updated when either there is motion, or the sensor battery runs low.\n+\n+### Hidden door sensors\n+\n+Similar in operation to the motion sensor above.  Link such that the modem is a responder to the motion sensor. Create a contact.map file in the transforms directory like the following:\n+\n+```\n+    OPEN=open\n+    CLOSED=closed\n+    -=unknown\n+```\n+\n+**Items**\n+Then create entries in the .items file like this:\n+\n+```\n+    Contact doorSensor             \"Door sensor [MAP(contact.map):%s]\" { channel=\"insteon:device:local:AABBCC:contact\" }\n+    Number  doorSensorBatteryLevel \"Door sensor battery level [%.1f]\"  { channel=\"insteon:device:local:AABBCC:batteryLevel\" }\n+```\n+\n+This will give you a contact and the battery level. Note that battery level is only updated when either there is motion, or the sensor battery runs low.\n+\n+### Locks\n+\n+Read the instructions very carefully: sync with lock within 5 feet to avoid bad connection, link twice for both ON and OFF functionality.\n+\n+**Items**\n+Put something like this into your .items file:\n+\n+```\n+    Switch doorLock \"Front Door [MAP(lock.map):%s]\"  { channel=\"insteon:device:local:AABBCC:switch\" }\n+```\n+\n+and create a file \"lock.map\" in the transforms directory with these entries: \n+\n+```\n+    ON=Lock\n+    OFF=Unlock\n+    -=unknown\n+```\n+\n+### I/O Linc (garage door openers)\n+\n+The I/O Linc devices are really two devices in one: a relay and a contact. Link the modem both ways, as responder and controller using the set buttons as described in the instructions.\n+\n+Add this map into your transforms directory as \"contact.map\":\n+\n+```\n+    OPEN=open\n+    CLOSED=closed\n+    -=unknown\n+```\n+\n+**Items**\n+Along with this into your .items file:\n+\n+```\n+    Switch  garageDoorOpener  \"garage door opener\"                        <garagedoor>  { channel=\"insteon:device:local:AABBCC:switch\", autoupdate=\"false\" }\n+    Contact garageDoorContact \"garage door contact [MAP(contact.map):%s]\"               { channel=\"insteon:device:local:AABBCC:contact\" }\n+```\n+\n+**Sitemap**\n+To make it visible in the GUI, put this into your sitemap file:\n+\n+```\n+    Switch item=garageDoorOpener label=\"garage door opener\" mappings=[ ON=\"OPEN/CLOSE\"]\n+    Text item=garageDoorContact\n+```\n+\n+For safety reasons, only close the garage door if you have visual contact to make sure there is no obstruction! The use of automated rules for closing garage doors is dangerous.\n+\n+> NOTE: If the I/O Linc returns the wrong value when the device is polled (For example you open the garage door and the state correctly shows OPEN, but during polling it shows CLOSED), you probably linked the device with the PLM or hub when the door was in the wrong position. You need unlink and then link again with the door in the opposite position. Please see the Insteon I/O Linc documentation for further details.\n+\n+### Keypads\n+\n+Before you attempt to configure the keypads, please familiarize yourself with the concept of an Insteon group.\n+\n+The Insteon keypad devices typically control one main load and have a number of buttons that will send out group broadcast messages to trigger a scene. If you just want to use the main load switch within openhab just link modem and device with the set buttons as usual, no complicated linking is necessary. But if you want to get the buttons to work, read on.\n+\n+Each button will send out a message for a different, predefined group. Complicating matters further, the button numbering used internally by the device must be mapped to whatever labels are printed on the physical buttons of the device. Here is an example correspondence table:\n+\n+| Group | Button Number | 2487S Label |\n+|-------|---------------|-------------|\n+|  0x01 |        1      |   (Load)    |\n+|  0x03 |        3      |     A       |\n+|  0x04 |        4      |     B       |\n+|  0x05 |        5      |     C       |\n+|  0x06 |        6      |     D       |\n+\n+When e.g. the \"A\" button is pressed (that's button #3 internally) a broadcast message will be sent out to all responders configured to listen to Insteon group #3. This means you must configure the modem as a responder to group #3 (and #4, #5, #6) messages coming from your keypad. For instructions how to do this, check out the [Insteon Terminal](https://github.com/pfrommerd/insteon-terminal). You can even do that with the set buttons (see instructions that come with the keypad).\n+\n+While capturing the messages that the buttons emit is pretty straight forward, controlling the buttons is  another matter. They cannot be simply toggled with a direct command to the device, but instead a broadcast message must be sent on a group number that the button has been programmed to listen to. This means you need to pick a set of unused groups that is globally unique (if you have multiple keypads, each one of them has to use different groups), one group for each button. The example configuration below uses groups 0xf3, 0xf4, 0xf5, and 0xf6. Then link the buttons such that they respond to those groups, and link the modem as a controller for them (see [Insteon Terminal](https://github.com/pfrommerd/insteon-terminal) documentation). In your items file you specify these groups with the \"group=\" parameters such that the binding knows what group number to put on the outgoing message.\n+\n+\n+#### Keypad switches\n+\n+**Items**\n+\n+Here is a simple example, just using the load (main) switch:\n+\n+```\n+    Switch keypadSwitch             \"main load\"          { channel=\"insteon:device:local:AABBCC:loadSwitch\" }\n+    Number keypadSwitchManualChange \"main manual change\" { channel=\"insteon:device:local:AABBCC:loadSwitchManualChange\" }\n+    Switch keypadSwitchFastOnOff    \"main fast on/off\"   { channel=\"insteon:device:local:AABBCC:loadSwitchFastOnOff\" }\n+```\n+\n+Most people will not use the fast on/off features or the manual change feature, so you really only need the first line. To make the buttons available, add the following:\n+\n+**Things**\n+\n+```\n+Bridge insteon:network:local [port=\"/dev/ttyUSB0\"] {\n+  Thing device AABBCC [address=\"AA.BB.CC\", productKey=\"F00.00.15\"] {\n+    Channels:\n+      Type switch : keypadButtonA [ group=\"0xf3\" ]\n+      Type switch : keypadButtonB [ group=\"0xf4\" ]\n+      Type switch : keypadButtonC [ group=\"0xf5\" ]\n+      Type switch : keypadButtonD [ group=\"0xf6\" ]\n+  }\n+}\n+```\n+\n+The value after group must either be a number or string. The hexadecimal value 0xf3 can either converted to a numeric value 243 or the string value \"0xf3\".\n+\n+**Items**\n+\n+```\n+    Switch keypadSwitchA \"keypad button A\" { channel=\"insteon:device:local:AABBCC:keypadButtonA\"}\n+    Switch keypadSwitchB \"keypad button B\" { channel=\"insteon:device:local:AABBCC:keypadButtonB\"}\n+    Switch keypadSwitchC \"keypad button C\" { channel=\"insteon:device:local:AABBCC:keypadButtonC\"}\n+    Switch keypadSwitchD \"keypad button D\" { channel=\"insteon:device:local:AABBCC:keypadButtonD\"}\n+```\n+\n+**Sitemap**\n+\n+The following sitemap will bring the items to life in the GUI:\n+\n+```\n+    Frame label=\"Keypad\" {\n+          Switch item=keypadSwitch label=\"main\"\n+          Switch item=keypadSwitchFastOnOff label=\"fast on/off\"\n+          Switch item=keypadSwitchManualChange label=\"manual change\" mappings=[ 0=\"DOWN\", 1=\"STOP\",  2=\"UP\"]\n+          Switch item=keypadSwitchA label=\"button A\"\n+          Switch item=keypadSwitchB label=\"button B\"\n+          Switch item=keypadSwitchC label=\"button C\"\n+          Switch item=keypadSwitchD label=\"button D\"\n+    }\n+```\n+\n+#### Keypad dimmers\n+\n+The keypad dimmers are like keypad switches, except that the main load is dimmable.\n+\n+**Items**\n+\n+```\n+    Dimmer keypadDimmer           \"dimmer\"                          { channel=\"insteon:device:local:AABBCC:loadDimmer\" }\n+    Switch keypadDimmerButtonA    \"keypad dimmer button A [%d %%]\"  { channel=\"insteon:device:local:AABBCC:keypadButtonA\" }\n+```\n+\n+**Sitemap**\n+\n+```\n+    Slider item=keypadDimmer switchSupport\n+    Switch item=keypadDimmerButtonA label=\"buttonA\"\n+```\n+\n+### Thermostats\n+\n+The thermostat (2441TH) is one of the most complex Insteon devices available. It must first be properly linked to the modem using configuration software like [Insteon Terminal](https://github.com/pfrommerd/insteon-terminal). The Insteon Terminal wiki describes in detail how to link the thermostat, and how to make it publish status update reports.\n+\n+When all is set and done the modem must be configured as a controller to group 0 (not sure why), and a responder to groups 1-5 such that it picks up when the thermostat switches on/off heating and cooling etc, and it must be a responder to special group 0xEF to get status update reports when measured values (temperature) change. Symmetrically, the thermostat must be a responder to group 0, and a controller for groups 1-5 and 0xEF. The linking process is not difficult but needs some persistence. Again, refer to the [Insteon Terminal](https://github.com/pfrommerd/insteon-terminal) documentation.\n+\n+**Items**\n+\n+This is an example of what to put into your .items file:\n+\n+```\n+    Number  thermostatCoolPoint   \"cool point [%.1f \u00b0F]\"  { channel=\"insteon:device:local:AABBCC:coolSetPoint\" }\n+    Number  thermostatHeatPoint   \"heat point [%.1f \u00b0F]\"  { channel=\"insteon:device:local:AABBCC:heatSetPoint\" }\n+    Number  thermostatSystemMode  \"system mode [%d]\"      { channel=\"insteon:device:local:AABBCC:systemMode\" }\n+    Number  thermostatFanMode     \"fan mode [%d]\"         { channel=\"insteon:device:local:AABBCC:fanMode\" }\n+    Number  thermostatIsHeating   \"is heating [%d]\"       { channel=\"insteon:device:local:AABBCC:isHeating\"}\n+    Number  thermostatIsCooling   \"is cooling [%d]\"       { channel=\"insteon:device:local:AABBCC:isCooling\" }\n+    Number  thermostatTempFahren  \"temperature [%.1f \u00b0F]\" { channel=\"insteon:device:local:AABBCC:tempFahrenheit\" }\n+    Number  thermostatTempCelsius \"temperature [%.1f \u00b0C]\" { channel=\"insteon:device:local:AABBCC:tempCelsius\" }\n+    Number  thermostatHumidity    \"humidity [%.0f %%]\"    { channel=\"insteon:device:local:AABBCC:humidity\" }\n+```\n+\n+Add this as well for some more exotic features:\n+\n+```\n+    Number  thermostatACDelay      \"A/C delay [%d min]\"        { channel=\"insteon:device:local:AABBCC:acDelay\" }\n+    Number  thermostatBacklight    \"backlight [%d sec]\"        { channel=\"insteon:device:local:AABBCC:backlightDuration\" }\n+    Number  thermostatStage1       \"A/C stage 1 time [%d min]\" { channel=\"insteon:device:local:AABBCC:stage1Duration\" }\n+    Number  thermostatHumidityHigh \"humidity high [%d %%]\"     { channel=\"insteon:device:local:AABBCC:humidityHigh\" }\n+    Number  thermostatHumidityLow  \"humidity low [%d %%]\"      { channel=\"insteon:device:local:AABBCC:humidityLow\" }\n+```\n+\n+**Sitemap**\n+\n+For the thermostat to display in the GUI, add this to the sitemap file:\n+\n+```\n+    Text   item=thermostatTempCelsius icon=\"temperature\"\n+    Text   item=thermostatTempFahren icon=\"temperature\"\n+    Text   item=thermostatHumidity\n+    Setpoint item=thermostatCoolPoint icon=\"temperature\" minValue=63 maxValue=90 step=1\n+    Setpoint item=thermostatHeatPoint icon=\"temperature\" minValue=50 maxValue=80 step=1\n+    Switch item=thermostatSystemMode  label=\"system mode\" mappings=[ 0=\"OFF\",  1=\"HEAT\", 2=\"COOL\", 3=\"AUTO\", 4=\"PROGRAM\"]\n+    Switch item=thermostatFanMode  label=\"fan mode\" mappings=[ 0=\"AUTO\",  1=\"ALWAYS ON\"]\n+    Switch item=thermostatIsHeating  label=\"is heating\" mappings=[ 0=\"OFF\",  1=\"HEATING\"]\n+    Switch item=thermostatIsCooling  label=\"is cooling\" mappings=[ 0=\"OFF\",  1=\"COOLING\"]\n+    Setpoint item=thermostatACDelay  minValue=2 maxValue=20 step=1\n+    Setpoint item=thermostatBacklight  minValue=0 maxValue=100 step=1\n+    Setpoint item=thermostatHumidityHigh  minValue=0 maxValue=100 step=1\n+    Setpoint item=thermostatHumidityLow   minValue=0 maxValue=100 step=1\n+    Setpoint item=thermostatStage1  minValue=1 maxValue=60 step=1\n+```\n+\n+### Power Meters\n+\n+The iMeter Solo reports both wattage and kilowatt hours, and is updated during the normal polling process of the devices. You can also manually update the current values from the device and reset the device. See the example below:\n+\n+**Items**\n+\n+``` \n+    Number iMeterWatts   \"iMeter [%d watts]\"   { channel=\"insteon:device:local:AABBCC:watts\" }\n+    Number iMeterKwh     \"iMeter [%.04f kwh]\"  { channel=\"insteon:device:local:AABBCC:kwh\" }\n+    Switch iMeterUpdate  \"iMeter Update\"       { channel=\"insteon:device:local:AABBCC:update\" }\n+    Switch iMeterReset   \"iMeter Reset\"        { channel=\"insteon:device:local:AABBCC:reset\" }\n+```\n+\n+### Fan Controllers\n+\n+Here is an example configuration for a FanLinc module, which has a dimmable light and a variable speed fan:\n+\n+**Items**\n+\n+```\n+    Dimmer fanLincDimmer \"fanlinc dimmer [%d %%]\" { channel=\"insteon:device:local:AABBCC:lightDimmer\" }\n+    Number fanLincFan    \"fanlinc fan\"            { channel=\"insteon:device:local:AABBCC:fan\"}\n+```\n+\n+**Sitemap**\n+\n+```\n+    Slider item=fanLincDimmer switchSupport\n+    Switch item=fanLincFan label=\"fan speed\" mappings=[ 0=\"OFF\",  1=\"LOW\", 2=\"MEDIUM\", 3=\"HIGH\"]\n+```\n+\n+### X10 devices\n+\n+It is worth noting that both the Inseon PLM and the 2014 Hub can both command X10 devices over the powerline, and also set switch stats based on X10 signals received over the powerline.  This allows openHAB not only control X10 devices without the need for other hardwaare, but it can also have rules that react to incoming X10 powerline commands.  While you cannot bind the the X10 devices to the Insteon PLM/HUB, here are some examples for configuring X10 devices. Be aware that most X10 switches/dimmers send no status updates, i.e. openHAB will not learn about switches that are toggled manually. Further note that\n+X10 devices are addressed with `houseCode.unitCode`, e.g. `A.2`.\n+\n+**Items**\n+\n+```\n+    Switch x10Switch  \"X10 switch\" { channel=\"insteon:device:local:AABB:switch\" }\n+    Dimmer x10Dimmer  \"X10 dimmer\" { channel=\"insteon:device:local:AABB:dimmer\" }\n+    Contact x10Motion \"X10 motion\" { channel=\"insteon:device:local:AABB:contact\" }\n+```\n+\n+## Direct sending of group broadcasts (triggering scenes)\n+\n+The binding can command the modem to send broadcasts to a given Insteon group. Since it is a broadcast message, the corresponding item does *not* take the address of any device, but of the modem itself. The format is broadcastOnOff#X where X is the group that you want to be able to broadcast messages to:\n+\n+**Things**\n+\n+```\n+Bridge insteon:network:local      [port=\"/dev/ttyUSB0\"] {\n+  Thing device AABBCC             [address=\"AA.BB.CC\", productKey=\"0x000045\"] {\n+    Channels:\n+      Type switch : broadcastOnOff#2\n+  }\n+}\n+\n+```\n+\n+**Items**\n+\n+```\n+    Switch  broadcastOnOff \"group on/off\"  { channel=\"insteon:device:local:AABBCC:broadcastOnOff#2\" }\n+```\n+\n+Flipping this switch to \"ON\" will cause the modem to send a broadcast message with group=2, and all devices that are configured to respond to it should react.\n+\n+## 3-way switch configurations and the \"related\" keyword\n+\n+When an Insteon device changes its state because it is directly operated (for example by flipping a switch manually), it sends out a broadcast message to announce the state change, and the binding (if the PLM modem is properly linked as a responder) should update the corresponding openHAB items. Other linked devices however may also change their state in response, but those devices will *not* send out a broadcast message, and so openHAB will not learn about their state change until the next poll. One common scenario is e.g. a switch in a 3-way configuration, with one switch controlling the load, and the other switch being linked as a controller. In this scenario, the \"related\" keyword can be used to cause the binding to poll a related device whenever a state change occurs for another device. A typical example would be two dimmers (A and B) in a 3-way configuration:\n+\n+```\n+Bridge insteon:network:local [port=\"/dev/ttyUSB0\"] {\n+  Thing device AABBCC [address=\"AA.BB.CC\", productKey=\"F00.00.11\"] {\n+    Channels:\n+      Type dimmer : dimmer [related=\"AA.BB.DD\"]\n+  }\n+  Thing device AABBDD [address=\"AA.BB.DD\", productKey=\"F00.00.11\"] {\n+    Channels:\n+      Type dimmer : dimmer [related=\"AA.BB.CC\"]\n+  }\n+}\n+```\n+\n+More than one device can be polled by separating them with \"+\" sign, e.g. \"related=aa.bb.cc+xx.yy.zz\" would poll both of these devices. The implemenation of the *related* keyword is simple: if you add it to a channel, and that channel changes its state, then the *related* device will be polled to see if its state has updated.\n+\n+## Troubleshooting\n+\n+Turn on DEBUG or TRACE logging for `org.openhab.binding.insteon`. See [logging in openHAB](https://www.openhab.org/docs/administration/logging.html) for more info.\n+\n+### Device Permissions / Linux Device Locks\n+\n+When openHAB is running as a non-root user (Linux/OSX) it is important to ensure it has write access not just to the PLM device, but to the os lock directory. Under openSUSE this is `/run/lock` and is managed by the **lock** group. \n+\n+Example commands to grant openHAB access (adjust for your distribution):\n+\n+````\n+usermod -a -G dialout openhab\n+usermod -a -G lock openhab\n+````\n+\n+Insufficient access to the lock directory will result in openHAB failing to access the device, even if the device itself is writable.\n+\n+### Adding new device types (using existing device features)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "04a9796d14dfbc5f3ff997d872f04b6d03ee411d"}, "originalPosition": 663}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTMxNjg3Ng==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            ### Adding new device features\n          \n          \n            \n            ### Adding New Device Features", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r389316876", "createdAt": "2020-03-07T22:28:44Z", "author": {"login": "kaikreuzer"}, "path": "bundles/org.openhab.binding.insteon/README.md", "diffHunk": "@@ -0,0 +1,719 @@\n+# Insteon Binding\n+\n+Insteon is a home area networking technology developed primarily for connecting light switches and loads. Insteon devices send messages either via the power line, or by means of radio frequency (RF) waves, or both (dual-band). A considerable number of Insteon compatible devices such as switchable relays, thermostats, sensors etc are available. More about Insteon can be found on [Wikipedia](http://en.wikipedia.org/wiki/Insteon).\n+\n+This binding provides access to the Insteon network by means of either an Insteon PowerLinc Modem (PLM), a legacy Insteon Hub 2242-222 or the current 2245-222 Insteon Hub. The modem can be connected to the openHAB server either via a serial port (Model 2413S) or a USB port (Model 2413U). The Insteon PowerLinc Controller (Model 2414U) is not supported since it is a PLC not a PLM. The modem can also be connected via TCP (such as ser2net).  The binding translates openHAB commands into Insteon messages and sends them on the Insteon network. Relevant messages from the Insteon network (like notifications about switches being toggled) are picked up by the modem and converted to openHAB status updates by the binding. The binding also supports sending and receiving of legacy X10 messages.\n+\n+The binding does not support linking new devices on the fly, i.e. all devices must be linked with the modem *before* starting the Insteon binding.\n+\n+openHAB is not a configuration tool! To configure and set up your devices, link the devices manually via the set buttons, or use the free [Insteon Terminal](https://github.com/pfrommerd/insteon-terminal) software. The free HouseLinc software from Insteon can also be used for configuration, but it wipes the modem link database clean on its initial use, requiring to re-link the modem to all devices.\n+\n+## Supported Things\n+\n+| Thing  | Type   | Description                  |\n+|----------|--------|------------------------------|\n+| network  | Bridge | An insteon PLM or hub that is used to communicate with the Insteon devices |\n+|device| Thing | Insteon devices such as dimmers, keypads, sensors, etc. |\n+\n+## Discovery\n+\n+The binding will automatically add the network bridge called local to the Paper UI inbox. Upon proper configuration of the network bridge, the network device database will be downloaded. Any Insteon device that exists in the database and is not currently configured will get added to the inbox.  The naming convention is **Insteon Device AABBCC**, where AA, BB and CC are from the Insteon device address.  X10 devices are not auto discovered. \n+\n+## Thing Configuration\n+\n+###### Network Configuration\n+\n+The Insteon PLM or hub is configured with the following:\n+\n+| Parameter | Default | Required | Description |\n+|----------|---------:|--------:|-------------|\n+| port   |         |   Yes    | **Examples:**<br>- PLM on  Linux: `/dev/ttyS0` or `/dev/ttyUSB0`<br>- Smartenit ZBPLM on Linux: `/dev/ttyUSB0,baudRate=115200`<br>- PLM on Windows: `COM1`<br>- Current  hub (2245-222) at 192.168.1.100 on port 25105, with a poll interval of 1000 ms (1 second): `/hub2/my_user_name:my_password@192.168.1.100:25105,poll_time=1000`<br>- Legacy hub (2242-222) at 192.168.1.100 on port 9761:`/hub/192.168.1.100:9761`<br>- Networked PLM using ser2net at 192.168.1.100 on port 9761:`/tcp/192.168.1.100:9761` |\n+| devicePollIntervalSeconds | 300 |  No  | Poll interval of devices in seconds. Poll too often and you will overload the insteon network, leading to sluggish or no response when trying to send messages to devices. The default poll interval of 300 seconds has been tested and found to be a good compromise in a configuration of about 110 switches/dimmers. |\n+|modemDbRetryTimeoutSeconds|120|No|The number of seconds to wait for the modem database to completely download before retrying again.  Under normal circumstances this will not need to be modified.|\n+| additionalDevices | |       No     | Optional file with additional device types. The syntax of the file is identical to the `device_types.xml` file in the source tree. Please remember to post successfully added device types to the openhab group so the developers can include them into the `device_types.xml` file! |\n+| additionalFeatures | |      No     | Optional file with additional feature templates, like in the `device_features.xml` file in the source tree. |\n+\n+>NOTE: For users upgrading from InsteonPLM, The parameter port_1 is now port. \n+\n+###### Device Configuration\n+\n+The Insteon device is configured with the following required parameters:\n+\n+| Parameter | Description |\n+|----------|-------------|\n+|address|Insteon or X10 address of the device. Insteon device addresses are in the format 'xx.xx.xx', and can be found on the device. X10 device address are in the format 'x.y' and are typically configured on the device.|\n+|productKey|Insteon binding product key that is used to identy the device. Every Insteon device type is uniquely identified by its Insteon product key, typically a six digit hex number. For some of the older device types (in particular the SwitchLinc switches and dimmers), Insteon does not give a product key, so an arbitrary fake one of the format Fxx.xx.xx (or Xxx.xx.xx for X10 devices) is assigned by the binding.|\n+\n+The following is a list of the product keys and associated devices. These have been tested and should work out of the box:\n+\n+| Model | Description | Product Key | tested by |\n+|-------|-------------|-------------|-----------|\n+| 2477D | SwitchLinc Dimmer | F00.00.01 | Bernd Pfrommer |\n+| 2477S | SwitchLinc Switch | F00.00.02 | Bernd Pfrommer |\n+| 2845-222 | Hidden Door Sensor | F00.00.03 | Josenivaldo Benito |\n+| 2876S | ICON Switch | F00.00.04 | Patrick Giasson |\n+| 2456D3 | LampLinc V2 | F00.00.05 | Patrick Giasson |\n+| 2442-222 | Micro Dimmer | F00.00.06 | Josenivaldo Benito |\n+| 2453-222 | DIN Rail On/Off | F00.00.07 | Josenivaldo Benito |\n+| 2452-222 | DIN Rail Dimmer | F00.00.08 | Josenivaldo Benito |\n+| 2458-A1 | MorningLinc RF Lock Controller | F00.00.09 | cdeadlock |\n+| 2852-222 | Leak Sensor | F00.00.0A | Kirk McCann |\n+| 2672-422 | LED Dimmer | F00.00.0B | ??? |\n+| 2476D | SwitchLinc Dimmer | F00.00.0C | LiberatorUSA |\n+| 2634-222 | On/Off Dual-Band Outdoor Module | F00.00.0D | LiberatorUSA |\n+| 2342-2 | Mini Remote | F00.00.10 | Bernd Pfrommer |\n+| 2663-222 | On/Off Outlet | 0x000039 | SwissKid |\n+| 2466D | ToggleLinc Dimmer | F00.00.11 | Rob Nielsen |\n+| 2466S | ToggleLinc Switch | F00.00.12 | Rob Nielsen |\n+| 2672-222 | LED Bulb | F00.00.13 | Rob Nielsen |\n+| 2487S | KeypadLinc On/Off 6-Button | F00.00.14 | Bernd Pfrommer |\n+| 2334-232 | KeypadLink Dimmer 6-Button | F00.00.15 | Rob Nielsen |\n+| 2334-232 | KeypadLink Dimmer 8-Button | F00.00.16 | Rob Nielsen |\n+| 2423A1 | iMeter Solo Power Meter | F00.00.17 | Rob Nielsen |\n+| 2423A1 | Thermostat 2441TH | F00.00.18 | Daniel Campbell, Bernd Pfrommer |\n+| 2457D2 | LampLinc Dimmer | F00.00.19 | Jonathan Huizingh |\n+| 2475SDB | In-LineLinc Relay | F00.00.1A | Jim Howard |\n+| 2635-222 | On/Off Module | F00.00.1B | Jonathan Huizingh |\n+| 2475F | FanLinc Module | F00.00.1C | Brian Tillman |\n+| 2456S3 | ApplianceLinc | F00.00.1D | ??? |\n+| 2674-222 | LED Bulb (recessed) | F00.00.1E | Steve Bate |\n+| 2477SA1 | 220V 30-amp Load Controller N/O | F00.00.1F | Shawn R. |\n+| 2342-222 | Mini Remote (8 Button) | F00.00.20 | Bernd Pfrommer |\n+| 2441V | Insteon Thermostat Adaptor for Venstar | F00.00.21 | Bernd Pfrommer |\n+| 2982-222 | Insteon Smoke Bridge | F00.00.22 | Bernd Pfrommer |\n+| 2450 | IO Link | 0x00001A | Bernd Pfrommer |\n+| 2486D | KeypadLinc Dimmer | 0x000037 | Patrick Giasson, Joe Barnum |\n+| 2484DWH8 | KeypadLinc Countdown Timer | 0x000041 | Rob Nielsen |\n+| 2413U | PowerLinc 2413U USB modem | 0x000045 | Bernd Pfrommer |\n+| 2843-222 | Wireless Open/Close Sensor | 0x000049 | Josenivaldo Benito |\n+| 2842-222 | Motion Sensor | 0x00004A | Bernd Pfrommer |\n+| 2486DWH8 | KeypadLinc Dimmer | 0x000051 | Chris Graham |\n+| 2472D | OutletLincDimmer | 0x000068 | Chris Graham |\n+| X10 switch | generic X10 switch | X00.00.01 | Bernd Pfrommer |\n+| X10 dimmer | generic X10 dimmer | X00.00.02 | Bernd Pfrommer |\n+| X10 motion | generic X10 motion sensor | X00.00.03 | Bernd Pfrommer |\n+\n+## Channels\n+\n+Below is the list of possible channels for the Insteon devices. In order to determing which channels a device supports, you can either look at the device in Paper UI, or find it in the openhab log file.\n+\n+| channel  | type   | description                  |\n+|----------|--------|------------------------------|\n+| acDelay | Number | AC Delay |\n+| backlightDuration | Number | Back Light Duration |\n+| batteryLevel | Number | Battery Level |\n+| batteryWatermarkLevel | Number | Battery Watermark Level |\n+| bottomOutlet | Switch | Bottom Outlet |\n+| buttonA | Switch | Button A |\n+| buttonB | Switch | Button B |\n+| buttonC | Switch | Button C |\n+| buttonD | Switch | Button D |\n+| buttonE | Switch | Button E |\n+| buttonF | Switch | Button F |\n+| buttonG | Switch | Button G |\n+| buttonH | Switch | Button H |\n+| broadcastOnOff | Switch | Broadcast On/Off |\n+| contact | Contact | Contact |\n+| coolSetPoint | Number | Cool Set Point |\n+| dimmer | Dimmer | Dimmer |\n+| fan | Number | Fan |\n+| fanMode | Number | Fan Mode |\n+| fastOnOff | Switch | Fast On/Off |\n+| fastOnOffButtonA | Switch | Fast On/Off Button A |\n+| fastOnOffButtonB | Switch | Fast On/Off Button B |\n+| fastOnOffButtonC | Switch | Fast On/Off Button C |\n+| fastOnOffButtonD | Switch | Fast On/Off Button D |\n+| heatSetPoint | Number | Heat Set Point |\n+| humidity | Number | Humidity |\n+| humidityHigh | Number | Humidity High |\n+| humidityLow | Number | Humidity Low |\n+| isCooling | Number | Is Cooling |\n+| isHeating | Number | Is Heating |\n+| keypadButtonA | Switch | Keypad Button A |\n+| keypadButtonB | Switch | Keypad Button B |\n+| keypadButtonC | Switch | Keypad Button C |\n+| keypadButtonD | Switch | Keypad Button D |\n+| keypadButtonE | Switch | Keypad Button E |\n+| keypadButtonF | Switch | Keypad Button F |\n+| keypadButtonG | Switch | Keypad Button G |\n+| keypadButtonH | Switch | Keypad Button H |\n+| kWh | Number | Kilowatt Hour |\n+| lastHeardFrom | DateTime | Last Heard From |\n+| ledBrightness | Number | LED brightness |\n+| lightDimmer | Dimmer | light Dimmer |\n+| lightLevel | Number | Light Level |\n+| loadDimmer | Dimmer | Load Dimmer |\n+| loadSwitch | Switch | Load Switch |\n+| loadSwitchFastOnOff | Switch | Load Switch Fast On/Off |\n+| loadSwitchManualChange | Number | Load Switch Manual Change |\n+| manualChange | Number | Manual Change |\n+| manualChangeButtonA | Number | Manual Change Button A |\n+| manualChangeButtonB | Number | Manual Change Button B |\n+| manualChangeButtonC | Number | Manual Change Button C |\n+| manualChangeButtonD | Number | Manual Change Button D |\n+| notification | Number | Notification |\n+| onLevel | Number | On Level |\n+| rampDimmer | Dimmer | Ramp Dimmer |\n+| rampRate | Number | Ramp Rate |\n+| reset | Switch | Reset |\n+| stage1Duration | Number | Stage 1 Duration |\n+| switch | Switch | Switch |\n+| systemMode | Number | System Mode |\n+| tempCelsius | Number | Temperature Celsius |\n+| tempFahrenheit | Number | Temperature Fahrenheit |\n+| topOutlet | Switch | Top Outlet |\n+| update | Switch | Update |\n+| watts | Number | Watts |\n+\n+\n+## Full Example\n+\n+Sample things file:\n+\n+```\n+Bridge insteon:network:local [port=\"/dev/ttyUSB0\"] {\n+  Thing device 22F8A8 [address=\"22.F8.A8\", productKey=\"F00.00.15\"] {\n+    Channels:\n+      Type switch : keypadButtonA [ group=3 ]\n+      Type switch : keypadButtonB [ group=4 ]\n+      Type switch : keypadButtonC [ group=5 ]\n+      Type switch : keypadButtonD [ group=6 ]\n+  }\n+  Thing device 238D93 [address=\"23.8D.93\", productKey=\"F00.00.12\"]\n+  Thing device 238F55 [address=\"23.8F.55\", productKey=\"F00.00.11\"] {\n+    Channels:\n+      Type dimmer : dimmer [related=\"23.B0.D9+23.8F.C9\"]\n+  }\n+  Thing device 238FC9 [address=\"23.8F.C9\", productKey=\"F00.00.11\"] {\n+    Channels:\n+      Type dimmer : dimmer [related=\"23.8F.55+23.B0.D9\"]\n+  }\n+  Thing device 23B0D9 [address=\"23.B0.D9\", productKey=\"F00.00.11\"] {\n+    Channels:\n+      Type dimmer : dimmer [related=\"23.8F.55+23.8F.C9\"]\n+  }\n+  Thing device 243141 [address=\"24.31.41\", productKey=\"F00.00.11\"]  {\n+    Channels:\n+      Type dimmer : dimmer [dimmermax=60]\n+  }\n+}\n+```\n+\n+Sample items file:\n+\n+```\n+Switch switch1 { channel=\"insteon:device:local:243141:switch\" }\n+Dimmer dimmer1 { channel=\"insteon:device:local:238F55:dimmer\" }\n+Dimmer dimmer2 { channel=\"insteon:device:local:23B0D9:dimmer\" }\n+Dimmer dimmer3 { channel=\"insteon:device:local:238FC9:dimmer\" }\n+Dimmer keypad  { channel=\"insteon:device:local:22F8A8:loadDimmer\" }\n+Switch keypadA { channel=\"insteon:device:local:22F8A8:keypadButtonA\" }\n+Switch keypadB { channel=\"insteon:device:local:22F8A8:keypadButtonB\" }\n+Switch keypadC { channel=\"insteon:device:local:22F8A8:keypadButtonC\" }\n+Switch keypadD { channel=\"insteon:device:local:22F8A8:keypadButtonD\" }\n+Dimmer dimmer  { channel=\"insteon:device:local:238D93:dimmer\" }\n+```\n+\n+## Insteon Groups and Scenes\n+\n+How do Insteon devices tell other devices on the network that their state has changed? They send out a broadcast message, labeled with a specific *group* number. All devices (called *responders*) that are configured to listen to this message will then go into a pre-defined state. For instance when light switch A is switched to \"ON\", it will send out a message to group #1, and all responders will react to it, e.g they may go into the \"ON\" position as well. Since more than one device can participate, the sending out of the broadcast message and the subsequent state change of the responders is referred to as \"triggering a scene\". At the device and PLM level, the concept of a \"scene\" does not exist, so you will find it notably absent in the binding code and this document. A scene is strictly a higher level concept, introduced to shield the user from the details of how the communication is implemented.\n+\n+Many Insteon devices send out messages on different group numbers, depending on what happens to them. A leak sensor may send out a message on group #1 when dry, and on group #2 when wet. The default group used for e.g. linking two light switches is usually group #1.\n+\n+## Insteon binding process\n+\n+Before Insteon devices communicate with one another, they must be linked. During the linking process, one of the devices will be the \"Controller\", the other the \"Responder\" (see e.g. the [SwitchLinc Instructions](https://www.insteon.com/pdf/2477S.pdf)).\n+\n+The responder listens to messages from the controller, and reacts to them. Note that except for the case of a motion detector (which is just a controller to the modem), the modem controls the device (e.g. send on/off messages to it), and the device controls the modem (so the modem learns about the switch being toggled). For this reason, most devices and in particular switches/dimmers should be linked twice, with one taking the role of controller during the first linking, and the other acting as controller during the second linking process. To do so, first press and hold the \"Set\" button on the modem until the light starts blinking. Then press and hold the \"Set\" button on the remote device,\n+e.g. the light switch, until it double beeps (the light on the modem should go off as well). Now do exactly the reverse: press and hold the \"Set\" button on the remote device until its light starts blinking, then press and hold the \"Set\" button on the modem until it double beeps, and the light of the remote device (switch) goes off. Done.\n+\n+For some of the more sophisticated devices the complete linking process can no longer be done with the set buttons, but requires software like e.g. [Insteon Terminal](https://github.com/pfrommerd/insteon-terminal).\n+\n+## Insteon Features\n+\n+Since Insteon devices can have multiple features (for instance a switchable relay and a contact sensor) under a single Insteon address, an openHAB item is not bound to a device, but to a given feature of a device. For example, the following lines would create two Number items referring to the same thermostat device, but to different features of it:\n+\n+```\n+Number  thermostatCoolPoint \"cool point [%.1f \u00b0F]\" { channel=\"insteon:device:local:32F422:coolSetPoint\" }\n+Number  thermostatHeatPoint \"heat point [%.1f \u00b0F]\" { channel=\"insteon:device:local:32F422:heatSetPoint\" }\n+```\n+\n+### Simple light switches\n+\n+The following example shows how to configure a simple light switch (2477S) in the .items file:\n+\n+```\n+Switch officeLight \"office light\"  { channel=\"insteon:device:local:AABBCC:switch\" }\n+```\n+\n+### Simple dimmers\n+\n+Here is how to configure a simple dimmer (2477D) in the .items file:\n+\n+```\n+Dimmer kitchenChandelier \"kitchen chandelier\" { channel=\"insteon:device:local:AABBCC:dimmer\" }\n+```\n+\n+Dimmers can be configured with a maximum level when turning a device on or setting a percentage level. If a maximum level is configured, openHAB will never set the level of the dimmer above the level specified. The parameter dimmermax must be defined for the channel. The below example sets a maximum level of 70% for dim 1 and 60% for dim 2:\n+\n+**Things**\n+\n+```\n+Bridge insteon:network:local [port=\"/dev/ttyUSB0\"] {\n+  Thing device AABBCC [address=\"AA.BB.CC\", productKey=\"F00.00.11\"]  {\n+    Channels:\n+      Type dimmer : dimmer [dimmermax=70]\n+  }\n+  Thing device AABBCD [address=\"AA.BB.CD\", productKey=\"F00.00.15\"]  {\n+    Channels:\n+      Type dimmer : loadDimmer [dimmermax=60]\n+  }\n+}\n+```\n+\n+**Items**\n+\n+```\n+Dimmer d1 \"dimmer 1\" { channel=\"insteon:device:local:AABBCC:dimmer\"}\n+Dimmer d2 \"dimmer 2\" { channel=\"insteon:device:local:AABBCD:loadDimmer\"}\n+```\n+\n+Setting a maximum level does not affect manual turning on or dimming a switch.\n+\n+### On/Off Outlets\n+\n+Here's how to configure the top and bottom outlet of the in-wall 2 outlet controller:\n+\n+```\n+Switch fOutTop \"Front Outlet Top\"    <socket> { channel=\"insteon:device:local:AABBCC:topOutlet\" }\n+Switch fOutBot \"Front Outlet Bottom\" <socket> { channel=\"insteon:device:local:AABBCC:bottomOutlet\" }\n+```\n+\n+This will give you individual control of each outlet.\n+    \n+### Mini remotes\n+\n+Link the mini remote to be a controller of the modem by using the set button. Link all buttons, one after the other. The 4-button mini remote sends out messages on groups 0x01 - 0x04, each corresponding to one button. The modem's link database (see [Insteon Terminal](https://github.com/pfrommerd/insteon-terminal)) should look like this:\n+\n+```\n+    0000 xx.xx.xx                       xx.xx.xx  RESP  10100010 group: 01 data: 02 2c 41\n+    0000 xx.xx.xx                       xx.xx.xx  RESP  10100010 group: 02 data: 02 2c 41\n+    0000 xx.xx.xx                       xx.xx.xx  RESP  10100010 group: 03 data: 02 2c 41\n+    0000 xx.xx.xx                       xx.xx.xx  RESP  10100010 group: 04 data: 02 2c 41\n+```\n+\n+**Items**\n+This goes into the items file:\n+\n+```\n+    Switch miniRemoteButtonA \"mini remote button a\" { channel=\"insteon:device:local:AABBCC:buttonA\", autoupdate=\"false\" }\n+    Switch miniRemoteButtonB \"mini remote button b\" { channel=\"insteon:device:local:AABBCC:buttonB\", autoupdate=\"false\" }\n+    Switch miniRemoteButtonC \"mini remote button c\" { channel=\"insteon:device:local:AABBCC:buttonC\", autoupdate=\"false\" }\n+    Switch miniRemoteButtonD \"mini remote button d\" { channel=\"insteon:device:local:AABBCC:buttonD\", autoupdate=\"false\" }\n+```\n+\n+**Sitemap**\n+This goes into the sitemap file:\n+\n+```\n+    Switch item=miniRemoteButtonA label=\"mini remote button a\" mappings=[ OFF=\"Off\", ON=\"On\"]\n+    Switch item=miniRemoteButtonB label=\"mini remote button b\" mappings=[ OFF=\"Off\", ON=\"On\"]\n+    Switch item=miniRemoteButtonC label=\"mini remote button c\" mappings=[ OFF=\"Off\", ON=\"On\"]\n+    Switch item=miniRemoteButtonD label=\"mini remote button d\" mappings=[ OFF=\"Off\", ON=\"On\"]\n+```\n+\n+The switches in the GUI just display the mini remote's most recent button presses. They are not operable because the PLM cannot trigger the mini remotes scenes.\n+\n+### Motion sensors\n+\n+Link such that the modem is a responder to the motion sensor. Create a contact.map file in the transforms directory as described elsewhere in this document. Then create entries in the .items file like this:\n+\n+**Items**\n+\n+```\n+    Contact motionSensor             \"motion sensor [MAP(contact.map):%s]\" { channel=\"insteon:device:local:AABBCC:contact\"}\n+    Number  motionSensorBatteryLevel \"motion sensor battery level [%.1f]\"  { channel=\"insteon:device:local:AABBCC:batteryLevel\" }\n+    Number  motionSensorLightLevel   \"motion sensor light level [%.1f]\"    { channel=\"insteon:device:local:AABBCC:lightLevel\" }\n+```\n+\n+This will give you a contact, the battery level, and the light level. Note that battery and light level are only updated when either there is motion, or the sensor battery runs low.\n+\n+### Hidden door sensors\n+\n+Similar in operation to the motion sensor above.  Link such that the modem is a responder to the motion sensor. Create a contact.map file in the transforms directory like the following:\n+\n+```\n+    OPEN=open\n+    CLOSED=closed\n+    -=unknown\n+```\n+\n+**Items**\n+Then create entries in the .items file like this:\n+\n+```\n+    Contact doorSensor             \"Door sensor [MAP(contact.map):%s]\" { channel=\"insteon:device:local:AABBCC:contact\" }\n+    Number  doorSensorBatteryLevel \"Door sensor battery level [%.1f]\"  { channel=\"insteon:device:local:AABBCC:batteryLevel\" }\n+```\n+\n+This will give you a contact and the battery level. Note that battery level is only updated when either there is motion, or the sensor battery runs low.\n+\n+### Locks\n+\n+Read the instructions very carefully: sync with lock within 5 feet to avoid bad connection, link twice for both ON and OFF functionality.\n+\n+**Items**\n+Put something like this into your .items file:\n+\n+```\n+    Switch doorLock \"Front Door [MAP(lock.map):%s]\"  { channel=\"insteon:device:local:AABBCC:switch\" }\n+```\n+\n+and create a file \"lock.map\" in the transforms directory with these entries: \n+\n+```\n+    ON=Lock\n+    OFF=Unlock\n+    -=unknown\n+```\n+\n+### I/O Linc (garage door openers)\n+\n+The I/O Linc devices are really two devices in one: a relay and a contact. Link the modem both ways, as responder and controller using the set buttons as described in the instructions.\n+\n+Add this map into your transforms directory as \"contact.map\":\n+\n+```\n+    OPEN=open\n+    CLOSED=closed\n+    -=unknown\n+```\n+\n+**Items**\n+Along with this into your .items file:\n+\n+```\n+    Switch  garageDoorOpener  \"garage door opener\"                        <garagedoor>  { channel=\"insteon:device:local:AABBCC:switch\", autoupdate=\"false\" }\n+    Contact garageDoorContact \"garage door contact [MAP(contact.map):%s]\"               { channel=\"insteon:device:local:AABBCC:contact\" }\n+```\n+\n+**Sitemap**\n+To make it visible in the GUI, put this into your sitemap file:\n+\n+```\n+    Switch item=garageDoorOpener label=\"garage door opener\" mappings=[ ON=\"OPEN/CLOSE\"]\n+    Text item=garageDoorContact\n+```\n+\n+For safety reasons, only close the garage door if you have visual contact to make sure there is no obstruction! The use of automated rules for closing garage doors is dangerous.\n+\n+> NOTE: If the I/O Linc returns the wrong value when the device is polled (For example you open the garage door and the state correctly shows OPEN, but during polling it shows CLOSED), you probably linked the device with the PLM or hub when the door was in the wrong position. You need unlink and then link again with the door in the opposite position. Please see the Insteon I/O Linc documentation for further details.\n+\n+### Keypads\n+\n+Before you attempt to configure the keypads, please familiarize yourself with the concept of an Insteon group.\n+\n+The Insteon keypad devices typically control one main load and have a number of buttons that will send out group broadcast messages to trigger a scene. If you just want to use the main load switch within openhab just link modem and device with the set buttons as usual, no complicated linking is necessary. But if you want to get the buttons to work, read on.\n+\n+Each button will send out a message for a different, predefined group. Complicating matters further, the button numbering used internally by the device must be mapped to whatever labels are printed on the physical buttons of the device. Here is an example correspondence table:\n+\n+| Group | Button Number | 2487S Label |\n+|-------|---------------|-------------|\n+|  0x01 |        1      |   (Load)    |\n+|  0x03 |        3      |     A       |\n+|  0x04 |        4      |     B       |\n+|  0x05 |        5      |     C       |\n+|  0x06 |        6      |     D       |\n+\n+When e.g. the \"A\" button is pressed (that's button #3 internally) a broadcast message will be sent out to all responders configured to listen to Insteon group #3. This means you must configure the modem as a responder to group #3 (and #4, #5, #6) messages coming from your keypad. For instructions how to do this, check out the [Insteon Terminal](https://github.com/pfrommerd/insteon-terminal). You can even do that with the set buttons (see instructions that come with the keypad).\n+\n+While capturing the messages that the buttons emit is pretty straight forward, controlling the buttons is  another matter. They cannot be simply toggled with a direct command to the device, but instead a broadcast message must be sent on a group number that the button has been programmed to listen to. This means you need to pick a set of unused groups that is globally unique (if you have multiple keypads, each one of them has to use different groups), one group for each button. The example configuration below uses groups 0xf3, 0xf4, 0xf5, and 0xf6. Then link the buttons such that they respond to those groups, and link the modem as a controller for them (see [Insteon Terminal](https://github.com/pfrommerd/insteon-terminal) documentation). In your items file you specify these groups with the \"group=\" parameters such that the binding knows what group number to put on the outgoing message.\n+\n+\n+#### Keypad switches\n+\n+**Items**\n+\n+Here is a simple example, just using the load (main) switch:\n+\n+```\n+    Switch keypadSwitch             \"main load\"          { channel=\"insteon:device:local:AABBCC:loadSwitch\" }\n+    Number keypadSwitchManualChange \"main manual change\" { channel=\"insteon:device:local:AABBCC:loadSwitchManualChange\" }\n+    Switch keypadSwitchFastOnOff    \"main fast on/off\"   { channel=\"insteon:device:local:AABBCC:loadSwitchFastOnOff\" }\n+```\n+\n+Most people will not use the fast on/off features or the manual change feature, so you really only need the first line. To make the buttons available, add the following:\n+\n+**Things**\n+\n+```\n+Bridge insteon:network:local [port=\"/dev/ttyUSB0\"] {\n+  Thing device AABBCC [address=\"AA.BB.CC\", productKey=\"F00.00.15\"] {\n+    Channels:\n+      Type switch : keypadButtonA [ group=\"0xf3\" ]\n+      Type switch : keypadButtonB [ group=\"0xf4\" ]\n+      Type switch : keypadButtonC [ group=\"0xf5\" ]\n+      Type switch : keypadButtonD [ group=\"0xf6\" ]\n+  }\n+}\n+```\n+\n+The value after group must either be a number or string. The hexadecimal value 0xf3 can either converted to a numeric value 243 or the string value \"0xf3\".\n+\n+**Items**\n+\n+```\n+    Switch keypadSwitchA \"keypad button A\" { channel=\"insteon:device:local:AABBCC:keypadButtonA\"}\n+    Switch keypadSwitchB \"keypad button B\" { channel=\"insteon:device:local:AABBCC:keypadButtonB\"}\n+    Switch keypadSwitchC \"keypad button C\" { channel=\"insteon:device:local:AABBCC:keypadButtonC\"}\n+    Switch keypadSwitchD \"keypad button D\" { channel=\"insteon:device:local:AABBCC:keypadButtonD\"}\n+```\n+\n+**Sitemap**\n+\n+The following sitemap will bring the items to life in the GUI:\n+\n+```\n+    Frame label=\"Keypad\" {\n+          Switch item=keypadSwitch label=\"main\"\n+          Switch item=keypadSwitchFastOnOff label=\"fast on/off\"\n+          Switch item=keypadSwitchManualChange label=\"manual change\" mappings=[ 0=\"DOWN\", 1=\"STOP\",  2=\"UP\"]\n+          Switch item=keypadSwitchA label=\"button A\"\n+          Switch item=keypadSwitchB label=\"button B\"\n+          Switch item=keypadSwitchC label=\"button C\"\n+          Switch item=keypadSwitchD label=\"button D\"\n+    }\n+```\n+\n+#### Keypad dimmers\n+\n+The keypad dimmers are like keypad switches, except that the main load is dimmable.\n+\n+**Items**\n+\n+```\n+    Dimmer keypadDimmer           \"dimmer\"                          { channel=\"insteon:device:local:AABBCC:loadDimmer\" }\n+    Switch keypadDimmerButtonA    \"keypad dimmer button A [%d %%]\"  { channel=\"insteon:device:local:AABBCC:keypadButtonA\" }\n+```\n+\n+**Sitemap**\n+\n+```\n+    Slider item=keypadDimmer switchSupport\n+    Switch item=keypadDimmerButtonA label=\"buttonA\"\n+```\n+\n+### Thermostats\n+\n+The thermostat (2441TH) is one of the most complex Insteon devices available. It must first be properly linked to the modem using configuration software like [Insteon Terminal](https://github.com/pfrommerd/insteon-terminal). The Insteon Terminal wiki describes in detail how to link the thermostat, and how to make it publish status update reports.\n+\n+When all is set and done the modem must be configured as a controller to group 0 (not sure why), and a responder to groups 1-5 such that it picks up when the thermostat switches on/off heating and cooling etc, and it must be a responder to special group 0xEF to get status update reports when measured values (temperature) change. Symmetrically, the thermostat must be a responder to group 0, and a controller for groups 1-5 and 0xEF. The linking process is not difficult but needs some persistence. Again, refer to the [Insteon Terminal](https://github.com/pfrommerd/insteon-terminal) documentation.\n+\n+**Items**\n+\n+This is an example of what to put into your .items file:\n+\n+```\n+    Number  thermostatCoolPoint   \"cool point [%.1f \u00b0F]\"  { channel=\"insteon:device:local:AABBCC:coolSetPoint\" }\n+    Number  thermostatHeatPoint   \"heat point [%.1f \u00b0F]\"  { channel=\"insteon:device:local:AABBCC:heatSetPoint\" }\n+    Number  thermostatSystemMode  \"system mode [%d]\"      { channel=\"insteon:device:local:AABBCC:systemMode\" }\n+    Number  thermostatFanMode     \"fan mode [%d]\"         { channel=\"insteon:device:local:AABBCC:fanMode\" }\n+    Number  thermostatIsHeating   \"is heating [%d]\"       { channel=\"insteon:device:local:AABBCC:isHeating\"}\n+    Number  thermostatIsCooling   \"is cooling [%d]\"       { channel=\"insteon:device:local:AABBCC:isCooling\" }\n+    Number  thermostatTempFahren  \"temperature [%.1f \u00b0F]\" { channel=\"insteon:device:local:AABBCC:tempFahrenheit\" }\n+    Number  thermostatTempCelsius \"temperature [%.1f \u00b0C]\" { channel=\"insteon:device:local:AABBCC:tempCelsius\" }\n+    Number  thermostatHumidity    \"humidity [%.0f %%]\"    { channel=\"insteon:device:local:AABBCC:humidity\" }\n+```\n+\n+Add this as well for some more exotic features:\n+\n+```\n+    Number  thermostatACDelay      \"A/C delay [%d min]\"        { channel=\"insteon:device:local:AABBCC:acDelay\" }\n+    Number  thermostatBacklight    \"backlight [%d sec]\"        { channel=\"insteon:device:local:AABBCC:backlightDuration\" }\n+    Number  thermostatStage1       \"A/C stage 1 time [%d min]\" { channel=\"insteon:device:local:AABBCC:stage1Duration\" }\n+    Number  thermostatHumidityHigh \"humidity high [%d %%]\"     { channel=\"insteon:device:local:AABBCC:humidityHigh\" }\n+    Number  thermostatHumidityLow  \"humidity low [%d %%]\"      { channel=\"insteon:device:local:AABBCC:humidityLow\" }\n+```\n+\n+**Sitemap**\n+\n+For the thermostat to display in the GUI, add this to the sitemap file:\n+\n+```\n+    Text   item=thermostatTempCelsius icon=\"temperature\"\n+    Text   item=thermostatTempFahren icon=\"temperature\"\n+    Text   item=thermostatHumidity\n+    Setpoint item=thermostatCoolPoint icon=\"temperature\" minValue=63 maxValue=90 step=1\n+    Setpoint item=thermostatHeatPoint icon=\"temperature\" minValue=50 maxValue=80 step=1\n+    Switch item=thermostatSystemMode  label=\"system mode\" mappings=[ 0=\"OFF\",  1=\"HEAT\", 2=\"COOL\", 3=\"AUTO\", 4=\"PROGRAM\"]\n+    Switch item=thermostatFanMode  label=\"fan mode\" mappings=[ 0=\"AUTO\",  1=\"ALWAYS ON\"]\n+    Switch item=thermostatIsHeating  label=\"is heating\" mappings=[ 0=\"OFF\",  1=\"HEATING\"]\n+    Switch item=thermostatIsCooling  label=\"is cooling\" mappings=[ 0=\"OFF\",  1=\"COOLING\"]\n+    Setpoint item=thermostatACDelay  minValue=2 maxValue=20 step=1\n+    Setpoint item=thermostatBacklight  minValue=0 maxValue=100 step=1\n+    Setpoint item=thermostatHumidityHigh  minValue=0 maxValue=100 step=1\n+    Setpoint item=thermostatHumidityLow   minValue=0 maxValue=100 step=1\n+    Setpoint item=thermostatStage1  minValue=1 maxValue=60 step=1\n+```\n+\n+### Power Meters\n+\n+The iMeter Solo reports both wattage and kilowatt hours, and is updated during the normal polling process of the devices. You can also manually update the current values from the device and reset the device. See the example below:\n+\n+**Items**\n+\n+``` \n+    Number iMeterWatts   \"iMeter [%d watts]\"   { channel=\"insteon:device:local:AABBCC:watts\" }\n+    Number iMeterKwh     \"iMeter [%.04f kwh]\"  { channel=\"insteon:device:local:AABBCC:kwh\" }\n+    Switch iMeterUpdate  \"iMeter Update\"       { channel=\"insteon:device:local:AABBCC:update\" }\n+    Switch iMeterReset   \"iMeter Reset\"        { channel=\"insteon:device:local:AABBCC:reset\" }\n+```\n+\n+### Fan Controllers\n+\n+Here is an example configuration for a FanLinc module, which has a dimmable light and a variable speed fan:\n+\n+**Items**\n+\n+```\n+    Dimmer fanLincDimmer \"fanlinc dimmer [%d %%]\" { channel=\"insteon:device:local:AABBCC:lightDimmer\" }\n+    Number fanLincFan    \"fanlinc fan\"            { channel=\"insteon:device:local:AABBCC:fan\"}\n+```\n+\n+**Sitemap**\n+\n+```\n+    Slider item=fanLincDimmer switchSupport\n+    Switch item=fanLincFan label=\"fan speed\" mappings=[ 0=\"OFF\",  1=\"LOW\", 2=\"MEDIUM\", 3=\"HIGH\"]\n+```\n+\n+### X10 devices\n+\n+It is worth noting that both the Inseon PLM and the 2014 Hub can both command X10 devices over the powerline, and also set switch stats based on X10 signals received over the powerline.  This allows openHAB not only control X10 devices without the need for other hardwaare, but it can also have rules that react to incoming X10 powerline commands.  While you cannot bind the the X10 devices to the Insteon PLM/HUB, here are some examples for configuring X10 devices. Be aware that most X10 switches/dimmers send no status updates, i.e. openHAB will not learn about switches that are toggled manually. Further note that\n+X10 devices are addressed with `houseCode.unitCode`, e.g. `A.2`.\n+\n+**Items**\n+\n+```\n+    Switch x10Switch  \"X10 switch\" { channel=\"insteon:device:local:AABB:switch\" }\n+    Dimmer x10Dimmer  \"X10 dimmer\" { channel=\"insteon:device:local:AABB:dimmer\" }\n+    Contact x10Motion \"X10 motion\" { channel=\"insteon:device:local:AABB:contact\" }\n+```\n+\n+## Direct sending of group broadcasts (triggering scenes)\n+\n+The binding can command the modem to send broadcasts to a given Insteon group. Since it is a broadcast message, the corresponding item does *not* take the address of any device, but of the modem itself. The format is broadcastOnOff#X where X is the group that you want to be able to broadcast messages to:\n+\n+**Things**\n+\n+```\n+Bridge insteon:network:local      [port=\"/dev/ttyUSB0\"] {\n+  Thing device AABBCC             [address=\"AA.BB.CC\", productKey=\"0x000045\"] {\n+    Channels:\n+      Type switch : broadcastOnOff#2\n+  }\n+}\n+\n+```\n+\n+**Items**\n+\n+```\n+    Switch  broadcastOnOff \"group on/off\"  { channel=\"insteon:device:local:AABBCC:broadcastOnOff#2\" }\n+```\n+\n+Flipping this switch to \"ON\" will cause the modem to send a broadcast message with group=2, and all devices that are configured to respond to it should react.\n+\n+## 3-way switch configurations and the \"related\" keyword\n+\n+When an Insteon device changes its state because it is directly operated (for example by flipping a switch manually), it sends out a broadcast message to announce the state change, and the binding (if the PLM modem is properly linked as a responder) should update the corresponding openHAB items. Other linked devices however may also change their state in response, but those devices will *not* send out a broadcast message, and so openHAB will not learn about their state change until the next poll. One common scenario is e.g. a switch in a 3-way configuration, with one switch controlling the load, and the other switch being linked as a controller. In this scenario, the \"related\" keyword can be used to cause the binding to poll a related device whenever a state change occurs for another device. A typical example would be two dimmers (A and B) in a 3-way configuration:\n+\n+```\n+Bridge insteon:network:local [port=\"/dev/ttyUSB0\"] {\n+  Thing device AABBCC [address=\"AA.BB.CC\", productKey=\"F00.00.11\"] {\n+    Channels:\n+      Type dimmer : dimmer [related=\"AA.BB.DD\"]\n+  }\n+  Thing device AABBDD [address=\"AA.BB.DD\", productKey=\"F00.00.11\"] {\n+    Channels:\n+      Type dimmer : dimmer [related=\"AA.BB.CC\"]\n+  }\n+}\n+```\n+\n+More than one device can be polled by separating them with \"+\" sign, e.g. \"related=aa.bb.cc+xx.yy.zz\" would poll both of these devices. The implemenation of the *related* keyword is simple: if you add it to a channel, and that channel changes its state, then the *related* device will be polled to see if its state has updated.\n+\n+## Troubleshooting\n+\n+Turn on DEBUG or TRACE logging for `org.openhab.binding.insteon`. See [logging in openHAB](https://www.openhab.org/docs/administration/logging.html) for more info.\n+\n+### Device Permissions / Linux Device Locks\n+\n+When openHAB is running as a non-root user (Linux/OSX) it is important to ensure it has write access not just to the PLM device, but to the os lock directory. Under openSUSE this is `/run/lock` and is managed by the **lock** group. \n+\n+Example commands to grant openHAB access (adjust for your distribution):\n+\n+````\n+usermod -a -G dialout openhab\n+usermod -a -G lock openhab\n+````\n+\n+Insufficient access to the lock directory will result in openHAB failing to access the device, even if the device itself is writable.\n+\n+### Adding new device types (using existing device features)\n+\n+Device types are defined in the file `device_types.xml`, which is inside the Insteon bundle and thus not visible to the user. You can however load your own device_types.xml by referencing it in the network config parameters:\n+\n+    additionalDevices=\"/usr/local/openhab/rt/my_own_devices.xml\"\n+\n+Where the `my_own_devices.xml` file defines a new device like this:\n+\n+```xml\n+    <xml>\n+     <device productKey=\"F00.00.XX\">\n+      <model>2456-D3</model>\n+      <description>LampLinc V2</description>\n+      <feature name=\"dimmer\">GenericDimmer</feature>\n+      <feature name=\"lastheardfrom\">GenericLastTime</feature>\n+     </device>\n+    </xml>\n+```\n+\n+Finding the Insteon product key can be tricky since Insteon has not updated the product key table (http://www.insteon.com/pdf/insteon_devcats_and_product_keys_20081008.pdf) since 2008. If a web search does not turn up the product key, make one up, starting with \"F\", like: F00.00.99. Avoid duplicate keys by finding the highest fake product key in the `device_types.xml` file, and incrementing by one.\n+\n+### Adding new device features", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "04a9796d14dfbc5f3ff997d872f04b6d03ee411d"}, "originalPosition": 684}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTMxNjkzMg==", "bodyText": "Please remove this section - we do not add developer stuff in the README.", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r389316932", "createdAt": "2020-03-07T22:30:02Z", "author": {"login": "kaikreuzer"}, "path": "bundles/org.openhab.binding.insteon/README.md", "diffHunk": "@@ -0,0 +1,719 @@\n+# Insteon Binding\n+\n+Insteon is a home area networking technology developed primarily for connecting light switches and loads. Insteon devices send messages either via the power line, or by means of radio frequency (RF) waves, or both (dual-band). A considerable number of Insteon compatible devices such as switchable relays, thermostats, sensors etc are available. More about Insteon can be found on [Wikipedia](http://en.wikipedia.org/wiki/Insteon).\n+\n+This binding provides access to the Insteon network by means of either an Insteon PowerLinc Modem (PLM), a legacy Insteon Hub 2242-222 or the current 2245-222 Insteon Hub. The modem can be connected to the openHAB server either via a serial port (Model 2413S) or a USB port (Model 2413U). The Insteon PowerLinc Controller (Model 2414U) is not supported since it is a PLC not a PLM. The modem can also be connected via TCP (such as ser2net).  The binding translates openHAB commands into Insteon messages and sends them on the Insteon network. Relevant messages from the Insteon network (like notifications about switches being toggled) are picked up by the modem and converted to openHAB status updates by the binding. The binding also supports sending and receiving of legacy X10 messages.\n+\n+The binding does not support linking new devices on the fly, i.e. all devices must be linked with the modem *before* starting the Insteon binding.\n+\n+openHAB is not a configuration tool! To configure and set up your devices, link the devices manually via the set buttons, or use the free [Insteon Terminal](https://github.com/pfrommerd/insteon-terminal) software. The free HouseLinc software from Insteon can also be used for configuration, but it wipes the modem link database clean on its initial use, requiring to re-link the modem to all devices.\n+\n+## Supported Things\n+\n+| Thing  | Type   | Description                  |\n+|----------|--------|------------------------------|\n+| network  | Bridge | An insteon PLM or hub that is used to communicate with the Insteon devices |\n+|device| Thing | Insteon devices such as dimmers, keypads, sensors, etc. |\n+\n+## Discovery\n+\n+The binding will automatically add the network bridge called local to the Paper UI inbox. Upon proper configuration of the network bridge, the network device database will be downloaded. Any Insteon device that exists in the database and is not currently configured will get added to the inbox.  The naming convention is **Insteon Device AABBCC**, where AA, BB and CC are from the Insteon device address.  X10 devices are not auto discovered. \n+\n+## Thing Configuration\n+\n+###### Network Configuration\n+\n+The Insteon PLM or hub is configured with the following:\n+\n+| Parameter | Default | Required | Description |\n+|----------|---------:|--------:|-------------|\n+| port   |         |   Yes    | **Examples:**<br>- PLM on  Linux: `/dev/ttyS0` or `/dev/ttyUSB0`<br>- Smartenit ZBPLM on Linux: `/dev/ttyUSB0,baudRate=115200`<br>- PLM on Windows: `COM1`<br>- Current  hub (2245-222) at 192.168.1.100 on port 25105, with a poll interval of 1000 ms (1 second): `/hub2/my_user_name:my_password@192.168.1.100:25105,poll_time=1000`<br>- Legacy hub (2242-222) at 192.168.1.100 on port 9761:`/hub/192.168.1.100:9761`<br>- Networked PLM using ser2net at 192.168.1.100 on port 9761:`/tcp/192.168.1.100:9761` |\n+| devicePollIntervalSeconds | 300 |  No  | Poll interval of devices in seconds. Poll too often and you will overload the insteon network, leading to sluggish or no response when trying to send messages to devices. The default poll interval of 300 seconds has been tested and found to be a good compromise in a configuration of about 110 switches/dimmers. |\n+|modemDbRetryTimeoutSeconds|120|No|The number of seconds to wait for the modem database to completely download before retrying again.  Under normal circumstances this will not need to be modified.|\n+| additionalDevices | |       No     | Optional file with additional device types. The syntax of the file is identical to the `device_types.xml` file in the source tree. Please remember to post successfully added device types to the openhab group so the developers can include them into the `device_types.xml` file! |\n+| additionalFeatures | |      No     | Optional file with additional feature templates, like in the `device_features.xml` file in the source tree. |\n+\n+>NOTE: For users upgrading from InsteonPLM, The parameter port_1 is now port. \n+\n+###### Device Configuration\n+\n+The Insteon device is configured with the following required parameters:\n+\n+| Parameter | Description |\n+|----------|-------------|\n+|address|Insteon or X10 address of the device. Insteon device addresses are in the format 'xx.xx.xx', and can be found on the device. X10 device address are in the format 'x.y' and are typically configured on the device.|\n+|productKey|Insteon binding product key that is used to identy the device. Every Insteon device type is uniquely identified by its Insteon product key, typically a six digit hex number. For some of the older device types (in particular the SwitchLinc switches and dimmers), Insteon does not give a product key, so an arbitrary fake one of the format Fxx.xx.xx (or Xxx.xx.xx for X10 devices) is assigned by the binding.|\n+\n+The following is a list of the product keys and associated devices. These have been tested and should work out of the box:\n+\n+| Model | Description | Product Key | tested by |\n+|-------|-------------|-------------|-----------|\n+| 2477D | SwitchLinc Dimmer | F00.00.01 | Bernd Pfrommer |\n+| 2477S | SwitchLinc Switch | F00.00.02 | Bernd Pfrommer |\n+| 2845-222 | Hidden Door Sensor | F00.00.03 | Josenivaldo Benito |\n+| 2876S | ICON Switch | F00.00.04 | Patrick Giasson |\n+| 2456D3 | LampLinc V2 | F00.00.05 | Patrick Giasson |\n+| 2442-222 | Micro Dimmer | F00.00.06 | Josenivaldo Benito |\n+| 2453-222 | DIN Rail On/Off | F00.00.07 | Josenivaldo Benito |\n+| 2452-222 | DIN Rail Dimmer | F00.00.08 | Josenivaldo Benito |\n+| 2458-A1 | MorningLinc RF Lock Controller | F00.00.09 | cdeadlock |\n+| 2852-222 | Leak Sensor | F00.00.0A | Kirk McCann |\n+| 2672-422 | LED Dimmer | F00.00.0B | ??? |\n+| 2476D | SwitchLinc Dimmer | F00.00.0C | LiberatorUSA |\n+| 2634-222 | On/Off Dual-Band Outdoor Module | F00.00.0D | LiberatorUSA |\n+| 2342-2 | Mini Remote | F00.00.10 | Bernd Pfrommer |\n+| 2663-222 | On/Off Outlet | 0x000039 | SwissKid |\n+| 2466D | ToggleLinc Dimmer | F00.00.11 | Rob Nielsen |\n+| 2466S | ToggleLinc Switch | F00.00.12 | Rob Nielsen |\n+| 2672-222 | LED Bulb | F00.00.13 | Rob Nielsen |\n+| 2487S | KeypadLinc On/Off 6-Button | F00.00.14 | Bernd Pfrommer |\n+| 2334-232 | KeypadLink Dimmer 6-Button | F00.00.15 | Rob Nielsen |\n+| 2334-232 | KeypadLink Dimmer 8-Button | F00.00.16 | Rob Nielsen |\n+| 2423A1 | iMeter Solo Power Meter | F00.00.17 | Rob Nielsen |\n+| 2423A1 | Thermostat 2441TH | F00.00.18 | Daniel Campbell, Bernd Pfrommer |\n+| 2457D2 | LampLinc Dimmer | F00.00.19 | Jonathan Huizingh |\n+| 2475SDB | In-LineLinc Relay | F00.00.1A | Jim Howard |\n+| 2635-222 | On/Off Module | F00.00.1B | Jonathan Huizingh |\n+| 2475F | FanLinc Module | F00.00.1C | Brian Tillman |\n+| 2456S3 | ApplianceLinc | F00.00.1D | ??? |\n+| 2674-222 | LED Bulb (recessed) | F00.00.1E | Steve Bate |\n+| 2477SA1 | 220V 30-amp Load Controller N/O | F00.00.1F | Shawn R. |\n+| 2342-222 | Mini Remote (8 Button) | F00.00.20 | Bernd Pfrommer |\n+| 2441V | Insteon Thermostat Adaptor for Venstar | F00.00.21 | Bernd Pfrommer |\n+| 2982-222 | Insteon Smoke Bridge | F00.00.22 | Bernd Pfrommer |\n+| 2450 | IO Link | 0x00001A | Bernd Pfrommer |\n+| 2486D | KeypadLinc Dimmer | 0x000037 | Patrick Giasson, Joe Barnum |\n+| 2484DWH8 | KeypadLinc Countdown Timer | 0x000041 | Rob Nielsen |\n+| 2413U | PowerLinc 2413U USB modem | 0x000045 | Bernd Pfrommer |\n+| 2843-222 | Wireless Open/Close Sensor | 0x000049 | Josenivaldo Benito |\n+| 2842-222 | Motion Sensor | 0x00004A | Bernd Pfrommer |\n+| 2486DWH8 | KeypadLinc Dimmer | 0x000051 | Chris Graham |\n+| 2472D | OutletLincDimmer | 0x000068 | Chris Graham |\n+| X10 switch | generic X10 switch | X00.00.01 | Bernd Pfrommer |\n+| X10 dimmer | generic X10 dimmer | X00.00.02 | Bernd Pfrommer |\n+| X10 motion | generic X10 motion sensor | X00.00.03 | Bernd Pfrommer |\n+\n+## Channels\n+\n+Below is the list of possible channels for the Insteon devices. In order to determing which channels a device supports, you can either look at the device in Paper UI, or find it in the openhab log file.\n+\n+| channel  | type   | description                  |\n+|----------|--------|------------------------------|\n+| acDelay | Number | AC Delay |\n+| backlightDuration | Number | Back Light Duration |\n+| batteryLevel | Number | Battery Level |\n+| batteryWatermarkLevel | Number | Battery Watermark Level |\n+| bottomOutlet | Switch | Bottom Outlet |\n+| buttonA | Switch | Button A |\n+| buttonB | Switch | Button B |\n+| buttonC | Switch | Button C |\n+| buttonD | Switch | Button D |\n+| buttonE | Switch | Button E |\n+| buttonF | Switch | Button F |\n+| buttonG | Switch | Button G |\n+| buttonH | Switch | Button H |\n+| broadcastOnOff | Switch | Broadcast On/Off |\n+| contact | Contact | Contact |\n+| coolSetPoint | Number | Cool Set Point |\n+| dimmer | Dimmer | Dimmer |\n+| fan | Number | Fan |\n+| fanMode | Number | Fan Mode |\n+| fastOnOff | Switch | Fast On/Off |\n+| fastOnOffButtonA | Switch | Fast On/Off Button A |\n+| fastOnOffButtonB | Switch | Fast On/Off Button B |\n+| fastOnOffButtonC | Switch | Fast On/Off Button C |\n+| fastOnOffButtonD | Switch | Fast On/Off Button D |\n+| heatSetPoint | Number | Heat Set Point |\n+| humidity | Number | Humidity |\n+| humidityHigh | Number | Humidity High |\n+| humidityLow | Number | Humidity Low |\n+| isCooling | Number | Is Cooling |\n+| isHeating | Number | Is Heating |\n+| keypadButtonA | Switch | Keypad Button A |\n+| keypadButtonB | Switch | Keypad Button B |\n+| keypadButtonC | Switch | Keypad Button C |\n+| keypadButtonD | Switch | Keypad Button D |\n+| keypadButtonE | Switch | Keypad Button E |\n+| keypadButtonF | Switch | Keypad Button F |\n+| keypadButtonG | Switch | Keypad Button G |\n+| keypadButtonH | Switch | Keypad Button H |\n+| kWh | Number | Kilowatt Hour |\n+| lastHeardFrom | DateTime | Last Heard From |\n+| ledBrightness | Number | LED brightness |\n+| lightDimmer | Dimmer | light Dimmer |\n+| lightLevel | Number | Light Level |\n+| loadDimmer | Dimmer | Load Dimmer |\n+| loadSwitch | Switch | Load Switch |\n+| loadSwitchFastOnOff | Switch | Load Switch Fast On/Off |\n+| loadSwitchManualChange | Number | Load Switch Manual Change |\n+| manualChange | Number | Manual Change |\n+| manualChangeButtonA | Number | Manual Change Button A |\n+| manualChangeButtonB | Number | Manual Change Button B |\n+| manualChangeButtonC | Number | Manual Change Button C |\n+| manualChangeButtonD | Number | Manual Change Button D |\n+| notification | Number | Notification |\n+| onLevel | Number | On Level |\n+| rampDimmer | Dimmer | Ramp Dimmer |\n+| rampRate | Number | Ramp Rate |\n+| reset | Switch | Reset |\n+| stage1Duration | Number | Stage 1 Duration |\n+| switch | Switch | Switch |\n+| systemMode | Number | System Mode |\n+| tempCelsius | Number | Temperature Celsius |\n+| tempFahrenheit | Number | Temperature Fahrenheit |\n+| topOutlet | Switch | Top Outlet |\n+| update | Switch | Update |\n+| watts | Number | Watts |\n+\n+\n+## Full Example\n+\n+Sample things file:\n+\n+```\n+Bridge insteon:network:local [port=\"/dev/ttyUSB0\"] {\n+  Thing device 22F8A8 [address=\"22.F8.A8\", productKey=\"F00.00.15\"] {\n+    Channels:\n+      Type switch : keypadButtonA [ group=3 ]\n+      Type switch : keypadButtonB [ group=4 ]\n+      Type switch : keypadButtonC [ group=5 ]\n+      Type switch : keypadButtonD [ group=6 ]\n+  }\n+  Thing device 238D93 [address=\"23.8D.93\", productKey=\"F00.00.12\"]\n+  Thing device 238F55 [address=\"23.8F.55\", productKey=\"F00.00.11\"] {\n+    Channels:\n+      Type dimmer : dimmer [related=\"23.B0.D9+23.8F.C9\"]\n+  }\n+  Thing device 238FC9 [address=\"23.8F.C9\", productKey=\"F00.00.11\"] {\n+    Channels:\n+      Type dimmer : dimmer [related=\"23.8F.55+23.B0.D9\"]\n+  }\n+  Thing device 23B0D9 [address=\"23.B0.D9\", productKey=\"F00.00.11\"] {\n+    Channels:\n+      Type dimmer : dimmer [related=\"23.8F.55+23.8F.C9\"]\n+  }\n+  Thing device 243141 [address=\"24.31.41\", productKey=\"F00.00.11\"]  {\n+    Channels:\n+      Type dimmer : dimmer [dimmermax=60]\n+  }\n+}\n+```\n+\n+Sample items file:\n+\n+```\n+Switch switch1 { channel=\"insteon:device:local:243141:switch\" }\n+Dimmer dimmer1 { channel=\"insteon:device:local:238F55:dimmer\" }\n+Dimmer dimmer2 { channel=\"insteon:device:local:23B0D9:dimmer\" }\n+Dimmer dimmer3 { channel=\"insteon:device:local:238FC9:dimmer\" }\n+Dimmer keypad  { channel=\"insteon:device:local:22F8A8:loadDimmer\" }\n+Switch keypadA { channel=\"insteon:device:local:22F8A8:keypadButtonA\" }\n+Switch keypadB { channel=\"insteon:device:local:22F8A8:keypadButtonB\" }\n+Switch keypadC { channel=\"insteon:device:local:22F8A8:keypadButtonC\" }\n+Switch keypadD { channel=\"insteon:device:local:22F8A8:keypadButtonD\" }\n+Dimmer dimmer  { channel=\"insteon:device:local:238D93:dimmer\" }\n+```\n+\n+## Insteon Groups and Scenes\n+\n+How do Insteon devices tell other devices on the network that their state has changed? They send out a broadcast message, labeled with a specific *group* number. All devices (called *responders*) that are configured to listen to this message will then go into a pre-defined state. For instance when light switch A is switched to \"ON\", it will send out a message to group #1, and all responders will react to it, e.g they may go into the \"ON\" position as well. Since more than one device can participate, the sending out of the broadcast message and the subsequent state change of the responders is referred to as \"triggering a scene\". At the device and PLM level, the concept of a \"scene\" does not exist, so you will find it notably absent in the binding code and this document. A scene is strictly a higher level concept, introduced to shield the user from the details of how the communication is implemented.\n+\n+Many Insteon devices send out messages on different group numbers, depending on what happens to them. A leak sensor may send out a message on group #1 when dry, and on group #2 when wet. The default group used for e.g. linking two light switches is usually group #1.\n+\n+## Insteon binding process\n+\n+Before Insteon devices communicate with one another, they must be linked. During the linking process, one of the devices will be the \"Controller\", the other the \"Responder\" (see e.g. the [SwitchLinc Instructions](https://www.insteon.com/pdf/2477S.pdf)).\n+\n+The responder listens to messages from the controller, and reacts to them. Note that except for the case of a motion detector (which is just a controller to the modem), the modem controls the device (e.g. send on/off messages to it), and the device controls the modem (so the modem learns about the switch being toggled). For this reason, most devices and in particular switches/dimmers should be linked twice, with one taking the role of controller during the first linking, and the other acting as controller during the second linking process. To do so, first press and hold the \"Set\" button on the modem until the light starts blinking. Then press and hold the \"Set\" button on the remote device,\n+e.g. the light switch, until it double beeps (the light on the modem should go off as well). Now do exactly the reverse: press and hold the \"Set\" button on the remote device until its light starts blinking, then press and hold the \"Set\" button on the modem until it double beeps, and the light of the remote device (switch) goes off. Done.\n+\n+For some of the more sophisticated devices the complete linking process can no longer be done with the set buttons, but requires software like e.g. [Insteon Terminal](https://github.com/pfrommerd/insteon-terminal).\n+\n+## Insteon Features\n+\n+Since Insteon devices can have multiple features (for instance a switchable relay and a contact sensor) under a single Insteon address, an openHAB item is not bound to a device, but to a given feature of a device. For example, the following lines would create two Number items referring to the same thermostat device, but to different features of it:\n+\n+```\n+Number  thermostatCoolPoint \"cool point [%.1f \u00b0F]\" { channel=\"insteon:device:local:32F422:coolSetPoint\" }\n+Number  thermostatHeatPoint \"heat point [%.1f \u00b0F]\" { channel=\"insteon:device:local:32F422:heatSetPoint\" }\n+```\n+\n+### Simple light switches\n+\n+The following example shows how to configure a simple light switch (2477S) in the .items file:\n+\n+```\n+Switch officeLight \"office light\"  { channel=\"insteon:device:local:AABBCC:switch\" }\n+```\n+\n+### Simple dimmers\n+\n+Here is how to configure a simple dimmer (2477D) in the .items file:\n+\n+```\n+Dimmer kitchenChandelier \"kitchen chandelier\" { channel=\"insteon:device:local:AABBCC:dimmer\" }\n+```\n+\n+Dimmers can be configured with a maximum level when turning a device on or setting a percentage level. If a maximum level is configured, openHAB will never set the level of the dimmer above the level specified. The parameter dimmermax must be defined for the channel. The below example sets a maximum level of 70% for dim 1 and 60% for dim 2:\n+\n+**Things**\n+\n+```\n+Bridge insteon:network:local [port=\"/dev/ttyUSB0\"] {\n+  Thing device AABBCC [address=\"AA.BB.CC\", productKey=\"F00.00.11\"]  {\n+    Channels:\n+      Type dimmer : dimmer [dimmermax=70]\n+  }\n+  Thing device AABBCD [address=\"AA.BB.CD\", productKey=\"F00.00.15\"]  {\n+    Channels:\n+      Type dimmer : loadDimmer [dimmermax=60]\n+  }\n+}\n+```\n+\n+**Items**\n+\n+```\n+Dimmer d1 \"dimmer 1\" { channel=\"insteon:device:local:AABBCC:dimmer\"}\n+Dimmer d2 \"dimmer 2\" { channel=\"insteon:device:local:AABBCD:loadDimmer\"}\n+```\n+\n+Setting a maximum level does not affect manual turning on or dimming a switch.\n+\n+### On/Off Outlets\n+\n+Here's how to configure the top and bottom outlet of the in-wall 2 outlet controller:\n+\n+```\n+Switch fOutTop \"Front Outlet Top\"    <socket> { channel=\"insteon:device:local:AABBCC:topOutlet\" }\n+Switch fOutBot \"Front Outlet Bottom\" <socket> { channel=\"insteon:device:local:AABBCC:bottomOutlet\" }\n+```\n+\n+This will give you individual control of each outlet.\n+    \n+### Mini remotes\n+\n+Link the mini remote to be a controller of the modem by using the set button. Link all buttons, one after the other. The 4-button mini remote sends out messages on groups 0x01 - 0x04, each corresponding to one button. The modem's link database (see [Insteon Terminal](https://github.com/pfrommerd/insteon-terminal)) should look like this:\n+\n+```\n+    0000 xx.xx.xx                       xx.xx.xx  RESP  10100010 group: 01 data: 02 2c 41\n+    0000 xx.xx.xx                       xx.xx.xx  RESP  10100010 group: 02 data: 02 2c 41\n+    0000 xx.xx.xx                       xx.xx.xx  RESP  10100010 group: 03 data: 02 2c 41\n+    0000 xx.xx.xx                       xx.xx.xx  RESP  10100010 group: 04 data: 02 2c 41\n+```\n+\n+**Items**\n+This goes into the items file:\n+\n+```\n+    Switch miniRemoteButtonA \"mini remote button a\" { channel=\"insteon:device:local:AABBCC:buttonA\", autoupdate=\"false\" }\n+    Switch miniRemoteButtonB \"mini remote button b\" { channel=\"insteon:device:local:AABBCC:buttonB\", autoupdate=\"false\" }\n+    Switch miniRemoteButtonC \"mini remote button c\" { channel=\"insteon:device:local:AABBCC:buttonC\", autoupdate=\"false\" }\n+    Switch miniRemoteButtonD \"mini remote button d\" { channel=\"insteon:device:local:AABBCC:buttonD\", autoupdate=\"false\" }\n+```\n+\n+**Sitemap**\n+This goes into the sitemap file:\n+\n+```\n+    Switch item=miniRemoteButtonA label=\"mini remote button a\" mappings=[ OFF=\"Off\", ON=\"On\"]\n+    Switch item=miniRemoteButtonB label=\"mini remote button b\" mappings=[ OFF=\"Off\", ON=\"On\"]\n+    Switch item=miniRemoteButtonC label=\"mini remote button c\" mappings=[ OFF=\"Off\", ON=\"On\"]\n+    Switch item=miniRemoteButtonD label=\"mini remote button d\" mappings=[ OFF=\"Off\", ON=\"On\"]\n+```\n+\n+The switches in the GUI just display the mini remote's most recent button presses. They are not operable because the PLM cannot trigger the mini remotes scenes.\n+\n+### Motion sensors\n+\n+Link such that the modem is a responder to the motion sensor. Create a contact.map file in the transforms directory as described elsewhere in this document. Then create entries in the .items file like this:\n+\n+**Items**\n+\n+```\n+    Contact motionSensor             \"motion sensor [MAP(contact.map):%s]\" { channel=\"insteon:device:local:AABBCC:contact\"}\n+    Number  motionSensorBatteryLevel \"motion sensor battery level [%.1f]\"  { channel=\"insteon:device:local:AABBCC:batteryLevel\" }\n+    Number  motionSensorLightLevel   \"motion sensor light level [%.1f]\"    { channel=\"insteon:device:local:AABBCC:lightLevel\" }\n+```\n+\n+This will give you a contact, the battery level, and the light level. Note that battery and light level are only updated when either there is motion, or the sensor battery runs low.\n+\n+### Hidden door sensors\n+\n+Similar in operation to the motion sensor above.  Link such that the modem is a responder to the motion sensor. Create a contact.map file in the transforms directory like the following:\n+\n+```\n+    OPEN=open\n+    CLOSED=closed\n+    -=unknown\n+```\n+\n+**Items**\n+Then create entries in the .items file like this:\n+\n+```\n+    Contact doorSensor             \"Door sensor [MAP(contact.map):%s]\" { channel=\"insteon:device:local:AABBCC:contact\" }\n+    Number  doorSensorBatteryLevel \"Door sensor battery level [%.1f]\"  { channel=\"insteon:device:local:AABBCC:batteryLevel\" }\n+```\n+\n+This will give you a contact and the battery level. Note that battery level is only updated when either there is motion, or the sensor battery runs low.\n+\n+### Locks\n+\n+Read the instructions very carefully: sync with lock within 5 feet to avoid bad connection, link twice for both ON and OFF functionality.\n+\n+**Items**\n+Put something like this into your .items file:\n+\n+```\n+    Switch doorLock \"Front Door [MAP(lock.map):%s]\"  { channel=\"insteon:device:local:AABBCC:switch\" }\n+```\n+\n+and create a file \"lock.map\" in the transforms directory with these entries: \n+\n+```\n+    ON=Lock\n+    OFF=Unlock\n+    -=unknown\n+```\n+\n+### I/O Linc (garage door openers)\n+\n+The I/O Linc devices are really two devices in one: a relay and a contact. Link the modem both ways, as responder and controller using the set buttons as described in the instructions.\n+\n+Add this map into your transforms directory as \"contact.map\":\n+\n+```\n+    OPEN=open\n+    CLOSED=closed\n+    -=unknown\n+```\n+\n+**Items**\n+Along with this into your .items file:\n+\n+```\n+    Switch  garageDoorOpener  \"garage door opener\"                        <garagedoor>  { channel=\"insteon:device:local:AABBCC:switch\", autoupdate=\"false\" }\n+    Contact garageDoorContact \"garage door contact [MAP(contact.map):%s]\"               { channel=\"insteon:device:local:AABBCC:contact\" }\n+```\n+\n+**Sitemap**\n+To make it visible in the GUI, put this into your sitemap file:\n+\n+```\n+    Switch item=garageDoorOpener label=\"garage door opener\" mappings=[ ON=\"OPEN/CLOSE\"]\n+    Text item=garageDoorContact\n+```\n+\n+For safety reasons, only close the garage door if you have visual contact to make sure there is no obstruction! The use of automated rules for closing garage doors is dangerous.\n+\n+> NOTE: If the I/O Linc returns the wrong value when the device is polled (For example you open the garage door and the state correctly shows OPEN, but during polling it shows CLOSED), you probably linked the device with the PLM or hub when the door was in the wrong position. You need unlink and then link again with the door in the opposite position. Please see the Insteon I/O Linc documentation for further details.\n+\n+### Keypads\n+\n+Before you attempt to configure the keypads, please familiarize yourself with the concept of an Insteon group.\n+\n+The Insteon keypad devices typically control one main load and have a number of buttons that will send out group broadcast messages to trigger a scene. If you just want to use the main load switch within openhab just link modem and device with the set buttons as usual, no complicated linking is necessary. But if you want to get the buttons to work, read on.\n+\n+Each button will send out a message for a different, predefined group. Complicating matters further, the button numbering used internally by the device must be mapped to whatever labels are printed on the physical buttons of the device. Here is an example correspondence table:\n+\n+| Group | Button Number | 2487S Label |\n+|-------|---------------|-------------|\n+|  0x01 |        1      |   (Load)    |\n+|  0x03 |        3      |     A       |\n+|  0x04 |        4      |     B       |\n+|  0x05 |        5      |     C       |\n+|  0x06 |        6      |     D       |\n+\n+When e.g. the \"A\" button is pressed (that's button #3 internally) a broadcast message will be sent out to all responders configured to listen to Insteon group #3. This means you must configure the modem as a responder to group #3 (and #4, #5, #6) messages coming from your keypad. For instructions how to do this, check out the [Insteon Terminal](https://github.com/pfrommerd/insteon-terminal). You can even do that with the set buttons (see instructions that come with the keypad).\n+\n+While capturing the messages that the buttons emit is pretty straight forward, controlling the buttons is  another matter. They cannot be simply toggled with a direct command to the device, but instead a broadcast message must be sent on a group number that the button has been programmed to listen to. This means you need to pick a set of unused groups that is globally unique (if you have multiple keypads, each one of them has to use different groups), one group for each button. The example configuration below uses groups 0xf3, 0xf4, 0xf5, and 0xf6. Then link the buttons such that they respond to those groups, and link the modem as a controller for them (see [Insteon Terminal](https://github.com/pfrommerd/insteon-terminal) documentation). In your items file you specify these groups with the \"group=\" parameters such that the binding knows what group number to put on the outgoing message.\n+\n+\n+#### Keypad switches\n+\n+**Items**\n+\n+Here is a simple example, just using the load (main) switch:\n+\n+```\n+    Switch keypadSwitch             \"main load\"          { channel=\"insteon:device:local:AABBCC:loadSwitch\" }\n+    Number keypadSwitchManualChange \"main manual change\" { channel=\"insteon:device:local:AABBCC:loadSwitchManualChange\" }\n+    Switch keypadSwitchFastOnOff    \"main fast on/off\"   { channel=\"insteon:device:local:AABBCC:loadSwitchFastOnOff\" }\n+```\n+\n+Most people will not use the fast on/off features or the manual change feature, so you really only need the first line. To make the buttons available, add the following:\n+\n+**Things**\n+\n+```\n+Bridge insteon:network:local [port=\"/dev/ttyUSB0\"] {\n+  Thing device AABBCC [address=\"AA.BB.CC\", productKey=\"F00.00.15\"] {\n+    Channels:\n+      Type switch : keypadButtonA [ group=\"0xf3\" ]\n+      Type switch : keypadButtonB [ group=\"0xf4\" ]\n+      Type switch : keypadButtonC [ group=\"0xf5\" ]\n+      Type switch : keypadButtonD [ group=\"0xf6\" ]\n+  }\n+}\n+```\n+\n+The value after group must either be a number or string. The hexadecimal value 0xf3 can either converted to a numeric value 243 or the string value \"0xf3\".\n+\n+**Items**\n+\n+```\n+    Switch keypadSwitchA \"keypad button A\" { channel=\"insteon:device:local:AABBCC:keypadButtonA\"}\n+    Switch keypadSwitchB \"keypad button B\" { channel=\"insteon:device:local:AABBCC:keypadButtonB\"}\n+    Switch keypadSwitchC \"keypad button C\" { channel=\"insteon:device:local:AABBCC:keypadButtonC\"}\n+    Switch keypadSwitchD \"keypad button D\" { channel=\"insteon:device:local:AABBCC:keypadButtonD\"}\n+```\n+\n+**Sitemap**\n+\n+The following sitemap will bring the items to life in the GUI:\n+\n+```\n+    Frame label=\"Keypad\" {\n+          Switch item=keypadSwitch label=\"main\"\n+          Switch item=keypadSwitchFastOnOff label=\"fast on/off\"\n+          Switch item=keypadSwitchManualChange label=\"manual change\" mappings=[ 0=\"DOWN\", 1=\"STOP\",  2=\"UP\"]\n+          Switch item=keypadSwitchA label=\"button A\"\n+          Switch item=keypadSwitchB label=\"button B\"\n+          Switch item=keypadSwitchC label=\"button C\"\n+          Switch item=keypadSwitchD label=\"button D\"\n+    }\n+```\n+\n+#### Keypad dimmers\n+\n+The keypad dimmers are like keypad switches, except that the main load is dimmable.\n+\n+**Items**\n+\n+```\n+    Dimmer keypadDimmer           \"dimmer\"                          { channel=\"insteon:device:local:AABBCC:loadDimmer\" }\n+    Switch keypadDimmerButtonA    \"keypad dimmer button A [%d %%]\"  { channel=\"insteon:device:local:AABBCC:keypadButtonA\" }\n+```\n+\n+**Sitemap**\n+\n+```\n+    Slider item=keypadDimmer switchSupport\n+    Switch item=keypadDimmerButtonA label=\"buttonA\"\n+```\n+\n+### Thermostats\n+\n+The thermostat (2441TH) is one of the most complex Insteon devices available. It must first be properly linked to the modem using configuration software like [Insteon Terminal](https://github.com/pfrommerd/insteon-terminal). The Insteon Terminal wiki describes in detail how to link the thermostat, and how to make it publish status update reports.\n+\n+When all is set and done the modem must be configured as a controller to group 0 (not sure why), and a responder to groups 1-5 such that it picks up when the thermostat switches on/off heating and cooling etc, and it must be a responder to special group 0xEF to get status update reports when measured values (temperature) change. Symmetrically, the thermostat must be a responder to group 0, and a controller for groups 1-5 and 0xEF. The linking process is not difficult but needs some persistence. Again, refer to the [Insteon Terminal](https://github.com/pfrommerd/insteon-terminal) documentation.\n+\n+**Items**\n+\n+This is an example of what to put into your .items file:\n+\n+```\n+    Number  thermostatCoolPoint   \"cool point [%.1f \u00b0F]\"  { channel=\"insteon:device:local:AABBCC:coolSetPoint\" }\n+    Number  thermostatHeatPoint   \"heat point [%.1f \u00b0F]\"  { channel=\"insteon:device:local:AABBCC:heatSetPoint\" }\n+    Number  thermostatSystemMode  \"system mode [%d]\"      { channel=\"insteon:device:local:AABBCC:systemMode\" }\n+    Number  thermostatFanMode     \"fan mode [%d]\"         { channel=\"insteon:device:local:AABBCC:fanMode\" }\n+    Number  thermostatIsHeating   \"is heating [%d]\"       { channel=\"insteon:device:local:AABBCC:isHeating\"}\n+    Number  thermostatIsCooling   \"is cooling [%d]\"       { channel=\"insteon:device:local:AABBCC:isCooling\" }\n+    Number  thermostatTempFahren  \"temperature [%.1f \u00b0F]\" { channel=\"insteon:device:local:AABBCC:tempFahrenheit\" }\n+    Number  thermostatTempCelsius \"temperature [%.1f \u00b0C]\" { channel=\"insteon:device:local:AABBCC:tempCelsius\" }\n+    Number  thermostatHumidity    \"humidity [%.0f %%]\"    { channel=\"insteon:device:local:AABBCC:humidity\" }\n+```\n+\n+Add this as well for some more exotic features:\n+\n+```\n+    Number  thermostatACDelay      \"A/C delay [%d min]\"        { channel=\"insteon:device:local:AABBCC:acDelay\" }\n+    Number  thermostatBacklight    \"backlight [%d sec]\"        { channel=\"insteon:device:local:AABBCC:backlightDuration\" }\n+    Number  thermostatStage1       \"A/C stage 1 time [%d min]\" { channel=\"insteon:device:local:AABBCC:stage1Duration\" }\n+    Number  thermostatHumidityHigh \"humidity high [%d %%]\"     { channel=\"insteon:device:local:AABBCC:humidityHigh\" }\n+    Number  thermostatHumidityLow  \"humidity low [%d %%]\"      { channel=\"insteon:device:local:AABBCC:humidityLow\" }\n+```\n+\n+**Sitemap**\n+\n+For the thermostat to display in the GUI, add this to the sitemap file:\n+\n+```\n+    Text   item=thermostatTempCelsius icon=\"temperature\"\n+    Text   item=thermostatTempFahren icon=\"temperature\"\n+    Text   item=thermostatHumidity\n+    Setpoint item=thermostatCoolPoint icon=\"temperature\" minValue=63 maxValue=90 step=1\n+    Setpoint item=thermostatHeatPoint icon=\"temperature\" minValue=50 maxValue=80 step=1\n+    Switch item=thermostatSystemMode  label=\"system mode\" mappings=[ 0=\"OFF\",  1=\"HEAT\", 2=\"COOL\", 3=\"AUTO\", 4=\"PROGRAM\"]\n+    Switch item=thermostatFanMode  label=\"fan mode\" mappings=[ 0=\"AUTO\",  1=\"ALWAYS ON\"]\n+    Switch item=thermostatIsHeating  label=\"is heating\" mappings=[ 0=\"OFF\",  1=\"HEATING\"]\n+    Switch item=thermostatIsCooling  label=\"is cooling\" mappings=[ 0=\"OFF\",  1=\"COOLING\"]\n+    Setpoint item=thermostatACDelay  minValue=2 maxValue=20 step=1\n+    Setpoint item=thermostatBacklight  minValue=0 maxValue=100 step=1\n+    Setpoint item=thermostatHumidityHigh  minValue=0 maxValue=100 step=1\n+    Setpoint item=thermostatHumidityLow   minValue=0 maxValue=100 step=1\n+    Setpoint item=thermostatStage1  minValue=1 maxValue=60 step=1\n+```\n+\n+### Power Meters\n+\n+The iMeter Solo reports both wattage and kilowatt hours, and is updated during the normal polling process of the devices. You can also manually update the current values from the device and reset the device. See the example below:\n+\n+**Items**\n+\n+``` \n+    Number iMeterWatts   \"iMeter [%d watts]\"   { channel=\"insteon:device:local:AABBCC:watts\" }\n+    Number iMeterKwh     \"iMeter [%.04f kwh]\"  { channel=\"insteon:device:local:AABBCC:kwh\" }\n+    Switch iMeterUpdate  \"iMeter Update\"       { channel=\"insteon:device:local:AABBCC:update\" }\n+    Switch iMeterReset   \"iMeter Reset\"        { channel=\"insteon:device:local:AABBCC:reset\" }\n+```\n+\n+### Fan Controllers\n+\n+Here is an example configuration for a FanLinc module, which has a dimmable light and a variable speed fan:\n+\n+**Items**\n+\n+```\n+    Dimmer fanLincDimmer \"fanlinc dimmer [%d %%]\" { channel=\"insteon:device:local:AABBCC:lightDimmer\" }\n+    Number fanLincFan    \"fanlinc fan\"            { channel=\"insteon:device:local:AABBCC:fan\"}\n+```\n+\n+**Sitemap**\n+\n+```\n+    Slider item=fanLincDimmer switchSupport\n+    Switch item=fanLincFan label=\"fan speed\" mappings=[ 0=\"OFF\",  1=\"LOW\", 2=\"MEDIUM\", 3=\"HIGH\"]\n+```\n+\n+### X10 devices\n+\n+It is worth noting that both the Inseon PLM and the 2014 Hub can both command X10 devices over the powerline, and also set switch stats based on X10 signals received over the powerline.  This allows openHAB not only control X10 devices without the need for other hardwaare, but it can also have rules that react to incoming X10 powerline commands.  While you cannot bind the the X10 devices to the Insteon PLM/HUB, here are some examples for configuring X10 devices. Be aware that most X10 switches/dimmers send no status updates, i.e. openHAB will not learn about switches that are toggled manually. Further note that\n+X10 devices are addressed with `houseCode.unitCode`, e.g. `A.2`.\n+\n+**Items**\n+\n+```\n+    Switch x10Switch  \"X10 switch\" { channel=\"insteon:device:local:AABB:switch\" }\n+    Dimmer x10Dimmer  \"X10 dimmer\" { channel=\"insteon:device:local:AABB:dimmer\" }\n+    Contact x10Motion \"X10 motion\" { channel=\"insteon:device:local:AABB:contact\" }\n+```\n+\n+## Direct sending of group broadcasts (triggering scenes)\n+\n+The binding can command the modem to send broadcasts to a given Insteon group. Since it is a broadcast message, the corresponding item does *not* take the address of any device, but of the modem itself. The format is broadcastOnOff#X where X is the group that you want to be able to broadcast messages to:\n+\n+**Things**\n+\n+```\n+Bridge insteon:network:local      [port=\"/dev/ttyUSB0\"] {\n+  Thing device AABBCC             [address=\"AA.BB.CC\", productKey=\"0x000045\"] {\n+    Channels:\n+      Type switch : broadcastOnOff#2\n+  }\n+}\n+\n+```\n+\n+**Items**\n+\n+```\n+    Switch  broadcastOnOff \"group on/off\"  { channel=\"insteon:device:local:AABBCC:broadcastOnOff#2\" }\n+```\n+\n+Flipping this switch to \"ON\" will cause the modem to send a broadcast message with group=2, and all devices that are configured to respond to it should react.\n+\n+## 3-way switch configurations and the \"related\" keyword\n+\n+When an Insteon device changes its state because it is directly operated (for example by flipping a switch manually), it sends out a broadcast message to announce the state change, and the binding (if the PLM modem is properly linked as a responder) should update the corresponding openHAB items. Other linked devices however may also change their state in response, but those devices will *not* send out a broadcast message, and so openHAB will not learn about their state change until the next poll. One common scenario is e.g. a switch in a 3-way configuration, with one switch controlling the load, and the other switch being linked as a controller. In this scenario, the \"related\" keyword can be used to cause the binding to poll a related device whenever a state change occurs for another device. A typical example would be two dimmers (A and B) in a 3-way configuration:\n+\n+```\n+Bridge insteon:network:local [port=\"/dev/ttyUSB0\"] {\n+  Thing device AABBCC [address=\"AA.BB.CC\", productKey=\"F00.00.11\"] {\n+    Channels:\n+      Type dimmer : dimmer [related=\"AA.BB.DD\"]\n+  }\n+  Thing device AABBDD [address=\"AA.BB.DD\", productKey=\"F00.00.11\"] {\n+    Channels:\n+      Type dimmer : dimmer [related=\"AA.BB.CC\"]\n+  }\n+}\n+```\n+\n+More than one device can be polled by separating them with \"+\" sign, e.g. \"related=aa.bb.cc+xx.yy.zz\" would poll both of these devices. The implemenation of the *related* keyword is simple: if you add it to a channel, and that channel changes its state, then the *related* device will be polled to see if its state has updated.\n+\n+## Troubleshooting\n+\n+Turn on DEBUG or TRACE logging for `org.openhab.binding.insteon`. See [logging in openHAB](https://www.openhab.org/docs/administration/logging.html) for more info.\n+\n+### Device Permissions / Linux Device Locks\n+\n+When openHAB is running as a non-root user (Linux/OSX) it is important to ensure it has write access not just to the PLM device, but to the os lock directory. Under openSUSE this is `/run/lock` and is managed by the **lock** group. \n+\n+Example commands to grant openHAB access (adjust for your distribution):\n+\n+````\n+usermod -a -G dialout openhab\n+usermod -a -G lock openhab\n+````\n+\n+Insufficient access to the lock directory will result in openHAB failing to access the device, even if the device itself is writable.\n+\n+### Adding new device types (using existing device features)\n+\n+Device types are defined in the file `device_types.xml`, which is inside the Insteon bundle and thus not visible to the user. You can however load your own device_types.xml by referencing it in the network config parameters:\n+\n+    additionalDevices=\"/usr/local/openhab/rt/my_own_devices.xml\"\n+\n+Where the `my_own_devices.xml` file defines a new device like this:\n+\n+```xml\n+    <xml>\n+     <device productKey=\"F00.00.XX\">\n+      <model>2456-D3</model>\n+      <description>LampLinc V2</description>\n+      <feature name=\"dimmer\">GenericDimmer</feature>\n+      <feature name=\"lastheardfrom\">GenericLastTime</feature>\n+     </device>\n+    </xml>\n+```\n+\n+Finding the Insteon product key can be tricky since Insteon has not updated the product key table (http://www.insteon.com/pdf/insteon_devcats_and_product_keys_20081008.pdf) since 2008. If a web search does not turn up the product key, make one up, starting with \"F\", like: F00.00.99. Avoid duplicate keys by finding the highest fake product key in the `device_types.xml` file, and incrementing by one.\n+\n+### Adding new device features\n+\n+If you can't can't build a new device out of the existing device features (for a complete list see `device_features.xml`) you can add new features by specifying a file (let's call it `my_own_features.xml`) with the \"additionalDevices\" option in the network config parameters:\n+\n+    additionalFeatures=\"/usr/local/openhab/rt/my_own_features.xml\"\n+\n+  In this file you can define your own features (or even overwrite an existing feature). In the example below a new feature \"MyFeature\" is defined, which can then be referenced from the `device_types.xml` file (or from `my_own_devices.xml`):\n+\n+```xml\n+    <xml>\n+     <feature name=\"MyFeature\">\n+     <message-dispatcher>DefaultDispatcher</message-dispatcher>\n+     <message-handler cmd=\"0x03\">NoOpMsgHandler</message-handler>\n+     <message-handler cmd=\"0x06\">NoOpMsgHandler</message-handler>\n+     <message-handler cmd=\"0x11\">NoOpMsgHandler</message-handler>\n+     <message-handler cmd=\"0x13\">NoOpMsgHandler</message-handler>\n+     <message-handler cmd=\"0x19\">LightStateSwitchHandler</message-handler>\n+     <command-handler command=\"OnOffType\">IOLincOnOffCommandHandler</command-handler>\n+     <poll-handler>DefaultPollHandler</poll-handler>\n+     </feature>\n+    </xml>\n+```\n+\n+If you cannot cobble together a suitable device feature out of existing handlers you will have to define new ones by editing the corresponding Java classes in the source tree (see below).\n+\n+### Adding new handlers (for developers experienced with Eclipse IDE)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "04a9796d14dfbc5f3ff997d872f04b6d03ee411d"}, "originalPosition": 709}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTMxNzAwMw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            5. Using the Insteon Hub 2014 in conjunction with other applications (such as the InsteonApp) is not supported. Concretely, OpenHab will not learn when a switch is flipped via the Insteon App until the next poll, which could take minutes.\n          \n          \n            \n            5. Using the Insteon Hub 2014 in conjunction with other applications (such as the InsteonApp) is not supported. Concretely, openHAB will not learn when a switch is flipped via the Insteon App until the next poll, which could take minutes.", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r389317003", "createdAt": "2020-03-07T22:30:59Z", "author": {"login": "kaikreuzer"}, "path": "bundles/org.openhab.binding.insteon/README.md", "diffHunk": "@@ -0,0 +1,719 @@\n+# Insteon Binding\n+\n+Insteon is a home area networking technology developed primarily for connecting light switches and loads. Insteon devices send messages either via the power line, or by means of radio frequency (RF) waves, or both (dual-band). A considerable number of Insteon compatible devices such as switchable relays, thermostats, sensors etc are available. More about Insteon can be found on [Wikipedia](http://en.wikipedia.org/wiki/Insteon).\n+\n+This binding provides access to the Insteon network by means of either an Insteon PowerLinc Modem (PLM), a legacy Insteon Hub 2242-222 or the current 2245-222 Insteon Hub. The modem can be connected to the openHAB server either via a serial port (Model 2413S) or a USB port (Model 2413U). The Insteon PowerLinc Controller (Model 2414U) is not supported since it is a PLC not a PLM. The modem can also be connected via TCP (such as ser2net).  The binding translates openHAB commands into Insteon messages and sends them on the Insteon network. Relevant messages from the Insteon network (like notifications about switches being toggled) are picked up by the modem and converted to openHAB status updates by the binding. The binding also supports sending and receiving of legacy X10 messages.\n+\n+The binding does not support linking new devices on the fly, i.e. all devices must be linked with the modem *before* starting the Insteon binding.\n+\n+openHAB is not a configuration tool! To configure and set up your devices, link the devices manually via the set buttons, or use the free [Insteon Terminal](https://github.com/pfrommerd/insteon-terminal) software. The free HouseLinc software from Insteon can also be used for configuration, but it wipes the modem link database clean on its initial use, requiring to re-link the modem to all devices.\n+\n+## Supported Things\n+\n+| Thing  | Type   | Description                  |\n+|----------|--------|------------------------------|\n+| network  | Bridge | An insteon PLM or hub that is used to communicate with the Insteon devices |\n+|device| Thing | Insteon devices such as dimmers, keypads, sensors, etc. |\n+\n+## Discovery\n+\n+The binding will automatically add the network bridge called local to the Paper UI inbox. Upon proper configuration of the network bridge, the network device database will be downloaded. Any Insteon device that exists in the database and is not currently configured will get added to the inbox.  The naming convention is **Insteon Device AABBCC**, where AA, BB and CC are from the Insteon device address.  X10 devices are not auto discovered. \n+\n+## Thing Configuration\n+\n+###### Network Configuration\n+\n+The Insteon PLM or hub is configured with the following:\n+\n+| Parameter | Default | Required | Description |\n+|----------|---------:|--------:|-------------|\n+| port   |         |   Yes    | **Examples:**<br>- PLM on  Linux: `/dev/ttyS0` or `/dev/ttyUSB0`<br>- Smartenit ZBPLM on Linux: `/dev/ttyUSB0,baudRate=115200`<br>- PLM on Windows: `COM1`<br>- Current  hub (2245-222) at 192.168.1.100 on port 25105, with a poll interval of 1000 ms (1 second): `/hub2/my_user_name:my_password@192.168.1.100:25105,poll_time=1000`<br>- Legacy hub (2242-222) at 192.168.1.100 on port 9761:`/hub/192.168.1.100:9761`<br>- Networked PLM using ser2net at 192.168.1.100 on port 9761:`/tcp/192.168.1.100:9761` |\n+| devicePollIntervalSeconds | 300 |  No  | Poll interval of devices in seconds. Poll too often and you will overload the insteon network, leading to sluggish or no response when trying to send messages to devices. The default poll interval of 300 seconds has been tested and found to be a good compromise in a configuration of about 110 switches/dimmers. |\n+|modemDbRetryTimeoutSeconds|120|No|The number of seconds to wait for the modem database to completely download before retrying again.  Under normal circumstances this will not need to be modified.|\n+| additionalDevices | |       No     | Optional file with additional device types. The syntax of the file is identical to the `device_types.xml` file in the source tree. Please remember to post successfully added device types to the openhab group so the developers can include them into the `device_types.xml` file! |\n+| additionalFeatures | |      No     | Optional file with additional feature templates, like in the `device_features.xml` file in the source tree. |\n+\n+>NOTE: For users upgrading from InsteonPLM, The parameter port_1 is now port. \n+\n+###### Device Configuration\n+\n+The Insteon device is configured with the following required parameters:\n+\n+| Parameter | Description |\n+|----------|-------------|\n+|address|Insteon or X10 address of the device. Insteon device addresses are in the format 'xx.xx.xx', and can be found on the device. X10 device address are in the format 'x.y' and are typically configured on the device.|\n+|productKey|Insteon binding product key that is used to identy the device. Every Insteon device type is uniquely identified by its Insteon product key, typically a six digit hex number. For some of the older device types (in particular the SwitchLinc switches and dimmers), Insteon does not give a product key, so an arbitrary fake one of the format Fxx.xx.xx (or Xxx.xx.xx for X10 devices) is assigned by the binding.|\n+\n+The following is a list of the product keys and associated devices. These have been tested and should work out of the box:\n+\n+| Model | Description | Product Key | tested by |\n+|-------|-------------|-------------|-----------|\n+| 2477D | SwitchLinc Dimmer | F00.00.01 | Bernd Pfrommer |\n+| 2477S | SwitchLinc Switch | F00.00.02 | Bernd Pfrommer |\n+| 2845-222 | Hidden Door Sensor | F00.00.03 | Josenivaldo Benito |\n+| 2876S | ICON Switch | F00.00.04 | Patrick Giasson |\n+| 2456D3 | LampLinc V2 | F00.00.05 | Patrick Giasson |\n+| 2442-222 | Micro Dimmer | F00.00.06 | Josenivaldo Benito |\n+| 2453-222 | DIN Rail On/Off | F00.00.07 | Josenivaldo Benito |\n+| 2452-222 | DIN Rail Dimmer | F00.00.08 | Josenivaldo Benito |\n+| 2458-A1 | MorningLinc RF Lock Controller | F00.00.09 | cdeadlock |\n+| 2852-222 | Leak Sensor | F00.00.0A | Kirk McCann |\n+| 2672-422 | LED Dimmer | F00.00.0B | ??? |\n+| 2476D | SwitchLinc Dimmer | F00.00.0C | LiberatorUSA |\n+| 2634-222 | On/Off Dual-Band Outdoor Module | F00.00.0D | LiberatorUSA |\n+| 2342-2 | Mini Remote | F00.00.10 | Bernd Pfrommer |\n+| 2663-222 | On/Off Outlet | 0x000039 | SwissKid |\n+| 2466D | ToggleLinc Dimmer | F00.00.11 | Rob Nielsen |\n+| 2466S | ToggleLinc Switch | F00.00.12 | Rob Nielsen |\n+| 2672-222 | LED Bulb | F00.00.13 | Rob Nielsen |\n+| 2487S | KeypadLinc On/Off 6-Button | F00.00.14 | Bernd Pfrommer |\n+| 2334-232 | KeypadLink Dimmer 6-Button | F00.00.15 | Rob Nielsen |\n+| 2334-232 | KeypadLink Dimmer 8-Button | F00.00.16 | Rob Nielsen |\n+| 2423A1 | iMeter Solo Power Meter | F00.00.17 | Rob Nielsen |\n+| 2423A1 | Thermostat 2441TH | F00.00.18 | Daniel Campbell, Bernd Pfrommer |\n+| 2457D2 | LampLinc Dimmer | F00.00.19 | Jonathan Huizingh |\n+| 2475SDB | In-LineLinc Relay | F00.00.1A | Jim Howard |\n+| 2635-222 | On/Off Module | F00.00.1B | Jonathan Huizingh |\n+| 2475F | FanLinc Module | F00.00.1C | Brian Tillman |\n+| 2456S3 | ApplianceLinc | F00.00.1D | ??? |\n+| 2674-222 | LED Bulb (recessed) | F00.00.1E | Steve Bate |\n+| 2477SA1 | 220V 30-amp Load Controller N/O | F00.00.1F | Shawn R. |\n+| 2342-222 | Mini Remote (8 Button) | F00.00.20 | Bernd Pfrommer |\n+| 2441V | Insteon Thermostat Adaptor for Venstar | F00.00.21 | Bernd Pfrommer |\n+| 2982-222 | Insteon Smoke Bridge | F00.00.22 | Bernd Pfrommer |\n+| 2450 | IO Link | 0x00001A | Bernd Pfrommer |\n+| 2486D | KeypadLinc Dimmer | 0x000037 | Patrick Giasson, Joe Barnum |\n+| 2484DWH8 | KeypadLinc Countdown Timer | 0x000041 | Rob Nielsen |\n+| 2413U | PowerLinc 2413U USB modem | 0x000045 | Bernd Pfrommer |\n+| 2843-222 | Wireless Open/Close Sensor | 0x000049 | Josenivaldo Benito |\n+| 2842-222 | Motion Sensor | 0x00004A | Bernd Pfrommer |\n+| 2486DWH8 | KeypadLinc Dimmer | 0x000051 | Chris Graham |\n+| 2472D | OutletLincDimmer | 0x000068 | Chris Graham |\n+| X10 switch | generic X10 switch | X00.00.01 | Bernd Pfrommer |\n+| X10 dimmer | generic X10 dimmer | X00.00.02 | Bernd Pfrommer |\n+| X10 motion | generic X10 motion sensor | X00.00.03 | Bernd Pfrommer |\n+\n+## Channels\n+\n+Below is the list of possible channels for the Insteon devices. In order to determing which channels a device supports, you can either look at the device in Paper UI, or find it in the openhab log file.\n+\n+| channel  | type   | description                  |\n+|----------|--------|------------------------------|\n+| acDelay | Number | AC Delay |\n+| backlightDuration | Number | Back Light Duration |\n+| batteryLevel | Number | Battery Level |\n+| batteryWatermarkLevel | Number | Battery Watermark Level |\n+| bottomOutlet | Switch | Bottom Outlet |\n+| buttonA | Switch | Button A |\n+| buttonB | Switch | Button B |\n+| buttonC | Switch | Button C |\n+| buttonD | Switch | Button D |\n+| buttonE | Switch | Button E |\n+| buttonF | Switch | Button F |\n+| buttonG | Switch | Button G |\n+| buttonH | Switch | Button H |\n+| broadcastOnOff | Switch | Broadcast On/Off |\n+| contact | Contact | Contact |\n+| coolSetPoint | Number | Cool Set Point |\n+| dimmer | Dimmer | Dimmer |\n+| fan | Number | Fan |\n+| fanMode | Number | Fan Mode |\n+| fastOnOff | Switch | Fast On/Off |\n+| fastOnOffButtonA | Switch | Fast On/Off Button A |\n+| fastOnOffButtonB | Switch | Fast On/Off Button B |\n+| fastOnOffButtonC | Switch | Fast On/Off Button C |\n+| fastOnOffButtonD | Switch | Fast On/Off Button D |\n+| heatSetPoint | Number | Heat Set Point |\n+| humidity | Number | Humidity |\n+| humidityHigh | Number | Humidity High |\n+| humidityLow | Number | Humidity Low |\n+| isCooling | Number | Is Cooling |\n+| isHeating | Number | Is Heating |\n+| keypadButtonA | Switch | Keypad Button A |\n+| keypadButtonB | Switch | Keypad Button B |\n+| keypadButtonC | Switch | Keypad Button C |\n+| keypadButtonD | Switch | Keypad Button D |\n+| keypadButtonE | Switch | Keypad Button E |\n+| keypadButtonF | Switch | Keypad Button F |\n+| keypadButtonG | Switch | Keypad Button G |\n+| keypadButtonH | Switch | Keypad Button H |\n+| kWh | Number | Kilowatt Hour |\n+| lastHeardFrom | DateTime | Last Heard From |\n+| ledBrightness | Number | LED brightness |\n+| lightDimmer | Dimmer | light Dimmer |\n+| lightLevel | Number | Light Level |\n+| loadDimmer | Dimmer | Load Dimmer |\n+| loadSwitch | Switch | Load Switch |\n+| loadSwitchFastOnOff | Switch | Load Switch Fast On/Off |\n+| loadSwitchManualChange | Number | Load Switch Manual Change |\n+| manualChange | Number | Manual Change |\n+| manualChangeButtonA | Number | Manual Change Button A |\n+| manualChangeButtonB | Number | Manual Change Button B |\n+| manualChangeButtonC | Number | Manual Change Button C |\n+| manualChangeButtonD | Number | Manual Change Button D |\n+| notification | Number | Notification |\n+| onLevel | Number | On Level |\n+| rampDimmer | Dimmer | Ramp Dimmer |\n+| rampRate | Number | Ramp Rate |\n+| reset | Switch | Reset |\n+| stage1Duration | Number | Stage 1 Duration |\n+| switch | Switch | Switch |\n+| systemMode | Number | System Mode |\n+| tempCelsius | Number | Temperature Celsius |\n+| tempFahrenheit | Number | Temperature Fahrenheit |\n+| topOutlet | Switch | Top Outlet |\n+| update | Switch | Update |\n+| watts | Number | Watts |\n+\n+\n+## Full Example\n+\n+Sample things file:\n+\n+```\n+Bridge insteon:network:local [port=\"/dev/ttyUSB0\"] {\n+  Thing device 22F8A8 [address=\"22.F8.A8\", productKey=\"F00.00.15\"] {\n+    Channels:\n+      Type switch : keypadButtonA [ group=3 ]\n+      Type switch : keypadButtonB [ group=4 ]\n+      Type switch : keypadButtonC [ group=5 ]\n+      Type switch : keypadButtonD [ group=6 ]\n+  }\n+  Thing device 238D93 [address=\"23.8D.93\", productKey=\"F00.00.12\"]\n+  Thing device 238F55 [address=\"23.8F.55\", productKey=\"F00.00.11\"] {\n+    Channels:\n+      Type dimmer : dimmer [related=\"23.B0.D9+23.8F.C9\"]\n+  }\n+  Thing device 238FC9 [address=\"23.8F.C9\", productKey=\"F00.00.11\"] {\n+    Channels:\n+      Type dimmer : dimmer [related=\"23.8F.55+23.B0.D9\"]\n+  }\n+  Thing device 23B0D9 [address=\"23.B0.D9\", productKey=\"F00.00.11\"] {\n+    Channels:\n+      Type dimmer : dimmer [related=\"23.8F.55+23.8F.C9\"]\n+  }\n+  Thing device 243141 [address=\"24.31.41\", productKey=\"F00.00.11\"]  {\n+    Channels:\n+      Type dimmer : dimmer [dimmermax=60]\n+  }\n+}\n+```\n+\n+Sample items file:\n+\n+```\n+Switch switch1 { channel=\"insteon:device:local:243141:switch\" }\n+Dimmer dimmer1 { channel=\"insteon:device:local:238F55:dimmer\" }\n+Dimmer dimmer2 { channel=\"insteon:device:local:23B0D9:dimmer\" }\n+Dimmer dimmer3 { channel=\"insteon:device:local:238FC9:dimmer\" }\n+Dimmer keypad  { channel=\"insteon:device:local:22F8A8:loadDimmer\" }\n+Switch keypadA { channel=\"insteon:device:local:22F8A8:keypadButtonA\" }\n+Switch keypadB { channel=\"insteon:device:local:22F8A8:keypadButtonB\" }\n+Switch keypadC { channel=\"insteon:device:local:22F8A8:keypadButtonC\" }\n+Switch keypadD { channel=\"insteon:device:local:22F8A8:keypadButtonD\" }\n+Dimmer dimmer  { channel=\"insteon:device:local:238D93:dimmer\" }\n+```\n+\n+## Insteon Groups and Scenes\n+\n+How do Insteon devices tell other devices on the network that their state has changed? They send out a broadcast message, labeled with a specific *group* number. All devices (called *responders*) that are configured to listen to this message will then go into a pre-defined state. For instance when light switch A is switched to \"ON\", it will send out a message to group #1, and all responders will react to it, e.g they may go into the \"ON\" position as well. Since more than one device can participate, the sending out of the broadcast message and the subsequent state change of the responders is referred to as \"triggering a scene\". At the device and PLM level, the concept of a \"scene\" does not exist, so you will find it notably absent in the binding code and this document. A scene is strictly a higher level concept, introduced to shield the user from the details of how the communication is implemented.\n+\n+Many Insteon devices send out messages on different group numbers, depending on what happens to them. A leak sensor may send out a message on group #1 when dry, and on group #2 when wet. The default group used for e.g. linking two light switches is usually group #1.\n+\n+## Insteon binding process\n+\n+Before Insteon devices communicate with one another, they must be linked. During the linking process, one of the devices will be the \"Controller\", the other the \"Responder\" (see e.g. the [SwitchLinc Instructions](https://www.insteon.com/pdf/2477S.pdf)).\n+\n+The responder listens to messages from the controller, and reacts to them. Note that except for the case of a motion detector (which is just a controller to the modem), the modem controls the device (e.g. send on/off messages to it), and the device controls the modem (so the modem learns about the switch being toggled). For this reason, most devices and in particular switches/dimmers should be linked twice, with one taking the role of controller during the first linking, and the other acting as controller during the second linking process. To do so, first press and hold the \"Set\" button on the modem until the light starts blinking. Then press and hold the \"Set\" button on the remote device,\n+e.g. the light switch, until it double beeps (the light on the modem should go off as well). Now do exactly the reverse: press and hold the \"Set\" button on the remote device until its light starts blinking, then press and hold the \"Set\" button on the modem until it double beeps, and the light of the remote device (switch) goes off. Done.\n+\n+For some of the more sophisticated devices the complete linking process can no longer be done with the set buttons, but requires software like e.g. [Insteon Terminal](https://github.com/pfrommerd/insteon-terminal).\n+\n+## Insteon Features\n+\n+Since Insteon devices can have multiple features (for instance a switchable relay and a contact sensor) under a single Insteon address, an openHAB item is not bound to a device, but to a given feature of a device. For example, the following lines would create two Number items referring to the same thermostat device, but to different features of it:\n+\n+```\n+Number  thermostatCoolPoint \"cool point [%.1f \u00b0F]\" { channel=\"insteon:device:local:32F422:coolSetPoint\" }\n+Number  thermostatHeatPoint \"heat point [%.1f \u00b0F]\" { channel=\"insteon:device:local:32F422:heatSetPoint\" }\n+```\n+\n+### Simple light switches\n+\n+The following example shows how to configure a simple light switch (2477S) in the .items file:\n+\n+```\n+Switch officeLight \"office light\"  { channel=\"insteon:device:local:AABBCC:switch\" }\n+```\n+\n+### Simple dimmers\n+\n+Here is how to configure a simple dimmer (2477D) in the .items file:\n+\n+```\n+Dimmer kitchenChandelier \"kitchen chandelier\" { channel=\"insteon:device:local:AABBCC:dimmer\" }\n+```\n+\n+Dimmers can be configured with a maximum level when turning a device on or setting a percentage level. If a maximum level is configured, openHAB will never set the level of the dimmer above the level specified. The parameter dimmermax must be defined for the channel. The below example sets a maximum level of 70% for dim 1 and 60% for dim 2:\n+\n+**Things**\n+\n+```\n+Bridge insteon:network:local [port=\"/dev/ttyUSB0\"] {\n+  Thing device AABBCC [address=\"AA.BB.CC\", productKey=\"F00.00.11\"]  {\n+    Channels:\n+      Type dimmer : dimmer [dimmermax=70]\n+  }\n+  Thing device AABBCD [address=\"AA.BB.CD\", productKey=\"F00.00.15\"]  {\n+    Channels:\n+      Type dimmer : loadDimmer [dimmermax=60]\n+  }\n+}\n+```\n+\n+**Items**\n+\n+```\n+Dimmer d1 \"dimmer 1\" { channel=\"insteon:device:local:AABBCC:dimmer\"}\n+Dimmer d2 \"dimmer 2\" { channel=\"insteon:device:local:AABBCD:loadDimmer\"}\n+```\n+\n+Setting a maximum level does not affect manual turning on or dimming a switch.\n+\n+### On/Off Outlets\n+\n+Here's how to configure the top and bottom outlet of the in-wall 2 outlet controller:\n+\n+```\n+Switch fOutTop \"Front Outlet Top\"    <socket> { channel=\"insteon:device:local:AABBCC:topOutlet\" }\n+Switch fOutBot \"Front Outlet Bottom\" <socket> { channel=\"insteon:device:local:AABBCC:bottomOutlet\" }\n+```\n+\n+This will give you individual control of each outlet.\n+    \n+### Mini remotes\n+\n+Link the mini remote to be a controller of the modem by using the set button. Link all buttons, one after the other. The 4-button mini remote sends out messages on groups 0x01 - 0x04, each corresponding to one button. The modem's link database (see [Insteon Terminal](https://github.com/pfrommerd/insteon-terminal)) should look like this:\n+\n+```\n+    0000 xx.xx.xx                       xx.xx.xx  RESP  10100010 group: 01 data: 02 2c 41\n+    0000 xx.xx.xx                       xx.xx.xx  RESP  10100010 group: 02 data: 02 2c 41\n+    0000 xx.xx.xx                       xx.xx.xx  RESP  10100010 group: 03 data: 02 2c 41\n+    0000 xx.xx.xx                       xx.xx.xx  RESP  10100010 group: 04 data: 02 2c 41\n+```\n+\n+**Items**\n+This goes into the items file:\n+\n+```\n+    Switch miniRemoteButtonA \"mini remote button a\" { channel=\"insteon:device:local:AABBCC:buttonA\", autoupdate=\"false\" }\n+    Switch miniRemoteButtonB \"mini remote button b\" { channel=\"insteon:device:local:AABBCC:buttonB\", autoupdate=\"false\" }\n+    Switch miniRemoteButtonC \"mini remote button c\" { channel=\"insteon:device:local:AABBCC:buttonC\", autoupdate=\"false\" }\n+    Switch miniRemoteButtonD \"mini remote button d\" { channel=\"insteon:device:local:AABBCC:buttonD\", autoupdate=\"false\" }\n+```\n+\n+**Sitemap**\n+This goes into the sitemap file:\n+\n+```\n+    Switch item=miniRemoteButtonA label=\"mini remote button a\" mappings=[ OFF=\"Off\", ON=\"On\"]\n+    Switch item=miniRemoteButtonB label=\"mini remote button b\" mappings=[ OFF=\"Off\", ON=\"On\"]\n+    Switch item=miniRemoteButtonC label=\"mini remote button c\" mappings=[ OFF=\"Off\", ON=\"On\"]\n+    Switch item=miniRemoteButtonD label=\"mini remote button d\" mappings=[ OFF=\"Off\", ON=\"On\"]\n+```\n+\n+The switches in the GUI just display the mini remote's most recent button presses. They are not operable because the PLM cannot trigger the mini remotes scenes.\n+\n+### Motion sensors\n+\n+Link such that the modem is a responder to the motion sensor. Create a contact.map file in the transforms directory as described elsewhere in this document. Then create entries in the .items file like this:\n+\n+**Items**\n+\n+```\n+    Contact motionSensor             \"motion sensor [MAP(contact.map):%s]\" { channel=\"insteon:device:local:AABBCC:contact\"}\n+    Number  motionSensorBatteryLevel \"motion sensor battery level [%.1f]\"  { channel=\"insteon:device:local:AABBCC:batteryLevel\" }\n+    Number  motionSensorLightLevel   \"motion sensor light level [%.1f]\"    { channel=\"insteon:device:local:AABBCC:lightLevel\" }\n+```\n+\n+This will give you a contact, the battery level, and the light level. Note that battery and light level are only updated when either there is motion, or the sensor battery runs low.\n+\n+### Hidden door sensors\n+\n+Similar in operation to the motion sensor above.  Link such that the modem is a responder to the motion sensor. Create a contact.map file in the transforms directory like the following:\n+\n+```\n+    OPEN=open\n+    CLOSED=closed\n+    -=unknown\n+```\n+\n+**Items**\n+Then create entries in the .items file like this:\n+\n+```\n+    Contact doorSensor             \"Door sensor [MAP(contact.map):%s]\" { channel=\"insteon:device:local:AABBCC:contact\" }\n+    Number  doorSensorBatteryLevel \"Door sensor battery level [%.1f]\"  { channel=\"insteon:device:local:AABBCC:batteryLevel\" }\n+```\n+\n+This will give you a contact and the battery level. Note that battery level is only updated when either there is motion, or the sensor battery runs low.\n+\n+### Locks\n+\n+Read the instructions very carefully: sync with lock within 5 feet to avoid bad connection, link twice for both ON and OFF functionality.\n+\n+**Items**\n+Put something like this into your .items file:\n+\n+```\n+    Switch doorLock \"Front Door [MAP(lock.map):%s]\"  { channel=\"insteon:device:local:AABBCC:switch\" }\n+```\n+\n+and create a file \"lock.map\" in the transforms directory with these entries: \n+\n+```\n+    ON=Lock\n+    OFF=Unlock\n+    -=unknown\n+```\n+\n+### I/O Linc (garage door openers)\n+\n+The I/O Linc devices are really two devices in one: a relay and a contact. Link the modem both ways, as responder and controller using the set buttons as described in the instructions.\n+\n+Add this map into your transforms directory as \"contact.map\":\n+\n+```\n+    OPEN=open\n+    CLOSED=closed\n+    -=unknown\n+```\n+\n+**Items**\n+Along with this into your .items file:\n+\n+```\n+    Switch  garageDoorOpener  \"garage door opener\"                        <garagedoor>  { channel=\"insteon:device:local:AABBCC:switch\", autoupdate=\"false\" }\n+    Contact garageDoorContact \"garage door contact [MAP(contact.map):%s]\"               { channel=\"insteon:device:local:AABBCC:contact\" }\n+```\n+\n+**Sitemap**\n+To make it visible in the GUI, put this into your sitemap file:\n+\n+```\n+    Switch item=garageDoorOpener label=\"garage door opener\" mappings=[ ON=\"OPEN/CLOSE\"]\n+    Text item=garageDoorContact\n+```\n+\n+For safety reasons, only close the garage door if you have visual contact to make sure there is no obstruction! The use of automated rules for closing garage doors is dangerous.\n+\n+> NOTE: If the I/O Linc returns the wrong value when the device is polled (For example you open the garage door and the state correctly shows OPEN, but during polling it shows CLOSED), you probably linked the device with the PLM or hub when the door was in the wrong position. You need unlink and then link again with the door in the opposite position. Please see the Insteon I/O Linc documentation for further details.\n+\n+### Keypads\n+\n+Before you attempt to configure the keypads, please familiarize yourself with the concept of an Insteon group.\n+\n+The Insteon keypad devices typically control one main load and have a number of buttons that will send out group broadcast messages to trigger a scene. If you just want to use the main load switch within openhab just link modem and device with the set buttons as usual, no complicated linking is necessary. But if you want to get the buttons to work, read on.\n+\n+Each button will send out a message for a different, predefined group. Complicating matters further, the button numbering used internally by the device must be mapped to whatever labels are printed on the physical buttons of the device. Here is an example correspondence table:\n+\n+| Group | Button Number | 2487S Label |\n+|-------|---------------|-------------|\n+|  0x01 |        1      |   (Load)    |\n+|  0x03 |        3      |     A       |\n+|  0x04 |        4      |     B       |\n+|  0x05 |        5      |     C       |\n+|  0x06 |        6      |     D       |\n+\n+When e.g. the \"A\" button is pressed (that's button #3 internally) a broadcast message will be sent out to all responders configured to listen to Insteon group #3. This means you must configure the modem as a responder to group #3 (and #4, #5, #6) messages coming from your keypad. For instructions how to do this, check out the [Insteon Terminal](https://github.com/pfrommerd/insteon-terminal). You can even do that with the set buttons (see instructions that come with the keypad).\n+\n+While capturing the messages that the buttons emit is pretty straight forward, controlling the buttons is  another matter. They cannot be simply toggled with a direct command to the device, but instead a broadcast message must be sent on a group number that the button has been programmed to listen to. This means you need to pick a set of unused groups that is globally unique (if you have multiple keypads, each one of them has to use different groups), one group for each button. The example configuration below uses groups 0xf3, 0xf4, 0xf5, and 0xf6. Then link the buttons such that they respond to those groups, and link the modem as a controller for them (see [Insteon Terminal](https://github.com/pfrommerd/insteon-terminal) documentation). In your items file you specify these groups with the \"group=\" parameters such that the binding knows what group number to put on the outgoing message.\n+\n+\n+#### Keypad switches\n+\n+**Items**\n+\n+Here is a simple example, just using the load (main) switch:\n+\n+```\n+    Switch keypadSwitch             \"main load\"          { channel=\"insteon:device:local:AABBCC:loadSwitch\" }\n+    Number keypadSwitchManualChange \"main manual change\" { channel=\"insteon:device:local:AABBCC:loadSwitchManualChange\" }\n+    Switch keypadSwitchFastOnOff    \"main fast on/off\"   { channel=\"insteon:device:local:AABBCC:loadSwitchFastOnOff\" }\n+```\n+\n+Most people will not use the fast on/off features or the manual change feature, so you really only need the first line. To make the buttons available, add the following:\n+\n+**Things**\n+\n+```\n+Bridge insteon:network:local [port=\"/dev/ttyUSB0\"] {\n+  Thing device AABBCC [address=\"AA.BB.CC\", productKey=\"F00.00.15\"] {\n+    Channels:\n+      Type switch : keypadButtonA [ group=\"0xf3\" ]\n+      Type switch : keypadButtonB [ group=\"0xf4\" ]\n+      Type switch : keypadButtonC [ group=\"0xf5\" ]\n+      Type switch : keypadButtonD [ group=\"0xf6\" ]\n+  }\n+}\n+```\n+\n+The value after group must either be a number or string. The hexadecimal value 0xf3 can either converted to a numeric value 243 or the string value \"0xf3\".\n+\n+**Items**\n+\n+```\n+    Switch keypadSwitchA \"keypad button A\" { channel=\"insteon:device:local:AABBCC:keypadButtonA\"}\n+    Switch keypadSwitchB \"keypad button B\" { channel=\"insteon:device:local:AABBCC:keypadButtonB\"}\n+    Switch keypadSwitchC \"keypad button C\" { channel=\"insteon:device:local:AABBCC:keypadButtonC\"}\n+    Switch keypadSwitchD \"keypad button D\" { channel=\"insteon:device:local:AABBCC:keypadButtonD\"}\n+```\n+\n+**Sitemap**\n+\n+The following sitemap will bring the items to life in the GUI:\n+\n+```\n+    Frame label=\"Keypad\" {\n+          Switch item=keypadSwitch label=\"main\"\n+          Switch item=keypadSwitchFastOnOff label=\"fast on/off\"\n+          Switch item=keypadSwitchManualChange label=\"manual change\" mappings=[ 0=\"DOWN\", 1=\"STOP\",  2=\"UP\"]\n+          Switch item=keypadSwitchA label=\"button A\"\n+          Switch item=keypadSwitchB label=\"button B\"\n+          Switch item=keypadSwitchC label=\"button C\"\n+          Switch item=keypadSwitchD label=\"button D\"\n+    }\n+```\n+\n+#### Keypad dimmers\n+\n+The keypad dimmers are like keypad switches, except that the main load is dimmable.\n+\n+**Items**\n+\n+```\n+    Dimmer keypadDimmer           \"dimmer\"                          { channel=\"insteon:device:local:AABBCC:loadDimmer\" }\n+    Switch keypadDimmerButtonA    \"keypad dimmer button A [%d %%]\"  { channel=\"insteon:device:local:AABBCC:keypadButtonA\" }\n+```\n+\n+**Sitemap**\n+\n+```\n+    Slider item=keypadDimmer switchSupport\n+    Switch item=keypadDimmerButtonA label=\"buttonA\"\n+```\n+\n+### Thermostats\n+\n+The thermostat (2441TH) is one of the most complex Insteon devices available. It must first be properly linked to the modem using configuration software like [Insteon Terminal](https://github.com/pfrommerd/insteon-terminal). The Insteon Terminal wiki describes in detail how to link the thermostat, and how to make it publish status update reports.\n+\n+When all is set and done the modem must be configured as a controller to group 0 (not sure why), and a responder to groups 1-5 such that it picks up when the thermostat switches on/off heating and cooling etc, and it must be a responder to special group 0xEF to get status update reports when measured values (temperature) change. Symmetrically, the thermostat must be a responder to group 0, and a controller for groups 1-5 and 0xEF. The linking process is not difficult but needs some persistence. Again, refer to the [Insteon Terminal](https://github.com/pfrommerd/insteon-terminal) documentation.\n+\n+**Items**\n+\n+This is an example of what to put into your .items file:\n+\n+```\n+    Number  thermostatCoolPoint   \"cool point [%.1f \u00b0F]\"  { channel=\"insteon:device:local:AABBCC:coolSetPoint\" }\n+    Number  thermostatHeatPoint   \"heat point [%.1f \u00b0F]\"  { channel=\"insteon:device:local:AABBCC:heatSetPoint\" }\n+    Number  thermostatSystemMode  \"system mode [%d]\"      { channel=\"insteon:device:local:AABBCC:systemMode\" }\n+    Number  thermostatFanMode     \"fan mode [%d]\"         { channel=\"insteon:device:local:AABBCC:fanMode\" }\n+    Number  thermostatIsHeating   \"is heating [%d]\"       { channel=\"insteon:device:local:AABBCC:isHeating\"}\n+    Number  thermostatIsCooling   \"is cooling [%d]\"       { channel=\"insteon:device:local:AABBCC:isCooling\" }\n+    Number  thermostatTempFahren  \"temperature [%.1f \u00b0F]\" { channel=\"insteon:device:local:AABBCC:tempFahrenheit\" }\n+    Number  thermostatTempCelsius \"temperature [%.1f \u00b0C]\" { channel=\"insteon:device:local:AABBCC:tempCelsius\" }\n+    Number  thermostatHumidity    \"humidity [%.0f %%]\"    { channel=\"insteon:device:local:AABBCC:humidity\" }\n+```\n+\n+Add this as well for some more exotic features:\n+\n+```\n+    Number  thermostatACDelay      \"A/C delay [%d min]\"        { channel=\"insteon:device:local:AABBCC:acDelay\" }\n+    Number  thermostatBacklight    \"backlight [%d sec]\"        { channel=\"insteon:device:local:AABBCC:backlightDuration\" }\n+    Number  thermostatStage1       \"A/C stage 1 time [%d min]\" { channel=\"insteon:device:local:AABBCC:stage1Duration\" }\n+    Number  thermostatHumidityHigh \"humidity high [%d %%]\"     { channel=\"insteon:device:local:AABBCC:humidityHigh\" }\n+    Number  thermostatHumidityLow  \"humidity low [%d %%]\"      { channel=\"insteon:device:local:AABBCC:humidityLow\" }\n+```\n+\n+**Sitemap**\n+\n+For the thermostat to display in the GUI, add this to the sitemap file:\n+\n+```\n+    Text   item=thermostatTempCelsius icon=\"temperature\"\n+    Text   item=thermostatTempFahren icon=\"temperature\"\n+    Text   item=thermostatHumidity\n+    Setpoint item=thermostatCoolPoint icon=\"temperature\" minValue=63 maxValue=90 step=1\n+    Setpoint item=thermostatHeatPoint icon=\"temperature\" minValue=50 maxValue=80 step=1\n+    Switch item=thermostatSystemMode  label=\"system mode\" mappings=[ 0=\"OFF\",  1=\"HEAT\", 2=\"COOL\", 3=\"AUTO\", 4=\"PROGRAM\"]\n+    Switch item=thermostatFanMode  label=\"fan mode\" mappings=[ 0=\"AUTO\",  1=\"ALWAYS ON\"]\n+    Switch item=thermostatIsHeating  label=\"is heating\" mappings=[ 0=\"OFF\",  1=\"HEATING\"]\n+    Switch item=thermostatIsCooling  label=\"is cooling\" mappings=[ 0=\"OFF\",  1=\"COOLING\"]\n+    Setpoint item=thermostatACDelay  minValue=2 maxValue=20 step=1\n+    Setpoint item=thermostatBacklight  minValue=0 maxValue=100 step=1\n+    Setpoint item=thermostatHumidityHigh  minValue=0 maxValue=100 step=1\n+    Setpoint item=thermostatHumidityLow   minValue=0 maxValue=100 step=1\n+    Setpoint item=thermostatStage1  minValue=1 maxValue=60 step=1\n+```\n+\n+### Power Meters\n+\n+The iMeter Solo reports both wattage and kilowatt hours, and is updated during the normal polling process of the devices. You can also manually update the current values from the device and reset the device. See the example below:\n+\n+**Items**\n+\n+``` \n+    Number iMeterWatts   \"iMeter [%d watts]\"   { channel=\"insteon:device:local:AABBCC:watts\" }\n+    Number iMeterKwh     \"iMeter [%.04f kwh]\"  { channel=\"insteon:device:local:AABBCC:kwh\" }\n+    Switch iMeterUpdate  \"iMeter Update\"       { channel=\"insteon:device:local:AABBCC:update\" }\n+    Switch iMeterReset   \"iMeter Reset\"        { channel=\"insteon:device:local:AABBCC:reset\" }\n+```\n+\n+### Fan Controllers\n+\n+Here is an example configuration for a FanLinc module, which has a dimmable light and a variable speed fan:\n+\n+**Items**\n+\n+```\n+    Dimmer fanLincDimmer \"fanlinc dimmer [%d %%]\" { channel=\"insteon:device:local:AABBCC:lightDimmer\" }\n+    Number fanLincFan    \"fanlinc fan\"            { channel=\"insteon:device:local:AABBCC:fan\"}\n+```\n+\n+**Sitemap**\n+\n+```\n+    Slider item=fanLincDimmer switchSupport\n+    Switch item=fanLincFan label=\"fan speed\" mappings=[ 0=\"OFF\",  1=\"LOW\", 2=\"MEDIUM\", 3=\"HIGH\"]\n+```\n+\n+### X10 devices\n+\n+It is worth noting that both the Inseon PLM and the 2014 Hub can both command X10 devices over the powerline, and also set switch stats based on X10 signals received over the powerline.  This allows openHAB not only control X10 devices without the need for other hardwaare, but it can also have rules that react to incoming X10 powerline commands.  While you cannot bind the the X10 devices to the Insteon PLM/HUB, here are some examples for configuring X10 devices. Be aware that most X10 switches/dimmers send no status updates, i.e. openHAB will not learn about switches that are toggled manually. Further note that\n+X10 devices are addressed with `houseCode.unitCode`, e.g. `A.2`.\n+\n+**Items**\n+\n+```\n+    Switch x10Switch  \"X10 switch\" { channel=\"insteon:device:local:AABB:switch\" }\n+    Dimmer x10Dimmer  \"X10 dimmer\" { channel=\"insteon:device:local:AABB:dimmer\" }\n+    Contact x10Motion \"X10 motion\" { channel=\"insteon:device:local:AABB:contact\" }\n+```\n+\n+## Direct sending of group broadcasts (triggering scenes)\n+\n+The binding can command the modem to send broadcasts to a given Insteon group. Since it is a broadcast message, the corresponding item does *not* take the address of any device, but of the modem itself. The format is broadcastOnOff#X where X is the group that you want to be able to broadcast messages to:\n+\n+**Things**\n+\n+```\n+Bridge insteon:network:local      [port=\"/dev/ttyUSB0\"] {\n+  Thing device AABBCC             [address=\"AA.BB.CC\", productKey=\"0x000045\"] {\n+    Channels:\n+      Type switch : broadcastOnOff#2\n+  }\n+}\n+\n+```\n+\n+**Items**\n+\n+```\n+    Switch  broadcastOnOff \"group on/off\"  { channel=\"insteon:device:local:AABBCC:broadcastOnOff#2\" }\n+```\n+\n+Flipping this switch to \"ON\" will cause the modem to send a broadcast message with group=2, and all devices that are configured to respond to it should react.\n+\n+## 3-way switch configurations and the \"related\" keyword\n+\n+When an Insteon device changes its state because it is directly operated (for example by flipping a switch manually), it sends out a broadcast message to announce the state change, and the binding (if the PLM modem is properly linked as a responder) should update the corresponding openHAB items. Other linked devices however may also change their state in response, but those devices will *not* send out a broadcast message, and so openHAB will not learn about their state change until the next poll. One common scenario is e.g. a switch in a 3-way configuration, with one switch controlling the load, and the other switch being linked as a controller. In this scenario, the \"related\" keyword can be used to cause the binding to poll a related device whenever a state change occurs for another device. A typical example would be two dimmers (A and B) in a 3-way configuration:\n+\n+```\n+Bridge insteon:network:local [port=\"/dev/ttyUSB0\"] {\n+  Thing device AABBCC [address=\"AA.BB.CC\", productKey=\"F00.00.11\"] {\n+    Channels:\n+      Type dimmer : dimmer [related=\"AA.BB.DD\"]\n+  }\n+  Thing device AABBDD [address=\"AA.BB.DD\", productKey=\"F00.00.11\"] {\n+    Channels:\n+      Type dimmer : dimmer [related=\"AA.BB.CC\"]\n+  }\n+}\n+```\n+\n+More than one device can be polled by separating them with \"+\" sign, e.g. \"related=aa.bb.cc+xx.yy.zz\" would poll both of these devices. The implemenation of the *related* keyword is simple: if you add it to a channel, and that channel changes its state, then the *related* device will be polled to see if its state has updated.\n+\n+## Troubleshooting\n+\n+Turn on DEBUG or TRACE logging for `org.openhab.binding.insteon`. See [logging in openHAB](https://www.openhab.org/docs/administration/logging.html) for more info.\n+\n+### Device Permissions / Linux Device Locks\n+\n+When openHAB is running as a non-root user (Linux/OSX) it is important to ensure it has write access not just to the PLM device, but to the os lock directory. Under openSUSE this is `/run/lock` and is managed by the **lock** group. \n+\n+Example commands to grant openHAB access (adjust for your distribution):\n+\n+````\n+usermod -a -G dialout openhab\n+usermod -a -G lock openhab\n+````\n+\n+Insufficient access to the lock directory will result in openHAB failing to access the device, even if the device itself is writable.\n+\n+### Adding new device types (using existing device features)\n+\n+Device types are defined in the file `device_types.xml`, which is inside the Insteon bundle and thus not visible to the user. You can however load your own device_types.xml by referencing it in the network config parameters:\n+\n+    additionalDevices=\"/usr/local/openhab/rt/my_own_devices.xml\"\n+\n+Where the `my_own_devices.xml` file defines a new device like this:\n+\n+```xml\n+    <xml>\n+     <device productKey=\"F00.00.XX\">\n+      <model>2456-D3</model>\n+      <description>LampLinc V2</description>\n+      <feature name=\"dimmer\">GenericDimmer</feature>\n+      <feature name=\"lastheardfrom\">GenericLastTime</feature>\n+     </device>\n+    </xml>\n+```\n+\n+Finding the Insteon product key can be tricky since Insteon has not updated the product key table (http://www.insteon.com/pdf/insteon_devcats_and_product_keys_20081008.pdf) since 2008. If a web search does not turn up the product key, make one up, starting with \"F\", like: F00.00.99. Avoid duplicate keys by finding the highest fake product key in the `device_types.xml` file, and incrementing by one.\n+\n+### Adding new device features\n+\n+If you can't can't build a new device out of the existing device features (for a complete list see `device_features.xml`) you can add new features by specifying a file (let's call it `my_own_features.xml`) with the \"additionalDevices\" option in the network config parameters:\n+\n+    additionalFeatures=\"/usr/local/openhab/rt/my_own_features.xml\"\n+\n+  In this file you can define your own features (or even overwrite an existing feature). In the example below a new feature \"MyFeature\" is defined, which can then be referenced from the `device_types.xml` file (or from `my_own_devices.xml`):\n+\n+```xml\n+    <xml>\n+     <feature name=\"MyFeature\">\n+     <message-dispatcher>DefaultDispatcher</message-dispatcher>\n+     <message-handler cmd=\"0x03\">NoOpMsgHandler</message-handler>\n+     <message-handler cmd=\"0x06\">NoOpMsgHandler</message-handler>\n+     <message-handler cmd=\"0x11\">NoOpMsgHandler</message-handler>\n+     <message-handler cmd=\"0x13\">NoOpMsgHandler</message-handler>\n+     <message-handler cmd=\"0x19\">LightStateSwitchHandler</message-handler>\n+     <command-handler command=\"OnOffType\">IOLincOnOffCommandHandler</command-handler>\n+     <poll-handler>DefaultPollHandler</poll-handler>\n+     </feature>\n+    </xml>\n+```\n+\n+If you cannot cobble together a suitable device feature out of existing handlers you will have to define new ones by editing the corresponding Java classes in the source tree (see below).\n+\n+### Adding new handlers (for developers experienced with Eclipse IDE)\n+\n+If all else fails there are the Java sources, in particular the classes MessageHandler.java (what to do with messages coming in from the Insteon network), PollHandler.java (how to form outbound messages for device polling), and CommandHandler.java (how to translate openhab commands to Insteon network messages). To that end you'll need to become a bonafide openHAB developer, and set up an openHAB Eclipse build environment, following the online instructions. Before you write new handlers have a good look at the existing ones, they are quite flexible and configurable via parameters in `device_features.xml`.\n+\n+## Known Limitations and Issues\n+\n+1. Devices cannot be linked to the modem while the binding is running. If new devices are linked, the binding must be restarted.\n+2. Setting up Insteon groups and linking devices cannot be done from within openHAB. Use the [Insteon Terminal](https://github.com/pfrommerd/insteon-terminal) for that. If using Insteon Terminal (especially as root), ensure any stale lock files (For example, /var/lock/LCK..ttyUSB0) are removed before starting openHAB runtime. Failure to do so may result in \"found no ports\".\n+3. Very rarely during binding startup, a message arrives at the modem while the initial read of the modem database happens. Somehow the modem then stops sending the remaining link records and the binding no longer is able to address the missing devices. The fix is to simply restart the binding.\n+4. The Insteon PLM device is know to break after about 2-3 years due to poorly sized capacitors of the power supply. With a bit of soldering skill you can repair it yourself, see http://pfrommer.us/home-automation or the original thread: http://forum.universal-devices.com/topic/13866-repair-of-2413s-plm-when-the-power-supply-fails/.\n+5. Using the Insteon Hub 2014 in conjunction with other applications (such as the InsteonApp) is not supported. Concretely, OpenHab will not learn when a switch is flipped via the Insteon App until the next poll, which could take minutes.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "04a9796d14dfbc5f3ff997d872f04b6d03ee411d"}, "originalPosition": 719}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTMxNzA0Ng==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            4. The Insteon PLM device is know to break after about 2-3 years due to poorly sized capacitors of the power supply. With a bit of soldering skill you can repair it yourself, see http://pfrommer.us/home-automation or the original thread: http://forum.universal-devices.com/topic/13866-repair-of-2413s-plm-when-the-power-supply-fails/.\n          \n          \n            \n            4. The Insteon PLM device is know to break after about 2-3 years due to poorly sized capacitors of the power supply. With a bit of soldering skill you can repair it yourself, see [here](http://pfrommer.us/home-automation) or [the original thread](http://forum.universal-devices.com/topic/13866-repair-of-2413s-plm-when-the-power-supply-fails/).", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r389317046", "createdAt": "2020-03-07T22:31:38Z", "author": {"login": "kaikreuzer"}, "path": "bundles/org.openhab.binding.insteon/README.md", "diffHunk": "@@ -0,0 +1,719 @@\n+# Insteon Binding\n+\n+Insteon is a home area networking technology developed primarily for connecting light switches and loads. Insteon devices send messages either via the power line, or by means of radio frequency (RF) waves, or both (dual-band). A considerable number of Insteon compatible devices such as switchable relays, thermostats, sensors etc are available. More about Insteon can be found on [Wikipedia](http://en.wikipedia.org/wiki/Insteon).\n+\n+This binding provides access to the Insteon network by means of either an Insteon PowerLinc Modem (PLM), a legacy Insteon Hub 2242-222 or the current 2245-222 Insteon Hub. The modem can be connected to the openHAB server either via a serial port (Model 2413S) or a USB port (Model 2413U). The Insteon PowerLinc Controller (Model 2414U) is not supported since it is a PLC not a PLM. The modem can also be connected via TCP (such as ser2net).  The binding translates openHAB commands into Insteon messages and sends them on the Insteon network. Relevant messages from the Insteon network (like notifications about switches being toggled) are picked up by the modem and converted to openHAB status updates by the binding. The binding also supports sending and receiving of legacy X10 messages.\n+\n+The binding does not support linking new devices on the fly, i.e. all devices must be linked with the modem *before* starting the Insteon binding.\n+\n+openHAB is not a configuration tool! To configure and set up your devices, link the devices manually via the set buttons, or use the free [Insteon Terminal](https://github.com/pfrommerd/insteon-terminal) software. The free HouseLinc software from Insteon can also be used for configuration, but it wipes the modem link database clean on its initial use, requiring to re-link the modem to all devices.\n+\n+## Supported Things\n+\n+| Thing  | Type   | Description                  |\n+|----------|--------|------------------------------|\n+| network  | Bridge | An insteon PLM or hub that is used to communicate with the Insteon devices |\n+|device| Thing | Insteon devices such as dimmers, keypads, sensors, etc. |\n+\n+## Discovery\n+\n+The binding will automatically add the network bridge called local to the Paper UI inbox. Upon proper configuration of the network bridge, the network device database will be downloaded. Any Insteon device that exists in the database and is not currently configured will get added to the inbox.  The naming convention is **Insteon Device AABBCC**, where AA, BB and CC are from the Insteon device address.  X10 devices are not auto discovered. \n+\n+## Thing Configuration\n+\n+###### Network Configuration\n+\n+The Insteon PLM or hub is configured with the following:\n+\n+| Parameter | Default | Required | Description |\n+|----------|---------:|--------:|-------------|\n+| port   |         |   Yes    | **Examples:**<br>- PLM on  Linux: `/dev/ttyS0` or `/dev/ttyUSB0`<br>- Smartenit ZBPLM on Linux: `/dev/ttyUSB0,baudRate=115200`<br>- PLM on Windows: `COM1`<br>- Current  hub (2245-222) at 192.168.1.100 on port 25105, with a poll interval of 1000 ms (1 second): `/hub2/my_user_name:my_password@192.168.1.100:25105,poll_time=1000`<br>- Legacy hub (2242-222) at 192.168.1.100 on port 9761:`/hub/192.168.1.100:9761`<br>- Networked PLM using ser2net at 192.168.1.100 on port 9761:`/tcp/192.168.1.100:9761` |\n+| devicePollIntervalSeconds | 300 |  No  | Poll interval of devices in seconds. Poll too often and you will overload the insteon network, leading to sluggish or no response when trying to send messages to devices. The default poll interval of 300 seconds has been tested and found to be a good compromise in a configuration of about 110 switches/dimmers. |\n+|modemDbRetryTimeoutSeconds|120|No|The number of seconds to wait for the modem database to completely download before retrying again.  Under normal circumstances this will not need to be modified.|\n+| additionalDevices | |       No     | Optional file with additional device types. The syntax of the file is identical to the `device_types.xml` file in the source tree. Please remember to post successfully added device types to the openhab group so the developers can include them into the `device_types.xml` file! |\n+| additionalFeatures | |      No     | Optional file with additional feature templates, like in the `device_features.xml` file in the source tree. |\n+\n+>NOTE: For users upgrading from InsteonPLM, The parameter port_1 is now port. \n+\n+###### Device Configuration\n+\n+The Insteon device is configured with the following required parameters:\n+\n+| Parameter | Description |\n+|----------|-------------|\n+|address|Insteon or X10 address of the device. Insteon device addresses are in the format 'xx.xx.xx', and can be found on the device. X10 device address are in the format 'x.y' and are typically configured on the device.|\n+|productKey|Insteon binding product key that is used to identy the device. Every Insteon device type is uniquely identified by its Insteon product key, typically a six digit hex number. For some of the older device types (in particular the SwitchLinc switches and dimmers), Insteon does not give a product key, so an arbitrary fake one of the format Fxx.xx.xx (or Xxx.xx.xx for X10 devices) is assigned by the binding.|\n+\n+The following is a list of the product keys and associated devices. These have been tested and should work out of the box:\n+\n+| Model | Description | Product Key | tested by |\n+|-------|-------------|-------------|-----------|\n+| 2477D | SwitchLinc Dimmer | F00.00.01 | Bernd Pfrommer |\n+| 2477S | SwitchLinc Switch | F00.00.02 | Bernd Pfrommer |\n+| 2845-222 | Hidden Door Sensor | F00.00.03 | Josenivaldo Benito |\n+| 2876S | ICON Switch | F00.00.04 | Patrick Giasson |\n+| 2456D3 | LampLinc V2 | F00.00.05 | Patrick Giasson |\n+| 2442-222 | Micro Dimmer | F00.00.06 | Josenivaldo Benito |\n+| 2453-222 | DIN Rail On/Off | F00.00.07 | Josenivaldo Benito |\n+| 2452-222 | DIN Rail Dimmer | F00.00.08 | Josenivaldo Benito |\n+| 2458-A1 | MorningLinc RF Lock Controller | F00.00.09 | cdeadlock |\n+| 2852-222 | Leak Sensor | F00.00.0A | Kirk McCann |\n+| 2672-422 | LED Dimmer | F00.00.0B | ??? |\n+| 2476D | SwitchLinc Dimmer | F00.00.0C | LiberatorUSA |\n+| 2634-222 | On/Off Dual-Band Outdoor Module | F00.00.0D | LiberatorUSA |\n+| 2342-2 | Mini Remote | F00.00.10 | Bernd Pfrommer |\n+| 2663-222 | On/Off Outlet | 0x000039 | SwissKid |\n+| 2466D | ToggleLinc Dimmer | F00.00.11 | Rob Nielsen |\n+| 2466S | ToggleLinc Switch | F00.00.12 | Rob Nielsen |\n+| 2672-222 | LED Bulb | F00.00.13 | Rob Nielsen |\n+| 2487S | KeypadLinc On/Off 6-Button | F00.00.14 | Bernd Pfrommer |\n+| 2334-232 | KeypadLink Dimmer 6-Button | F00.00.15 | Rob Nielsen |\n+| 2334-232 | KeypadLink Dimmer 8-Button | F00.00.16 | Rob Nielsen |\n+| 2423A1 | iMeter Solo Power Meter | F00.00.17 | Rob Nielsen |\n+| 2423A1 | Thermostat 2441TH | F00.00.18 | Daniel Campbell, Bernd Pfrommer |\n+| 2457D2 | LampLinc Dimmer | F00.00.19 | Jonathan Huizingh |\n+| 2475SDB | In-LineLinc Relay | F00.00.1A | Jim Howard |\n+| 2635-222 | On/Off Module | F00.00.1B | Jonathan Huizingh |\n+| 2475F | FanLinc Module | F00.00.1C | Brian Tillman |\n+| 2456S3 | ApplianceLinc | F00.00.1D | ??? |\n+| 2674-222 | LED Bulb (recessed) | F00.00.1E | Steve Bate |\n+| 2477SA1 | 220V 30-amp Load Controller N/O | F00.00.1F | Shawn R. |\n+| 2342-222 | Mini Remote (8 Button) | F00.00.20 | Bernd Pfrommer |\n+| 2441V | Insteon Thermostat Adaptor for Venstar | F00.00.21 | Bernd Pfrommer |\n+| 2982-222 | Insteon Smoke Bridge | F00.00.22 | Bernd Pfrommer |\n+| 2450 | IO Link | 0x00001A | Bernd Pfrommer |\n+| 2486D | KeypadLinc Dimmer | 0x000037 | Patrick Giasson, Joe Barnum |\n+| 2484DWH8 | KeypadLinc Countdown Timer | 0x000041 | Rob Nielsen |\n+| 2413U | PowerLinc 2413U USB modem | 0x000045 | Bernd Pfrommer |\n+| 2843-222 | Wireless Open/Close Sensor | 0x000049 | Josenivaldo Benito |\n+| 2842-222 | Motion Sensor | 0x00004A | Bernd Pfrommer |\n+| 2486DWH8 | KeypadLinc Dimmer | 0x000051 | Chris Graham |\n+| 2472D | OutletLincDimmer | 0x000068 | Chris Graham |\n+| X10 switch | generic X10 switch | X00.00.01 | Bernd Pfrommer |\n+| X10 dimmer | generic X10 dimmer | X00.00.02 | Bernd Pfrommer |\n+| X10 motion | generic X10 motion sensor | X00.00.03 | Bernd Pfrommer |\n+\n+## Channels\n+\n+Below is the list of possible channels for the Insteon devices. In order to determing which channels a device supports, you can either look at the device in Paper UI, or find it in the openhab log file.\n+\n+| channel  | type   | description                  |\n+|----------|--------|------------------------------|\n+| acDelay | Number | AC Delay |\n+| backlightDuration | Number | Back Light Duration |\n+| batteryLevel | Number | Battery Level |\n+| batteryWatermarkLevel | Number | Battery Watermark Level |\n+| bottomOutlet | Switch | Bottom Outlet |\n+| buttonA | Switch | Button A |\n+| buttonB | Switch | Button B |\n+| buttonC | Switch | Button C |\n+| buttonD | Switch | Button D |\n+| buttonE | Switch | Button E |\n+| buttonF | Switch | Button F |\n+| buttonG | Switch | Button G |\n+| buttonH | Switch | Button H |\n+| broadcastOnOff | Switch | Broadcast On/Off |\n+| contact | Contact | Contact |\n+| coolSetPoint | Number | Cool Set Point |\n+| dimmer | Dimmer | Dimmer |\n+| fan | Number | Fan |\n+| fanMode | Number | Fan Mode |\n+| fastOnOff | Switch | Fast On/Off |\n+| fastOnOffButtonA | Switch | Fast On/Off Button A |\n+| fastOnOffButtonB | Switch | Fast On/Off Button B |\n+| fastOnOffButtonC | Switch | Fast On/Off Button C |\n+| fastOnOffButtonD | Switch | Fast On/Off Button D |\n+| heatSetPoint | Number | Heat Set Point |\n+| humidity | Number | Humidity |\n+| humidityHigh | Number | Humidity High |\n+| humidityLow | Number | Humidity Low |\n+| isCooling | Number | Is Cooling |\n+| isHeating | Number | Is Heating |\n+| keypadButtonA | Switch | Keypad Button A |\n+| keypadButtonB | Switch | Keypad Button B |\n+| keypadButtonC | Switch | Keypad Button C |\n+| keypadButtonD | Switch | Keypad Button D |\n+| keypadButtonE | Switch | Keypad Button E |\n+| keypadButtonF | Switch | Keypad Button F |\n+| keypadButtonG | Switch | Keypad Button G |\n+| keypadButtonH | Switch | Keypad Button H |\n+| kWh | Number | Kilowatt Hour |\n+| lastHeardFrom | DateTime | Last Heard From |\n+| ledBrightness | Number | LED brightness |\n+| lightDimmer | Dimmer | light Dimmer |\n+| lightLevel | Number | Light Level |\n+| loadDimmer | Dimmer | Load Dimmer |\n+| loadSwitch | Switch | Load Switch |\n+| loadSwitchFastOnOff | Switch | Load Switch Fast On/Off |\n+| loadSwitchManualChange | Number | Load Switch Manual Change |\n+| manualChange | Number | Manual Change |\n+| manualChangeButtonA | Number | Manual Change Button A |\n+| manualChangeButtonB | Number | Manual Change Button B |\n+| manualChangeButtonC | Number | Manual Change Button C |\n+| manualChangeButtonD | Number | Manual Change Button D |\n+| notification | Number | Notification |\n+| onLevel | Number | On Level |\n+| rampDimmer | Dimmer | Ramp Dimmer |\n+| rampRate | Number | Ramp Rate |\n+| reset | Switch | Reset |\n+| stage1Duration | Number | Stage 1 Duration |\n+| switch | Switch | Switch |\n+| systemMode | Number | System Mode |\n+| tempCelsius | Number | Temperature Celsius |\n+| tempFahrenheit | Number | Temperature Fahrenheit |\n+| topOutlet | Switch | Top Outlet |\n+| update | Switch | Update |\n+| watts | Number | Watts |\n+\n+\n+## Full Example\n+\n+Sample things file:\n+\n+```\n+Bridge insteon:network:local [port=\"/dev/ttyUSB0\"] {\n+  Thing device 22F8A8 [address=\"22.F8.A8\", productKey=\"F00.00.15\"] {\n+    Channels:\n+      Type switch : keypadButtonA [ group=3 ]\n+      Type switch : keypadButtonB [ group=4 ]\n+      Type switch : keypadButtonC [ group=5 ]\n+      Type switch : keypadButtonD [ group=6 ]\n+  }\n+  Thing device 238D93 [address=\"23.8D.93\", productKey=\"F00.00.12\"]\n+  Thing device 238F55 [address=\"23.8F.55\", productKey=\"F00.00.11\"] {\n+    Channels:\n+      Type dimmer : dimmer [related=\"23.B0.D9+23.8F.C9\"]\n+  }\n+  Thing device 238FC9 [address=\"23.8F.C9\", productKey=\"F00.00.11\"] {\n+    Channels:\n+      Type dimmer : dimmer [related=\"23.8F.55+23.B0.D9\"]\n+  }\n+  Thing device 23B0D9 [address=\"23.B0.D9\", productKey=\"F00.00.11\"] {\n+    Channels:\n+      Type dimmer : dimmer [related=\"23.8F.55+23.8F.C9\"]\n+  }\n+  Thing device 243141 [address=\"24.31.41\", productKey=\"F00.00.11\"]  {\n+    Channels:\n+      Type dimmer : dimmer [dimmermax=60]\n+  }\n+}\n+```\n+\n+Sample items file:\n+\n+```\n+Switch switch1 { channel=\"insteon:device:local:243141:switch\" }\n+Dimmer dimmer1 { channel=\"insteon:device:local:238F55:dimmer\" }\n+Dimmer dimmer2 { channel=\"insteon:device:local:23B0D9:dimmer\" }\n+Dimmer dimmer3 { channel=\"insteon:device:local:238FC9:dimmer\" }\n+Dimmer keypad  { channel=\"insteon:device:local:22F8A8:loadDimmer\" }\n+Switch keypadA { channel=\"insteon:device:local:22F8A8:keypadButtonA\" }\n+Switch keypadB { channel=\"insteon:device:local:22F8A8:keypadButtonB\" }\n+Switch keypadC { channel=\"insteon:device:local:22F8A8:keypadButtonC\" }\n+Switch keypadD { channel=\"insteon:device:local:22F8A8:keypadButtonD\" }\n+Dimmer dimmer  { channel=\"insteon:device:local:238D93:dimmer\" }\n+```\n+\n+## Insteon Groups and Scenes\n+\n+How do Insteon devices tell other devices on the network that their state has changed? They send out a broadcast message, labeled with a specific *group* number. All devices (called *responders*) that are configured to listen to this message will then go into a pre-defined state. For instance when light switch A is switched to \"ON\", it will send out a message to group #1, and all responders will react to it, e.g they may go into the \"ON\" position as well. Since more than one device can participate, the sending out of the broadcast message and the subsequent state change of the responders is referred to as \"triggering a scene\". At the device and PLM level, the concept of a \"scene\" does not exist, so you will find it notably absent in the binding code and this document. A scene is strictly a higher level concept, introduced to shield the user from the details of how the communication is implemented.\n+\n+Many Insteon devices send out messages on different group numbers, depending on what happens to them. A leak sensor may send out a message on group #1 when dry, and on group #2 when wet. The default group used for e.g. linking two light switches is usually group #1.\n+\n+## Insteon binding process\n+\n+Before Insteon devices communicate with one another, they must be linked. During the linking process, one of the devices will be the \"Controller\", the other the \"Responder\" (see e.g. the [SwitchLinc Instructions](https://www.insteon.com/pdf/2477S.pdf)).\n+\n+The responder listens to messages from the controller, and reacts to them. Note that except for the case of a motion detector (which is just a controller to the modem), the modem controls the device (e.g. send on/off messages to it), and the device controls the modem (so the modem learns about the switch being toggled). For this reason, most devices and in particular switches/dimmers should be linked twice, with one taking the role of controller during the first linking, and the other acting as controller during the second linking process. To do so, first press and hold the \"Set\" button on the modem until the light starts blinking. Then press and hold the \"Set\" button on the remote device,\n+e.g. the light switch, until it double beeps (the light on the modem should go off as well). Now do exactly the reverse: press and hold the \"Set\" button on the remote device until its light starts blinking, then press and hold the \"Set\" button on the modem until it double beeps, and the light of the remote device (switch) goes off. Done.\n+\n+For some of the more sophisticated devices the complete linking process can no longer be done with the set buttons, but requires software like e.g. [Insteon Terminal](https://github.com/pfrommerd/insteon-terminal).\n+\n+## Insteon Features\n+\n+Since Insteon devices can have multiple features (for instance a switchable relay and a contact sensor) under a single Insteon address, an openHAB item is not bound to a device, but to a given feature of a device. For example, the following lines would create two Number items referring to the same thermostat device, but to different features of it:\n+\n+```\n+Number  thermostatCoolPoint \"cool point [%.1f \u00b0F]\" { channel=\"insteon:device:local:32F422:coolSetPoint\" }\n+Number  thermostatHeatPoint \"heat point [%.1f \u00b0F]\" { channel=\"insteon:device:local:32F422:heatSetPoint\" }\n+```\n+\n+### Simple light switches\n+\n+The following example shows how to configure a simple light switch (2477S) in the .items file:\n+\n+```\n+Switch officeLight \"office light\"  { channel=\"insteon:device:local:AABBCC:switch\" }\n+```\n+\n+### Simple dimmers\n+\n+Here is how to configure a simple dimmer (2477D) in the .items file:\n+\n+```\n+Dimmer kitchenChandelier \"kitchen chandelier\" { channel=\"insteon:device:local:AABBCC:dimmer\" }\n+```\n+\n+Dimmers can be configured with a maximum level when turning a device on or setting a percentage level. If a maximum level is configured, openHAB will never set the level of the dimmer above the level specified. The parameter dimmermax must be defined for the channel. The below example sets a maximum level of 70% for dim 1 and 60% for dim 2:\n+\n+**Things**\n+\n+```\n+Bridge insteon:network:local [port=\"/dev/ttyUSB0\"] {\n+  Thing device AABBCC [address=\"AA.BB.CC\", productKey=\"F00.00.11\"]  {\n+    Channels:\n+      Type dimmer : dimmer [dimmermax=70]\n+  }\n+  Thing device AABBCD [address=\"AA.BB.CD\", productKey=\"F00.00.15\"]  {\n+    Channels:\n+      Type dimmer : loadDimmer [dimmermax=60]\n+  }\n+}\n+```\n+\n+**Items**\n+\n+```\n+Dimmer d1 \"dimmer 1\" { channel=\"insteon:device:local:AABBCC:dimmer\"}\n+Dimmer d2 \"dimmer 2\" { channel=\"insteon:device:local:AABBCD:loadDimmer\"}\n+```\n+\n+Setting a maximum level does not affect manual turning on or dimming a switch.\n+\n+### On/Off Outlets\n+\n+Here's how to configure the top and bottom outlet of the in-wall 2 outlet controller:\n+\n+```\n+Switch fOutTop \"Front Outlet Top\"    <socket> { channel=\"insteon:device:local:AABBCC:topOutlet\" }\n+Switch fOutBot \"Front Outlet Bottom\" <socket> { channel=\"insteon:device:local:AABBCC:bottomOutlet\" }\n+```\n+\n+This will give you individual control of each outlet.\n+    \n+### Mini remotes\n+\n+Link the mini remote to be a controller of the modem by using the set button. Link all buttons, one after the other. The 4-button mini remote sends out messages on groups 0x01 - 0x04, each corresponding to one button. The modem's link database (see [Insteon Terminal](https://github.com/pfrommerd/insteon-terminal)) should look like this:\n+\n+```\n+    0000 xx.xx.xx                       xx.xx.xx  RESP  10100010 group: 01 data: 02 2c 41\n+    0000 xx.xx.xx                       xx.xx.xx  RESP  10100010 group: 02 data: 02 2c 41\n+    0000 xx.xx.xx                       xx.xx.xx  RESP  10100010 group: 03 data: 02 2c 41\n+    0000 xx.xx.xx                       xx.xx.xx  RESP  10100010 group: 04 data: 02 2c 41\n+```\n+\n+**Items**\n+This goes into the items file:\n+\n+```\n+    Switch miniRemoteButtonA \"mini remote button a\" { channel=\"insteon:device:local:AABBCC:buttonA\", autoupdate=\"false\" }\n+    Switch miniRemoteButtonB \"mini remote button b\" { channel=\"insteon:device:local:AABBCC:buttonB\", autoupdate=\"false\" }\n+    Switch miniRemoteButtonC \"mini remote button c\" { channel=\"insteon:device:local:AABBCC:buttonC\", autoupdate=\"false\" }\n+    Switch miniRemoteButtonD \"mini remote button d\" { channel=\"insteon:device:local:AABBCC:buttonD\", autoupdate=\"false\" }\n+```\n+\n+**Sitemap**\n+This goes into the sitemap file:\n+\n+```\n+    Switch item=miniRemoteButtonA label=\"mini remote button a\" mappings=[ OFF=\"Off\", ON=\"On\"]\n+    Switch item=miniRemoteButtonB label=\"mini remote button b\" mappings=[ OFF=\"Off\", ON=\"On\"]\n+    Switch item=miniRemoteButtonC label=\"mini remote button c\" mappings=[ OFF=\"Off\", ON=\"On\"]\n+    Switch item=miniRemoteButtonD label=\"mini remote button d\" mappings=[ OFF=\"Off\", ON=\"On\"]\n+```\n+\n+The switches in the GUI just display the mini remote's most recent button presses. They are not operable because the PLM cannot trigger the mini remotes scenes.\n+\n+### Motion sensors\n+\n+Link such that the modem is a responder to the motion sensor. Create a contact.map file in the transforms directory as described elsewhere in this document. Then create entries in the .items file like this:\n+\n+**Items**\n+\n+```\n+    Contact motionSensor             \"motion sensor [MAP(contact.map):%s]\" { channel=\"insteon:device:local:AABBCC:contact\"}\n+    Number  motionSensorBatteryLevel \"motion sensor battery level [%.1f]\"  { channel=\"insteon:device:local:AABBCC:batteryLevel\" }\n+    Number  motionSensorLightLevel   \"motion sensor light level [%.1f]\"    { channel=\"insteon:device:local:AABBCC:lightLevel\" }\n+```\n+\n+This will give you a contact, the battery level, and the light level. Note that battery and light level are only updated when either there is motion, or the sensor battery runs low.\n+\n+### Hidden door sensors\n+\n+Similar in operation to the motion sensor above.  Link such that the modem is a responder to the motion sensor. Create a contact.map file in the transforms directory like the following:\n+\n+```\n+    OPEN=open\n+    CLOSED=closed\n+    -=unknown\n+```\n+\n+**Items**\n+Then create entries in the .items file like this:\n+\n+```\n+    Contact doorSensor             \"Door sensor [MAP(contact.map):%s]\" { channel=\"insteon:device:local:AABBCC:contact\" }\n+    Number  doorSensorBatteryLevel \"Door sensor battery level [%.1f]\"  { channel=\"insteon:device:local:AABBCC:batteryLevel\" }\n+```\n+\n+This will give you a contact and the battery level. Note that battery level is only updated when either there is motion, or the sensor battery runs low.\n+\n+### Locks\n+\n+Read the instructions very carefully: sync with lock within 5 feet to avoid bad connection, link twice for both ON and OFF functionality.\n+\n+**Items**\n+Put something like this into your .items file:\n+\n+```\n+    Switch doorLock \"Front Door [MAP(lock.map):%s]\"  { channel=\"insteon:device:local:AABBCC:switch\" }\n+```\n+\n+and create a file \"lock.map\" in the transforms directory with these entries: \n+\n+```\n+    ON=Lock\n+    OFF=Unlock\n+    -=unknown\n+```\n+\n+### I/O Linc (garage door openers)\n+\n+The I/O Linc devices are really two devices in one: a relay and a contact. Link the modem both ways, as responder and controller using the set buttons as described in the instructions.\n+\n+Add this map into your transforms directory as \"contact.map\":\n+\n+```\n+    OPEN=open\n+    CLOSED=closed\n+    -=unknown\n+```\n+\n+**Items**\n+Along with this into your .items file:\n+\n+```\n+    Switch  garageDoorOpener  \"garage door opener\"                        <garagedoor>  { channel=\"insteon:device:local:AABBCC:switch\", autoupdate=\"false\" }\n+    Contact garageDoorContact \"garage door contact [MAP(contact.map):%s]\"               { channel=\"insteon:device:local:AABBCC:contact\" }\n+```\n+\n+**Sitemap**\n+To make it visible in the GUI, put this into your sitemap file:\n+\n+```\n+    Switch item=garageDoorOpener label=\"garage door opener\" mappings=[ ON=\"OPEN/CLOSE\"]\n+    Text item=garageDoorContact\n+```\n+\n+For safety reasons, only close the garage door if you have visual contact to make sure there is no obstruction! The use of automated rules for closing garage doors is dangerous.\n+\n+> NOTE: If the I/O Linc returns the wrong value when the device is polled (For example you open the garage door and the state correctly shows OPEN, but during polling it shows CLOSED), you probably linked the device with the PLM or hub when the door was in the wrong position. You need unlink and then link again with the door in the opposite position. Please see the Insteon I/O Linc documentation for further details.\n+\n+### Keypads\n+\n+Before you attempt to configure the keypads, please familiarize yourself with the concept of an Insteon group.\n+\n+The Insteon keypad devices typically control one main load and have a number of buttons that will send out group broadcast messages to trigger a scene. If you just want to use the main load switch within openhab just link modem and device with the set buttons as usual, no complicated linking is necessary. But if you want to get the buttons to work, read on.\n+\n+Each button will send out a message for a different, predefined group. Complicating matters further, the button numbering used internally by the device must be mapped to whatever labels are printed on the physical buttons of the device. Here is an example correspondence table:\n+\n+| Group | Button Number | 2487S Label |\n+|-------|---------------|-------------|\n+|  0x01 |        1      |   (Load)    |\n+|  0x03 |        3      |     A       |\n+|  0x04 |        4      |     B       |\n+|  0x05 |        5      |     C       |\n+|  0x06 |        6      |     D       |\n+\n+When e.g. the \"A\" button is pressed (that's button #3 internally) a broadcast message will be sent out to all responders configured to listen to Insteon group #3. This means you must configure the modem as a responder to group #3 (and #4, #5, #6) messages coming from your keypad. For instructions how to do this, check out the [Insteon Terminal](https://github.com/pfrommerd/insteon-terminal). You can even do that with the set buttons (see instructions that come with the keypad).\n+\n+While capturing the messages that the buttons emit is pretty straight forward, controlling the buttons is  another matter. They cannot be simply toggled with a direct command to the device, but instead a broadcast message must be sent on a group number that the button has been programmed to listen to. This means you need to pick a set of unused groups that is globally unique (if you have multiple keypads, each one of them has to use different groups), one group for each button. The example configuration below uses groups 0xf3, 0xf4, 0xf5, and 0xf6. Then link the buttons such that they respond to those groups, and link the modem as a controller for them (see [Insteon Terminal](https://github.com/pfrommerd/insteon-terminal) documentation). In your items file you specify these groups with the \"group=\" parameters such that the binding knows what group number to put on the outgoing message.\n+\n+\n+#### Keypad switches\n+\n+**Items**\n+\n+Here is a simple example, just using the load (main) switch:\n+\n+```\n+    Switch keypadSwitch             \"main load\"          { channel=\"insteon:device:local:AABBCC:loadSwitch\" }\n+    Number keypadSwitchManualChange \"main manual change\" { channel=\"insteon:device:local:AABBCC:loadSwitchManualChange\" }\n+    Switch keypadSwitchFastOnOff    \"main fast on/off\"   { channel=\"insteon:device:local:AABBCC:loadSwitchFastOnOff\" }\n+```\n+\n+Most people will not use the fast on/off features or the manual change feature, so you really only need the first line. To make the buttons available, add the following:\n+\n+**Things**\n+\n+```\n+Bridge insteon:network:local [port=\"/dev/ttyUSB0\"] {\n+  Thing device AABBCC [address=\"AA.BB.CC\", productKey=\"F00.00.15\"] {\n+    Channels:\n+      Type switch : keypadButtonA [ group=\"0xf3\" ]\n+      Type switch : keypadButtonB [ group=\"0xf4\" ]\n+      Type switch : keypadButtonC [ group=\"0xf5\" ]\n+      Type switch : keypadButtonD [ group=\"0xf6\" ]\n+  }\n+}\n+```\n+\n+The value after group must either be a number or string. The hexadecimal value 0xf3 can either converted to a numeric value 243 or the string value \"0xf3\".\n+\n+**Items**\n+\n+```\n+    Switch keypadSwitchA \"keypad button A\" { channel=\"insteon:device:local:AABBCC:keypadButtonA\"}\n+    Switch keypadSwitchB \"keypad button B\" { channel=\"insteon:device:local:AABBCC:keypadButtonB\"}\n+    Switch keypadSwitchC \"keypad button C\" { channel=\"insteon:device:local:AABBCC:keypadButtonC\"}\n+    Switch keypadSwitchD \"keypad button D\" { channel=\"insteon:device:local:AABBCC:keypadButtonD\"}\n+```\n+\n+**Sitemap**\n+\n+The following sitemap will bring the items to life in the GUI:\n+\n+```\n+    Frame label=\"Keypad\" {\n+          Switch item=keypadSwitch label=\"main\"\n+          Switch item=keypadSwitchFastOnOff label=\"fast on/off\"\n+          Switch item=keypadSwitchManualChange label=\"manual change\" mappings=[ 0=\"DOWN\", 1=\"STOP\",  2=\"UP\"]\n+          Switch item=keypadSwitchA label=\"button A\"\n+          Switch item=keypadSwitchB label=\"button B\"\n+          Switch item=keypadSwitchC label=\"button C\"\n+          Switch item=keypadSwitchD label=\"button D\"\n+    }\n+```\n+\n+#### Keypad dimmers\n+\n+The keypad dimmers are like keypad switches, except that the main load is dimmable.\n+\n+**Items**\n+\n+```\n+    Dimmer keypadDimmer           \"dimmer\"                          { channel=\"insteon:device:local:AABBCC:loadDimmer\" }\n+    Switch keypadDimmerButtonA    \"keypad dimmer button A [%d %%]\"  { channel=\"insteon:device:local:AABBCC:keypadButtonA\" }\n+```\n+\n+**Sitemap**\n+\n+```\n+    Slider item=keypadDimmer switchSupport\n+    Switch item=keypadDimmerButtonA label=\"buttonA\"\n+```\n+\n+### Thermostats\n+\n+The thermostat (2441TH) is one of the most complex Insteon devices available. It must first be properly linked to the modem using configuration software like [Insteon Terminal](https://github.com/pfrommerd/insteon-terminal). The Insteon Terminal wiki describes in detail how to link the thermostat, and how to make it publish status update reports.\n+\n+When all is set and done the modem must be configured as a controller to group 0 (not sure why), and a responder to groups 1-5 such that it picks up when the thermostat switches on/off heating and cooling etc, and it must be a responder to special group 0xEF to get status update reports when measured values (temperature) change. Symmetrically, the thermostat must be a responder to group 0, and a controller for groups 1-5 and 0xEF. The linking process is not difficult but needs some persistence. Again, refer to the [Insteon Terminal](https://github.com/pfrommerd/insteon-terminal) documentation.\n+\n+**Items**\n+\n+This is an example of what to put into your .items file:\n+\n+```\n+    Number  thermostatCoolPoint   \"cool point [%.1f \u00b0F]\"  { channel=\"insteon:device:local:AABBCC:coolSetPoint\" }\n+    Number  thermostatHeatPoint   \"heat point [%.1f \u00b0F]\"  { channel=\"insteon:device:local:AABBCC:heatSetPoint\" }\n+    Number  thermostatSystemMode  \"system mode [%d]\"      { channel=\"insteon:device:local:AABBCC:systemMode\" }\n+    Number  thermostatFanMode     \"fan mode [%d]\"         { channel=\"insteon:device:local:AABBCC:fanMode\" }\n+    Number  thermostatIsHeating   \"is heating [%d]\"       { channel=\"insteon:device:local:AABBCC:isHeating\"}\n+    Number  thermostatIsCooling   \"is cooling [%d]\"       { channel=\"insteon:device:local:AABBCC:isCooling\" }\n+    Number  thermostatTempFahren  \"temperature [%.1f \u00b0F]\" { channel=\"insteon:device:local:AABBCC:tempFahrenheit\" }\n+    Number  thermostatTempCelsius \"temperature [%.1f \u00b0C]\" { channel=\"insteon:device:local:AABBCC:tempCelsius\" }\n+    Number  thermostatHumidity    \"humidity [%.0f %%]\"    { channel=\"insteon:device:local:AABBCC:humidity\" }\n+```\n+\n+Add this as well for some more exotic features:\n+\n+```\n+    Number  thermostatACDelay      \"A/C delay [%d min]\"        { channel=\"insteon:device:local:AABBCC:acDelay\" }\n+    Number  thermostatBacklight    \"backlight [%d sec]\"        { channel=\"insteon:device:local:AABBCC:backlightDuration\" }\n+    Number  thermostatStage1       \"A/C stage 1 time [%d min]\" { channel=\"insteon:device:local:AABBCC:stage1Duration\" }\n+    Number  thermostatHumidityHigh \"humidity high [%d %%]\"     { channel=\"insteon:device:local:AABBCC:humidityHigh\" }\n+    Number  thermostatHumidityLow  \"humidity low [%d %%]\"      { channel=\"insteon:device:local:AABBCC:humidityLow\" }\n+```\n+\n+**Sitemap**\n+\n+For the thermostat to display in the GUI, add this to the sitemap file:\n+\n+```\n+    Text   item=thermostatTempCelsius icon=\"temperature\"\n+    Text   item=thermostatTempFahren icon=\"temperature\"\n+    Text   item=thermostatHumidity\n+    Setpoint item=thermostatCoolPoint icon=\"temperature\" minValue=63 maxValue=90 step=1\n+    Setpoint item=thermostatHeatPoint icon=\"temperature\" minValue=50 maxValue=80 step=1\n+    Switch item=thermostatSystemMode  label=\"system mode\" mappings=[ 0=\"OFF\",  1=\"HEAT\", 2=\"COOL\", 3=\"AUTO\", 4=\"PROGRAM\"]\n+    Switch item=thermostatFanMode  label=\"fan mode\" mappings=[ 0=\"AUTO\",  1=\"ALWAYS ON\"]\n+    Switch item=thermostatIsHeating  label=\"is heating\" mappings=[ 0=\"OFF\",  1=\"HEATING\"]\n+    Switch item=thermostatIsCooling  label=\"is cooling\" mappings=[ 0=\"OFF\",  1=\"COOLING\"]\n+    Setpoint item=thermostatACDelay  minValue=2 maxValue=20 step=1\n+    Setpoint item=thermostatBacklight  minValue=0 maxValue=100 step=1\n+    Setpoint item=thermostatHumidityHigh  minValue=0 maxValue=100 step=1\n+    Setpoint item=thermostatHumidityLow   minValue=0 maxValue=100 step=1\n+    Setpoint item=thermostatStage1  minValue=1 maxValue=60 step=1\n+```\n+\n+### Power Meters\n+\n+The iMeter Solo reports both wattage and kilowatt hours, and is updated during the normal polling process of the devices. You can also manually update the current values from the device and reset the device. See the example below:\n+\n+**Items**\n+\n+``` \n+    Number iMeterWatts   \"iMeter [%d watts]\"   { channel=\"insteon:device:local:AABBCC:watts\" }\n+    Number iMeterKwh     \"iMeter [%.04f kwh]\"  { channel=\"insteon:device:local:AABBCC:kwh\" }\n+    Switch iMeterUpdate  \"iMeter Update\"       { channel=\"insteon:device:local:AABBCC:update\" }\n+    Switch iMeterReset   \"iMeter Reset\"        { channel=\"insteon:device:local:AABBCC:reset\" }\n+```\n+\n+### Fan Controllers\n+\n+Here is an example configuration for a FanLinc module, which has a dimmable light and a variable speed fan:\n+\n+**Items**\n+\n+```\n+    Dimmer fanLincDimmer \"fanlinc dimmer [%d %%]\" { channel=\"insteon:device:local:AABBCC:lightDimmer\" }\n+    Number fanLincFan    \"fanlinc fan\"            { channel=\"insteon:device:local:AABBCC:fan\"}\n+```\n+\n+**Sitemap**\n+\n+```\n+    Slider item=fanLincDimmer switchSupport\n+    Switch item=fanLincFan label=\"fan speed\" mappings=[ 0=\"OFF\",  1=\"LOW\", 2=\"MEDIUM\", 3=\"HIGH\"]\n+```\n+\n+### X10 devices\n+\n+It is worth noting that both the Inseon PLM and the 2014 Hub can both command X10 devices over the powerline, and also set switch stats based on X10 signals received over the powerline.  This allows openHAB not only control X10 devices without the need for other hardwaare, but it can also have rules that react to incoming X10 powerline commands.  While you cannot bind the the X10 devices to the Insteon PLM/HUB, here are some examples for configuring X10 devices. Be aware that most X10 switches/dimmers send no status updates, i.e. openHAB will not learn about switches that are toggled manually. Further note that\n+X10 devices are addressed with `houseCode.unitCode`, e.g. `A.2`.\n+\n+**Items**\n+\n+```\n+    Switch x10Switch  \"X10 switch\" { channel=\"insteon:device:local:AABB:switch\" }\n+    Dimmer x10Dimmer  \"X10 dimmer\" { channel=\"insteon:device:local:AABB:dimmer\" }\n+    Contact x10Motion \"X10 motion\" { channel=\"insteon:device:local:AABB:contact\" }\n+```\n+\n+## Direct sending of group broadcasts (triggering scenes)\n+\n+The binding can command the modem to send broadcasts to a given Insteon group. Since it is a broadcast message, the corresponding item does *not* take the address of any device, but of the modem itself. The format is broadcastOnOff#X where X is the group that you want to be able to broadcast messages to:\n+\n+**Things**\n+\n+```\n+Bridge insteon:network:local      [port=\"/dev/ttyUSB0\"] {\n+  Thing device AABBCC             [address=\"AA.BB.CC\", productKey=\"0x000045\"] {\n+    Channels:\n+      Type switch : broadcastOnOff#2\n+  }\n+}\n+\n+```\n+\n+**Items**\n+\n+```\n+    Switch  broadcastOnOff \"group on/off\"  { channel=\"insteon:device:local:AABBCC:broadcastOnOff#2\" }\n+```\n+\n+Flipping this switch to \"ON\" will cause the modem to send a broadcast message with group=2, and all devices that are configured to respond to it should react.\n+\n+## 3-way switch configurations and the \"related\" keyword\n+\n+When an Insteon device changes its state because it is directly operated (for example by flipping a switch manually), it sends out a broadcast message to announce the state change, and the binding (if the PLM modem is properly linked as a responder) should update the corresponding openHAB items. Other linked devices however may also change their state in response, but those devices will *not* send out a broadcast message, and so openHAB will not learn about their state change until the next poll. One common scenario is e.g. a switch in a 3-way configuration, with one switch controlling the load, and the other switch being linked as a controller. In this scenario, the \"related\" keyword can be used to cause the binding to poll a related device whenever a state change occurs for another device. A typical example would be two dimmers (A and B) in a 3-way configuration:\n+\n+```\n+Bridge insteon:network:local [port=\"/dev/ttyUSB0\"] {\n+  Thing device AABBCC [address=\"AA.BB.CC\", productKey=\"F00.00.11\"] {\n+    Channels:\n+      Type dimmer : dimmer [related=\"AA.BB.DD\"]\n+  }\n+  Thing device AABBDD [address=\"AA.BB.DD\", productKey=\"F00.00.11\"] {\n+    Channels:\n+      Type dimmer : dimmer [related=\"AA.BB.CC\"]\n+  }\n+}\n+```\n+\n+More than one device can be polled by separating them with \"+\" sign, e.g. \"related=aa.bb.cc+xx.yy.zz\" would poll both of these devices. The implemenation of the *related* keyword is simple: if you add it to a channel, and that channel changes its state, then the *related* device will be polled to see if its state has updated.\n+\n+## Troubleshooting\n+\n+Turn on DEBUG or TRACE logging for `org.openhab.binding.insteon`. See [logging in openHAB](https://www.openhab.org/docs/administration/logging.html) for more info.\n+\n+### Device Permissions / Linux Device Locks\n+\n+When openHAB is running as a non-root user (Linux/OSX) it is important to ensure it has write access not just to the PLM device, but to the os lock directory. Under openSUSE this is `/run/lock` and is managed by the **lock** group. \n+\n+Example commands to grant openHAB access (adjust for your distribution):\n+\n+````\n+usermod -a -G dialout openhab\n+usermod -a -G lock openhab\n+````\n+\n+Insufficient access to the lock directory will result in openHAB failing to access the device, even if the device itself is writable.\n+\n+### Adding new device types (using existing device features)\n+\n+Device types are defined in the file `device_types.xml`, which is inside the Insteon bundle and thus not visible to the user. You can however load your own device_types.xml by referencing it in the network config parameters:\n+\n+    additionalDevices=\"/usr/local/openhab/rt/my_own_devices.xml\"\n+\n+Where the `my_own_devices.xml` file defines a new device like this:\n+\n+```xml\n+    <xml>\n+     <device productKey=\"F00.00.XX\">\n+      <model>2456-D3</model>\n+      <description>LampLinc V2</description>\n+      <feature name=\"dimmer\">GenericDimmer</feature>\n+      <feature name=\"lastheardfrom\">GenericLastTime</feature>\n+     </device>\n+    </xml>\n+```\n+\n+Finding the Insteon product key can be tricky since Insteon has not updated the product key table (http://www.insteon.com/pdf/insteon_devcats_and_product_keys_20081008.pdf) since 2008. If a web search does not turn up the product key, make one up, starting with \"F\", like: F00.00.99. Avoid duplicate keys by finding the highest fake product key in the `device_types.xml` file, and incrementing by one.\n+\n+### Adding new device features\n+\n+If you can't can't build a new device out of the existing device features (for a complete list see `device_features.xml`) you can add new features by specifying a file (let's call it `my_own_features.xml`) with the \"additionalDevices\" option in the network config parameters:\n+\n+    additionalFeatures=\"/usr/local/openhab/rt/my_own_features.xml\"\n+\n+  In this file you can define your own features (or even overwrite an existing feature). In the example below a new feature \"MyFeature\" is defined, which can then be referenced from the `device_types.xml` file (or from `my_own_devices.xml`):\n+\n+```xml\n+    <xml>\n+     <feature name=\"MyFeature\">\n+     <message-dispatcher>DefaultDispatcher</message-dispatcher>\n+     <message-handler cmd=\"0x03\">NoOpMsgHandler</message-handler>\n+     <message-handler cmd=\"0x06\">NoOpMsgHandler</message-handler>\n+     <message-handler cmd=\"0x11\">NoOpMsgHandler</message-handler>\n+     <message-handler cmd=\"0x13\">NoOpMsgHandler</message-handler>\n+     <message-handler cmd=\"0x19\">LightStateSwitchHandler</message-handler>\n+     <command-handler command=\"OnOffType\">IOLincOnOffCommandHandler</command-handler>\n+     <poll-handler>DefaultPollHandler</poll-handler>\n+     </feature>\n+    </xml>\n+```\n+\n+If you cannot cobble together a suitable device feature out of existing handlers you will have to define new ones by editing the corresponding Java classes in the source tree (see below).\n+\n+### Adding new handlers (for developers experienced with Eclipse IDE)\n+\n+If all else fails there are the Java sources, in particular the classes MessageHandler.java (what to do with messages coming in from the Insteon network), PollHandler.java (how to form outbound messages for device polling), and CommandHandler.java (how to translate openhab commands to Insteon network messages). To that end you'll need to become a bonafide openHAB developer, and set up an openHAB Eclipse build environment, following the online instructions. Before you write new handlers have a good look at the existing ones, they are quite flexible and configurable via parameters in `device_features.xml`.\n+\n+## Known Limitations and Issues\n+\n+1. Devices cannot be linked to the modem while the binding is running. If new devices are linked, the binding must be restarted.\n+2. Setting up Insteon groups and linking devices cannot be done from within openHAB. Use the [Insteon Terminal](https://github.com/pfrommerd/insteon-terminal) for that. If using Insteon Terminal (especially as root), ensure any stale lock files (For example, /var/lock/LCK..ttyUSB0) are removed before starting openHAB runtime. Failure to do so may result in \"found no ports\".\n+3. Very rarely during binding startup, a message arrives at the modem while the initial read of the modem database happens. Somehow the modem then stops sending the remaining link records and the binding no longer is able to address the missing devices. The fix is to simply restart the binding.\n+4. The Insteon PLM device is know to break after about 2-3 years due to poorly sized capacitors of the power supply. With a bit of soldering skill you can repair it yourself, see http://pfrommer.us/home-automation or the original thread: http://forum.universal-devices.com/topic/13866-repair-of-2413s-plm-when-the-power-supply-fails/.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "04a9796d14dfbc5f3ff997d872f04b6d03ee411d"}, "originalPosition": 718}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTMxNzEzMA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            logger.warn(\"device {} has not responded to polls for {} sec\", dev.toString(),\n          \n          \n            \n                            logger.debug(\"device {} has not responded to polls for {} sec\", dev.toString(),", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r389317130", "createdAt": "2020-03-07T22:33:37Z", "author": {"login": "kaikreuzer"}, "path": "bundles/org.openhab.binding.insteon/src/main/java/org/openhab/binding/insteon/internal/InsteonBinding.java", "diffHunk": "@@ -0,0 +1,520 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.insteon.internal;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map.Entry;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import javax.xml.parsers.ParserConfigurationException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.openhab.binding.insteon.internal.config.InsteonChannelConfiguration;\n+import org.openhab.binding.insteon.internal.config.InsteonNetworkConfiguration;\n+import org.openhab.binding.insteon.internal.device.DeviceFeature;\n+import org.openhab.binding.insteon.internal.device.DeviceFeatureListener;\n+import org.openhab.binding.insteon.internal.device.DeviceType;\n+import org.openhab.binding.insteon.internal.device.DeviceTypeLoader;\n+import org.openhab.binding.insteon.internal.device.InsteonAddress;\n+import org.openhab.binding.insteon.internal.device.InsteonDevice;\n+import org.openhab.binding.insteon.internal.device.InsteonDevice.DeviceStatus;\n+import org.openhab.binding.insteon.internal.device.RequestQueueManager;\n+import org.openhab.binding.insteon.internal.driver.Driver;\n+import org.openhab.binding.insteon.internal.driver.DriverListener;\n+import org.openhab.binding.insteon.internal.driver.ModemDBEntry;\n+import org.openhab.binding.insteon.internal.driver.Poller;\n+import org.openhab.binding.insteon.internal.handler.InsteonNetworkHandler;\n+import org.openhab.binding.insteon.internal.message.FieldException;\n+import org.openhab.binding.insteon.internal.message.Msg;\n+import org.openhab.binding.insteon.internal.message.MsgListener;\n+import org.openhab.binding.insteon.internal.utils.Utils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.xml.sax.SAXException;\n+\n+/**\n+ * A majority of the code in this file is from the openHAB 1 binding\n+ * org.openhab.binding.insteonplm.InsteonPLMActiveBinding. Including the comments below.\n+ *\n+ * -----------------------------------------------------------------------------------------------\n+ *\n+ * This class represents the actual implementation of the binding, and controls the high level flow\n+ * of messages to and from the InsteonModem.\n+ *\n+ * Writing this binding has been an odyssey through the quirks of the Insteon protocol\n+ * and Insteon devices. A substantial redesign was necessary at some point along the way.\n+ * Here are some of the hard learned lessons that should be considered by anyone who wants\n+ * to re-architect the binding:\n+ *\n+ * 1) The entries of the link database of the modem are not reliable. The category/subcategory entries in\n+ * particular have junk data. Forget about using the modem database to generate a list of devices.\n+ * The database should only be used to verify that a device has been linked.\n+ *\n+ * 2) Querying devices for their product information does not work either. First of all, battery operated devices\n+ * (and there are a lot of those) have their radio switched off, and may generally not respond to product\n+ * queries. Even main stream hardwired devices sold presently (like the 2477s switch and the 2477d dimmer)\n+ * don't even have a product ID. Although supposedly part of the Insteon protocol, we have yet to\n+ * encounter a device that would cough up a product id when queried, even among very recent devices. They\n+ * simply return zeros as product id. Lesson: forget about querying devices to generate a device list.\n+ *\n+ * 3) Polling is a thorny issue: too much traffic on the network, and messages will be dropped left and right,\n+ * and not just the poll related ones, but others as well. In particular sending back-to-back messages\n+ * seemed to result in the second message simply never getting sent, without flow control back pressure\n+ * (NACK) from the modem. For now the work-around is to space out the messages upon sending, and\n+ * in general poll as infrequently as acceptable.\n+ *\n+ * 4) Instantiating and tracking devices when reported by the modem (either from the database, or when\n+ * messages are received) leads to complicated state management because there is no guarantee at what\n+ * point (if at all) the binding configuration will be available. It gets even more difficult when\n+ * items are created, destroyed, and modified while the binding runs.\n+ *\n+ * For the above reasons, devices are only instantiated when they are referenced by binding information.\n+ * As nice as it would be to discover devices and their properties dynamically, we have abandoned that\n+ * path because it had led to a complicated and fragile system which due to the technical limitations\n+ * above was inherently squirrely.\n+ *\n+ *\n+ * @author Bernd Pfrommer - Initial contribution\n+ * @author Daniel Pfrommer - openHAB 1 insteonplm binding\n+ * @author Rob Nielsen - Port to openHAB 2 insteon binding\n+ */\n+@NonNullByDefault\n+@SuppressWarnings({ \"null\", \"unused\" })\n+public class InsteonBinding {\n+    private static final int DEAD_DEVICE_COUNT = 10;\n+\n+    private final Logger logger = LoggerFactory.getLogger(InsteonBinding.class);\n+\n+    private Driver driver = new Driver();\n+    private ConcurrentHashMap<InsteonAddress, InsteonDevice> devices = new ConcurrentHashMap<>();\n+    private ConcurrentHashMap<String, InsteonChannelConfiguration> bindingConfigs = new ConcurrentHashMap<>();\n+    private PortListener portListener = new PortListener();\n+    private int devicePollIntervalMilliseconds = 300000;\n+    private int deadDeviceTimeout = -1;\n+    private int messagesReceived = 0;\n+    private boolean isActive = false; // state of binding\n+    private int x10HouseUnit = -1;\n+    private InsteonNetworkHandler handler;\n+\n+    public InsteonBinding(InsteonNetworkHandler handler, @Nullable InsteonNetworkConfiguration config,\n+            @Nullable SerialPortManager serialPortManager) {\n+        this.handler = handler;\n+\n+        Integer devicePollIntervalSeconds = config.getDevicePollIntervalSeconds();\n+        if (devicePollIntervalSeconds != null) {\n+            devicePollIntervalMilliseconds = devicePollIntervalSeconds * 1000;\n+        }\n+        logger.debug(\"device poll interval set to {} seconds\", devicePollIntervalMilliseconds / 1000);\n+\n+        Integer modemDbRetryTimeoutSeconds = config.getModemDbRetryTimeoutSeconds();\n+        if (modemDbRetryTimeoutSeconds != null) {\n+            logger.debug(\"setting modem db retry timeout to {} seconds\", modemDbRetryTimeoutSeconds);\n+            driver.setModemDBRetryTimeout(modemDbRetryTimeoutSeconds * 1000);\n+        }\n+\n+        String additionalDevices = config.getAdditionalDevices();\n+        if (additionalDevices != null) {\n+            try {\n+                DeviceTypeLoader.instance().loadDeviceTypesXML(additionalDevices);\n+                logger.debug(\"read additional device definitions from {}\", additionalDevices);\n+            } catch (ParserConfigurationException | SAXException | IOException e) {\n+                logger.warn(\"error reading additional devices from {}\", additionalDevices, e);\n+            }\n+        }\n+\n+        String additionalFeatures = config.getAdditionalFeatures();\n+        if (additionalFeatures != null) {\n+            logger.debug(\"reading additional feature templates from {}\", additionalFeatures);\n+            DeviceFeature.readFeatureTemplates(additionalFeatures);\n+        }\n+\n+        deadDeviceTimeout = devicePollIntervalMilliseconds * DEAD_DEVICE_COUNT;\n+        logger.debug(\"dead device timeout set to {} seconds\", deadDeviceTimeout / 1000);\n+\n+        String port = config.getPort();\n+        logger.info(\"port = '{}'\", Utils.redactPassword(port));\n+        driver.addPort(\"port\", port, serialPortManager);\n+        driver.addMsgListener(portListener, port);\n+\n+        logger.debug(\"setting driver listener\");\n+        driver.setDriverListener(portListener);\n+    }\n+\n+    public boolean startPolling() {\n+        logger.debug(\"starting {} ports\", driver.getNumberOfPorts());\n+\n+        driver.startAllPorts();\n+        logger.debug(\"ports started\");\n+        switch (driver.getNumberOfPorts()) {\n+            case 0:\n+                logger.warn(\"initialization complete, but found no ports!\");\n+                return false;\n+            case 1:\n+                logger.debug(\"initialization complete, found 1 port!\");\n+                break;\n+            default:\n+                logger.warn(\"initialization complete, found {} ports.\", driver.getNumberOfPorts());\n+                break;\n+        }\n+\n+        return true;\n+    }\n+\n+    public void setIsActive(boolean isActive) {\n+        this.isActive = isActive;\n+    }\n+\n+    public void sendCommand(String channelName, Command command) {\n+        if (!isActive) {\n+            logger.debug(\"not ready to handle commands yet, returning.\");\n+            return;\n+        }\n+\n+        InsteonChannelConfiguration bindingConfig = bindingConfigs.get(channelName);\n+        if (bindingConfig == null) {\n+            logger.warn(\"unable to find binding config for channel {}\", channelName);\n+            return;\n+        }\n+\n+        InsteonDevice dev = getDevice(bindingConfig.getAddress());\n+        if (dev == null) {\n+            logger.warn(\"no device found with insteon address {}\", bindingConfig.getAddress());\n+            return;\n+        }\n+\n+        dev.processCommand(driver, bindingConfig, command);\n+\n+        logger.debug(\"found binding config for channel {}\", channelName);\n+    }\n+\n+    public void addFeatureListener(InsteonChannelConfiguration bindingConfig) {\n+        logger.debug(\"adding listener for channel {}\", bindingConfig.getChannelName());\n+\n+        InsteonAddress address = bindingConfig.getAddress();\n+        InsteonDevice dev = getDevice(address);\n+        @Nullable\n+        DeviceFeature f = dev.getFeature(bindingConfig.getFeature());\n+        if (f == null || f.isFeatureGroup()) {\n+            StringBuilder buf = new StringBuilder();\n+            ArrayList<String> names = new ArrayList<>(dev.getFeatures().keySet());\n+            Collections.sort(names);\n+            for (String name : names) {\n+                DeviceFeature feature = dev.getFeature(name);\n+                if (!feature.isFeatureGroup()) {\n+                    if (buf.length() > 0) {\n+                        buf.append(\", \");\n+                    }\n+                    buf.append(name);\n+                }\n+            }\n+\n+            logger.warn(\"channel {} references unknown feature: {}, it will be ignored. Known features for {} are: {}.\",\n+                    bindingConfig.getChannelName(), bindingConfig.getFeature(), bindingConfig.getProductKey(),\n+                    buf.toString());\n+            return;\n+        }\n+\n+        DeviceFeatureListener fl = new DeviceFeatureListener(this, bindingConfig.getChannelUID(),\n+                bindingConfig.getChannelName());\n+        fl.setParameters(bindingConfig.getParameters());\n+        f.addListener(fl);\n+\n+        bindingConfigs.put(bindingConfig.getChannelName(), bindingConfig);\n+    }\n+\n+    public void removeFeatureListener(ChannelUID channelUID) {\n+        String channelName = channelUID.getAsString();\n+\n+        logger.debug(\"removing listener for channel {}\", channelName);\n+\n+        for (Iterator<Entry<InsteonAddress, InsteonDevice>> it = devices.entrySet().iterator(); it.hasNext();) {\n+            InsteonDevice dev = it.next().getValue();\n+            boolean removedListener = dev.removeFeatureListener(channelName);\n+            if (removedListener) {\n+                logger.trace(\"removed feature listener {} from dev {}\", channelName, dev);\n+            }\n+        }\n+    }\n+\n+    public void updateFeatureState(ChannelUID channelUID, State state) {\n+        handler.updateState(channelUID, state);\n+    }\n+\n+    public InsteonDevice makeNewDevice(InsteonAddress addr, String productKey) {\n+        DeviceType dt = DeviceTypeLoader.instance().getDeviceType(productKey);\n+        InsteonDevice dev = InsteonDevice.makeDevice(dt);\n+        dev.setAddress(addr);\n+        dev.setDriver(driver);\n+        dev.addPort(driver.getDefaultPort());\n+        if (!dev.hasValidPollingInterval()) {\n+            dev.setPollInterval(devicePollIntervalMilliseconds);\n+        }\n+        if (driver.isModemDBComplete() && dev.getStatus() != DeviceStatus.POLLING) {\n+            int ndev = checkIfInModemDatabase(dev);\n+            if (dev.hasModemDBEntry()) {\n+                dev.setStatus(DeviceStatus.POLLING);\n+                Poller.instance().startPolling(dev, ndev);\n+            }\n+        }\n+        devices.put(addr, dev);\n+\n+        handler.insteonDeviceWasCreated();\n+\n+        return (dev);\n+    }\n+\n+    public void removeDevice(InsteonAddress addr) {\n+        InsteonDevice dev = devices.remove(addr);\n+        if (dev == null) {\n+            return;\n+        }\n+\n+        if (dev.getStatus() == DeviceStatus.POLLING) {\n+            Poller.instance().stopPolling(dev);\n+        }\n+    }\n+\n+    /**\n+     * Checks if a device is in the modem link database, and, if the database\n+     * is complete, logs a warning if the device is not present\n+     *\n+     * @param dev The device to search for in the modem database\n+     * @return number of devices in modem database\n+     */\n+    private int checkIfInModemDatabase(InsteonDevice dev) {\n+        try {\n+            InsteonAddress addr = dev.getAddress();\n+            HashMap<InsteonAddress, @Nullable ModemDBEntry> dbes = driver.lockModemDBEntries();\n+            if (dbes.containsKey(addr)) {\n+                if (!dev.hasModemDBEntry()) {\n+                    logger.info(\"device {} found in the modem database and {}.\", addr, getLinkInfo(dbes, addr));\n+                    dev.setHasModemDBEntry(true);\n+                }\n+            } else {\n+                if (driver.isModemDBComplete() && !addr.isX10()) {\n+                    logger.warn(\"device {} not found in the modem database. Did you forget to link?\", addr);\n+                }\n+            }\n+            return dbes.size();\n+        } finally {\n+            driver.unlockModemDBEntries();\n+        }\n+    }\n+\n+    /**\n+     * Everything below was copied from Insteon PLM v1\n+     */\n+\n+    /**\n+     * Clean up all state.\n+     */\n+    public void shutdown() {\n+        logger.debug(\"shutting down Insteon bridge\");\n+        driver.stopAllPorts();\n+        devices.clear();\n+        RequestQueueManager.destroyInstance();\n+        Poller.instance().stop();\n+        isActive = false;\n+    }\n+\n+    /**\n+     * Method to find a device by address\n+     *\n+     * @param aAddr the insteon address to search for\n+     * @return reference to the device, or null if not found\n+     */\n+    public @Nullable InsteonDevice getDevice(@Nullable InsteonAddress aAddr) {\n+        InsteonDevice dev = (aAddr == null) ? null : devices.get(aAddr);\n+        return (dev);\n+    }\n+\n+    private String getLinkInfo(HashMap<InsteonAddress, @Nullable ModemDBEntry> dbes, InsteonAddress a) {\n+        ModemDBEntry dbe = dbes.get(a);\n+        ArrayList<Byte> controls = dbe.getControls();\n+        ArrayList<Byte> responds = dbe.getRespondsTo();\n+\n+        StringBuilder buf = new StringBuilder(\"the modem\");\n+        if (!controls.isEmpty()) {\n+            buf.append(\" controls groups [\");\n+            buf.append(toGroupString(controls));\n+            buf.append(\"]\");\n+        }\n+\n+        if (!responds.isEmpty()) {\n+            if (!controls.isEmpty()) {\n+                buf.append(\" and\");\n+            }\n+\n+            buf.append(\" responds to groups [\");\n+            buf.append(toGroupString(responds));\n+            buf.append(\"]\");\n+        }\n+\n+        return buf.toString();\n+    }\n+\n+    private String toGroupString(ArrayList<Byte> group) {\n+        ArrayList<Byte> sorted = new ArrayList<>(group);\n+        Collections.sort(sorted);\n+\n+        StringBuilder buf = new StringBuilder();\n+        for (Byte b : sorted) {\n+            if (buf.length() > 0) {\n+                buf.append(\",\");\n+            }\n+            buf.append(\"0x\");\n+            buf.append(Utils.getHexString(b));\n+        }\n+\n+        return buf.toString();\n+    }\n+\n+    public void logDeviceStatistics() {\n+        String msg = String.format(\"devices: %3d configured, %3d polling, msgs received: %5d\", devices.size(),\n+                Poller.instance().getSizeOfQueue(), messagesReceived);\n+        logger.info(\"{}\", msg);\n+        messagesReceived = 0;\n+        for (InsteonDevice dev : devices.values()) {\n+            if (dev.isModem()) {\n+                continue;\n+            }\n+            if (deadDeviceTimeout > 0 && dev.getPollOverDueTime() > deadDeviceTimeout) {\n+                logger.warn(\"device {} has not responded to polls for {} sec\", dev.toString(),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "04a9796d14dfbc5f3ff997d872f04b6d03ee411d"}, "originalPosition": 403}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTMxNzE0NQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            logger.info(\"modem database has {} entries!\", dbes.size());\n          \n          \n            \n                            logger.debug(\"modem database has {} entries!\", dbes.size());", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r389317145", "createdAt": "2020-03-07T22:33:56Z", "author": {"login": "kaikreuzer"}, "path": "bundles/org.openhab.binding.insteon/src/main/java/org/openhab/binding/insteon/internal/InsteonBinding.java", "diffHunk": "@@ -0,0 +1,520 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.insteon.internal;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map.Entry;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import javax.xml.parsers.ParserConfigurationException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.openhab.binding.insteon.internal.config.InsteonChannelConfiguration;\n+import org.openhab.binding.insteon.internal.config.InsteonNetworkConfiguration;\n+import org.openhab.binding.insteon.internal.device.DeviceFeature;\n+import org.openhab.binding.insteon.internal.device.DeviceFeatureListener;\n+import org.openhab.binding.insteon.internal.device.DeviceType;\n+import org.openhab.binding.insteon.internal.device.DeviceTypeLoader;\n+import org.openhab.binding.insteon.internal.device.InsteonAddress;\n+import org.openhab.binding.insteon.internal.device.InsteonDevice;\n+import org.openhab.binding.insteon.internal.device.InsteonDevice.DeviceStatus;\n+import org.openhab.binding.insteon.internal.device.RequestQueueManager;\n+import org.openhab.binding.insteon.internal.driver.Driver;\n+import org.openhab.binding.insteon.internal.driver.DriverListener;\n+import org.openhab.binding.insteon.internal.driver.ModemDBEntry;\n+import org.openhab.binding.insteon.internal.driver.Poller;\n+import org.openhab.binding.insteon.internal.handler.InsteonNetworkHandler;\n+import org.openhab.binding.insteon.internal.message.FieldException;\n+import org.openhab.binding.insteon.internal.message.Msg;\n+import org.openhab.binding.insteon.internal.message.MsgListener;\n+import org.openhab.binding.insteon.internal.utils.Utils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.xml.sax.SAXException;\n+\n+/**\n+ * A majority of the code in this file is from the openHAB 1 binding\n+ * org.openhab.binding.insteonplm.InsteonPLMActiveBinding. Including the comments below.\n+ *\n+ * -----------------------------------------------------------------------------------------------\n+ *\n+ * This class represents the actual implementation of the binding, and controls the high level flow\n+ * of messages to and from the InsteonModem.\n+ *\n+ * Writing this binding has been an odyssey through the quirks of the Insteon protocol\n+ * and Insteon devices. A substantial redesign was necessary at some point along the way.\n+ * Here are some of the hard learned lessons that should be considered by anyone who wants\n+ * to re-architect the binding:\n+ *\n+ * 1) The entries of the link database of the modem are not reliable. The category/subcategory entries in\n+ * particular have junk data. Forget about using the modem database to generate a list of devices.\n+ * The database should only be used to verify that a device has been linked.\n+ *\n+ * 2) Querying devices for their product information does not work either. First of all, battery operated devices\n+ * (and there are a lot of those) have their radio switched off, and may generally not respond to product\n+ * queries. Even main stream hardwired devices sold presently (like the 2477s switch and the 2477d dimmer)\n+ * don't even have a product ID. Although supposedly part of the Insteon protocol, we have yet to\n+ * encounter a device that would cough up a product id when queried, even among very recent devices. They\n+ * simply return zeros as product id. Lesson: forget about querying devices to generate a device list.\n+ *\n+ * 3) Polling is a thorny issue: too much traffic on the network, and messages will be dropped left and right,\n+ * and not just the poll related ones, but others as well. In particular sending back-to-back messages\n+ * seemed to result in the second message simply never getting sent, without flow control back pressure\n+ * (NACK) from the modem. For now the work-around is to space out the messages upon sending, and\n+ * in general poll as infrequently as acceptable.\n+ *\n+ * 4) Instantiating and tracking devices when reported by the modem (either from the database, or when\n+ * messages are received) leads to complicated state management because there is no guarantee at what\n+ * point (if at all) the binding configuration will be available. It gets even more difficult when\n+ * items are created, destroyed, and modified while the binding runs.\n+ *\n+ * For the above reasons, devices are only instantiated when they are referenced by binding information.\n+ * As nice as it would be to discover devices and their properties dynamically, we have abandoned that\n+ * path because it had led to a complicated and fragile system which due to the technical limitations\n+ * above was inherently squirrely.\n+ *\n+ *\n+ * @author Bernd Pfrommer - Initial contribution\n+ * @author Daniel Pfrommer - openHAB 1 insteonplm binding\n+ * @author Rob Nielsen - Port to openHAB 2 insteon binding\n+ */\n+@NonNullByDefault\n+@SuppressWarnings({ \"null\", \"unused\" })\n+public class InsteonBinding {\n+    private static final int DEAD_DEVICE_COUNT = 10;\n+\n+    private final Logger logger = LoggerFactory.getLogger(InsteonBinding.class);\n+\n+    private Driver driver = new Driver();\n+    private ConcurrentHashMap<InsteonAddress, InsteonDevice> devices = new ConcurrentHashMap<>();\n+    private ConcurrentHashMap<String, InsteonChannelConfiguration> bindingConfigs = new ConcurrentHashMap<>();\n+    private PortListener portListener = new PortListener();\n+    private int devicePollIntervalMilliseconds = 300000;\n+    private int deadDeviceTimeout = -1;\n+    private int messagesReceived = 0;\n+    private boolean isActive = false; // state of binding\n+    private int x10HouseUnit = -1;\n+    private InsteonNetworkHandler handler;\n+\n+    public InsteonBinding(InsteonNetworkHandler handler, @Nullable InsteonNetworkConfiguration config,\n+            @Nullable SerialPortManager serialPortManager) {\n+        this.handler = handler;\n+\n+        Integer devicePollIntervalSeconds = config.getDevicePollIntervalSeconds();\n+        if (devicePollIntervalSeconds != null) {\n+            devicePollIntervalMilliseconds = devicePollIntervalSeconds * 1000;\n+        }\n+        logger.debug(\"device poll interval set to {} seconds\", devicePollIntervalMilliseconds / 1000);\n+\n+        Integer modemDbRetryTimeoutSeconds = config.getModemDbRetryTimeoutSeconds();\n+        if (modemDbRetryTimeoutSeconds != null) {\n+            logger.debug(\"setting modem db retry timeout to {} seconds\", modemDbRetryTimeoutSeconds);\n+            driver.setModemDBRetryTimeout(modemDbRetryTimeoutSeconds * 1000);\n+        }\n+\n+        String additionalDevices = config.getAdditionalDevices();\n+        if (additionalDevices != null) {\n+            try {\n+                DeviceTypeLoader.instance().loadDeviceTypesXML(additionalDevices);\n+                logger.debug(\"read additional device definitions from {}\", additionalDevices);\n+            } catch (ParserConfigurationException | SAXException | IOException e) {\n+                logger.warn(\"error reading additional devices from {}\", additionalDevices, e);\n+            }\n+        }\n+\n+        String additionalFeatures = config.getAdditionalFeatures();\n+        if (additionalFeatures != null) {\n+            logger.debug(\"reading additional feature templates from {}\", additionalFeatures);\n+            DeviceFeature.readFeatureTemplates(additionalFeatures);\n+        }\n+\n+        deadDeviceTimeout = devicePollIntervalMilliseconds * DEAD_DEVICE_COUNT;\n+        logger.debug(\"dead device timeout set to {} seconds\", deadDeviceTimeout / 1000);\n+\n+        String port = config.getPort();\n+        logger.info(\"port = '{}'\", Utils.redactPassword(port));\n+        driver.addPort(\"port\", port, serialPortManager);\n+        driver.addMsgListener(portListener, port);\n+\n+        logger.debug(\"setting driver listener\");\n+        driver.setDriverListener(portListener);\n+    }\n+\n+    public boolean startPolling() {\n+        logger.debug(\"starting {} ports\", driver.getNumberOfPorts());\n+\n+        driver.startAllPorts();\n+        logger.debug(\"ports started\");\n+        switch (driver.getNumberOfPorts()) {\n+            case 0:\n+                logger.warn(\"initialization complete, but found no ports!\");\n+                return false;\n+            case 1:\n+                logger.debug(\"initialization complete, found 1 port!\");\n+                break;\n+            default:\n+                logger.warn(\"initialization complete, found {} ports.\", driver.getNumberOfPorts());\n+                break;\n+        }\n+\n+        return true;\n+    }\n+\n+    public void setIsActive(boolean isActive) {\n+        this.isActive = isActive;\n+    }\n+\n+    public void sendCommand(String channelName, Command command) {\n+        if (!isActive) {\n+            logger.debug(\"not ready to handle commands yet, returning.\");\n+            return;\n+        }\n+\n+        InsteonChannelConfiguration bindingConfig = bindingConfigs.get(channelName);\n+        if (bindingConfig == null) {\n+            logger.warn(\"unable to find binding config for channel {}\", channelName);\n+            return;\n+        }\n+\n+        InsteonDevice dev = getDevice(bindingConfig.getAddress());\n+        if (dev == null) {\n+            logger.warn(\"no device found with insteon address {}\", bindingConfig.getAddress());\n+            return;\n+        }\n+\n+        dev.processCommand(driver, bindingConfig, command);\n+\n+        logger.debug(\"found binding config for channel {}\", channelName);\n+    }\n+\n+    public void addFeatureListener(InsteonChannelConfiguration bindingConfig) {\n+        logger.debug(\"adding listener for channel {}\", bindingConfig.getChannelName());\n+\n+        InsteonAddress address = bindingConfig.getAddress();\n+        InsteonDevice dev = getDevice(address);\n+        @Nullable\n+        DeviceFeature f = dev.getFeature(bindingConfig.getFeature());\n+        if (f == null || f.isFeatureGroup()) {\n+            StringBuilder buf = new StringBuilder();\n+            ArrayList<String> names = new ArrayList<>(dev.getFeatures().keySet());\n+            Collections.sort(names);\n+            for (String name : names) {\n+                DeviceFeature feature = dev.getFeature(name);\n+                if (!feature.isFeatureGroup()) {\n+                    if (buf.length() > 0) {\n+                        buf.append(\", \");\n+                    }\n+                    buf.append(name);\n+                }\n+            }\n+\n+            logger.warn(\"channel {} references unknown feature: {}, it will be ignored. Known features for {} are: {}.\",\n+                    bindingConfig.getChannelName(), bindingConfig.getFeature(), bindingConfig.getProductKey(),\n+                    buf.toString());\n+            return;\n+        }\n+\n+        DeviceFeatureListener fl = new DeviceFeatureListener(this, bindingConfig.getChannelUID(),\n+                bindingConfig.getChannelName());\n+        fl.setParameters(bindingConfig.getParameters());\n+        f.addListener(fl);\n+\n+        bindingConfigs.put(bindingConfig.getChannelName(), bindingConfig);\n+    }\n+\n+    public void removeFeatureListener(ChannelUID channelUID) {\n+        String channelName = channelUID.getAsString();\n+\n+        logger.debug(\"removing listener for channel {}\", channelName);\n+\n+        for (Iterator<Entry<InsteonAddress, InsteonDevice>> it = devices.entrySet().iterator(); it.hasNext();) {\n+            InsteonDevice dev = it.next().getValue();\n+            boolean removedListener = dev.removeFeatureListener(channelName);\n+            if (removedListener) {\n+                logger.trace(\"removed feature listener {} from dev {}\", channelName, dev);\n+            }\n+        }\n+    }\n+\n+    public void updateFeatureState(ChannelUID channelUID, State state) {\n+        handler.updateState(channelUID, state);\n+    }\n+\n+    public InsteonDevice makeNewDevice(InsteonAddress addr, String productKey) {\n+        DeviceType dt = DeviceTypeLoader.instance().getDeviceType(productKey);\n+        InsteonDevice dev = InsteonDevice.makeDevice(dt);\n+        dev.setAddress(addr);\n+        dev.setDriver(driver);\n+        dev.addPort(driver.getDefaultPort());\n+        if (!dev.hasValidPollingInterval()) {\n+            dev.setPollInterval(devicePollIntervalMilliseconds);\n+        }\n+        if (driver.isModemDBComplete() && dev.getStatus() != DeviceStatus.POLLING) {\n+            int ndev = checkIfInModemDatabase(dev);\n+            if (dev.hasModemDBEntry()) {\n+                dev.setStatus(DeviceStatus.POLLING);\n+                Poller.instance().startPolling(dev, ndev);\n+            }\n+        }\n+        devices.put(addr, dev);\n+\n+        handler.insteonDeviceWasCreated();\n+\n+        return (dev);\n+    }\n+\n+    public void removeDevice(InsteonAddress addr) {\n+        InsteonDevice dev = devices.remove(addr);\n+        if (dev == null) {\n+            return;\n+        }\n+\n+        if (dev.getStatus() == DeviceStatus.POLLING) {\n+            Poller.instance().stopPolling(dev);\n+        }\n+    }\n+\n+    /**\n+     * Checks if a device is in the modem link database, and, if the database\n+     * is complete, logs a warning if the device is not present\n+     *\n+     * @param dev The device to search for in the modem database\n+     * @return number of devices in modem database\n+     */\n+    private int checkIfInModemDatabase(InsteonDevice dev) {\n+        try {\n+            InsteonAddress addr = dev.getAddress();\n+            HashMap<InsteonAddress, @Nullable ModemDBEntry> dbes = driver.lockModemDBEntries();\n+            if (dbes.containsKey(addr)) {\n+                if (!dev.hasModemDBEntry()) {\n+                    logger.info(\"device {} found in the modem database and {}.\", addr, getLinkInfo(dbes, addr));\n+                    dev.setHasModemDBEntry(true);\n+                }\n+            } else {\n+                if (driver.isModemDBComplete() && !addr.isX10()) {\n+                    logger.warn(\"device {} not found in the modem database. Did you forget to link?\", addr);\n+                }\n+            }\n+            return dbes.size();\n+        } finally {\n+            driver.unlockModemDBEntries();\n+        }\n+    }\n+\n+    /**\n+     * Everything below was copied from Insteon PLM v1\n+     */\n+\n+    /**\n+     * Clean up all state.\n+     */\n+    public void shutdown() {\n+        logger.debug(\"shutting down Insteon bridge\");\n+        driver.stopAllPorts();\n+        devices.clear();\n+        RequestQueueManager.destroyInstance();\n+        Poller.instance().stop();\n+        isActive = false;\n+    }\n+\n+    /**\n+     * Method to find a device by address\n+     *\n+     * @param aAddr the insteon address to search for\n+     * @return reference to the device, or null if not found\n+     */\n+    public @Nullable InsteonDevice getDevice(@Nullable InsteonAddress aAddr) {\n+        InsteonDevice dev = (aAddr == null) ? null : devices.get(aAddr);\n+        return (dev);\n+    }\n+\n+    private String getLinkInfo(HashMap<InsteonAddress, @Nullable ModemDBEntry> dbes, InsteonAddress a) {\n+        ModemDBEntry dbe = dbes.get(a);\n+        ArrayList<Byte> controls = dbe.getControls();\n+        ArrayList<Byte> responds = dbe.getRespondsTo();\n+\n+        StringBuilder buf = new StringBuilder(\"the modem\");\n+        if (!controls.isEmpty()) {\n+            buf.append(\" controls groups [\");\n+            buf.append(toGroupString(controls));\n+            buf.append(\"]\");\n+        }\n+\n+        if (!responds.isEmpty()) {\n+            if (!controls.isEmpty()) {\n+                buf.append(\" and\");\n+            }\n+\n+            buf.append(\" responds to groups [\");\n+            buf.append(toGroupString(responds));\n+            buf.append(\"]\");\n+        }\n+\n+        return buf.toString();\n+    }\n+\n+    private String toGroupString(ArrayList<Byte> group) {\n+        ArrayList<Byte> sorted = new ArrayList<>(group);\n+        Collections.sort(sorted);\n+\n+        StringBuilder buf = new StringBuilder();\n+        for (Byte b : sorted) {\n+            if (buf.length() > 0) {\n+                buf.append(\",\");\n+            }\n+            buf.append(\"0x\");\n+            buf.append(Utils.getHexString(b));\n+        }\n+\n+        return buf.toString();\n+    }\n+\n+    public void logDeviceStatistics() {\n+        String msg = String.format(\"devices: %3d configured, %3d polling, msgs received: %5d\", devices.size(),\n+                Poller.instance().getSizeOfQueue(), messagesReceived);\n+        logger.info(\"{}\", msg);\n+        messagesReceived = 0;\n+        for (InsteonDevice dev : devices.values()) {\n+            if (dev.isModem()) {\n+                continue;\n+            }\n+            if (deadDeviceTimeout > 0 && dev.getPollOverDueTime() > deadDeviceTimeout) {\n+                logger.warn(\"device {} has not responded to polls for {} sec\", dev.toString(),\n+                        dev.getPollOverDueTime() / 3600);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Handles messages that come in from the ports.\n+     * Will only process one message at a time.\n+     */\n+    @NonNullByDefault\n+    private class PortListener implements MsgListener, DriverListener {\n+        @Override\n+        public void msg(Msg msg, String fromPort) {\n+            if (msg.isEcho() || msg.isPureNack()) {\n+                return;\n+            }\n+            messagesReceived++;\n+            logger.debug(\"got msg: {}\", msg);\n+            if (msg.isX10()) {\n+                handleX10Message(msg, fromPort);\n+            } else {\n+                handleInsteonMessage(msg, fromPort);\n+            }\n+\n+        }\n+\n+        @Override\n+        public void driverCompletelyInitialized() {\n+            List<String> missing = new ArrayList<String>();\n+            try {\n+                HashMap<InsteonAddress, @Nullable ModemDBEntry> dbes = driver.lockModemDBEntries();\n+                logger.info(\"modem database has {} entries!\", dbes.size());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "04a9796d14dfbc5f3ff997d872f04b6d03ee411d"}, "originalPosition": 435}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTMxNzE4NQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                        logger.info(\"device {} found in the modem database and {}.\", a, getLinkInfo(dbes, a));\n          \n          \n            \n                                        logger.debug(\"device {} found in the modem database and {}.\", a, getLinkInfo(dbes, a));", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r389317185", "createdAt": "2020-03-07T22:34:25Z", "author": {"login": "kaikreuzer"}, "path": "bundles/org.openhab.binding.insteon/src/main/java/org/openhab/binding/insteon/internal/InsteonBinding.java", "diffHunk": "@@ -0,0 +1,520 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.insteon.internal;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map.Entry;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import javax.xml.parsers.ParserConfigurationException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.openhab.binding.insteon.internal.config.InsteonChannelConfiguration;\n+import org.openhab.binding.insteon.internal.config.InsteonNetworkConfiguration;\n+import org.openhab.binding.insteon.internal.device.DeviceFeature;\n+import org.openhab.binding.insteon.internal.device.DeviceFeatureListener;\n+import org.openhab.binding.insteon.internal.device.DeviceType;\n+import org.openhab.binding.insteon.internal.device.DeviceTypeLoader;\n+import org.openhab.binding.insteon.internal.device.InsteonAddress;\n+import org.openhab.binding.insteon.internal.device.InsteonDevice;\n+import org.openhab.binding.insteon.internal.device.InsteonDevice.DeviceStatus;\n+import org.openhab.binding.insteon.internal.device.RequestQueueManager;\n+import org.openhab.binding.insteon.internal.driver.Driver;\n+import org.openhab.binding.insteon.internal.driver.DriverListener;\n+import org.openhab.binding.insteon.internal.driver.ModemDBEntry;\n+import org.openhab.binding.insteon.internal.driver.Poller;\n+import org.openhab.binding.insteon.internal.handler.InsteonNetworkHandler;\n+import org.openhab.binding.insteon.internal.message.FieldException;\n+import org.openhab.binding.insteon.internal.message.Msg;\n+import org.openhab.binding.insteon.internal.message.MsgListener;\n+import org.openhab.binding.insteon.internal.utils.Utils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.xml.sax.SAXException;\n+\n+/**\n+ * A majority of the code in this file is from the openHAB 1 binding\n+ * org.openhab.binding.insteonplm.InsteonPLMActiveBinding. Including the comments below.\n+ *\n+ * -----------------------------------------------------------------------------------------------\n+ *\n+ * This class represents the actual implementation of the binding, and controls the high level flow\n+ * of messages to and from the InsteonModem.\n+ *\n+ * Writing this binding has been an odyssey through the quirks of the Insteon protocol\n+ * and Insteon devices. A substantial redesign was necessary at some point along the way.\n+ * Here are some of the hard learned lessons that should be considered by anyone who wants\n+ * to re-architect the binding:\n+ *\n+ * 1) The entries of the link database of the modem are not reliable. The category/subcategory entries in\n+ * particular have junk data. Forget about using the modem database to generate a list of devices.\n+ * The database should only be used to verify that a device has been linked.\n+ *\n+ * 2) Querying devices for their product information does not work either. First of all, battery operated devices\n+ * (and there are a lot of those) have their radio switched off, and may generally not respond to product\n+ * queries. Even main stream hardwired devices sold presently (like the 2477s switch and the 2477d dimmer)\n+ * don't even have a product ID. Although supposedly part of the Insteon protocol, we have yet to\n+ * encounter a device that would cough up a product id when queried, even among very recent devices. They\n+ * simply return zeros as product id. Lesson: forget about querying devices to generate a device list.\n+ *\n+ * 3) Polling is a thorny issue: too much traffic on the network, and messages will be dropped left and right,\n+ * and not just the poll related ones, but others as well. In particular sending back-to-back messages\n+ * seemed to result in the second message simply never getting sent, without flow control back pressure\n+ * (NACK) from the modem. For now the work-around is to space out the messages upon sending, and\n+ * in general poll as infrequently as acceptable.\n+ *\n+ * 4) Instantiating and tracking devices when reported by the modem (either from the database, or when\n+ * messages are received) leads to complicated state management because there is no guarantee at what\n+ * point (if at all) the binding configuration will be available. It gets even more difficult when\n+ * items are created, destroyed, and modified while the binding runs.\n+ *\n+ * For the above reasons, devices are only instantiated when they are referenced by binding information.\n+ * As nice as it would be to discover devices and their properties dynamically, we have abandoned that\n+ * path because it had led to a complicated and fragile system which due to the technical limitations\n+ * above was inherently squirrely.\n+ *\n+ *\n+ * @author Bernd Pfrommer - Initial contribution\n+ * @author Daniel Pfrommer - openHAB 1 insteonplm binding\n+ * @author Rob Nielsen - Port to openHAB 2 insteon binding\n+ */\n+@NonNullByDefault\n+@SuppressWarnings({ \"null\", \"unused\" })\n+public class InsteonBinding {\n+    private static final int DEAD_DEVICE_COUNT = 10;\n+\n+    private final Logger logger = LoggerFactory.getLogger(InsteonBinding.class);\n+\n+    private Driver driver = new Driver();\n+    private ConcurrentHashMap<InsteonAddress, InsteonDevice> devices = new ConcurrentHashMap<>();\n+    private ConcurrentHashMap<String, InsteonChannelConfiguration> bindingConfigs = new ConcurrentHashMap<>();\n+    private PortListener portListener = new PortListener();\n+    private int devicePollIntervalMilliseconds = 300000;\n+    private int deadDeviceTimeout = -1;\n+    private int messagesReceived = 0;\n+    private boolean isActive = false; // state of binding\n+    private int x10HouseUnit = -1;\n+    private InsteonNetworkHandler handler;\n+\n+    public InsteonBinding(InsteonNetworkHandler handler, @Nullable InsteonNetworkConfiguration config,\n+            @Nullable SerialPortManager serialPortManager) {\n+        this.handler = handler;\n+\n+        Integer devicePollIntervalSeconds = config.getDevicePollIntervalSeconds();\n+        if (devicePollIntervalSeconds != null) {\n+            devicePollIntervalMilliseconds = devicePollIntervalSeconds * 1000;\n+        }\n+        logger.debug(\"device poll interval set to {} seconds\", devicePollIntervalMilliseconds / 1000);\n+\n+        Integer modemDbRetryTimeoutSeconds = config.getModemDbRetryTimeoutSeconds();\n+        if (modemDbRetryTimeoutSeconds != null) {\n+            logger.debug(\"setting modem db retry timeout to {} seconds\", modemDbRetryTimeoutSeconds);\n+            driver.setModemDBRetryTimeout(modemDbRetryTimeoutSeconds * 1000);\n+        }\n+\n+        String additionalDevices = config.getAdditionalDevices();\n+        if (additionalDevices != null) {\n+            try {\n+                DeviceTypeLoader.instance().loadDeviceTypesXML(additionalDevices);\n+                logger.debug(\"read additional device definitions from {}\", additionalDevices);\n+            } catch (ParserConfigurationException | SAXException | IOException e) {\n+                logger.warn(\"error reading additional devices from {}\", additionalDevices, e);\n+            }\n+        }\n+\n+        String additionalFeatures = config.getAdditionalFeatures();\n+        if (additionalFeatures != null) {\n+            logger.debug(\"reading additional feature templates from {}\", additionalFeatures);\n+            DeviceFeature.readFeatureTemplates(additionalFeatures);\n+        }\n+\n+        deadDeviceTimeout = devicePollIntervalMilliseconds * DEAD_DEVICE_COUNT;\n+        logger.debug(\"dead device timeout set to {} seconds\", deadDeviceTimeout / 1000);\n+\n+        String port = config.getPort();\n+        logger.info(\"port = '{}'\", Utils.redactPassword(port));\n+        driver.addPort(\"port\", port, serialPortManager);\n+        driver.addMsgListener(portListener, port);\n+\n+        logger.debug(\"setting driver listener\");\n+        driver.setDriverListener(portListener);\n+    }\n+\n+    public boolean startPolling() {\n+        logger.debug(\"starting {} ports\", driver.getNumberOfPorts());\n+\n+        driver.startAllPorts();\n+        logger.debug(\"ports started\");\n+        switch (driver.getNumberOfPorts()) {\n+            case 0:\n+                logger.warn(\"initialization complete, but found no ports!\");\n+                return false;\n+            case 1:\n+                logger.debug(\"initialization complete, found 1 port!\");\n+                break;\n+            default:\n+                logger.warn(\"initialization complete, found {} ports.\", driver.getNumberOfPorts());\n+                break;\n+        }\n+\n+        return true;\n+    }\n+\n+    public void setIsActive(boolean isActive) {\n+        this.isActive = isActive;\n+    }\n+\n+    public void sendCommand(String channelName, Command command) {\n+        if (!isActive) {\n+            logger.debug(\"not ready to handle commands yet, returning.\");\n+            return;\n+        }\n+\n+        InsteonChannelConfiguration bindingConfig = bindingConfigs.get(channelName);\n+        if (bindingConfig == null) {\n+            logger.warn(\"unable to find binding config for channel {}\", channelName);\n+            return;\n+        }\n+\n+        InsteonDevice dev = getDevice(bindingConfig.getAddress());\n+        if (dev == null) {\n+            logger.warn(\"no device found with insteon address {}\", bindingConfig.getAddress());\n+            return;\n+        }\n+\n+        dev.processCommand(driver, bindingConfig, command);\n+\n+        logger.debug(\"found binding config for channel {}\", channelName);\n+    }\n+\n+    public void addFeatureListener(InsteonChannelConfiguration bindingConfig) {\n+        logger.debug(\"adding listener for channel {}\", bindingConfig.getChannelName());\n+\n+        InsteonAddress address = bindingConfig.getAddress();\n+        InsteonDevice dev = getDevice(address);\n+        @Nullable\n+        DeviceFeature f = dev.getFeature(bindingConfig.getFeature());\n+        if (f == null || f.isFeatureGroup()) {\n+            StringBuilder buf = new StringBuilder();\n+            ArrayList<String> names = new ArrayList<>(dev.getFeatures().keySet());\n+            Collections.sort(names);\n+            for (String name : names) {\n+                DeviceFeature feature = dev.getFeature(name);\n+                if (!feature.isFeatureGroup()) {\n+                    if (buf.length() > 0) {\n+                        buf.append(\", \");\n+                    }\n+                    buf.append(name);\n+                }\n+            }\n+\n+            logger.warn(\"channel {} references unknown feature: {}, it will be ignored. Known features for {} are: {}.\",\n+                    bindingConfig.getChannelName(), bindingConfig.getFeature(), bindingConfig.getProductKey(),\n+                    buf.toString());\n+            return;\n+        }\n+\n+        DeviceFeatureListener fl = new DeviceFeatureListener(this, bindingConfig.getChannelUID(),\n+                bindingConfig.getChannelName());\n+        fl.setParameters(bindingConfig.getParameters());\n+        f.addListener(fl);\n+\n+        bindingConfigs.put(bindingConfig.getChannelName(), bindingConfig);\n+    }\n+\n+    public void removeFeatureListener(ChannelUID channelUID) {\n+        String channelName = channelUID.getAsString();\n+\n+        logger.debug(\"removing listener for channel {}\", channelName);\n+\n+        for (Iterator<Entry<InsteonAddress, InsteonDevice>> it = devices.entrySet().iterator(); it.hasNext();) {\n+            InsteonDevice dev = it.next().getValue();\n+            boolean removedListener = dev.removeFeatureListener(channelName);\n+            if (removedListener) {\n+                logger.trace(\"removed feature listener {} from dev {}\", channelName, dev);\n+            }\n+        }\n+    }\n+\n+    public void updateFeatureState(ChannelUID channelUID, State state) {\n+        handler.updateState(channelUID, state);\n+    }\n+\n+    public InsteonDevice makeNewDevice(InsteonAddress addr, String productKey) {\n+        DeviceType dt = DeviceTypeLoader.instance().getDeviceType(productKey);\n+        InsteonDevice dev = InsteonDevice.makeDevice(dt);\n+        dev.setAddress(addr);\n+        dev.setDriver(driver);\n+        dev.addPort(driver.getDefaultPort());\n+        if (!dev.hasValidPollingInterval()) {\n+            dev.setPollInterval(devicePollIntervalMilliseconds);\n+        }\n+        if (driver.isModemDBComplete() && dev.getStatus() != DeviceStatus.POLLING) {\n+            int ndev = checkIfInModemDatabase(dev);\n+            if (dev.hasModemDBEntry()) {\n+                dev.setStatus(DeviceStatus.POLLING);\n+                Poller.instance().startPolling(dev, ndev);\n+            }\n+        }\n+        devices.put(addr, dev);\n+\n+        handler.insteonDeviceWasCreated();\n+\n+        return (dev);\n+    }\n+\n+    public void removeDevice(InsteonAddress addr) {\n+        InsteonDevice dev = devices.remove(addr);\n+        if (dev == null) {\n+            return;\n+        }\n+\n+        if (dev.getStatus() == DeviceStatus.POLLING) {\n+            Poller.instance().stopPolling(dev);\n+        }\n+    }\n+\n+    /**\n+     * Checks if a device is in the modem link database, and, if the database\n+     * is complete, logs a warning if the device is not present\n+     *\n+     * @param dev The device to search for in the modem database\n+     * @return number of devices in modem database\n+     */\n+    private int checkIfInModemDatabase(InsteonDevice dev) {\n+        try {\n+            InsteonAddress addr = dev.getAddress();\n+            HashMap<InsteonAddress, @Nullable ModemDBEntry> dbes = driver.lockModemDBEntries();\n+            if (dbes.containsKey(addr)) {\n+                if (!dev.hasModemDBEntry()) {\n+                    logger.info(\"device {} found in the modem database and {}.\", addr, getLinkInfo(dbes, addr));\n+                    dev.setHasModemDBEntry(true);\n+                }\n+            } else {\n+                if (driver.isModemDBComplete() && !addr.isX10()) {\n+                    logger.warn(\"device {} not found in the modem database. Did you forget to link?\", addr);\n+                }\n+            }\n+            return dbes.size();\n+        } finally {\n+            driver.unlockModemDBEntries();\n+        }\n+    }\n+\n+    /**\n+     * Everything below was copied from Insteon PLM v1\n+     */\n+\n+    /**\n+     * Clean up all state.\n+     */\n+    public void shutdown() {\n+        logger.debug(\"shutting down Insteon bridge\");\n+        driver.stopAllPorts();\n+        devices.clear();\n+        RequestQueueManager.destroyInstance();\n+        Poller.instance().stop();\n+        isActive = false;\n+    }\n+\n+    /**\n+     * Method to find a device by address\n+     *\n+     * @param aAddr the insteon address to search for\n+     * @return reference to the device, or null if not found\n+     */\n+    public @Nullable InsteonDevice getDevice(@Nullable InsteonAddress aAddr) {\n+        InsteonDevice dev = (aAddr == null) ? null : devices.get(aAddr);\n+        return (dev);\n+    }\n+\n+    private String getLinkInfo(HashMap<InsteonAddress, @Nullable ModemDBEntry> dbes, InsteonAddress a) {\n+        ModemDBEntry dbe = dbes.get(a);\n+        ArrayList<Byte> controls = dbe.getControls();\n+        ArrayList<Byte> responds = dbe.getRespondsTo();\n+\n+        StringBuilder buf = new StringBuilder(\"the modem\");\n+        if (!controls.isEmpty()) {\n+            buf.append(\" controls groups [\");\n+            buf.append(toGroupString(controls));\n+            buf.append(\"]\");\n+        }\n+\n+        if (!responds.isEmpty()) {\n+            if (!controls.isEmpty()) {\n+                buf.append(\" and\");\n+            }\n+\n+            buf.append(\" responds to groups [\");\n+            buf.append(toGroupString(responds));\n+            buf.append(\"]\");\n+        }\n+\n+        return buf.toString();\n+    }\n+\n+    private String toGroupString(ArrayList<Byte> group) {\n+        ArrayList<Byte> sorted = new ArrayList<>(group);\n+        Collections.sort(sorted);\n+\n+        StringBuilder buf = new StringBuilder();\n+        for (Byte b : sorted) {\n+            if (buf.length() > 0) {\n+                buf.append(\",\");\n+            }\n+            buf.append(\"0x\");\n+            buf.append(Utils.getHexString(b));\n+        }\n+\n+        return buf.toString();\n+    }\n+\n+    public void logDeviceStatistics() {\n+        String msg = String.format(\"devices: %3d configured, %3d polling, msgs received: %5d\", devices.size(),\n+                Poller.instance().getSizeOfQueue(), messagesReceived);\n+        logger.info(\"{}\", msg);\n+        messagesReceived = 0;\n+        for (InsteonDevice dev : devices.values()) {\n+            if (dev.isModem()) {\n+                continue;\n+            }\n+            if (deadDeviceTimeout > 0 && dev.getPollOverDueTime() > deadDeviceTimeout) {\n+                logger.warn(\"device {} has not responded to polls for {} sec\", dev.toString(),\n+                        dev.getPollOverDueTime() / 3600);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Handles messages that come in from the ports.\n+     * Will only process one message at a time.\n+     */\n+    @NonNullByDefault\n+    private class PortListener implements MsgListener, DriverListener {\n+        @Override\n+        public void msg(Msg msg, String fromPort) {\n+            if (msg.isEcho() || msg.isPureNack()) {\n+                return;\n+            }\n+            messagesReceived++;\n+            logger.debug(\"got msg: {}\", msg);\n+            if (msg.isX10()) {\n+                handleX10Message(msg, fromPort);\n+            } else {\n+                handleInsteonMessage(msg, fromPort);\n+            }\n+\n+        }\n+\n+        @Override\n+        public void driverCompletelyInitialized() {\n+            List<String> missing = new ArrayList<String>();\n+            try {\n+                HashMap<InsteonAddress, @Nullable ModemDBEntry> dbes = driver.lockModemDBEntries();\n+                logger.info(\"modem database has {} entries!\", dbes.size());\n+                if (dbes.isEmpty()) {\n+                    logger.warn(\"the modem link database is empty!\");\n+                }\n+                for (InsteonAddress k : dbes.keySet()) {\n+                    logger.debug(\"modem db entry: {}\", k);\n+                }\n+                HashSet<InsteonAddress> addrs = new HashSet<>();\n+                for (InsteonDevice dev : devices.values()) {\n+                    InsteonAddress a = dev.getAddress();\n+                    if (!dbes.containsKey(a)) {\n+                        if (!a.isX10()) {\n+                            logger.warn(\"device {} not found in the modem database. Did you forget to link?\", a);\n+                        }\n+                    } else {\n+                        if (!dev.hasModemDBEntry()) {\n+                            addrs.add(a);\n+                            logger.info(\"device {} found in the modem database and {}.\", a, getLinkInfo(dbes, a));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "04a9796d14dfbc5f3ff997d872f04b6d03ee411d"}, "originalPosition": 452}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTMxNzE5NQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                    logger.info(\"device {} found in the modem database, but is not configured as a thing and {}.\",\n          \n          \n            \n                                    logger.debug(\"device {} found in the modem database, but is not configured as a thing and {}.\",", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r389317195", "createdAt": "2020-03-07T22:34:42Z", "author": {"login": "kaikreuzer"}, "path": "bundles/org.openhab.binding.insteon/src/main/java/org/openhab/binding/insteon/internal/InsteonBinding.java", "diffHunk": "@@ -0,0 +1,520 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.insteon.internal;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map.Entry;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import javax.xml.parsers.ParserConfigurationException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.openhab.binding.insteon.internal.config.InsteonChannelConfiguration;\n+import org.openhab.binding.insteon.internal.config.InsteonNetworkConfiguration;\n+import org.openhab.binding.insteon.internal.device.DeviceFeature;\n+import org.openhab.binding.insteon.internal.device.DeviceFeatureListener;\n+import org.openhab.binding.insteon.internal.device.DeviceType;\n+import org.openhab.binding.insteon.internal.device.DeviceTypeLoader;\n+import org.openhab.binding.insteon.internal.device.InsteonAddress;\n+import org.openhab.binding.insteon.internal.device.InsteonDevice;\n+import org.openhab.binding.insteon.internal.device.InsteonDevice.DeviceStatus;\n+import org.openhab.binding.insteon.internal.device.RequestQueueManager;\n+import org.openhab.binding.insteon.internal.driver.Driver;\n+import org.openhab.binding.insteon.internal.driver.DriverListener;\n+import org.openhab.binding.insteon.internal.driver.ModemDBEntry;\n+import org.openhab.binding.insteon.internal.driver.Poller;\n+import org.openhab.binding.insteon.internal.handler.InsteonNetworkHandler;\n+import org.openhab.binding.insteon.internal.message.FieldException;\n+import org.openhab.binding.insteon.internal.message.Msg;\n+import org.openhab.binding.insteon.internal.message.MsgListener;\n+import org.openhab.binding.insteon.internal.utils.Utils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.xml.sax.SAXException;\n+\n+/**\n+ * A majority of the code in this file is from the openHAB 1 binding\n+ * org.openhab.binding.insteonplm.InsteonPLMActiveBinding. Including the comments below.\n+ *\n+ * -----------------------------------------------------------------------------------------------\n+ *\n+ * This class represents the actual implementation of the binding, and controls the high level flow\n+ * of messages to and from the InsteonModem.\n+ *\n+ * Writing this binding has been an odyssey through the quirks of the Insteon protocol\n+ * and Insteon devices. A substantial redesign was necessary at some point along the way.\n+ * Here are some of the hard learned lessons that should be considered by anyone who wants\n+ * to re-architect the binding:\n+ *\n+ * 1) The entries of the link database of the modem are not reliable. The category/subcategory entries in\n+ * particular have junk data. Forget about using the modem database to generate a list of devices.\n+ * The database should only be used to verify that a device has been linked.\n+ *\n+ * 2) Querying devices for their product information does not work either. First of all, battery operated devices\n+ * (and there are a lot of those) have their radio switched off, and may generally not respond to product\n+ * queries. Even main stream hardwired devices sold presently (like the 2477s switch and the 2477d dimmer)\n+ * don't even have a product ID. Although supposedly part of the Insteon protocol, we have yet to\n+ * encounter a device that would cough up a product id when queried, even among very recent devices. They\n+ * simply return zeros as product id. Lesson: forget about querying devices to generate a device list.\n+ *\n+ * 3) Polling is a thorny issue: too much traffic on the network, and messages will be dropped left and right,\n+ * and not just the poll related ones, but others as well. In particular sending back-to-back messages\n+ * seemed to result in the second message simply never getting sent, without flow control back pressure\n+ * (NACK) from the modem. For now the work-around is to space out the messages upon sending, and\n+ * in general poll as infrequently as acceptable.\n+ *\n+ * 4) Instantiating and tracking devices when reported by the modem (either from the database, or when\n+ * messages are received) leads to complicated state management because there is no guarantee at what\n+ * point (if at all) the binding configuration will be available. It gets even more difficult when\n+ * items are created, destroyed, and modified while the binding runs.\n+ *\n+ * For the above reasons, devices are only instantiated when they are referenced by binding information.\n+ * As nice as it would be to discover devices and their properties dynamically, we have abandoned that\n+ * path because it had led to a complicated and fragile system which due to the technical limitations\n+ * above was inherently squirrely.\n+ *\n+ *\n+ * @author Bernd Pfrommer - Initial contribution\n+ * @author Daniel Pfrommer - openHAB 1 insteonplm binding\n+ * @author Rob Nielsen - Port to openHAB 2 insteon binding\n+ */\n+@NonNullByDefault\n+@SuppressWarnings({ \"null\", \"unused\" })\n+public class InsteonBinding {\n+    private static final int DEAD_DEVICE_COUNT = 10;\n+\n+    private final Logger logger = LoggerFactory.getLogger(InsteonBinding.class);\n+\n+    private Driver driver = new Driver();\n+    private ConcurrentHashMap<InsteonAddress, InsteonDevice> devices = new ConcurrentHashMap<>();\n+    private ConcurrentHashMap<String, InsteonChannelConfiguration> bindingConfigs = new ConcurrentHashMap<>();\n+    private PortListener portListener = new PortListener();\n+    private int devicePollIntervalMilliseconds = 300000;\n+    private int deadDeviceTimeout = -1;\n+    private int messagesReceived = 0;\n+    private boolean isActive = false; // state of binding\n+    private int x10HouseUnit = -1;\n+    private InsteonNetworkHandler handler;\n+\n+    public InsteonBinding(InsteonNetworkHandler handler, @Nullable InsteonNetworkConfiguration config,\n+            @Nullable SerialPortManager serialPortManager) {\n+        this.handler = handler;\n+\n+        Integer devicePollIntervalSeconds = config.getDevicePollIntervalSeconds();\n+        if (devicePollIntervalSeconds != null) {\n+            devicePollIntervalMilliseconds = devicePollIntervalSeconds * 1000;\n+        }\n+        logger.debug(\"device poll interval set to {} seconds\", devicePollIntervalMilliseconds / 1000);\n+\n+        Integer modemDbRetryTimeoutSeconds = config.getModemDbRetryTimeoutSeconds();\n+        if (modemDbRetryTimeoutSeconds != null) {\n+            logger.debug(\"setting modem db retry timeout to {} seconds\", modemDbRetryTimeoutSeconds);\n+            driver.setModemDBRetryTimeout(modemDbRetryTimeoutSeconds * 1000);\n+        }\n+\n+        String additionalDevices = config.getAdditionalDevices();\n+        if (additionalDevices != null) {\n+            try {\n+                DeviceTypeLoader.instance().loadDeviceTypesXML(additionalDevices);\n+                logger.debug(\"read additional device definitions from {}\", additionalDevices);\n+            } catch (ParserConfigurationException | SAXException | IOException e) {\n+                logger.warn(\"error reading additional devices from {}\", additionalDevices, e);\n+            }\n+        }\n+\n+        String additionalFeatures = config.getAdditionalFeatures();\n+        if (additionalFeatures != null) {\n+            logger.debug(\"reading additional feature templates from {}\", additionalFeatures);\n+            DeviceFeature.readFeatureTemplates(additionalFeatures);\n+        }\n+\n+        deadDeviceTimeout = devicePollIntervalMilliseconds * DEAD_DEVICE_COUNT;\n+        logger.debug(\"dead device timeout set to {} seconds\", deadDeviceTimeout / 1000);\n+\n+        String port = config.getPort();\n+        logger.info(\"port = '{}'\", Utils.redactPassword(port));\n+        driver.addPort(\"port\", port, serialPortManager);\n+        driver.addMsgListener(portListener, port);\n+\n+        logger.debug(\"setting driver listener\");\n+        driver.setDriverListener(portListener);\n+    }\n+\n+    public boolean startPolling() {\n+        logger.debug(\"starting {} ports\", driver.getNumberOfPorts());\n+\n+        driver.startAllPorts();\n+        logger.debug(\"ports started\");\n+        switch (driver.getNumberOfPorts()) {\n+            case 0:\n+                logger.warn(\"initialization complete, but found no ports!\");\n+                return false;\n+            case 1:\n+                logger.debug(\"initialization complete, found 1 port!\");\n+                break;\n+            default:\n+                logger.warn(\"initialization complete, found {} ports.\", driver.getNumberOfPorts());\n+                break;\n+        }\n+\n+        return true;\n+    }\n+\n+    public void setIsActive(boolean isActive) {\n+        this.isActive = isActive;\n+    }\n+\n+    public void sendCommand(String channelName, Command command) {\n+        if (!isActive) {\n+            logger.debug(\"not ready to handle commands yet, returning.\");\n+            return;\n+        }\n+\n+        InsteonChannelConfiguration bindingConfig = bindingConfigs.get(channelName);\n+        if (bindingConfig == null) {\n+            logger.warn(\"unable to find binding config for channel {}\", channelName);\n+            return;\n+        }\n+\n+        InsteonDevice dev = getDevice(bindingConfig.getAddress());\n+        if (dev == null) {\n+            logger.warn(\"no device found with insteon address {}\", bindingConfig.getAddress());\n+            return;\n+        }\n+\n+        dev.processCommand(driver, bindingConfig, command);\n+\n+        logger.debug(\"found binding config for channel {}\", channelName);\n+    }\n+\n+    public void addFeatureListener(InsteonChannelConfiguration bindingConfig) {\n+        logger.debug(\"adding listener for channel {}\", bindingConfig.getChannelName());\n+\n+        InsteonAddress address = bindingConfig.getAddress();\n+        InsteonDevice dev = getDevice(address);\n+        @Nullable\n+        DeviceFeature f = dev.getFeature(bindingConfig.getFeature());\n+        if (f == null || f.isFeatureGroup()) {\n+            StringBuilder buf = new StringBuilder();\n+            ArrayList<String> names = new ArrayList<>(dev.getFeatures().keySet());\n+            Collections.sort(names);\n+            for (String name : names) {\n+                DeviceFeature feature = dev.getFeature(name);\n+                if (!feature.isFeatureGroup()) {\n+                    if (buf.length() > 0) {\n+                        buf.append(\", \");\n+                    }\n+                    buf.append(name);\n+                }\n+            }\n+\n+            logger.warn(\"channel {} references unknown feature: {}, it will be ignored. Known features for {} are: {}.\",\n+                    bindingConfig.getChannelName(), bindingConfig.getFeature(), bindingConfig.getProductKey(),\n+                    buf.toString());\n+            return;\n+        }\n+\n+        DeviceFeatureListener fl = new DeviceFeatureListener(this, bindingConfig.getChannelUID(),\n+                bindingConfig.getChannelName());\n+        fl.setParameters(bindingConfig.getParameters());\n+        f.addListener(fl);\n+\n+        bindingConfigs.put(bindingConfig.getChannelName(), bindingConfig);\n+    }\n+\n+    public void removeFeatureListener(ChannelUID channelUID) {\n+        String channelName = channelUID.getAsString();\n+\n+        logger.debug(\"removing listener for channel {}\", channelName);\n+\n+        for (Iterator<Entry<InsteonAddress, InsteonDevice>> it = devices.entrySet().iterator(); it.hasNext();) {\n+            InsteonDevice dev = it.next().getValue();\n+            boolean removedListener = dev.removeFeatureListener(channelName);\n+            if (removedListener) {\n+                logger.trace(\"removed feature listener {} from dev {}\", channelName, dev);\n+            }\n+        }\n+    }\n+\n+    public void updateFeatureState(ChannelUID channelUID, State state) {\n+        handler.updateState(channelUID, state);\n+    }\n+\n+    public InsteonDevice makeNewDevice(InsteonAddress addr, String productKey) {\n+        DeviceType dt = DeviceTypeLoader.instance().getDeviceType(productKey);\n+        InsteonDevice dev = InsteonDevice.makeDevice(dt);\n+        dev.setAddress(addr);\n+        dev.setDriver(driver);\n+        dev.addPort(driver.getDefaultPort());\n+        if (!dev.hasValidPollingInterval()) {\n+            dev.setPollInterval(devicePollIntervalMilliseconds);\n+        }\n+        if (driver.isModemDBComplete() && dev.getStatus() != DeviceStatus.POLLING) {\n+            int ndev = checkIfInModemDatabase(dev);\n+            if (dev.hasModemDBEntry()) {\n+                dev.setStatus(DeviceStatus.POLLING);\n+                Poller.instance().startPolling(dev, ndev);\n+            }\n+        }\n+        devices.put(addr, dev);\n+\n+        handler.insteonDeviceWasCreated();\n+\n+        return (dev);\n+    }\n+\n+    public void removeDevice(InsteonAddress addr) {\n+        InsteonDevice dev = devices.remove(addr);\n+        if (dev == null) {\n+            return;\n+        }\n+\n+        if (dev.getStatus() == DeviceStatus.POLLING) {\n+            Poller.instance().stopPolling(dev);\n+        }\n+    }\n+\n+    /**\n+     * Checks if a device is in the modem link database, and, if the database\n+     * is complete, logs a warning if the device is not present\n+     *\n+     * @param dev The device to search for in the modem database\n+     * @return number of devices in modem database\n+     */\n+    private int checkIfInModemDatabase(InsteonDevice dev) {\n+        try {\n+            InsteonAddress addr = dev.getAddress();\n+            HashMap<InsteonAddress, @Nullable ModemDBEntry> dbes = driver.lockModemDBEntries();\n+            if (dbes.containsKey(addr)) {\n+                if (!dev.hasModemDBEntry()) {\n+                    logger.info(\"device {} found in the modem database and {}.\", addr, getLinkInfo(dbes, addr));\n+                    dev.setHasModemDBEntry(true);\n+                }\n+            } else {\n+                if (driver.isModemDBComplete() && !addr.isX10()) {\n+                    logger.warn(\"device {} not found in the modem database. Did you forget to link?\", addr);\n+                }\n+            }\n+            return dbes.size();\n+        } finally {\n+            driver.unlockModemDBEntries();\n+        }\n+    }\n+\n+    /**\n+     * Everything below was copied from Insteon PLM v1\n+     */\n+\n+    /**\n+     * Clean up all state.\n+     */\n+    public void shutdown() {\n+        logger.debug(\"shutting down Insteon bridge\");\n+        driver.stopAllPorts();\n+        devices.clear();\n+        RequestQueueManager.destroyInstance();\n+        Poller.instance().stop();\n+        isActive = false;\n+    }\n+\n+    /**\n+     * Method to find a device by address\n+     *\n+     * @param aAddr the insteon address to search for\n+     * @return reference to the device, or null if not found\n+     */\n+    public @Nullable InsteonDevice getDevice(@Nullable InsteonAddress aAddr) {\n+        InsteonDevice dev = (aAddr == null) ? null : devices.get(aAddr);\n+        return (dev);\n+    }\n+\n+    private String getLinkInfo(HashMap<InsteonAddress, @Nullable ModemDBEntry> dbes, InsteonAddress a) {\n+        ModemDBEntry dbe = dbes.get(a);\n+        ArrayList<Byte> controls = dbe.getControls();\n+        ArrayList<Byte> responds = dbe.getRespondsTo();\n+\n+        StringBuilder buf = new StringBuilder(\"the modem\");\n+        if (!controls.isEmpty()) {\n+            buf.append(\" controls groups [\");\n+            buf.append(toGroupString(controls));\n+            buf.append(\"]\");\n+        }\n+\n+        if (!responds.isEmpty()) {\n+            if (!controls.isEmpty()) {\n+                buf.append(\" and\");\n+            }\n+\n+            buf.append(\" responds to groups [\");\n+            buf.append(toGroupString(responds));\n+            buf.append(\"]\");\n+        }\n+\n+        return buf.toString();\n+    }\n+\n+    private String toGroupString(ArrayList<Byte> group) {\n+        ArrayList<Byte> sorted = new ArrayList<>(group);\n+        Collections.sort(sorted);\n+\n+        StringBuilder buf = new StringBuilder();\n+        for (Byte b : sorted) {\n+            if (buf.length() > 0) {\n+                buf.append(\",\");\n+            }\n+            buf.append(\"0x\");\n+            buf.append(Utils.getHexString(b));\n+        }\n+\n+        return buf.toString();\n+    }\n+\n+    public void logDeviceStatistics() {\n+        String msg = String.format(\"devices: %3d configured, %3d polling, msgs received: %5d\", devices.size(),\n+                Poller.instance().getSizeOfQueue(), messagesReceived);\n+        logger.info(\"{}\", msg);\n+        messagesReceived = 0;\n+        for (InsteonDevice dev : devices.values()) {\n+            if (dev.isModem()) {\n+                continue;\n+            }\n+            if (deadDeviceTimeout > 0 && dev.getPollOverDueTime() > deadDeviceTimeout) {\n+                logger.warn(\"device {} has not responded to polls for {} sec\", dev.toString(),\n+                        dev.getPollOverDueTime() / 3600);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Handles messages that come in from the ports.\n+     * Will only process one message at a time.\n+     */\n+    @NonNullByDefault\n+    private class PortListener implements MsgListener, DriverListener {\n+        @Override\n+        public void msg(Msg msg, String fromPort) {\n+            if (msg.isEcho() || msg.isPureNack()) {\n+                return;\n+            }\n+            messagesReceived++;\n+            logger.debug(\"got msg: {}\", msg);\n+            if (msg.isX10()) {\n+                handleX10Message(msg, fromPort);\n+            } else {\n+                handleInsteonMessage(msg, fromPort);\n+            }\n+\n+        }\n+\n+        @Override\n+        public void driverCompletelyInitialized() {\n+            List<String> missing = new ArrayList<String>();\n+            try {\n+                HashMap<InsteonAddress, @Nullable ModemDBEntry> dbes = driver.lockModemDBEntries();\n+                logger.info(\"modem database has {} entries!\", dbes.size());\n+                if (dbes.isEmpty()) {\n+                    logger.warn(\"the modem link database is empty!\");\n+                }\n+                for (InsteonAddress k : dbes.keySet()) {\n+                    logger.debug(\"modem db entry: {}\", k);\n+                }\n+                HashSet<InsteonAddress> addrs = new HashSet<>();\n+                for (InsteonDevice dev : devices.values()) {\n+                    InsteonAddress a = dev.getAddress();\n+                    if (!dbes.containsKey(a)) {\n+                        if (!a.isX10()) {\n+                            logger.warn(\"device {} not found in the modem database. Did you forget to link?\", a);\n+                        }\n+                    } else {\n+                        if (!dev.hasModemDBEntry()) {\n+                            addrs.add(a);\n+                            logger.info(\"device {} found in the modem database and {}.\", a, getLinkInfo(dbes, a));\n+                            dev.setHasModemDBEntry(true);\n+                        }\n+                        if (dev.getStatus() != DeviceStatus.POLLING) {\n+                            Poller.instance().startPolling(dev, dbes.size());\n+                        }\n+                    }\n+                }\n+\n+                for (InsteonAddress k : dbes.keySet()) {\n+                    if (!addrs.contains(k) && !k.equals(dbes.get(k).getPort().getAddress())) {\n+                        logger.info(\"device {} found in the modem database, but is not configured as a thing and {}.\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "04a9796d14dfbc5f3ff997d872f04b6d03ee411d"}, "originalPosition": 463}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTMxNzM2MA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            logger.warn(\"{}: command send i/o error: \", nm(), e);\n          \n          \n            \n                            logger.debug(\"{}: command send i/o error: \", nm(), e);\n          \n      \n    \n    \n  \n\nInstead of logging warnings, you should set the Thing Status to OFFLINE, when the communication didn't work.", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r389317360", "createdAt": "2020-03-07T22:38:04Z", "author": {"login": "kaikreuzer"}, "path": "bundles/org.openhab.binding.insteon/src/main/java/org/openhab/binding/insteon/internal/device/CommandHandler.java", "diffHunk": "@@ -0,0 +1,912 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.insteon.internal.device;\n+\n+import java.io.IOException;\n+import java.lang.reflect.InvocationTargetException;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.Timer;\n+import java.util.TimerTask;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.IncreaseDecreaseType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.openhab.binding.insteon.internal.config.InsteonChannelConfiguration;\n+import org.openhab.binding.insteon.internal.device.DeviceFeatureListener.StateChangeType;\n+import org.openhab.binding.insteon.internal.message.FieldException;\n+import org.openhab.binding.insteon.internal.message.Msg;\n+import org.openhab.binding.insteon.internal.utils.Utils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * A command handler translates an openHAB command into a insteon message\n+ *\n+ * @author Daniel Pfrommer - Initial contribution\n+ * @author Bernd Pfrommer - openHAB 1 insteonplm binding\n+ * @author Rob Nielsen - Port to openHAB 2 insteon binding\n+ */\n+@NonNullByDefault\n+@SuppressWarnings(\"null\")\n+public abstract class CommandHandler {\n+    private static final Logger logger = LoggerFactory.getLogger(CommandHandler.class);\n+    DeviceFeature feature; // related DeviceFeature\n+    @Nullable\n+    HashMap<String, @Nullable String> parameters = new HashMap<>();\n+\n+    /**\n+     * Constructor\n+     *\n+     * @param feature The DeviceFeature for which this command was intended.\n+     *            The openHAB commands are issued on an openhab item. The .items files bind\n+     *            an openHAB item to a DeviceFeature.\n+     */\n+    CommandHandler(DeviceFeature feature) {\n+        this.feature = feature;\n+    }\n+\n+    /**\n+     * Implements what to do when an openHAB command is received\n+     *\n+     * @param config the configuration for the item that generated the command\n+     * @param cmd the openhab command issued\n+     * @param device the Insteon device to which this command applies\n+     */\n+    public abstract void handleCommand(InsteonChannelConfiguration conf, Command cmd, InsteonDevice device);\n+\n+    /**\n+     * Returns parameter as integer\n+     *\n+     * @param key key of parameter\n+     * @param def default\n+     * @return value of parameter\n+     */\n+    protected int getIntParameter(String key, int def) {\n+        String val = parameters.get(key);\n+        if (val == null) {\n+            return (def); // param not found\n+        }\n+        int ret = def;\n+        try {\n+            ret = Utils.strToInt(val);\n+        } catch (NumberFormatException e) {\n+            logger.warn(\"malformed int parameter in command handler: {}\", key);\n+        }\n+        return ret;\n+    }\n+\n+    /**\n+     * Returns parameter as String\n+     *\n+     * @param key key of parameter\n+     * @param def default\n+     * @return value of parameter\n+     */\n+    protected @Nullable String getStringParameter(String key, String def) {\n+        return (parameters.get(key) == null ? def : parameters.get(key));\n+    }\n+\n+    /**\n+     * Shorthand to return class name for logging purposes\n+     *\n+     * @return name of the class\n+     */\n+    protected String nm() {\n+        return (this.getClass().getSimpleName());\n+    }\n+\n+    protected int getMaxLightLevel(InsteonChannelConfiguration conf, int defaultLevel) {\n+        HashMap<String, @Nullable String> params = conf.getParameters();\n+        if (conf.getFeature().contains(\"dimmer\") && params.containsKey(\"dimmermax\")) {\n+            String item = conf.getChannelName();\n+            String dimmerMax = params.get(\"dimmermax\");\n+            try {\n+                int i = Integer.parseInt(dimmerMax);\n+                if (i > 1 && i <= 99) {\n+                    int level = (int) Math.ceil((i * 255.0) / 100); // round up\n+                    if (level < defaultLevel) {\n+                        logger.debug(\"item {}: using dimmermax value of {}\", item, dimmerMax);\n+                        return level;\n+                    }\n+                } else {\n+                    logger.warn(\"item {}: dimmermax must be between 1-99 inclusive: {}\", item, dimmerMax);\n+                }\n+            } catch (NumberFormatException e) {\n+                logger.warn(\"item {}: invalid int value for dimmermax: {}\", item, dimmerMax);\n+            }\n+        }\n+\n+        return defaultLevel;\n+    }\n+\n+    void setParameters(HashMap<String, @Nullable String> hm) {\n+        parameters = hm;\n+    }\n+\n+    /**\n+     * Helper function to extract the group parameter from the binding config,\n+     *\n+     * @param c the binding configuration to test\n+     * @return the value of the \"group\" parameter, or -1 if none\n+     */\n+    protected static int getGroup(InsteonChannelConfiguration c) {\n+        String v = c.getParameters().get(\"group\");\n+        int iv = -1;\n+        try {\n+            iv = (v == null) ? -1 : Utils.strToInt(v);\n+        } catch (NumberFormatException e) {\n+            logger.warn(\"malformed int parameter in for item {}\", c.getChannelName());\n+        }\n+        return iv;\n+    }\n+\n+    @NonNullByDefault\n+    public static class WarnCommandHandler extends CommandHandler {\n+        WarnCommandHandler(DeviceFeature f) {\n+            super(f);\n+        }\n+\n+        @Override\n+        public void handleCommand(InsteonChannelConfiguration conf, Command cmd, InsteonDevice dev) {\n+            logger.warn(\"{}: command {} is not implemented yet!\", nm(), cmd);\n+        }\n+    }\n+\n+    @NonNullByDefault\n+    public static class NoOpCommandHandler extends CommandHandler {\n+        NoOpCommandHandler(DeviceFeature f) {\n+            super(f);\n+        }\n+\n+        @Override\n+        public void handleCommand(InsteonChannelConfiguration conf, Command cmd, InsteonDevice dev) {\n+            // do nothing, not even log\n+        }\n+    }\n+\n+    @NonNullByDefault\n+    public static class LightOnOffCommandHandler extends CommandHandler {\n+        LightOnOffCommandHandler(DeviceFeature f) {\n+            super(f);\n+        }\n+\n+        @Override\n+        public void handleCommand(InsteonChannelConfiguration conf, Command cmd, InsteonDevice dev) {\n+            try {\n+                int ext = getIntParameter(\"ext\", 0);\n+                int direc = 0x00;\n+                int level = 0x00;\n+                Msg m = null;\n+                if (cmd == OnOffType.ON) {\n+                    level = getMaxLightLevel(conf, 0xff);\n+                    direc = 0x11;\n+                    logger.debug(\"{}: sent msg to switch {} to {}\", nm(), dev.getAddress(),\n+                            level == 0xff ? \"on\" : level);\n+                } else if (cmd == OnOffType.OFF) {\n+                    direc = 0x13;\n+                    logger.debug(\"{}: sent msg to switch {} off\", nm(), dev.getAddress());\n+                }\n+                if (ext == 1 || ext == 2) {\n+                    byte[] data = new byte[] { (byte) getIntParameter(\"d1\", 0), (byte) getIntParameter(\"d2\", 0),\n+                            (byte) getIntParameter(\"d3\", 0) };\n+                    m = dev.makeExtendedMessage((byte) 0x0f, (byte) direc, (byte) level, data);\n+                    logger.debug(\"{}: was an extended message for device {}\", nm(), dev.getAddress());\n+                    if (ext == 1) {\n+                        m.setCRC();\n+                    } else if (ext == 2) {\n+                        m.setCRC2();\n+                    }\n+                } else {\n+                    m = dev.makeStandardMessage((byte) 0x0f, (byte) direc, (byte) level, getGroup(conf));\n+                }\n+                logger.debug(\"Sending message to {}\", dev.getAddress());\n+                dev.enqueueMessage(m, feature);\n+                // expect to get a direct ack after this!\n+            } catch (IOException e) {\n+                logger.warn(\"{}: command send i/o error: \", nm(), e);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "04a9796d14dfbc5f3ff997d872f04b6d03ee411d"}, "originalPosition": 221}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTMxNzQxNA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            logger.warn(\"{}: command send i/o error: \", nm(), e);\n          \n          \n            \n                            logger.debug(\"{}: command send i/o error: \", nm(), e);\n          \n      \n    \n    \n  \n\nInstead of logging warnings, you should set the Thing Status to OFFLINE, when the communication didn't work.", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r389317414", "createdAt": "2020-03-07T22:38:47Z", "author": {"login": "kaikreuzer"}, "path": "bundles/org.openhab.binding.insteon/src/main/java/org/openhab/binding/insteon/internal/device/CommandHandler.java", "diffHunk": "@@ -0,0 +1,912 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.insteon.internal.device;\n+\n+import java.io.IOException;\n+import java.lang.reflect.InvocationTargetException;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.Timer;\n+import java.util.TimerTask;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.IncreaseDecreaseType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.openhab.binding.insteon.internal.config.InsteonChannelConfiguration;\n+import org.openhab.binding.insteon.internal.device.DeviceFeatureListener.StateChangeType;\n+import org.openhab.binding.insteon.internal.message.FieldException;\n+import org.openhab.binding.insteon.internal.message.Msg;\n+import org.openhab.binding.insteon.internal.utils.Utils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * A command handler translates an openHAB command into a insteon message\n+ *\n+ * @author Daniel Pfrommer - Initial contribution\n+ * @author Bernd Pfrommer - openHAB 1 insteonplm binding\n+ * @author Rob Nielsen - Port to openHAB 2 insteon binding\n+ */\n+@NonNullByDefault\n+@SuppressWarnings(\"null\")\n+public abstract class CommandHandler {\n+    private static final Logger logger = LoggerFactory.getLogger(CommandHandler.class);\n+    DeviceFeature feature; // related DeviceFeature\n+    @Nullable\n+    HashMap<String, @Nullable String> parameters = new HashMap<>();\n+\n+    /**\n+     * Constructor\n+     *\n+     * @param feature The DeviceFeature for which this command was intended.\n+     *            The openHAB commands are issued on an openhab item. The .items files bind\n+     *            an openHAB item to a DeviceFeature.\n+     */\n+    CommandHandler(DeviceFeature feature) {\n+        this.feature = feature;\n+    }\n+\n+    /**\n+     * Implements what to do when an openHAB command is received\n+     *\n+     * @param config the configuration for the item that generated the command\n+     * @param cmd the openhab command issued\n+     * @param device the Insteon device to which this command applies\n+     */\n+    public abstract void handleCommand(InsteonChannelConfiguration conf, Command cmd, InsteonDevice device);\n+\n+    /**\n+     * Returns parameter as integer\n+     *\n+     * @param key key of parameter\n+     * @param def default\n+     * @return value of parameter\n+     */\n+    protected int getIntParameter(String key, int def) {\n+        String val = parameters.get(key);\n+        if (val == null) {\n+            return (def); // param not found\n+        }\n+        int ret = def;\n+        try {\n+            ret = Utils.strToInt(val);\n+        } catch (NumberFormatException e) {\n+            logger.warn(\"malformed int parameter in command handler: {}\", key);\n+        }\n+        return ret;\n+    }\n+\n+    /**\n+     * Returns parameter as String\n+     *\n+     * @param key key of parameter\n+     * @param def default\n+     * @return value of parameter\n+     */\n+    protected @Nullable String getStringParameter(String key, String def) {\n+        return (parameters.get(key) == null ? def : parameters.get(key));\n+    }\n+\n+    /**\n+     * Shorthand to return class name for logging purposes\n+     *\n+     * @return name of the class\n+     */\n+    protected String nm() {\n+        return (this.getClass().getSimpleName());\n+    }\n+\n+    protected int getMaxLightLevel(InsteonChannelConfiguration conf, int defaultLevel) {\n+        HashMap<String, @Nullable String> params = conf.getParameters();\n+        if (conf.getFeature().contains(\"dimmer\") && params.containsKey(\"dimmermax\")) {\n+            String item = conf.getChannelName();\n+            String dimmerMax = params.get(\"dimmermax\");\n+            try {\n+                int i = Integer.parseInt(dimmerMax);\n+                if (i > 1 && i <= 99) {\n+                    int level = (int) Math.ceil((i * 255.0) / 100); // round up\n+                    if (level < defaultLevel) {\n+                        logger.debug(\"item {}: using dimmermax value of {}\", item, dimmerMax);\n+                        return level;\n+                    }\n+                } else {\n+                    logger.warn(\"item {}: dimmermax must be between 1-99 inclusive: {}\", item, dimmerMax);\n+                }\n+            } catch (NumberFormatException e) {\n+                logger.warn(\"item {}: invalid int value for dimmermax: {}\", item, dimmerMax);\n+            }\n+        }\n+\n+        return defaultLevel;\n+    }\n+\n+    void setParameters(HashMap<String, @Nullable String> hm) {\n+        parameters = hm;\n+    }\n+\n+    /**\n+     * Helper function to extract the group parameter from the binding config,\n+     *\n+     * @param c the binding configuration to test\n+     * @return the value of the \"group\" parameter, or -1 if none\n+     */\n+    protected static int getGroup(InsteonChannelConfiguration c) {\n+        String v = c.getParameters().get(\"group\");\n+        int iv = -1;\n+        try {\n+            iv = (v == null) ? -1 : Utils.strToInt(v);\n+        } catch (NumberFormatException e) {\n+            logger.warn(\"malformed int parameter in for item {}\", c.getChannelName());\n+        }\n+        return iv;\n+    }\n+\n+    @NonNullByDefault\n+    public static class WarnCommandHandler extends CommandHandler {\n+        WarnCommandHandler(DeviceFeature f) {\n+            super(f);\n+        }\n+\n+        @Override\n+        public void handleCommand(InsteonChannelConfiguration conf, Command cmd, InsteonDevice dev) {\n+            logger.warn(\"{}: command {} is not implemented yet!\", nm(), cmd);\n+        }\n+    }\n+\n+    @NonNullByDefault\n+    public static class NoOpCommandHandler extends CommandHandler {\n+        NoOpCommandHandler(DeviceFeature f) {\n+            super(f);\n+        }\n+\n+        @Override\n+        public void handleCommand(InsteonChannelConfiguration conf, Command cmd, InsteonDevice dev) {\n+            // do nothing, not even log\n+        }\n+    }\n+\n+    @NonNullByDefault\n+    public static class LightOnOffCommandHandler extends CommandHandler {\n+        LightOnOffCommandHandler(DeviceFeature f) {\n+            super(f);\n+        }\n+\n+        @Override\n+        public void handleCommand(InsteonChannelConfiguration conf, Command cmd, InsteonDevice dev) {\n+            try {\n+                int ext = getIntParameter(\"ext\", 0);\n+                int direc = 0x00;\n+                int level = 0x00;\n+                Msg m = null;\n+                if (cmd == OnOffType.ON) {\n+                    level = getMaxLightLevel(conf, 0xff);\n+                    direc = 0x11;\n+                    logger.debug(\"{}: sent msg to switch {} to {}\", nm(), dev.getAddress(),\n+                            level == 0xff ? \"on\" : level);\n+                } else if (cmd == OnOffType.OFF) {\n+                    direc = 0x13;\n+                    logger.debug(\"{}: sent msg to switch {} off\", nm(), dev.getAddress());\n+                }\n+                if (ext == 1 || ext == 2) {\n+                    byte[] data = new byte[] { (byte) getIntParameter(\"d1\", 0), (byte) getIntParameter(\"d2\", 0),\n+                            (byte) getIntParameter(\"d3\", 0) };\n+                    m = dev.makeExtendedMessage((byte) 0x0f, (byte) direc, (byte) level, data);\n+                    logger.debug(\"{}: was an extended message for device {}\", nm(), dev.getAddress());\n+                    if (ext == 1) {\n+                        m.setCRC();\n+                    } else if (ext == 2) {\n+                        m.setCRC2();\n+                    }\n+                } else {\n+                    m = dev.makeStandardMessage((byte) 0x0f, (byte) direc, (byte) level, getGroup(conf));\n+                }\n+                logger.debug(\"Sending message to {}\", dev.getAddress());\n+                dev.enqueueMessage(m, feature);\n+                // expect to get a direct ack after this!\n+            } catch (IOException e) {\n+                logger.warn(\"{}: command send i/o error: \", nm(), e);\n+            } catch (FieldException e) {\n+                logger.warn(\"{}: command send message creation error \", nm(), e);\n+            }\n+        }\n+    }\n+\n+    @NonNullByDefault\n+    public static class FastOnOffCommandHandler extends CommandHandler {\n+        FastOnOffCommandHandler(DeviceFeature f) {\n+            super(f);\n+        }\n+\n+        @Override\n+        public void handleCommand(InsteonChannelConfiguration conf, Command cmd, InsteonDevice dev) {\n+            try {\n+                if (cmd == OnOffType.ON) {\n+                    int level = getMaxLightLevel(conf, 0xff);\n+                    Msg m = dev.makeStandardMessage((byte) 0x0f, (byte) 0x12, (byte) level, getGroup(conf));\n+                    dev.enqueueMessage(m, feature);\n+                    logger.debug(\"{}: sent fast on to switch {} level {}\", nm(), dev.getAddress(),\n+                            level == 0xff ? \"on\" : level);\n+                } else if (cmd == OnOffType.OFF) {\n+                    Msg m = dev.makeStandardMessage((byte) 0x0f, (byte) 0x14, (byte) 0x00, getGroup(conf));\n+                    dev.enqueueMessage(m, feature);\n+                    logger.debug(\"{}: sent fast off to switch {}\", nm(), dev.getAddress());\n+                }\n+                // expect to get a direct ack after this!\n+            } catch (IOException e) {\n+                logger.warn(\"{}: command send i/o error: \", nm(), e);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "04a9796d14dfbc5f3ff997d872f04b6d03ee411d"}, "originalPosition": 250}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTMxNzQyNQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            logger.warn(\"{}: command send i/o error: \", nm(), e);\n          \n          \n            \n                            logger.debug(\"{}: command send i/o error: \", nm(), e);\n          \n      \n    \n    \n  \n\nInstead of logging warnings, you should set the Thing Status to OFFLINE, when the communication didn't work.", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r389317425", "createdAt": "2020-03-07T22:39:02Z", "author": {"login": "kaikreuzer"}, "path": "bundles/org.openhab.binding.insteon/src/main/java/org/openhab/binding/insteon/internal/device/CommandHandler.java", "diffHunk": "@@ -0,0 +1,912 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.insteon.internal.device;\n+\n+import java.io.IOException;\n+import java.lang.reflect.InvocationTargetException;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.Timer;\n+import java.util.TimerTask;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.IncreaseDecreaseType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.openhab.binding.insteon.internal.config.InsteonChannelConfiguration;\n+import org.openhab.binding.insteon.internal.device.DeviceFeatureListener.StateChangeType;\n+import org.openhab.binding.insteon.internal.message.FieldException;\n+import org.openhab.binding.insteon.internal.message.Msg;\n+import org.openhab.binding.insteon.internal.utils.Utils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * A command handler translates an openHAB command into a insteon message\n+ *\n+ * @author Daniel Pfrommer - Initial contribution\n+ * @author Bernd Pfrommer - openHAB 1 insteonplm binding\n+ * @author Rob Nielsen - Port to openHAB 2 insteon binding\n+ */\n+@NonNullByDefault\n+@SuppressWarnings(\"null\")\n+public abstract class CommandHandler {\n+    private static final Logger logger = LoggerFactory.getLogger(CommandHandler.class);\n+    DeviceFeature feature; // related DeviceFeature\n+    @Nullable\n+    HashMap<String, @Nullable String> parameters = new HashMap<>();\n+\n+    /**\n+     * Constructor\n+     *\n+     * @param feature The DeviceFeature for which this command was intended.\n+     *            The openHAB commands are issued on an openhab item. The .items files bind\n+     *            an openHAB item to a DeviceFeature.\n+     */\n+    CommandHandler(DeviceFeature feature) {\n+        this.feature = feature;\n+    }\n+\n+    /**\n+     * Implements what to do when an openHAB command is received\n+     *\n+     * @param config the configuration for the item that generated the command\n+     * @param cmd the openhab command issued\n+     * @param device the Insteon device to which this command applies\n+     */\n+    public abstract void handleCommand(InsteonChannelConfiguration conf, Command cmd, InsteonDevice device);\n+\n+    /**\n+     * Returns parameter as integer\n+     *\n+     * @param key key of parameter\n+     * @param def default\n+     * @return value of parameter\n+     */\n+    protected int getIntParameter(String key, int def) {\n+        String val = parameters.get(key);\n+        if (val == null) {\n+            return (def); // param not found\n+        }\n+        int ret = def;\n+        try {\n+            ret = Utils.strToInt(val);\n+        } catch (NumberFormatException e) {\n+            logger.warn(\"malformed int parameter in command handler: {}\", key);\n+        }\n+        return ret;\n+    }\n+\n+    /**\n+     * Returns parameter as String\n+     *\n+     * @param key key of parameter\n+     * @param def default\n+     * @return value of parameter\n+     */\n+    protected @Nullable String getStringParameter(String key, String def) {\n+        return (parameters.get(key) == null ? def : parameters.get(key));\n+    }\n+\n+    /**\n+     * Shorthand to return class name for logging purposes\n+     *\n+     * @return name of the class\n+     */\n+    protected String nm() {\n+        return (this.getClass().getSimpleName());\n+    }\n+\n+    protected int getMaxLightLevel(InsteonChannelConfiguration conf, int defaultLevel) {\n+        HashMap<String, @Nullable String> params = conf.getParameters();\n+        if (conf.getFeature().contains(\"dimmer\") && params.containsKey(\"dimmermax\")) {\n+            String item = conf.getChannelName();\n+            String dimmerMax = params.get(\"dimmermax\");\n+            try {\n+                int i = Integer.parseInt(dimmerMax);\n+                if (i > 1 && i <= 99) {\n+                    int level = (int) Math.ceil((i * 255.0) / 100); // round up\n+                    if (level < defaultLevel) {\n+                        logger.debug(\"item {}: using dimmermax value of {}\", item, dimmerMax);\n+                        return level;\n+                    }\n+                } else {\n+                    logger.warn(\"item {}: dimmermax must be between 1-99 inclusive: {}\", item, dimmerMax);\n+                }\n+            } catch (NumberFormatException e) {\n+                logger.warn(\"item {}: invalid int value for dimmermax: {}\", item, dimmerMax);\n+            }\n+        }\n+\n+        return defaultLevel;\n+    }\n+\n+    void setParameters(HashMap<String, @Nullable String> hm) {\n+        parameters = hm;\n+    }\n+\n+    /**\n+     * Helper function to extract the group parameter from the binding config,\n+     *\n+     * @param c the binding configuration to test\n+     * @return the value of the \"group\" parameter, or -1 if none\n+     */\n+    protected static int getGroup(InsteonChannelConfiguration c) {\n+        String v = c.getParameters().get(\"group\");\n+        int iv = -1;\n+        try {\n+            iv = (v == null) ? -1 : Utils.strToInt(v);\n+        } catch (NumberFormatException e) {\n+            logger.warn(\"malformed int parameter in for item {}\", c.getChannelName());\n+        }\n+        return iv;\n+    }\n+\n+    @NonNullByDefault\n+    public static class WarnCommandHandler extends CommandHandler {\n+        WarnCommandHandler(DeviceFeature f) {\n+            super(f);\n+        }\n+\n+        @Override\n+        public void handleCommand(InsteonChannelConfiguration conf, Command cmd, InsteonDevice dev) {\n+            logger.warn(\"{}: command {} is not implemented yet!\", nm(), cmd);\n+        }\n+    }\n+\n+    @NonNullByDefault\n+    public static class NoOpCommandHandler extends CommandHandler {\n+        NoOpCommandHandler(DeviceFeature f) {\n+            super(f);\n+        }\n+\n+        @Override\n+        public void handleCommand(InsteonChannelConfiguration conf, Command cmd, InsteonDevice dev) {\n+            // do nothing, not even log\n+        }\n+    }\n+\n+    @NonNullByDefault\n+    public static class LightOnOffCommandHandler extends CommandHandler {\n+        LightOnOffCommandHandler(DeviceFeature f) {\n+            super(f);\n+        }\n+\n+        @Override\n+        public void handleCommand(InsteonChannelConfiguration conf, Command cmd, InsteonDevice dev) {\n+            try {\n+                int ext = getIntParameter(\"ext\", 0);\n+                int direc = 0x00;\n+                int level = 0x00;\n+                Msg m = null;\n+                if (cmd == OnOffType.ON) {\n+                    level = getMaxLightLevel(conf, 0xff);\n+                    direc = 0x11;\n+                    logger.debug(\"{}: sent msg to switch {} to {}\", nm(), dev.getAddress(),\n+                            level == 0xff ? \"on\" : level);\n+                } else if (cmd == OnOffType.OFF) {\n+                    direc = 0x13;\n+                    logger.debug(\"{}: sent msg to switch {} off\", nm(), dev.getAddress());\n+                }\n+                if (ext == 1 || ext == 2) {\n+                    byte[] data = new byte[] { (byte) getIntParameter(\"d1\", 0), (byte) getIntParameter(\"d2\", 0),\n+                            (byte) getIntParameter(\"d3\", 0) };\n+                    m = dev.makeExtendedMessage((byte) 0x0f, (byte) direc, (byte) level, data);\n+                    logger.debug(\"{}: was an extended message for device {}\", nm(), dev.getAddress());\n+                    if (ext == 1) {\n+                        m.setCRC();\n+                    } else if (ext == 2) {\n+                        m.setCRC2();\n+                    }\n+                } else {\n+                    m = dev.makeStandardMessage((byte) 0x0f, (byte) direc, (byte) level, getGroup(conf));\n+                }\n+                logger.debug(\"Sending message to {}\", dev.getAddress());\n+                dev.enqueueMessage(m, feature);\n+                // expect to get a direct ack after this!\n+            } catch (IOException e) {\n+                logger.warn(\"{}: command send i/o error: \", nm(), e);\n+            } catch (FieldException e) {\n+                logger.warn(\"{}: command send message creation error \", nm(), e);\n+            }\n+        }\n+    }\n+\n+    @NonNullByDefault\n+    public static class FastOnOffCommandHandler extends CommandHandler {\n+        FastOnOffCommandHandler(DeviceFeature f) {\n+            super(f);\n+        }\n+\n+        @Override\n+        public void handleCommand(InsteonChannelConfiguration conf, Command cmd, InsteonDevice dev) {\n+            try {\n+                if (cmd == OnOffType.ON) {\n+                    int level = getMaxLightLevel(conf, 0xff);\n+                    Msg m = dev.makeStandardMessage((byte) 0x0f, (byte) 0x12, (byte) level, getGroup(conf));\n+                    dev.enqueueMessage(m, feature);\n+                    logger.debug(\"{}: sent fast on to switch {} level {}\", nm(), dev.getAddress(),\n+                            level == 0xff ? \"on\" : level);\n+                } else if (cmd == OnOffType.OFF) {\n+                    Msg m = dev.makeStandardMessage((byte) 0x0f, (byte) 0x14, (byte) 0x00, getGroup(conf));\n+                    dev.enqueueMessage(m, feature);\n+                    logger.debug(\"{}: sent fast off to switch {}\", nm(), dev.getAddress());\n+                }\n+                // expect to get a direct ack after this!\n+            } catch (IOException e) {\n+                logger.warn(\"{}: command send i/o error: \", nm(), e);\n+            } catch (FieldException e) {\n+                logger.warn(\"{}: command send message creation error \", nm(), e);\n+            }\n+        }\n+    }\n+\n+    @NonNullByDefault\n+    public static class RampOnOffCommandHandler extends RampCommandHandler {\n+        RampOnOffCommandHandler(DeviceFeature f) {\n+            super(f);\n+        }\n+\n+        @Override\n+        public void handleCommand(InsteonChannelConfiguration conf, Command cmd, InsteonDevice dev) {\n+            try {\n+                if (cmd == OnOffType.ON) {\n+                    double ramptime = getRampTime(conf, 0);\n+                    int ramplevel = getRampLevel(conf, 100);\n+                    byte cmd2 = encode(ramptime, ramplevel);\n+                    Msg m = dev.makeStandardMessage((byte) 0x0f, getOnCmd(), cmd2, getGroup(conf));\n+                    dev.enqueueMessage(m, feature);\n+                    logger.debug(\"{}: sent ramp on to switch {} time {} level {} cmd1 {}\", nm(), dev.getAddress(),\n+                            ramptime, ramplevel, getOnCmd());\n+                } else if (cmd == OnOffType.OFF) {\n+                    double ramptime = getRampTime(conf, 0);\n+                    int ramplevel = getRampLevel(conf, 0 /* ignored */);\n+                    byte cmd2 = encode(ramptime, ramplevel);\n+                    Msg m = dev.makeStandardMessage((byte) 0x0f, getOffCmd(), cmd2, getGroup(conf));\n+                    dev.enqueueMessage(m, feature);\n+                    logger.debug(\"{}: sent ramp off to switch {} time {} cmd1 {}\", nm(), dev.getAddress(), ramptime,\n+                            getOffCmd());\n+                }\n+                // expect to get a direct ack after this!\n+            } catch (IOException e) {\n+                logger.warn(\"{}: command send i/o error: \", nm(), e);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "04a9796d14dfbc5f3ff997d872f04b6d03ee411d"}, "originalPosition": 285}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTMxNzQzOQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            logger.warn(\"{}: command send i/o error: \", nm(), e);\n          \n          \n            \n                            logger.debug(\"{}: command send i/o error: \", nm(), e);\n          \n      \n    \n    \n  \n\nInstead of logging warnings, you should set the Thing Status to OFFLINE, when the communication didn't work.", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r389317439", "createdAt": "2020-03-07T22:39:22Z", "author": {"login": "kaikreuzer"}, "path": "bundles/org.openhab.binding.insteon/src/main/java/org/openhab/binding/insteon/internal/device/CommandHandler.java", "diffHunk": "@@ -0,0 +1,912 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.insteon.internal.device;\n+\n+import java.io.IOException;\n+import java.lang.reflect.InvocationTargetException;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.Timer;\n+import java.util.TimerTask;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.IncreaseDecreaseType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.openhab.binding.insteon.internal.config.InsteonChannelConfiguration;\n+import org.openhab.binding.insteon.internal.device.DeviceFeatureListener.StateChangeType;\n+import org.openhab.binding.insteon.internal.message.FieldException;\n+import org.openhab.binding.insteon.internal.message.Msg;\n+import org.openhab.binding.insteon.internal.utils.Utils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * A command handler translates an openHAB command into a insteon message\n+ *\n+ * @author Daniel Pfrommer - Initial contribution\n+ * @author Bernd Pfrommer - openHAB 1 insteonplm binding\n+ * @author Rob Nielsen - Port to openHAB 2 insteon binding\n+ */\n+@NonNullByDefault\n+@SuppressWarnings(\"null\")\n+public abstract class CommandHandler {\n+    private static final Logger logger = LoggerFactory.getLogger(CommandHandler.class);\n+    DeviceFeature feature; // related DeviceFeature\n+    @Nullable\n+    HashMap<String, @Nullable String> parameters = new HashMap<>();\n+\n+    /**\n+     * Constructor\n+     *\n+     * @param feature The DeviceFeature for which this command was intended.\n+     *            The openHAB commands are issued on an openhab item. The .items files bind\n+     *            an openHAB item to a DeviceFeature.\n+     */\n+    CommandHandler(DeviceFeature feature) {\n+        this.feature = feature;\n+    }\n+\n+    /**\n+     * Implements what to do when an openHAB command is received\n+     *\n+     * @param config the configuration for the item that generated the command\n+     * @param cmd the openhab command issued\n+     * @param device the Insteon device to which this command applies\n+     */\n+    public abstract void handleCommand(InsteonChannelConfiguration conf, Command cmd, InsteonDevice device);\n+\n+    /**\n+     * Returns parameter as integer\n+     *\n+     * @param key key of parameter\n+     * @param def default\n+     * @return value of parameter\n+     */\n+    protected int getIntParameter(String key, int def) {\n+        String val = parameters.get(key);\n+        if (val == null) {\n+            return (def); // param not found\n+        }\n+        int ret = def;\n+        try {\n+            ret = Utils.strToInt(val);\n+        } catch (NumberFormatException e) {\n+            logger.warn(\"malformed int parameter in command handler: {}\", key);\n+        }\n+        return ret;\n+    }\n+\n+    /**\n+     * Returns parameter as String\n+     *\n+     * @param key key of parameter\n+     * @param def default\n+     * @return value of parameter\n+     */\n+    protected @Nullable String getStringParameter(String key, String def) {\n+        return (parameters.get(key) == null ? def : parameters.get(key));\n+    }\n+\n+    /**\n+     * Shorthand to return class name for logging purposes\n+     *\n+     * @return name of the class\n+     */\n+    protected String nm() {\n+        return (this.getClass().getSimpleName());\n+    }\n+\n+    protected int getMaxLightLevel(InsteonChannelConfiguration conf, int defaultLevel) {\n+        HashMap<String, @Nullable String> params = conf.getParameters();\n+        if (conf.getFeature().contains(\"dimmer\") && params.containsKey(\"dimmermax\")) {\n+            String item = conf.getChannelName();\n+            String dimmerMax = params.get(\"dimmermax\");\n+            try {\n+                int i = Integer.parseInt(dimmerMax);\n+                if (i > 1 && i <= 99) {\n+                    int level = (int) Math.ceil((i * 255.0) / 100); // round up\n+                    if (level < defaultLevel) {\n+                        logger.debug(\"item {}: using dimmermax value of {}\", item, dimmerMax);\n+                        return level;\n+                    }\n+                } else {\n+                    logger.warn(\"item {}: dimmermax must be between 1-99 inclusive: {}\", item, dimmerMax);\n+                }\n+            } catch (NumberFormatException e) {\n+                logger.warn(\"item {}: invalid int value for dimmermax: {}\", item, dimmerMax);\n+            }\n+        }\n+\n+        return defaultLevel;\n+    }\n+\n+    void setParameters(HashMap<String, @Nullable String> hm) {\n+        parameters = hm;\n+    }\n+\n+    /**\n+     * Helper function to extract the group parameter from the binding config,\n+     *\n+     * @param c the binding configuration to test\n+     * @return the value of the \"group\" parameter, or -1 if none\n+     */\n+    protected static int getGroup(InsteonChannelConfiguration c) {\n+        String v = c.getParameters().get(\"group\");\n+        int iv = -1;\n+        try {\n+            iv = (v == null) ? -1 : Utils.strToInt(v);\n+        } catch (NumberFormatException e) {\n+            logger.warn(\"malformed int parameter in for item {}\", c.getChannelName());\n+        }\n+        return iv;\n+    }\n+\n+    @NonNullByDefault\n+    public static class WarnCommandHandler extends CommandHandler {\n+        WarnCommandHandler(DeviceFeature f) {\n+            super(f);\n+        }\n+\n+        @Override\n+        public void handleCommand(InsteonChannelConfiguration conf, Command cmd, InsteonDevice dev) {\n+            logger.warn(\"{}: command {} is not implemented yet!\", nm(), cmd);\n+        }\n+    }\n+\n+    @NonNullByDefault\n+    public static class NoOpCommandHandler extends CommandHandler {\n+        NoOpCommandHandler(DeviceFeature f) {\n+            super(f);\n+        }\n+\n+        @Override\n+        public void handleCommand(InsteonChannelConfiguration conf, Command cmd, InsteonDevice dev) {\n+            // do nothing, not even log\n+        }\n+    }\n+\n+    @NonNullByDefault\n+    public static class LightOnOffCommandHandler extends CommandHandler {\n+        LightOnOffCommandHandler(DeviceFeature f) {\n+            super(f);\n+        }\n+\n+        @Override\n+        public void handleCommand(InsteonChannelConfiguration conf, Command cmd, InsteonDevice dev) {\n+            try {\n+                int ext = getIntParameter(\"ext\", 0);\n+                int direc = 0x00;\n+                int level = 0x00;\n+                Msg m = null;\n+                if (cmd == OnOffType.ON) {\n+                    level = getMaxLightLevel(conf, 0xff);\n+                    direc = 0x11;\n+                    logger.debug(\"{}: sent msg to switch {} to {}\", nm(), dev.getAddress(),\n+                            level == 0xff ? \"on\" : level);\n+                } else if (cmd == OnOffType.OFF) {\n+                    direc = 0x13;\n+                    logger.debug(\"{}: sent msg to switch {} off\", nm(), dev.getAddress());\n+                }\n+                if (ext == 1 || ext == 2) {\n+                    byte[] data = new byte[] { (byte) getIntParameter(\"d1\", 0), (byte) getIntParameter(\"d2\", 0),\n+                            (byte) getIntParameter(\"d3\", 0) };\n+                    m = dev.makeExtendedMessage((byte) 0x0f, (byte) direc, (byte) level, data);\n+                    logger.debug(\"{}: was an extended message for device {}\", nm(), dev.getAddress());\n+                    if (ext == 1) {\n+                        m.setCRC();\n+                    } else if (ext == 2) {\n+                        m.setCRC2();\n+                    }\n+                } else {\n+                    m = dev.makeStandardMessage((byte) 0x0f, (byte) direc, (byte) level, getGroup(conf));\n+                }\n+                logger.debug(\"Sending message to {}\", dev.getAddress());\n+                dev.enqueueMessage(m, feature);\n+                // expect to get a direct ack after this!\n+            } catch (IOException e) {\n+                logger.warn(\"{}: command send i/o error: \", nm(), e);\n+            } catch (FieldException e) {\n+                logger.warn(\"{}: command send message creation error \", nm(), e);\n+            }\n+        }\n+    }\n+\n+    @NonNullByDefault\n+    public static class FastOnOffCommandHandler extends CommandHandler {\n+        FastOnOffCommandHandler(DeviceFeature f) {\n+            super(f);\n+        }\n+\n+        @Override\n+        public void handleCommand(InsteonChannelConfiguration conf, Command cmd, InsteonDevice dev) {\n+            try {\n+                if (cmd == OnOffType.ON) {\n+                    int level = getMaxLightLevel(conf, 0xff);\n+                    Msg m = dev.makeStandardMessage((byte) 0x0f, (byte) 0x12, (byte) level, getGroup(conf));\n+                    dev.enqueueMessage(m, feature);\n+                    logger.debug(\"{}: sent fast on to switch {} level {}\", nm(), dev.getAddress(),\n+                            level == 0xff ? \"on\" : level);\n+                } else if (cmd == OnOffType.OFF) {\n+                    Msg m = dev.makeStandardMessage((byte) 0x0f, (byte) 0x14, (byte) 0x00, getGroup(conf));\n+                    dev.enqueueMessage(m, feature);\n+                    logger.debug(\"{}: sent fast off to switch {}\", nm(), dev.getAddress());\n+                }\n+                // expect to get a direct ack after this!\n+            } catch (IOException e) {\n+                logger.warn(\"{}: command send i/o error: \", nm(), e);\n+            } catch (FieldException e) {\n+                logger.warn(\"{}: command send message creation error \", nm(), e);\n+            }\n+        }\n+    }\n+\n+    @NonNullByDefault\n+    public static class RampOnOffCommandHandler extends RampCommandHandler {\n+        RampOnOffCommandHandler(DeviceFeature f) {\n+            super(f);\n+        }\n+\n+        @Override\n+        public void handleCommand(InsteonChannelConfiguration conf, Command cmd, InsteonDevice dev) {\n+            try {\n+                if (cmd == OnOffType.ON) {\n+                    double ramptime = getRampTime(conf, 0);\n+                    int ramplevel = getRampLevel(conf, 100);\n+                    byte cmd2 = encode(ramptime, ramplevel);\n+                    Msg m = dev.makeStandardMessage((byte) 0x0f, getOnCmd(), cmd2, getGroup(conf));\n+                    dev.enqueueMessage(m, feature);\n+                    logger.debug(\"{}: sent ramp on to switch {} time {} level {} cmd1 {}\", nm(), dev.getAddress(),\n+                            ramptime, ramplevel, getOnCmd());\n+                } else if (cmd == OnOffType.OFF) {\n+                    double ramptime = getRampTime(conf, 0);\n+                    int ramplevel = getRampLevel(conf, 0 /* ignored */);\n+                    byte cmd2 = encode(ramptime, ramplevel);\n+                    Msg m = dev.makeStandardMessage((byte) 0x0f, getOffCmd(), cmd2, getGroup(conf));\n+                    dev.enqueueMessage(m, feature);\n+                    logger.debug(\"{}: sent ramp off to switch {} time {} cmd1 {}\", nm(), dev.getAddress(), ramptime,\n+                            getOffCmd());\n+                }\n+                // expect to get a direct ack after this!\n+            } catch (IOException e) {\n+                logger.warn(\"{}: command send i/o error: \", nm(), e);\n+            } catch (FieldException e) {\n+                logger.warn(\"{}: command send message creation error \", nm(), e);\n+            }\n+        }\n+\n+        private int getRampLevel(InsteonChannelConfiguration conf, int defaultValue) {\n+            HashMap<String, @Nullable String> params = conf.getParameters();\n+            return params.containsKey(\"ramplevel\") ? Integer.parseInt(params.get(\"ramplevel\")) : defaultValue;\n+        }\n+    }\n+\n+    @NonNullByDefault\n+    public static class ManualChangeCommandHandler extends CommandHandler {\n+        ManualChangeCommandHandler(DeviceFeature f) {\n+            super(f);\n+        }\n+\n+        @Override\n+        public void handleCommand(InsteonChannelConfiguration conf, Command cmd, InsteonDevice dev) {\n+            try {\n+                if (cmd instanceof DecimalType) {\n+                    int v = ((DecimalType) cmd).intValue();\n+                    int cmd1 = (v != 1) ? 0x17 : 0x18; // start or stop\n+                    int cmd2 = (v == 2) ? 0x01 : 0; // up or down\n+                    Msg m = dev.makeStandardMessage((byte) 0x0f, (byte) cmd1, (byte) cmd2, getGroup(conf));\n+                    dev.enqueueMessage(m, feature);\n+                    logger.debug(\"{}: cmd {} sent manual change {} {} to {}\", nm(), v,\n+                            (cmd1 == 0x17) ? \"START\" : \"STOP\", (cmd2 == 0x01) ? \"UP\" : \"DOWN\", dev.getAddress());\n+                } else {\n+                    logger.warn(\"{}: invalid command type: {}\", nm(), cmd);\n+                }\n+            } catch (IOException e) {\n+                logger.warn(\"{}: command send i/o error: \", nm(), e);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "04a9796d14dfbc5f3ff997d872f04b6d03ee411d"}, "originalPosition": 318}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTMxNzQ0OA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            logger.warn(\"{}: command send i/o error: \", nm(), e);\n          \n          \n            \n                            logger.debug(\"{}: command send i/o error: \", nm(), e);\n          \n      \n    \n    \n  \n\nInstead of logging warnings, you should set the Thing Status to OFFLINE, when the communication didn't work.", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r389317448", "createdAt": "2020-03-07T22:39:44Z", "author": {"login": "kaikreuzer"}, "path": "bundles/org.openhab.binding.insteon/src/main/java/org/openhab/binding/insteon/internal/device/CommandHandler.java", "diffHunk": "@@ -0,0 +1,912 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.insteon.internal.device;\n+\n+import java.io.IOException;\n+import java.lang.reflect.InvocationTargetException;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.Timer;\n+import java.util.TimerTask;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.IncreaseDecreaseType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.openhab.binding.insteon.internal.config.InsteonChannelConfiguration;\n+import org.openhab.binding.insteon.internal.device.DeviceFeatureListener.StateChangeType;\n+import org.openhab.binding.insteon.internal.message.FieldException;\n+import org.openhab.binding.insteon.internal.message.Msg;\n+import org.openhab.binding.insteon.internal.utils.Utils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * A command handler translates an openHAB command into a insteon message\n+ *\n+ * @author Daniel Pfrommer - Initial contribution\n+ * @author Bernd Pfrommer - openHAB 1 insteonplm binding\n+ * @author Rob Nielsen - Port to openHAB 2 insteon binding\n+ */\n+@NonNullByDefault\n+@SuppressWarnings(\"null\")\n+public abstract class CommandHandler {\n+    private static final Logger logger = LoggerFactory.getLogger(CommandHandler.class);\n+    DeviceFeature feature; // related DeviceFeature\n+    @Nullable\n+    HashMap<String, @Nullable String> parameters = new HashMap<>();\n+\n+    /**\n+     * Constructor\n+     *\n+     * @param feature The DeviceFeature for which this command was intended.\n+     *            The openHAB commands are issued on an openhab item. The .items files bind\n+     *            an openHAB item to a DeviceFeature.\n+     */\n+    CommandHandler(DeviceFeature feature) {\n+        this.feature = feature;\n+    }\n+\n+    /**\n+     * Implements what to do when an openHAB command is received\n+     *\n+     * @param config the configuration for the item that generated the command\n+     * @param cmd the openhab command issued\n+     * @param device the Insteon device to which this command applies\n+     */\n+    public abstract void handleCommand(InsteonChannelConfiguration conf, Command cmd, InsteonDevice device);\n+\n+    /**\n+     * Returns parameter as integer\n+     *\n+     * @param key key of parameter\n+     * @param def default\n+     * @return value of parameter\n+     */\n+    protected int getIntParameter(String key, int def) {\n+        String val = parameters.get(key);\n+        if (val == null) {\n+            return (def); // param not found\n+        }\n+        int ret = def;\n+        try {\n+            ret = Utils.strToInt(val);\n+        } catch (NumberFormatException e) {\n+            logger.warn(\"malformed int parameter in command handler: {}\", key);\n+        }\n+        return ret;\n+    }\n+\n+    /**\n+     * Returns parameter as String\n+     *\n+     * @param key key of parameter\n+     * @param def default\n+     * @return value of parameter\n+     */\n+    protected @Nullable String getStringParameter(String key, String def) {\n+        return (parameters.get(key) == null ? def : parameters.get(key));\n+    }\n+\n+    /**\n+     * Shorthand to return class name for logging purposes\n+     *\n+     * @return name of the class\n+     */\n+    protected String nm() {\n+        return (this.getClass().getSimpleName());\n+    }\n+\n+    protected int getMaxLightLevel(InsteonChannelConfiguration conf, int defaultLevel) {\n+        HashMap<String, @Nullable String> params = conf.getParameters();\n+        if (conf.getFeature().contains(\"dimmer\") && params.containsKey(\"dimmermax\")) {\n+            String item = conf.getChannelName();\n+            String dimmerMax = params.get(\"dimmermax\");\n+            try {\n+                int i = Integer.parseInt(dimmerMax);\n+                if (i > 1 && i <= 99) {\n+                    int level = (int) Math.ceil((i * 255.0) / 100); // round up\n+                    if (level < defaultLevel) {\n+                        logger.debug(\"item {}: using dimmermax value of {}\", item, dimmerMax);\n+                        return level;\n+                    }\n+                } else {\n+                    logger.warn(\"item {}: dimmermax must be between 1-99 inclusive: {}\", item, dimmerMax);\n+                }\n+            } catch (NumberFormatException e) {\n+                logger.warn(\"item {}: invalid int value for dimmermax: {}\", item, dimmerMax);\n+            }\n+        }\n+\n+        return defaultLevel;\n+    }\n+\n+    void setParameters(HashMap<String, @Nullable String> hm) {\n+        parameters = hm;\n+    }\n+\n+    /**\n+     * Helper function to extract the group parameter from the binding config,\n+     *\n+     * @param c the binding configuration to test\n+     * @return the value of the \"group\" parameter, or -1 if none\n+     */\n+    protected static int getGroup(InsteonChannelConfiguration c) {\n+        String v = c.getParameters().get(\"group\");\n+        int iv = -1;\n+        try {\n+            iv = (v == null) ? -1 : Utils.strToInt(v);\n+        } catch (NumberFormatException e) {\n+            logger.warn(\"malformed int parameter in for item {}\", c.getChannelName());\n+        }\n+        return iv;\n+    }\n+\n+    @NonNullByDefault\n+    public static class WarnCommandHandler extends CommandHandler {\n+        WarnCommandHandler(DeviceFeature f) {\n+            super(f);\n+        }\n+\n+        @Override\n+        public void handleCommand(InsteonChannelConfiguration conf, Command cmd, InsteonDevice dev) {\n+            logger.warn(\"{}: command {} is not implemented yet!\", nm(), cmd);\n+        }\n+    }\n+\n+    @NonNullByDefault\n+    public static class NoOpCommandHandler extends CommandHandler {\n+        NoOpCommandHandler(DeviceFeature f) {\n+            super(f);\n+        }\n+\n+        @Override\n+        public void handleCommand(InsteonChannelConfiguration conf, Command cmd, InsteonDevice dev) {\n+            // do nothing, not even log\n+        }\n+    }\n+\n+    @NonNullByDefault\n+    public static class LightOnOffCommandHandler extends CommandHandler {\n+        LightOnOffCommandHandler(DeviceFeature f) {\n+            super(f);\n+        }\n+\n+        @Override\n+        public void handleCommand(InsteonChannelConfiguration conf, Command cmd, InsteonDevice dev) {\n+            try {\n+                int ext = getIntParameter(\"ext\", 0);\n+                int direc = 0x00;\n+                int level = 0x00;\n+                Msg m = null;\n+                if (cmd == OnOffType.ON) {\n+                    level = getMaxLightLevel(conf, 0xff);\n+                    direc = 0x11;\n+                    logger.debug(\"{}: sent msg to switch {} to {}\", nm(), dev.getAddress(),\n+                            level == 0xff ? \"on\" : level);\n+                } else if (cmd == OnOffType.OFF) {\n+                    direc = 0x13;\n+                    logger.debug(\"{}: sent msg to switch {} off\", nm(), dev.getAddress());\n+                }\n+                if (ext == 1 || ext == 2) {\n+                    byte[] data = new byte[] { (byte) getIntParameter(\"d1\", 0), (byte) getIntParameter(\"d2\", 0),\n+                            (byte) getIntParameter(\"d3\", 0) };\n+                    m = dev.makeExtendedMessage((byte) 0x0f, (byte) direc, (byte) level, data);\n+                    logger.debug(\"{}: was an extended message for device {}\", nm(), dev.getAddress());\n+                    if (ext == 1) {\n+                        m.setCRC();\n+                    } else if (ext == 2) {\n+                        m.setCRC2();\n+                    }\n+                } else {\n+                    m = dev.makeStandardMessage((byte) 0x0f, (byte) direc, (byte) level, getGroup(conf));\n+                }\n+                logger.debug(\"Sending message to {}\", dev.getAddress());\n+                dev.enqueueMessage(m, feature);\n+                // expect to get a direct ack after this!\n+            } catch (IOException e) {\n+                logger.warn(\"{}: command send i/o error: \", nm(), e);\n+            } catch (FieldException e) {\n+                logger.warn(\"{}: command send message creation error \", nm(), e);\n+            }\n+        }\n+    }\n+\n+    @NonNullByDefault\n+    public static class FastOnOffCommandHandler extends CommandHandler {\n+        FastOnOffCommandHandler(DeviceFeature f) {\n+            super(f);\n+        }\n+\n+        @Override\n+        public void handleCommand(InsteonChannelConfiguration conf, Command cmd, InsteonDevice dev) {\n+            try {\n+                if (cmd == OnOffType.ON) {\n+                    int level = getMaxLightLevel(conf, 0xff);\n+                    Msg m = dev.makeStandardMessage((byte) 0x0f, (byte) 0x12, (byte) level, getGroup(conf));\n+                    dev.enqueueMessage(m, feature);\n+                    logger.debug(\"{}: sent fast on to switch {} level {}\", nm(), dev.getAddress(),\n+                            level == 0xff ? \"on\" : level);\n+                } else if (cmd == OnOffType.OFF) {\n+                    Msg m = dev.makeStandardMessage((byte) 0x0f, (byte) 0x14, (byte) 0x00, getGroup(conf));\n+                    dev.enqueueMessage(m, feature);\n+                    logger.debug(\"{}: sent fast off to switch {}\", nm(), dev.getAddress());\n+                }\n+                // expect to get a direct ack after this!\n+            } catch (IOException e) {\n+                logger.warn(\"{}: command send i/o error: \", nm(), e);\n+            } catch (FieldException e) {\n+                logger.warn(\"{}: command send message creation error \", nm(), e);\n+            }\n+        }\n+    }\n+\n+    @NonNullByDefault\n+    public static class RampOnOffCommandHandler extends RampCommandHandler {\n+        RampOnOffCommandHandler(DeviceFeature f) {\n+            super(f);\n+        }\n+\n+        @Override\n+        public void handleCommand(InsteonChannelConfiguration conf, Command cmd, InsteonDevice dev) {\n+            try {\n+                if (cmd == OnOffType.ON) {\n+                    double ramptime = getRampTime(conf, 0);\n+                    int ramplevel = getRampLevel(conf, 100);\n+                    byte cmd2 = encode(ramptime, ramplevel);\n+                    Msg m = dev.makeStandardMessage((byte) 0x0f, getOnCmd(), cmd2, getGroup(conf));\n+                    dev.enqueueMessage(m, feature);\n+                    logger.debug(\"{}: sent ramp on to switch {} time {} level {} cmd1 {}\", nm(), dev.getAddress(),\n+                            ramptime, ramplevel, getOnCmd());\n+                } else if (cmd == OnOffType.OFF) {\n+                    double ramptime = getRampTime(conf, 0);\n+                    int ramplevel = getRampLevel(conf, 0 /* ignored */);\n+                    byte cmd2 = encode(ramptime, ramplevel);\n+                    Msg m = dev.makeStandardMessage((byte) 0x0f, getOffCmd(), cmd2, getGroup(conf));\n+                    dev.enqueueMessage(m, feature);\n+                    logger.debug(\"{}: sent ramp off to switch {} time {} cmd1 {}\", nm(), dev.getAddress(), ramptime,\n+                            getOffCmd());\n+                }\n+                // expect to get a direct ack after this!\n+            } catch (IOException e) {\n+                logger.warn(\"{}: command send i/o error: \", nm(), e);\n+            } catch (FieldException e) {\n+                logger.warn(\"{}: command send message creation error \", nm(), e);\n+            }\n+        }\n+\n+        private int getRampLevel(InsteonChannelConfiguration conf, int defaultValue) {\n+            HashMap<String, @Nullable String> params = conf.getParameters();\n+            return params.containsKey(\"ramplevel\") ? Integer.parseInt(params.get(\"ramplevel\")) : defaultValue;\n+        }\n+    }\n+\n+    @NonNullByDefault\n+    public static class ManualChangeCommandHandler extends CommandHandler {\n+        ManualChangeCommandHandler(DeviceFeature f) {\n+            super(f);\n+        }\n+\n+        @Override\n+        public void handleCommand(InsteonChannelConfiguration conf, Command cmd, InsteonDevice dev) {\n+            try {\n+                if (cmd instanceof DecimalType) {\n+                    int v = ((DecimalType) cmd).intValue();\n+                    int cmd1 = (v != 1) ? 0x17 : 0x18; // start or stop\n+                    int cmd2 = (v == 2) ? 0x01 : 0; // up or down\n+                    Msg m = dev.makeStandardMessage((byte) 0x0f, (byte) cmd1, (byte) cmd2, getGroup(conf));\n+                    dev.enqueueMessage(m, feature);\n+                    logger.debug(\"{}: cmd {} sent manual change {} {} to {}\", nm(), v,\n+                            (cmd1 == 0x17) ? \"START\" : \"STOP\", (cmd2 == 0x01) ? \"UP\" : \"DOWN\", dev.getAddress());\n+                } else {\n+                    logger.warn(\"{}: invalid command type: {}\", nm(), cmd);\n+                }\n+            } catch (IOException e) {\n+                logger.warn(\"{}: command send i/o error: \", nm(), e);\n+            } catch (FieldException e) {\n+                logger.warn(\"{}: command send message creation error \", nm(), e);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Sends ALLLink broadcast commands to group\n+     */\n+    @NonNullByDefault\n+    public static class GroupBroadcastCommandHandler extends CommandHandler {\n+        GroupBroadcastCommandHandler(DeviceFeature f) {\n+            super(f);\n+        }\n+\n+        @Override\n+        public void handleCommand(InsteonChannelConfiguration conf, Command cmd, InsteonDevice dev) {\n+            try {\n+                if (cmd == OnOffType.ON || cmd == OnOffType.OFF) {\n+                    byte cmd1 = (byte) ((cmd == OnOffType.ON) ? 0x11 : 0x13);\n+                    byte value = (byte) ((cmd == OnOffType.ON) ? 0xFF : 0x00);\n+                    int group = getGroup(conf);\n+                    if (group == -1) {\n+                        logger.warn(\"no group=xx specified in item {}\", conf.getChannelName());\n+                        return;\n+                    }\n+                    logger.debug(\"{}: sending {} broadcast to group {}\", nm(), (cmd1 == 0x11) ? \"ON\" : \"OFF\",\n+                            getGroup(conf));\n+                    Msg m = dev.makeStandardMessage((byte) 0x0f, cmd1, value, group);\n+                    dev.enqueueMessage(m, feature);\n+                }\n+            } catch (IOException e) {\n+                logger.warn(\"{}: command send i/o error: \", nm(), e);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "04a9796d14dfbc5f3ff997d872f04b6d03ee411d"}, "originalPosition": 351}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTMxNzQ1Ng==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            logger.warn(\"{}: command send i/o error: \", nm(), e);\n          \n          \n            \n                            logger.debug(\"{}: command send i/o error: \", nm(), e);\n          \n      \n    \n    \n  \n\nInstead of logging warnings, you should set the Thing Status to OFFLINE, when the communication didn't work.", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r389317456", "createdAt": "2020-03-07T22:39:59Z", "author": {"login": "kaikreuzer"}, "path": "bundles/org.openhab.binding.insteon/src/main/java/org/openhab/binding/insteon/internal/device/CommandHandler.java", "diffHunk": "@@ -0,0 +1,912 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.insteon.internal.device;\n+\n+import java.io.IOException;\n+import java.lang.reflect.InvocationTargetException;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.Timer;\n+import java.util.TimerTask;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.IncreaseDecreaseType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.openhab.binding.insteon.internal.config.InsteonChannelConfiguration;\n+import org.openhab.binding.insteon.internal.device.DeviceFeatureListener.StateChangeType;\n+import org.openhab.binding.insteon.internal.message.FieldException;\n+import org.openhab.binding.insteon.internal.message.Msg;\n+import org.openhab.binding.insteon.internal.utils.Utils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * A command handler translates an openHAB command into a insteon message\n+ *\n+ * @author Daniel Pfrommer - Initial contribution\n+ * @author Bernd Pfrommer - openHAB 1 insteonplm binding\n+ * @author Rob Nielsen - Port to openHAB 2 insteon binding\n+ */\n+@NonNullByDefault\n+@SuppressWarnings(\"null\")\n+public abstract class CommandHandler {\n+    private static final Logger logger = LoggerFactory.getLogger(CommandHandler.class);\n+    DeviceFeature feature; // related DeviceFeature\n+    @Nullable\n+    HashMap<String, @Nullable String> parameters = new HashMap<>();\n+\n+    /**\n+     * Constructor\n+     *\n+     * @param feature The DeviceFeature for which this command was intended.\n+     *            The openHAB commands are issued on an openhab item. The .items files bind\n+     *            an openHAB item to a DeviceFeature.\n+     */\n+    CommandHandler(DeviceFeature feature) {\n+        this.feature = feature;\n+    }\n+\n+    /**\n+     * Implements what to do when an openHAB command is received\n+     *\n+     * @param config the configuration for the item that generated the command\n+     * @param cmd the openhab command issued\n+     * @param device the Insteon device to which this command applies\n+     */\n+    public abstract void handleCommand(InsteonChannelConfiguration conf, Command cmd, InsteonDevice device);\n+\n+    /**\n+     * Returns parameter as integer\n+     *\n+     * @param key key of parameter\n+     * @param def default\n+     * @return value of parameter\n+     */\n+    protected int getIntParameter(String key, int def) {\n+        String val = parameters.get(key);\n+        if (val == null) {\n+            return (def); // param not found\n+        }\n+        int ret = def;\n+        try {\n+            ret = Utils.strToInt(val);\n+        } catch (NumberFormatException e) {\n+            logger.warn(\"malformed int parameter in command handler: {}\", key);\n+        }\n+        return ret;\n+    }\n+\n+    /**\n+     * Returns parameter as String\n+     *\n+     * @param key key of parameter\n+     * @param def default\n+     * @return value of parameter\n+     */\n+    protected @Nullable String getStringParameter(String key, String def) {\n+        return (parameters.get(key) == null ? def : parameters.get(key));\n+    }\n+\n+    /**\n+     * Shorthand to return class name for logging purposes\n+     *\n+     * @return name of the class\n+     */\n+    protected String nm() {\n+        return (this.getClass().getSimpleName());\n+    }\n+\n+    protected int getMaxLightLevel(InsteonChannelConfiguration conf, int defaultLevel) {\n+        HashMap<String, @Nullable String> params = conf.getParameters();\n+        if (conf.getFeature().contains(\"dimmer\") && params.containsKey(\"dimmermax\")) {\n+            String item = conf.getChannelName();\n+            String dimmerMax = params.get(\"dimmermax\");\n+            try {\n+                int i = Integer.parseInt(dimmerMax);\n+                if (i > 1 && i <= 99) {\n+                    int level = (int) Math.ceil((i * 255.0) / 100); // round up\n+                    if (level < defaultLevel) {\n+                        logger.debug(\"item {}: using dimmermax value of {}\", item, dimmerMax);\n+                        return level;\n+                    }\n+                } else {\n+                    logger.warn(\"item {}: dimmermax must be between 1-99 inclusive: {}\", item, dimmerMax);\n+                }\n+            } catch (NumberFormatException e) {\n+                logger.warn(\"item {}: invalid int value for dimmermax: {}\", item, dimmerMax);\n+            }\n+        }\n+\n+        return defaultLevel;\n+    }\n+\n+    void setParameters(HashMap<String, @Nullable String> hm) {\n+        parameters = hm;\n+    }\n+\n+    /**\n+     * Helper function to extract the group parameter from the binding config,\n+     *\n+     * @param c the binding configuration to test\n+     * @return the value of the \"group\" parameter, or -1 if none\n+     */\n+    protected static int getGroup(InsteonChannelConfiguration c) {\n+        String v = c.getParameters().get(\"group\");\n+        int iv = -1;\n+        try {\n+            iv = (v == null) ? -1 : Utils.strToInt(v);\n+        } catch (NumberFormatException e) {\n+            logger.warn(\"malformed int parameter in for item {}\", c.getChannelName());\n+        }\n+        return iv;\n+    }\n+\n+    @NonNullByDefault\n+    public static class WarnCommandHandler extends CommandHandler {\n+        WarnCommandHandler(DeviceFeature f) {\n+            super(f);\n+        }\n+\n+        @Override\n+        public void handleCommand(InsteonChannelConfiguration conf, Command cmd, InsteonDevice dev) {\n+            logger.warn(\"{}: command {} is not implemented yet!\", nm(), cmd);\n+        }\n+    }\n+\n+    @NonNullByDefault\n+    public static class NoOpCommandHandler extends CommandHandler {\n+        NoOpCommandHandler(DeviceFeature f) {\n+            super(f);\n+        }\n+\n+        @Override\n+        public void handleCommand(InsteonChannelConfiguration conf, Command cmd, InsteonDevice dev) {\n+            // do nothing, not even log\n+        }\n+    }\n+\n+    @NonNullByDefault\n+    public static class LightOnOffCommandHandler extends CommandHandler {\n+        LightOnOffCommandHandler(DeviceFeature f) {\n+            super(f);\n+        }\n+\n+        @Override\n+        public void handleCommand(InsteonChannelConfiguration conf, Command cmd, InsteonDevice dev) {\n+            try {\n+                int ext = getIntParameter(\"ext\", 0);\n+                int direc = 0x00;\n+                int level = 0x00;\n+                Msg m = null;\n+                if (cmd == OnOffType.ON) {\n+                    level = getMaxLightLevel(conf, 0xff);\n+                    direc = 0x11;\n+                    logger.debug(\"{}: sent msg to switch {} to {}\", nm(), dev.getAddress(),\n+                            level == 0xff ? \"on\" : level);\n+                } else if (cmd == OnOffType.OFF) {\n+                    direc = 0x13;\n+                    logger.debug(\"{}: sent msg to switch {} off\", nm(), dev.getAddress());\n+                }\n+                if (ext == 1 || ext == 2) {\n+                    byte[] data = new byte[] { (byte) getIntParameter(\"d1\", 0), (byte) getIntParameter(\"d2\", 0),\n+                            (byte) getIntParameter(\"d3\", 0) };\n+                    m = dev.makeExtendedMessage((byte) 0x0f, (byte) direc, (byte) level, data);\n+                    logger.debug(\"{}: was an extended message for device {}\", nm(), dev.getAddress());\n+                    if (ext == 1) {\n+                        m.setCRC();\n+                    } else if (ext == 2) {\n+                        m.setCRC2();\n+                    }\n+                } else {\n+                    m = dev.makeStandardMessage((byte) 0x0f, (byte) direc, (byte) level, getGroup(conf));\n+                }\n+                logger.debug(\"Sending message to {}\", dev.getAddress());\n+                dev.enqueueMessage(m, feature);\n+                // expect to get a direct ack after this!\n+            } catch (IOException e) {\n+                logger.warn(\"{}: command send i/o error: \", nm(), e);\n+            } catch (FieldException e) {\n+                logger.warn(\"{}: command send message creation error \", nm(), e);\n+            }\n+        }\n+    }\n+\n+    @NonNullByDefault\n+    public static class FastOnOffCommandHandler extends CommandHandler {\n+        FastOnOffCommandHandler(DeviceFeature f) {\n+            super(f);\n+        }\n+\n+        @Override\n+        public void handleCommand(InsteonChannelConfiguration conf, Command cmd, InsteonDevice dev) {\n+            try {\n+                if (cmd == OnOffType.ON) {\n+                    int level = getMaxLightLevel(conf, 0xff);\n+                    Msg m = dev.makeStandardMessage((byte) 0x0f, (byte) 0x12, (byte) level, getGroup(conf));\n+                    dev.enqueueMessage(m, feature);\n+                    logger.debug(\"{}: sent fast on to switch {} level {}\", nm(), dev.getAddress(),\n+                            level == 0xff ? \"on\" : level);\n+                } else if (cmd == OnOffType.OFF) {\n+                    Msg m = dev.makeStandardMessage((byte) 0x0f, (byte) 0x14, (byte) 0x00, getGroup(conf));\n+                    dev.enqueueMessage(m, feature);\n+                    logger.debug(\"{}: sent fast off to switch {}\", nm(), dev.getAddress());\n+                }\n+                // expect to get a direct ack after this!\n+            } catch (IOException e) {\n+                logger.warn(\"{}: command send i/o error: \", nm(), e);\n+            } catch (FieldException e) {\n+                logger.warn(\"{}: command send message creation error \", nm(), e);\n+            }\n+        }\n+    }\n+\n+    @NonNullByDefault\n+    public static class RampOnOffCommandHandler extends RampCommandHandler {\n+        RampOnOffCommandHandler(DeviceFeature f) {\n+            super(f);\n+        }\n+\n+        @Override\n+        public void handleCommand(InsteonChannelConfiguration conf, Command cmd, InsteonDevice dev) {\n+            try {\n+                if (cmd == OnOffType.ON) {\n+                    double ramptime = getRampTime(conf, 0);\n+                    int ramplevel = getRampLevel(conf, 100);\n+                    byte cmd2 = encode(ramptime, ramplevel);\n+                    Msg m = dev.makeStandardMessage((byte) 0x0f, getOnCmd(), cmd2, getGroup(conf));\n+                    dev.enqueueMessage(m, feature);\n+                    logger.debug(\"{}: sent ramp on to switch {} time {} level {} cmd1 {}\", nm(), dev.getAddress(),\n+                            ramptime, ramplevel, getOnCmd());\n+                } else if (cmd == OnOffType.OFF) {\n+                    double ramptime = getRampTime(conf, 0);\n+                    int ramplevel = getRampLevel(conf, 0 /* ignored */);\n+                    byte cmd2 = encode(ramptime, ramplevel);\n+                    Msg m = dev.makeStandardMessage((byte) 0x0f, getOffCmd(), cmd2, getGroup(conf));\n+                    dev.enqueueMessage(m, feature);\n+                    logger.debug(\"{}: sent ramp off to switch {} time {} cmd1 {}\", nm(), dev.getAddress(), ramptime,\n+                            getOffCmd());\n+                }\n+                // expect to get a direct ack after this!\n+            } catch (IOException e) {\n+                logger.warn(\"{}: command send i/o error: \", nm(), e);\n+            } catch (FieldException e) {\n+                logger.warn(\"{}: command send message creation error \", nm(), e);\n+            }\n+        }\n+\n+        private int getRampLevel(InsteonChannelConfiguration conf, int defaultValue) {\n+            HashMap<String, @Nullable String> params = conf.getParameters();\n+            return params.containsKey(\"ramplevel\") ? Integer.parseInt(params.get(\"ramplevel\")) : defaultValue;\n+        }\n+    }\n+\n+    @NonNullByDefault\n+    public static class ManualChangeCommandHandler extends CommandHandler {\n+        ManualChangeCommandHandler(DeviceFeature f) {\n+            super(f);\n+        }\n+\n+        @Override\n+        public void handleCommand(InsteonChannelConfiguration conf, Command cmd, InsteonDevice dev) {\n+            try {\n+                if (cmd instanceof DecimalType) {\n+                    int v = ((DecimalType) cmd).intValue();\n+                    int cmd1 = (v != 1) ? 0x17 : 0x18; // start or stop\n+                    int cmd2 = (v == 2) ? 0x01 : 0; // up or down\n+                    Msg m = dev.makeStandardMessage((byte) 0x0f, (byte) cmd1, (byte) cmd2, getGroup(conf));\n+                    dev.enqueueMessage(m, feature);\n+                    logger.debug(\"{}: cmd {} sent manual change {} {} to {}\", nm(), v,\n+                            (cmd1 == 0x17) ? \"START\" : \"STOP\", (cmd2 == 0x01) ? \"UP\" : \"DOWN\", dev.getAddress());\n+                } else {\n+                    logger.warn(\"{}: invalid command type: {}\", nm(), cmd);\n+                }\n+            } catch (IOException e) {\n+                logger.warn(\"{}: command send i/o error: \", nm(), e);\n+            } catch (FieldException e) {\n+                logger.warn(\"{}: command send message creation error \", nm(), e);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Sends ALLLink broadcast commands to group\n+     */\n+    @NonNullByDefault\n+    public static class GroupBroadcastCommandHandler extends CommandHandler {\n+        GroupBroadcastCommandHandler(DeviceFeature f) {\n+            super(f);\n+        }\n+\n+        @Override\n+        public void handleCommand(InsteonChannelConfiguration conf, Command cmd, InsteonDevice dev) {\n+            try {\n+                if (cmd == OnOffType.ON || cmd == OnOffType.OFF) {\n+                    byte cmd1 = (byte) ((cmd == OnOffType.ON) ? 0x11 : 0x13);\n+                    byte value = (byte) ((cmd == OnOffType.ON) ? 0xFF : 0x00);\n+                    int group = getGroup(conf);\n+                    if (group == -1) {\n+                        logger.warn(\"no group=xx specified in item {}\", conf.getChannelName());\n+                        return;\n+                    }\n+                    logger.debug(\"{}: sending {} broadcast to group {}\", nm(), (cmd1 == 0x11) ? \"ON\" : \"OFF\",\n+                            getGroup(conf));\n+                    Msg m = dev.makeStandardMessage((byte) 0x0f, cmd1, value, group);\n+                    dev.enqueueMessage(m, feature);\n+                }\n+            } catch (IOException e) {\n+                logger.warn(\"{}: command send i/o error: \", nm(), e);\n+            } catch (FieldException e) {\n+                logger.warn(\"{}: command send message creation error \", nm(), e);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * This Handler was supposed to set the LEDs of the 2487S, but it doesn't work.\n+     * The parameters were modeled after the 2486D, it may work for that one,\n+     * leaving it in for now.\n+     *\n+     * From the HouseLinc PLM traffic log, the following commands (in the D2 data field)\n+     * of the 2486D are supported:\n+     *\n+     * 0x02: LED follow mask may work or not\n+     * 0x03: LED OFF mask\n+     * 0x04: X10 addr setting\n+     * 0x05: ramp rate\n+     * 0x06: on Level for button\n+     * 0x07: global LED brightness (could not see any effect during testing)\n+     * 0x0B: set nontoggle on/off command\n+     *\n+     * crucially, the 0x09 command does not work (NACK from device)\n+     *\n+     * @author Bernd Pfrommer - openHAB 1 insteonplm binding\n+     */\n+    @NonNullByDefault\n+    public static class LEDOnOffCommandHandler extends CommandHandler {\n+        LEDOnOffCommandHandler(DeviceFeature f) {\n+            super(f);\n+        }\n+\n+        @Override\n+        public void handleCommand(InsteonChannelConfiguration conf, Command cmd, InsteonDevice dev) {\n+            try {\n+                int button = this.getIntParameter(\"button\", -1);\n+                if (cmd == OnOffType.ON) {\n+                    Msg m = dev.makeExtendedMessage((byte) 0x1f, (byte) 0x2e, (byte) 0x00,\n+                            new byte[] { (byte) button, (byte) 0x09, (byte) 0x01 });\n+                    dev.enqueueMessage(m, feature);\n+                    logger.debug(\"{}: sent msg to switch {} on\", nm(), dev.getAddress());\n+                } else if (cmd == OnOffType.OFF) {\n+                    Msg m = dev.makeExtendedMessage((byte) 0x1f, (byte) 0x2e, (byte) 0x00,\n+                            new byte[] { (byte) button, (byte) 0x09, (byte) 0x00 });\n+                    dev.enqueueMessage(m, feature);\n+                    logger.debug(\"{}: sent msg to switch {} off\", nm(), dev.getAddress());\n+                }\n+            } catch (IOException e) {\n+                logger.warn(\"{}: command send i/o error: \", nm(), e);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "04a9796d14dfbc5f3ff997d872f04b6d03ee411d"}, "originalPosition": 400}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTMxNzQ2MA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            logger.warn(\"{}: command send i/o error: \", nm(), e);\n          \n          \n            \n                            logger.debug(\"{}: command send i/o error: \", nm(), e);\n          \n      \n    \n    \n  \n\nInstead of logging warnings, you should set the Thing Status to OFFLINE, when the communication didn't work.", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r389317460", "createdAt": "2020-03-07T22:40:12Z", "author": {"login": "kaikreuzer"}, "path": "bundles/org.openhab.binding.insteon/src/main/java/org/openhab/binding/insteon/internal/device/CommandHandler.java", "diffHunk": "@@ -0,0 +1,912 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.insteon.internal.device;\n+\n+import java.io.IOException;\n+import java.lang.reflect.InvocationTargetException;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.Timer;\n+import java.util.TimerTask;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.IncreaseDecreaseType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.openhab.binding.insteon.internal.config.InsteonChannelConfiguration;\n+import org.openhab.binding.insteon.internal.device.DeviceFeatureListener.StateChangeType;\n+import org.openhab.binding.insteon.internal.message.FieldException;\n+import org.openhab.binding.insteon.internal.message.Msg;\n+import org.openhab.binding.insteon.internal.utils.Utils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * A command handler translates an openHAB command into a insteon message\n+ *\n+ * @author Daniel Pfrommer - Initial contribution\n+ * @author Bernd Pfrommer - openHAB 1 insteonplm binding\n+ * @author Rob Nielsen - Port to openHAB 2 insteon binding\n+ */\n+@NonNullByDefault\n+@SuppressWarnings(\"null\")\n+public abstract class CommandHandler {\n+    private static final Logger logger = LoggerFactory.getLogger(CommandHandler.class);\n+    DeviceFeature feature; // related DeviceFeature\n+    @Nullable\n+    HashMap<String, @Nullable String> parameters = new HashMap<>();\n+\n+    /**\n+     * Constructor\n+     *\n+     * @param feature The DeviceFeature for which this command was intended.\n+     *            The openHAB commands are issued on an openhab item. The .items files bind\n+     *            an openHAB item to a DeviceFeature.\n+     */\n+    CommandHandler(DeviceFeature feature) {\n+        this.feature = feature;\n+    }\n+\n+    /**\n+     * Implements what to do when an openHAB command is received\n+     *\n+     * @param config the configuration for the item that generated the command\n+     * @param cmd the openhab command issued\n+     * @param device the Insteon device to which this command applies\n+     */\n+    public abstract void handleCommand(InsteonChannelConfiguration conf, Command cmd, InsteonDevice device);\n+\n+    /**\n+     * Returns parameter as integer\n+     *\n+     * @param key key of parameter\n+     * @param def default\n+     * @return value of parameter\n+     */\n+    protected int getIntParameter(String key, int def) {\n+        String val = parameters.get(key);\n+        if (val == null) {\n+            return (def); // param not found\n+        }\n+        int ret = def;\n+        try {\n+            ret = Utils.strToInt(val);\n+        } catch (NumberFormatException e) {\n+            logger.warn(\"malformed int parameter in command handler: {}\", key);\n+        }\n+        return ret;\n+    }\n+\n+    /**\n+     * Returns parameter as String\n+     *\n+     * @param key key of parameter\n+     * @param def default\n+     * @return value of parameter\n+     */\n+    protected @Nullable String getStringParameter(String key, String def) {\n+        return (parameters.get(key) == null ? def : parameters.get(key));\n+    }\n+\n+    /**\n+     * Shorthand to return class name for logging purposes\n+     *\n+     * @return name of the class\n+     */\n+    protected String nm() {\n+        return (this.getClass().getSimpleName());\n+    }\n+\n+    protected int getMaxLightLevel(InsteonChannelConfiguration conf, int defaultLevel) {\n+        HashMap<String, @Nullable String> params = conf.getParameters();\n+        if (conf.getFeature().contains(\"dimmer\") && params.containsKey(\"dimmermax\")) {\n+            String item = conf.getChannelName();\n+            String dimmerMax = params.get(\"dimmermax\");\n+            try {\n+                int i = Integer.parseInt(dimmerMax);\n+                if (i > 1 && i <= 99) {\n+                    int level = (int) Math.ceil((i * 255.0) / 100); // round up\n+                    if (level < defaultLevel) {\n+                        logger.debug(\"item {}: using dimmermax value of {}\", item, dimmerMax);\n+                        return level;\n+                    }\n+                } else {\n+                    logger.warn(\"item {}: dimmermax must be between 1-99 inclusive: {}\", item, dimmerMax);\n+                }\n+            } catch (NumberFormatException e) {\n+                logger.warn(\"item {}: invalid int value for dimmermax: {}\", item, dimmerMax);\n+            }\n+        }\n+\n+        return defaultLevel;\n+    }\n+\n+    void setParameters(HashMap<String, @Nullable String> hm) {\n+        parameters = hm;\n+    }\n+\n+    /**\n+     * Helper function to extract the group parameter from the binding config,\n+     *\n+     * @param c the binding configuration to test\n+     * @return the value of the \"group\" parameter, or -1 if none\n+     */\n+    protected static int getGroup(InsteonChannelConfiguration c) {\n+        String v = c.getParameters().get(\"group\");\n+        int iv = -1;\n+        try {\n+            iv = (v == null) ? -1 : Utils.strToInt(v);\n+        } catch (NumberFormatException e) {\n+            logger.warn(\"malformed int parameter in for item {}\", c.getChannelName());\n+        }\n+        return iv;\n+    }\n+\n+    @NonNullByDefault\n+    public static class WarnCommandHandler extends CommandHandler {\n+        WarnCommandHandler(DeviceFeature f) {\n+            super(f);\n+        }\n+\n+        @Override\n+        public void handleCommand(InsteonChannelConfiguration conf, Command cmd, InsteonDevice dev) {\n+            logger.warn(\"{}: command {} is not implemented yet!\", nm(), cmd);\n+        }\n+    }\n+\n+    @NonNullByDefault\n+    public static class NoOpCommandHandler extends CommandHandler {\n+        NoOpCommandHandler(DeviceFeature f) {\n+            super(f);\n+        }\n+\n+        @Override\n+        public void handleCommand(InsteonChannelConfiguration conf, Command cmd, InsteonDevice dev) {\n+            // do nothing, not even log\n+        }\n+    }\n+\n+    @NonNullByDefault\n+    public static class LightOnOffCommandHandler extends CommandHandler {\n+        LightOnOffCommandHandler(DeviceFeature f) {\n+            super(f);\n+        }\n+\n+        @Override\n+        public void handleCommand(InsteonChannelConfiguration conf, Command cmd, InsteonDevice dev) {\n+            try {\n+                int ext = getIntParameter(\"ext\", 0);\n+                int direc = 0x00;\n+                int level = 0x00;\n+                Msg m = null;\n+                if (cmd == OnOffType.ON) {\n+                    level = getMaxLightLevel(conf, 0xff);\n+                    direc = 0x11;\n+                    logger.debug(\"{}: sent msg to switch {} to {}\", nm(), dev.getAddress(),\n+                            level == 0xff ? \"on\" : level);\n+                } else if (cmd == OnOffType.OFF) {\n+                    direc = 0x13;\n+                    logger.debug(\"{}: sent msg to switch {} off\", nm(), dev.getAddress());\n+                }\n+                if (ext == 1 || ext == 2) {\n+                    byte[] data = new byte[] { (byte) getIntParameter(\"d1\", 0), (byte) getIntParameter(\"d2\", 0),\n+                            (byte) getIntParameter(\"d3\", 0) };\n+                    m = dev.makeExtendedMessage((byte) 0x0f, (byte) direc, (byte) level, data);\n+                    logger.debug(\"{}: was an extended message for device {}\", nm(), dev.getAddress());\n+                    if (ext == 1) {\n+                        m.setCRC();\n+                    } else if (ext == 2) {\n+                        m.setCRC2();\n+                    }\n+                } else {\n+                    m = dev.makeStandardMessage((byte) 0x0f, (byte) direc, (byte) level, getGroup(conf));\n+                }\n+                logger.debug(\"Sending message to {}\", dev.getAddress());\n+                dev.enqueueMessage(m, feature);\n+                // expect to get a direct ack after this!\n+            } catch (IOException e) {\n+                logger.warn(\"{}: command send i/o error: \", nm(), e);\n+            } catch (FieldException e) {\n+                logger.warn(\"{}: command send message creation error \", nm(), e);\n+            }\n+        }\n+    }\n+\n+    @NonNullByDefault\n+    public static class FastOnOffCommandHandler extends CommandHandler {\n+        FastOnOffCommandHandler(DeviceFeature f) {\n+            super(f);\n+        }\n+\n+        @Override\n+        public void handleCommand(InsteonChannelConfiguration conf, Command cmd, InsteonDevice dev) {\n+            try {\n+                if (cmd == OnOffType.ON) {\n+                    int level = getMaxLightLevel(conf, 0xff);\n+                    Msg m = dev.makeStandardMessage((byte) 0x0f, (byte) 0x12, (byte) level, getGroup(conf));\n+                    dev.enqueueMessage(m, feature);\n+                    logger.debug(\"{}: sent fast on to switch {} level {}\", nm(), dev.getAddress(),\n+                            level == 0xff ? \"on\" : level);\n+                } else if (cmd == OnOffType.OFF) {\n+                    Msg m = dev.makeStandardMessage((byte) 0x0f, (byte) 0x14, (byte) 0x00, getGroup(conf));\n+                    dev.enqueueMessage(m, feature);\n+                    logger.debug(\"{}: sent fast off to switch {}\", nm(), dev.getAddress());\n+                }\n+                // expect to get a direct ack after this!\n+            } catch (IOException e) {\n+                logger.warn(\"{}: command send i/o error: \", nm(), e);\n+            } catch (FieldException e) {\n+                logger.warn(\"{}: command send message creation error \", nm(), e);\n+            }\n+        }\n+    }\n+\n+    @NonNullByDefault\n+    public static class RampOnOffCommandHandler extends RampCommandHandler {\n+        RampOnOffCommandHandler(DeviceFeature f) {\n+            super(f);\n+        }\n+\n+        @Override\n+        public void handleCommand(InsteonChannelConfiguration conf, Command cmd, InsteonDevice dev) {\n+            try {\n+                if (cmd == OnOffType.ON) {\n+                    double ramptime = getRampTime(conf, 0);\n+                    int ramplevel = getRampLevel(conf, 100);\n+                    byte cmd2 = encode(ramptime, ramplevel);\n+                    Msg m = dev.makeStandardMessage((byte) 0x0f, getOnCmd(), cmd2, getGroup(conf));\n+                    dev.enqueueMessage(m, feature);\n+                    logger.debug(\"{}: sent ramp on to switch {} time {} level {} cmd1 {}\", nm(), dev.getAddress(),\n+                            ramptime, ramplevel, getOnCmd());\n+                } else if (cmd == OnOffType.OFF) {\n+                    double ramptime = getRampTime(conf, 0);\n+                    int ramplevel = getRampLevel(conf, 0 /* ignored */);\n+                    byte cmd2 = encode(ramptime, ramplevel);\n+                    Msg m = dev.makeStandardMessage((byte) 0x0f, getOffCmd(), cmd2, getGroup(conf));\n+                    dev.enqueueMessage(m, feature);\n+                    logger.debug(\"{}: sent ramp off to switch {} time {} cmd1 {}\", nm(), dev.getAddress(), ramptime,\n+                            getOffCmd());\n+                }\n+                // expect to get a direct ack after this!\n+            } catch (IOException e) {\n+                logger.warn(\"{}: command send i/o error: \", nm(), e);\n+            } catch (FieldException e) {\n+                logger.warn(\"{}: command send message creation error \", nm(), e);\n+            }\n+        }\n+\n+        private int getRampLevel(InsteonChannelConfiguration conf, int defaultValue) {\n+            HashMap<String, @Nullable String> params = conf.getParameters();\n+            return params.containsKey(\"ramplevel\") ? Integer.parseInt(params.get(\"ramplevel\")) : defaultValue;\n+        }\n+    }\n+\n+    @NonNullByDefault\n+    public static class ManualChangeCommandHandler extends CommandHandler {\n+        ManualChangeCommandHandler(DeviceFeature f) {\n+            super(f);\n+        }\n+\n+        @Override\n+        public void handleCommand(InsteonChannelConfiguration conf, Command cmd, InsteonDevice dev) {\n+            try {\n+                if (cmd instanceof DecimalType) {\n+                    int v = ((DecimalType) cmd).intValue();\n+                    int cmd1 = (v != 1) ? 0x17 : 0x18; // start or stop\n+                    int cmd2 = (v == 2) ? 0x01 : 0; // up or down\n+                    Msg m = dev.makeStandardMessage((byte) 0x0f, (byte) cmd1, (byte) cmd2, getGroup(conf));\n+                    dev.enqueueMessage(m, feature);\n+                    logger.debug(\"{}: cmd {} sent manual change {} {} to {}\", nm(), v,\n+                            (cmd1 == 0x17) ? \"START\" : \"STOP\", (cmd2 == 0x01) ? \"UP\" : \"DOWN\", dev.getAddress());\n+                } else {\n+                    logger.warn(\"{}: invalid command type: {}\", nm(), cmd);\n+                }\n+            } catch (IOException e) {\n+                logger.warn(\"{}: command send i/o error: \", nm(), e);\n+            } catch (FieldException e) {\n+                logger.warn(\"{}: command send message creation error \", nm(), e);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Sends ALLLink broadcast commands to group\n+     */\n+    @NonNullByDefault\n+    public static class GroupBroadcastCommandHandler extends CommandHandler {\n+        GroupBroadcastCommandHandler(DeviceFeature f) {\n+            super(f);\n+        }\n+\n+        @Override\n+        public void handleCommand(InsteonChannelConfiguration conf, Command cmd, InsteonDevice dev) {\n+            try {\n+                if (cmd == OnOffType.ON || cmd == OnOffType.OFF) {\n+                    byte cmd1 = (byte) ((cmd == OnOffType.ON) ? 0x11 : 0x13);\n+                    byte value = (byte) ((cmd == OnOffType.ON) ? 0xFF : 0x00);\n+                    int group = getGroup(conf);\n+                    if (group == -1) {\n+                        logger.warn(\"no group=xx specified in item {}\", conf.getChannelName());\n+                        return;\n+                    }\n+                    logger.debug(\"{}: sending {} broadcast to group {}\", nm(), (cmd1 == 0x11) ? \"ON\" : \"OFF\",\n+                            getGroup(conf));\n+                    Msg m = dev.makeStandardMessage((byte) 0x0f, cmd1, value, group);\n+                    dev.enqueueMessage(m, feature);\n+                }\n+            } catch (IOException e) {\n+                logger.warn(\"{}: command send i/o error: \", nm(), e);\n+            } catch (FieldException e) {\n+                logger.warn(\"{}: command send message creation error \", nm(), e);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * This Handler was supposed to set the LEDs of the 2487S, but it doesn't work.\n+     * The parameters were modeled after the 2486D, it may work for that one,\n+     * leaving it in for now.\n+     *\n+     * From the HouseLinc PLM traffic log, the following commands (in the D2 data field)\n+     * of the 2486D are supported:\n+     *\n+     * 0x02: LED follow mask may work or not\n+     * 0x03: LED OFF mask\n+     * 0x04: X10 addr setting\n+     * 0x05: ramp rate\n+     * 0x06: on Level for button\n+     * 0x07: global LED brightness (could not see any effect during testing)\n+     * 0x0B: set nontoggle on/off command\n+     *\n+     * crucially, the 0x09 command does not work (NACK from device)\n+     *\n+     * @author Bernd Pfrommer - openHAB 1 insteonplm binding\n+     */\n+    @NonNullByDefault\n+    public static class LEDOnOffCommandHandler extends CommandHandler {\n+        LEDOnOffCommandHandler(DeviceFeature f) {\n+            super(f);\n+        }\n+\n+        @Override\n+        public void handleCommand(InsteonChannelConfiguration conf, Command cmd, InsteonDevice dev) {\n+            try {\n+                int button = this.getIntParameter(\"button\", -1);\n+                if (cmd == OnOffType.ON) {\n+                    Msg m = dev.makeExtendedMessage((byte) 0x1f, (byte) 0x2e, (byte) 0x00,\n+                            new byte[] { (byte) button, (byte) 0x09, (byte) 0x01 });\n+                    dev.enqueueMessage(m, feature);\n+                    logger.debug(\"{}: sent msg to switch {} on\", nm(), dev.getAddress());\n+                } else if (cmd == OnOffType.OFF) {\n+                    Msg m = dev.makeExtendedMessage((byte) 0x1f, (byte) 0x2e, (byte) 0x00,\n+                            new byte[] { (byte) button, (byte) 0x09, (byte) 0x00 });\n+                    dev.enqueueMessage(m, feature);\n+                    logger.debug(\"{}: sent msg to switch {} off\", nm(), dev.getAddress());\n+                }\n+            } catch (IOException e) {\n+                logger.warn(\"{}: command send i/o error: \", nm(), e);\n+            } catch (FieldException e) {\n+                logger.warn(\"{}: command send message creation error \", nm(), e);\n+            }\n+        }\n+    }\n+\n+    @NonNullByDefault\n+    public static class X10OnOffCommandHandler extends CommandHandler {\n+        X10OnOffCommandHandler(DeviceFeature f) {\n+            super(f);\n+        }\n+\n+        @Override\n+        public void handleCommand(InsteonChannelConfiguration conf, Command cmd, InsteonDevice dev) {\n+            try {\n+                byte houseCode = dev.getX10HouseCode();\n+                byte houseUnitCode = (byte) (houseCode << 4 | dev.getX10UnitCode());\n+                if (cmd == OnOffType.ON || cmd == OnOffType.OFF) {\n+                    byte houseCommandCode = (byte) (houseCode << 4\n+                            | (cmd == OnOffType.ON ? X10.Command.ON.code() : X10.Command.OFF.code()));\n+                    Msg munit = dev.makeX10Message(houseUnitCode, (byte) 0x00); // send unit code\n+                    dev.enqueueMessage(munit, feature);\n+                    Msg mcmd = dev.makeX10Message(houseCommandCode, (byte) 0x80); // send command code\n+                    dev.enqueueMessage(mcmd, feature);\n+                    String onOff = cmd == OnOffType.ON ? \"ON\" : \"OFF\";\n+                    logger.debug(\"{}: sent msg to switch {} {}\", nm(), dev.getAddress(), onOff);\n+                }\n+            } catch (IOException e) {\n+                logger.warn(\"{}: command send i/o error: \", nm(), e);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "04a9796d14dfbc5f3ff997d872f04b6d03ee411d"}, "originalPosition": 429}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTMxNzQ4OQ==", "bodyText": "Ok, I won't repeat me anymore...", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r389317489", "createdAt": "2020-03-07T22:40:35Z", "author": {"login": "kaikreuzer"}, "path": "bundles/org.openhab.binding.insteon/src/main/java/org/openhab/binding/insteon/internal/device/CommandHandler.java", "diffHunk": "@@ -0,0 +1,912 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.insteon.internal.device;\n+\n+import java.io.IOException;\n+import java.lang.reflect.InvocationTargetException;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.Timer;\n+import java.util.TimerTask;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.IncreaseDecreaseType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.openhab.binding.insteon.internal.config.InsteonChannelConfiguration;\n+import org.openhab.binding.insteon.internal.device.DeviceFeatureListener.StateChangeType;\n+import org.openhab.binding.insteon.internal.message.FieldException;\n+import org.openhab.binding.insteon.internal.message.Msg;\n+import org.openhab.binding.insteon.internal.utils.Utils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * A command handler translates an openHAB command into a insteon message\n+ *\n+ * @author Daniel Pfrommer - Initial contribution\n+ * @author Bernd Pfrommer - openHAB 1 insteonplm binding\n+ * @author Rob Nielsen - Port to openHAB 2 insteon binding\n+ */\n+@NonNullByDefault\n+@SuppressWarnings(\"null\")\n+public abstract class CommandHandler {\n+    private static final Logger logger = LoggerFactory.getLogger(CommandHandler.class);\n+    DeviceFeature feature; // related DeviceFeature\n+    @Nullable\n+    HashMap<String, @Nullable String> parameters = new HashMap<>();\n+\n+    /**\n+     * Constructor\n+     *\n+     * @param feature The DeviceFeature for which this command was intended.\n+     *            The openHAB commands are issued on an openhab item. The .items files bind\n+     *            an openHAB item to a DeviceFeature.\n+     */\n+    CommandHandler(DeviceFeature feature) {\n+        this.feature = feature;\n+    }\n+\n+    /**\n+     * Implements what to do when an openHAB command is received\n+     *\n+     * @param config the configuration for the item that generated the command\n+     * @param cmd the openhab command issued\n+     * @param device the Insteon device to which this command applies\n+     */\n+    public abstract void handleCommand(InsteonChannelConfiguration conf, Command cmd, InsteonDevice device);\n+\n+    /**\n+     * Returns parameter as integer\n+     *\n+     * @param key key of parameter\n+     * @param def default\n+     * @return value of parameter\n+     */\n+    protected int getIntParameter(String key, int def) {\n+        String val = parameters.get(key);\n+        if (val == null) {\n+            return (def); // param not found\n+        }\n+        int ret = def;\n+        try {\n+            ret = Utils.strToInt(val);\n+        } catch (NumberFormatException e) {\n+            logger.warn(\"malformed int parameter in command handler: {}\", key);\n+        }\n+        return ret;\n+    }\n+\n+    /**\n+     * Returns parameter as String\n+     *\n+     * @param key key of parameter\n+     * @param def default\n+     * @return value of parameter\n+     */\n+    protected @Nullable String getStringParameter(String key, String def) {\n+        return (parameters.get(key) == null ? def : parameters.get(key));\n+    }\n+\n+    /**\n+     * Shorthand to return class name for logging purposes\n+     *\n+     * @return name of the class\n+     */\n+    protected String nm() {\n+        return (this.getClass().getSimpleName());\n+    }\n+\n+    protected int getMaxLightLevel(InsteonChannelConfiguration conf, int defaultLevel) {\n+        HashMap<String, @Nullable String> params = conf.getParameters();\n+        if (conf.getFeature().contains(\"dimmer\") && params.containsKey(\"dimmermax\")) {\n+            String item = conf.getChannelName();\n+            String dimmerMax = params.get(\"dimmermax\");\n+            try {\n+                int i = Integer.parseInt(dimmerMax);\n+                if (i > 1 && i <= 99) {\n+                    int level = (int) Math.ceil((i * 255.0) / 100); // round up\n+                    if (level < defaultLevel) {\n+                        logger.debug(\"item {}: using dimmermax value of {}\", item, dimmerMax);\n+                        return level;\n+                    }\n+                } else {\n+                    logger.warn(\"item {}: dimmermax must be between 1-99 inclusive: {}\", item, dimmerMax);\n+                }\n+            } catch (NumberFormatException e) {\n+                logger.warn(\"item {}: invalid int value for dimmermax: {}\", item, dimmerMax);\n+            }\n+        }\n+\n+        return defaultLevel;\n+    }\n+\n+    void setParameters(HashMap<String, @Nullable String> hm) {\n+        parameters = hm;\n+    }\n+\n+    /**\n+     * Helper function to extract the group parameter from the binding config,\n+     *\n+     * @param c the binding configuration to test\n+     * @return the value of the \"group\" parameter, or -1 if none\n+     */\n+    protected static int getGroup(InsteonChannelConfiguration c) {\n+        String v = c.getParameters().get(\"group\");\n+        int iv = -1;\n+        try {\n+            iv = (v == null) ? -1 : Utils.strToInt(v);\n+        } catch (NumberFormatException e) {\n+            logger.warn(\"malformed int parameter in for item {}\", c.getChannelName());\n+        }\n+        return iv;\n+    }\n+\n+    @NonNullByDefault\n+    public static class WarnCommandHandler extends CommandHandler {\n+        WarnCommandHandler(DeviceFeature f) {\n+            super(f);\n+        }\n+\n+        @Override\n+        public void handleCommand(InsteonChannelConfiguration conf, Command cmd, InsteonDevice dev) {\n+            logger.warn(\"{}: command {} is not implemented yet!\", nm(), cmd);\n+        }\n+    }\n+\n+    @NonNullByDefault\n+    public static class NoOpCommandHandler extends CommandHandler {\n+        NoOpCommandHandler(DeviceFeature f) {\n+            super(f);\n+        }\n+\n+        @Override\n+        public void handleCommand(InsteonChannelConfiguration conf, Command cmd, InsteonDevice dev) {\n+            // do nothing, not even log\n+        }\n+    }\n+\n+    @NonNullByDefault\n+    public static class LightOnOffCommandHandler extends CommandHandler {\n+        LightOnOffCommandHandler(DeviceFeature f) {\n+            super(f);\n+        }\n+\n+        @Override\n+        public void handleCommand(InsteonChannelConfiguration conf, Command cmd, InsteonDevice dev) {\n+            try {\n+                int ext = getIntParameter(\"ext\", 0);\n+                int direc = 0x00;\n+                int level = 0x00;\n+                Msg m = null;\n+                if (cmd == OnOffType.ON) {\n+                    level = getMaxLightLevel(conf, 0xff);\n+                    direc = 0x11;\n+                    logger.debug(\"{}: sent msg to switch {} to {}\", nm(), dev.getAddress(),\n+                            level == 0xff ? \"on\" : level);\n+                } else if (cmd == OnOffType.OFF) {\n+                    direc = 0x13;\n+                    logger.debug(\"{}: sent msg to switch {} off\", nm(), dev.getAddress());\n+                }\n+                if (ext == 1 || ext == 2) {\n+                    byte[] data = new byte[] { (byte) getIntParameter(\"d1\", 0), (byte) getIntParameter(\"d2\", 0),\n+                            (byte) getIntParameter(\"d3\", 0) };\n+                    m = dev.makeExtendedMessage((byte) 0x0f, (byte) direc, (byte) level, data);\n+                    logger.debug(\"{}: was an extended message for device {}\", nm(), dev.getAddress());\n+                    if (ext == 1) {\n+                        m.setCRC();\n+                    } else if (ext == 2) {\n+                        m.setCRC2();\n+                    }\n+                } else {\n+                    m = dev.makeStandardMessage((byte) 0x0f, (byte) direc, (byte) level, getGroup(conf));\n+                }\n+                logger.debug(\"Sending message to {}\", dev.getAddress());\n+                dev.enqueueMessage(m, feature);\n+                // expect to get a direct ack after this!\n+            } catch (IOException e) {\n+                logger.warn(\"{}: command send i/o error: \", nm(), e);\n+            } catch (FieldException e) {\n+                logger.warn(\"{}: command send message creation error \", nm(), e);\n+            }\n+        }\n+    }\n+\n+    @NonNullByDefault\n+    public static class FastOnOffCommandHandler extends CommandHandler {\n+        FastOnOffCommandHandler(DeviceFeature f) {\n+            super(f);\n+        }\n+\n+        @Override\n+        public void handleCommand(InsteonChannelConfiguration conf, Command cmd, InsteonDevice dev) {\n+            try {\n+                if (cmd == OnOffType.ON) {\n+                    int level = getMaxLightLevel(conf, 0xff);\n+                    Msg m = dev.makeStandardMessage((byte) 0x0f, (byte) 0x12, (byte) level, getGroup(conf));\n+                    dev.enqueueMessage(m, feature);\n+                    logger.debug(\"{}: sent fast on to switch {} level {}\", nm(), dev.getAddress(),\n+                            level == 0xff ? \"on\" : level);\n+                } else if (cmd == OnOffType.OFF) {\n+                    Msg m = dev.makeStandardMessage((byte) 0x0f, (byte) 0x14, (byte) 0x00, getGroup(conf));\n+                    dev.enqueueMessage(m, feature);\n+                    logger.debug(\"{}: sent fast off to switch {}\", nm(), dev.getAddress());\n+                }\n+                // expect to get a direct ack after this!\n+            } catch (IOException e) {\n+                logger.warn(\"{}: command send i/o error: \", nm(), e);\n+            } catch (FieldException e) {\n+                logger.warn(\"{}: command send message creation error \", nm(), e);\n+            }\n+        }\n+    }\n+\n+    @NonNullByDefault\n+    public static class RampOnOffCommandHandler extends RampCommandHandler {\n+        RampOnOffCommandHandler(DeviceFeature f) {\n+            super(f);\n+        }\n+\n+        @Override\n+        public void handleCommand(InsteonChannelConfiguration conf, Command cmd, InsteonDevice dev) {\n+            try {\n+                if (cmd == OnOffType.ON) {\n+                    double ramptime = getRampTime(conf, 0);\n+                    int ramplevel = getRampLevel(conf, 100);\n+                    byte cmd2 = encode(ramptime, ramplevel);\n+                    Msg m = dev.makeStandardMessage((byte) 0x0f, getOnCmd(), cmd2, getGroup(conf));\n+                    dev.enqueueMessage(m, feature);\n+                    logger.debug(\"{}: sent ramp on to switch {} time {} level {} cmd1 {}\", nm(), dev.getAddress(),\n+                            ramptime, ramplevel, getOnCmd());\n+                } else if (cmd == OnOffType.OFF) {\n+                    double ramptime = getRampTime(conf, 0);\n+                    int ramplevel = getRampLevel(conf, 0 /* ignored */);\n+                    byte cmd2 = encode(ramptime, ramplevel);\n+                    Msg m = dev.makeStandardMessage((byte) 0x0f, getOffCmd(), cmd2, getGroup(conf));\n+                    dev.enqueueMessage(m, feature);\n+                    logger.debug(\"{}: sent ramp off to switch {} time {} cmd1 {}\", nm(), dev.getAddress(), ramptime,\n+                            getOffCmd());\n+                }\n+                // expect to get a direct ack after this!\n+            } catch (IOException e) {\n+                logger.warn(\"{}: command send i/o error: \", nm(), e);\n+            } catch (FieldException e) {\n+                logger.warn(\"{}: command send message creation error \", nm(), e);\n+            }\n+        }\n+\n+        private int getRampLevel(InsteonChannelConfiguration conf, int defaultValue) {\n+            HashMap<String, @Nullable String> params = conf.getParameters();\n+            return params.containsKey(\"ramplevel\") ? Integer.parseInt(params.get(\"ramplevel\")) : defaultValue;\n+        }\n+    }\n+\n+    @NonNullByDefault\n+    public static class ManualChangeCommandHandler extends CommandHandler {\n+        ManualChangeCommandHandler(DeviceFeature f) {\n+            super(f);\n+        }\n+\n+        @Override\n+        public void handleCommand(InsteonChannelConfiguration conf, Command cmd, InsteonDevice dev) {\n+            try {\n+                if (cmd instanceof DecimalType) {\n+                    int v = ((DecimalType) cmd).intValue();\n+                    int cmd1 = (v != 1) ? 0x17 : 0x18; // start or stop\n+                    int cmd2 = (v == 2) ? 0x01 : 0; // up or down\n+                    Msg m = dev.makeStandardMessage((byte) 0x0f, (byte) cmd1, (byte) cmd2, getGroup(conf));\n+                    dev.enqueueMessage(m, feature);\n+                    logger.debug(\"{}: cmd {} sent manual change {} {} to {}\", nm(), v,\n+                            (cmd1 == 0x17) ? \"START\" : \"STOP\", (cmd2 == 0x01) ? \"UP\" : \"DOWN\", dev.getAddress());\n+                } else {\n+                    logger.warn(\"{}: invalid command type: {}\", nm(), cmd);\n+                }\n+            } catch (IOException e) {\n+                logger.warn(\"{}: command send i/o error: \", nm(), e);\n+            } catch (FieldException e) {\n+                logger.warn(\"{}: command send message creation error \", nm(), e);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Sends ALLLink broadcast commands to group\n+     */\n+    @NonNullByDefault\n+    public static class GroupBroadcastCommandHandler extends CommandHandler {\n+        GroupBroadcastCommandHandler(DeviceFeature f) {\n+            super(f);\n+        }\n+\n+        @Override\n+        public void handleCommand(InsteonChannelConfiguration conf, Command cmd, InsteonDevice dev) {\n+            try {\n+                if (cmd == OnOffType.ON || cmd == OnOffType.OFF) {\n+                    byte cmd1 = (byte) ((cmd == OnOffType.ON) ? 0x11 : 0x13);\n+                    byte value = (byte) ((cmd == OnOffType.ON) ? 0xFF : 0x00);\n+                    int group = getGroup(conf);\n+                    if (group == -1) {\n+                        logger.warn(\"no group=xx specified in item {}\", conf.getChannelName());\n+                        return;\n+                    }\n+                    logger.debug(\"{}: sending {} broadcast to group {}\", nm(), (cmd1 == 0x11) ? \"ON\" : \"OFF\",\n+                            getGroup(conf));\n+                    Msg m = dev.makeStandardMessage((byte) 0x0f, cmd1, value, group);\n+                    dev.enqueueMessage(m, feature);\n+                }\n+            } catch (IOException e) {\n+                logger.warn(\"{}: command send i/o error: \", nm(), e);\n+            } catch (FieldException e) {\n+                logger.warn(\"{}: command send message creation error \", nm(), e);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * This Handler was supposed to set the LEDs of the 2487S, but it doesn't work.\n+     * The parameters were modeled after the 2486D, it may work for that one,\n+     * leaving it in for now.\n+     *\n+     * From the HouseLinc PLM traffic log, the following commands (in the D2 data field)\n+     * of the 2486D are supported:\n+     *\n+     * 0x02: LED follow mask may work or not\n+     * 0x03: LED OFF mask\n+     * 0x04: X10 addr setting\n+     * 0x05: ramp rate\n+     * 0x06: on Level for button\n+     * 0x07: global LED brightness (could not see any effect during testing)\n+     * 0x0B: set nontoggle on/off command\n+     *\n+     * crucially, the 0x09 command does not work (NACK from device)\n+     *\n+     * @author Bernd Pfrommer - openHAB 1 insteonplm binding\n+     */\n+    @NonNullByDefault\n+    public static class LEDOnOffCommandHandler extends CommandHandler {\n+        LEDOnOffCommandHandler(DeviceFeature f) {\n+            super(f);\n+        }\n+\n+        @Override\n+        public void handleCommand(InsteonChannelConfiguration conf, Command cmd, InsteonDevice dev) {\n+            try {\n+                int button = this.getIntParameter(\"button\", -1);\n+                if (cmd == OnOffType.ON) {\n+                    Msg m = dev.makeExtendedMessage((byte) 0x1f, (byte) 0x2e, (byte) 0x00,\n+                            new byte[] { (byte) button, (byte) 0x09, (byte) 0x01 });\n+                    dev.enqueueMessage(m, feature);\n+                    logger.debug(\"{}: sent msg to switch {} on\", nm(), dev.getAddress());\n+                } else if (cmd == OnOffType.OFF) {\n+                    Msg m = dev.makeExtendedMessage((byte) 0x1f, (byte) 0x2e, (byte) 0x00,\n+                            new byte[] { (byte) button, (byte) 0x09, (byte) 0x00 });\n+                    dev.enqueueMessage(m, feature);\n+                    logger.debug(\"{}: sent msg to switch {} off\", nm(), dev.getAddress());\n+                }\n+            } catch (IOException e) {\n+                logger.warn(\"{}: command send i/o error: \", nm(), e);\n+            } catch (FieldException e) {\n+                logger.warn(\"{}: command send message creation error \", nm(), e);\n+            }\n+        }\n+    }\n+\n+    @NonNullByDefault\n+    public static class X10OnOffCommandHandler extends CommandHandler {\n+        X10OnOffCommandHandler(DeviceFeature f) {\n+            super(f);\n+        }\n+\n+        @Override\n+        public void handleCommand(InsteonChannelConfiguration conf, Command cmd, InsteonDevice dev) {\n+            try {\n+                byte houseCode = dev.getX10HouseCode();\n+                byte houseUnitCode = (byte) (houseCode << 4 | dev.getX10UnitCode());\n+                if (cmd == OnOffType.ON || cmd == OnOffType.OFF) {\n+                    byte houseCommandCode = (byte) (houseCode << 4\n+                            | (cmd == OnOffType.ON ? X10.Command.ON.code() : X10.Command.OFF.code()));\n+                    Msg munit = dev.makeX10Message(houseUnitCode, (byte) 0x00); // send unit code\n+                    dev.enqueueMessage(munit, feature);\n+                    Msg mcmd = dev.makeX10Message(houseCommandCode, (byte) 0x80); // send command code\n+                    dev.enqueueMessage(mcmd, feature);\n+                    String onOff = cmd == OnOffType.ON ? \"ON\" : \"OFF\";\n+                    logger.debug(\"{}: sent msg to switch {} {}\", nm(), dev.getAddress(), onOff);\n+                }\n+            } catch (IOException e) {\n+                logger.warn(\"{}: command send i/o error: \", nm(), e);\n+            } catch (FieldException e) {\n+                logger.warn(\"{}: command send message creation error \", nm(), e);\n+            }\n+        }\n+    }\n+\n+    @NonNullByDefault\n+    public static class X10PercentCommandHandler extends CommandHandler {\n+        X10PercentCommandHandler(DeviceFeature f) {\n+            super(f);\n+        }\n+\n+        @Override\n+        public void handleCommand(InsteonChannelConfiguration conf, Command cmd, InsteonDevice dev) {\n+            try {\n+                //\n+                // I did not have hardware that would respond to the PRESET_DIM codes.\n+                // This code path needs testing.\n+                //\n+                byte houseCode = dev.getX10HouseCode();\n+                byte houseUnitCode = (byte) (houseCode << 4 | dev.getX10UnitCode());\n+                Msg munit = dev.makeX10Message(houseUnitCode, (byte) 0x00); // send unit code\n+                dev.enqueueMessage(munit, feature);\n+                PercentType pc = (PercentType) cmd;\n+                logger.debug(\"{}: changing level of {} to {}\", nm(), dev.getAddress(), pc.intValue());\n+                int level = (pc.intValue() * 32) / 100;\n+                byte cmdCode = (level >= 16) ? X10.Command.PRESET_DIM_2.code() : X10.Command.PRESET_DIM_1.code();\n+                level = level % 16;\n+                if (level <= 0) {\n+                    level = 0;\n+                }\n+                houseCode = (byte) x10CodeForLevel[level];\n+                cmdCode |= (houseCode << 4);\n+                Msg mcmd = dev.makeX10Message(cmdCode, (byte) 0x80); // send command code\n+                dev.enqueueMessage(mcmd, feature);\n+            } catch (IOException e) {\n+                logger.warn(\"{}: command send i/o error: \", nm(), e);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "04a9796d14dfbc5f3ff997d872f04b6d03ee411d"}, "originalPosition": 466}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTMxNzg3MQ==", "bodyText": "This I do not understand. You clearly cannot know whether one of those exist, so why do you add a discovery result?\nCan't you check for their physical presence? If not, the user should add a bridge manually.", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r389317871", "createdAt": "2020-03-07T22:46:33Z", "author": {"login": "kaikreuzer"}, "path": "bundles/org.openhab.binding.insteon/src/main/java/org/openhab/binding/insteon/internal/discovery/InsteonNetworkDiscoveryService.java", "diffHunk": "@@ -0,0 +1,59 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.insteon.internal.discovery;\n+\n+import java.util.Arrays;\n+import java.util.HashSet;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.smarthome.config.discovery.AbstractDiscoveryService;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResultBuilder;\n+import org.eclipse.smarthome.config.discovery.DiscoveryService;\n+import org.eclipse.smarthome.core.thing.ThingUID;\n+import org.openhab.binding.insteon.internal.InsteonBindingConstants;\n+import org.osgi.service.component.annotations.Component;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link InsteonNetworkDiscoveryService} is responsible for device discovery.\n+ *\n+ * @author Rob Nielsen - Initial contribution\n+ */\n+@NonNullByDefault\n+@Component(service = DiscoveryService.class, immediate = true, configurationPid = \"discovery.insteon\")\n+public class InsteonNetworkDiscoveryService extends AbstractDiscoveryService {\n+    private final Logger logger = LoggerFactory.getLogger(InsteonNetworkDiscoveryService.class);\n+\n+    private static final ThingUID LOCAL_THING = new ThingUID(InsteonBindingConstants.NETWORK_THING_TYPE, \"local\");\n+\n+    private static final int DISCOVER_TIMEOUT_SECONDS = 2;\n+\n+    public InsteonNetworkDiscoveryService() {\n+        super(new HashSet<>(Arrays.asList(InsteonBindingConstants.NETWORK_THING_TYPE)), DISCOVER_TIMEOUT_SECONDS, true);\n+\n+        logger.debug(\"Initializing InsteonNetworkDiscoveryService\");\n+    }\n+\n+    @Override\n+    protected void startBackgroundDiscovery() {\n+        startScan();\n+    }\n+\n+    @Override\n+    protected void startScan() {\n+        logger.debug(\"Starting scan for Insteon network\");\n+\n+        thingDiscovered(DiscoveryResultBuilder.create(LOCAL_THING).withLabel(\"Insteon PLM or Hub\").build());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "04a9796d14dfbc5f3ff997d872f04b6d03ee411d"}, "originalPosition": 57}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTMxODE1MA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            String msg = \"Unable to start Insteon device, the insteon or X10 address '\" + address\n          \n          \n            \n                                    + \"' is invalid. It must be in the format 'AB.CD.EF' or 'H.U' (X10).\";\n          \n          \n            \n                            logger.warn(msg);\n          \n          \n            \n                            String msg = \"Unable to start Insteon device, the insteon or X10 address '\" + address\n          \n          \n            \n                                    + \"' is invalid. It must be in the format 'AB.CD.EF' or 'H.U' (X10).\";\n          \n          \n            \n                            logger.warn(\"{}\", msg);", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r389318150", "createdAt": "2020-03-07T22:52:48Z", "author": {"login": "kaikreuzer"}, "path": "bundles/org.openhab.binding.insteon/src/main/java/org/openhab/binding/insteon/internal/handler/InsteonDeviceHandler.java", "diffHunk": "@@ -0,0 +1,329 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.insteon.internal.handler;\n+\n+import java.math.BigDecimal;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.builder.ThingBuilder;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.openhab.binding.insteon.internal.InsteonBinding;\n+import org.openhab.binding.insteon.internal.InsteonBindingConstants;\n+import org.openhab.binding.insteon.internal.config.InsteonChannelConfiguration;\n+import org.openhab.binding.insteon.internal.config.InsteonDeviceConfiguration;\n+import org.openhab.binding.insteon.internal.device.DeviceFeature;\n+import org.openhab.binding.insteon.internal.device.DeviceTypeLoader;\n+import org.openhab.binding.insteon.internal.device.InsteonAddress;\n+import org.openhab.binding.insteon.internal.device.InsteonDevice;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link InsteonDeviceHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Rob Nielsen - Initial contribution\n+ */\n+@NonNullByDefault\n+public class InsteonDeviceHandler extends BaseThingHandler {\n+\n+    private static final Set<String> DEFINED_CHANNELS = Collections.unmodifiableSet(Stream.of(\n+            InsteonBindingConstants.AC_DELAY, InsteonBindingConstants.BACKLIGHT_DURATION,\n+            InsteonBindingConstants.BATTERY_LEVEL, InsteonBindingConstants.BATTERY_WATERMARK_LEVEL,\n+            InsteonBindingConstants.BOTTOM_OUTLET, InsteonBindingConstants.BUTTON_A, InsteonBindingConstants.BUTTON_B,\n+            InsteonBindingConstants.BUTTON_C, InsteonBindingConstants.BUTTON_D, InsteonBindingConstants.BUTTON_E,\n+            InsteonBindingConstants.BUTTON_F, InsteonBindingConstants.BUTTON_G, InsteonBindingConstants.BUTTON_H,\n+            InsteonBindingConstants.BROADCAST_ON_OFF, InsteonBindingConstants.CONTACT,\n+            InsteonBindingConstants.COOL_SET_POINT, InsteonBindingConstants.DIMMER, InsteonBindingConstants.FAN,\n+            InsteonBindingConstants.FAN_MODE, InsteonBindingConstants.FAST_ON_OFF,\n+            InsteonBindingConstants.FAST_ON_OFF_BUTTON_A, InsteonBindingConstants.FAST_ON_OFF_BUTTON_B,\n+            InsteonBindingConstants.FAST_ON_OFF_BUTTON_C, InsteonBindingConstants.FAST_ON_OFF_BUTTON_D,\n+            InsteonBindingConstants.HEAT_SET_POINT, InsteonBindingConstants.HUMIDITY,\n+            InsteonBindingConstants.HUMIDITY_HIGH, InsteonBindingConstants.HUMIDITY_LOW,\n+            InsteonBindingConstants.IS_COOLING, InsteonBindingConstants.IS_HEATING,\n+            InsteonBindingConstants.KEYPAD_BUTTON_A, InsteonBindingConstants.KEYPAD_BUTTON_B,\n+            InsteonBindingConstants.KEYPAD_BUTTON_C, InsteonBindingConstants.KEYPAD_BUTTON_D,\n+            InsteonBindingConstants.KEYPAD_BUTTON_E, InsteonBindingConstants.KEYPAD_BUTTON_F,\n+            InsteonBindingConstants.KEYPAD_BUTTON_G, InsteonBindingConstants.KEYPAD_BUTTON_H,\n+            InsteonBindingConstants.KWH, InsteonBindingConstants.LAST_HEARD_FROM,\n+            InsteonBindingConstants.LED_BRIGHTNESS, InsteonBindingConstants.LIGHT_DIMMER,\n+            InsteonBindingConstants.LIGHT_LEVEL, InsteonBindingConstants.LOAD_DIMMER,\n+            InsteonBindingConstants.LOAD_SWITCH, InsteonBindingConstants.LOAD_SWITCH_FAST_ON_OFF,\n+            InsteonBindingConstants.LOAD_SWITCH_MANUAL_CHANGE, InsteonBindingConstants.MANUAL_CHANGE,\n+            InsteonBindingConstants.MANUAL_CHANGE_BUTTON_A, InsteonBindingConstants.MANUAL_CHANGE_BUTTON_B,\n+            InsteonBindingConstants.MANUAL_CHANGE_BUTTON_C, InsteonBindingConstants.MANUAL_CHANGE_BUTTON_D,\n+            InsteonBindingConstants.NOTIFICATION, InsteonBindingConstants.ON_LEVEL, InsteonBindingConstants.RAMP_DIMMER,\n+            InsteonBindingConstants.RAMP_RATE, InsteonBindingConstants.RESET, InsteonBindingConstants.STAGE1_DURATION,\n+            InsteonBindingConstants.SWITCH, InsteonBindingConstants.SYSTEM_MODE, InsteonBindingConstants.TEMP_CELSIUS,\n+            InsteonBindingConstants.TEMP_FAHRENHEIT, InsteonBindingConstants.TOP_OUTLET, InsteonBindingConstants.UPDATE,\n+            InsteonBindingConstants.WATTS).collect(Collectors.toSet()));\n+\n+    private static final String BROADCAST_ON_OFF = \"broadcastonoff\";\n+    private static final String CMD = \"cmd\";\n+    private static final String CMD_RESET = \"reset\";\n+    private static final String CMD_UPDATE = \"update\";\n+    private static final String DATA = \"data\";\n+    private static final String FIELD = \"field\";\n+    private static final String FIELD_BATTERY_LEVEL = \"battery_level\";\n+    private static final String FIELD_BATTERY_WATERMARK_LEVEL = \"battery_watermark_level\";\n+    private static final String FIELD_KWH = \"kwh\";\n+    private static final String FIELD_LIGHT_LEVEL = \"light_level\";\n+    private static final String FIELD_WATTS = \"watts\";\n+    private static final String GROUP = \"group\";\n+    private static final String METER = \"meter\";\n+\n+    private static final String HIDDEN_DOOR_SENSOR_PRODUCT_KEY = \"F00.00.03\";\n+    private static final String MOTION_SENSOR_PRODUCT_KEY = \"0x00004A\";\n+    private static final String PLM_PRODUCT_KEY = \"0x000045\";\n+    private static final String POWER_METER_PRODUCT_KEY = \"F00.00.17\";\n+\n+    private final Logger logger = LoggerFactory.getLogger(InsteonDeviceHandler.class);\n+\n+    private @Nullable InsteonDeviceConfiguration config;\n+\n+    public InsteonDeviceHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        config = getConfigAs(InsteonDeviceConfiguration.class);\n+\n+        scheduler.execute(() -> {\n+            if (getBridge() == null) {\n+                String msg = \"An Insteon network bridge has not been selected for this device.\";\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, msg);\n+                return;\n+            }\n+\n+            String address = config.getAddress();\n+            if (!InsteonAddress.s_isValid(address)) {\n+                String msg = \"Unable to start Insteon device, the insteon or X10 address '\" + address\n+                        + \"' is invalid. It must be in the format 'AB.CD.EF' or 'H.U' (X10).\";\n+                logger.warn(msg);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Njc1MDI1Mg=="}, "originalCommit": {"oid": "ed93353c47fa5d457223c66d8f91b1c168a57e23"}, "originalPosition": 128}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTMxODIzOQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    logger.info(\"Starting Insteon bridge\");\n          \n          \n            \n                    logger.debug(\"Starting Insteon bridge\");", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r389318239", "createdAt": "2020-03-07T22:54:07Z", "author": {"login": "kaikreuzer"}, "path": "bundles/org.openhab.binding.insteon/src/main/java/org/openhab/binding/insteon/internal/handler/InsteonNetworkHandler.java", "diffHunk": "@@ -0,0 +1,148 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.insteon.internal.handler;\n+\n+import java.util.List;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseBridgeHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.openhab.binding.insteon.internal.InsteonBinding;\n+import org.openhab.binding.insteon.internal.config.InsteonNetworkConfiguration;\n+import org.openhab.binding.insteon.internal.discovery.InsteonDeviceDiscoveryService;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link InsteonNetworkHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Rob Nielsen - Initial contribution\n+ */\n+@NonNullByDefault\n+@SuppressWarnings(\"null\")\n+public class InsteonNetworkHandler extends BaseBridgeHandler {\n+\n+    private static final int LOG_DEVICE_STATISTICS_DELAY_IN_SECONDS = 600;\n+    private static final int SETTLE_TIME_IN_SECONDS = 5;\n+\n+    private final Logger logger = LoggerFactory.getLogger(InsteonNetworkHandler.class);\n+\n+    private @Nullable InsteonNetworkConfiguration config;\n+    private @Nullable InsteonBinding insteonBinding;\n+    private @Nullable InsteonDeviceDiscoveryService insteonDeviceDiscoveryService;\n+    private @Nullable ScheduledFuture<?> pollingJob = null;\n+    private @Nullable ScheduledFuture<?> settleJob = null;\n+    private long lastInsteonDeviceCreatedTimestamp = 0;\n+    private @Nullable SerialPortManager serialPortManager;\n+\n+    public static ClassLoader classLoader = Thread.currentThread().getContextClassLoader();\n+\n+    public InsteonNetworkHandler(Bridge bridge, @Nullable SerialPortManager serialPortManager) {\n+        super(bridge);\n+        this.serialPortManager = serialPortManager;\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.info(\"Starting Insteon bridge\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "04a9796d14dfbc5f3ff997d872f04b6d03ee411d"}, "originalPosition": 71}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTMxODI1NA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        updateStatus(ThingStatus.ONLINE);\n          \n          \n            \n                        updateStatus(ThingStatus.UNKOWN);\n          \n      \n    \n    \n  \n\nYou didn't have any successful communication with the bridge here, did you?", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r389318254", "createdAt": "2020-03-07T22:54:50Z", "author": {"login": "kaikreuzer"}, "path": "bundles/org.openhab.binding.insteon/src/main/java/org/openhab/binding/insteon/internal/handler/InsteonNetworkHandler.java", "diffHunk": "@@ -0,0 +1,148 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.insteon.internal.handler;\n+\n+import java.util.List;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseBridgeHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.openhab.binding.insteon.internal.InsteonBinding;\n+import org.openhab.binding.insteon.internal.config.InsteonNetworkConfiguration;\n+import org.openhab.binding.insteon.internal.discovery.InsteonDeviceDiscoveryService;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link InsteonNetworkHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Rob Nielsen - Initial contribution\n+ */\n+@NonNullByDefault\n+@SuppressWarnings(\"null\")\n+public class InsteonNetworkHandler extends BaseBridgeHandler {\n+\n+    private static final int LOG_DEVICE_STATISTICS_DELAY_IN_SECONDS = 600;\n+    private static final int SETTLE_TIME_IN_SECONDS = 5;\n+\n+    private final Logger logger = LoggerFactory.getLogger(InsteonNetworkHandler.class);\n+\n+    private @Nullable InsteonNetworkConfiguration config;\n+    private @Nullable InsteonBinding insteonBinding;\n+    private @Nullable InsteonDeviceDiscoveryService insteonDeviceDiscoveryService;\n+    private @Nullable ScheduledFuture<?> pollingJob = null;\n+    private @Nullable ScheduledFuture<?> settleJob = null;\n+    private long lastInsteonDeviceCreatedTimestamp = 0;\n+    private @Nullable SerialPortManager serialPortManager;\n+\n+    public static ClassLoader classLoader = Thread.currentThread().getContextClassLoader();\n+\n+    public InsteonNetworkHandler(Bridge bridge, @Nullable SerialPortManager serialPortManager) {\n+        super(bridge);\n+        this.serialPortManager = serialPortManager;\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.info(\"Starting Insteon bridge\");\n+        config = getConfigAs(InsteonNetworkConfiguration.class);\n+\n+        scheduler.execute(() -> {\n+            insteonBinding = new InsteonBinding(this, config, serialPortManager);\n+\n+            updateStatus(ThingStatus.ONLINE);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "04a9796d14dfbc5f3ff997d872f04b6d03ee411d"}, "originalPosition": 77}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTMxODI4Nw==", "bodyText": "here you can set it to ONLINE", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r389318287", "createdAt": "2020-03-07T22:55:17Z", "author": {"login": "kaikreuzer"}, "path": "bundles/org.openhab.binding.insteon/src/main/java/org/openhab/binding/insteon/internal/handler/InsteonNetworkHandler.java", "diffHunk": "@@ -0,0 +1,148 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.insteon.internal.handler;\n+\n+import java.util.List;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseBridgeHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.openhab.binding.insteon.internal.InsteonBinding;\n+import org.openhab.binding.insteon.internal.config.InsteonNetworkConfiguration;\n+import org.openhab.binding.insteon.internal.discovery.InsteonDeviceDiscoveryService;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link InsteonNetworkHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Rob Nielsen - Initial contribution\n+ */\n+@NonNullByDefault\n+@SuppressWarnings(\"null\")\n+public class InsteonNetworkHandler extends BaseBridgeHandler {\n+\n+    private static final int LOG_DEVICE_STATISTICS_DELAY_IN_SECONDS = 600;\n+    private static final int SETTLE_TIME_IN_SECONDS = 5;\n+\n+    private final Logger logger = LoggerFactory.getLogger(InsteonNetworkHandler.class);\n+\n+    private @Nullable InsteonNetworkConfiguration config;\n+    private @Nullable InsteonBinding insteonBinding;\n+    private @Nullable InsteonDeviceDiscoveryService insteonDeviceDiscoveryService;\n+    private @Nullable ScheduledFuture<?> pollingJob = null;\n+    private @Nullable ScheduledFuture<?> settleJob = null;\n+    private long lastInsteonDeviceCreatedTimestamp = 0;\n+    private @Nullable SerialPortManager serialPortManager;\n+\n+    public static ClassLoader classLoader = Thread.currentThread().getContextClassLoader();\n+\n+    public InsteonNetworkHandler(Bridge bridge, @Nullable SerialPortManager serialPortManager) {\n+        super(bridge);\n+        this.serialPortManager = serialPortManager;\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.info(\"Starting Insteon bridge\");\n+        config = getConfigAs(InsteonNetworkConfiguration.class);\n+\n+        scheduler.execute(() -> {\n+            insteonBinding = new InsteonBinding(this, config, serialPortManager);\n+\n+            updateStatus(ThingStatus.ONLINE);\n+\n+            // hold off on starting to poll until devices that already are defined as things are added.\n+            // wait SETTLE_TIME_IN_SECONDS to start then check every second afterwards until it has been at\n+            // least SETTLE_TIME_IN_SECONDS since last device was created.\n+            settleJob = scheduler.scheduleWithFixedDelay(() -> {\n+                // check to see if it has been at least SETTLE_TIME_IN_SECONDS since last device was created\n+                if (System.currentTimeMillis() - lastInsteonDeviceCreatedTimestamp > SETTLE_TIME_IN_SECONDS * 1000) {\n+                    // settle time has expired start polling\n+                    if (insteonBinding.startPolling()) {\n+                        pollingJob = scheduler.scheduleWithFixedDelay(() -> {\n+                            insteonBinding.logDeviceStatistics();\n+                        }, 0, LOG_DEVICE_STATISTICS_DELAY_IN_SECONDS, TimeUnit.SECONDS);\n+\n+                        insteonBinding.setIsActive(true);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "04a9796d14dfbc5f3ff997d872f04b6d03ee411d"}, "originalPosition": 91}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTMxODI5Mg==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    logger.info(\"Shutting down Insteon bridge\");\n          \n          \n            \n                    logger.debug(\"Shutting down Insteon bridge\");", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r389318292", "createdAt": "2020-03-07T22:55:32Z", "author": {"login": "kaikreuzer"}, "path": "bundles/org.openhab.binding.insteon/src/main/java/org/openhab/binding/insteon/internal/handler/InsteonNetworkHandler.java", "diffHunk": "@@ -0,0 +1,148 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.insteon.internal.handler;\n+\n+import java.util.List;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseBridgeHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.openhab.binding.insteon.internal.InsteonBinding;\n+import org.openhab.binding.insteon.internal.config.InsteonNetworkConfiguration;\n+import org.openhab.binding.insteon.internal.discovery.InsteonDeviceDiscoveryService;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link InsteonNetworkHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Rob Nielsen - Initial contribution\n+ */\n+@NonNullByDefault\n+@SuppressWarnings(\"null\")\n+public class InsteonNetworkHandler extends BaseBridgeHandler {\n+\n+    private static final int LOG_DEVICE_STATISTICS_DELAY_IN_SECONDS = 600;\n+    private static final int SETTLE_TIME_IN_SECONDS = 5;\n+\n+    private final Logger logger = LoggerFactory.getLogger(InsteonNetworkHandler.class);\n+\n+    private @Nullable InsteonNetworkConfiguration config;\n+    private @Nullable InsteonBinding insteonBinding;\n+    private @Nullable InsteonDeviceDiscoveryService insteonDeviceDiscoveryService;\n+    private @Nullable ScheduledFuture<?> pollingJob = null;\n+    private @Nullable ScheduledFuture<?> settleJob = null;\n+    private long lastInsteonDeviceCreatedTimestamp = 0;\n+    private @Nullable SerialPortManager serialPortManager;\n+\n+    public static ClassLoader classLoader = Thread.currentThread().getContextClassLoader();\n+\n+    public InsteonNetworkHandler(Bridge bridge, @Nullable SerialPortManager serialPortManager) {\n+        super(bridge);\n+        this.serialPortManager = serialPortManager;\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.info(\"Starting Insteon bridge\");\n+        config = getConfigAs(InsteonNetworkConfiguration.class);\n+\n+        scheduler.execute(() -> {\n+            insteonBinding = new InsteonBinding(this, config, serialPortManager);\n+\n+            updateStatus(ThingStatus.ONLINE);\n+\n+            // hold off on starting to poll until devices that already are defined as things are added.\n+            // wait SETTLE_TIME_IN_SECONDS to start then check every second afterwards until it has been at\n+            // least SETTLE_TIME_IN_SECONDS since last device was created.\n+            settleJob = scheduler.scheduleWithFixedDelay(() -> {\n+                // check to see if it has been at least SETTLE_TIME_IN_SECONDS since last device was created\n+                if (System.currentTimeMillis() - lastInsteonDeviceCreatedTimestamp > SETTLE_TIME_IN_SECONDS * 1000) {\n+                    // settle time has expired start polling\n+                    if (insteonBinding.startPolling()) {\n+                        pollingJob = scheduler.scheduleWithFixedDelay(() -> {\n+                            insteonBinding.logDeviceStatistics();\n+                        }, 0, LOG_DEVICE_STATISTICS_DELAY_IN_SECONDS, TimeUnit.SECONDS);\n+\n+                        insteonBinding.setIsActive(true);\n+                    } else {\n+                        String msg = \"Initialization failed, unable to start the Insteon bridge with the port '\"\n+                                + config.getPort() + \"'.\";\n+                        logger.warn(msg);\n+\n+                        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, msg);\n+                    }\n+\n+                    settleJob.cancel(true);\n+                    settleJob = null;\n+                }\n+            }, SETTLE_TIME_IN_SECONDS, 1, TimeUnit.SECONDS);\n+        });\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.info(\"Shutting down Insteon bridge\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "04a9796d14dfbc5f3ff997d872f04b6d03ee411d"}, "originalPosition": 109}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTMxODQxMw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\t<label>light Dimmer</label>\n          \n          \n            \n            \t\t<label>Light Dimmer</label>", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r389318413", "createdAt": "2020-03-07T22:57:54Z", "author": {"login": "kaikreuzer"}, "path": "bundles/org.openhab.binding.insteon/src/main/resources/ESH-INF/thing/thing-types.xml", "diffHunk": "@@ -0,0 +1,453 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"insteon\"\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\n+\t<bridge-type id=\"network\">\n+\t\t<label>Insteon Network</label>\n+\t\t<description>An Insteon PLM or hub that is used to communicate with the Insteon devices.</description>\n+\n+\t\t<config-description>\n+\t\t\t<parameter name=\"port\" type=\"text\" required=\"true\">\n+\t\t\t\t<label>Port</label>\n+\t\t\t\t<description>Configuration information that is used to connect to PLM or hub.</description>\n+\t\t\t</parameter>\n+\n+\t\t\t<parameter name=\"devicePollIntervalSeconds\" type=\"integer\" min=\"5\" max=\"3600\">\n+\t\t\t\t<label>Device Poll Interval</label>\n+\t\t\t\t<description>Device poll interval in seconds.</description>\n+\t\t\t</parameter>\n+\n+\t\t\t<parameter name=\"modemDbRetryTimeoutSeconds\" type=\"integer\" min=\"30\" max=\"600\">\n+\t\t\t\t<label>Modem DB Retry Timeout</label>\n+\t\t\t\t<description>Modem DB retry timeout in seconds.</description>\n+\t\t\t</parameter>\n+\n+\n+\t\t\t<parameter name=\"additionalDevices\" type=\"text\">\n+\t\t\t\t<label>Additional Devices</label>\n+\t\t\t\t<description>Optional file with additional device types.</description>\n+\t\t\t</parameter>\n+\n+\t\t\t<parameter name=\"additionalFeatures\" type=\"text\">\n+\t\t\t\t<label>Additional Features</label>\n+\t\t\t\t<description>Optional file with additional feature templates.</description>\n+\t\t\t</parameter>\n+\t\t</config-description>\n+\t</bridge-type>\n+\n+\t<thing-type id=\"device\">\n+\t\t<supported-bridge-type-refs>\n+\t\t\t<bridge-type-ref id=\"network\" />\n+\t\t</supported-bridge-type-refs>\n+\n+\t\t<label>Insteon Device</label>\n+\t\t<description>Insteon devices such as switches, dimmers, keypads, sensors, etc.</description>\n+\n+\t\t<channels>\n+\t\t\t<channel id=\"acDelay\" typeId=\"acDelay\" />\n+\t\t\t<channel id=\"backlightDuration\" typeId=\"backlightDuration\" />\n+\t\t\t<channel id=\"batteryLevel\" typeId=\"batteryLevel\" />\n+\t\t\t<channel id=\"batteryWatermarkLevel\" typeId=\"batteryWatermarkLevel\" />\n+\t\t\t<channel id=\"bottomOutlet\" typeId=\"bottomOutlet\" />\n+\t\t\t<channel id=\"buttonA\" typeId=\"buttonA\" />\n+\t\t\t<channel id=\"buttonB\" typeId=\"buttonB\" />\n+\t\t\t<channel id=\"buttonC\" typeId=\"buttonC\" />\n+\t\t\t<channel id=\"buttonD\" typeId=\"buttonD\" />\n+\t\t\t<channel id=\"buttonE\" typeId=\"buttonE\" />\n+\t\t\t<channel id=\"buttonF\" typeId=\"buttonF\" />\n+\t\t\t<channel id=\"buttonG\" typeId=\"buttonG\" />\n+\t\t\t<channel id=\"buttonH\" typeId=\"buttonH\" />\n+\t\t\t<channel id=\"broadcastOnOff\" typeId=\"broadcastOnOff\" />\n+\t\t\t<channel id=\"contact\" typeId=\"contact\" />\n+\t\t\t<channel id=\"coolSetPoint\" typeId=\"coolSetPoint\" />\n+\t\t\t<channel id=\"dimmer\" typeId=\"dimmer\" />\n+\t\t\t<channel id=\"fan\" typeId=\"fan\" />\n+\t\t\t<channel id=\"fanMode\" typeId=\"fanMode\" />\n+\t\t\t<channel id=\"fastOnOff\" typeId=\"fastOnOff\" />\n+\t\t\t<channel id=\"fastOnOffButtonA\" typeId=\"fastOnOffButtonA\" />\n+\t\t\t<channel id=\"fastOnOffButtonB\" typeId=\"fastOnOffButtonB\" />\n+\t\t\t<channel id=\"fastOnOffButtonC\" typeId=\"fastOnOffButtonC\" />\n+\t\t\t<channel id=\"fastOnOffButtonD\" typeId=\"fastOnOffButtonD\" />\n+\t\t\t<channel id=\"heatSetPoint\" typeId=\"heatSetPoint\" />\n+\t\t\t<channel id=\"humidity\" typeId=\"humidity\" />\n+\t\t\t<channel id=\"humidityHigh\" typeId=\"humidityHigh\" />\n+\t\t\t<channel id=\"humidityLow\" typeId=\"humidityLow\" />\n+\t\t\t<channel id=\"isCooling\" typeId=\"isCooling\" />\n+\t\t\t<channel id=\"isHeating\" typeId=\"isHeating\" />\n+\t\t\t<channel id=\"keypadButtonA\" typeId=\"keypadButtonA\" />\n+\t\t\t<channel id=\"keypadButtonB\" typeId=\"keypadButtonB\" />\n+\t\t\t<channel id=\"keypadButtonC\" typeId=\"keypadButtonC\" />\n+\t\t\t<channel id=\"keypadButtonD\" typeId=\"keypadButtonD\" />\n+\t\t\t<channel id=\"keypadButtonE\" typeId=\"keypadButtonE\" />\n+\t\t\t<channel id=\"keypadButtonF\" typeId=\"keypadButtonF\" />\n+\t\t\t<channel id=\"keypadButtonG\" typeId=\"keypadButtonG\" />\n+\t\t\t<channel id=\"keypadButtonH\" typeId=\"keypadButtonH\" />\n+\t\t\t<channel id=\"kWh\" typeId=\"kWh\" />\n+\t\t\t<channel id=\"lastHeardFrom\" typeId=\"lastHeardFrom\" />\n+\t\t\t<channel id=\"ledBrightness\" typeId=\"ledBrightness\" />\n+\t\t\t<channel id=\"lightDimmer\" typeId=\"lightDimmer\" />\n+\t\t\t<channel id=\"lightLevel\" typeId=\"lightLevel\" />\n+\t\t\t<channel id=\"loadDimmer\" typeId=\"loadDimmer\" />\n+\t\t\t<channel id=\"loadSwitch\" typeId=\"loadSwitch\" />\n+\t\t\t<channel id=\"loadSwitchFastOnOff\" typeId=\"loadSwitchFastOnOff\" />\n+\t\t\t<channel id=\"loadSwitchManualChange\" typeId=\"loadSwitchManualChange\" />\n+\t\t\t<channel id=\"manualChange\" typeId=\"manualChange\" />\n+\t\t\t<channel id=\"manualChangeButtonA\" typeId=\"manualChangeButtonA\" />\n+\t\t\t<channel id=\"manualChangeButtonB\" typeId=\"manualChangeButtonB\" />\n+\t\t\t<channel id=\"manualChangeButtonC\" typeId=\"manualChangeButtonC\" />\n+\t\t\t<channel id=\"manualChangeButtonD\" typeId=\"manualChangeButtonD\" />\n+\t\t\t<channel id=\"notification\" typeId=\"notification\" />\n+\t\t\t<channel id=\"onLevel\" typeId=\"onLevel\" />\n+\t\t\t<channel id=\"rampDimmer\" typeId=\"rampDimmer\" />\n+\t\t\t<channel id=\"rampRate\" typeId=\"rampRate\" />\n+\t\t\t<channel id=\"reset\" typeId=\"reset\" />\n+\t\t\t<channel id=\"stage1Duration\" typeId=\"stage1Duration\" />\n+\t\t\t<channel id=\"switch\" typeId=\"switch\" />\n+\t\t\t<channel id=\"systemMode\" typeId=\"systemMode\" />\n+\t\t\t<channel id=\"tempCelsius\" typeId=\"tempCelsius\" />\n+\t\t\t<channel id=\"tempFahrenheit\" typeId=\"tempFahrenheit\" />\n+\t\t\t<channel id=\"topOutlet\" typeId=\"topOutlet\" />\n+\t\t\t<channel id=\"update\" typeId=\"update\" />\n+\t\t\t<channel id=\"watts\" typeId=\"watts\" />\n+\t\t</channels>\n+\n+\t\t<config-description>\n+\t\t\t<parameter name=\"address\" type=\"text\" required=\"true\">\n+\t\t\t\t<label>Address</label>\n+\t\t\t\t<description>Insteon address of the device.</description>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"productKey\" type=\"text\" required=\"true\">\n+\t\t\t\t<label>Product Key</label>\n+\t\t\t\t<description>Insteon binding product key that is used to identify the model of the device.</description>\n+\t\t\t</parameter>\n+\t\t</config-description>\n+\t</thing-type>\n+\n+\t<channel-type id=\"acDelay\">\n+\t\t<item-type>Number</item-type>\n+\t\t<label>AC Delay</label>\n+\t</channel-type>\n+\n+\t<channel-type id=\"backlightDuration\">\n+\t\t<item-type>Number</item-type>\n+\t\t<label>Back Light Duration</label>\n+\t</channel-type>\n+\n+\t<channel-type id=\"batteryLevel\">\n+\t\t<item-type>Number</item-type>\n+\t\t<label>Battery Level</label>\n+\t</channel-type>\n+\n+\t<channel-type id=\"batteryWatermarkLevel\">\n+\t\t<item-type>Number</item-type>\n+\t\t<label>Battery Watermark Level</label>\n+\t</channel-type>\n+\n+\t<channel-type id=\"bottomOutlet\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Bottom Outlet</label>\n+\t</channel-type>\n+\n+\t<channel-type id=\"buttonA\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Button A</label>\n+\t</channel-type>\n+\n+\t<channel-type id=\"buttonB\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Button B</label>\n+\t</channel-type>\n+\n+\t<channel-type id=\"buttonC\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Button C</label>\n+\t</channel-type>\n+\n+\t<channel-type id=\"buttonD\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Button D</label>\n+\t</channel-type>\n+\n+\t<channel-type id=\"buttonE\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Button E</label>\n+\t</channel-type>\n+\n+\t<channel-type id=\"buttonF\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Button F</label>\n+\t</channel-type>\n+\n+\t<channel-type id=\"buttonG\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Button G</label>\n+\t</channel-type>\n+\n+\t<channel-type id=\"buttonH\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Button H</label>\n+\t</channel-type>\n+\n+\t<channel-type id=\"broadcastOnOff\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Broadcast On/Off</label>\n+\t</channel-type>\n+\n+\t<channel-type id=\"contact\">\n+\t\t<item-type>Contact</item-type>\n+\t\t<label>Contact</label>\n+\t</channel-type>\n+\n+\t<channel-type id=\"coolSetPoint\">\n+\t\t<item-type>Number</item-type>\n+\t\t<label>Cool Set Point</label>\n+\t</channel-type>\n+\n+\t<channel-type id=\"dimmer\">\n+\t\t<item-type>Dimmer</item-type>\n+\t\t<label>Dimmer</label>\n+\t</channel-type>\n+\n+\t<channel-type id=\"fan\">\n+\t\t<item-type>Number</item-type>\n+\t\t<label>Fan</label>\n+\t</channel-type>\n+\n+\t<channel-type id=\"fanMode\">\n+\t\t<item-type>Number</item-type>\n+\t\t<label>Fan Mode</label>\n+\t</channel-type>\n+\n+\t<channel-type id=\"fastOnOff\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Fast On/Off</label>\n+\t</channel-type>\n+\n+\t<channel-type id=\"fastOnOffButtonA\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Fast On/Off Button A</label>\n+\t</channel-type>\n+\n+\t<channel-type id=\"fastOnOffButtonB\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Fast On/Off Button B</label>\n+\t</channel-type>\n+\n+\t<channel-type id=\"fastOnOffButtonC\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Fast On/Off Button C</label>\n+\t</channel-type>\n+\n+\t<channel-type id=\"fastOnOffButtonD\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Fast On/Off Button D</label>\n+\t</channel-type>\n+\n+\t<channel-type id=\"heatSetPoint\">\n+\t\t<item-type>Number</item-type>\n+\t\t<label>Heat Set Point</label>\n+\t</channel-type>\n+\n+\t<channel-type id=\"humidity\">\n+\t\t<item-type>Number</item-type>\n+\t\t<label>Humidity</label>\n+\t</channel-type>\n+\n+\t<channel-type id=\"humidityHigh\">\n+\t\t<item-type>Number</item-type>\n+\t\t<label>Humidity High</label>\n+\t</channel-type>\n+\n+\t<channel-type id=\"humidityLow\">\n+\t\t<item-type>Number</item-type>\n+\t\t<label>Humidity Low</label>\n+\t</channel-type>\n+\n+\t<channel-type id=\"isCooling\">\n+\t\t<item-type>Number</item-type>\n+\t\t<label>Is Cooling</label>\n+\t</channel-type>\n+\n+\t<channel-type id=\"isHeating\">\n+\t\t<item-type>Number</item-type>\n+\t\t<label>Is Heating</label>\n+\t</channel-type>\n+\n+\t<channel-type id=\"keypadButtonA\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Keypad Button A</label>\n+\t</channel-type>\n+\n+\t<channel-type id=\"keypadButtonB\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Keypad Button B</label>\n+\t</channel-type>\n+\n+\t<channel-type id=\"keypadButtonC\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Keypad Button C</label>\n+\t</channel-type>\n+\n+\t<channel-type id=\"keypadButtonD\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Keypad Button D</label>\n+\t</channel-type>\n+\n+\t<channel-type id=\"keypadButtonE\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Keypad Button E</label>\n+\t</channel-type>\n+\n+\t<channel-type id=\"keypadButtonF\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Keypad Button F</label>\n+\t</channel-type>\n+\n+\t<channel-type id=\"keypadButtonG\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Keypad Button G</label>\n+\t</channel-type>\n+\n+\t<channel-type id=\"keypadButtonH\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Keypad Button H</label>\n+\t</channel-type>\n+\n+\t<channel-type id=\"kWh\">\n+\t\t<item-type>Number</item-type>\n+\t\t<label>Kilowatt Hour</label>\n+\t</channel-type>\n+\n+\t<channel-type id=\"lastHeardFrom\">\n+\t\t<item-type>DateTime</item-type>\n+\t\t<label>Last Heard From</label>\n+\t</channel-type>\n+\n+\t<channel-type id=\"ledBrightness\">\n+\t\t<item-type>Number</item-type>\n+\t\t<label>LED brightness</label>\n+\t</channel-type>\n+\n+\t<channel-type id=\"lightDimmer\">\n+\t\t<item-type>Dimmer</item-type>\n+\t\t<label>light Dimmer</label>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "04a9796d14dfbc5f3ff997d872f04b6d03ee411d"}, "originalPosition": 335}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTMxODQxNw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\t<label>LED brightness</label>\n          \n          \n            \n            \t\t<label>LED Brightness</label>", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r389318417", "createdAt": "2020-03-07T22:58:04Z", "author": {"login": "kaikreuzer"}, "path": "bundles/org.openhab.binding.insteon/src/main/resources/ESH-INF/thing/thing-types.xml", "diffHunk": "@@ -0,0 +1,453 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"insteon\"\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\n+\t<bridge-type id=\"network\">\n+\t\t<label>Insteon Network</label>\n+\t\t<description>An Insteon PLM or hub that is used to communicate with the Insteon devices.</description>\n+\n+\t\t<config-description>\n+\t\t\t<parameter name=\"port\" type=\"text\" required=\"true\">\n+\t\t\t\t<label>Port</label>\n+\t\t\t\t<description>Configuration information that is used to connect to PLM or hub.</description>\n+\t\t\t</parameter>\n+\n+\t\t\t<parameter name=\"devicePollIntervalSeconds\" type=\"integer\" min=\"5\" max=\"3600\">\n+\t\t\t\t<label>Device Poll Interval</label>\n+\t\t\t\t<description>Device poll interval in seconds.</description>\n+\t\t\t</parameter>\n+\n+\t\t\t<parameter name=\"modemDbRetryTimeoutSeconds\" type=\"integer\" min=\"30\" max=\"600\">\n+\t\t\t\t<label>Modem DB Retry Timeout</label>\n+\t\t\t\t<description>Modem DB retry timeout in seconds.</description>\n+\t\t\t</parameter>\n+\n+\n+\t\t\t<parameter name=\"additionalDevices\" type=\"text\">\n+\t\t\t\t<label>Additional Devices</label>\n+\t\t\t\t<description>Optional file with additional device types.</description>\n+\t\t\t</parameter>\n+\n+\t\t\t<parameter name=\"additionalFeatures\" type=\"text\">\n+\t\t\t\t<label>Additional Features</label>\n+\t\t\t\t<description>Optional file with additional feature templates.</description>\n+\t\t\t</parameter>\n+\t\t</config-description>\n+\t</bridge-type>\n+\n+\t<thing-type id=\"device\">\n+\t\t<supported-bridge-type-refs>\n+\t\t\t<bridge-type-ref id=\"network\" />\n+\t\t</supported-bridge-type-refs>\n+\n+\t\t<label>Insteon Device</label>\n+\t\t<description>Insteon devices such as switches, dimmers, keypads, sensors, etc.</description>\n+\n+\t\t<channels>\n+\t\t\t<channel id=\"acDelay\" typeId=\"acDelay\" />\n+\t\t\t<channel id=\"backlightDuration\" typeId=\"backlightDuration\" />\n+\t\t\t<channel id=\"batteryLevel\" typeId=\"batteryLevel\" />\n+\t\t\t<channel id=\"batteryWatermarkLevel\" typeId=\"batteryWatermarkLevel\" />\n+\t\t\t<channel id=\"bottomOutlet\" typeId=\"bottomOutlet\" />\n+\t\t\t<channel id=\"buttonA\" typeId=\"buttonA\" />\n+\t\t\t<channel id=\"buttonB\" typeId=\"buttonB\" />\n+\t\t\t<channel id=\"buttonC\" typeId=\"buttonC\" />\n+\t\t\t<channel id=\"buttonD\" typeId=\"buttonD\" />\n+\t\t\t<channel id=\"buttonE\" typeId=\"buttonE\" />\n+\t\t\t<channel id=\"buttonF\" typeId=\"buttonF\" />\n+\t\t\t<channel id=\"buttonG\" typeId=\"buttonG\" />\n+\t\t\t<channel id=\"buttonH\" typeId=\"buttonH\" />\n+\t\t\t<channel id=\"broadcastOnOff\" typeId=\"broadcastOnOff\" />\n+\t\t\t<channel id=\"contact\" typeId=\"contact\" />\n+\t\t\t<channel id=\"coolSetPoint\" typeId=\"coolSetPoint\" />\n+\t\t\t<channel id=\"dimmer\" typeId=\"dimmer\" />\n+\t\t\t<channel id=\"fan\" typeId=\"fan\" />\n+\t\t\t<channel id=\"fanMode\" typeId=\"fanMode\" />\n+\t\t\t<channel id=\"fastOnOff\" typeId=\"fastOnOff\" />\n+\t\t\t<channel id=\"fastOnOffButtonA\" typeId=\"fastOnOffButtonA\" />\n+\t\t\t<channel id=\"fastOnOffButtonB\" typeId=\"fastOnOffButtonB\" />\n+\t\t\t<channel id=\"fastOnOffButtonC\" typeId=\"fastOnOffButtonC\" />\n+\t\t\t<channel id=\"fastOnOffButtonD\" typeId=\"fastOnOffButtonD\" />\n+\t\t\t<channel id=\"heatSetPoint\" typeId=\"heatSetPoint\" />\n+\t\t\t<channel id=\"humidity\" typeId=\"humidity\" />\n+\t\t\t<channel id=\"humidityHigh\" typeId=\"humidityHigh\" />\n+\t\t\t<channel id=\"humidityLow\" typeId=\"humidityLow\" />\n+\t\t\t<channel id=\"isCooling\" typeId=\"isCooling\" />\n+\t\t\t<channel id=\"isHeating\" typeId=\"isHeating\" />\n+\t\t\t<channel id=\"keypadButtonA\" typeId=\"keypadButtonA\" />\n+\t\t\t<channel id=\"keypadButtonB\" typeId=\"keypadButtonB\" />\n+\t\t\t<channel id=\"keypadButtonC\" typeId=\"keypadButtonC\" />\n+\t\t\t<channel id=\"keypadButtonD\" typeId=\"keypadButtonD\" />\n+\t\t\t<channel id=\"keypadButtonE\" typeId=\"keypadButtonE\" />\n+\t\t\t<channel id=\"keypadButtonF\" typeId=\"keypadButtonF\" />\n+\t\t\t<channel id=\"keypadButtonG\" typeId=\"keypadButtonG\" />\n+\t\t\t<channel id=\"keypadButtonH\" typeId=\"keypadButtonH\" />\n+\t\t\t<channel id=\"kWh\" typeId=\"kWh\" />\n+\t\t\t<channel id=\"lastHeardFrom\" typeId=\"lastHeardFrom\" />\n+\t\t\t<channel id=\"ledBrightness\" typeId=\"ledBrightness\" />\n+\t\t\t<channel id=\"lightDimmer\" typeId=\"lightDimmer\" />\n+\t\t\t<channel id=\"lightLevel\" typeId=\"lightLevel\" />\n+\t\t\t<channel id=\"loadDimmer\" typeId=\"loadDimmer\" />\n+\t\t\t<channel id=\"loadSwitch\" typeId=\"loadSwitch\" />\n+\t\t\t<channel id=\"loadSwitchFastOnOff\" typeId=\"loadSwitchFastOnOff\" />\n+\t\t\t<channel id=\"loadSwitchManualChange\" typeId=\"loadSwitchManualChange\" />\n+\t\t\t<channel id=\"manualChange\" typeId=\"manualChange\" />\n+\t\t\t<channel id=\"manualChangeButtonA\" typeId=\"manualChangeButtonA\" />\n+\t\t\t<channel id=\"manualChangeButtonB\" typeId=\"manualChangeButtonB\" />\n+\t\t\t<channel id=\"manualChangeButtonC\" typeId=\"manualChangeButtonC\" />\n+\t\t\t<channel id=\"manualChangeButtonD\" typeId=\"manualChangeButtonD\" />\n+\t\t\t<channel id=\"notification\" typeId=\"notification\" />\n+\t\t\t<channel id=\"onLevel\" typeId=\"onLevel\" />\n+\t\t\t<channel id=\"rampDimmer\" typeId=\"rampDimmer\" />\n+\t\t\t<channel id=\"rampRate\" typeId=\"rampRate\" />\n+\t\t\t<channel id=\"reset\" typeId=\"reset\" />\n+\t\t\t<channel id=\"stage1Duration\" typeId=\"stage1Duration\" />\n+\t\t\t<channel id=\"switch\" typeId=\"switch\" />\n+\t\t\t<channel id=\"systemMode\" typeId=\"systemMode\" />\n+\t\t\t<channel id=\"tempCelsius\" typeId=\"tempCelsius\" />\n+\t\t\t<channel id=\"tempFahrenheit\" typeId=\"tempFahrenheit\" />\n+\t\t\t<channel id=\"topOutlet\" typeId=\"topOutlet\" />\n+\t\t\t<channel id=\"update\" typeId=\"update\" />\n+\t\t\t<channel id=\"watts\" typeId=\"watts\" />\n+\t\t</channels>\n+\n+\t\t<config-description>\n+\t\t\t<parameter name=\"address\" type=\"text\" required=\"true\">\n+\t\t\t\t<label>Address</label>\n+\t\t\t\t<description>Insteon address of the device.</description>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"productKey\" type=\"text\" required=\"true\">\n+\t\t\t\t<label>Product Key</label>\n+\t\t\t\t<description>Insteon binding product key that is used to identify the model of the device.</description>\n+\t\t\t</parameter>\n+\t\t</config-description>\n+\t</thing-type>\n+\n+\t<channel-type id=\"acDelay\">\n+\t\t<item-type>Number</item-type>\n+\t\t<label>AC Delay</label>\n+\t</channel-type>\n+\n+\t<channel-type id=\"backlightDuration\">\n+\t\t<item-type>Number</item-type>\n+\t\t<label>Back Light Duration</label>\n+\t</channel-type>\n+\n+\t<channel-type id=\"batteryLevel\">\n+\t\t<item-type>Number</item-type>\n+\t\t<label>Battery Level</label>\n+\t</channel-type>\n+\n+\t<channel-type id=\"batteryWatermarkLevel\">\n+\t\t<item-type>Number</item-type>\n+\t\t<label>Battery Watermark Level</label>\n+\t</channel-type>\n+\n+\t<channel-type id=\"bottomOutlet\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Bottom Outlet</label>\n+\t</channel-type>\n+\n+\t<channel-type id=\"buttonA\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Button A</label>\n+\t</channel-type>\n+\n+\t<channel-type id=\"buttonB\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Button B</label>\n+\t</channel-type>\n+\n+\t<channel-type id=\"buttonC\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Button C</label>\n+\t</channel-type>\n+\n+\t<channel-type id=\"buttonD\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Button D</label>\n+\t</channel-type>\n+\n+\t<channel-type id=\"buttonE\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Button E</label>\n+\t</channel-type>\n+\n+\t<channel-type id=\"buttonF\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Button F</label>\n+\t</channel-type>\n+\n+\t<channel-type id=\"buttonG\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Button G</label>\n+\t</channel-type>\n+\n+\t<channel-type id=\"buttonH\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Button H</label>\n+\t</channel-type>\n+\n+\t<channel-type id=\"broadcastOnOff\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Broadcast On/Off</label>\n+\t</channel-type>\n+\n+\t<channel-type id=\"contact\">\n+\t\t<item-type>Contact</item-type>\n+\t\t<label>Contact</label>\n+\t</channel-type>\n+\n+\t<channel-type id=\"coolSetPoint\">\n+\t\t<item-type>Number</item-type>\n+\t\t<label>Cool Set Point</label>\n+\t</channel-type>\n+\n+\t<channel-type id=\"dimmer\">\n+\t\t<item-type>Dimmer</item-type>\n+\t\t<label>Dimmer</label>\n+\t</channel-type>\n+\n+\t<channel-type id=\"fan\">\n+\t\t<item-type>Number</item-type>\n+\t\t<label>Fan</label>\n+\t</channel-type>\n+\n+\t<channel-type id=\"fanMode\">\n+\t\t<item-type>Number</item-type>\n+\t\t<label>Fan Mode</label>\n+\t</channel-type>\n+\n+\t<channel-type id=\"fastOnOff\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Fast On/Off</label>\n+\t</channel-type>\n+\n+\t<channel-type id=\"fastOnOffButtonA\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Fast On/Off Button A</label>\n+\t</channel-type>\n+\n+\t<channel-type id=\"fastOnOffButtonB\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Fast On/Off Button B</label>\n+\t</channel-type>\n+\n+\t<channel-type id=\"fastOnOffButtonC\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Fast On/Off Button C</label>\n+\t</channel-type>\n+\n+\t<channel-type id=\"fastOnOffButtonD\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Fast On/Off Button D</label>\n+\t</channel-type>\n+\n+\t<channel-type id=\"heatSetPoint\">\n+\t\t<item-type>Number</item-type>\n+\t\t<label>Heat Set Point</label>\n+\t</channel-type>\n+\n+\t<channel-type id=\"humidity\">\n+\t\t<item-type>Number</item-type>\n+\t\t<label>Humidity</label>\n+\t</channel-type>\n+\n+\t<channel-type id=\"humidityHigh\">\n+\t\t<item-type>Number</item-type>\n+\t\t<label>Humidity High</label>\n+\t</channel-type>\n+\n+\t<channel-type id=\"humidityLow\">\n+\t\t<item-type>Number</item-type>\n+\t\t<label>Humidity Low</label>\n+\t</channel-type>\n+\n+\t<channel-type id=\"isCooling\">\n+\t\t<item-type>Number</item-type>\n+\t\t<label>Is Cooling</label>\n+\t</channel-type>\n+\n+\t<channel-type id=\"isHeating\">\n+\t\t<item-type>Number</item-type>\n+\t\t<label>Is Heating</label>\n+\t</channel-type>\n+\n+\t<channel-type id=\"keypadButtonA\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Keypad Button A</label>\n+\t</channel-type>\n+\n+\t<channel-type id=\"keypadButtonB\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Keypad Button B</label>\n+\t</channel-type>\n+\n+\t<channel-type id=\"keypadButtonC\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Keypad Button C</label>\n+\t</channel-type>\n+\n+\t<channel-type id=\"keypadButtonD\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Keypad Button D</label>\n+\t</channel-type>\n+\n+\t<channel-type id=\"keypadButtonE\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Keypad Button E</label>\n+\t</channel-type>\n+\n+\t<channel-type id=\"keypadButtonF\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Keypad Button F</label>\n+\t</channel-type>\n+\n+\t<channel-type id=\"keypadButtonG\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Keypad Button G</label>\n+\t</channel-type>\n+\n+\t<channel-type id=\"keypadButtonH\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Keypad Button H</label>\n+\t</channel-type>\n+\n+\t<channel-type id=\"kWh\">\n+\t\t<item-type>Number</item-type>\n+\t\t<label>Kilowatt Hour</label>\n+\t</channel-type>\n+\n+\t<channel-type id=\"lastHeardFrom\">\n+\t\t<item-type>DateTime</item-type>\n+\t\t<label>Last Heard From</label>\n+\t</channel-type>\n+\n+\t<channel-type id=\"ledBrightness\">\n+\t\t<item-type>Number</item-type>\n+\t\t<label>LED brightness</label>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "04a9796d14dfbc5f3ff997d872f04b6d03ee411d"}, "originalPosition": 330}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTMxODU0NA==", "bodyText": "As far as I understand, every device just has a subset of those channels. In that case, you must only add the ones here that exist for ALL devices. All other channels can be added dynamically by the device handler upon initialisation.", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r389318544", "createdAt": "2020-03-07T23:00:32Z", "author": {"login": "kaikreuzer"}, "path": "bundles/org.openhab.binding.insteon/src/main/resources/ESH-INF/thing/thing-types.xml", "diffHunk": "@@ -0,0 +1,453 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"insteon\"\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\n+\t<bridge-type id=\"network\">\n+\t\t<label>Insteon Network</label>\n+\t\t<description>An Insteon PLM or hub that is used to communicate with the Insteon devices.</description>\n+\n+\t\t<config-description>\n+\t\t\t<parameter name=\"port\" type=\"text\" required=\"true\">\n+\t\t\t\t<label>Port</label>\n+\t\t\t\t<description>Configuration information that is used to connect to PLM or hub.</description>\n+\t\t\t</parameter>\n+\n+\t\t\t<parameter name=\"devicePollIntervalSeconds\" type=\"integer\" min=\"5\" max=\"3600\">\n+\t\t\t\t<label>Device Poll Interval</label>\n+\t\t\t\t<description>Device poll interval in seconds.</description>\n+\t\t\t</parameter>\n+\n+\t\t\t<parameter name=\"modemDbRetryTimeoutSeconds\" type=\"integer\" min=\"30\" max=\"600\">\n+\t\t\t\t<label>Modem DB Retry Timeout</label>\n+\t\t\t\t<description>Modem DB retry timeout in seconds.</description>\n+\t\t\t</parameter>\n+\n+\n+\t\t\t<parameter name=\"additionalDevices\" type=\"text\">\n+\t\t\t\t<label>Additional Devices</label>\n+\t\t\t\t<description>Optional file with additional device types.</description>\n+\t\t\t</parameter>\n+\n+\t\t\t<parameter name=\"additionalFeatures\" type=\"text\">\n+\t\t\t\t<label>Additional Features</label>\n+\t\t\t\t<description>Optional file with additional feature templates.</description>\n+\t\t\t</parameter>\n+\t\t</config-description>\n+\t</bridge-type>\n+\n+\t<thing-type id=\"device\">\n+\t\t<supported-bridge-type-refs>\n+\t\t\t<bridge-type-ref id=\"network\" />\n+\t\t</supported-bridge-type-refs>\n+\n+\t\t<label>Insteon Device</label>\n+\t\t<description>Insteon devices such as switches, dimmers, keypads, sensors, etc.</description>\n+\n+\t\t<channels>\n+\t\t\t<channel id=\"acDelay\" typeId=\"acDelay\" />", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "04a9796d14dfbc5f3ff997d872f04b6d03ee411d"}, "originalPosition": 49}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTMxODY2NA==", "bodyText": "Have a try nonetheless. We must not have separate celsius and fahrenheit channels in openHAB 2. So please merge them into a single \"temp\" channel. If you cannot test, just drop the Fahrenheit one and add Celsius as a unit when updating the channel state.", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r389318664", "createdAt": "2020-03-07T23:03:10Z", "author": {"login": "kaikreuzer"}, "path": "bundles/org.openhab.binding.insteon/src/main/resources/ESH-INF/thing/thing-types.xml", "diffHunk": "@@ -0,0 +1,444 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"insteon\"\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\n+\t<bridge-type id=\"network\">\n+\t\t<label>Insteon Network</label>\n+\t\t<description>An Insteon PLM or hub that is used to communicate with the Insteon devices.</description>\n+\n+\t\t<config-description>\n+\t\t\t<parameter name=\"port\" type=\"text\" required=\"true\">\n+\t\t\t\t<label>Port</label>\n+\t\t\t\t<description>Configuration information that is used to connect to PLM or hub.</description>\n+\t\t\t</parameter>\n+\n+\t\t\t<parameter name=\"devicePollInterval\" type=\"integer\" min=\"5000\" max=\"3600000\">\n+\t\t\t\t<label>Device Poll Interval</label>\n+\t\t\t\t<description>Device poll interval in milliseconds.</description>\n+\t\t\t</parameter>\n+\n+\t\t\t<parameter name=\"deviceStatisticsInterval\" type=\"integer\" min=\"60\">\n+\t\t\t\t<label>Device Statistics Interval</label>\n+\t\t\t\t<description>Interval to display the device statistics.</description>\n+\t\t\t</parameter>\n+\n+\t\t\t<parameter name=\"deviceDeadCount\" type=\"integer\" min=\"2\" max=\"100000\">\n+\t\t\t\t<label>Device Dead Count</label>\n+\t\t\t\t<description>Device dead count along with device poll interval is used to calculate dead device timeout.</description>\n+\t\t\t</parameter>\n+\n+\t\t\t<parameter name=\"modemDbRetryTimeout\" type=\"integer\" min=\"5\">\n+\t\t\t\t<label>Modem Database Retry Timeout</label>\n+\t\t\t\t<description>Modem database retry timeout in seconds.</description>\n+\t\t\t</parameter>\n+\n+\t\t\t<parameter name=\"additionalDevices\" type=\"text\">\n+\t\t\t\t<label>Additional Devices</label>\n+\t\t\t\t<description>Optional file with additional device types.</description>\n+\t\t\t</parameter>\n+\n+\t\t\t<parameter name=\"additionalFeatures\" type=\"text\">\n+\t\t\t\t<label>Additional Features</label>\n+\t\t\t\t<description>Optional file with additional feature templates.</description>\n+\t\t\t</parameter>\n+\t\t</config-description>\n+\t</bridge-type>\n+\n+\t<thing-type id=\"device\">\n+\t\t<supported-bridge-type-refs>\n+\t\t\t<bridge-type-ref id=\"network\" />\n+\t\t</supported-bridge-type-refs>\n+\n+\t\t<label>Insteon Device</label>\n+\t\t<description>Insteon devices such as switches, dimmers, keypads, sensors, etc.</description>\n+\n+\t\t<channels>\n+\t\t\t<channel id=\"acDelay\" typeId=\"acDelay\" />\n+\t\t\t<channel id=\"backlightDuration\" typeId=\"backlightDuration\" />\n+\t\t\t<channel id=\"bottomOutlet\" typeId=\"bottomOutlet\" />\n+\t\t\t<channel id=\"buttonA\" typeId=\"buttonA\" />\n+\t\t\t<channel id=\"buttonB\" typeId=\"buttonB\" />\n+\t\t\t<channel id=\"buttonC\" typeId=\"buttonC\" />\n+\t\t\t<channel id=\"buttonD\" typeId=\"buttonD\" />\n+\t\t\t<channel id=\"buttonE\" typeId=\"buttonE\" />\n+\t\t\t<channel id=\"buttonF\" typeId=\"buttonF\" />\n+\t\t\t<channel id=\"buttonG\" typeId=\"buttonG\" />\n+\t\t\t<channel id=\"buttonH\" typeId=\"buttonH\" />\n+\t\t\t<channel id=\"contact\" typeId=\"contact\" />\n+\t\t\t<channel id=\"coolSetPoint\" typeId=\"coolSetPoint\" />\n+\t\t\t<channel id=\"data\" typeId=\"data\" />\n+\t\t\t<channel id=\"dimmer\" typeId=\"dimmer\" />\n+\t\t\t<channel id=\"fan\" typeId=\"fan\" />\n+\t\t\t<channel id=\"fanMode\" typeId=\"fanMode\" />\n+\t\t\t<channel id=\"fastOnOff\" typeId=\"fastOnOff\" />\n+\t\t\t<channel id=\"fastOnOffButtonA\" typeId=\"fastOnOffButtonA\" />\n+\t\t\t<channel id=\"fastOnOffButtonB\" typeId=\"fastOnOffButtonB\" />\n+\t\t\t<channel id=\"fastOnOffButtonC\" typeId=\"fastOnOffButtonC\" />\n+\t\t\t<channel id=\"fastOnOffButtonD\" typeId=\"fastOnOffButtonD\" />\n+\t\t\t<channel id=\"heatSetPoint\" typeId=\"heatSetPoint\" />\n+\t\t\t<channel id=\"humidity\" typeId=\"humidity\" />\n+\t\t\t<channel id=\"humidityHigh\" typeId=\"humidityHigh\" />\n+\t\t\t<channel id=\"humidityLow\" typeId=\"humidityLow\" />\n+\t\t\t<channel id=\"isCooling\" typeId=\"isCooling\" />\n+\t\t\t<channel id=\"isHeating\" typeId=\"isHeating\" />\n+\t\t\t<channel id=\"keypadButtonA\" typeId=\"keypadButtonA\" />\n+\t\t\t<channel id=\"keypadButtonB\" typeId=\"keypadButtonB\" />\n+\t\t\t<channel id=\"keypadButtonC\" typeId=\"keypadButtonC\" />\n+\t\t\t<channel id=\"keypadButtonD\" typeId=\"keypadButtonD\" />\n+\t\t\t<channel id=\"keypadButtonE\" typeId=\"keypadButtonE\" />\n+\t\t\t<channel id=\"keypadButtonF\" typeId=\"keypadButtonF\" />\n+\t\t\t<channel id=\"keypadButtonG\" typeId=\"keypadButtonG\" />\n+\t\t\t<channel id=\"keypadButtonH\" typeId=\"keypadButtonH\" />\n+\t\t\t<channel id=\"lastHeardFrom\" typeId=\"lastHeardFrom\" />\n+\t\t\t<channel id=\"ledBrightness\" typeId=\"ledBrightness\" />\n+\t\t\t<channel id=\"lightDimmer\" typeId=\"lightDimmer\" />\n+\t\t\t<channel id=\"loadDimmer\" typeId=\"loadDimmer\" />\n+\t\t\t<channel id=\"loadSwitch\" typeId=\"loadSwitch\" />\n+\t\t\t<channel id=\"loadSwitchFastOnOff\" typeId=\"loadSwitchFastOnOff\" />\n+\t\t\t<channel id=\"loadSwitchManualChange\" typeId=\"loadSwitchManualChange\" />\n+\t\t\t<channel id=\"manualChange\" typeId=\"manualChange\" />\n+\t\t\t<channel id=\"manualChangeButtonA\" typeId=\"manualChangeButtonA\" />\n+\t\t\t<channel id=\"manualChangeButtonB\" typeId=\"manualChangeButtonB\" />\n+\t\t\t<channel id=\"manualChangeButtonC\" typeId=\"manualChangeButtonC\" />\n+\t\t\t<channel id=\"manualChangeButtonD\" typeId=\"manualChangeButtonD\" />\n+\t\t\t<channel id=\"meterKWH\" typeId=\"meterKWH\" />\n+\t\t\t<channel id=\"meterReset\" typeId=\"meterReset\" />\n+\t\t\t<channel id=\"meterUpdate\" typeId=\"meterUpdate\" />\n+\t\t\t<channel id=\"meterWatts\" typeId=\"meterWatts\" />\n+\t\t\t<channel id=\"notification\" typeId=\"notification\" />\n+\t\t\t<channel id=\"onLevel\" typeId=\"onLevel\" />\n+\t\t\t<channel id=\"rampDimmer\" typeId=\"rampDimmer\" />\n+\t\t\t<channel id=\"rampRate\" typeId=\"rampRate\" />\n+\t\t\t<channel id=\"stage1Duration\" typeId=\"stage1Duration\" />\n+\t\t\t<channel id=\"switch\" typeId=\"switch\" />\n+\t\t\t<channel id=\"systemMode\" typeId=\"systemMode\" />\n+\t\t\t<channel id=\"tempCelsius\" typeId=\"tempCelsius\" />\n+\t\t\t<channel id=\"tempFahrenheit\" typeId=\"tempFahrenheit\" />\n+\t\t\t<channel id=\"topOutlet\" typeId=\"topOutlet\" />\n+\t\t</channels>\n+\n+\t\t<config-description>\n+\t\t\t<parameter name=\"address\" type=\"text\" required=\"true\">\n+\t\t\t\t<label>Address</label>\n+\t\t\t\t<description>Insteon address of the device.</description>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"productKey\" type=\"text\" required=\"true\">\n+\t\t\t\t<label>Product Key</label>\n+\t\t\t\t<description>Insteon binding product key that is used to identify the model of the device.</description>\n+\t\t\t</parameter>\n+\t\t</config-description>\n+\t</thing-type>\n+\n+\t<channel-type id=\"acDelay\">\n+\t\t<item-type>Number</item-type>\n+\t\t<label>AC Delay</label>\n+\t</channel-type>\n+\n+\t<channel-type id=\"backlightDuration\">\n+\t\t<item-type>Number</item-type>\n+\t\t<label>Back Light Duration</label>\n+\t</channel-type>\n+\n+\t<channel-type id=\"bottomOutlet\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Bottom Outlet</label>\n+\t</channel-type>\n+\n+\t<channel-type id=\"buttonA\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Button A</label>\n+\t</channel-type>\n+\n+\t<channel-type id=\"buttonB\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Button B</label>\n+\t</channel-type>\n+\n+\t<channel-type id=\"buttonC\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Button C</label>\n+\t</channel-type>\n+\n+\t<channel-type id=\"buttonD\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Button D</label>\n+\t</channel-type>\n+\n+\t<channel-type id=\"buttonE\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Button E</label>\n+\t</channel-type>\n+\n+\t<channel-type id=\"buttonF\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Button F</label>\n+\t</channel-type>\n+\n+\t<channel-type id=\"buttonG\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Button G</label>\n+\t</channel-type>\n+\n+\t<channel-type id=\"buttonH\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Button H</label>\n+\t</channel-type>\n+\n+\t<channel-type id=\"contact\">\n+\t\t<item-type>Contact</item-type>\n+\t\t<label>Contact</label>\n+\t</channel-type>\n+\n+\t<channel-type id=\"coolSetPoint\">\n+\t\t<item-type>Number</item-type>\n+\t\t<label>Cool Set Point</label>\n+\t</channel-type>\n+\n+\t<channel-type id=\"data\">\n+\t\t<item-type>Number</item-type>\n+\t\t<label>Data</label>\n+\t</channel-type>\n+\n+\t<channel-type id=\"dimmer\">\n+\t\t<item-type>Dimmer</item-type>\n+\t\t<label>Dimmer</label>\n+\t</channel-type>\n+\n+\t<channel-type id=\"fan\">\n+\t\t<item-type>Number</item-type>\n+\t\t<label>Fan</label>\n+\t</channel-type>\n+\n+\t<channel-type id=\"fanMode\">\n+\t\t<item-type>Number</item-type>\n+\t\t<label>Fan Mode</label>\n+\t</channel-type>\n+\n+\t<channel-type id=\"fastOnOff\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Fast On/Off</label>\n+\t</channel-type>\n+\n+\t<channel-type id=\"fastOnOffButtonA\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Fast On/Off Button A</label>\n+\t</channel-type>\n+\n+\t<channel-type id=\"fastOnOffButtonB\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Fast On/Off Button B</label>\n+\t</channel-type>\n+\n+\t<channel-type id=\"fastOnOffButtonC\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Fast On/Off Button C</label>\n+\t</channel-type>\n+\n+\t<channel-type id=\"fastOnOffButtonD\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Fast On/Off Button D</label>\n+\t</channel-type>\n+\n+\t<channel-type id=\"heatSetPoint\">\n+\t\t<item-type>Number</item-type>\n+\t\t<label>Heat Set Point</label>\n+\t</channel-type>\n+\n+\t<channel-type id=\"humidity\">\n+\t\t<item-type>Number</item-type>\n+\t\t<label>Humidity</label>\n+\t</channel-type>\n+\n+\t<channel-type id=\"humidityHigh\">\n+\t\t<item-type>Number</item-type>\n+\t\t<label>Humidity High</label>\n+\t</channel-type>\n+\n+\t<channel-type id=\"humidityLow\">\n+\t\t<item-type>Number</item-type>\n+\t\t<label>Humidity Low</label>\n+\t</channel-type>\n+\n+\t<channel-type id=\"isCooling\">\n+\t\t<item-type>Number</item-type>\n+\t\t<label>Is Cooling</label>\n+\t</channel-type>\n+\n+\t<channel-type id=\"isHeating\">\n+\t\t<item-type>Number</item-type>\n+\t\t<label>Is Heating</label>\n+\t</channel-type>\n+\n+\t<channel-type id=\"keypadButtonA\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Keypad Button A</label>\n+\t</channel-type>\n+\n+\t<channel-type id=\"keypadButtonB\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Keypad Button B</label>\n+\t</channel-type>\n+\n+\t<channel-type id=\"keypadButtonC\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Keypad Button C</label>\n+\t</channel-type>\n+\n+\t<channel-type id=\"keypadButtonD\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Keypad Button D</label>\n+\t</channel-type>\n+\n+\t<channel-type id=\"keypadButtonE\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Keypad Button E</label>\n+\t</channel-type>\n+\n+\t<channel-type id=\"keypadButtonF\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Keypad Button F</label>\n+\t</channel-type>\n+\n+\t<channel-type id=\"keypadButtonG\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Keypad Button G</label>\n+\t</channel-type>\n+\n+\t<channel-type id=\"keypadButtonH\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Keypad Button H</label>\n+\t</channel-type>\n+\n+\t<channel-type id=\"lastHeardFrom\">\n+\t\t<item-type>DateTime</item-type>\n+\t\t<label>Last Heard From</label>\n+\t</channel-type>\n+\n+\t<channel-type id=\"ledBrightness\">\n+\t\t<item-type>Number</item-type>\n+\t\t<label>LED brightness</label>\n+\t</channel-type>\n+\n+\t<channel-type id=\"lightDimmer\">\n+\t\t<item-type>Dimmer</item-type>\n+\t\t<label>light Dimmer</label>\n+\t</channel-type>\n+\n+\t<channel-type id=\"loadDimmer\">\n+\t\t<item-type>Dimmer</item-type>\n+\t\t<label>Load Dimmer</label>\n+\t</channel-type>\n+\n+\t<channel-type id=\"loadSwitch\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Load Switch</label>\n+\t</channel-type>\n+\n+\t<channel-type id=\"loadSwitchFastOnOff\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Load Switch Fast On/Off</label>\n+\t</channel-type>\n+\n+\t<channel-type id=\"loadSwitchManualChange\">\n+\t\t<item-type>Number</item-type>\n+\t\t<label>Load Switch Manual Change</label>\n+\t</channel-type>\n+\n+\t<channel-type id=\"manualChange\">\n+\t\t<item-type>Number</item-type>\n+\t\t<label>Manual Change</label>\n+\t</channel-type>\n+\n+\t<channel-type id=\"manualChangeButtonA\">\n+\t\t<item-type>Number</item-type>\n+\t\t<label>Manual Change Button A</label>\n+\t</channel-type>\n+\n+\t<channel-type id=\"manualChangeButtonB\">\n+\t\t<item-type>Number</item-type>\n+\t\t<label>Manual Change Button B</label>\n+\t</channel-type>\n+\n+\t<channel-type id=\"manualChangeButtonC\">\n+\t\t<item-type>Number</item-type>\n+\t\t<label>Manual Change Button C</label>\n+\t</channel-type>\n+\n+\t<channel-type id=\"manualChangeButtonD\">\n+\t\t<item-type>Number</item-type>\n+\t\t<label>Manual Change Button D</label>\n+\t</channel-type>\n+\n+\t<channel-type id=\"meterKWH\">\n+\t\t<item-type>Number</item-type>\n+\t\t<label>Meter KWH</label>\n+\t</channel-type>\n+\n+\t<channel-type id=\"meterReset\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Meter Reset</label>\n+\t</channel-type>\n+\n+\t<channel-type id=\"meterUpdate\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Meter Update</label>\n+\t</channel-type>\n+\n+\t<channel-type id=\"meterWatts\">\n+\t\t<item-type>Number</item-type>\n+\t\t<label>Meter Watts</label>\n+\t</channel-type>\n+\n+\t<channel-type id=\"notification\">\n+\t\t<item-type>Number</item-type>\n+\t\t<label>Notification</label>\n+\t</channel-type>\n+\n+\t<channel-type id=\"onLevel\">\n+\t\t<item-type>Number</item-type>\n+\t\t<label>On Level</label>\n+\t</channel-type>\n+\n+\t<channel-type id=\"rampDimmer\">\n+\t\t<item-type>Dimmer</item-type>\n+\t\t<label>Ramp Dimmer</label>\n+\t</channel-type>\n+\n+\t<channel-type id=\"rampRate\">\n+\t\t<item-type>Number</item-type>\n+\t\t<label>Ramp Rate</label>\n+\t</channel-type>\n+\n+\t<channel-type id=\"stage1Duration\">\n+\t\t<item-type>Number</item-type>\n+\t\t<label>Stage 1 Duration</label>\n+\t</channel-type>\n+\n+\t<channel-type id=\"switch\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Switch</label>\n+\t</channel-type>\n+\n+\t<channel-type id=\"systemMode\">\n+\t\t<item-type>Number</item-type>\n+\t\t<label>System Mode</label>\n+\t</channel-type>\n+\n+\t<channel-type id=\"tempCelsius\">\n+\t\t<item-type>Number</item-type>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTEwNTQ1MA=="}, "originalCommit": {"oid": "d8407f4d3e56f93dadba66a086ab0d3e70ef5b95"}, "originalPosition": 430}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzcwNzkzNzM3", "url": "https://github.com/openhab/openhab-addons/pull/6911#pullrequestreview-370793737", "createdAt": "2020-03-07T23:04:37Z", "commit": {"oid": "04a9796d14dfbc5f3ff997d872f04b6d03ee411d"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzcxNTQ5NDIx", "url": "https://github.com/openhab/openhab-addons/pull/6911#pullrequestreview-371549421", "createdAt": "2020-03-09T21:42:39Z", "commit": {"oid": "a74ebd4cfea29795ae2b753286fc24889766ed22"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wOVQyMTo0MjozOVrOFz6YhA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wOVQyMjowMjo1NFrOFz66Yg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTk3ODI0NA==", "bodyText": "please do this change", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r389978244", "createdAt": "2020-03-09T21:42:39Z", "author": {"login": "kaikreuzer"}, "path": "bundles/org.openhab.binding.insteon/src/main/java/org/openhab/binding/insteon/internal/InsteonBinding.java", "diffHunk": "@@ -0,0 +1,512 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.insteon.internal;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map.Entry;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import javax.xml.parsers.ParserConfigurationException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.insteon.internal.config.InsteonChannelConfiguration;\n+import org.openhab.binding.insteon.internal.config.InsteonNetworkConfiguration;\n+import org.openhab.binding.insteon.internal.device.DeviceFeature;\n+import org.openhab.binding.insteon.internal.device.DeviceFeatureListener;\n+import org.openhab.binding.insteon.internal.device.DeviceType;\n+import org.openhab.binding.insteon.internal.device.DeviceTypeLoader;\n+import org.openhab.binding.insteon.internal.device.InsteonAddress;\n+import org.openhab.binding.insteon.internal.device.InsteonDevice;\n+import org.openhab.binding.insteon.internal.device.InsteonDevice.DeviceStatus;\n+import org.openhab.binding.insteon.internal.device.RequestQueueManager;\n+import org.openhab.binding.insteon.internal.driver.Driver;\n+import org.openhab.binding.insteon.internal.driver.DriverListener;\n+import org.openhab.binding.insteon.internal.driver.ModemDBEntry;\n+import org.openhab.binding.insteon.internal.driver.Poller;\n+import org.openhab.binding.insteon.internal.handler.InsteonNetworkHandler;\n+import org.openhab.binding.insteon.internal.message.FieldException;\n+import org.openhab.binding.insteon.internal.message.Msg;\n+import org.openhab.binding.insteon.internal.message.MsgListener;\n+import org.openhab.binding.insteon.internal.utils.Utils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.xml.sax.SAXException;\n+\n+/**\n+ * A majority of the code in this file is from the OpenHAB 1 binding\n+ * org.openhab.binding.insteonplm.InsteonPLMActiveBinding. Including the comments below.\n+ *\n+ * -----------------------------------------------------------------------------------------------\n+ *\n+ * This class represents the actual implementation of the binding, and controls the high level flow\n+ * of messages to and from the InsteonModem.\n+ *\n+ * Writing this binding has been an odyssey through the quirks of the Insteon protocol\n+ * and Insteon devices. A substantial redesign was necessary at some point along the way.\n+ * Here are some of the hard learned lessons that should be considered by anyone who wants\n+ * to re-architect the binding:\n+ *\n+ * 1) The entries of the link database of the modem are not reliable. The category/subcategory entries in\n+ * particular have junk data. Forget about using the modem database to generate a list of devices.\n+ * The database should only be used to verify that a device has been linked.\n+ *\n+ * 2) Querying devices for their product information does not work either. First of all, battery operated devices\n+ * (and there are a lot of those) have their radio switched off, and may generally not respond to product\n+ * queries. Even main stream hardwired devices sold presently (like the 2477s switch and the 2477d dimmer)\n+ * don't even have a product ID. Although supposedly part of the Insteon protocol, we have yet to\n+ * encounter a device that would cough up a product id when queried, even among very recent devices. They\n+ * simply return zeros as product id. Lesson: forget about querying devices to generate a device list.\n+ *\n+ * 3) Polling is a thorny issue: too much traffic on the network, and messages will be dropped left and right,\n+ * and not just the poll related ones, but others as well. In particular sending back-to-back messages\n+ * seemed to result in the second message simply never getting sent, without flow control back pressure\n+ * (NACK) from the modem. For now the work-around is to space out the messages upon sending, and\n+ * in general poll as infrequently as acceptable.\n+ *\n+ * 4) Instantiating and tracking devices when reported by the modem (either from the database, or when\n+ * messages are received) leads to complicated state management because there is no guarantee at what\n+ * point (if at all) the binding configuration will be available. It gets even more difficult when\n+ * items are created, destroyed, and modified while the binding runs.\n+ *\n+ * For the above reasons, devices are only instantiated when they are referenced by binding information.\n+ * As nice as it would be to discover devices and their properties dynamically, we have abandoned that\n+ * path because it had led to a complicated and fragile system which due to the technical limitations\n+ * above was inherently squirrely.\n+ *\n+ *\n+ * @author Bernd Pfrommer - Initial contribution\n+ * @author Daniel Pfrommer - OpenHAB 1 insteonplm binding\n+ * @author Rob Nielsen - Port to OpenHAB 2 insteon binding\n+ */\n+@NonNullByDefault\n+public class InsteonBinding {\n+    private static final int DEAD_DEVICE_COUNT = 10;\n+\n+    private final Logger logger = LoggerFactory.getLogger(InsteonBinding.class);\n+\n+    private Driver m_driver = new Driver();\n+    private ConcurrentHashMap<InsteonAddress, InsteonDevice> m_devices = new ConcurrentHashMap<InsteonAddress, InsteonDevice>();\n+    private ConcurrentHashMap<String, InsteonChannelConfiguration> m_bindingConfigs = new ConcurrentHashMap<>();\n+    private PortListener m_portListener = new PortListener();\n+    private int m_devicePollIntervalMilliseconds = 300000;\n+    private int m_deadDeviceTimeout = -1;\n+    private int m_messagesReceived = 0;\n+    private boolean m_isActive = false; // state of binding\n+    private int m_x10HouseUnit = -1;\n+    private InsteonNetworkHandler m_handler;\n+\n+    public InsteonBinding(InsteonNetworkHandler handler, @Nullable InsteonNetworkConfiguration config) {\n+        this.m_handler = handler;\n+\n+        Integer devicePollIntervalSeconds = config.getDevicePollIntervalSeconds();\n+        if (devicePollIntervalSeconds != null) {\n+            m_devicePollIntervalMilliseconds = devicePollIntervalSeconds * 1000;\n+        }\n+        logger.info(\"device poll interval set to {} seconds\", m_devicePollIntervalMilliseconds / 1000);\n+\n+        Integer modemDbRetryTimeoutSeconds = config.getModemDbRetryTimeoutSeconds();\n+        if (modemDbRetryTimeoutSeconds != null) {\n+            logger.info(\"setting modem db retry timeout to {} seconds\", modemDbRetryTimeoutSeconds);\n+            m_driver.setModemDBRetryTimeout(modemDbRetryTimeoutSeconds * 1000);\n+        }\n+\n+        String additionalDevices = config.getAdditionalDevices();\n+        if (additionalDevices != null) {\n+            try {\n+                DeviceTypeLoader.s_instance().loadDeviceTypesXML(additionalDevices);\n+                logger.info(\"read additional device definitions from {}\", additionalDevices);\n+            } catch (ParserConfigurationException | SAXException | IOException e) {\n+                logger.warn(\"error reading additional devices from {}\", additionalDevices, e);\n+            }\n+        }\n+\n+        String additionalFeatures = config.getAdditionalFeatures();\n+        if (additionalFeatures != null) {\n+            logger.info(\"reading additional feature templates from {}\", additionalFeatures);\n+            DeviceFeature.s_readFeatureTemplates(additionalFeatures);\n+        }\n+\n+        m_deadDeviceTimeout = m_devicePollIntervalMilliseconds * DEAD_DEVICE_COUNT;\n+        logger.info(\"dead device timeout set to {} seconds\", m_deadDeviceTimeout / 1000);\n+\n+        String port = config.getPort();\n+        logger.info(\"port = '{}'\", port);\n+        m_driver.addPort(\"port\", port);\n+        m_driver.addMsgListener(m_portListener, port);\n+\n+        logger.debug(\"setting driver listener\");\n+        m_driver.setDriverListener(m_portListener);\n+    }\n+\n+    public boolean startPolling() {\n+        logger.debug(\"starting {} ports\", m_driver.getNumberOfPorts());\n+\n+        m_driver.startAllPorts();\n+        logger.debug(\"ports started\");\n+        switch (m_driver.getNumberOfPorts()) {\n+            case 0:\n+                logger.warn(\"initialization complete, but found no ports!\");\n+                return false;\n+            case 1:\n+                logger.debug(\"initialization complete, found 1 port!\");\n+                break;\n+            default:\n+                logger.warn(\"initialization complete, found {} ports.\", m_driver.getNumberOfPorts());\n+                break;\n+        }\n+\n+        return true;\n+    }\n+\n+    public void setIsActive(boolean isActive) {\n+        m_isActive = isActive;\n+    }\n+\n+    public void sendCommand(String channelName, Command command) {\n+        if (!m_isActive) {\n+            logger.debug(\"not ready to handle commands yet, returning.\");\n+            return;\n+        }\n+\n+        InsteonChannelConfiguration bindingConfig = m_bindingConfigs.get(channelName);\n+        if (bindingConfig == null) {\n+            logger.warn(\"unable to find binding config for channel {}\", channelName);\n+            return;\n+        }\n+\n+        InsteonDevice dev = getDevice(bindingConfig.getAddress());\n+        if (dev == null) {\n+            logger.warn(\"no device found with insteon address {}\", bindingConfig.getAddress());\n+            return;\n+        }\n+\n+        dev.processCommand(m_driver, bindingConfig, command);\n+\n+        logger.debug(\"found binding config for channel {}\", channelName);\n+    }\n+\n+    public void addFeatureListener(InsteonChannelConfiguration bindingConfig) {\n+        logger.debug(\"adding listener for channel {}\", bindingConfig.getChannelName());\n+\n+        InsteonAddress address = bindingConfig.getAddress();\n+        InsteonDevice dev = getDevice(address);\n+        @Nullable\n+        DeviceFeature f = dev.getFeature(bindingConfig.getFeature());\n+        if (f == null || f.isFeatureGroup()) {\n+            StringBuffer buf = new StringBuffer();\n+            ArrayList<String> names = new ArrayList<String>(dev.getFeatures().keySet());\n+            Collections.sort(names);\n+            for (String name : names) {\n+                DeviceFeature feature = dev.getFeature(name);\n+                if (!feature.isFeatureGroup()) {\n+                    if (buf.length() > 0) {\n+                        buf.append(\", \");\n+                    }\n+                    buf.append(name);\n+                }\n+            }\n+\n+            logger.warn(\"channel {} references unknown feature: {}, it will be ignored. Known features for {} are: {}.\",\n+                    bindingConfig.getChannelName(), bindingConfig.getFeature(), bindingConfig.getProductKey(),\n+                    buf.toString());\n+            return;\n+        }\n+\n+        DeviceFeatureListener fl = new DeviceFeatureListener(this, bindingConfig.getChannelUID(),\n+                bindingConfig.getChannelName());\n+        fl.setParameters(bindingConfig.getParameters());\n+        f.addListener(fl);\n+\n+        m_bindingConfigs.put(bindingConfig.getChannelName(), bindingConfig);\n+    }\n+\n+    public void removeFeatureListener(ChannelUID channelUID) {\n+        String channelName = channelUID.getAsString();\n+\n+        logger.debug(\"removing listener for channel {}\", channelName);\n+\n+        for (Iterator<Entry<InsteonAddress, InsteonDevice>> it = m_devices.entrySet().iterator(); it.hasNext();) {\n+            InsteonDevice dev = it.next().getValue();\n+            boolean removedListener = dev.removeFeatureListener(channelName);\n+            if (removedListener) {\n+                logger.trace(\"removed feature listener {} from dev {}\", channelName, dev);\n+            }\n+        }\n+    }\n+\n+    public void updateFeatureState(ChannelUID channelUID, State state) {\n+        m_handler.updateState(channelUID, state);\n+    }\n+\n+    public InsteonDevice makeNewDevice(InsteonAddress addr, String productKey) {\n+        DeviceType dt = DeviceTypeLoader.s_instance().getDeviceType(productKey);\n+        InsteonDevice dev = InsteonDevice.s_makeDevice(dt);\n+        dev.setAddress(addr);\n+        dev.setDriver(m_driver);\n+        dev.addPort(m_driver.getDefaultPort());\n+        if (!dev.hasValidPollingInterval()) {\n+            dev.setPollInterval(m_devicePollIntervalMilliseconds);\n+        }\n+        if (m_driver.isModemDBComplete() && dev.getStatus() != DeviceStatus.POLLING) {\n+            int ndev = checkIfInModemDatabase(dev);\n+            if (dev.hasModemDBEntry()) {\n+                dev.setStatus(DeviceStatus.POLLING);\n+                Poller.s_instance().startPolling(dev, ndev);\n+            }\n+        }\n+        m_devices.put(addr, dev);\n+\n+        m_handler.insteonDeviceWasCreated();\n+\n+        return (dev);\n+    }\n+\n+    public void removeDevice(InsteonAddress addr) {\n+        InsteonDevice dev = m_devices.remove(addr);\n+        if (dev == null) {\n+            return;\n+        }\n+\n+        if (dev.getStatus() == DeviceStatus.POLLING) {\n+            Poller.s_instance().stopPolling(dev);\n+        }\n+    }\n+\n+    /**\n+     * Checks if a device is in the modem link database, and, if the database\n+     * is complete, logs a warning if the device is not present\n+     *\n+     * @param dev The device to search for in the modem database\n+     * @return number of devices in modem database\n+     */\n+    private int checkIfInModemDatabase(InsteonDevice dev) {\n+        InsteonAddress addr = dev.getAddress();\n+        HashMap<InsteonAddress, @Nullable ModemDBEntry> dbes = m_driver.lockModemDBEntries();\n+        if (dbes.containsKey(addr)) {\n+            if (!dev.hasModemDBEntry()) {\n+                logger.info(\"device {} found in the modem database and {}.\", addr, getLinkInfo(dbes, addr));\n+                dev.setHasModemDBEntry(true);\n+            }\n+        } else {\n+            if (m_driver.isModemDBComplete() && !addr.isX10()) {\n+                logger.warn(\"device {} not found in the modem database. Did you forget to link?\", addr);\n+            }\n+        }\n+        int ndev = dbes.size();\n+        m_driver.unlockModemDBEntries();\n+        return ndev;\n+    }\n+\n+    /**\n+     * Everything below was copied from Insteon PLM v1\n+     */\n+\n+    /**\n+     * Clean up all state.\n+     */\n+    public void shutdown() {\n+        logger.debug(\"shutting down Insteon bridge\");\n+        m_driver.stopAllPorts();\n+        m_devices.clear();\n+        RequestQueueManager.s_destroyInstance();\n+        Poller.s_instance().stop();\n+        m_isActive = false;\n+    }\n+\n+    /**\n+     * Method to find a device by address\n+     *\n+     * @param aAddr the insteon address to search for\n+     * @return reference to the device, or null if not found\n+     */\n+    public @Nullable InsteonDevice getDevice(@Nullable InsteonAddress aAddr) {\n+        InsteonDevice dev = (aAddr == null) ? null : m_devices.get(aAddr);\n+        return (dev);\n+    }\n+\n+    private String getLinkInfo(HashMap<InsteonAddress, @Nullable ModemDBEntry> dbes, InsteonAddress a) {\n+        ModemDBEntry dbe = dbes.get(a);\n+        ArrayList<Byte> controls = dbe.getControls();\n+        ArrayList<Byte> responds = dbe.getRespondsTo();\n+\n+        StringBuffer buf = new StringBuffer(\"the modem\");\n+        if (!controls.isEmpty()) {\n+            buf.append(\" controls groups [\");\n+            buf.append(toGroupString(controls));\n+            buf.append(\"]\");\n+        }\n+\n+        if (!responds.isEmpty()) {\n+            if (!controls.isEmpty()) {\n+                buf.append(\" and\");\n+            }\n+\n+            buf.append(\" responds to groups [\");\n+            buf.append(toGroupString(responds));\n+            buf.append(\"]\");\n+        }\n+\n+        return buf.toString();\n+    }\n+\n+    private String toGroupString(ArrayList<Byte> group) {\n+        ArrayList<Byte> sorted = new ArrayList<Byte>(group);\n+        Collections.sort(sorted);\n+\n+        StringBuffer buf = new StringBuffer();\n+        for (Byte b : sorted) {\n+            if (buf.length() > 0) {\n+                buf.append(\",\");\n+            }\n+            buf.append(\"0x\");\n+            buf.append(Utils.getHexString(b));\n+        }\n+\n+        return buf.toString();\n+    }\n+\n+    public void logDeviceStatistics() {\n+        String msg = String.format(\"devices: %3d configured, %3d polling, msgs received: %5d\", m_devices.size(),\n+                Poller.s_instance().getSizeOfQueue(), m_messagesReceived);\n+        logger.info(\"{}\", msg);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjcxODI0Nw=="}, "originalCommit": {"oid": "ed93353c47fa5d457223c66d8f91b1c168a57e23"}, "originalPosition": 391}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTk3OTE0MQ==", "bodyText": "In that situation, you should change the thing status to OFFLINE with an according message. Logging should be debug, unless there's a fatal misconfiguration or a bug in the code that should be reported.", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r389979141", "createdAt": "2020-03-09T21:44:36Z", "author": {"login": "kaikreuzer"}, "path": "bundles/org.openhab.binding.insteon/src/main/java/org/openhab/binding/insteon/internal/InsteonBinding.java", "diffHunk": "@@ -0,0 +1,520 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.insteon.internal;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map.Entry;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import javax.xml.parsers.ParserConfigurationException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.openhab.binding.insteon.internal.config.InsteonChannelConfiguration;\n+import org.openhab.binding.insteon.internal.config.InsteonNetworkConfiguration;\n+import org.openhab.binding.insteon.internal.device.DeviceFeature;\n+import org.openhab.binding.insteon.internal.device.DeviceFeatureListener;\n+import org.openhab.binding.insteon.internal.device.DeviceType;\n+import org.openhab.binding.insteon.internal.device.DeviceTypeLoader;\n+import org.openhab.binding.insteon.internal.device.InsteonAddress;\n+import org.openhab.binding.insteon.internal.device.InsteonDevice;\n+import org.openhab.binding.insteon.internal.device.InsteonDevice.DeviceStatus;\n+import org.openhab.binding.insteon.internal.device.RequestQueueManager;\n+import org.openhab.binding.insteon.internal.driver.Driver;\n+import org.openhab.binding.insteon.internal.driver.DriverListener;\n+import org.openhab.binding.insteon.internal.driver.ModemDBEntry;\n+import org.openhab.binding.insteon.internal.driver.Poller;\n+import org.openhab.binding.insteon.internal.handler.InsteonNetworkHandler;\n+import org.openhab.binding.insteon.internal.message.FieldException;\n+import org.openhab.binding.insteon.internal.message.Msg;\n+import org.openhab.binding.insteon.internal.message.MsgListener;\n+import org.openhab.binding.insteon.internal.utils.Utils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.xml.sax.SAXException;\n+\n+/**\n+ * A majority of the code in this file is from the openHAB 1 binding\n+ * org.openhab.binding.insteonplm.InsteonPLMActiveBinding. Including the comments below.\n+ *\n+ * -----------------------------------------------------------------------------------------------\n+ *\n+ * This class represents the actual implementation of the binding, and controls the high level flow\n+ * of messages to and from the InsteonModem.\n+ *\n+ * Writing this binding has been an odyssey through the quirks of the Insteon protocol\n+ * and Insteon devices. A substantial redesign was necessary at some point along the way.\n+ * Here are some of the hard learned lessons that should be considered by anyone who wants\n+ * to re-architect the binding:\n+ *\n+ * 1) The entries of the link database of the modem are not reliable. The category/subcategory entries in\n+ * particular have junk data. Forget about using the modem database to generate a list of devices.\n+ * The database should only be used to verify that a device has been linked.\n+ *\n+ * 2) Querying devices for their product information does not work either. First of all, battery operated devices\n+ * (and there are a lot of those) have their radio switched off, and may generally not respond to product\n+ * queries. Even main stream hardwired devices sold presently (like the 2477s switch and the 2477d dimmer)\n+ * don't even have a product ID. Although supposedly part of the Insteon protocol, we have yet to\n+ * encounter a device that would cough up a product id when queried, even among very recent devices. They\n+ * simply return zeros as product id. Lesson: forget about querying devices to generate a device list.\n+ *\n+ * 3) Polling is a thorny issue: too much traffic on the network, and messages will be dropped left and right,\n+ * and not just the poll related ones, but others as well. In particular sending back-to-back messages\n+ * seemed to result in the second message simply never getting sent, without flow control back pressure\n+ * (NACK) from the modem. For now the work-around is to space out the messages upon sending, and\n+ * in general poll as infrequently as acceptable.\n+ *\n+ * 4) Instantiating and tracking devices when reported by the modem (either from the database, or when\n+ * messages are received) leads to complicated state management because there is no guarantee at what\n+ * point (if at all) the binding configuration will be available. It gets even more difficult when\n+ * items are created, destroyed, and modified while the binding runs.\n+ *\n+ * For the above reasons, devices are only instantiated when they are referenced by binding information.\n+ * As nice as it would be to discover devices and their properties dynamically, we have abandoned that\n+ * path because it had led to a complicated and fragile system which due to the technical limitations\n+ * above was inherently squirrely.\n+ *\n+ *\n+ * @author Bernd Pfrommer - Initial contribution\n+ * @author Daniel Pfrommer - openHAB 1 insteonplm binding\n+ * @author Rob Nielsen - Port to openHAB 2 insteon binding\n+ */\n+@NonNullByDefault\n+@SuppressWarnings({ \"null\", \"unused\" })\n+public class InsteonBinding {\n+    private static final int DEAD_DEVICE_COUNT = 10;\n+\n+    private final Logger logger = LoggerFactory.getLogger(InsteonBinding.class);\n+\n+    private Driver driver = new Driver();\n+    private ConcurrentHashMap<InsteonAddress, InsteonDevice> devices = new ConcurrentHashMap<>();\n+    private ConcurrentHashMap<String, InsteonChannelConfiguration> bindingConfigs = new ConcurrentHashMap<>();\n+    private PortListener portListener = new PortListener();\n+    private int devicePollIntervalMilliseconds = 300000;\n+    private int deadDeviceTimeout = -1;\n+    private int messagesReceived = 0;\n+    private boolean isActive = false; // state of binding\n+    private int x10HouseUnit = -1;\n+    private InsteonNetworkHandler handler;\n+\n+    public InsteonBinding(InsteonNetworkHandler handler, @Nullable InsteonNetworkConfiguration config,\n+            @Nullable SerialPortManager serialPortManager) {\n+        this.handler = handler;\n+\n+        Integer devicePollIntervalSeconds = config.getDevicePollIntervalSeconds();\n+        if (devicePollIntervalSeconds != null) {\n+            devicePollIntervalMilliseconds = devicePollIntervalSeconds * 1000;\n+        }\n+        logger.debug(\"device poll interval set to {} seconds\", devicePollIntervalMilliseconds / 1000);\n+\n+        Integer modemDbRetryTimeoutSeconds = config.getModemDbRetryTimeoutSeconds();\n+        if (modemDbRetryTimeoutSeconds != null) {\n+            logger.debug(\"setting modem db retry timeout to {} seconds\", modemDbRetryTimeoutSeconds);\n+            driver.setModemDBRetryTimeout(modemDbRetryTimeoutSeconds * 1000);\n+        }\n+\n+        String additionalDevices = config.getAdditionalDevices();\n+        if (additionalDevices != null) {\n+            try {\n+                DeviceTypeLoader.instance().loadDeviceTypesXML(additionalDevices);\n+                logger.debug(\"read additional device definitions from {}\", additionalDevices);\n+            } catch (ParserConfigurationException | SAXException | IOException e) {\n+                logger.warn(\"error reading additional devices from {}\", additionalDevices, e);\n+            }\n+        }\n+\n+        String additionalFeatures = config.getAdditionalFeatures();\n+        if (additionalFeatures != null) {\n+            logger.debug(\"reading additional feature templates from {}\", additionalFeatures);\n+            DeviceFeature.readFeatureTemplates(additionalFeatures);\n+        }\n+\n+        deadDeviceTimeout = devicePollIntervalMilliseconds * DEAD_DEVICE_COUNT;\n+        logger.debug(\"dead device timeout set to {} seconds\", deadDeviceTimeout / 1000);\n+\n+        String port = config.getPort();\n+        logger.info(\"port = '{}'\", Utils.redactPassword(port));\n+        driver.addPort(\"port\", port, serialPortManager);\n+        driver.addMsgListener(portListener, port);\n+\n+        logger.debug(\"setting driver listener\");\n+        driver.setDriverListener(portListener);\n+    }\n+\n+    public boolean startPolling() {\n+        logger.debug(\"starting {} ports\", driver.getNumberOfPorts());\n+\n+        driver.startAllPorts();\n+        logger.debug(\"ports started\");\n+        switch (driver.getNumberOfPorts()) {\n+            case 0:\n+                logger.warn(\"initialization complete, but found no ports!\");\n+                return false;\n+            case 1:\n+                logger.debug(\"initialization complete, found 1 port!\");\n+                break;\n+            default:\n+                logger.warn(\"initialization complete, found {} ports.\", driver.getNumberOfPorts());\n+                break;\n+        }\n+\n+        return true;\n+    }\n+\n+    public void setIsActive(boolean isActive) {\n+        this.isActive = isActive;\n+    }\n+\n+    public void sendCommand(String channelName, Command command) {\n+        if (!isActive) {\n+            logger.debug(\"not ready to handle commands yet, returning.\");\n+            return;\n+        }\n+\n+        InsteonChannelConfiguration bindingConfig = bindingConfigs.get(channelName);\n+        if (bindingConfig == null) {\n+            logger.warn(\"unable to find binding config for channel {}\", channelName);\n+            return;\n+        }\n+\n+        InsteonDevice dev = getDevice(bindingConfig.getAddress());\n+        if (dev == null) {\n+            logger.warn(\"no device found with insteon address {}\", bindingConfig.getAddress());\n+            return;\n+        }\n+\n+        dev.processCommand(driver, bindingConfig, command);\n+\n+        logger.debug(\"found binding config for channel {}\", channelName);\n+    }\n+\n+    public void addFeatureListener(InsteonChannelConfiguration bindingConfig) {\n+        logger.debug(\"adding listener for channel {}\", bindingConfig.getChannelName());\n+\n+        InsteonAddress address = bindingConfig.getAddress();\n+        InsteonDevice dev = getDevice(address);\n+        @Nullable\n+        DeviceFeature f = dev.getFeature(bindingConfig.getFeature());\n+        if (f == null || f.isFeatureGroup()) {\n+            StringBuilder buf = new StringBuilder();\n+            ArrayList<String> names = new ArrayList<>(dev.getFeatures().keySet());\n+            Collections.sort(names);\n+            for (String name : names) {\n+                DeviceFeature feature = dev.getFeature(name);\n+                if (!feature.isFeatureGroup()) {\n+                    if (buf.length() > 0) {\n+                        buf.append(\", \");\n+                    }\n+                    buf.append(name);\n+                }\n+            }\n+\n+            logger.warn(\"channel {} references unknown feature: {}, it will be ignored. Known features for {} are: {}.\",\n+                    bindingConfig.getChannelName(), bindingConfig.getFeature(), bindingConfig.getProductKey(),\n+                    buf.toString());\n+            return;\n+        }\n+\n+        DeviceFeatureListener fl = new DeviceFeatureListener(this, bindingConfig.getChannelUID(),\n+                bindingConfig.getChannelName());\n+        fl.setParameters(bindingConfig.getParameters());\n+        f.addListener(fl);\n+\n+        bindingConfigs.put(bindingConfig.getChannelName(), bindingConfig);\n+    }\n+\n+    public void removeFeatureListener(ChannelUID channelUID) {\n+        String channelName = channelUID.getAsString();\n+\n+        logger.debug(\"removing listener for channel {}\", channelName);\n+\n+        for (Iterator<Entry<InsteonAddress, InsteonDevice>> it = devices.entrySet().iterator(); it.hasNext();) {\n+            InsteonDevice dev = it.next().getValue();\n+            boolean removedListener = dev.removeFeatureListener(channelName);\n+            if (removedListener) {\n+                logger.trace(\"removed feature listener {} from dev {}\", channelName, dev);\n+            }\n+        }\n+    }\n+\n+    public void updateFeatureState(ChannelUID channelUID, State state) {\n+        handler.updateState(channelUID, state);\n+    }\n+\n+    public InsteonDevice makeNewDevice(InsteonAddress addr, String productKey) {\n+        DeviceType dt = DeviceTypeLoader.instance().getDeviceType(productKey);\n+        InsteonDevice dev = InsteonDevice.makeDevice(dt);\n+        dev.setAddress(addr);\n+        dev.setDriver(driver);\n+        dev.addPort(driver.getDefaultPort());\n+        if (!dev.hasValidPollingInterval()) {\n+            dev.setPollInterval(devicePollIntervalMilliseconds);\n+        }\n+        if (driver.isModemDBComplete() && dev.getStatus() != DeviceStatus.POLLING) {\n+            int ndev = checkIfInModemDatabase(dev);\n+            if (dev.hasModemDBEntry()) {\n+                dev.setStatus(DeviceStatus.POLLING);\n+                Poller.instance().startPolling(dev, ndev);\n+            }\n+        }\n+        devices.put(addr, dev);\n+\n+        handler.insteonDeviceWasCreated();\n+\n+        return (dev);\n+    }\n+\n+    public void removeDevice(InsteonAddress addr) {\n+        InsteonDevice dev = devices.remove(addr);\n+        if (dev == null) {\n+            return;\n+        }\n+\n+        if (dev.getStatus() == DeviceStatus.POLLING) {\n+            Poller.instance().stopPolling(dev);\n+        }\n+    }\n+\n+    /**\n+     * Checks if a device is in the modem link database, and, if the database\n+     * is complete, logs a warning if the device is not present\n+     *\n+     * @param dev The device to search for in the modem database\n+     * @return number of devices in modem database\n+     */\n+    private int checkIfInModemDatabase(InsteonDevice dev) {\n+        try {\n+            InsteonAddress addr = dev.getAddress();\n+            HashMap<InsteonAddress, @Nullable ModemDBEntry> dbes = driver.lockModemDBEntries();\n+            if (dbes.containsKey(addr)) {\n+                if (!dev.hasModemDBEntry()) {\n+                    logger.info(\"device {} found in the modem database and {}.\", addr, getLinkInfo(dbes, addr));\n+                    dev.setHasModemDBEntry(true);\n+                }\n+            } else {\n+                if (driver.isModemDBComplete() && !addr.isX10()) {\n+                    logger.warn(\"device {} not found in the modem database. Did you forget to link?\", addr);\n+                }\n+            }\n+            return dbes.size();\n+        } finally {\n+            driver.unlockModemDBEntries();\n+        }\n+    }\n+\n+    /**\n+     * Everything below was copied from Insteon PLM v1\n+     */\n+\n+    /**\n+     * Clean up all state.\n+     */\n+    public void shutdown() {\n+        logger.debug(\"shutting down Insteon bridge\");\n+        driver.stopAllPorts();\n+        devices.clear();\n+        RequestQueueManager.destroyInstance();\n+        Poller.instance().stop();\n+        isActive = false;\n+    }\n+\n+    /**\n+     * Method to find a device by address\n+     *\n+     * @param aAddr the insteon address to search for\n+     * @return reference to the device, or null if not found\n+     */\n+    public @Nullable InsteonDevice getDevice(@Nullable InsteonAddress aAddr) {\n+        InsteonDevice dev = (aAddr == null) ? null : devices.get(aAddr);\n+        return (dev);\n+    }\n+\n+    private String getLinkInfo(HashMap<InsteonAddress, @Nullable ModemDBEntry> dbes, InsteonAddress a) {\n+        ModemDBEntry dbe = dbes.get(a);\n+        ArrayList<Byte> controls = dbe.getControls();\n+        ArrayList<Byte> responds = dbe.getRespondsTo();\n+\n+        StringBuilder buf = new StringBuilder(\"the modem\");\n+        if (!controls.isEmpty()) {\n+            buf.append(\" controls groups [\");\n+            buf.append(toGroupString(controls));\n+            buf.append(\"]\");\n+        }\n+\n+        if (!responds.isEmpty()) {\n+            if (!controls.isEmpty()) {\n+                buf.append(\" and\");\n+            }\n+\n+            buf.append(\" responds to groups [\");\n+            buf.append(toGroupString(responds));\n+            buf.append(\"]\");\n+        }\n+\n+        return buf.toString();\n+    }\n+\n+    private String toGroupString(ArrayList<Byte> group) {\n+        ArrayList<Byte> sorted = new ArrayList<>(group);\n+        Collections.sort(sorted);\n+\n+        StringBuilder buf = new StringBuilder();\n+        for (Byte b : sorted) {\n+            if (buf.length() > 0) {\n+                buf.append(\",\");\n+            }\n+            buf.append(\"0x\");\n+            buf.append(Utils.getHexString(b));\n+        }\n+\n+        return buf.toString();\n+    }\n+\n+    public void logDeviceStatistics() {\n+        String msg = String.format(\"devices: %3d configured, %3d polling, msgs received: %5d\", devices.size(),\n+                Poller.instance().getSizeOfQueue(), messagesReceived);\n+        logger.info(\"{}\", msg);\n+        messagesReceived = 0;\n+        for (InsteonDevice dev : devices.values()) {\n+            if (dev.isModem()) {\n+                continue;\n+            }\n+            if (deadDeviceTimeout > 0 && dev.getPollOverDueTime() > deadDeviceTimeout) {\n+                logger.warn(\"device {} has not responded to polls for {} sec\", dev.toString(),", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTMxNzEzMA=="}, "originalCommit": {"oid": "04a9796d14dfbc5f3ff997d872f04b6d03ee411d"}, "originalPosition": 403}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTk3OTkyNg==", "bodyText": "No, please change it - history tells us that it otherwise will easily be forgotten...", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r389979926", "createdAt": "2020-03-09T21:46:21Z", "author": {"login": "kaikreuzer"}, "path": "bundles/org.openhab.binding.insteon/src/main/java/org/openhab/binding/insteon/internal/InsteonBinding.java", "diffHunk": "@@ -0,0 +1,520 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.insteon.internal;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map.Entry;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import javax.xml.parsers.ParserConfigurationException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.openhab.binding.insteon.internal.config.InsteonChannelConfiguration;\n+import org.openhab.binding.insteon.internal.config.InsteonNetworkConfiguration;\n+import org.openhab.binding.insteon.internal.device.DeviceFeature;\n+import org.openhab.binding.insteon.internal.device.DeviceFeatureListener;\n+import org.openhab.binding.insteon.internal.device.DeviceType;\n+import org.openhab.binding.insteon.internal.device.DeviceTypeLoader;\n+import org.openhab.binding.insteon.internal.device.InsteonAddress;\n+import org.openhab.binding.insteon.internal.device.InsteonDevice;\n+import org.openhab.binding.insteon.internal.device.InsteonDevice.DeviceStatus;\n+import org.openhab.binding.insteon.internal.device.RequestQueueManager;\n+import org.openhab.binding.insteon.internal.driver.Driver;\n+import org.openhab.binding.insteon.internal.driver.DriverListener;\n+import org.openhab.binding.insteon.internal.driver.ModemDBEntry;\n+import org.openhab.binding.insteon.internal.driver.Poller;\n+import org.openhab.binding.insteon.internal.handler.InsteonNetworkHandler;\n+import org.openhab.binding.insteon.internal.message.FieldException;\n+import org.openhab.binding.insteon.internal.message.Msg;\n+import org.openhab.binding.insteon.internal.message.MsgListener;\n+import org.openhab.binding.insteon.internal.utils.Utils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.xml.sax.SAXException;\n+\n+/**\n+ * A majority of the code in this file is from the openHAB 1 binding\n+ * org.openhab.binding.insteonplm.InsteonPLMActiveBinding. Including the comments below.\n+ *\n+ * -----------------------------------------------------------------------------------------------\n+ *\n+ * This class represents the actual implementation of the binding, and controls the high level flow\n+ * of messages to and from the InsteonModem.\n+ *\n+ * Writing this binding has been an odyssey through the quirks of the Insteon protocol\n+ * and Insteon devices. A substantial redesign was necessary at some point along the way.\n+ * Here are some of the hard learned lessons that should be considered by anyone who wants\n+ * to re-architect the binding:\n+ *\n+ * 1) The entries of the link database of the modem are not reliable. The category/subcategory entries in\n+ * particular have junk data. Forget about using the modem database to generate a list of devices.\n+ * The database should only be used to verify that a device has been linked.\n+ *\n+ * 2) Querying devices for their product information does not work either. First of all, battery operated devices\n+ * (and there are a lot of those) have their radio switched off, and may generally not respond to product\n+ * queries. Even main stream hardwired devices sold presently (like the 2477s switch and the 2477d dimmer)\n+ * don't even have a product ID. Although supposedly part of the Insteon protocol, we have yet to\n+ * encounter a device that would cough up a product id when queried, even among very recent devices. They\n+ * simply return zeros as product id. Lesson: forget about querying devices to generate a device list.\n+ *\n+ * 3) Polling is a thorny issue: too much traffic on the network, and messages will be dropped left and right,\n+ * and not just the poll related ones, but others as well. In particular sending back-to-back messages\n+ * seemed to result in the second message simply never getting sent, without flow control back pressure\n+ * (NACK) from the modem. For now the work-around is to space out the messages upon sending, and\n+ * in general poll as infrequently as acceptable.\n+ *\n+ * 4) Instantiating and tracking devices when reported by the modem (either from the database, or when\n+ * messages are received) leads to complicated state management because there is no guarantee at what\n+ * point (if at all) the binding configuration will be available. It gets even more difficult when\n+ * items are created, destroyed, and modified while the binding runs.\n+ *\n+ * For the above reasons, devices are only instantiated when they are referenced by binding information.\n+ * As nice as it would be to discover devices and their properties dynamically, we have abandoned that\n+ * path because it had led to a complicated and fragile system which due to the technical limitations\n+ * above was inherently squirrely.\n+ *\n+ *\n+ * @author Bernd Pfrommer - Initial contribution\n+ * @author Daniel Pfrommer - openHAB 1 insteonplm binding\n+ * @author Rob Nielsen - Port to openHAB 2 insteon binding\n+ */\n+@NonNullByDefault\n+@SuppressWarnings({ \"null\", \"unused\" })\n+public class InsteonBinding {\n+    private static final int DEAD_DEVICE_COUNT = 10;\n+\n+    private final Logger logger = LoggerFactory.getLogger(InsteonBinding.class);\n+\n+    private Driver driver = new Driver();\n+    private ConcurrentHashMap<InsteonAddress, InsteonDevice> devices = new ConcurrentHashMap<>();\n+    private ConcurrentHashMap<String, InsteonChannelConfiguration> bindingConfigs = new ConcurrentHashMap<>();\n+    private PortListener portListener = new PortListener();\n+    private int devicePollIntervalMilliseconds = 300000;\n+    private int deadDeviceTimeout = -1;\n+    private int messagesReceived = 0;\n+    private boolean isActive = false; // state of binding\n+    private int x10HouseUnit = -1;\n+    private InsteonNetworkHandler handler;\n+\n+    public InsteonBinding(InsteonNetworkHandler handler, @Nullable InsteonNetworkConfiguration config,\n+            @Nullable SerialPortManager serialPortManager) {\n+        this.handler = handler;\n+\n+        Integer devicePollIntervalSeconds = config.getDevicePollIntervalSeconds();\n+        if (devicePollIntervalSeconds != null) {\n+            devicePollIntervalMilliseconds = devicePollIntervalSeconds * 1000;\n+        }\n+        logger.debug(\"device poll interval set to {} seconds\", devicePollIntervalMilliseconds / 1000);\n+\n+        Integer modemDbRetryTimeoutSeconds = config.getModemDbRetryTimeoutSeconds();\n+        if (modemDbRetryTimeoutSeconds != null) {\n+            logger.debug(\"setting modem db retry timeout to {} seconds\", modemDbRetryTimeoutSeconds);\n+            driver.setModemDBRetryTimeout(modemDbRetryTimeoutSeconds * 1000);\n+        }\n+\n+        String additionalDevices = config.getAdditionalDevices();\n+        if (additionalDevices != null) {\n+            try {\n+                DeviceTypeLoader.instance().loadDeviceTypesXML(additionalDevices);\n+                logger.debug(\"read additional device definitions from {}\", additionalDevices);\n+            } catch (ParserConfigurationException | SAXException | IOException e) {\n+                logger.warn(\"error reading additional devices from {}\", additionalDevices, e);\n+            }\n+        }\n+\n+        String additionalFeatures = config.getAdditionalFeatures();\n+        if (additionalFeatures != null) {\n+            logger.debug(\"reading additional feature templates from {}\", additionalFeatures);\n+            DeviceFeature.readFeatureTemplates(additionalFeatures);\n+        }\n+\n+        deadDeviceTimeout = devicePollIntervalMilliseconds * DEAD_DEVICE_COUNT;\n+        logger.debug(\"dead device timeout set to {} seconds\", deadDeviceTimeout / 1000);\n+\n+        String port = config.getPort();\n+        logger.info(\"port = '{}'\", Utils.redactPassword(port));\n+        driver.addPort(\"port\", port, serialPortManager);\n+        driver.addMsgListener(portListener, port);\n+\n+        logger.debug(\"setting driver listener\");\n+        driver.setDriverListener(portListener);\n+    }\n+\n+    public boolean startPolling() {\n+        logger.debug(\"starting {} ports\", driver.getNumberOfPorts());\n+\n+        driver.startAllPorts();\n+        logger.debug(\"ports started\");\n+        switch (driver.getNumberOfPorts()) {\n+            case 0:\n+                logger.warn(\"initialization complete, but found no ports!\");\n+                return false;\n+            case 1:\n+                logger.debug(\"initialization complete, found 1 port!\");\n+                break;\n+            default:\n+                logger.warn(\"initialization complete, found {} ports.\", driver.getNumberOfPorts());\n+                break;\n+        }\n+\n+        return true;\n+    }\n+\n+    public void setIsActive(boolean isActive) {\n+        this.isActive = isActive;\n+    }\n+\n+    public void sendCommand(String channelName, Command command) {\n+        if (!isActive) {\n+            logger.debug(\"not ready to handle commands yet, returning.\");\n+            return;\n+        }\n+\n+        InsteonChannelConfiguration bindingConfig = bindingConfigs.get(channelName);\n+        if (bindingConfig == null) {\n+            logger.warn(\"unable to find binding config for channel {}\", channelName);\n+            return;\n+        }\n+\n+        InsteonDevice dev = getDevice(bindingConfig.getAddress());\n+        if (dev == null) {\n+            logger.warn(\"no device found with insteon address {}\", bindingConfig.getAddress());\n+            return;\n+        }\n+\n+        dev.processCommand(driver, bindingConfig, command);\n+\n+        logger.debug(\"found binding config for channel {}\", channelName);\n+    }\n+\n+    public void addFeatureListener(InsteonChannelConfiguration bindingConfig) {\n+        logger.debug(\"adding listener for channel {}\", bindingConfig.getChannelName());\n+\n+        InsteonAddress address = bindingConfig.getAddress();\n+        InsteonDevice dev = getDevice(address);\n+        @Nullable\n+        DeviceFeature f = dev.getFeature(bindingConfig.getFeature());\n+        if (f == null || f.isFeatureGroup()) {\n+            StringBuilder buf = new StringBuilder();\n+            ArrayList<String> names = new ArrayList<>(dev.getFeatures().keySet());\n+            Collections.sort(names);\n+            for (String name : names) {\n+                DeviceFeature feature = dev.getFeature(name);\n+                if (!feature.isFeatureGroup()) {\n+                    if (buf.length() > 0) {\n+                        buf.append(\", \");\n+                    }\n+                    buf.append(name);\n+                }\n+            }\n+\n+            logger.warn(\"channel {} references unknown feature: {}, it will be ignored. Known features for {} are: {}.\",\n+                    bindingConfig.getChannelName(), bindingConfig.getFeature(), bindingConfig.getProductKey(),\n+                    buf.toString());\n+            return;\n+        }\n+\n+        DeviceFeatureListener fl = new DeviceFeatureListener(this, bindingConfig.getChannelUID(),\n+                bindingConfig.getChannelName());\n+        fl.setParameters(bindingConfig.getParameters());\n+        f.addListener(fl);\n+\n+        bindingConfigs.put(bindingConfig.getChannelName(), bindingConfig);\n+    }\n+\n+    public void removeFeatureListener(ChannelUID channelUID) {\n+        String channelName = channelUID.getAsString();\n+\n+        logger.debug(\"removing listener for channel {}\", channelName);\n+\n+        for (Iterator<Entry<InsteonAddress, InsteonDevice>> it = devices.entrySet().iterator(); it.hasNext();) {\n+            InsteonDevice dev = it.next().getValue();\n+            boolean removedListener = dev.removeFeatureListener(channelName);\n+            if (removedListener) {\n+                logger.trace(\"removed feature listener {} from dev {}\", channelName, dev);\n+            }\n+        }\n+    }\n+\n+    public void updateFeatureState(ChannelUID channelUID, State state) {\n+        handler.updateState(channelUID, state);\n+    }\n+\n+    public InsteonDevice makeNewDevice(InsteonAddress addr, String productKey) {\n+        DeviceType dt = DeviceTypeLoader.instance().getDeviceType(productKey);\n+        InsteonDevice dev = InsteonDevice.makeDevice(dt);\n+        dev.setAddress(addr);\n+        dev.setDriver(driver);\n+        dev.addPort(driver.getDefaultPort());\n+        if (!dev.hasValidPollingInterval()) {\n+            dev.setPollInterval(devicePollIntervalMilliseconds);\n+        }\n+        if (driver.isModemDBComplete() && dev.getStatus() != DeviceStatus.POLLING) {\n+            int ndev = checkIfInModemDatabase(dev);\n+            if (dev.hasModemDBEntry()) {\n+                dev.setStatus(DeviceStatus.POLLING);\n+                Poller.instance().startPolling(dev, ndev);\n+            }\n+        }\n+        devices.put(addr, dev);\n+\n+        handler.insteonDeviceWasCreated();\n+\n+        return (dev);\n+    }\n+\n+    public void removeDevice(InsteonAddress addr) {\n+        InsteonDevice dev = devices.remove(addr);\n+        if (dev == null) {\n+            return;\n+        }\n+\n+        if (dev.getStatus() == DeviceStatus.POLLING) {\n+            Poller.instance().stopPolling(dev);\n+        }\n+    }\n+\n+    /**\n+     * Checks if a device is in the modem link database, and, if the database\n+     * is complete, logs a warning if the device is not present\n+     *\n+     * @param dev The device to search for in the modem database\n+     * @return number of devices in modem database\n+     */\n+    private int checkIfInModemDatabase(InsteonDevice dev) {\n+        try {\n+            InsteonAddress addr = dev.getAddress();\n+            HashMap<InsteonAddress, @Nullable ModemDBEntry> dbes = driver.lockModemDBEntries();\n+            if (dbes.containsKey(addr)) {\n+                if (!dev.hasModemDBEntry()) {\n+                    logger.info(\"device {} found in the modem database and {}.\", addr, getLinkInfo(dbes, addr));\n+                    dev.setHasModemDBEntry(true);\n+                }\n+            } else {\n+                if (driver.isModemDBComplete() && !addr.isX10()) {\n+                    logger.warn(\"device {} not found in the modem database. Did you forget to link?\", addr);\n+                }\n+            }\n+            return dbes.size();\n+        } finally {\n+            driver.unlockModemDBEntries();\n+        }\n+    }\n+\n+    /**\n+     * Everything below was copied from Insteon PLM v1\n+     */\n+\n+    /**\n+     * Clean up all state.\n+     */\n+    public void shutdown() {\n+        logger.debug(\"shutting down Insteon bridge\");\n+        driver.stopAllPorts();\n+        devices.clear();\n+        RequestQueueManager.destroyInstance();\n+        Poller.instance().stop();\n+        isActive = false;\n+    }\n+\n+    /**\n+     * Method to find a device by address\n+     *\n+     * @param aAddr the insteon address to search for\n+     * @return reference to the device, or null if not found\n+     */\n+    public @Nullable InsteonDevice getDevice(@Nullable InsteonAddress aAddr) {\n+        InsteonDevice dev = (aAddr == null) ? null : devices.get(aAddr);\n+        return (dev);\n+    }\n+\n+    private String getLinkInfo(HashMap<InsteonAddress, @Nullable ModemDBEntry> dbes, InsteonAddress a) {\n+        ModemDBEntry dbe = dbes.get(a);\n+        ArrayList<Byte> controls = dbe.getControls();\n+        ArrayList<Byte> responds = dbe.getRespondsTo();\n+\n+        StringBuilder buf = new StringBuilder(\"the modem\");\n+        if (!controls.isEmpty()) {\n+            buf.append(\" controls groups [\");\n+            buf.append(toGroupString(controls));\n+            buf.append(\"]\");\n+        }\n+\n+        if (!responds.isEmpty()) {\n+            if (!controls.isEmpty()) {\n+                buf.append(\" and\");\n+            }\n+\n+            buf.append(\" responds to groups [\");\n+            buf.append(toGroupString(responds));\n+            buf.append(\"]\");\n+        }\n+\n+        return buf.toString();\n+    }\n+\n+    private String toGroupString(ArrayList<Byte> group) {\n+        ArrayList<Byte> sorted = new ArrayList<>(group);\n+        Collections.sort(sorted);\n+\n+        StringBuilder buf = new StringBuilder();\n+        for (Byte b : sorted) {\n+            if (buf.length() > 0) {\n+                buf.append(\",\");\n+            }\n+            buf.append(\"0x\");\n+            buf.append(Utils.getHexString(b));\n+        }\n+\n+        return buf.toString();\n+    }\n+\n+    public void logDeviceStatistics() {\n+        String msg = String.format(\"devices: %3d configured, %3d polling, msgs received: %5d\", devices.size(),\n+                Poller.instance().getSizeOfQueue(), messagesReceived);\n+        logger.info(\"{}\", msg);\n+        messagesReceived = 0;\n+        for (InsteonDevice dev : devices.values()) {\n+            if (dev.isModem()) {\n+                continue;\n+            }\n+            if (deadDeviceTimeout > 0 && dev.getPollOverDueTime() > deadDeviceTimeout) {\n+                logger.warn(\"device {} has not responded to polls for {} sec\", dev.toString(),\n+                        dev.getPollOverDueTime() / 3600);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Handles messages that come in from the ports.\n+     * Will only process one message at a time.\n+     */\n+    @NonNullByDefault\n+    private class PortListener implements MsgListener, DriverListener {\n+        @Override\n+        public void msg(Msg msg, String fromPort) {\n+            if (msg.isEcho() || msg.isPureNack()) {\n+                return;\n+            }\n+            messagesReceived++;\n+            logger.debug(\"got msg: {}\", msg);\n+            if (msg.isX10()) {\n+                handleX10Message(msg, fromPort);\n+            } else {\n+                handleInsteonMessage(msg, fromPort);\n+            }\n+\n+        }\n+\n+        @Override\n+        public void driverCompletelyInitialized() {\n+            List<String> missing = new ArrayList<String>();\n+            try {\n+                HashMap<InsteonAddress, @Nullable ModemDBEntry> dbes = driver.lockModemDBEntries();\n+                logger.info(\"modem database has {} entries!\", dbes.size());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTMxNzE0NQ=="}, "originalCommit": {"oid": "04a9796d14dfbc5f3ff997d872f04b6d03ee411d"}, "originalPosition": 435}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTk4MDAyNw==", "bodyText": "dito", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r389980027", "createdAt": "2020-03-09T21:46:33Z", "author": {"login": "kaikreuzer"}, "path": "bundles/org.openhab.binding.insteon/src/main/java/org/openhab/binding/insteon/internal/InsteonBinding.java", "diffHunk": "@@ -0,0 +1,520 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.insteon.internal;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map.Entry;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import javax.xml.parsers.ParserConfigurationException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.openhab.binding.insteon.internal.config.InsteonChannelConfiguration;\n+import org.openhab.binding.insteon.internal.config.InsteonNetworkConfiguration;\n+import org.openhab.binding.insteon.internal.device.DeviceFeature;\n+import org.openhab.binding.insteon.internal.device.DeviceFeatureListener;\n+import org.openhab.binding.insteon.internal.device.DeviceType;\n+import org.openhab.binding.insteon.internal.device.DeviceTypeLoader;\n+import org.openhab.binding.insteon.internal.device.InsteonAddress;\n+import org.openhab.binding.insteon.internal.device.InsteonDevice;\n+import org.openhab.binding.insteon.internal.device.InsteonDevice.DeviceStatus;\n+import org.openhab.binding.insteon.internal.device.RequestQueueManager;\n+import org.openhab.binding.insteon.internal.driver.Driver;\n+import org.openhab.binding.insteon.internal.driver.DriverListener;\n+import org.openhab.binding.insteon.internal.driver.ModemDBEntry;\n+import org.openhab.binding.insteon.internal.driver.Poller;\n+import org.openhab.binding.insteon.internal.handler.InsteonNetworkHandler;\n+import org.openhab.binding.insteon.internal.message.FieldException;\n+import org.openhab.binding.insteon.internal.message.Msg;\n+import org.openhab.binding.insteon.internal.message.MsgListener;\n+import org.openhab.binding.insteon.internal.utils.Utils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.xml.sax.SAXException;\n+\n+/**\n+ * A majority of the code in this file is from the openHAB 1 binding\n+ * org.openhab.binding.insteonplm.InsteonPLMActiveBinding. Including the comments below.\n+ *\n+ * -----------------------------------------------------------------------------------------------\n+ *\n+ * This class represents the actual implementation of the binding, and controls the high level flow\n+ * of messages to and from the InsteonModem.\n+ *\n+ * Writing this binding has been an odyssey through the quirks of the Insteon protocol\n+ * and Insteon devices. A substantial redesign was necessary at some point along the way.\n+ * Here are some of the hard learned lessons that should be considered by anyone who wants\n+ * to re-architect the binding:\n+ *\n+ * 1) The entries of the link database of the modem are not reliable. The category/subcategory entries in\n+ * particular have junk data. Forget about using the modem database to generate a list of devices.\n+ * The database should only be used to verify that a device has been linked.\n+ *\n+ * 2) Querying devices for their product information does not work either. First of all, battery operated devices\n+ * (and there are a lot of those) have their radio switched off, and may generally not respond to product\n+ * queries. Even main stream hardwired devices sold presently (like the 2477s switch and the 2477d dimmer)\n+ * don't even have a product ID. Although supposedly part of the Insteon protocol, we have yet to\n+ * encounter a device that would cough up a product id when queried, even among very recent devices. They\n+ * simply return zeros as product id. Lesson: forget about querying devices to generate a device list.\n+ *\n+ * 3) Polling is a thorny issue: too much traffic on the network, and messages will be dropped left and right,\n+ * and not just the poll related ones, but others as well. In particular sending back-to-back messages\n+ * seemed to result in the second message simply never getting sent, without flow control back pressure\n+ * (NACK) from the modem. For now the work-around is to space out the messages upon sending, and\n+ * in general poll as infrequently as acceptable.\n+ *\n+ * 4) Instantiating and tracking devices when reported by the modem (either from the database, or when\n+ * messages are received) leads to complicated state management because there is no guarantee at what\n+ * point (if at all) the binding configuration will be available. It gets even more difficult when\n+ * items are created, destroyed, and modified while the binding runs.\n+ *\n+ * For the above reasons, devices are only instantiated when they are referenced by binding information.\n+ * As nice as it would be to discover devices and their properties dynamically, we have abandoned that\n+ * path because it had led to a complicated and fragile system which due to the technical limitations\n+ * above was inherently squirrely.\n+ *\n+ *\n+ * @author Bernd Pfrommer - Initial contribution\n+ * @author Daniel Pfrommer - openHAB 1 insteonplm binding\n+ * @author Rob Nielsen - Port to openHAB 2 insteon binding\n+ */\n+@NonNullByDefault\n+@SuppressWarnings({ \"null\", \"unused\" })\n+public class InsteonBinding {\n+    private static final int DEAD_DEVICE_COUNT = 10;\n+\n+    private final Logger logger = LoggerFactory.getLogger(InsteonBinding.class);\n+\n+    private Driver driver = new Driver();\n+    private ConcurrentHashMap<InsteonAddress, InsteonDevice> devices = new ConcurrentHashMap<>();\n+    private ConcurrentHashMap<String, InsteonChannelConfiguration> bindingConfigs = new ConcurrentHashMap<>();\n+    private PortListener portListener = new PortListener();\n+    private int devicePollIntervalMilliseconds = 300000;\n+    private int deadDeviceTimeout = -1;\n+    private int messagesReceived = 0;\n+    private boolean isActive = false; // state of binding\n+    private int x10HouseUnit = -1;\n+    private InsteonNetworkHandler handler;\n+\n+    public InsteonBinding(InsteonNetworkHandler handler, @Nullable InsteonNetworkConfiguration config,\n+            @Nullable SerialPortManager serialPortManager) {\n+        this.handler = handler;\n+\n+        Integer devicePollIntervalSeconds = config.getDevicePollIntervalSeconds();\n+        if (devicePollIntervalSeconds != null) {\n+            devicePollIntervalMilliseconds = devicePollIntervalSeconds * 1000;\n+        }\n+        logger.debug(\"device poll interval set to {} seconds\", devicePollIntervalMilliseconds / 1000);\n+\n+        Integer modemDbRetryTimeoutSeconds = config.getModemDbRetryTimeoutSeconds();\n+        if (modemDbRetryTimeoutSeconds != null) {\n+            logger.debug(\"setting modem db retry timeout to {} seconds\", modemDbRetryTimeoutSeconds);\n+            driver.setModemDBRetryTimeout(modemDbRetryTimeoutSeconds * 1000);\n+        }\n+\n+        String additionalDevices = config.getAdditionalDevices();\n+        if (additionalDevices != null) {\n+            try {\n+                DeviceTypeLoader.instance().loadDeviceTypesXML(additionalDevices);\n+                logger.debug(\"read additional device definitions from {}\", additionalDevices);\n+            } catch (ParserConfigurationException | SAXException | IOException e) {\n+                logger.warn(\"error reading additional devices from {}\", additionalDevices, e);\n+            }\n+        }\n+\n+        String additionalFeatures = config.getAdditionalFeatures();\n+        if (additionalFeatures != null) {\n+            logger.debug(\"reading additional feature templates from {}\", additionalFeatures);\n+            DeviceFeature.readFeatureTemplates(additionalFeatures);\n+        }\n+\n+        deadDeviceTimeout = devicePollIntervalMilliseconds * DEAD_DEVICE_COUNT;\n+        logger.debug(\"dead device timeout set to {} seconds\", deadDeviceTimeout / 1000);\n+\n+        String port = config.getPort();\n+        logger.info(\"port = '{}'\", Utils.redactPassword(port));\n+        driver.addPort(\"port\", port, serialPortManager);\n+        driver.addMsgListener(portListener, port);\n+\n+        logger.debug(\"setting driver listener\");\n+        driver.setDriverListener(portListener);\n+    }\n+\n+    public boolean startPolling() {\n+        logger.debug(\"starting {} ports\", driver.getNumberOfPorts());\n+\n+        driver.startAllPorts();\n+        logger.debug(\"ports started\");\n+        switch (driver.getNumberOfPorts()) {\n+            case 0:\n+                logger.warn(\"initialization complete, but found no ports!\");\n+                return false;\n+            case 1:\n+                logger.debug(\"initialization complete, found 1 port!\");\n+                break;\n+            default:\n+                logger.warn(\"initialization complete, found {} ports.\", driver.getNumberOfPorts());\n+                break;\n+        }\n+\n+        return true;\n+    }\n+\n+    public void setIsActive(boolean isActive) {\n+        this.isActive = isActive;\n+    }\n+\n+    public void sendCommand(String channelName, Command command) {\n+        if (!isActive) {\n+            logger.debug(\"not ready to handle commands yet, returning.\");\n+            return;\n+        }\n+\n+        InsteonChannelConfiguration bindingConfig = bindingConfigs.get(channelName);\n+        if (bindingConfig == null) {\n+            logger.warn(\"unable to find binding config for channel {}\", channelName);\n+            return;\n+        }\n+\n+        InsteonDevice dev = getDevice(bindingConfig.getAddress());\n+        if (dev == null) {\n+            logger.warn(\"no device found with insteon address {}\", bindingConfig.getAddress());\n+            return;\n+        }\n+\n+        dev.processCommand(driver, bindingConfig, command);\n+\n+        logger.debug(\"found binding config for channel {}\", channelName);\n+    }\n+\n+    public void addFeatureListener(InsteonChannelConfiguration bindingConfig) {\n+        logger.debug(\"adding listener for channel {}\", bindingConfig.getChannelName());\n+\n+        InsteonAddress address = bindingConfig.getAddress();\n+        InsteonDevice dev = getDevice(address);\n+        @Nullable\n+        DeviceFeature f = dev.getFeature(bindingConfig.getFeature());\n+        if (f == null || f.isFeatureGroup()) {\n+            StringBuilder buf = new StringBuilder();\n+            ArrayList<String> names = new ArrayList<>(dev.getFeatures().keySet());\n+            Collections.sort(names);\n+            for (String name : names) {\n+                DeviceFeature feature = dev.getFeature(name);\n+                if (!feature.isFeatureGroup()) {\n+                    if (buf.length() > 0) {\n+                        buf.append(\", \");\n+                    }\n+                    buf.append(name);\n+                }\n+            }\n+\n+            logger.warn(\"channel {} references unknown feature: {}, it will be ignored. Known features for {} are: {}.\",\n+                    bindingConfig.getChannelName(), bindingConfig.getFeature(), bindingConfig.getProductKey(),\n+                    buf.toString());\n+            return;\n+        }\n+\n+        DeviceFeatureListener fl = new DeviceFeatureListener(this, bindingConfig.getChannelUID(),\n+                bindingConfig.getChannelName());\n+        fl.setParameters(bindingConfig.getParameters());\n+        f.addListener(fl);\n+\n+        bindingConfigs.put(bindingConfig.getChannelName(), bindingConfig);\n+    }\n+\n+    public void removeFeatureListener(ChannelUID channelUID) {\n+        String channelName = channelUID.getAsString();\n+\n+        logger.debug(\"removing listener for channel {}\", channelName);\n+\n+        for (Iterator<Entry<InsteonAddress, InsteonDevice>> it = devices.entrySet().iterator(); it.hasNext();) {\n+            InsteonDevice dev = it.next().getValue();\n+            boolean removedListener = dev.removeFeatureListener(channelName);\n+            if (removedListener) {\n+                logger.trace(\"removed feature listener {} from dev {}\", channelName, dev);\n+            }\n+        }\n+    }\n+\n+    public void updateFeatureState(ChannelUID channelUID, State state) {\n+        handler.updateState(channelUID, state);\n+    }\n+\n+    public InsteonDevice makeNewDevice(InsteonAddress addr, String productKey) {\n+        DeviceType dt = DeviceTypeLoader.instance().getDeviceType(productKey);\n+        InsteonDevice dev = InsteonDevice.makeDevice(dt);\n+        dev.setAddress(addr);\n+        dev.setDriver(driver);\n+        dev.addPort(driver.getDefaultPort());\n+        if (!dev.hasValidPollingInterval()) {\n+            dev.setPollInterval(devicePollIntervalMilliseconds);\n+        }\n+        if (driver.isModemDBComplete() && dev.getStatus() != DeviceStatus.POLLING) {\n+            int ndev = checkIfInModemDatabase(dev);\n+            if (dev.hasModemDBEntry()) {\n+                dev.setStatus(DeviceStatus.POLLING);\n+                Poller.instance().startPolling(dev, ndev);\n+            }\n+        }\n+        devices.put(addr, dev);\n+\n+        handler.insteonDeviceWasCreated();\n+\n+        return (dev);\n+    }\n+\n+    public void removeDevice(InsteonAddress addr) {\n+        InsteonDevice dev = devices.remove(addr);\n+        if (dev == null) {\n+            return;\n+        }\n+\n+        if (dev.getStatus() == DeviceStatus.POLLING) {\n+            Poller.instance().stopPolling(dev);\n+        }\n+    }\n+\n+    /**\n+     * Checks if a device is in the modem link database, and, if the database\n+     * is complete, logs a warning if the device is not present\n+     *\n+     * @param dev The device to search for in the modem database\n+     * @return number of devices in modem database\n+     */\n+    private int checkIfInModemDatabase(InsteonDevice dev) {\n+        try {\n+            InsteonAddress addr = dev.getAddress();\n+            HashMap<InsteonAddress, @Nullable ModemDBEntry> dbes = driver.lockModemDBEntries();\n+            if (dbes.containsKey(addr)) {\n+                if (!dev.hasModemDBEntry()) {\n+                    logger.info(\"device {} found in the modem database and {}.\", addr, getLinkInfo(dbes, addr));\n+                    dev.setHasModemDBEntry(true);\n+                }\n+            } else {\n+                if (driver.isModemDBComplete() && !addr.isX10()) {\n+                    logger.warn(\"device {} not found in the modem database. Did you forget to link?\", addr);\n+                }\n+            }\n+            return dbes.size();\n+        } finally {\n+            driver.unlockModemDBEntries();\n+        }\n+    }\n+\n+    /**\n+     * Everything below was copied from Insteon PLM v1\n+     */\n+\n+    /**\n+     * Clean up all state.\n+     */\n+    public void shutdown() {\n+        logger.debug(\"shutting down Insteon bridge\");\n+        driver.stopAllPorts();\n+        devices.clear();\n+        RequestQueueManager.destroyInstance();\n+        Poller.instance().stop();\n+        isActive = false;\n+    }\n+\n+    /**\n+     * Method to find a device by address\n+     *\n+     * @param aAddr the insteon address to search for\n+     * @return reference to the device, or null if not found\n+     */\n+    public @Nullable InsteonDevice getDevice(@Nullable InsteonAddress aAddr) {\n+        InsteonDevice dev = (aAddr == null) ? null : devices.get(aAddr);\n+        return (dev);\n+    }\n+\n+    private String getLinkInfo(HashMap<InsteonAddress, @Nullable ModemDBEntry> dbes, InsteonAddress a) {\n+        ModemDBEntry dbe = dbes.get(a);\n+        ArrayList<Byte> controls = dbe.getControls();\n+        ArrayList<Byte> responds = dbe.getRespondsTo();\n+\n+        StringBuilder buf = new StringBuilder(\"the modem\");\n+        if (!controls.isEmpty()) {\n+            buf.append(\" controls groups [\");\n+            buf.append(toGroupString(controls));\n+            buf.append(\"]\");\n+        }\n+\n+        if (!responds.isEmpty()) {\n+            if (!controls.isEmpty()) {\n+                buf.append(\" and\");\n+            }\n+\n+            buf.append(\" responds to groups [\");\n+            buf.append(toGroupString(responds));\n+            buf.append(\"]\");\n+        }\n+\n+        return buf.toString();\n+    }\n+\n+    private String toGroupString(ArrayList<Byte> group) {\n+        ArrayList<Byte> sorted = new ArrayList<>(group);\n+        Collections.sort(sorted);\n+\n+        StringBuilder buf = new StringBuilder();\n+        for (Byte b : sorted) {\n+            if (buf.length() > 0) {\n+                buf.append(\",\");\n+            }\n+            buf.append(\"0x\");\n+            buf.append(Utils.getHexString(b));\n+        }\n+\n+        return buf.toString();\n+    }\n+\n+    public void logDeviceStatistics() {\n+        String msg = String.format(\"devices: %3d configured, %3d polling, msgs received: %5d\", devices.size(),\n+                Poller.instance().getSizeOfQueue(), messagesReceived);\n+        logger.info(\"{}\", msg);\n+        messagesReceived = 0;\n+        for (InsteonDevice dev : devices.values()) {\n+            if (dev.isModem()) {\n+                continue;\n+            }\n+            if (deadDeviceTimeout > 0 && dev.getPollOverDueTime() > deadDeviceTimeout) {\n+                logger.warn(\"device {} has not responded to polls for {} sec\", dev.toString(),\n+                        dev.getPollOverDueTime() / 3600);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Handles messages that come in from the ports.\n+     * Will only process one message at a time.\n+     */\n+    @NonNullByDefault\n+    private class PortListener implements MsgListener, DriverListener {\n+        @Override\n+        public void msg(Msg msg, String fromPort) {\n+            if (msg.isEcho() || msg.isPureNack()) {\n+                return;\n+            }\n+            messagesReceived++;\n+            logger.debug(\"got msg: {}\", msg);\n+            if (msg.isX10()) {\n+                handleX10Message(msg, fromPort);\n+            } else {\n+                handleInsteonMessage(msg, fromPort);\n+            }\n+\n+        }\n+\n+        @Override\n+        public void driverCompletelyInitialized() {\n+            List<String> missing = new ArrayList<String>();\n+            try {\n+                HashMap<InsteonAddress, @Nullable ModemDBEntry> dbes = driver.lockModemDBEntries();\n+                logger.info(\"modem database has {} entries!\", dbes.size());\n+                if (dbes.isEmpty()) {\n+                    logger.warn(\"the modem link database is empty!\");\n+                }\n+                for (InsteonAddress k : dbes.keySet()) {\n+                    logger.debug(\"modem db entry: {}\", k);\n+                }\n+                HashSet<InsteonAddress> addrs = new HashSet<>();\n+                for (InsteonDevice dev : devices.values()) {\n+                    InsteonAddress a = dev.getAddress();\n+                    if (!dbes.containsKey(a)) {\n+                        if (!a.isX10()) {\n+                            logger.warn(\"device {} not found in the modem database. Did you forget to link?\", a);\n+                        }\n+                    } else {\n+                        if (!dev.hasModemDBEntry()) {\n+                            addrs.add(a);\n+                            logger.info(\"device {} found in the modem database and {}.\", a, getLinkInfo(dbes, a));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTMxNzE4NQ=="}, "originalCommit": {"oid": "04a9796d14dfbc5f3ff997d872f04b6d03ee411d"}, "originalPosition": 452}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTk4MDE2MQ==", "bodyText": "dito", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r389980161", "createdAt": "2020-03-09T21:46:49Z", "author": {"login": "kaikreuzer"}, "path": "bundles/org.openhab.binding.insteon/src/main/java/org/openhab/binding/insteon/internal/InsteonBinding.java", "diffHunk": "@@ -0,0 +1,520 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.insteon.internal;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map.Entry;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import javax.xml.parsers.ParserConfigurationException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.openhab.binding.insteon.internal.config.InsteonChannelConfiguration;\n+import org.openhab.binding.insteon.internal.config.InsteonNetworkConfiguration;\n+import org.openhab.binding.insteon.internal.device.DeviceFeature;\n+import org.openhab.binding.insteon.internal.device.DeviceFeatureListener;\n+import org.openhab.binding.insteon.internal.device.DeviceType;\n+import org.openhab.binding.insteon.internal.device.DeviceTypeLoader;\n+import org.openhab.binding.insteon.internal.device.InsteonAddress;\n+import org.openhab.binding.insteon.internal.device.InsteonDevice;\n+import org.openhab.binding.insteon.internal.device.InsteonDevice.DeviceStatus;\n+import org.openhab.binding.insteon.internal.device.RequestQueueManager;\n+import org.openhab.binding.insteon.internal.driver.Driver;\n+import org.openhab.binding.insteon.internal.driver.DriverListener;\n+import org.openhab.binding.insteon.internal.driver.ModemDBEntry;\n+import org.openhab.binding.insteon.internal.driver.Poller;\n+import org.openhab.binding.insteon.internal.handler.InsteonNetworkHandler;\n+import org.openhab.binding.insteon.internal.message.FieldException;\n+import org.openhab.binding.insteon.internal.message.Msg;\n+import org.openhab.binding.insteon.internal.message.MsgListener;\n+import org.openhab.binding.insteon.internal.utils.Utils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.xml.sax.SAXException;\n+\n+/**\n+ * A majority of the code in this file is from the openHAB 1 binding\n+ * org.openhab.binding.insteonplm.InsteonPLMActiveBinding. Including the comments below.\n+ *\n+ * -----------------------------------------------------------------------------------------------\n+ *\n+ * This class represents the actual implementation of the binding, and controls the high level flow\n+ * of messages to and from the InsteonModem.\n+ *\n+ * Writing this binding has been an odyssey through the quirks of the Insteon protocol\n+ * and Insteon devices. A substantial redesign was necessary at some point along the way.\n+ * Here are some of the hard learned lessons that should be considered by anyone who wants\n+ * to re-architect the binding:\n+ *\n+ * 1) The entries of the link database of the modem are not reliable. The category/subcategory entries in\n+ * particular have junk data. Forget about using the modem database to generate a list of devices.\n+ * The database should only be used to verify that a device has been linked.\n+ *\n+ * 2) Querying devices for their product information does not work either. First of all, battery operated devices\n+ * (and there are a lot of those) have their radio switched off, and may generally not respond to product\n+ * queries. Even main stream hardwired devices sold presently (like the 2477s switch and the 2477d dimmer)\n+ * don't even have a product ID. Although supposedly part of the Insteon protocol, we have yet to\n+ * encounter a device that would cough up a product id when queried, even among very recent devices. They\n+ * simply return zeros as product id. Lesson: forget about querying devices to generate a device list.\n+ *\n+ * 3) Polling is a thorny issue: too much traffic on the network, and messages will be dropped left and right,\n+ * and not just the poll related ones, but others as well. In particular sending back-to-back messages\n+ * seemed to result in the second message simply never getting sent, without flow control back pressure\n+ * (NACK) from the modem. For now the work-around is to space out the messages upon sending, and\n+ * in general poll as infrequently as acceptable.\n+ *\n+ * 4) Instantiating and tracking devices when reported by the modem (either from the database, or when\n+ * messages are received) leads to complicated state management because there is no guarantee at what\n+ * point (if at all) the binding configuration will be available. It gets even more difficult when\n+ * items are created, destroyed, and modified while the binding runs.\n+ *\n+ * For the above reasons, devices are only instantiated when they are referenced by binding information.\n+ * As nice as it would be to discover devices and their properties dynamically, we have abandoned that\n+ * path because it had led to a complicated and fragile system which due to the technical limitations\n+ * above was inherently squirrely.\n+ *\n+ *\n+ * @author Bernd Pfrommer - Initial contribution\n+ * @author Daniel Pfrommer - openHAB 1 insteonplm binding\n+ * @author Rob Nielsen - Port to openHAB 2 insteon binding\n+ */\n+@NonNullByDefault\n+@SuppressWarnings({ \"null\", \"unused\" })\n+public class InsteonBinding {\n+    private static final int DEAD_DEVICE_COUNT = 10;\n+\n+    private final Logger logger = LoggerFactory.getLogger(InsteonBinding.class);\n+\n+    private Driver driver = new Driver();\n+    private ConcurrentHashMap<InsteonAddress, InsteonDevice> devices = new ConcurrentHashMap<>();\n+    private ConcurrentHashMap<String, InsteonChannelConfiguration> bindingConfigs = new ConcurrentHashMap<>();\n+    private PortListener portListener = new PortListener();\n+    private int devicePollIntervalMilliseconds = 300000;\n+    private int deadDeviceTimeout = -1;\n+    private int messagesReceived = 0;\n+    private boolean isActive = false; // state of binding\n+    private int x10HouseUnit = -1;\n+    private InsteonNetworkHandler handler;\n+\n+    public InsteonBinding(InsteonNetworkHandler handler, @Nullable InsteonNetworkConfiguration config,\n+            @Nullable SerialPortManager serialPortManager) {\n+        this.handler = handler;\n+\n+        Integer devicePollIntervalSeconds = config.getDevicePollIntervalSeconds();\n+        if (devicePollIntervalSeconds != null) {\n+            devicePollIntervalMilliseconds = devicePollIntervalSeconds * 1000;\n+        }\n+        logger.debug(\"device poll interval set to {} seconds\", devicePollIntervalMilliseconds / 1000);\n+\n+        Integer modemDbRetryTimeoutSeconds = config.getModemDbRetryTimeoutSeconds();\n+        if (modemDbRetryTimeoutSeconds != null) {\n+            logger.debug(\"setting modem db retry timeout to {} seconds\", modemDbRetryTimeoutSeconds);\n+            driver.setModemDBRetryTimeout(modemDbRetryTimeoutSeconds * 1000);\n+        }\n+\n+        String additionalDevices = config.getAdditionalDevices();\n+        if (additionalDevices != null) {\n+            try {\n+                DeviceTypeLoader.instance().loadDeviceTypesXML(additionalDevices);\n+                logger.debug(\"read additional device definitions from {}\", additionalDevices);\n+            } catch (ParserConfigurationException | SAXException | IOException e) {\n+                logger.warn(\"error reading additional devices from {}\", additionalDevices, e);\n+            }\n+        }\n+\n+        String additionalFeatures = config.getAdditionalFeatures();\n+        if (additionalFeatures != null) {\n+            logger.debug(\"reading additional feature templates from {}\", additionalFeatures);\n+            DeviceFeature.readFeatureTemplates(additionalFeatures);\n+        }\n+\n+        deadDeviceTimeout = devicePollIntervalMilliseconds * DEAD_DEVICE_COUNT;\n+        logger.debug(\"dead device timeout set to {} seconds\", deadDeviceTimeout / 1000);\n+\n+        String port = config.getPort();\n+        logger.info(\"port = '{}'\", Utils.redactPassword(port));\n+        driver.addPort(\"port\", port, serialPortManager);\n+        driver.addMsgListener(portListener, port);\n+\n+        logger.debug(\"setting driver listener\");\n+        driver.setDriverListener(portListener);\n+    }\n+\n+    public boolean startPolling() {\n+        logger.debug(\"starting {} ports\", driver.getNumberOfPorts());\n+\n+        driver.startAllPorts();\n+        logger.debug(\"ports started\");\n+        switch (driver.getNumberOfPorts()) {\n+            case 0:\n+                logger.warn(\"initialization complete, but found no ports!\");\n+                return false;\n+            case 1:\n+                logger.debug(\"initialization complete, found 1 port!\");\n+                break;\n+            default:\n+                logger.warn(\"initialization complete, found {} ports.\", driver.getNumberOfPorts());\n+                break;\n+        }\n+\n+        return true;\n+    }\n+\n+    public void setIsActive(boolean isActive) {\n+        this.isActive = isActive;\n+    }\n+\n+    public void sendCommand(String channelName, Command command) {\n+        if (!isActive) {\n+            logger.debug(\"not ready to handle commands yet, returning.\");\n+            return;\n+        }\n+\n+        InsteonChannelConfiguration bindingConfig = bindingConfigs.get(channelName);\n+        if (bindingConfig == null) {\n+            logger.warn(\"unable to find binding config for channel {}\", channelName);\n+            return;\n+        }\n+\n+        InsteonDevice dev = getDevice(bindingConfig.getAddress());\n+        if (dev == null) {\n+            logger.warn(\"no device found with insteon address {}\", bindingConfig.getAddress());\n+            return;\n+        }\n+\n+        dev.processCommand(driver, bindingConfig, command);\n+\n+        logger.debug(\"found binding config for channel {}\", channelName);\n+    }\n+\n+    public void addFeatureListener(InsteonChannelConfiguration bindingConfig) {\n+        logger.debug(\"adding listener for channel {}\", bindingConfig.getChannelName());\n+\n+        InsteonAddress address = bindingConfig.getAddress();\n+        InsteonDevice dev = getDevice(address);\n+        @Nullable\n+        DeviceFeature f = dev.getFeature(bindingConfig.getFeature());\n+        if (f == null || f.isFeatureGroup()) {\n+            StringBuilder buf = new StringBuilder();\n+            ArrayList<String> names = new ArrayList<>(dev.getFeatures().keySet());\n+            Collections.sort(names);\n+            for (String name : names) {\n+                DeviceFeature feature = dev.getFeature(name);\n+                if (!feature.isFeatureGroup()) {\n+                    if (buf.length() > 0) {\n+                        buf.append(\", \");\n+                    }\n+                    buf.append(name);\n+                }\n+            }\n+\n+            logger.warn(\"channel {} references unknown feature: {}, it will be ignored. Known features for {} are: {}.\",\n+                    bindingConfig.getChannelName(), bindingConfig.getFeature(), bindingConfig.getProductKey(),\n+                    buf.toString());\n+            return;\n+        }\n+\n+        DeviceFeatureListener fl = new DeviceFeatureListener(this, bindingConfig.getChannelUID(),\n+                bindingConfig.getChannelName());\n+        fl.setParameters(bindingConfig.getParameters());\n+        f.addListener(fl);\n+\n+        bindingConfigs.put(bindingConfig.getChannelName(), bindingConfig);\n+    }\n+\n+    public void removeFeatureListener(ChannelUID channelUID) {\n+        String channelName = channelUID.getAsString();\n+\n+        logger.debug(\"removing listener for channel {}\", channelName);\n+\n+        for (Iterator<Entry<InsteonAddress, InsteonDevice>> it = devices.entrySet().iterator(); it.hasNext();) {\n+            InsteonDevice dev = it.next().getValue();\n+            boolean removedListener = dev.removeFeatureListener(channelName);\n+            if (removedListener) {\n+                logger.trace(\"removed feature listener {} from dev {}\", channelName, dev);\n+            }\n+        }\n+    }\n+\n+    public void updateFeatureState(ChannelUID channelUID, State state) {\n+        handler.updateState(channelUID, state);\n+    }\n+\n+    public InsteonDevice makeNewDevice(InsteonAddress addr, String productKey) {\n+        DeviceType dt = DeviceTypeLoader.instance().getDeviceType(productKey);\n+        InsteonDevice dev = InsteonDevice.makeDevice(dt);\n+        dev.setAddress(addr);\n+        dev.setDriver(driver);\n+        dev.addPort(driver.getDefaultPort());\n+        if (!dev.hasValidPollingInterval()) {\n+            dev.setPollInterval(devicePollIntervalMilliseconds);\n+        }\n+        if (driver.isModemDBComplete() && dev.getStatus() != DeviceStatus.POLLING) {\n+            int ndev = checkIfInModemDatabase(dev);\n+            if (dev.hasModemDBEntry()) {\n+                dev.setStatus(DeviceStatus.POLLING);\n+                Poller.instance().startPolling(dev, ndev);\n+            }\n+        }\n+        devices.put(addr, dev);\n+\n+        handler.insteonDeviceWasCreated();\n+\n+        return (dev);\n+    }\n+\n+    public void removeDevice(InsteonAddress addr) {\n+        InsteonDevice dev = devices.remove(addr);\n+        if (dev == null) {\n+            return;\n+        }\n+\n+        if (dev.getStatus() == DeviceStatus.POLLING) {\n+            Poller.instance().stopPolling(dev);\n+        }\n+    }\n+\n+    /**\n+     * Checks if a device is in the modem link database, and, if the database\n+     * is complete, logs a warning if the device is not present\n+     *\n+     * @param dev The device to search for in the modem database\n+     * @return number of devices in modem database\n+     */\n+    private int checkIfInModemDatabase(InsteonDevice dev) {\n+        try {\n+            InsteonAddress addr = dev.getAddress();\n+            HashMap<InsteonAddress, @Nullable ModemDBEntry> dbes = driver.lockModemDBEntries();\n+            if (dbes.containsKey(addr)) {\n+                if (!dev.hasModemDBEntry()) {\n+                    logger.info(\"device {} found in the modem database and {}.\", addr, getLinkInfo(dbes, addr));\n+                    dev.setHasModemDBEntry(true);\n+                }\n+            } else {\n+                if (driver.isModemDBComplete() && !addr.isX10()) {\n+                    logger.warn(\"device {} not found in the modem database. Did you forget to link?\", addr);\n+                }\n+            }\n+            return dbes.size();\n+        } finally {\n+            driver.unlockModemDBEntries();\n+        }\n+    }\n+\n+    /**\n+     * Everything below was copied from Insteon PLM v1\n+     */\n+\n+    /**\n+     * Clean up all state.\n+     */\n+    public void shutdown() {\n+        logger.debug(\"shutting down Insteon bridge\");\n+        driver.stopAllPorts();\n+        devices.clear();\n+        RequestQueueManager.destroyInstance();\n+        Poller.instance().stop();\n+        isActive = false;\n+    }\n+\n+    /**\n+     * Method to find a device by address\n+     *\n+     * @param aAddr the insteon address to search for\n+     * @return reference to the device, or null if not found\n+     */\n+    public @Nullable InsteonDevice getDevice(@Nullable InsteonAddress aAddr) {\n+        InsteonDevice dev = (aAddr == null) ? null : devices.get(aAddr);\n+        return (dev);\n+    }\n+\n+    private String getLinkInfo(HashMap<InsteonAddress, @Nullable ModemDBEntry> dbes, InsteonAddress a) {\n+        ModemDBEntry dbe = dbes.get(a);\n+        ArrayList<Byte> controls = dbe.getControls();\n+        ArrayList<Byte> responds = dbe.getRespondsTo();\n+\n+        StringBuilder buf = new StringBuilder(\"the modem\");\n+        if (!controls.isEmpty()) {\n+            buf.append(\" controls groups [\");\n+            buf.append(toGroupString(controls));\n+            buf.append(\"]\");\n+        }\n+\n+        if (!responds.isEmpty()) {\n+            if (!controls.isEmpty()) {\n+                buf.append(\" and\");\n+            }\n+\n+            buf.append(\" responds to groups [\");\n+            buf.append(toGroupString(responds));\n+            buf.append(\"]\");\n+        }\n+\n+        return buf.toString();\n+    }\n+\n+    private String toGroupString(ArrayList<Byte> group) {\n+        ArrayList<Byte> sorted = new ArrayList<>(group);\n+        Collections.sort(sorted);\n+\n+        StringBuilder buf = new StringBuilder();\n+        for (Byte b : sorted) {\n+            if (buf.length() > 0) {\n+                buf.append(\",\");\n+            }\n+            buf.append(\"0x\");\n+            buf.append(Utils.getHexString(b));\n+        }\n+\n+        return buf.toString();\n+    }\n+\n+    public void logDeviceStatistics() {\n+        String msg = String.format(\"devices: %3d configured, %3d polling, msgs received: %5d\", devices.size(),\n+                Poller.instance().getSizeOfQueue(), messagesReceived);\n+        logger.info(\"{}\", msg);\n+        messagesReceived = 0;\n+        for (InsteonDevice dev : devices.values()) {\n+            if (dev.isModem()) {\n+                continue;\n+            }\n+            if (deadDeviceTimeout > 0 && dev.getPollOverDueTime() > deadDeviceTimeout) {\n+                logger.warn(\"device {} has not responded to polls for {} sec\", dev.toString(),\n+                        dev.getPollOverDueTime() / 3600);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Handles messages that come in from the ports.\n+     * Will only process one message at a time.\n+     */\n+    @NonNullByDefault\n+    private class PortListener implements MsgListener, DriverListener {\n+        @Override\n+        public void msg(Msg msg, String fromPort) {\n+            if (msg.isEcho() || msg.isPureNack()) {\n+                return;\n+            }\n+            messagesReceived++;\n+            logger.debug(\"got msg: {}\", msg);\n+            if (msg.isX10()) {\n+                handleX10Message(msg, fromPort);\n+            } else {\n+                handleInsteonMessage(msg, fromPort);\n+            }\n+\n+        }\n+\n+        @Override\n+        public void driverCompletelyInitialized() {\n+            List<String> missing = new ArrayList<String>();\n+            try {\n+                HashMap<InsteonAddress, @Nullable ModemDBEntry> dbes = driver.lockModemDBEntries();\n+                logger.info(\"modem database has {} entries!\", dbes.size());\n+                if (dbes.isEmpty()) {\n+                    logger.warn(\"the modem link database is empty!\");\n+                }\n+                for (InsteonAddress k : dbes.keySet()) {\n+                    logger.debug(\"modem db entry: {}\", k);\n+                }\n+                HashSet<InsteonAddress> addrs = new HashSet<>();\n+                for (InsteonDevice dev : devices.values()) {\n+                    InsteonAddress a = dev.getAddress();\n+                    if (!dbes.containsKey(a)) {\n+                        if (!a.isX10()) {\n+                            logger.warn(\"device {} not found in the modem database. Did you forget to link?\", a);\n+                        }\n+                    } else {\n+                        if (!dev.hasModemDBEntry()) {\n+                            addrs.add(a);\n+                            logger.info(\"device {} found in the modem database and {}.\", a, getLinkInfo(dbes, a));\n+                            dev.setHasModemDBEntry(true);\n+                        }\n+                        if (dev.getStatus() != DeviceStatus.POLLING) {\n+                            Poller.instance().startPolling(dev, dbes.size());\n+                        }\n+                    }\n+                }\n+\n+                for (InsteonAddress k : dbes.keySet()) {\n+                    if (!addrs.contains(k) && !k.equals(dbes.get(k).getPort().getAddress())) {\n+                        logger.info(\"device {} found in the modem database, but is not configured as a thing and {}.\",", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTMxNzE5NQ=="}, "originalCommit": {"oid": "04a9796d14dfbc5f3ff997d872f04b6d03ee411d"}, "originalPosition": 463}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTk4MTk1Mw==", "bodyText": "Can you link to the place in the code where this exception is thrown? As we are in a \"handleCommand\" method and the exception is about I/O, it very much seemed to me to be thrown if some communication with the device isn't working as expected. The FieldException below rather looks like an exception that is thrown on missing fields or similar.", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r389981953", "createdAt": "2020-03-09T21:51:00Z", "author": {"login": "kaikreuzer"}, "path": "bundles/org.openhab.binding.insteon/src/main/java/org/openhab/binding/insteon/internal/device/CommandHandler.java", "diffHunk": "@@ -0,0 +1,912 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.insteon.internal.device;\n+\n+import java.io.IOException;\n+import java.lang.reflect.InvocationTargetException;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.Timer;\n+import java.util.TimerTask;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.IncreaseDecreaseType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.openhab.binding.insteon.internal.config.InsteonChannelConfiguration;\n+import org.openhab.binding.insteon.internal.device.DeviceFeatureListener.StateChangeType;\n+import org.openhab.binding.insteon.internal.message.FieldException;\n+import org.openhab.binding.insteon.internal.message.Msg;\n+import org.openhab.binding.insteon.internal.utils.Utils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * A command handler translates an openHAB command into a insteon message\n+ *\n+ * @author Daniel Pfrommer - Initial contribution\n+ * @author Bernd Pfrommer - openHAB 1 insteonplm binding\n+ * @author Rob Nielsen - Port to openHAB 2 insteon binding\n+ */\n+@NonNullByDefault\n+@SuppressWarnings(\"null\")\n+public abstract class CommandHandler {\n+    private static final Logger logger = LoggerFactory.getLogger(CommandHandler.class);\n+    DeviceFeature feature; // related DeviceFeature\n+    @Nullable\n+    HashMap<String, @Nullable String> parameters = new HashMap<>();\n+\n+    /**\n+     * Constructor\n+     *\n+     * @param feature The DeviceFeature for which this command was intended.\n+     *            The openHAB commands are issued on an openhab item. The .items files bind\n+     *            an openHAB item to a DeviceFeature.\n+     */\n+    CommandHandler(DeviceFeature feature) {\n+        this.feature = feature;\n+    }\n+\n+    /**\n+     * Implements what to do when an openHAB command is received\n+     *\n+     * @param config the configuration for the item that generated the command\n+     * @param cmd the openhab command issued\n+     * @param device the Insteon device to which this command applies\n+     */\n+    public abstract void handleCommand(InsteonChannelConfiguration conf, Command cmd, InsteonDevice device);\n+\n+    /**\n+     * Returns parameter as integer\n+     *\n+     * @param key key of parameter\n+     * @param def default\n+     * @return value of parameter\n+     */\n+    protected int getIntParameter(String key, int def) {\n+        String val = parameters.get(key);\n+        if (val == null) {\n+            return (def); // param not found\n+        }\n+        int ret = def;\n+        try {\n+            ret = Utils.strToInt(val);\n+        } catch (NumberFormatException e) {\n+            logger.warn(\"malformed int parameter in command handler: {}\", key);\n+        }\n+        return ret;\n+    }\n+\n+    /**\n+     * Returns parameter as String\n+     *\n+     * @param key key of parameter\n+     * @param def default\n+     * @return value of parameter\n+     */\n+    protected @Nullable String getStringParameter(String key, String def) {\n+        return (parameters.get(key) == null ? def : parameters.get(key));\n+    }\n+\n+    /**\n+     * Shorthand to return class name for logging purposes\n+     *\n+     * @return name of the class\n+     */\n+    protected String nm() {\n+        return (this.getClass().getSimpleName());\n+    }\n+\n+    protected int getMaxLightLevel(InsteonChannelConfiguration conf, int defaultLevel) {\n+        HashMap<String, @Nullable String> params = conf.getParameters();\n+        if (conf.getFeature().contains(\"dimmer\") && params.containsKey(\"dimmermax\")) {\n+            String item = conf.getChannelName();\n+            String dimmerMax = params.get(\"dimmermax\");\n+            try {\n+                int i = Integer.parseInt(dimmerMax);\n+                if (i > 1 && i <= 99) {\n+                    int level = (int) Math.ceil((i * 255.0) / 100); // round up\n+                    if (level < defaultLevel) {\n+                        logger.debug(\"item {}: using dimmermax value of {}\", item, dimmerMax);\n+                        return level;\n+                    }\n+                } else {\n+                    logger.warn(\"item {}: dimmermax must be between 1-99 inclusive: {}\", item, dimmerMax);\n+                }\n+            } catch (NumberFormatException e) {\n+                logger.warn(\"item {}: invalid int value for dimmermax: {}\", item, dimmerMax);\n+            }\n+        }\n+\n+        return defaultLevel;\n+    }\n+\n+    void setParameters(HashMap<String, @Nullable String> hm) {\n+        parameters = hm;\n+    }\n+\n+    /**\n+     * Helper function to extract the group parameter from the binding config,\n+     *\n+     * @param c the binding configuration to test\n+     * @return the value of the \"group\" parameter, or -1 if none\n+     */\n+    protected static int getGroup(InsteonChannelConfiguration c) {\n+        String v = c.getParameters().get(\"group\");\n+        int iv = -1;\n+        try {\n+            iv = (v == null) ? -1 : Utils.strToInt(v);\n+        } catch (NumberFormatException e) {\n+            logger.warn(\"malformed int parameter in for item {}\", c.getChannelName());\n+        }\n+        return iv;\n+    }\n+\n+    @NonNullByDefault\n+    public static class WarnCommandHandler extends CommandHandler {\n+        WarnCommandHandler(DeviceFeature f) {\n+            super(f);\n+        }\n+\n+        @Override\n+        public void handleCommand(InsteonChannelConfiguration conf, Command cmd, InsteonDevice dev) {\n+            logger.warn(\"{}: command {} is not implemented yet!\", nm(), cmd);\n+        }\n+    }\n+\n+    @NonNullByDefault\n+    public static class NoOpCommandHandler extends CommandHandler {\n+        NoOpCommandHandler(DeviceFeature f) {\n+            super(f);\n+        }\n+\n+        @Override\n+        public void handleCommand(InsteonChannelConfiguration conf, Command cmd, InsteonDevice dev) {\n+            // do nothing, not even log\n+        }\n+    }\n+\n+    @NonNullByDefault\n+    public static class LightOnOffCommandHandler extends CommandHandler {\n+        LightOnOffCommandHandler(DeviceFeature f) {\n+            super(f);\n+        }\n+\n+        @Override\n+        public void handleCommand(InsteonChannelConfiguration conf, Command cmd, InsteonDevice dev) {\n+            try {\n+                int ext = getIntParameter(\"ext\", 0);\n+                int direc = 0x00;\n+                int level = 0x00;\n+                Msg m = null;\n+                if (cmd == OnOffType.ON) {\n+                    level = getMaxLightLevel(conf, 0xff);\n+                    direc = 0x11;\n+                    logger.debug(\"{}: sent msg to switch {} to {}\", nm(), dev.getAddress(),\n+                            level == 0xff ? \"on\" : level);\n+                } else if (cmd == OnOffType.OFF) {\n+                    direc = 0x13;\n+                    logger.debug(\"{}: sent msg to switch {} off\", nm(), dev.getAddress());\n+                }\n+                if (ext == 1 || ext == 2) {\n+                    byte[] data = new byte[] { (byte) getIntParameter(\"d1\", 0), (byte) getIntParameter(\"d2\", 0),\n+                            (byte) getIntParameter(\"d3\", 0) };\n+                    m = dev.makeExtendedMessage((byte) 0x0f, (byte) direc, (byte) level, data);\n+                    logger.debug(\"{}: was an extended message for device {}\", nm(), dev.getAddress());\n+                    if (ext == 1) {\n+                        m.setCRC();\n+                    } else if (ext == 2) {\n+                        m.setCRC2();\n+                    }\n+                } else {\n+                    m = dev.makeStandardMessage((byte) 0x0f, (byte) direc, (byte) level, getGroup(conf));\n+                }\n+                logger.debug(\"Sending message to {}\", dev.getAddress());\n+                dev.enqueueMessage(m, feature);\n+                // expect to get a direct ack after this!\n+            } catch (IOException e) {\n+                logger.warn(\"{}: command send i/o error: \", nm(), e);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTMxNzM2MA=="}, "originalCommit": {"oid": "04a9796d14dfbc5f3ff997d872f04b6d03ee411d"}, "originalPosition": 221}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTk4MzI3MA==", "bodyText": "Astro is an exception, because we know that sun and moon exist.\nJust because misusing a feature makes some people happy, we must not go down that path.\nAnd the new UI is guiding people anyhow much better in the setup process, so the inbox should stay what it is: The place where discovered devices are found.", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r389983270", "createdAt": "2020-03-09T21:54:17Z", "author": {"login": "kaikreuzer"}, "path": "bundles/org.openhab.binding.insteon/src/main/java/org/openhab/binding/insteon/internal/discovery/InsteonNetworkDiscoveryService.java", "diffHunk": "@@ -0,0 +1,59 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.insteon.internal.discovery;\n+\n+import java.util.Arrays;\n+import java.util.HashSet;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.smarthome.config.discovery.AbstractDiscoveryService;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResultBuilder;\n+import org.eclipse.smarthome.config.discovery.DiscoveryService;\n+import org.eclipse.smarthome.core.thing.ThingUID;\n+import org.openhab.binding.insteon.internal.InsteonBindingConstants;\n+import org.osgi.service.component.annotations.Component;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link InsteonNetworkDiscoveryService} is responsible for device discovery.\n+ *\n+ * @author Rob Nielsen - Initial contribution\n+ */\n+@NonNullByDefault\n+@Component(service = DiscoveryService.class, immediate = true, configurationPid = \"discovery.insteon\")\n+public class InsteonNetworkDiscoveryService extends AbstractDiscoveryService {\n+    private final Logger logger = LoggerFactory.getLogger(InsteonNetworkDiscoveryService.class);\n+\n+    private static final ThingUID LOCAL_THING = new ThingUID(InsteonBindingConstants.NETWORK_THING_TYPE, \"local\");\n+\n+    private static final int DISCOVER_TIMEOUT_SECONDS = 2;\n+\n+    public InsteonNetworkDiscoveryService() {\n+        super(new HashSet<>(Arrays.asList(InsteonBindingConstants.NETWORK_THING_TYPE)), DISCOVER_TIMEOUT_SECONDS, true);\n+\n+        logger.debug(\"Initializing InsteonNetworkDiscoveryService\");\n+    }\n+\n+    @Override\n+    protected void startBackgroundDiscovery() {\n+        startScan();\n+    }\n+\n+    @Override\n+    protected void startScan() {\n+        logger.debug(\"Starting scan for Insteon network\");\n+\n+        thingDiscovered(DiscoveryResultBuilder.create(LOCAL_THING).withLabel(\"Insteon PLM or Hub\").build());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTMxNzg3MQ=="}, "originalCommit": {"oid": "04a9796d14dfbc5f3ff997d872f04b6d03ee411d"}, "originalPosition": 57}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTk4NDMxMQ==", "bodyText": "Could you please elaborate on the reason why this is needed? If you cannot determine whether it is ONLINE or OFFLINE, you should rather keep it as UNKNOWN all the time.", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r389984311", "createdAt": "2020-03-09T21:56:42Z", "author": {"login": "kaikreuzer"}, "path": "bundles/org.openhab.binding.insteon/src/main/java/org/openhab/binding/insteon/internal/handler/InsteonNetworkHandler.java", "diffHunk": "@@ -0,0 +1,148 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.insteon.internal.handler;\n+\n+import java.util.List;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseBridgeHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.openhab.binding.insteon.internal.InsteonBinding;\n+import org.openhab.binding.insteon.internal.config.InsteonNetworkConfiguration;\n+import org.openhab.binding.insteon.internal.discovery.InsteonDeviceDiscoveryService;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link InsteonNetworkHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Rob Nielsen - Initial contribution\n+ */\n+@NonNullByDefault\n+@SuppressWarnings(\"null\")\n+public class InsteonNetworkHandler extends BaseBridgeHandler {\n+\n+    private static final int LOG_DEVICE_STATISTICS_DELAY_IN_SECONDS = 600;\n+    private static final int SETTLE_TIME_IN_SECONDS = 5;\n+\n+    private final Logger logger = LoggerFactory.getLogger(InsteonNetworkHandler.class);\n+\n+    private @Nullable InsteonNetworkConfiguration config;\n+    private @Nullable InsteonBinding insteonBinding;\n+    private @Nullable InsteonDeviceDiscoveryService insteonDeviceDiscoveryService;\n+    private @Nullable ScheduledFuture<?> pollingJob = null;\n+    private @Nullable ScheduledFuture<?> settleJob = null;\n+    private long lastInsteonDeviceCreatedTimestamp = 0;\n+    private @Nullable SerialPortManager serialPortManager;\n+\n+    public static ClassLoader classLoader = Thread.currentThread().getContextClassLoader();\n+\n+    public InsteonNetworkHandler(Bridge bridge, @Nullable SerialPortManager serialPortManager) {\n+        super(bridge);\n+        this.serialPortManager = serialPortManager;\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.info(\"Starting Insteon bridge\");\n+        config = getConfigAs(InsteonNetworkConfiguration.class);\n+\n+        scheduler.execute(() -> {\n+            insteonBinding = new InsteonBinding(this, config, serialPortManager);\n+\n+            updateStatus(ThingStatus.ONLINE);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTMxODI1NA=="}, "originalCommit": {"oid": "04a9796d14dfbc5f3ff997d872f04b6d03ee411d"}, "originalPosition": 77}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTk4NjkxNA==", "bodyText": "This might lead to buggy thing definitions if e.g. a thing is created manually or textually and it isn't immediately online. Furthermore, it can cause the framework to do a lot of unnecessary work as long as the list isn't updated.\nWhat's the sense in adding everything and then removing channels? Codewise, adding the channels that exist for a specific device should be pretty much the same, shouldn't it? And it would avoid the situation where incorrect thing definitions exist.", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r389986914", "createdAt": "2020-03-09T22:02:54Z", "author": {"login": "kaikreuzer"}, "path": "bundles/org.openhab.binding.insteon/src/main/resources/ESH-INF/thing/thing-types.xml", "diffHunk": "@@ -0,0 +1,453 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"insteon\"\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\n+\t<bridge-type id=\"network\">\n+\t\t<label>Insteon Network</label>\n+\t\t<description>An Insteon PLM or hub that is used to communicate with the Insteon devices.</description>\n+\n+\t\t<config-description>\n+\t\t\t<parameter name=\"port\" type=\"text\" required=\"true\">\n+\t\t\t\t<label>Port</label>\n+\t\t\t\t<description>Configuration information that is used to connect to PLM or hub.</description>\n+\t\t\t</parameter>\n+\n+\t\t\t<parameter name=\"devicePollIntervalSeconds\" type=\"integer\" min=\"5\" max=\"3600\">\n+\t\t\t\t<label>Device Poll Interval</label>\n+\t\t\t\t<description>Device poll interval in seconds.</description>\n+\t\t\t</parameter>\n+\n+\t\t\t<parameter name=\"modemDbRetryTimeoutSeconds\" type=\"integer\" min=\"30\" max=\"600\">\n+\t\t\t\t<label>Modem DB Retry Timeout</label>\n+\t\t\t\t<description>Modem DB retry timeout in seconds.</description>\n+\t\t\t</parameter>\n+\n+\n+\t\t\t<parameter name=\"additionalDevices\" type=\"text\">\n+\t\t\t\t<label>Additional Devices</label>\n+\t\t\t\t<description>Optional file with additional device types.</description>\n+\t\t\t</parameter>\n+\n+\t\t\t<parameter name=\"additionalFeatures\" type=\"text\">\n+\t\t\t\t<label>Additional Features</label>\n+\t\t\t\t<description>Optional file with additional feature templates.</description>\n+\t\t\t</parameter>\n+\t\t</config-description>\n+\t</bridge-type>\n+\n+\t<thing-type id=\"device\">\n+\t\t<supported-bridge-type-refs>\n+\t\t\t<bridge-type-ref id=\"network\" />\n+\t\t</supported-bridge-type-refs>\n+\n+\t\t<label>Insteon Device</label>\n+\t\t<description>Insteon devices such as switches, dimmers, keypads, sensors, etc.</description>\n+\n+\t\t<channels>\n+\t\t\t<channel id=\"acDelay\" typeId=\"acDelay\" />", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTMxODU0NA=="}, "originalCommit": {"oid": "04a9796d14dfbc5f3ff997d872f04b6d03ee411d"}, "originalPosition": 49}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzcxNjQ0NDY3", "url": "https://github.com/openhab/openhab-addons/pull/6911#pullrequestreview-371644467", "createdAt": "2020-03-10T02:29:09Z", "commit": {"oid": "2438b6bca04cc38379e830e874ef9f7a54f06e72"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMFQwMjoyOTowOVrOFz_hKA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMFQwMjoyOTowOVrOFz_hKA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDA2MjM3Ng==", "bodyText": "I would move this to before the scheduler executes. It is generally expected that a call to initialize() would update the ThingStatus, even if just to UNKNOWN.", "url": "https://github.com/openhab/openhab-addons/pull/6911#discussion_r390062376", "createdAt": "2020-03-10T02:29:09Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.insteon/src/main/java/org/openhab/binding/insteon/internal/handler/InsteonNetworkHandler.java", "diffHunk": "@@ -74,7 +74,7 @@ public void initialize() {\n         scheduler.execute(() -> {\n             insteonBinding = new InsteonBinding(this, config, serialPortManager);\n \n-            updateStatus(ThingStatus.ONLINE);\n+            updateStatus(ThingStatus.UNKNOWN);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2438b6bca04cc38379e830e874ef9f7a54f06e72"}, "originalPosition": 5}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc0NzU3NDI4", "url": "https://github.com/openhab/openhab-addons/pull/6911#pullrequestreview-374757428", "createdAt": "2020-03-14T22:12:59Z", "commit": {"oid": "aee929a99e7b575a94fc540a1942c2f539e7c99a"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e848835fd1b728fd30be7024541421d28781a13c", "author": {"user": {"login": "robnielsen", "name": null}}, "url": "https://github.com/openhab/openhab-addons/commit/e848835fd1b728fd30be7024541421d28781a13c", "committedDate": "2020-03-15T20:14:55Z", "message": "[insteon] initial commit of insteon binding\n\nSigned-off-by: Rob Nielsen <rob.nielsen@yahoo.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc3MDg3MTQ2", "url": "https://github.com/openhab/openhab-addons/pull/6911#pullrequestreview-377087146", "createdAt": "2020-03-18T17:31:09Z", "commit": {"oid": "e848835fd1b728fd30be7024541421d28781a13c"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1294, "cost": 1, "resetAt": "2021-10-28T19:08:13Z"}}}