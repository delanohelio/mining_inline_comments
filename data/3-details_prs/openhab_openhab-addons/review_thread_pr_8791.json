{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTA1NDgzMTAx", "number": 8791, "reviewThreads": {"totalCount": 18, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNFQwMzo0Mjo1NlrOExdOVA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNFQyMjozOTo0OFrOExmZsw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIwMjk0NDg0OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.remoteopenhab/src/main/java/org/openhab/binding/remoteopenhab/internal/handler/RemoteopenhabThingHandler.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNFQwMzo0Mjo1NlrOHnnE_w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNFQwOToyMzoyMlrOHnq7kw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTI5Njc2Nw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    List<Item> items = new ArrayList<>();\n          \n          \n            \n                    items.add(item);\n          \n          \n            \n                    createChannels(items, false);\n          \n          \n            \n                    createChannels(List.of(item), false);", "url": "https://github.com/openhab/openhab-addons/pull/8791#discussion_r511296767", "createdAt": "2020-10-24T03:42:56Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.remoteopenhab/src/main/java/org/openhab/binding/remoteopenhab/internal/handler/RemoteopenhabThingHandler.java", "diffHunk": "@@ -0,0 +1,535 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.remoteopenhab.internal.handler;\n+\n+import static org.openhab.binding.remoteopenhab.internal.RemoteopenhabBindingConstants.BINDING_ID;\n+\n+import java.time.ZonedDateTime;\n+import java.time.format.DateTimeFormatter;\n+import java.time.format.DateTimeParseException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.ws.rs.client.ClientBuilder;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.remoteopenhab.internal.RemoteopenhabChannelTypeProvider;\n+import org.openhab.binding.remoteopenhab.internal.RemoteopenhabStateDescriptionOptionProvider;\n+import org.openhab.binding.remoteopenhab.internal.config.RemoteopenhabInstanceConfiguration;\n+import org.openhab.binding.remoteopenhab.internal.data.Item;\n+import org.openhab.binding.remoteopenhab.internal.data.Option;\n+import org.openhab.binding.remoteopenhab.internal.data.StateDescription;\n+import org.openhab.binding.remoteopenhab.internal.exceptions.RemoteopenhabException;\n+import org.openhab.binding.remoteopenhab.internal.listener.RemoteopenhabStreamingDataListener;\n+import org.openhab.binding.remoteopenhab.internal.rest.RemoteopenhabRestClient;\n+import org.openhab.core.library.CoreItemFactory;\n+import org.openhab.core.library.types.DateTimeType;\n+import org.openhab.core.library.types.DecimalType;\n+import org.openhab.core.library.types.HSBType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.OpenClosedType;\n+import org.openhab.core.library.types.PercentType;\n+import org.openhab.core.library.types.PlayPauseType;\n+import org.openhab.core.library.types.PointType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.RawType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.builder.ChannelBuilder;\n+import org.openhab.core.thing.binding.builder.ThingBuilder;\n+import org.openhab.core.thing.type.AutoUpdatePolicy;\n+import org.openhab.core.thing.type.ChannelKind;\n+import org.openhab.core.thing.type.ChannelType;\n+import org.openhab.core.thing.type.ChannelTypeBuilder;\n+import org.openhab.core.thing.type.ChannelTypeUID;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.StateOption;\n+import org.openhab.core.types.TypeParser;\n+import org.openhab.core.types.UnDefType;\n+import org.osgi.service.jaxrs.client.SseEventSourceFactory;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+\n+/**\n+ * This bridge handler connects to Nest and handles all the API requests. It pulls down the\n+ * updated data, polls the system and does all the co-ordination with the other handlers\n+ * to get the data updated to the correct things.\n+ *\n+ * @author Laurent Garnier - Initial contribution\n+ */\n+@NonNullByDefault\n+public class RemoteopenhabThingHandler extends BaseThingHandler implements RemoteopenhabStreamingDataListener {\n+\n+    private static final String DATE_FORMAT_PATTERN = \"yyyy-MM-dd'T'HH:mm:ss.SSSZ\";\n+    private static final DateTimeFormatter FORMATTER_DATE = DateTimeFormatter.ofPattern(DATE_FORMAT_PATTERN);\n+\n+    private static final long CONNECTION_TIMEOUT_MILLIS = TimeUnit.MILLISECONDS.convert(5, TimeUnit.MINUTES);\n+\n+    private final Logger logger = LoggerFactory.getLogger(RemoteopenhabThingHandler.class);\n+\n+    private final ClientBuilder clientBuilder;\n+    private final SseEventSourceFactory eventSourceFactory;\n+    private final RemoteopenhabChannelTypeProvider channelTypeProvider;\n+    private final RemoteopenhabStateDescriptionOptionProvider stateDescriptionProvider;\n+    private final Gson jsonParser;\n+\n+    private final Object updateThingLock = new Object();\n+\n+    private @NonNullByDefault({}) RemoteopenhabInstanceConfiguration config;\n+\n+    private @Nullable ScheduledFuture<?> checkConnectionJob;\n+    private @Nullable RemoteopenhabRestClient restClient;\n+\n+    public RemoteopenhabThingHandler(Thing thing, ClientBuilder clientBuilder, SseEventSourceFactory eventSourceFactory,\n+            RemoteopenhabChannelTypeProvider channelTypeProvider,\n+            RemoteopenhabStateDescriptionOptionProvider stateDescriptionProvider, final Gson jsonParser) {\n+        super(thing);\n+        this.clientBuilder = clientBuilder;\n+        this.eventSourceFactory = eventSourceFactory;\n+        this.channelTypeProvider = channelTypeProvider;\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        this.jsonParser = jsonParser;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing remote openHAB thing handler\");\n+\n+        config = getConfigAs(RemoteopenhabInstanceConfiguration.class);\n+\n+        String url = getRestUrl();\n+        if (url.length() == 0 || !url.startsWith(\"http:\")) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"Please setup a HTTP REST URL in the thing configuration\");\n+        } else {\n+            logger.debug(\"REST URL = {}\", url);\n+\n+            RemoteopenhabRestClient client = new RemoteopenhabRestClient(clientBuilder, eventSourceFactory, jsonParser,\n+                    config.token, url);\n+            restClient = client;\n+\n+            updateStatus(ThingStatus.UNKNOWN);\n+\n+            startCheckConnectionJob(client);\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.debug(\"Disposing remote openHAB thing handler\");\n+        stopStreamingUpdates();\n+        stopCheckConnectionJob();\n+        this.restClient = null;\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (getThing().getStatus() != ThingStatus.ONLINE) {\n+            return;\n+        }\n+        RemoteopenhabRestClient client = restClient;\n+        if (client == null) {\n+            return;\n+        }\n+\n+        try {\n+            if (command instanceof RefreshType) {\n+                String state = client.getRemoteItemState(channelUID.getId());\n+                updateChannelState(channelUID.getId(), null, state);\n+            } else if (isLinked(channelUID)) {\n+                client.sendCommandToRemoteItem(channelUID.getId(), command);\n+                logger.debug(\"Sending command {} to remote item {} succeeded\",\n+                        command.toFullString().length() < 50 ? command.toFullString()\n+                                : command.toFullString().substring(0, 50) + \"...\",\n+                        channelUID.getId());\n+            }\n+        } catch (RemoteopenhabException e) {\n+            logger.debug(\"{}\", e.getMessage());\n+        }\n+    }\n+\n+    private String getRestUrl() {\n+        String url = config.restUrl.trim();\n+        if (url.endsWith(\"/\")) {\n+            url = url.substring(0, url.length() - 1);\n+        }\n+        return url;\n+    }\n+\n+    private void createChannels(List<Item> items, boolean replace) {\n+        synchronized (updateThingLock) {\n+            int nbGroups = 0;\n+            List<Channel> channels = new ArrayList<>();\n+            for (Item item : items) {\n+                String itemType = item.type;\n+                if (\"Group\".equals(itemType)) {\n+                    if (item.groupType.isEmpty()) {\n+                        // Standard groups are ignored\n+                        nbGroups++;\n+                        continue;\n+                    } else {\n+                        itemType = item.groupType;\n+                    }\n+                }\n+                String channelTypeId = String.format(\"item%s\", itemType.replace(\":\", \"\"));\n+                ChannelTypeUID channelTypeUID = new ChannelTypeUID(BINDING_ID, channelTypeId);\n+                ChannelType channelType = channelTypeProvider.getChannelType(channelTypeUID, null);\n+                String label;\n+                String description;\n+                if (channelType == null) {\n+                    logger.trace(\"Create the channel type {} for item type {}\", channelTypeUID, itemType);\n+                    label = String.format(\"Remote %s Item\", itemType);\n+                    description = String.format(\"An item of type %s from the remote server.\", itemType);\n+                    channelType = ChannelTypeBuilder.state(channelTypeUID, label, itemType).withDescription(description)\n+                            .withAutoUpdatePolicy(AutoUpdatePolicy.VETO).build();\n+                    channelTypeProvider.addChannelType(channelType);\n+                }\n+                ChannelUID channelUID = new ChannelUID(getThing().getUID(), item.name);\n+                logger.trace(\"Create the channel {} of type {}\", channelUID, channelTypeUID);\n+                label = item.name;\n+                description = String.format(\"Item %s from the remote server.\", item.name);\n+                channels.add(ChannelBuilder.create(channelUID, itemType).withType(channelTypeUID)\n+                        .withKind(ChannelKind.STATE).withLabel(label).withDescription(description).build());\n+            }\n+            ThingBuilder thingBuilder = editThing();\n+            if (replace) {\n+                thingBuilder.withChannels(channels);\n+                updateThing(thingBuilder.build());\n+                logger.debug(\"{} channels defined for the thing {} (from {} items including {} groups)\",\n+                        channels.size(), getThing().getUID(), items.size(), nbGroups);\n+            } else if (channels.size() > 0) {\n+                int nbRemoved = 0;\n+                for (Channel channel : channels) {\n+                    if (getThing().getChannel(channel.getUID()) != null) {\n+                        thingBuilder.withoutChannel(channel.getUID());\n+                        nbRemoved++;\n+                    }\n+                }\n+                if (nbRemoved > 0) {\n+                    logger.debug(\"{} channels removed for the thing {} (from {} items)\", nbRemoved, getThing().getUID(),\n+                            items.size());\n+                }\n+                for (Channel channel : channels) {\n+                    thingBuilder.withChannel(channel);\n+                }\n+                updateThing(thingBuilder.build());\n+                if (nbGroups > 0) {\n+                    logger.debug(\"{} channels added for the thing {} (from {} items including {} groups)\",\n+                            channels.size(), getThing().getUID(), items.size(), nbGroups);\n+                } else {\n+                    logger.debug(\"{} channels added for the thing {} (from {} items)\", channels.size(),\n+                            getThing().getUID(), items.size());\n+                }\n+            }\n+        }\n+    }\n+\n+    private void removeChannels(List<Item> items) {\n+        synchronized (updateThingLock) {\n+            int nbRemoved = 0;\n+            ThingBuilder thingBuilder = editThing();\n+            for (Item item : items) {\n+                Channel channel = getThing().getChannel(item.name);\n+                if (channel != null) {\n+                    thingBuilder.withoutChannel(channel.getUID());\n+                    nbRemoved++;\n+                }\n+            }\n+            if (nbRemoved > 0) {\n+                updateThing(thingBuilder.build());\n+                logger.debug(\"{} channels removed for the thing {} (from {} items)\", nbRemoved, getThing().getUID(),\n+                        items.size());\n+            }\n+        }\n+    }\n+\n+    private void setStateOptions(List<Item> items) {\n+        for (Item item : items) {\n+            Channel channel = getThing().getChannel(item.name);\n+            StateDescription descr = item.stateDescription;\n+            List<Option> options = descr == null ? null : descr.options;\n+            if (channel != null && options != null && options.size() > 0) {\n+                List<StateOption> stateOptions = new ArrayList<>();\n+                for (Option option : options) {\n+                    stateOptions.add(new StateOption(option.value, option.label));\n+                }\n+                stateDescriptionProvider.setStateOptions(channel.getUID(), stateOptions);\n+                logger.trace(\"{} options set for the channel {}\", options.size(), channel.getUID());\n+            }\n+        }\n+    }\n+\n+    public void checkConnection(RemoteopenhabRestClient client) {\n+        logger.debug(\"Try the root REST API...\");\n+        try {\n+            client.tryApi();\n+            if (client.getRestApiVersion() == null) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                        \"OH 1.x server not supported by the binding\");\n+            } else {\n+                List<Item> items = client.getRemoteItems();\n+\n+                createChannels(items, true);\n+                setStateOptions(items);\n+                for (Item item : items) {\n+                    updateChannelState(item.name, null, item.state);\n+                }\n+\n+                updateStatus(ThingStatus.ONLINE);\n+\n+                restartStreamingUpdates();\n+            }\n+        } catch (RemoteopenhabException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e.getMessage());\n+            stopStreamingUpdates();\n+        }\n+    }\n+\n+    private void startCheckConnectionJob(RemoteopenhabRestClient client) {\n+        ScheduledFuture<?> localCheckConnectionJob = checkConnectionJob;\n+        if (localCheckConnectionJob == null || localCheckConnectionJob.isCancelled()) {\n+            checkConnectionJob = scheduler.scheduleWithFixedDelay(() -> {\n+                long millisSinceLastEvent = System.currentTimeMillis() - client.getLastEventTimestamp();\n+                if (millisSinceLastEvent > CONNECTION_TIMEOUT_MILLIS) {\n+                    logger.debug(\"Check: Disconnected from streaming events, millisSinceLastEvent={}\",\n+                            millisSinceLastEvent);\n+                    checkConnection(client);\n+                } else {\n+                    logger.debug(\"Check: Receiving streaming events, millisSinceLastEvent={}\", millisSinceLastEvent);\n+                }\n+            }, 0, CONNECTION_TIMEOUT_MILLIS, TimeUnit.MILLISECONDS);\n+        }\n+    }\n+\n+    private void stopCheckConnectionJob() {\n+        ScheduledFuture<?> localCheckConnectionJob = checkConnectionJob;\n+        if (localCheckConnectionJob != null) {\n+            localCheckConnectionJob.cancel(true);\n+            checkConnectionJob = null;\n+        }\n+    }\n+\n+    private void restartStreamingUpdates() {\n+        synchronized (this) {\n+            stopStreamingUpdates();\n+            startStreamingUpdates();\n+        }\n+    }\n+\n+    private void startStreamingUpdates() {\n+        RemoteopenhabRestClient client = restClient;\n+        if (client != null) {\n+            synchronized (this) {\n+                client.addStreamingDataListener(this);\n+                client.start();\n+            }\n+        }\n+    }\n+\n+    private void stopStreamingUpdates() {\n+        RemoteopenhabRestClient client = restClient;\n+        if (client != null) {\n+            synchronized (this) {\n+                client.stop();\n+                client.removeStreamingDataListener(this);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void onConnected() {\n+        updateStatus(ThingStatus.ONLINE);\n+    }\n+\n+    @Override\n+    public void onError(String message) {\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, message);\n+    }\n+\n+    @Override\n+    public void onItemStateEvent(String itemName, String stateType, String state) {\n+        updateChannelState(itemName, stateType, state);\n+    }\n+\n+    @Override\n+    public void onItemAdded(Item item) {\n+        List<Item> items = new ArrayList<>();\n+        items.add(item);\n+        createChannels(items, false);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3dc867e53fe095f9925c318f8b1963318874020d"}, "originalPosition": 381}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTM1OTg5MQ==", "bodyText": "Done", "url": "https://github.com/openhab/openhab-addons/pull/8791#discussion_r511359891", "createdAt": "2020-10-24T09:23:22Z", "author": {"login": "lolodomo"}, "path": "bundles/org.openhab.binding.remoteopenhab/src/main/java/org/openhab/binding/remoteopenhab/internal/handler/RemoteopenhabThingHandler.java", "diffHunk": "@@ -0,0 +1,535 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.remoteopenhab.internal.handler;\n+\n+import static org.openhab.binding.remoteopenhab.internal.RemoteopenhabBindingConstants.BINDING_ID;\n+\n+import java.time.ZonedDateTime;\n+import java.time.format.DateTimeFormatter;\n+import java.time.format.DateTimeParseException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.ws.rs.client.ClientBuilder;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.remoteopenhab.internal.RemoteopenhabChannelTypeProvider;\n+import org.openhab.binding.remoteopenhab.internal.RemoteopenhabStateDescriptionOptionProvider;\n+import org.openhab.binding.remoteopenhab.internal.config.RemoteopenhabInstanceConfiguration;\n+import org.openhab.binding.remoteopenhab.internal.data.Item;\n+import org.openhab.binding.remoteopenhab.internal.data.Option;\n+import org.openhab.binding.remoteopenhab.internal.data.StateDescription;\n+import org.openhab.binding.remoteopenhab.internal.exceptions.RemoteopenhabException;\n+import org.openhab.binding.remoteopenhab.internal.listener.RemoteopenhabStreamingDataListener;\n+import org.openhab.binding.remoteopenhab.internal.rest.RemoteopenhabRestClient;\n+import org.openhab.core.library.CoreItemFactory;\n+import org.openhab.core.library.types.DateTimeType;\n+import org.openhab.core.library.types.DecimalType;\n+import org.openhab.core.library.types.HSBType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.OpenClosedType;\n+import org.openhab.core.library.types.PercentType;\n+import org.openhab.core.library.types.PlayPauseType;\n+import org.openhab.core.library.types.PointType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.RawType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.builder.ChannelBuilder;\n+import org.openhab.core.thing.binding.builder.ThingBuilder;\n+import org.openhab.core.thing.type.AutoUpdatePolicy;\n+import org.openhab.core.thing.type.ChannelKind;\n+import org.openhab.core.thing.type.ChannelType;\n+import org.openhab.core.thing.type.ChannelTypeBuilder;\n+import org.openhab.core.thing.type.ChannelTypeUID;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.StateOption;\n+import org.openhab.core.types.TypeParser;\n+import org.openhab.core.types.UnDefType;\n+import org.osgi.service.jaxrs.client.SseEventSourceFactory;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+\n+/**\n+ * This bridge handler connects to Nest and handles all the API requests. It pulls down the\n+ * updated data, polls the system and does all the co-ordination with the other handlers\n+ * to get the data updated to the correct things.\n+ *\n+ * @author Laurent Garnier - Initial contribution\n+ */\n+@NonNullByDefault\n+public class RemoteopenhabThingHandler extends BaseThingHandler implements RemoteopenhabStreamingDataListener {\n+\n+    private static final String DATE_FORMAT_PATTERN = \"yyyy-MM-dd'T'HH:mm:ss.SSSZ\";\n+    private static final DateTimeFormatter FORMATTER_DATE = DateTimeFormatter.ofPattern(DATE_FORMAT_PATTERN);\n+\n+    private static final long CONNECTION_TIMEOUT_MILLIS = TimeUnit.MILLISECONDS.convert(5, TimeUnit.MINUTES);\n+\n+    private final Logger logger = LoggerFactory.getLogger(RemoteopenhabThingHandler.class);\n+\n+    private final ClientBuilder clientBuilder;\n+    private final SseEventSourceFactory eventSourceFactory;\n+    private final RemoteopenhabChannelTypeProvider channelTypeProvider;\n+    private final RemoteopenhabStateDescriptionOptionProvider stateDescriptionProvider;\n+    private final Gson jsonParser;\n+\n+    private final Object updateThingLock = new Object();\n+\n+    private @NonNullByDefault({}) RemoteopenhabInstanceConfiguration config;\n+\n+    private @Nullable ScheduledFuture<?> checkConnectionJob;\n+    private @Nullable RemoteopenhabRestClient restClient;\n+\n+    public RemoteopenhabThingHandler(Thing thing, ClientBuilder clientBuilder, SseEventSourceFactory eventSourceFactory,\n+            RemoteopenhabChannelTypeProvider channelTypeProvider,\n+            RemoteopenhabStateDescriptionOptionProvider stateDescriptionProvider, final Gson jsonParser) {\n+        super(thing);\n+        this.clientBuilder = clientBuilder;\n+        this.eventSourceFactory = eventSourceFactory;\n+        this.channelTypeProvider = channelTypeProvider;\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        this.jsonParser = jsonParser;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing remote openHAB thing handler\");\n+\n+        config = getConfigAs(RemoteopenhabInstanceConfiguration.class);\n+\n+        String url = getRestUrl();\n+        if (url.length() == 0 || !url.startsWith(\"http:\")) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"Please setup a HTTP REST URL in the thing configuration\");\n+        } else {\n+            logger.debug(\"REST URL = {}\", url);\n+\n+            RemoteopenhabRestClient client = new RemoteopenhabRestClient(clientBuilder, eventSourceFactory, jsonParser,\n+                    config.token, url);\n+            restClient = client;\n+\n+            updateStatus(ThingStatus.UNKNOWN);\n+\n+            startCheckConnectionJob(client);\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.debug(\"Disposing remote openHAB thing handler\");\n+        stopStreamingUpdates();\n+        stopCheckConnectionJob();\n+        this.restClient = null;\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (getThing().getStatus() != ThingStatus.ONLINE) {\n+            return;\n+        }\n+        RemoteopenhabRestClient client = restClient;\n+        if (client == null) {\n+            return;\n+        }\n+\n+        try {\n+            if (command instanceof RefreshType) {\n+                String state = client.getRemoteItemState(channelUID.getId());\n+                updateChannelState(channelUID.getId(), null, state);\n+            } else if (isLinked(channelUID)) {\n+                client.sendCommandToRemoteItem(channelUID.getId(), command);\n+                logger.debug(\"Sending command {} to remote item {} succeeded\",\n+                        command.toFullString().length() < 50 ? command.toFullString()\n+                                : command.toFullString().substring(0, 50) + \"...\",\n+                        channelUID.getId());\n+            }\n+        } catch (RemoteopenhabException e) {\n+            logger.debug(\"{}\", e.getMessage());\n+        }\n+    }\n+\n+    private String getRestUrl() {\n+        String url = config.restUrl.trim();\n+        if (url.endsWith(\"/\")) {\n+            url = url.substring(0, url.length() - 1);\n+        }\n+        return url;\n+    }\n+\n+    private void createChannels(List<Item> items, boolean replace) {\n+        synchronized (updateThingLock) {\n+            int nbGroups = 0;\n+            List<Channel> channels = new ArrayList<>();\n+            for (Item item : items) {\n+                String itemType = item.type;\n+                if (\"Group\".equals(itemType)) {\n+                    if (item.groupType.isEmpty()) {\n+                        // Standard groups are ignored\n+                        nbGroups++;\n+                        continue;\n+                    } else {\n+                        itemType = item.groupType;\n+                    }\n+                }\n+                String channelTypeId = String.format(\"item%s\", itemType.replace(\":\", \"\"));\n+                ChannelTypeUID channelTypeUID = new ChannelTypeUID(BINDING_ID, channelTypeId);\n+                ChannelType channelType = channelTypeProvider.getChannelType(channelTypeUID, null);\n+                String label;\n+                String description;\n+                if (channelType == null) {\n+                    logger.trace(\"Create the channel type {} for item type {}\", channelTypeUID, itemType);\n+                    label = String.format(\"Remote %s Item\", itemType);\n+                    description = String.format(\"An item of type %s from the remote server.\", itemType);\n+                    channelType = ChannelTypeBuilder.state(channelTypeUID, label, itemType).withDescription(description)\n+                            .withAutoUpdatePolicy(AutoUpdatePolicy.VETO).build();\n+                    channelTypeProvider.addChannelType(channelType);\n+                }\n+                ChannelUID channelUID = new ChannelUID(getThing().getUID(), item.name);\n+                logger.trace(\"Create the channel {} of type {}\", channelUID, channelTypeUID);\n+                label = item.name;\n+                description = String.format(\"Item %s from the remote server.\", item.name);\n+                channels.add(ChannelBuilder.create(channelUID, itemType).withType(channelTypeUID)\n+                        .withKind(ChannelKind.STATE).withLabel(label).withDescription(description).build());\n+            }\n+            ThingBuilder thingBuilder = editThing();\n+            if (replace) {\n+                thingBuilder.withChannels(channels);\n+                updateThing(thingBuilder.build());\n+                logger.debug(\"{} channels defined for the thing {} (from {} items including {} groups)\",\n+                        channels.size(), getThing().getUID(), items.size(), nbGroups);\n+            } else if (channels.size() > 0) {\n+                int nbRemoved = 0;\n+                for (Channel channel : channels) {\n+                    if (getThing().getChannel(channel.getUID()) != null) {\n+                        thingBuilder.withoutChannel(channel.getUID());\n+                        nbRemoved++;\n+                    }\n+                }\n+                if (nbRemoved > 0) {\n+                    logger.debug(\"{} channels removed for the thing {} (from {} items)\", nbRemoved, getThing().getUID(),\n+                            items.size());\n+                }\n+                for (Channel channel : channels) {\n+                    thingBuilder.withChannel(channel);\n+                }\n+                updateThing(thingBuilder.build());\n+                if (nbGroups > 0) {\n+                    logger.debug(\"{} channels added for the thing {} (from {} items including {} groups)\",\n+                            channels.size(), getThing().getUID(), items.size(), nbGroups);\n+                } else {\n+                    logger.debug(\"{} channels added for the thing {} (from {} items)\", channels.size(),\n+                            getThing().getUID(), items.size());\n+                }\n+            }\n+        }\n+    }\n+\n+    private void removeChannels(List<Item> items) {\n+        synchronized (updateThingLock) {\n+            int nbRemoved = 0;\n+            ThingBuilder thingBuilder = editThing();\n+            for (Item item : items) {\n+                Channel channel = getThing().getChannel(item.name);\n+                if (channel != null) {\n+                    thingBuilder.withoutChannel(channel.getUID());\n+                    nbRemoved++;\n+                }\n+            }\n+            if (nbRemoved > 0) {\n+                updateThing(thingBuilder.build());\n+                logger.debug(\"{} channels removed for the thing {} (from {} items)\", nbRemoved, getThing().getUID(),\n+                        items.size());\n+            }\n+        }\n+    }\n+\n+    private void setStateOptions(List<Item> items) {\n+        for (Item item : items) {\n+            Channel channel = getThing().getChannel(item.name);\n+            StateDescription descr = item.stateDescription;\n+            List<Option> options = descr == null ? null : descr.options;\n+            if (channel != null && options != null && options.size() > 0) {\n+                List<StateOption> stateOptions = new ArrayList<>();\n+                for (Option option : options) {\n+                    stateOptions.add(new StateOption(option.value, option.label));\n+                }\n+                stateDescriptionProvider.setStateOptions(channel.getUID(), stateOptions);\n+                logger.trace(\"{} options set for the channel {}\", options.size(), channel.getUID());\n+            }\n+        }\n+    }\n+\n+    public void checkConnection(RemoteopenhabRestClient client) {\n+        logger.debug(\"Try the root REST API...\");\n+        try {\n+            client.tryApi();\n+            if (client.getRestApiVersion() == null) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                        \"OH 1.x server not supported by the binding\");\n+            } else {\n+                List<Item> items = client.getRemoteItems();\n+\n+                createChannels(items, true);\n+                setStateOptions(items);\n+                for (Item item : items) {\n+                    updateChannelState(item.name, null, item.state);\n+                }\n+\n+                updateStatus(ThingStatus.ONLINE);\n+\n+                restartStreamingUpdates();\n+            }\n+        } catch (RemoteopenhabException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e.getMessage());\n+            stopStreamingUpdates();\n+        }\n+    }\n+\n+    private void startCheckConnectionJob(RemoteopenhabRestClient client) {\n+        ScheduledFuture<?> localCheckConnectionJob = checkConnectionJob;\n+        if (localCheckConnectionJob == null || localCheckConnectionJob.isCancelled()) {\n+            checkConnectionJob = scheduler.scheduleWithFixedDelay(() -> {\n+                long millisSinceLastEvent = System.currentTimeMillis() - client.getLastEventTimestamp();\n+                if (millisSinceLastEvent > CONNECTION_TIMEOUT_MILLIS) {\n+                    logger.debug(\"Check: Disconnected from streaming events, millisSinceLastEvent={}\",\n+                            millisSinceLastEvent);\n+                    checkConnection(client);\n+                } else {\n+                    logger.debug(\"Check: Receiving streaming events, millisSinceLastEvent={}\", millisSinceLastEvent);\n+                }\n+            }, 0, CONNECTION_TIMEOUT_MILLIS, TimeUnit.MILLISECONDS);\n+        }\n+    }\n+\n+    private void stopCheckConnectionJob() {\n+        ScheduledFuture<?> localCheckConnectionJob = checkConnectionJob;\n+        if (localCheckConnectionJob != null) {\n+            localCheckConnectionJob.cancel(true);\n+            checkConnectionJob = null;\n+        }\n+    }\n+\n+    private void restartStreamingUpdates() {\n+        synchronized (this) {\n+            stopStreamingUpdates();\n+            startStreamingUpdates();\n+        }\n+    }\n+\n+    private void startStreamingUpdates() {\n+        RemoteopenhabRestClient client = restClient;\n+        if (client != null) {\n+            synchronized (this) {\n+                client.addStreamingDataListener(this);\n+                client.start();\n+            }\n+        }\n+    }\n+\n+    private void stopStreamingUpdates() {\n+        RemoteopenhabRestClient client = restClient;\n+        if (client != null) {\n+            synchronized (this) {\n+                client.stop();\n+                client.removeStreamingDataListener(this);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void onConnected() {\n+        updateStatus(ThingStatus.ONLINE);\n+    }\n+\n+    @Override\n+    public void onError(String message) {\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, message);\n+    }\n+\n+    @Override\n+    public void onItemStateEvent(String itemName, String stateType, String state) {\n+        updateChannelState(itemName, stateType, state);\n+    }\n+\n+    @Override\n+    public void onItemAdded(Item item) {\n+        List<Item> items = new ArrayList<>();\n+        items.add(item);\n+        createChannels(items, false);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTI5Njc2Nw=="}, "originalCommit": {"oid": "3dc867e53fe095f9925c318f8b1963318874020d"}, "originalPosition": 381}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIwMjk0NTI4OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.remoteopenhab/src/main/java/org/openhab/binding/remoteopenhab/internal/handler/RemoteopenhabThingHandler.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNFQwMzo0MzoxMVrOHnnFSw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNFQwOToyMzoxMVrOHnq7Tw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTI5Njg0Mw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    List<Item> items = new ArrayList<>();\n          \n          \n            \n                    items.add(item);\n          \n          \n            \n                    removeChannels(items);\n          \n          \n            \n                    removeChannels(List.of(item));", "url": "https://github.com/openhab/openhab-addons/pull/8791#discussion_r511296843", "createdAt": "2020-10-24T03:43:11Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.remoteopenhab/src/main/java/org/openhab/binding/remoteopenhab/internal/handler/RemoteopenhabThingHandler.java", "diffHunk": "@@ -0,0 +1,535 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.remoteopenhab.internal.handler;\n+\n+import static org.openhab.binding.remoteopenhab.internal.RemoteopenhabBindingConstants.BINDING_ID;\n+\n+import java.time.ZonedDateTime;\n+import java.time.format.DateTimeFormatter;\n+import java.time.format.DateTimeParseException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.ws.rs.client.ClientBuilder;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.remoteopenhab.internal.RemoteopenhabChannelTypeProvider;\n+import org.openhab.binding.remoteopenhab.internal.RemoteopenhabStateDescriptionOptionProvider;\n+import org.openhab.binding.remoteopenhab.internal.config.RemoteopenhabInstanceConfiguration;\n+import org.openhab.binding.remoteopenhab.internal.data.Item;\n+import org.openhab.binding.remoteopenhab.internal.data.Option;\n+import org.openhab.binding.remoteopenhab.internal.data.StateDescription;\n+import org.openhab.binding.remoteopenhab.internal.exceptions.RemoteopenhabException;\n+import org.openhab.binding.remoteopenhab.internal.listener.RemoteopenhabStreamingDataListener;\n+import org.openhab.binding.remoteopenhab.internal.rest.RemoteopenhabRestClient;\n+import org.openhab.core.library.CoreItemFactory;\n+import org.openhab.core.library.types.DateTimeType;\n+import org.openhab.core.library.types.DecimalType;\n+import org.openhab.core.library.types.HSBType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.OpenClosedType;\n+import org.openhab.core.library.types.PercentType;\n+import org.openhab.core.library.types.PlayPauseType;\n+import org.openhab.core.library.types.PointType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.RawType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.builder.ChannelBuilder;\n+import org.openhab.core.thing.binding.builder.ThingBuilder;\n+import org.openhab.core.thing.type.AutoUpdatePolicy;\n+import org.openhab.core.thing.type.ChannelKind;\n+import org.openhab.core.thing.type.ChannelType;\n+import org.openhab.core.thing.type.ChannelTypeBuilder;\n+import org.openhab.core.thing.type.ChannelTypeUID;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.StateOption;\n+import org.openhab.core.types.TypeParser;\n+import org.openhab.core.types.UnDefType;\n+import org.osgi.service.jaxrs.client.SseEventSourceFactory;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+\n+/**\n+ * This bridge handler connects to Nest and handles all the API requests. It pulls down the\n+ * updated data, polls the system and does all the co-ordination with the other handlers\n+ * to get the data updated to the correct things.\n+ *\n+ * @author Laurent Garnier - Initial contribution\n+ */\n+@NonNullByDefault\n+public class RemoteopenhabThingHandler extends BaseThingHandler implements RemoteopenhabStreamingDataListener {\n+\n+    private static final String DATE_FORMAT_PATTERN = \"yyyy-MM-dd'T'HH:mm:ss.SSSZ\";\n+    private static final DateTimeFormatter FORMATTER_DATE = DateTimeFormatter.ofPattern(DATE_FORMAT_PATTERN);\n+\n+    private static final long CONNECTION_TIMEOUT_MILLIS = TimeUnit.MILLISECONDS.convert(5, TimeUnit.MINUTES);\n+\n+    private final Logger logger = LoggerFactory.getLogger(RemoteopenhabThingHandler.class);\n+\n+    private final ClientBuilder clientBuilder;\n+    private final SseEventSourceFactory eventSourceFactory;\n+    private final RemoteopenhabChannelTypeProvider channelTypeProvider;\n+    private final RemoteopenhabStateDescriptionOptionProvider stateDescriptionProvider;\n+    private final Gson jsonParser;\n+\n+    private final Object updateThingLock = new Object();\n+\n+    private @NonNullByDefault({}) RemoteopenhabInstanceConfiguration config;\n+\n+    private @Nullable ScheduledFuture<?> checkConnectionJob;\n+    private @Nullable RemoteopenhabRestClient restClient;\n+\n+    public RemoteopenhabThingHandler(Thing thing, ClientBuilder clientBuilder, SseEventSourceFactory eventSourceFactory,\n+            RemoteopenhabChannelTypeProvider channelTypeProvider,\n+            RemoteopenhabStateDescriptionOptionProvider stateDescriptionProvider, final Gson jsonParser) {\n+        super(thing);\n+        this.clientBuilder = clientBuilder;\n+        this.eventSourceFactory = eventSourceFactory;\n+        this.channelTypeProvider = channelTypeProvider;\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        this.jsonParser = jsonParser;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing remote openHAB thing handler\");\n+\n+        config = getConfigAs(RemoteopenhabInstanceConfiguration.class);\n+\n+        String url = getRestUrl();\n+        if (url.length() == 0 || !url.startsWith(\"http:\")) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"Please setup a HTTP REST URL in the thing configuration\");\n+        } else {\n+            logger.debug(\"REST URL = {}\", url);\n+\n+            RemoteopenhabRestClient client = new RemoteopenhabRestClient(clientBuilder, eventSourceFactory, jsonParser,\n+                    config.token, url);\n+            restClient = client;\n+\n+            updateStatus(ThingStatus.UNKNOWN);\n+\n+            startCheckConnectionJob(client);\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.debug(\"Disposing remote openHAB thing handler\");\n+        stopStreamingUpdates();\n+        stopCheckConnectionJob();\n+        this.restClient = null;\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (getThing().getStatus() != ThingStatus.ONLINE) {\n+            return;\n+        }\n+        RemoteopenhabRestClient client = restClient;\n+        if (client == null) {\n+            return;\n+        }\n+\n+        try {\n+            if (command instanceof RefreshType) {\n+                String state = client.getRemoteItemState(channelUID.getId());\n+                updateChannelState(channelUID.getId(), null, state);\n+            } else if (isLinked(channelUID)) {\n+                client.sendCommandToRemoteItem(channelUID.getId(), command);\n+                logger.debug(\"Sending command {} to remote item {} succeeded\",\n+                        command.toFullString().length() < 50 ? command.toFullString()\n+                                : command.toFullString().substring(0, 50) + \"...\",\n+                        channelUID.getId());\n+            }\n+        } catch (RemoteopenhabException e) {\n+            logger.debug(\"{}\", e.getMessage());\n+        }\n+    }\n+\n+    private String getRestUrl() {\n+        String url = config.restUrl.trim();\n+        if (url.endsWith(\"/\")) {\n+            url = url.substring(0, url.length() - 1);\n+        }\n+        return url;\n+    }\n+\n+    private void createChannels(List<Item> items, boolean replace) {\n+        synchronized (updateThingLock) {\n+            int nbGroups = 0;\n+            List<Channel> channels = new ArrayList<>();\n+            for (Item item : items) {\n+                String itemType = item.type;\n+                if (\"Group\".equals(itemType)) {\n+                    if (item.groupType.isEmpty()) {\n+                        // Standard groups are ignored\n+                        nbGroups++;\n+                        continue;\n+                    } else {\n+                        itemType = item.groupType;\n+                    }\n+                }\n+                String channelTypeId = String.format(\"item%s\", itemType.replace(\":\", \"\"));\n+                ChannelTypeUID channelTypeUID = new ChannelTypeUID(BINDING_ID, channelTypeId);\n+                ChannelType channelType = channelTypeProvider.getChannelType(channelTypeUID, null);\n+                String label;\n+                String description;\n+                if (channelType == null) {\n+                    logger.trace(\"Create the channel type {} for item type {}\", channelTypeUID, itemType);\n+                    label = String.format(\"Remote %s Item\", itemType);\n+                    description = String.format(\"An item of type %s from the remote server.\", itemType);\n+                    channelType = ChannelTypeBuilder.state(channelTypeUID, label, itemType).withDescription(description)\n+                            .withAutoUpdatePolicy(AutoUpdatePolicy.VETO).build();\n+                    channelTypeProvider.addChannelType(channelType);\n+                }\n+                ChannelUID channelUID = new ChannelUID(getThing().getUID(), item.name);\n+                logger.trace(\"Create the channel {} of type {}\", channelUID, channelTypeUID);\n+                label = item.name;\n+                description = String.format(\"Item %s from the remote server.\", item.name);\n+                channels.add(ChannelBuilder.create(channelUID, itemType).withType(channelTypeUID)\n+                        .withKind(ChannelKind.STATE).withLabel(label).withDescription(description).build());\n+            }\n+            ThingBuilder thingBuilder = editThing();\n+            if (replace) {\n+                thingBuilder.withChannels(channels);\n+                updateThing(thingBuilder.build());\n+                logger.debug(\"{} channels defined for the thing {} (from {} items including {} groups)\",\n+                        channels.size(), getThing().getUID(), items.size(), nbGroups);\n+            } else if (channels.size() > 0) {\n+                int nbRemoved = 0;\n+                for (Channel channel : channels) {\n+                    if (getThing().getChannel(channel.getUID()) != null) {\n+                        thingBuilder.withoutChannel(channel.getUID());\n+                        nbRemoved++;\n+                    }\n+                }\n+                if (nbRemoved > 0) {\n+                    logger.debug(\"{} channels removed for the thing {} (from {} items)\", nbRemoved, getThing().getUID(),\n+                            items.size());\n+                }\n+                for (Channel channel : channels) {\n+                    thingBuilder.withChannel(channel);\n+                }\n+                updateThing(thingBuilder.build());\n+                if (nbGroups > 0) {\n+                    logger.debug(\"{} channels added for the thing {} (from {} items including {} groups)\",\n+                            channels.size(), getThing().getUID(), items.size(), nbGroups);\n+                } else {\n+                    logger.debug(\"{} channels added for the thing {} (from {} items)\", channels.size(),\n+                            getThing().getUID(), items.size());\n+                }\n+            }\n+        }\n+    }\n+\n+    private void removeChannels(List<Item> items) {\n+        synchronized (updateThingLock) {\n+            int nbRemoved = 0;\n+            ThingBuilder thingBuilder = editThing();\n+            for (Item item : items) {\n+                Channel channel = getThing().getChannel(item.name);\n+                if (channel != null) {\n+                    thingBuilder.withoutChannel(channel.getUID());\n+                    nbRemoved++;\n+                }\n+            }\n+            if (nbRemoved > 0) {\n+                updateThing(thingBuilder.build());\n+                logger.debug(\"{} channels removed for the thing {} (from {} items)\", nbRemoved, getThing().getUID(),\n+                        items.size());\n+            }\n+        }\n+    }\n+\n+    private void setStateOptions(List<Item> items) {\n+        for (Item item : items) {\n+            Channel channel = getThing().getChannel(item.name);\n+            StateDescription descr = item.stateDescription;\n+            List<Option> options = descr == null ? null : descr.options;\n+            if (channel != null && options != null && options.size() > 0) {\n+                List<StateOption> stateOptions = new ArrayList<>();\n+                for (Option option : options) {\n+                    stateOptions.add(new StateOption(option.value, option.label));\n+                }\n+                stateDescriptionProvider.setStateOptions(channel.getUID(), stateOptions);\n+                logger.trace(\"{} options set for the channel {}\", options.size(), channel.getUID());\n+            }\n+        }\n+    }\n+\n+    public void checkConnection(RemoteopenhabRestClient client) {\n+        logger.debug(\"Try the root REST API...\");\n+        try {\n+            client.tryApi();\n+            if (client.getRestApiVersion() == null) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                        \"OH 1.x server not supported by the binding\");\n+            } else {\n+                List<Item> items = client.getRemoteItems();\n+\n+                createChannels(items, true);\n+                setStateOptions(items);\n+                for (Item item : items) {\n+                    updateChannelState(item.name, null, item.state);\n+                }\n+\n+                updateStatus(ThingStatus.ONLINE);\n+\n+                restartStreamingUpdates();\n+            }\n+        } catch (RemoteopenhabException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e.getMessage());\n+            stopStreamingUpdates();\n+        }\n+    }\n+\n+    private void startCheckConnectionJob(RemoteopenhabRestClient client) {\n+        ScheduledFuture<?> localCheckConnectionJob = checkConnectionJob;\n+        if (localCheckConnectionJob == null || localCheckConnectionJob.isCancelled()) {\n+            checkConnectionJob = scheduler.scheduleWithFixedDelay(() -> {\n+                long millisSinceLastEvent = System.currentTimeMillis() - client.getLastEventTimestamp();\n+                if (millisSinceLastEvent > CONNECTION_TIMEOUT_MILLIS) {\n+                    logger.debug(\"Check: Disconnected from streaming events, millisSinceLastEvent={}\",\n+                            millisSinceLastEvent);\n+                    checkConnection(client);\n+                } else {\n+                    logger.debug(\"Check: Receiving streaming events, millisSinceLastEvent={}\", millisSinceLastEvent);\n+                }\n+            }, 0, CONNECTION_TIMEOUT_MILLIS, TimeUnit.MILLISECONDS);\n+        }\n+    }\n+\n+    private void stopCheckConnectionJob() {\n+        ScheduledFuture<?> localCheckConnectionJob = checkConnectionJob;\n+        if (localCheckConnectionJob != null) {\n+            localCheckConnectionJob.cancel(true);\n+            checkConnectionJob = null;\n+        }\n+    }\n+\n+    private void restartStreamingUpdates() {\n+        synchronized (this) {\n+            stopStreamingUpdates();\n+            startStreamingUpdates();\n+        }\n+    }\n+\n+    private void startStreamingUpdates() {\n+        RemoteopenhabRestClient client = restClient;\n+        if (client != null) {\n+            synchronized (this) {\n+                client.addStreamingDataListener(this);\n+                client.start();\n+            }\n+        }\n+    }\n+\n+    private void stopStreamingUpdates() {\n+        RemoteopenhabRestClient client = restClient;\n+        if (client != null) {\n+            synchronized (this) {\n+                client.stop();\n+                client.removeStreamingDataListener(this);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void onConnected() {\n+        updateStatus(ThingStatus.ONLINE);\n+    }\n+\n+    @Override\n+    public void onError(String message) {\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, message);\n+    }\n+\n+    @Override\n+    public void onItemStateEvent(String itemName, String stateType, String state) {\n+        updateChannelState(itemName, stateType, state);\n+    }\n+\n+    @Override\n+    public void onItemAdded(Item item) {\n+        List<Item> items = new ArrayList<>();\n+        items.add(item);\n+        createChannels(items, false);\n+    }\n+\n+    @Override\n+    public void onItemRemoved(Item item) {\n+        List<Item> items = new ArrayList<>();\n+        items.add(item);\n+        removeChannels(items);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3dc867e53fe095f9925c318f8b1963318874020d"}, "originalPosition": 388}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTM1OTgyMw==", "bodyText": "Done", "url": "https://github.com/openhab/openhab-addons/pull/8791#discussion_r511359823", "createdAt": "2020-10-24T09:23:11Z", "author": {"login": "lolodomo"}, "path": "bundles/org.openhab.binding.remoteopenhab/src/main/java/org/openhab/binding/remoteopenhab/internal/handler/RemoteopenhabThingHandler.java", "diffHunk": "@@ -0,0 +1,535 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.remoteopenhab.internal.handler;\n+\n+import static org.openhab.binding.remoteopenhab.internal.RemoteopenhabBindingConstants.BINDING_ID;\n+\n+import java.time.ZonedDateTime;\n+import java.time.format.DateTimeFormatter;\n+import java.time.format.DateTimeParseException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.ws.rs.client.ClientBuilder;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.remoteopenhab.internal.RemoteopenhabChannelTypeProvider;\n+import org.openhab.binding.remoteopenhab.internal.RemoteopenhabStateDescriptionOptionProvider;\n+import org.openhab.binding.remoteopenhab.internal.config.RemoteopenhabInstanceConfiguration;\n+import org.openhab.binding.remoteopenhab.internal.data.Item;\n+import org.openhab.binding.remoteopenhab.internal.data.Option;\n+import org.openhab.binding.remoteopenhab.internal.data.StateDescription;\n+import org.openhab.binding.remoteopenhab.internal.exceptions.RemoteopenhabException;\n+import org.openhab.binding.remoteopenhab.internal.listener.RemoteopenhabStreamingDataListener;\n+import org.openhab.binding.remoteopenhab.internal.rest.RemoteopenhabRestClient;\n+import org.openhab.core.library.CoreItemFactory;\n+import org.openhab.core.library.types.DateTimeType;\n+import org.openhab.core.library.types.DecimalType;\n+import org.openhab.core.library.types.HSBType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.OpenClosedType;\n+import org.openhab.core.library.types.PercentType;\n+import org.openhab.core.library.types.PlayPauseType;\n+import org.openhab.core.library.types.PointType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.RawType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.builder.ChannelBuilder;\n+import org.openhab.core.thing.binding.builder.ThingBuilder;\n+import org.openhab.core.thing.type.AutoUpdatePolicy;\n+import org.openhab.core.thing.type.ChannelKind;\n+import org.openhab.core.thing.type.ChannelType;\n+import org.openhab.core.thing.type.ChannelTypeBuilder;\n+import org.openhab.core.thing.type.ChannelTypeUID;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.StateOption;\n+import org.openhab.core.types.TypeParser;\n+import org.openhab.core.types.UnDefType;\n+import org.osgi.service.jaxrs.client.SseEventSourceFactory;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+\n+/**\n+ * This bridge handler connects to Nest and handles all the API requests. It pulls down the\n+ * updated data, polls the system and does all the co-ordination with the other handlers\n+ * to get the data updated to the correct things.\n+ *\n+ * @author Laurent Garnier - Initial contribution\n+ */\n+@NonNullByDefault\n+public class RemoteopenhabThingHandler extends BaseThingHandler implements RemoteopenhabStreamingDataListener {\n+\n+    private static final String DATE_FORMAT_PATTERN = \"yyyy-MM-dd'T'HH:mm:ss.SSSZ\";\n+    private static final DateTimeFormatter FORMATTER_DATE = DateTimeFormatter.ofPattern(DATE_FORMAT_PATTERN);\n+\n+    private static final long CONNECTION_TIMEOUT_MILLIS = TimeUnit.MILLISECONDS.convert(5, TimeUnit.MINUTES);\n+\n+    private final Logger logger = LoggerFactory.getLogger(RemoteopenhabThingHandler.class);\n+\n+    private final ClientBuilder clientBuilder;\n+    private final SseEventSourceFactory eventSourceFactory;\n+    private final RemoteopenhabChannelTypeProvider channelTypeProvider;\n+    private final RemoteopenhabStateDescriptionOptionProvider stateDescriptionProvider;\n+    private final Gson jsonParser;\n+\n+    private final Object updateThingLock = new Object();\n+\n+    private @NonNullByDefault({}) RemoteopenhabInstanceConfiguration config;\n+\n+    private @Nullable ScheduledFuture<?> checkConnectionJob;\n+    private @Nullable RemoteopenhabRestClient restClient;\n+\n+    public RemoteopenhabThingHandler(Thing thing, ClientBuilder clientBuilder, SseEventSourceFactory eventSourceFactory,\n+            RemoteopenhabChannelTypeProvider channelTypeProvider,\n+            RemoteopenhabStateDescriptionOptionProvider stateDescriptionProvider, final Gson jsonParser) {\n+        super(thing);\n+        this.clientBuilder = clientBuilder;\n+        this.eventSourceFactory = eventSourceFactory;\n+        this.channelTypeProvider = channelTypeProvider;\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        this.jsonParser = jsonParser;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing remote openHAB thing handler\");\n+\n+        config = getConfigAs(RemoteopenhabInstanceConfiguration.class);\n+\n+        String url = getRestUrl();\n+        if (url.length() == 0 || !url.startsWith(\"http:\")) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"Please setup a HTTP REST URL in the thing configuration\");\n+        } else {\n+            logger.debug(\"REST URL = {}\", url);\n+\n+            RemoteopenhabRestClient client = new RemoteopenhabRestClient(clientBuilder, eventSourceFactory, jsonParser,\n+                    config.token, url);\n+            restClient = client;\n+\n+            updateStatus(ThingStatus.UNKNOWN);\n+\n+            startCheckConnectionJob(client);\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.debug(\"Disposing remote openHAB thing handler\");\n+        stopStreamingUpdates();\n+        stopCheckConnectionJob();\n+        this.restClient = null;\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (getThing().getStatus() != ThingStatus.ONLINE) {\n+            return;\n+        }\n+        RemoteopenhabRestClient client = restClient;\n+        if (client == null) {\n+            return;\n+        }\n+\n+        try {\n+            if (command instanceof RefreshType) {\n+                String state = client.getRemoteItemState(channelUID.getId());\n+                updateChannelState(channelUID.getId(), null, state);\n+            } else if (isLinked(channelUID)) {\n+                client.sendCommandToRemoteItem(channelUID.getId(), command);\n+                logger.debug(\"Sending command {} to remote item {} succeeded\",\n+                        command.toFullString().length() < 50 ? command.toFullString()\n+                                : command.toFullString().substring(0, 50) + \"...\",\n+                        channelUID.getId());\n+            }\n+        } catch (RemoteopenhabException e) {\n+            logger.debug(\"{}\", e.getMessage());\n+        }\n+    }\n+\n+    private String getRestUrl() {\n+        String url = config.restUrl.trim();\n+        if (url.endsWith(\"/\")) {\n+            url = url.substring(0, url.length() - 1);\n+        }\n+        return url;\n+    }\n+\n+    private void createChannels(List<Item> items, boolean replace) {\n+        synchronized (updateThingLock) {\n+            int nbGroups = 0;\n+            List<Channel> channels = new ArrayList<>();\n+            for (Item item : items) {\n+                String itemType = item.type;\n+                if (\"Group\".equals(itemType)) {\n+                    if (item.groupType.isEmpty()) {\n+                        // Standard groups are ignored\n+                        nbGroups++;\n+                        continue;\n+                    } else {\n+                        itemType = item.groupType;\n+                    }\n+                }\n+                String channelTypeId = String.format(\"item%s\", itemType.replace(\":\", \"\"));\n+                ChannelTypeUID channelTypeUID = new ChannelTypeUID(BINDING_ID, channelTypeId);\n+                ChannelType channelType = channelTypeProvider.getChannelType(channelTypeUID, null);\n+                String label;\n+                String description;\n+                if (channelType == null) {\n+                    logger.trace(\"Create the channel type {} for item type {}\", channelTypeUID, itemType);\n+                    label = String.format(\"Remote %s Item\", itemType);\n+                    description = String.format(\"An item of type %s from the remote server.\", itemType);\n+                    channelType = ChannelTypeBuilder.state(channelTypeUID, label, itemType).withDescription(description)\n+                            .withAutoUpdatePolicy(AutoUpdatePolicy.VETO).build();\n+                    channelTypeProvider.addChannelType(channelType);\n+                }\n+                ChannelUID channelUID = new ChannelUID(getThing().getUID(), item.name);\n+                logger.trace(\"Create the channel {} of type {}\", channelUID, channelTypeUID);\n+                label = item.name;\n+                description = String.format(\"Item %s from the remote server.\", item.name);\n+                channels.add(ChannelBuilder.create(channelUID, itemType).withType(channelTypeUID)\n+                        .withKind(ChannelKind.STATE).withLabel(label).withDescription(description).build());\n+            }\n+            ThingBuilder thingBuilder = editThing();\n+            if (replace) {\n+                thingBuilder.withChannels(channels);\n+                updateThing(thingBuilder.build());\n+                logger.debug(\"{} channels defined for the thing {} (from {} items including {} groups)\",\n+                        channels.size(), getThing().getUID(), items.size(), nbGroups);\n+            } else if (channels.size() > 0) {\n+                int nbRemoved = 0;\n+                for (Channel channel : channels) {\n+                    if (getThing().getChannel(channel.getUID()) != null) {\n+                        thingBuilder.withoutChannel(channel.getUID());\n+                        nbRemoved++;\n+                    }\n+                }\n+                if (nbRemoved > 0) {\n+                    logger.debug(\"{} channels removed for the thing {} (from {} items)\", nbRemoved, getThing().getUID(),\n+                            items.size());\n+                }\n+                for (Channel channel : channels) {\n+                    thingBuilder.withChannel(channel);\n+                }\n+                updateThing(thingBuilder.build());\n+                if (nbGroups > 0) {\n+                    logger.debug(\"{} channels added for the thing {} (from {} items including {} groups)\",\n+                            channels.size(), getThing().getUID(), items.size(), nbGroups);\n+                } else {\n+                    logger.debug(\"{} channels added for the thing {} (from {} items)\", channels.size(),\n+                            getThing().getUID(), items.size());\n+                }\n+            }\n+        }\n+    }\n+\n+    private void removeChannels(List<Item> items) {\n+        synchronized (updateThingLock) {\n+            int nbRemoved = 0;\n+            ThingBuilder thingBuilder = editThing();\n+            for (Item item : items) {\n+                Channel channel = getThing().getChannel(item.name);\n+                if (channel != null) {\n+                    thingBuilder.withoutChannel(channel.getUID());\n+                    nbRemoved++;\n+                }\n+            }\n+            if (nbRemoved > 0) {\n+                updateThing(thingBuilder.build());\n+                logger.debug(\"{} channels removed for the thing {} (from {} items)\", nbRemoved, getThing().getUID(),\n+                        items.size());\n+            }\n+        }\n+    }\n+\n+    private void setStateOptions(List<Item> items) {\n+        for (Item item : items) {\n+            Channel channel = getThing().getChannel(item.name);\n+            StateDescription descr = item.stateDescription;\n+            List<Option> options = descr == null ? null : descr.options;\n+            if (channel != null && options != null && options.size() > 0) {\n+                List<StateOption> stateOptions = new ArrayList<>();\n+                for (Option option : options) {\n+                    stateOptions.add(new StateOption(option.value, option.label));\n+                }\n+                stateDescriptionProvider.setStateOptions(channel.getUID(), stateOptions);\n+                logger.trace(\"{} options set for the channel {}\", options.size(), channel.getUID());\n+            }\n+        }\n+    }\n+\n+    public void checkConnection(RemoteopenhabRestClient client) {\n+        logger.debug(\"Try the root REST API...\");\n+        try {\n+            client.tryApi();\n+            if (client.getRestApiVersion() == null) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                        \"OH 1.x server not supported by the binding\");\n+            } else {\n+                List<Item> items = client.getRemoteItems();\n+\n+                createChannels(items, true);\n+                setStateOptions(items);\n+                for (Item item : items) {\n+                    updateChannelState(item.name, null, item.state);\n+                }\n+\n+                updateStatus(ThingStatus.ONLINE);\n+\n+                restartStreamingUpdates();\n+            }\n+        } catch (RemoteopenhabException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e.getMessage());\n+            stopStreamingUpdates();\n+        }\n+    }\n+\n+    private void startCheckConnectionJob(RemoteopenhabRestClient client) {\n+        ScheduledFuture<?> localCheckConnectionJob = checkConnectionJob;\n+        if (localCheckConnectionJob == null || localCheckConnectionJob.isCancelled()) {\n+            checkConnectionJob = scheduler.scheduleWithFixedDelay(() -> {\n+                long millisSinceLastEvent = System.currentTimeMillis() - client.getLastEventTimestamp();\n+                if (millisSinceLastEvent > CONNECTION_TIMEOUT_MILLIS) {\n+                    logger.debug(\"Check: Disconnected from streaming events, millisSinceLastEvent={}\",\n+                            millisSinceLastEvent);\n+                    checkConnection(client);\n+                } else {\n+                    logger.debug(\"Check: Receiving streaming events, millisSinceLastEvent={}\", millisSinceLastEvent);\n+                }\n+            }, 0, CONNECTION_TIMEOUT_MILLIS, TimeUnit.MILLISECONDS);\n+        }\n+    }\n+\n+    private void stopCheckConnectionJob() {\n+        ScheduledFuture<?> localCheckConnectionJob = checkConnectionJob;\n+        if (localCheckConnectionJob != null) {\n+            localCheckConnectionJob.cancel(true);\n+            checkConnectionJob = null;\n+        }\n+    }\n+\n+    private void restartStreamingUpdates() {\n+        synchronized (this) {\n+            stopStreamingUpdates();\n+            startStreamingUpdates();\n+        }\n+    }\n+\n+    private void startStreamingUpdates() {\n+        RemoteopenhabRestClient client = restClient;\n+        if (client != null) {\n+            synchronized (this) {\n+                client.addStreamingDataListener(this);\n+                client.start();\n+            }\n+        }\n+    }\n+\n+    private void stopStreamingUpdates() {\n+        RemoteopenhabRestClient client = restClient;\n+        if (client != null) {\n+            synchronized (this) {\n+                client.stop();\n+                client.removeStreamingDataListener(this);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void onConnected() {\n+        updateStatus(ThingStatus.ONLINE);\n+    }\n+\n+    @Override\n+    public void onError(String message) {\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, message);\n+    }\n+\n+    @Override\n+    public void onItemStateEvent(String itemName, String stateType, String state) {\n+        updateChannelState(itemName, stateType, state);\n+    }\n+\n+    @Override\n+    public void onItemAdded(Item item) {\n+        List<Item> items = new ArrayList<>();\n+        items.add(item);\n+        createChannels(items, false);\n+    }\n+\n+    @Override\n+    public void onItemRemoved(Item item) {\n+        List<Item> items = new ArrayList<>();\n+        items.add(item);\n+        removeChannels(items);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTI5Njg0Mw=="}, "originalCommit": {"oid": "3dc867e53fe095f9925c318f8b1963318874020d"}, "originalPosition": 388}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIwMjk2NTU5OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.remoteopenhab/src/main/java/org/openhab/binding/remoteopenhab/internal/handler/RemoteopenhabThingHandler.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNFQwMzo1MzowNVrOHnnSng==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNFQxODo0NDowNFrOHnzl5w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTMwMDI1NA==", "bodyText": "In this circumstance it would be better to synchronize on the client itself rather than 'this'.\nAlso it seems wasteful to remove and re-add yourself as a listener every time you restart the client so I've adjusted the restartStreamingUpdates code accordingly.\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private void restartStreamingUpdates() {\n          \n          \n            \n                    synchronized (this) {\n          \n          \n            \n                        stopStreamingUpdates();\n          \n          \n            \n                        startStreamingUpdates();\n          \n          \n            \n                    }\n          \n          \n            \n                }\n          \n          \n            \n            \n          \n          \n            \n                private void startStreamingUpdates() {\n          \n          \n            \n                    RemoteopenhabRestClient client = restClient;\n          \n          \n            \n                    if (client != null) {\n          \n          \n            \n                        synchronized (this) {\n          \n          \n            \n                            client.addStreamingDataListener(this);\n          \n          \n            \n                            client.start();\n          \n          \n            \n                        }\n          \n          \n            \n                    }\n          \n          \n            \n                }\n          \n          \n            \n            \n          \n          \n            \n                private void stopStreamingUpdates() {\n          \n          \n            \n                    RemoteopenhabRestClient client = restClient;\n          \n          \n            \n                    if (client != null) {\n          \n          \n            \n                        synchronized (this) {\n          \n          \n            \n                            client.stop();\n          \n          \n            \n                            client.removeStreamingDataListener(this);\n          \n          \n            \n                        }\n          \n          \n            \n                    }\n          \n          \n            \n                }\n          \n          \n            \n                private void restartStreamingUpdates() {\n          \n          \n            \n                    RemoteopenhabRestClient client = restClient;\n          \n          \n            \n                    if (client != null) {\n          \n          \n            \n                        synchronized(client){\n          \n          \n            \n                            client.stop();\n          \n          \n            \n                            client.start();\n          \n          \n            \n                        }\n          \n          \n            \n                    }\n          \n          \n            \n                }\n          \n          \n            \n            \n          \n          \n            \n                private void startStreamingUpdates() {\n          \n          \n            \n                    RemoteopenhabRestClient client = restClient;\n          \n          \n            \n                    if (client != null) {\n          \n          \n            \n                        synchronized (client) {\n          \n          \n            \n                            client.addStreamingDataListener(this);\n          \n          \n            \n                            client.start();\n          \n          \n            \n                        }\n          \n          \n            \n                    }\n          \n          \n            \n                }\n          \n          \n            \n            \n          \n          \n            \n                private void stopStreamingUpdates() {\n          \n          \n            \n                    RemoteopenhabRestClient client = restClient;\n          \n          \n            \n                    if (client != null) {\n          \n          \n            \n                        synchronized (client) {\n          \n          \n            \n                            client.stop();\n          \n          \n            \n                            client.removeStreamingDataListener(this);\n          \n          \n            \n                        }\n          \n          \n            \n                    }\n          \n          \n            \n                }", "url": "https://github.com/openhab/openhab-addons/pull/8791#discussion_r511300254", "createdAt": "2020-10-24T03:53:05Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.remoteopenhab/src/main/java/org/openhab/binding/remoteopenhab/internal/handler/RemoteopenhabThingHandler.java", "diffHunk": "@@ -0,0 +1,535 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.remoteopenhab.internal.handler;\n+\n+import static org.openhab.binding.remoteopenhab.internal.RemoteopenhabBindingConstants.BINDING_ID;\n+\n+import java.time.ZonedDateTime;\n+import java.time.format.DateTimeFormatter;\n+import java.time.format.DateTimeParseException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.ws.rs.client.ClientBuilder;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.remoteopenhab.internal.RemoteopenhabChannelTypeProvider;\n+import org.openhab.binding.remoteopenhab.internal.RemoteopenhabStateDescriptionOptionProvider;\n+import org.openhab.binding.remoteopenhab.internal.config.RemoteopenhabInstanceConfiguration;\n+import org.openhab.binding.remoteopenhab.internal.data.Item;\n+import org.openhab.binding.remoteopenhab.internal.data.Option;\n+import org.openhab.binding.remoteopenhab.internal.data.StateDescription;\n+import org.openhab.binding.remoteopenhab.internal.exceptions.RemoteopenhabException;\n+import org.openhab.binding.remoteopenhab.internal.listener.RemoteopenhabStreamingDataListener;\n+import org.openhab.binding.remoteopenhab.internal.rest.RemoteopenhabRestClient;\n+import org.openhab.core.library.CoreItemFactory;\n+import org.openhab.core.library.types.DateTimeType;\n+import org.openhab.core.library.types.DecimalType;\n+import org.openhab.core.library.types.HSBType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.OpenClosedType;\n+import org.openhab.core.library.types.PercentType;\n+import org.openhab.core.library.types.PlayPauseType;\n+import org.openhab.core.library.types.PointType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.RawType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.builder.ChannelBuilder;\n+import org.openhab.core.thing.binding.builder.ThingBuilder;\n+import org.openhab.core.thing.type.AutoUpdatePolicy;\n+import org.openhab.core.thing.type.ChannelKind;\n+import org.openhab.core.thing.type.ChannelType;\n+import org.openhab.core.thing.type.ChannelTypeBuilder;\n+import org.openhab.core.thing.type.ChannelTypeUID;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.StateOption;\n+import org.openhab.core.types.TypeParser;\n+import org.openhab.core.types.UnDefType;\n+import org.osgi.service.jaxrs.client.SseEventSourceFactory;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+\n+/**\n+ * This bridge handler connects to Nest and handles all the API requests. It pulls down the\n+ * updated data, polls the system and does all the co-ordination with the other handlers\n+ * to get the data updated to the correct things.\n+ *\n+ * @author Laurent Garnier - Initial contribution\n+ */\n+@NonNullByDefault\n+public class RemoteopenhabThingHandler extends BaseThingHandler implements RemoteopenhabStreamingDataListener {\n+\n+    private static final String DATE_FORMAT_PATTERN = \"yyyy-MM-dd'T'HH:mm:ss.SSSZ\";\n+    private static final DateTimeFormatter FORMATTER_DATE = DateTimeFormatter.ofPattern(DATE_FORMAT_PATTERN);\n+\n+    private static final long CONNECTION_TIMEOUT_MILLIS = TimeUnit.MILLISECONDS.convert(5, TimeUnit.MINUTES);\n+\n+    private final Logger logger = LoggerFactory.getLogger(RemoteopenhabThingHandler.class);\n+\n+    private final ClientBuilder clientBuilder;\n+    private final SseEventSourceFactory eventSourceFactory;\n+    private final RemoteopenhabChannelTypeProvider channelTypeProvider;\n+    private final RemoteopenhabStateDescriptionOptionProvider stateDescriptionProvider;\n+    private final Gson jsonParser;\n+\n+    private final Object updateThingLock = new Object();\n+\n+    private @NonNullByDefault({}) RemoteopenhabInstanceConfiguration config;\n+\n+    private @Nullable ScheduledFuture<?> checkConnectionJob;\n+    private @Nullable RemoteopenhabRestClient restClient;\n+\n+    public RemoteopenhabThingHandler(Thing thing, ClientBuilder clientBuilder, SseEventSourceFactory eventSourceFactory,\n+            RemoteopenhabChannelTypeProvider channelTypeProvider,\n+            RemoteopenhabStateDescriptionOptionProvider stateDescriptionProvider, final Gson jsonParser) {\n+        super(thing);\n+        this.clientBuilder = clientBuilder;\n+        this.eventSourceFactory = eventSourceFactory;\n+        this.channelTypeProvider = channelTypeProvider;\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        this.jsonParser = jsonParser;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing remote openHAB thing handler\");\n+\n+        config = getConfigAs(RemoteopenhabInstanceConfiguration.class);\n+\n+        String url = getRestUrl();\n+        if (url.length() == 0 || !url.startsWith(\"http:\")) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"Please setup a HTTP REST URL in the thing configuration\");\n+        } else {\n+            logger.debug(\"REST URL = {}\", url);\n+\n+            RemoteopenhabRestClient client = new RemoteopenhabRestClient(clientBuilder, eventSourceFactory, jsonParser,\n+                    config.token, url);\n+            restClient = client;\n+\n+            updateStatus(ThingStatus.UNKNOWN);\n+\n+            startCheckConnectionJob(client);\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.debug(\"Disposing remote openHAB thing handler\");\n+        stopStreamingUpdates();\n+        stopCheckConnectionJob();\n+        this.restClient = null;\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (getThing().getStatus() != ThingStatus.ONLINE) {\n+            return;\n+        }\n+        RemoteopenhabRestClient client = restClient;\n+        if (client == null) {\n+            return;\n+        }\n+\n+        try {\n+            if (command instanceof RefreshType) {\n+                String state = client.getRemoteItemState(channelUID.getId());\n+                updateChannelState(channelUID.getId(), null, state);\n+            } else if (isLinked(channelUID)) {\n+                client.sendCommandToRemoteItem(channelUID.getId(), command);\n+                logger.debug(\"Sending command {} to remote item {} succeeded\",\n+                        command.toFullString().length() < 50 ? command.toFullString()\n+                                : command.toFullString().substring(0, 50) + \"...\",\n+                        channelUID.getId());\n+            }\n+        } catch (RemoteopenhabException e) {\n+            logger.debug(\"{}\", e.getMessage());\n+        }\n+    }\n+\n+    private String getRestUrl() {\n+        String url = config.restUrl.trim();\n+        if (url.endsWith(\"/\")) {\n+            url = url.substring(0, url.length() - 1);\n+        }\n+        return url;\n+    }\n+\n+    private void createChannels(List<Item> items, boolean replace) {\n+        synchronized (updateThingLock) {\n+            int nbGroups = 0;\n+            List<Channel> channels = new ArrayList<>();\n+            for (Item item : items) {\n+                String itemType = item.type;\n+                if (\"Group\".equals(itemType)) {\n+                    if (item.groupType.isEmpty()) {\n+                        // Standard groups are ignored\n+                        nbGroups++;\n+                        continue;\n+                    } else {\n+                        itemType = item.groupType;\n+                    }\n+                }\n+                String channelTypeId = String.format(\"item%s\", itemType.replace(\":\", \"\"));\n+                ChannelTypeUID channelTypeUID = new ChannelTypeUID(BINDING_ID, channelTypeId);\n+                ChannelType channelType = channelTypeProvider.getChannelType(channelTypeUID, null);\n+                String label;\n+                String description;\n+                if (channelType == null) {\n+                    logger.trace(\"Create the channel type {} for item type {}\", channelTypeUID, itemType);\n+                    label = String.format(\"Remote %s Item\", itemType);\n+                    description = String.format(\"An item of type %s from the remote server.\", itemType);\n+                    channelType = ChannelTypeBuilder.state(channelTypeUID, label, itemType).withDescription(description)\n+                            .withAutoUpdatePolicy(AutoUpdatePolicy.VETO).build();\n+                    channelTypeProvider.addChannelType(channelType);\n+                }\n+                ChannelUID channelUID = new ChannelUID(getThing().getUID(), item.name);\n+                logger.trace(\"Create the channel {} of type {}\", channelUID, channelTypeUID);\n+                label = item.name;\n+                description = String.format(\"Item %s from the remote server.\", item.name);\n+                channels.add(ChannelBuilder.create(channelUID, itemType).withType(channelTypeUID)\n+                        .withKind(ChannelKind.STATE).withLabel(label).withDescription(description).build());\n+            }\n+            ThingBuilder thingBuilder = editThing();\n+            if (replace) {\n+                thingBuilder.withChannels(channels);\n+                updateThing(thingBuilder.build());\n+                logger.debug(\"{} channels defined for the thing {} (from {} items including {} groups)\",\n+                        channels.size(), getThing().getUID(), items.size(), nbGroups);\n+            } else if (channels.size() > 0) {\n+                int nbRemoved = 0;\n+                for (Channel channel : channels) {\n+                    if (getThing().getChannel(channel.getUID()) != null) {\n+                        thingBuilder.withoutChannel(channel.getUID());\n+                        nbRemoved++;\n+                    }\n+                }\n+                if (nbRemoved > 0) {\n+                    logger.debug(\"{} channels removed for the thing {} (from {} items)\", nbRemoved, getThing().getUID(),\n+                            items.size());\n+                }\n+                for (Channel channel : channels) {\n+                    thingBuilder.withChannel(channel);\n+                }\n+                updateThing(thingBuilder.build());\n+                if (nbGroups > 0) {\n+                    logger.debug(\"{} channels added for the thing {} (from {} items including {} groups)\",\n+                            channels.size(), getThing().getUID(), items.size(), nbGroups);\n+                } else {\n+                    logger.debug(\"{} channels added for the thing {} (from {} items)\", channels.size(),\n+                            getThing().getUID(), items.size());\n+                }\n+            }\n+        }\n+    }\n+\n+    private void removeChannels(List<Item> items) {\n+        synchronized (updateThingLock) {\n+            int nbRemoved = 0;\n+            ThingBuilder thingBuilder = editThing();\n+            for (Item item : items) {\n+                Channel channel = getThing().getChannel(item.name);\n+                if (channel != null) {\n+                    thingBuilder.withoutChannel(channel.getUID());\n+                    nbRemoved++;\n+                }\n+            }\n+            if (nbRemoved > 0) {\n+                updateThing(thingBuilder.build());\n+                logger.debug(\"{} channels removed for the thing {} (from {} items)\", nbRemoved, getThing().getUID(),\n+                        items.size());\n+            }\n+        }\n+    }\n+\n+    private void setStateOptions(List<Item> items) {\n+        for (Item item : items) {\n+            Channel channel = getThing().getChannel(item.name);\n+            StateDescription descr = item.stateDescription;\n+            List<Option> options = descr == null ? null : descr.options;\n+            if (channel != null && options != null && options.size() > 0) {\n+                List<StateOption> stateOptions = new ArrayList<>();\n+                for (Option option : options) {\n+                    stateOptions.add(new StateOption(option.value, option.label));\n+                }\n+                stateDescriptionProvider.setStateOptions(channel.getUID(), stateOptions);\n+                logger.trace(\"{} options set for the channel {}\", options.size(), channel.getUID());\n+            }\n+        }\n+    }\n+\n+    public void checkConnection(RemoteopenhabRestClient client) {\n+        logger.debug(\"Try the root REST API...\");\n+        try {\n+            client.tryApi();\n+            if (client.getRestApiVersion() == null) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                        \"OH 1.x server not supported by the binding\");\n+            } else {\n+                List<Item> items = client.getRemoteItems();\n+\n+                createChannels(items, true);\n+                setStateOptions(items);\n+                for (Item item : items) {\n+                    updateChannelState(item.name, null, item.state);\n+                }\n+\n+                updateStatus(ThingStatus.ONLINE);\n+\n+                restartStreamingUpdates();\n+            }\n+        } catch (RemoteopenhabException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e.getMessage());\n+            stopStreamingUpdates();\n+        }\n+    }\n+\n+    private void startCheckConnectionJob(RemoteopenhabRestClient client) {\n+        ScheduledFuture<?> localCheckConnectionJob = checkConnectionJob;\n+        if (localCheckConnectionJob == null || localCheckConnectionJob.isCancelled()) {\n+            checkConnectionJob = scheduler.scheduleWithFixedDelay(() -> {\n+                long millisSinceLastEvent = System.currentTimeMillis() - client.getLastEventTimestamp();\n+                if (millisSinceLastEvent > CONNECTION_TIMEOUT_MILLIS) {\n+                    logger.debug(\"Check: Disconnected from streaming events, millisSinceLastEvent={}\",\n+                            millisSinceLastEvent);\n+                    checkConnection(client);\n+                } else {\n+                    logger.debug(\"Check: Receiving streaming events, millisSinceLastEvent={}\", millisSinceLastEvent);\n+                }\n+            }, 0, CONNECTION_TIMEOUT_MILLIS, TimeUnit.MILLISECONDS);\n+        }\n+    }\n+\n+    private void stopCheckConnectionJob() {\n+        ScheduledFuture<?> localCheckConnectionJob = checkConnectionJob;\n+        if (localCheckConnectionJob != null) {\n+            localCheckConnectionJob.cancel(true);\n+            checkConnectionJob = null;\n+        }\n+    }\n+\n+    private void restartStreamingUpdates() {\n+        synchronized (this) {\n+            stopStreamingUpdates();\n+            startStreamingUpdates();\n+        }\n+    }\n+\n+    private void startStreamingUpdates() {\n+        RemoteopenhabRestClient client = restClient;\n+        if (client != null) {\n+            synchronized (this) {\n+                client.addStreamingDataListener(this);\n+                client.start();\n+            }\n+        }\n+    }\n+\n+    private void stopStreamingUpdates() {\n+        RemoteopenhabRestClient client = restClient;\n+        if (client != null) {\n+            synchronized (this) {\n+                client.stop();\n+                client.removeStreamingDataListener(this);\n+            }\n+        }\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3dc867e53fe095f9925c318f8b1963318874020d"}, "originalPosition": 360}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTM0OTIzNg==", "bodyText": "Ok for the synchronized on the client.\nRegarding adding and removing the thing handler as listener, the idea is to be sure to not handle events coming from SSE after you d\u00e9cided to stop it. I prefer to keep this unchanged.", "url": "https://github.com/openhab/openhab-addons/pull/8791#discussion_r511349236", "createdAt": "2020-10-24T08:58:24Z", "author": {"login": "lolodomo"}, "path": "bundles/org.openhab.binding.remoteopenhab/src/main/java/org/openhab/binding/remoteopenhab/internal/handler/RemoteopenhabThingHandler.java", "diffHunk": "@@ -0,0 +1,535 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.remoteopenhab.internal.handler;\n+\n+import static org.openhab.binding.remoteopenhab.internal.RemoteopenhabBindingConstants.BINDING_ID;\n+\n+import java.time.ZonedDateTime;\n+import java.time.format.DateTimeFormatter;\n+import java.time.format.DateTimeParseException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.ws.rs.client.ClientBuilder;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.remoteopenhab.internal.RemoteopenhabChannelTypeProvider;\n+import org.openhab.binding.remoteopenhab.internal.RemoteopenhabStateDescriptionOptionProvider;\n+import org.openhab.binding.remoteopenhab.internal.config.RemoteopenhabInstanceConfiguration;\n+import org.openhab.binding.remoteopenhab.internal.data.Item;\n+import org.openhab.binding.remoteopenhab.internal.data.Option;\n+import org.openhab.binding.remoteopenhab.internal.data.StateDescription;\n+import org.openhab.binding.remoteopenhab.internal.exceptions.RemoteopenhabException;\n+import org.openhab.binding.remoteopenhab.internal.listener.RemoteopenhabStreamingDataListener;\n+import org.openhab.binding.remoteopenhab.internal.rest.RemoteopenhabRestClient;\n+import org.openhab.core.library.CoreItemFactory;\n+import org.openhab.core.library.types.DateTimeType;\n+import org.openhab.core.library.types.DecimalType;\n+import org.openhab.core.library.types.HSBType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.OpenClosedType;\n+import org.openhab.core.library.types.PercentType;\n+import org.openhab.core.library.types.PlayPauseType;\n+import org.openhab.core.library.types.PointType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.RawType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.builder.ChannelBuilder;\n+import org.openhab.core.thing.binding.builder.ThingBuilder;\n+import org.openhab.core.thing.type.AutoUpdatePolicy;\n+import org.openhab.core.thing.type.ChannelKind;\n+import org.openhab.core.thing.type.ChannelType;\n+import org.openhab.core.thing.type.ChannelTypeBuilder;\n+import org.openhab.core.thing.type.ChannelTypeUID;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.StateOption;\n+import org.openhab.core.types.TypeParser;\n+import org.openhab.core.types.UnDefType;\n+import org.osgi.service.jaxrs.client.SseEventSourceFactory;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+\n+/**\n+ * This bridge handler connects to Nest and handles all the API requests. It pulls down the\n+ * updated data, polls the system and does all the co-ordination with the other handlers\n+ * to get the data updated to the correct things.\n+ *\n+ * @author Laurent Garnier - Initial contribution\n+ */\n+@NonNullByDefault\n+public class RemoteopenhabThingHandler extends BaseThingHandler implements RemoteopenhabStreamingDataListener {\n+\n+    private static final String DATE_FORMAT_PATTERN = \"yyyy-MM-dd'T'HH:mm:ss.SSSZ\";\n+    private static final DateTimeFormatter FORMATTER_DATE = DateTimeFormatter.ofPattern(DATE_FORMAT_PATTERN);\n+\n+    private static final long CONNECTION_TIMEOUT_MILLIS = TimeUnit.MILLISECONDS.convert(5, TimeUnit.MINUTES);\n+\n+    private final Logger logger = LoggerFactory.getLogger(RemoteopenhabThingHandler.class);\n+\n+    private final ClientBuilder clientBuilder;\n+    private final SseEventSourceFactory eventSourceFactory;\n+    private final RemoteopenhabChannelTypeProvider channelTypeProvider;\n+    private final RemoteopenhabStateDescriptionOptionProvider stateDescriptionProvider;\n+    private final Gson jsonParser;\n+\n+    private final Object updateThingLock = new Object();\n+\n+    private @NonNullByDefault({}) RemoteopenhabInstanceConfiguration config;\n+\n+    private @Nullable ScheduledFuture<?> checkConnectionJob;\n+    private @Nullable RemoteopenhabRestClient restClient;\n+\n+    public RemoteopenhabThingHandler(Thing thing, ClientBuilder clientBuilder, SseEventSourceFactory eventSourceFactory,\n+            RemoteopenhabChannelTypeProvider channelTypeProvider,\n+            RemoteopenhabStateDescriptionOptionProvider stateDescriptionProvider, final Gson jsonParser) {\n+        super(thing);\n+        this.clientBuilder = clientBuilder;\n+        this.eventSourceFactory = eventSourceFactory;\n+        this.channelTypeProvider = channelTypeProvider;\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        this.jsonParser = jsonParser;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing remote openHAB thing handler\");\n+\n+        config = getConfigAs(RemoteopenhabInstanceConfiguration.class);\n+\n+        String url = getRestUrl();\n+        if (url.length() == 0 || !url.startsWith(\"http:\")) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"Please setup a HTTP REST URL in the thing configuration\");\n+        } else {\n+            logger.debug(\"REST URL = {}\", url);\n+\n+            RemoteopenhabRestClient client = new RemoteopenhabRestClient(clientBuilder, eventSourceFactory, jsonParser,\n+                    config.token, url);\n+            restClient = client;\n+\n+            updateStatus(ThingStatus.UNKNOWN);\n+\n+            startCheckConnectionJob(client);\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.debug(\"Disposing remote openHAB thing handler\");\n+        stopStreamingUpdates();\n+        stopCheckConnectionJob();\n+        this.restClient = null;\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (getThing().getStatus() != ThingStatus.ONLINE) {\n+            return;\n+        }\n+        RemoteopenhabRestClient client = restClient;\n+        if (client == null) {\n+            return;\n+        }\n+\n+        try {\n+            if (command instanceof RefreshType) {\n+                String state = client.getRemoteItemState(channelUID.getId());\n+                updateChannelState(channelUID.getId(), null, state);\n+            } else if (isLinked(channelUID)) {\n+                client.sendCommandToRemoteItem(channelUID.getId(), command);\n+                logger.debug(\"Sending command {} to remote item {} succeeded\",\n+                        command.toFullString().length() < 50 ? command.toFullString()\n+                                : command.toFullString().substring(0, 50) + \"...\",\n+                        channelUID.getId());\n+            }\n+        } catch (RemoteopenhabException e) {\n+            logger.debug(\"{}\", e.getMessage());\n+        }\n+    }\n+\n+    private String getRestUrl() {\n+        String url = config.restUrl.trim();\n+        if (url.endsWith(\"/\")) {\n+            url = url.substring(0, url.length() - 1);\n+        }\n+        return url;\n+    }\n+\n+    private void createChannels(List<Item> items, boolean replace) {\n+        synchronized (updateThingLock) {\n+            int nbGroups = 0;\n+            List<Channel> channels = new ArrayList<>();\n+            for (Item item : items) {\n+                String itemType = item.type;\n+                if (\"Group\".equals(itemType)) {\n+                    if (item.groupType.isEmpty()) {\n+                        // Standard groups are ignored\n+                        nbGroups++;\n+                        continue;\n+                    } else {\n+                        itemType = item.groupType;\n+                    }\n+                }\n+                String channelTypeId = String.format(\"item%s\", itemType.replace(\":\", \"\"));\n+                ChannelTypeUID channelTypeUID = new ChannelTypeUID(BINDING_ID, channelTypeId);\n+                ChannelType channelType = channelTypeProvider.getChannelType(channelTypeUID, null);\n+                String label;\n+                String description;\n+                if (channelType == null) {\n+                    logger.trace(\"Create the channel type {} for item type {}\", channelTypeUID, itemType);\n+                    label = String.format(\"Remote %s Item\", itemType);\n+                    description = String.format(\"An item of type %s from the remote server.\", itemType);\n+                    channelType = ChannelTypeBuilder.state(channelTypeUID, label, itemType).withDescription(description)\n+                            .withAutoUpdatePolicy(AutoUpdatePolicy.VETO).build();\n+                    channelTypeProvider.addChannelType(channelType);\n+                }\n+                ChannelUID channelUID = new ChannelUID(getThing().getUID(), item.name);\n+                logger.trace(\"Create the channel {} of type {}\", channelUID, channelTypeUID);\n+                label = item.name;\n+                description = String.format(\"Item %s from the remote server.\", item.name);\n+                channels.add(ChannelBuilder.create(channelUID, itemType).withType(channelTypeUID)\n+                        .withKind(ChannelKind.STATE).withLabel(label).withDescription(description).build());\n+            }\n+            ThingBuilder thingBuilder = editThing();\n+            if (replace) {\n+                thingBuilder.withChannels(channels);\n+                updateThing(thingBuilder.build());\n+                logger.debug(\"{} channels defined for the thing {} (from {} items including {} groups)\",\n+                        channels.size(), getThing().getUID(), items.size(), nbGroups);\n+            } else if (channels.size() > 0) {\n+                int nbRemoved = 0;\n+                for (Channel channel : channels) {\n+                    if (getThing().getChannel(channel.getUID()) != null) {\n+                        thingBuilder.withoutChannel(channel.getUID());\n+                        nbRemoved++;\n+                    }\n+                }\n+                if (nbRemoved > 0) {\n+                    logger.debug(\"{} channels removed for the thing {} (from {} items)\", nbRemoved, getThing().getUID(),\n+                            items.size());\n+                }\n+                for (Channel channel : channels) {\n+                    thingBuilder.withChannel(channel);\n+                }\n+                updateThing(thingBuilder.build());\n+                if (nbGroups > 0) {\n+                    logger.debug(\"{} channels added for the thing {} (from {} items including {} groups)\",\n+                            channels.size(), getThing().getUID(), items.size(), nbGroups);\n+                } else {\n+                    logger.debug(\"{} channels added for the thing {} (from {} items)\", channels.size(),\n+                            getThing().getUID(), items.size());\n+                }\n+            }\n+        }\n+    }\n+\n+    private void removeChannels(List<Item> items) {\n+        synchronized (updateThingLock) {\n+            int nbRemoved = 0;\n+            ThingBuilder thingBuilder = editThing();\n+            for (Item item : items) {\n+                Channel channel = getThing().getChannel(item.name);\n+                if (channel != null) {\n+                    thingBuilder.withoutChannel(channel.getUID());\n+                    nbRemoved++;\n+                }\n+            }\n+            if (nbRemoved > 0) {\n+                updateThing(thingBuilder.build());\n+                logger.debug(\"{} channels removed for the thing {} (from {} items)\", nbRemoved, getThing().getUID(),\n+                        items.size());\n+            }\n+        }\n+    }\n+\n+    private void setStateOptions(List<Item> items) {\n+        for (Item item : items) {\n+            Channel channel = getThing().getChannel(item.name);\n+            StateDescription descr = item.stateDescription;\n+            List<Option> options = descr == null ? null : descr.options;\n+            if (channel != null && options != null && options.size() > 0) {\n+                List<StateOption> stateOptions = new ArrayList<>();\n+                for (Option option : options) {\n+                    stateOptions.add(new StateOption(option.value, option.label));\n+                }\n+                stateDescriptionProvider.setStateOptions(channel.getUID(), stateOptions);\n+                logger.trace(\"{} options set for the channel {}\", options.size(), channel.getUID());\n+            }\n+        }\n+    }\n+\n+    public void checkConnection(RemoteopenhabRestClient client) {\n+        logger.debug(\"Try the root REST API...\");\n+        try {\n+            client.tryApi();\n+            if (client.getRestApiVersion() == null) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                        \"OH 1.x server not supported by the binding\");\n+            } else {\n+                List<Item> items = client.getRemoteItems();\n+\n+                createChannels(items, true);\n+                setStateOptions(items);\n+                for (Item item : items) {\n+                    updateChannelState(item.name, null, item.state);\n+                }\n+\n+                updateStatus(ThingStatus.ONLINE);\n+\n+                restartStreamingUpdates();\n+            }\n+        } catch (RemoteopenhabException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e.getMessage());\n+            stopStreamingUpdates();\n+        }\n+    }\n+\n+    private void startCheckConnectionJob(RemoteopenhabRestClient client) {\n+        ScheduledFuture<?> localCheckConnectionJob = checkConnectionJob;\n+        if (localCheckConnectionJob == null || localCheckConnectionJob.isCancelled()) {\n+            checkConnectionJob = scheduler.scheduleWithFixedDelay(() -> {\n+                long millisSinceLastEvent = System.currentTimeMillis() - client.getLastEventTimestamp();\n+                if (millisSinceLastEvent > CONNECTION_TIMEOUT_MILLIS) {\n+                    logger.debug(\"Check: Disconnected from streaming events, millisSinceLastEvent={}\",\n+                            millisSinceLastEvent);\n+                    checkConnection(client);\n+                } else {\n+                    logger.debug(\"Check: Receiving streaming events, millisSinceLastEvent={}\", millisSinceLastEvent);\n+                }\n+            }, 0, CONNECTION_TIMEOUT_MILLIS, TimeUnit.MILLISECONDS);\n+        }\n+    }\n+\n+    private void stopCheckConnectionJob() {\n+        ScheduledFuture<?> localCheckConnectionJob = checkConnectionJob;\n+        if (localCheckConnectionJob != null) {\n+            localCheckConnectionJob.cancel(true);\n+            checkConnectionJob = null;\n+        }\n+    }\n+\n+    private void restartStreamingUpdates() {\n+        synchronized (this) {\n+            stopStreamingUpdates();\n+            startStreamingUpdates();\n+        }\n+    }\n+\n+    private void startStreamingUpdates() {\n+        RemoteopenhabRestClient client = restClient;\n+        if (client != null) {\n+            synchronized (this) {\n+                client.addStreamingDataListener(this);\n+                client.start();\n+            }\n+        }\n+    }\n+\n+    private void stopStreamingUpdates() {\n+        RemoteopenhabRestClient client = restClient;\n+        if (client != null) {\n+            synchronized (this) {\n+                client.stop();\n+                client.removeStreamingDataListener(this);\n+            }\n+        }\n+    }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTMwMDI1NA=="}, "originalCommit": {"oid": "3dc867e53fe095f9925c318f8b1963318874020d"}, "originalPosition": 360}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTUwMTc5OQ==", "bodyText": "fine by me", "url": "https://github.com/openhab/openhab-addons/pull/8791#discussion_r511501799", "createdAt": "2020-10-24T18:44:04Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.remoteopenhab/src/main/java/org/openhab/binding/remoteopenhab/internal/handler/RemoteopenhabThingHandler.java", "diffHunk": "@@ -0,0 +1,535 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.remoteopenhab.internal.handler;\n+\n+import static org.openhab.binding.remoteopenhab.internal.RemoteopenhabBindingConstants.BINDING_ID;\n+\n+import java.time.ZonedDateTime;\n+import java.time.format.DateTimeFormatter;\n+import java.time.format.DateTimeParseException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.ws.rs.client.ClientBuilder;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.remoteopenhab.internal.RemoteopenhabChannelTypeProvider;\n+import org.openhab.binding.remoteopenhab.internal.RemoteopenhabStateDescriptionOptionProvider;\n+import org.openhab.binding.remoteopenhab.internal.config.RemoteopenhabInstanceConfiguration;\n+import org.openhab.binding.remoteopenhab.internal.data.Item;\n+import org.openhab.binding.remoteopenhab.internal.data.Option;\n+import org.openhab.binding.remoteopenhab.internal.data.StateDescription;\n+import org.openhab.binding.remoteopenhab.internal.exceptions.RemoteopenhabException;\n+import org.openhab.binding.remoteopenhab.internal.listener.RemoteopenhabStreamingDataListener;\n+import org.openhab.binding.remoteopenhab.internal.rest.RemoteopenhabRestClient;\n+import org.openhab.core.library.CoreItemFactory;\n+import org.openhab.core.library.types.DateTimeType;\n+import org.openhab.core.library.types.DecimalType;\n+import org.openhab.core.library.types.HSBType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.OpenClosedType;\n+import org.openhab.core.library.types.PercentType;\n+import org.openhab.core.library.types.PlayPauseType;\n+import org.openhab.core.library.types.PointType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.RawType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.builder.ChannelBuilder;\n+import org.openhab.core.thing.binding.builder.ThingBuilder;\n+import org.openhab.core.thing.type.AutoUpdatePolicy;\n+import org.openhab.core.thing.type.ChannelKind;\n+import org.openhab.core.thing.type.ChannelType;\n+import org.openhab.core.thing.type.ChannelTypeBuilder;\n+import org.openhab.core.thing.type.ChannelTypeUID;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.StateOption;\n+import org.openhab.core.types.TypeParser;\n+import org.openhab.core.types.UnDefType;\n+import org.osgi.service.jaxrs.client.SseEventSourceFactory;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+\n+/**\n+ * This bridge handler connects to Nest and handles all the API requests. It pulls down the\n+ * updated data, polls the system and does all the co-ordination with the other handlers\n+ * to get the data updated to the correct things.\n+ *\n+ * @author Laurent Garnier - Initial contribution\n+ */\n+@NonNullByDefault\n+public class RemoteopenhabThingHandler extends BaseThingHandler implements RemoteopenhabStreamingDataListener {\n+\n+    private static final String DATE_FORMAT_PATTERN = \"yyyy-MM-dd'T'HH:mm:ss.SSSZ\";\n+    private static final DateTimeFormatter FORMATTER_DATE = DateTimeFormatter.ofPattern(DATE_FORMAT_PATTERN);\n+\n+    private static final long CONNECTION_TIMEOUT_MILLIS = TimeUnit.MILLISECONDS.convert(5, TimeUnit.MINUTES);\n+\n+    private final Logger logger = LoggerFactory.getLogger(RemoteopenhabThingHandler.class);\n+\n+    private final ClientBuilder clientBuilder;\n+    private final SseEventSourceFactory eventSourceFactory;\n+    private final RemoteopenhabChannelTypeProvider channelTypeProvider;\n+    private final RemoteopenhabStateDescriptionOptionProvider stateDescriptionProvider;\n+    private final Gson jsonParser;\n+\n+    private final Object updateThingLock = new Object();\n+\n+    private @NonNullByDefault({}) RemoteopenhabInstanceConfiguration config;\n+\n+    private @Nullable ScheduledFuture<?> checkConnectionJob;\n+    private @Nullable RemoteopenhabRestClient restClient;\n+\n+    public RemoteopenhabThingHandler(Thing thing, ClientBuilder clientBuilder, SseEventSourceFactory eventSourceFactory,\n+            RemoteopenhabChannelTypeProvider channelTypeProvider,\n+            RemoteopenhabStateDescriptionOptionProvider stateDescriptionProvider, final Gson jsonParser) {\n+        super(thing);\n+        this.clientBuilder = clientBuilder;\n+        this.eventSourceFactory = eventSourceFactory;\n+        this.channelTypeProvider = channelTypeProvider;\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        this.jsonParser = jsonParser;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing remote openHAB thing handler\");\n+\n+        config = getConfigAs(RemoteopenhabInstanceConfiguration.class);\n+\n+        String url = getRestUrl();\n+        if (url.length() == 0 || !url.startsWith(\"http:\")) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"Please setup a HTTP REST URL in the thing configuration\");\n+        } else {\n+            logger.debug(\"REST URL = {}\", url);\n+\n+            RemoteopenhabRestClient client = new RemoteopenhabRestClient(clientBuilder, eventSourceFactory, jsonParser,\n+                    config.token, url);\n+            restClient = client;\n+\n+            updateStatus(ThingStatus.UNKNOWN);\n+\n+            startCheckConnectionJob(client);\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.debug(\"Disposing remote openHAB thing handler\");\n+        stopStreamingUpdates();\n+        stopCheckConnectionJob();\n+        this.restClient = null;\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (getThing().getStatus() != ThingStatus.ONLINE) {\n+            return;\n+        }\n+        RemoteopenhabRestClient client = restClient;\n+        if (client == null) {\n+            return;\n+        }\n+\n+        try {\n+            if (command instanceof RefreshType) {\n+                String state = client.getRemoteItemState(channelUID.getId());\n+                updateChannelState(channelUID.getId(), null, state);\n+            } else if (isLinked(channelUID)) {\n+                client.sendCommandToRemoteItem(channelUID.getId(), command);\n+                logger.debug(\"Sending command {} to remote item {} succeeded\",\n+                        command.toFullString().length() < 50 ? command.toFullString()\n+                                : command.toFullString().substring(0, 50) + \"...\",\n+                        channelUID.getId());\n+            }\n+        } catch (RemoteopenhabException e) {\n+            logger.debug(\"{}\", e.getMessage());\n+        }\n+    }\n+\n+    private String getRestUrl() {\n+        String url = config.restUrl.trim();\n+        if (url.endsWith(\"/\")) {\n+            url = url.substring(0, url.length() - 1);\n+        }\n+        return url;\n+    }\n+\n+    private void createChannels(List<Item> items, boolean replace) {\n+        synchronized (updateThingLock) {\n+            int nbGroups = 0;\n+            List<Channel> channels = new ArrayList<>();\n+            for (Item item : items) {\n+                String itemType = item.type;\n+                if (\"Group\".equals(itemType)) {\n+                    if (item.groupType.isEmpty()) {\n+                        // Standard groups are ignored\n+                        nbGroups++;\n+                        continue;\n+                    } else {\n+                        itemType = item.groupType;\n+                    }\n+                }\n+                String channelTypeId = String.format(\"item%s\", itemType.replace(\":\", \"\"));\n+                ChannelTypeUID channelTypeUID = new ChannelTypeUID(BINDING_ID, channelTypeId);\n+                ChannelType channelType = channelTypeProvider.getChannelType(channelTypeUID, null);\n+                String label;\n+                String description;\n+                if (channelType == null) {\n+                    logger.trace(\"Create the channel type {} for item type {}\", channelTypeUID, itemType);\n+                    label = String.format(\"Remote %s Item\", itemType);\n+                    description = String.format(\"An item of type %s from the remote server.\", itemType);\n+                    channelType = ChannelTypeBuilder.state(channelTypeUID, label, itemType).withDescription(description)\n+                            .withAutoUpdatePolicy(AutoUpdatePolicy.VETO).build();\n+                    channelTypeProvider.addChannelType(channelType);\n+                }\n+                ChannelUID channelUID = new ChannelUID(getThing().getUID(), item.name);\n+                logger.trace(\"Create the channel {} of type {}\", channelUID, channelTypeUID);\n+                label = item.name;\n+                description = String.format(\"Item %s from the remote server.\", item.name);\n+                channels.add(ChannelBuilder.create(channelUID, itemType).withType(channelTypeUID)\n+                        .withKind(ChannelKind.STATE).withLabel(label).withDescription(description).build());\n+            }\n+            ThingBuilder thingBuilder = editThing();\n+            if (replace) {\n+                thingBuilder.withChannels(channels);\n+                updateThing(thingBuilder.build());\n+                logger.debug(\"{} channels defined for the thing {} (from {} items including {} groups)\",\n+                        channels.size(), getThing().getUID(), items.size(), nbGroups);\n+            } else if (channels.size() > 0) {\n+                int nbRemoved = 0;\n+                for (Channel channel : channels) {\n+                    if (getThing().getChannel(channel.getUID()) != null) {\n+                        thingBuilder.withoutChannel(channel.getUID());\n+                        nbRemoved++;\n+                    }\n+                }\n+                if (nbRemoved > 0) {\n+                    logger.debug(\"{} channels removed for the thing {} (from {} items)\", nbRemoved, getThing().getUID(),\n+                            items.size());\n+                }\n+                for (Channel channel : channels) {\n+                    thingBuilder.withChannel(channel);\n+                }\n+                updateThing(thingBuilder.build());\n+                if (nbGroups > 0) {\n+                    logger.debug(\"{} channels added for the thing {} (from {} items including {} groups)\",\n+                            channels.size(), getThing().getUID(), items.size(), nbGroups);\n+                } else {\n+                    logger.debug(\"{} channels added for the thing {} (from {} items)\", channels.size(),\n+                            getThing().getUID(), items.size());\n+                }\n+            }\n+        }\n+    }\n+\n+    private void removeChannels(List<Item> items) {\n+        synchronized (updateThingLock) {\n+            int nbRemoved = 0;\n+            ThingBuilder thingBuilder = editThing();\n+            for (Item item : items) {\n+                Channel channel = getThing().getChannel(item.name);\n+                if (channel != null) {\n+                    thingBuilder.withoutChannel(channel.getUID());\n+                    nbRemoved++;\n+                }\n+            }\n+            if (nbRemoved > 0) {\n+                updateThing(thingBuilder.build());\n+                logger.debug(\"{} channels removed for the thing {} (from {} items)\", nbRemoved, getThing().getUID(),\n+                        items.size());\n+            }\n+        }\n+    }\n+\n+    private void setStateOptions(List<Item> items) {\n+        for (Item item : items) {\n+            Channel channel = getThing().getChannel(item.name);\n+            StateDescription descr = item.stateDescription;\n+            List<Option> options = descr == null ? null : descr.options;\n+            if (channel != null && options != null && options.size() > 0) {\n+                List<StateOption> stateOptions = new ArrayList<>();\n+                for (Option option : options) {\n+                    stateOptions.add(new StateOption(option.value, option.label));\n+                }\n+                stateDescriptionProvider.setStateOptions(channel.getUID(), stateOptions);\n+                logger.trace(\"{} options set for the channel {}\", options.size(), channel.getUID());\n+            }\n+        }\n+    }\n+\n+    public void checkConnection(RemoteopenhabRestClient client) {\n+        logger.debug(\"Try the root REST API...\");\n+        try {\n+            client.tryApi();\n+            if (client.getRestApiVersion() == null) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                        \"OH 1.x server not supported by the binding\");\n+            } else {\n+                List<Item> items = client.getRemoteItems();\n+\n+                createChannels(items, true);\n+                setStateOptions(items);\n+                for (Item item : items) {\n+                    updateChannelState(item.name, null, item.state);\n+                }\n+\n+                updateStatus(ThingStatus.ONLINE);\n+\n+                restartStreamingUpdates();\n+            }\n+        } catch (RemoteopenhabException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e.getMessage());\n+            stopStreamingUpdates();\n+        }\n+    }\n+\n+    private void startCheckConnectionJob(RemoteopenhabRestClient client) {\n+        ScheduledFuture<?> localCheckConnectionJob = checkConnectionJob;\n+        if (localCheckConnectionJob == null || localCheckConnectionJob.isCancelled()) {\n+            checkConnectionJob = scheduler.scheduleWithFixedDelay(() -> {\n+                long millisSinceLastEvent = System.currentTimeMillis() - client.getLastEventTimestamp();\n+                if (millisSinceLastEvent > CONNECTION_TIMEOUT_MILLIS) {\n+                    logger.debug(\"Check: Disconnected from streaming events, millisSinceLastEvent={}\",\n+                            millisSinceLastEvent);\n+                    checkConnection(client);\n+                } else {\n+                    logger.debug(\"Check: Receiving streaming events, millisSinceLastEvent={}\", millisSinceLastEvent);\n+                }\n+            }, 0, CONNECTION_TIMEOUT_MILLIS, TimeUnit.MILLISECONDS);\n+        }\n+    }\n+\n+    private void stopCheckConnectionJob() {\n+        ScheduledFuture<?> localCheckConnectionJob = checkConnectionJob;\n+        if (localCheckConnectionJob != null) {\n+            localCheckConnectionJob.cancel(true);\n+            checkConnectionJob = null;\n+        }\n+    }\n+\n+    private void restartStreamingUpdates() {\n+        synchronized (this) {\n+            stopStreamingUpdates();\n+            startStreamingUpdates();\n+        }\n+    }\n+\n+    private void startStreamingUpdates() {\n+        RemoteopenhabRestClient client = restClient;\n+        if (client != null) {\n+            synchronized (this) {\n+                client.addStreamingDataListener(this);\n+                client.start();\n+            }\n+        }\n+    }\n+\n+    private void stopStreamingUpdates() {\n+        RemoteopenhabRestClient client = restClient;\n+        if (client != null) {\n+            synchronized (this) {\n+                client.stop();\n+                client.removeStreamingDataListener(this);\n+            }\n+        }\n+    }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTMwMDI1NA=="}, "originalCommit": {"oid": "3dc867e53fe095f9925c318f8b1963318874020d"}, "originalPosition": 360}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIwMjk2Nzc1OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.remoteopenhab/src/main/java/org/openhab/binding/remoteopenhab/internal/handler/RemoteopenhabThingHandler.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNFQwMzo1NDoyMVrOHnnUJA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNFQxODo0NTo0N1rOHnzmtA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTMwMDY0NA==", "bodyText": "Might as well cover all your bases.\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    if (localCheckConnectionJob == null || localCheckConnectionJob.isCancelled()) {\n          \n          \n            \n                    if (localCheckConnectionJob == null || localCheckConnectionJob.isDone()) {", "url": "https://github.com/openhab/openhab-addons/pull/8791#discussion_r511300644", "createdAt": "2020-10-24T03:54:21Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.remoteopenhab/src/main/java/org/openhab/binding/remoteopenhab/internal/handler/RemoteopenhabThingHandler.java", "diffHunk": "@@ -0,0 +1,535 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.remoteopenhab.internal.handler;\n+\n+import static org.openhab.binding.remoteopenhab.internal.RemoteopenhabBindingConstants.BINDING_ID;\n+\n+import java.time.ZonedDateTime;\n+import java.time.format.DateTimeFormatter;\n+import java.time.format.DateTimeParseException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.ws.rs.client.ClientBuilder;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.remoteopenhab.internal.RemoteopenhabChannelTypeProvider;\n+import org.openhab.binding.remoteopenhab.internal.RemoteopenhabStateDescriptionOptionProvider;\n+import org.openhab.binding.remoteopenhab.internal.config.RemoteopenhabInstanceConfiguration;\n+import org.openhab.binding.remoteopenhab.internal.data.Item;\n+import org.openhab.binding.remoteopenhab.internal.data.Option;\n+import org.openhab.binding.remoteopenhab.internal.data.StateDescription;\n+import org.openhab.binding.remoteopenhab.internal.exceptions.RemoteopenhabException;\n+import org.openhab.binding.remoteopenhab.internal.listener.RemoteopenhabStreamingDataListener;\n+import org.openhab.binding.remoteopenhab.internal.rest.RemoteopenhabRestClient;\n+import org.openhab.core.library.CoreItemFactory;\n+import org.openhab.core.library.types.DateTimeType;\n+import org.openhab.core.library.types.DecimalType;\n+import org.openhab.core.library.types.HSBType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.OpenClosedType;\n+import org.openhab.core.library.types.PercentType;\n+import org.openhab.core.library.types.PlayPauseType;\n+import org.openhab.core.library.types.PointType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.RawType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.builder.ChannelBuilder;\n+import org.openhab.core.thing.binding.builder.ThingBuilder;\n+import org.openhab.core.thing.type.AutoUpdatePolicy;\n+import org.openhab.core.thing.type.ChannelKind;\n+import org.openhab.core.thing.type.ChannelType;\n+import org.openhab.core.thing.type.ChannelTypeBuilder;\n+import org.openhab.core.thing.type.ChannelTypeUID;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.StateOption;\n+import org.openhab.core.types.TypeParser;\n+import org.openhab.core.types.UnDefType;\n+import org.osgi.service.jaxrs.client.SseEventSourceFactory;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+\n+/**\n+ * This bridge handler connects to Nest and handles all the API requests. It pulls down the\n+ * updated data, polls the system and does all the co-ordination with the other handlers\n+ * to get the data updated to the correct things.\n+ *\n+ * @author Laurent Garnier - Initial contribution\n+ */\n+@NonNullByDefault\n+public class RemoteopenhabThingHandler extends BaseThingHandler implements RemoteopenhabStreamingDataListener {\n+\n+    private static final String DATE_FORMAT_PATTERN = \"yyyy-MM-dd'T'HH:mm:ss.SSSZ\";\n+    private static final DateTimeFormatter FORMATTER_DATE = DateTimeFormatter.ofPattern(DATE_FORMAT_PATTERN);\n+\n+    private static final long CONNECTION_TIMEOUT_MILLIS = TimeUnit.MILLISECONDS.convert(5, TimeUnit.MINUTES);\n+\n+    private final Logger logger = LoggerFactory.getLogger(RemoteopenhabThingHandler.class);\n+\n+    private final ClientBuilder clientBuilder;\n+    private final SseEventSourceFactory eventSourceFactory;\n+    private final RemoteopenhabChannelTypeProvider channelTypeProvider;\n+    private final RemoteopenhabStateDescriptionOptionProvider stateDescriptionProvider;\n+    private final Gson jsonParser;\n+\n+    private final Object updateThingLock = new Object();\n+\n+    private @NonNullByDefault({}) RemoteopenhabInstanceConfiguration config;\n+\n+    private @Nullable ScheduledFuture<?> checkConnectionJob;\n+    private @Nullable RemoteopenhabRestClient restClient;\n+\n+    public RemoteopenhabThingHandler(Thing thing, ClientBuilder clientBuilder, SseEventSourceFactory eventSourceFactory,\n+            RemoteopenhabChannelTypeProvider channelTypeProvider,\n+            RemoteopenhabStateDescriptionOptionProvider stateDescriptionProvider, final Gson jsonParser) {\n+        super(thing);\n+        this.clientBuilder = clientBuilder;\n+        this.eventSourceFactory = eventSourceFactory;\n+        this.channelTypeProvider = channelTypeProvider;\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        this.jsonParser = jsonParser;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing remote openHAB thing handler\");\n+\n+        config = getConfigAs(RemoteopenhabInstanceConfiguration.class);\n+\n+        String url = getRestUrl();\n+        if (url.length() == 0 || !url.startsWith(\"http:\")) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"Please setup a HTTP REST URL in the thing configuration\");\n+        } else {\n+            logger.debug(\"REST URL = {}\", url);\n+\n+            RemoteopenhabRestClient client = new RemoteopenhabRestClient(clientBuilder, eventSourceFactory, jsonParser,\n+                    config.token, url);\n+            restClient = client;\n+\n+            updateStatus(ThingStatus.UNKNOWN);\n+\n+            startCheckConnectionJob(client);\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.debug(\"Disposing remote openHAB thing handler\");\n+        stopStreamingUpdates();\n+        stopCheckConnectionJob();\n+        this.restClient = null;\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (getThing().getStatus() != ThingStatus.ONLINE) {\n+            return;\n+        }\n+        RemoteopenhabRestClient client = restClient;\n+        if (client == null) {\n+            return;\n+        }\n+\n+        try {\n+            if (command instanceof RefreshType) {\n+                String state = client.getRemoteItemState(channelUID.getId());\n+                updateChannelState(channelUID.getId(), null, state);\n+            } else if (isLinked(channelUID)) {\n+                client.sendCommandToRemoteItem(channelUID.getId(), command);\n+                logger.debug(\"Sending command {} to remote item {} succeeded\",\n+                        command.toFullString().length() < 50 ? command.toFullString()\n+                                : command.toFullString().substring(0, 50) + \"...\",\n+                        channelUID.getId());\n+            }\n+        } catch (RemoteopenhabException e) {\n+            logger.debug(\"{}\", e.getMessage());\n+        }\n+    }\n+\n+    private String getRestUrl() {\n+        String url = config.restUrl.trim();\n+        if (url.endsWith(\"/\")) {\n+            url = url.substring(0, url.length() - 1);\n+        }\n+        return url;\n+    }\n+\n+    private void createChannels(List<Item> items, boolean replace) {\n+        synchronized (updateThingLock) {\n+            int nbGroups = 0;\n+            List<Channel> channels = new ArrayList<>();\n+            for (Item item : items) {\n+                String itemType = item.type;\n+                if (\"Group\".equals(itemType)) {\n+                    if (item.groupType.isEmpty()) {\n+                        // Standard groups are ignored\n+                        nbGroups++;\n+                        continue;\n+                    } else {\n+                        itemType = item.groupType;\n+                    }\n+                }\n+                String channelTypeId = String.format(\"item%s\", itemType.replace(\":\", \"\"));\n+                ChannelTypeUID channelTypeUID = new ChannelTypeUID(BINDING_ID, channelTypeId);\n+                ChannelType channelType = channelTypeProvider.getChannelType(channelTypeUID, null);\n+                String label;\n+                String description;\n+                if (channelType == null) {\n+                    logger.trace(\"Create the channel type {} for item type {}\", channelTypeUID, itemType);\n+                    label = String.format(\"Remote %s Item\", itemType);\n+                    description = String.format(\"An item of type %s from the remote server.\", itemType);\n+                    channelType = ChannelTypeBuilder.state(channelTypeUID, label, itemType).withDescription(description)\n+                            .withAutoUpdatePolicy(AutoUpdatePolicy.VETO).build();\n+                    channelTypeProvider.addChannelType(channelType);\n+                }\n+                ChannelUID channelUID = new ChannelUID(getThing().getUID(), item.name);\n+                logger.trace(\"Create the channel {} of type {}\", channelUID, channelTypeUID);\n+                label = item.name;\n+                description = String.format(\"Item %s from the remote server.\", item.name);\n+                channels.add(ChannelBuilder.create(channelUID, itemType).withType(channelTypeUID)\n+                        .withKind(ChannelKind.STATE).withLabel(label).withDescription(description).build());\n+            }\n+            ThingBuilder thingBuilder = editThing();\n+            if (replace) {\n+                thingBuilder.withChannels(channels);\n+                updateThing(thingBuilder.build());\n+                logger.debug(\"{} channels defined for the thing {} (from {} items including {} groups)\",\n+                        channels.size(), getThing().getUID(), items.size(), nbGroups);\n+            } else if (channels.size() > 0) {\n+                int nbRemoved = 0;\n+                for (Channel channel : channels) {\n+                    if (getThing().getChannel(channel.getUID()) != null) {\n+                        thingBuilder.withoutChannel(channel.getUID());\n+                        nbRemoved++;\n+                    }\n+                }\n+                if (nbRemoved > 0) {\n+                    logger.debug(\"{} channels removed for the thing {} (from {} items)\", nbRemoved, getThing().getUID(),\n+                            items.size());\n+                }\n+                for (Channel channel : channels) {\n+                    thingBuilder.withChannel(channel);\n+                }\n+                updateThing(thingBuilder.build());\n+                if (nbGroups > 0) {\n+                    logger.debug(\"{} channels added for the thing {} (from {} items including {} groups)\",\n+                            channels.size(), getThing().getUID(), items.size(), nbGroups);\n+                } else {\n+                    logger.debug(\"{} channels added for the thing {} (from {} items)\", channels.size(),\n+                            getThing().getUID(), items.size());\n+                }\n+            }\n+        }\n+    }\n+\n+    private void removeChannels(List<Item> items) {\n+        synchronized (updateThingLock) {\n+            int nbRemoved = 0;\n+            ThingBuilder thingBuilder = editThing();\n+            for (Item item : items) {\n+                Channel channel = getThing().getChannel(item.name);\n+                if (channel != null) {\n+                    thingBuilder.withoutChannel(channel.getUID());\n+                    nbRemoved++;\n+                }\n+            }\n+            if (nbRemoved > 0) {\n+                updateThing(thingBuilder.build());\n+                logger.debug(\"{} channels removed for the thing {} (from {} items)\", nbRemoved, getThing().getUID(),\n+                        items.size());\n+            }\n+        }\n+    }\n+\n+    private void setStateOptions(List<Item> items) {\n+        for (Item item : items) {\n+            Channel channel = getThing().getChannel(item.name);\n+            StateDescription descr = item.stateDescription;\n+            List<Option> options = descr == null ? null : descr.options;\n+            if (channel != null && options != null && options.size() > 0) {\n+                List<StateOption> stateOptions = new ArrayList<>();\n+                for (Option option : options) {\n+                    stateOptions.add(new StateOption(option.value, option.label));\n+                }\n+                stateDescriptionProvider.setStateOptions(channel.getUID(), stateOptions);\n+                logger.trace(\"{} options set for the channel {}\", options.size(), channel.getUID());\n+            }\n+        }\n+    }\n+\n+    public void checkConnection(RemoteopenhabRestClient client) {\n+        logger.debug(\"Try the root REST API...\");\n+        try {\n+            client.tryApi();\n+            if (client.getRestApiVersion() == null) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                        \"OH 1.x server not supported by the binding\");\n+            } else {\n+                List<Item> items = client.getRemoteItems();\n+\n+                createChannels(items, true);\n+                setStateOptions(items);\n+                for (Item item : items) {\n+                    updateChannelState(item.name, null, item.state);\n+                }\n+\n+                updateStatus(ThingStatus.ONLINE);\n+\n+                restartStreamingUpdates();\n+            }\n+        } catch (RemoteopenhabException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e.getMessage());\n+            stopStreamingUpdates();\n+        }\n+    }\n+\n+    private void startCheckConnectionJob(RemoteopenhabRestClient client) {\n+        ScheduledFuture<?> localCheckConnectionJob = checkConnectionJob;\n+        if (localCheckConnectionJob == null || localCheckConnectionJob.isCancelled()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3dc867e53fe095f9925c318f8b1963318874020d"}, "originalPosition": 313}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTM1MjM3Mw==", "bodyText": "Why should I use here a different \"pattern\" from you can already find in hundreds of bindings ?", "url": "https://github.com/openhab/openhab-addons/pull/8791#discussion_r511352373", "createdAt": "2020-10-24T09:05:56Z", "author": {"login": "lolodomo"}, "path": "bundles/org.openhab.binding.remoteopenhab/src/main/java/org/openhab/binding/remoteopenhab/internal/handler/RemoteopenhabThingHandler.java", "diffHunk": "@@ -0,0 +1,535 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.remoteopenhab.internal.handler;\n+\n+import static org.openhab.binding.remoteopenhab.internal.RemoteopenhabBindingConstants.BINDING_ID;\n+\n+import java.time.ZonedDateTime;\n+import java.time.format.DateTimeFormatter;\n+import java.time.format.DateTimeParseException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.ws.rs.client.ClientBuilder;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.remoteopenhab.internal.RemoteopenhabChannelTypeProvider;\n+import org.openhab.binding.remoteopenhab.internal.RemoteopenhabStateDescriptionOptionProvider;\n+import org.openhab.binding.remoteopenhab.internal.config.RemoteopenhabInstanceConfiguration;\n+import org.openhab.binding.remoteopenhab.internal.data.Item;\n+import org.openhab.binding.remoteopenhab.internal.data.Option;\n+import org.openhab.binding.remoteopenhab.internal.data.StateDescription;\n+import org.openhab.binding.remoteopenhab.internal.exceptions.RemoteopenhabException;\n+import org.openhab.binding.remoteopenhab.internal.listener.RemoteopenhabStreamingDataListener;\n+import org.openhab.binding.remoteopenhab.internal.rest.RemoteopenhabRestClient;\n+import org.openhab.core.library.CoreItemFactory;\n+import org.openhab.core.library.types.DateTimeType;\n+import org.openhab.core.library.types.DecimalType;\n+import org.openhab.core.library.types.HSBType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.OpenClosedType;\n+import org.openhab.core.library.types.PercentType;\n+import org.openhab.core.library.types.PlayPauseType;\n+import org.openhab.core.library.types.PointType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.RawType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.builder.ChannelBuilder;\n+import org.openhab.core.thing.binding.builder.ThingBuilder;\n+import org.openhab.core.thing.type.AutoUpdatePolicy;\n+import org.openhab.core.thing.type.ChannelKind;\n+import org.openhab.core.thing.type.ChannelType;\n+import org.openhab.core.thing.type.ChannelTypeBuilder;\n+import org.openhab.core.thing.type.ChannelTypeUID;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.StateOption;\n+import org.openhab.core.types.TypeParser;\n+import org.openhab.core.types.UnDefType;\n+import org.osgi.service.jaxrs.client.SseEventSourceFactory;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+\n+/**\n+ * This bridge handler connects to Nest and handles all the API requests. It pulls down the\n+ * updated data, polls the system and does all the co-ordination with the other handlers\n+ * to get the data updated to the correct things.\n+ *\n+ * @author Laurent Garnier - Initial contribution\n+ */\n+@NonNullByDefault\n+public class RemoteopenhabThingHandler extends BaseThingHandler implements RemoteopenhabStreamingDataListener {\n+\n+    private static final String DATE_FORMAT_PATTERN = \"yyyy-MM-dd'T'HH:mm:ss.SSSZ\";\n+    private static final DateTimeFormatter FORMATTER_DATE = DateTimeFormatter.ofPattern(DATE_FORMAT_PATTERN);\n+\n+    private static final long CONNECTION_TIMEOUT_MILLIS = TimeUnit.MILLISECONDS.convert(5, TimeUnit.MINUTES);\n+\n+    private final Logger logger = LoggerFactory.getLogger(RemoteopenhabThingHandler.class);\n+\n+    private final ClientBuilder clientBuilder;\n+    private final SseEventSourceFactory eventSourceFactory;\n+    private final RemoteopenhabChannelTypeProvider channelTypeProvider;\n+    private final RemoteopenhabStateDescriptionOptionProvider stateDescriptionProvider;\n+    private final Gson jsonParser;\n+\n+    private final Object updateThingLock = new Object();\n+\n+    private @NonNullByDefault({}) RemoteopenhabInstanceConfiguration config;\n+\n+    private @Nullable ScheduledFuture<?> checkConnectionJob;\n+    private @Nullable RemoteopenhabRestClient restClient;\n+\n+    public RemoteopenhabThingHandler(Thing thing, ClientBuilder clientBuilder, SseEventSourceFactory eventSourceFactory,\n+            RemoteopenhabChannelTypeProvider channelTypeProvider,\n+            RemoteopenhabStateDescriptionOptionProvider stateDescriptionProvider, final Gson jsonParser) {\n+        super(thing);\n+        this.clientBuilder = clientBuilder;\n+        this.eventSourceFactory = eventSourceFactory;\n+        this.channelTypeProvider = channelTypeProvider;\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        this.jsonParser = jsonParser;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing remote openHAB thing handler\");\n+\n+        config = getConfigAs(RemoteopenhabInstanceConfiguration.class);\n+\n+        String url = getRestUrl();\n+        if (url.length() == 0 || !url.startsWith(\"http:\")) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"Please setup a HTTP REST URL in the thing configuration\");\n+        } else {\n+            logger.debug(\"REST URL = {}\", url);\n+\n+            RemoteopenhabRestClient client = new RemoteopenhabRestClient(clientBuilder, eventSourceFactory, jsonParser,\n+                    config.token, url);\n+            restClient = client;\n+\n+            updateStatus(ThingStatus.UNKNOWN);\n+\n+            startCheckConnectionJob(client);\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.debug(\"Disposing remote openHAB thing handler\");\n+        stopStreamingUpdates();\n+        stopCheckConnectionJob();\n+        this.restClient = null;\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (getThing().getStatus() != ThingStatus.ONLINE) {\n+            return;\n+        }\n+        RemoteopenhabRestClient client = restClient;\n+        if (client == null) {\n+            return;\n+        }\n+\n+        try {\n+            if (command instanceof RefreshType) {\n+                String state = client.getRemoteItemState(channelUID.getId());\n+                updateChannelState(channelUID.getId(), null, state);\n+            } else if (isLinked(channelUID)) {\n+                client.sendCommandToRemoteItem(channelUID.getId(), command);\n+                logger.debug(\"Sending command {} to remote item {} succeeded\",\n+                        command.toFullString().length() < 50 ? command.toFullString()\n+                                : command.toFullString().substring(0, 50) + \"...\",\n+                        channelUID.getId());\n+            }\n+        } catch (RemoteopenhabException e) {\n+            logger.debug(\"{}\", e.getMessage());\n+        }\n+    }\n+\n+    private String getRestUrl() {\n+        String url = config.restUrl.trim();\n+        if (url.endsWith(\"/\")) {\n+            url = url.substring(0, url.length() - 1);\n+        }\n+        return url;\n+    }\n+\n+    private void createChannels(List<Item> items, boolean replace) {\n+        synchronized (updateThingLock) {\n+            int nbGroups = 0;\n+            List<Channel> channels = new ArrayList<>();\n+            for (Item item : items) {\n+                String itemType = item.type;\n+                if (\"Group\".equals(itemType)) {\n+                    if (item.groupType.isEmpty()) {\n+                        // Standard groups are ignored\n+                        nbGroups++;\n+                        continue;\n+                    } else {\n+                        itemType = item.groupType;\n+                    }\n+                }\n+                String channelTypeId = String.format(\"item%s\", itemType.replace(\":\", \"\"));\n+                ChannelTypeUID channelTypeUID = new ChannelTypeUID(BINDING_ID, channelTypeId);\n+                ChannelType channelType = channelTypeProvider.getChannelType(channelTypeUID, null);\n+                String label;\n+                String description;\n+                if (channelType == null) {\n+                    logger.trace(\"Create the channel type {} for item type {}\", channelTypeUID, itemType);\n+                    label = String.format(\"Remote %s Item\", itemType);\n+                    description = String.format(\"An item of type %s from the remote server.\", itemType);\n+                    channelType = ChannelTypeBuilder.state(channelTypeUID, label, itemType).withDescription(description)\n+                            .withAutoUpdatePolicy(AutoUpdatePolicy.VETO).build();\n+                    channelTypeProvider.addChannelType(channelType);\n+                }\n+                ChannelUID channelUID = new ChannelUID(getThing().getUID(), item.name);\n+                logger.trace(\"Create the channel {} of type {}\", channelUID, channelTypeUID);\n+                label = item.name;\n+                description = String.format(\"Item %s from the remote server.\", item.name);\n+                channels.add(ChannelBuilder.create(channelUID, itemType).withType(channelTypeUID)\n+                        .withKind(ChannelKind.STATE).withLabel(label).withDescription(description).build());\n+            }\n+            ThingBuilder thingBuilder = editThing();\n+            if (replace) {\n+                thingBuilder.withChannels(channels);\n+                updateThing(thingBuilder.build());\n+                logger.debug(\"{} channels defined for the thing {} (from {} items including {} groups)\",\n+                        channels.size(), getThing().getUID(), items.size(), nbGroups);\n+            } else if (channels.size() > 0) {\n+                int nbRemoved = 0;\n+                for (Channel channel : channels) {\n+                    if (getThing().getChannel(channel.getUID()) != null) {\n+                        thingBuilder.withoutChannel(channel.getUID());\n+                        nbRemoved++;\n+                    }\n+                }\n+                if (nbRemoved > 0) {\n+                    logger.debug(\"{} channels removed for the thing {} (from {} items)\", nbRemoved, getThing().getUID(),\n+                            items.size());\n+                }\n+                for (Channel channel : channels) {\n+                    thingBuilder.withChannel(channel);\n+                }\n+                updateThing(thingBuilder.build());\n+                if (nbGroups > 0) {\n+                    logger.debug(\"{} channels added for the thing {} (from {} items including {} groups)\",\n+                            channels.size(), getThing().getUID(), items.size(), nbGroups);\n+                } else {\n+                    logger.debug(\"{} channels added for the thing {} (from {} items)\", channels.size(),\n+                            getThing().getUID(), items.size());\n+                }\n+            }\n+        }\n+    }\n+\n+    private void removeChannels(List<Item> items) {\n+        synchronized (updateThingLock) {\n+            int nbRemoved = 0;\n+            ThingBuilder thingBuilder = editThing();\n+            for (Item item : items) {\n+                Channel channel = getThing().getChannel(item.name);\n+                if (channel != null) {\n+                    thingBuilder.withoutChannel(channel.getUID());\n+                    nbRemoved++;\n+                }\n+            }\n+            if (nbRemoved > 0) {\n+                updateThing(thingBuilder.build());\n+                logger.debug(\"{} channels removed for the thing {} (from {} items)\", nbRemoved, getThing().getUID(),\n+                        items.size());\n+            }\n+        }\n+    }\n+\n+    private void setStateOptions(List<Item> items) {\n+        for (Item item : items) {\n+            Channel channel = getThing().getChannel(item.name);\n+            StateDescription descr = item.stateDescription;\n+            List<Option> options = descr == null ? null : descr.options;\n+            if (channel != null && options != null && options.size() > 0) {\n+                List<StateOption> stateOptions = new ArrayList<>();\n+                for (Option option : options) {\n+                    stateOptions.add(new StateOption(option.value, option.label));\n+                }\n+                stateDescriptionProvider.setStateOptions(channel.getUID(), stateOptions);\n+                logger.trace(\"{} options set for the channel {}\", options.size(), channel.getUID());\n+            }\n+        }\n+    }\n+\n+    public void checkConnection(RemoteopenhabRestClient client) {\n+        logger.debug(\"Try the root REST API...\");\n+        try {\n+            client.tryApi();\n+            if (client.getRestApiVersion() == null) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                        \"OH 1.x server not supported by the binding\");\n+            } else {\n+                List<Item> items = client.getRemoteItems();\n+\n+                createChannels(items, true);\n+                setStateOptions(items);\n+                for (Item item : items) {\n+                    updateChannelState(item.name, null, item.state);\n+                }\n+\n+                updateStatus(ThingStatus.ONLINE);\n+\n+                restartStreamingUpdates();\n+            }\n+        } catch (RemoteopenhabException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e.getMessage());\n+            stopStreamingUpdates();\n+        }\n+    }\n+\n+    private void startCheckConnectionJob(RemoteopenhabRestClient client) {\n+        ScheduledFuture<?> localCheckConnectionJob = checkConnectionJob;\n+        if (localCheckConnectionJob == null || localCheckConnectionJob.isCancelled()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTMwMDY0NA=="}, "originalCommit": {"oid": "3dc867e53fe095f9925c318f8b1963318874020d"}, "originalPosition": 313}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTUwMjAwNA==", "bodyText": "Well if the prior job finished due to an error then isCancelled would return false, but isDone would return true. I figure if the intent is to restart the future if it is no longer running, isDone is more appropriate in that case.", "url": "https://github.com/openhab/openhab-addons/pull/8791#discussion_r511502004", "createdAt": "2020-10-24T18:45:47Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.remoteopenhab/src/main/java/org/openhab/binding/remoteopenhab/internal/handler/RemoteopenhabThingHandler.java", "diffHunk": "@@ -0,0 +1,535 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.remoteopenhab.internal.handler;\n+\n+import static org.openhab.binding.remoteopenhab.internal.RemoteopenhabBindingConstants.BINDING_ID;\n+\n+import java.time.ZonedDateTime;\n+import java.time.format.DateTimeFormatter;\n+import java.time.format.DateTimeParseException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.ws.rs.client.ClientBuilder;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.remoteopenhab.internal.RemoteopenhabChannelTypeProvider;\n+import org.openhab.binding.remoteopenhab.internal.RemoteopenhabStateDescriptionOptionProvider;\n+import org.openhab.binding.remoteopenhab.internal.config.RemoteopenhabInstanceConfiguration;\n+import org.openhab.binding.remoteopenhab.internal.data.Item;\n+import org.openhab.binding.remoteopenhab.internal.data.Option;\n+import org.openhab.binding.remoteopenhab.internal.data.StateDescription;\n+import org.openhab.binding.remoteopenhab.internal.exceptions.RemoteopenhabException;\n+import org.openhab.binding.remoteopenhab.internal.listener.RemoteopenhabStreamingDataListener;\n+import org.openhab.binding.remoteopenhab.internal.rest.RemoteopenhabRestClient;\n+import org.openhab.core.library.CoreItemFactory;\n+import org.openhab.core.library.types.DateTimeType;\n+import org.openhab.core.library.types.DecimalType;\n+import org.openhab.core.library.types.HSBType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.OpenClosedType;\n+import org.openhab.core.library.types.PercentType;\n+import org.openhab.core.library.types.PlayPauseType;\n+import org.openhab.core.library.types.PointType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.RawType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.builder.ChannelBuilder;\n+import org.openhab.core.thing.binding.builder.ThingBuilder;\n+import org.openhab.core.thing.type.AutoUpdatePolicy;\n+import org.openhab.core.thing.type.ChannelKind;\n+import org.openhab.core.thing.type.ChannelType;\n+import org.openhab.core.thing.type.ChannelTypeBuilder;\n+import org.openhab.core.thing.type.ChannelTypeUID;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.StateOption;\n+import org.openhab.core.types.TypeParser;\n+import org.openhab.core.types.UnDefType;\n+import org.osgi.service.jaxrs.client.SseEventSourceFactory;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+\n+/**\n+ * This bridge handler connects to Nest and handles all the API requests. It pulls down the\n+ * updated data, polls the system and does all the co-ordination with the other handlers\n+ * to get the data updated to the correct things.\n+ *\n+ * @author Laurent Garnier - Initial contribution\n+ */\n+@NonNullByDefault\n+public class RemoteopenhabThingHandler extends BaseThingHandler implements RemoteopenhabStreamingDataListener {\n+\n+    private static final String DATE_FORMAT_PATTERN = \"yyyy-MM-dd'T'HH:mm:ss.SSSZ\";\n+    private static final DateTimeFormatter FORMATTER_DATE = DateTimeFormatter.ofPattern(DATE_FORMAT_PATTERN);\n+\n+    private static final long CONNECTION_TIMEOUT_MILLIS = TimeUnit.MILLISECONDS.convert(5, TimeUnit.MINUTES);\n+\n+    private final Logger logger = LoggerFactory.getLogger(RemoteopenhabThingHandler.class);\n+\n+    private final ClientBuilder clientBuilder;\n+    private final SseEventSourceFactory eventSourceFactory;\n+    private final RemoteopenhabChannelTypeProvider channelTypeProvider;\n+    private final RemoteopenhabStateDescriptionOptionProvider stateDescriptionProvider;\n+    private final Gson jsonParser;\n+\n+    private final Object updateThingLock = new Object();\n+\n+    private @NonNullByDefault({}) RemoteopenhabInstanceConfiguration config;\n+\n+    private @Nullable ScheduledFuture<?> checkConnectionJob;\n+    private @Nullable RemoteopenhabRestClient restClient;\n+\n+    public RemoteopenhabThingHandler(Thing thing, ClientBuilder clientBuilder, SseEventSourceFactory eventSourceFactory,\n+            RemoteopenhabChannelTypeProvider channelTypeProvider,\n+            RemoteopenhabStateDescriptionOptionProvider stateDescriptionProvider, final Gson jsonParser) {\n+        super(thing);\n+        this.clientBuilder = clientBuilder;\n+        this.eventSourceFactory = eventSourceFactory;\n+        this.channelTypeProvider = channelTypeProvider;\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        this.jsonParser = jsonParser;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing remote openHAB thing handler\");\n+\n+        config = getConfigAs(RemoteopenhabInstanceConfiguration.class);\n+\n+        String url = getRestUrl();\n+        if (url.length() == 0 || !url.startsWith(\"http:\")) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"Please setup a HTTP REST URL in the thing configuration\");\n+        } else {\n+            logger.debug(\"REST URL = {}\", url);\n+\n+            RemoteopenhabRestClient client = new RemoteopenhabRestClient(clientBuilder, eventSourceFactory, jsonParser,\n+                    config.token, url);\n+            restClient = client;\n+\n+            updateStatus(ThingStatus.UNKNOWN);\n+\n+            startCheckConnectionJob(client);\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.debug(\"Disposing remote openHAB thing handler\");\n+        stopStreamingUpdates();\n+        stopCheckConnectionJob();\n+        this.restClient = null;\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (getThing().getStatus() != ThingStatus.ONLINE) {\n+            return;\n+        }\n+        RemoteopenhabRestClient client = restClient;\n+        if (client == null) {\n+            return;\n+        }\n+\n+        try {\n+            if (command instanceof RefreshType) {\n+                String state = client.getRemoteItemState(channelUID.getId());\n+                updateChannelState(channelUID.getId(), null, state);\n+            } else if (isLinked(channelUID)) {\n+                client.sendCommandToRemoteItem(channelUID.getId(), command);\n+                logger.debug(\"Sending command {} to remote item {} succeeded\",\n+                        command.toFullString().length() < 50 ? command.toFullString()\n+                                : command.toFullString().substring(0, 50) + \"...\",\n+                        channelUID.getId());\n+            }\n+        } catch (RemoteopenhabException e) {\n+            logger.debug(\"{}\", e.getMessage());\n+        }\n+    }\n+\n+    private String getRestUrl() {\n+        String url = config.restUrl.trim();\n+        if (url.endsWith(\"/\")) {\n+            url = url.substring(0, url.length() - 1);\n+        }\n+        return url;\n+    }\n+\n+    private void createChannels(List<Item> items, boolean replace) {\n+        synchronized (updateThingLock) {\n+            int nbGroups = 0;\n+            List<Channel> channels = new ArrayList<>();\n+            for (Item item : items) {\n+                String itemType = item.type;\n+                if (\"Group\".equals(itemType)) {\n+                    if (item.groupType.isEmpty()) {\n+                        // Standard groups are ignored\n+                        nbGroups++;\n+                        continue;\n+                    } else {\n+                        itemType = item.groupType;\n+                    }\n+                }\n+                String channelTypeId = String.format(\"item%s\", itemType.replace(\":\", \"\"));\n+                ChannelTypeUID channelTypeUID = new ChannelTypeUID(BINDING_ID, channelTypeId);\n+                ChannelType channelType = channelTypeProvider.getChannelType(channelTypeUID, null);\n+                String label;\n+                String description;\n+                if (channelType == null) {\n+                    logger.trace(\"Create the channel type {} for item type {}\", channelTypeUID, itemType);\n+                    label = String.format(\"Remote %s Item\", itemType);\n+                    description = String.format(\"An item of type %s from the remote server.\", itemType);\n+                    channelType = ChannelTypeBuilder.state(channelTypeUID, label, itemType).withDescription(description)\n+                            .withAutoUpdatePolicy(AutoUpdatePolicy.VETO).build();\n+                    channelTypeProvider.addChannelType(channelType);\n+                }\n+                ChannelUID channelUID = new ChannelUID(getThing().getUID(), item.name);\n+                logger.trace(\"Create the channel {} of type {}\", channelUID, channelTypeUID);\n+                label = item.name;\n+                description = String.format(\"Item %s from the remote server.\", item.name);\n+                channels.add(ChannelBuilder.create(channelUID, itemType).withType(channelTypeUID)\n+                        .withKind(ChannelKind.STATE).withLabel(label).withDescription(description).build());\n+            }\n+            ThingBuilder thingBuilder = editThing();\n+            if (replace) {\n+                thingBuilder.withChannels(channels);\n+                updateThing(thingBuilder.build());\n+                logger.debug(\"{} channels defined for the thing {} (from {} items including {} groups)\",\n+                        channels.size(), getThing().getUID(), items.size(), nbGroups);\n+            } else if (channels.size() > 0) {\n+                int nbRemoved = 0;\n+                for (Channel channel : channels) {\n+                    if (getThing().getChannel(channel.getUID()) != null) {\n+                        thingBuilder.withoutChannel(channel.getUID());\n+                        nbRemoved++;\n+                    }\n+                }\n+                if (nbRemoved > 0) {\n+                    logger.debug(\"{} channels removed for the thing {} (from {} items)\", nbRemoved, getThing().getUID(),\n+                            items.size());\n+                }\n+                for (Channel channel : channels) {\n+                    thingBuilder.withChannel(channel);\n+                }\n+                updateThing(thingBuilder.build());\n+                if (nbGroups > 0) {\n+                    logger.debug(\"{} channels added for the thing {} (from {} items including {} groups)\",\n+                            channels.size(), getThing().getUID(), items.size(), nbGroups);\n+                } else {\n+                    logger.debug(\"{} channels added for the thing {} (from {} items)\", channels.size(),\n+                            getThing().getUID(), items.size());\n+                }\n+            }\n+        }\n+    }\n+\n+    private void removeChannels(List<Item> items) {\n+        synchronized (updateThingLock) {\n+            int nbRemoved = 0;\n+            ThingBuilder thingBuilder = editThing();\n+            for (Item item : items) {\n+                Channel channel = getThing().getChannel(item.name);\n+                if (channel != null) {\n+                    thingBuilder.withoutChannel(channel.getUID());\n+                    nbRemoved++;\n+                }\n+            }\n+            if (nbRemoved > 0) {\n+                updateThing(thingBuilder.build());\n+                logger.debug(\"{} channels removed for the thing {} (from {} items)\", nbRemoved, getThing().getUID(),\n+                        items.size());\n+            }\n+        }\n+    }\n+\n+    private void setStateOptions(List<Item> items) {\n+        for (Item item : items) {\n+            Channel channel = getThing().getChannel(item.name);\n+            StateDescription descr = item.stateDescription;\n+            List<Option> options = descr == null ? null : descr.options;\n+            if (channel != null && options != null && options.size() > 0) {\n+                List<StateOption> stateOptions = new ArrayList<>();\n+                for (Option option : options) {\n+                    stateOptions.add(new StateOption(option.value, option.label));\n+                }\n+                stateDescriptionProvider.setStateOptions(channel.getUID(), stateOptions);\n+                logger.trace(\"{} options set for the channel {}\", options.size(), channel.getUID());\n+            }\n+        }\n+    }\n+\n+    public void checkConnection(RemoteopenhabRestClient client) {\n+        logger.debug(\"Try the root REST API...\");\n+        try {\n+            client.tryApi();\n+            if (client.getRestApiVersion() == null) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                        \"OH 1.x server not supported by the binding\");\n+            } else {\n+                List<Item> items = client.getRemoteItems();\n+\n+                createChannels(items, true);\n+                setStateOptions(items);\n+                for (Item item : items) {\n+                    updateChannelState(item.name, null, item.state);\n+                }\n+\n+                updateStatus(ThingStatus.ONLINE);\n+\n+                restartStreamingUpdates();\n+            }\n+        } catch (RemoteopenhabException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e.getMessage());\n+            stopStreamingUpdates();\n+        }\n+    }\n+\n+    private void startCheckConnectionJob(RemoteopenhabRestClient client) {\n+        ScheduledFuture<?> localCheckConnectionJob = checkConnectionJob;\n+        if (localCheckConnectionJob == null || localCheckConnectionJob.isCancelled()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTMwMDY0NA=="}, "originalCommit": {"oid": "3dc867e53fe095f9925c318f8b1963318874020d"}, "originalPosition": 313}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIwMjk4MTkzOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.remoteopenhab/src/main/java/org/openhab/binding/remoteopenhab/internal/handler/RemoteopenhabThingHandler.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNFQwNDowMTo0NlrOHnneAA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNFQwOToyMjo1NVrOHnq7AA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTMwMzE2OA==", "bodyText": "Please cache channelState.toFullString() to a local variable.", "url": "https://github.com/openhab/openhab-addons/pull/8791#discussion_r511303168", "createdAt": "2020-10-24T04:01:46Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.remoteopenhab/src/main/java/org/openhab/binding/remoteopenhab/internal/handler/RemoteopenhabThingHandler.java", "diffHunk": "@@ -0,0 +1,535 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.remoteopenhab.internal.handler;\n+\n+import static org.openhab.binding.remoteopenhab.internal.RemoteopenhabBindingConstants.BINDING_ID;\n+\n+import java.time.ZonedDateTime;\n+import java.time.format.DateTimeFormatter;\n+import java.time.format.DateTimeParseException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.ws.rs.client.ClientBuilder;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.remoteopenhab.internal.RemoteopenhabChannelTypeProvider;\n+import org.openhab.binding.remoteopenhab.internal.RemoteopenhabStateDescriptionOptionProvider;\n+import org.openhab.binding.remoteopenhab.internal.config.RemoteopenhabInstanceConfiguration;\n+import org.openhab.binding.remoteopenhab.internal.data.Item;\n+import org.openhab.binding.remoteopenhab.internal.data.Option;\n+import org.openhab.binding.remoteopenhab.internal.data.StateDescription;\n+import org.openhab.binding.remoteopenhab.internal.exceptions.RemoteopenhabException;\n+import org.openhab.binding.remoteopenhab.internal.listener.RemoteopenhabStreamingDataListener;\n+import org.openhab.binding.remoteopenhab.internal.rest.RemoteopenhabRestClient;\n+import org.openhab.core.library.CoreItemFactory;\n+import org.openhab.core.library.types.DateTimeType;\n+import org.openhab.core.library.types.DecimalType;\n+import org.openhab.core.library.types.HSBType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.OpenClosedType;\n+import org.openhab.core.library.types.PercentType;\n+import org.openhab.core.library.types.PlayPauseType;\n+import org.openhab.core.library.types.PointType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.RawType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.builder.ChannelBuilder;\n+import org.openhab.core.thing.binding.builder.ThingBuilder;\n+import org.openhab.core.thing.type.AutoUpdatePolicy;\n+import org.openhab.core.thing.type.ChannelKind;\n+import org.openhab.core.thing.type.ChannelType;\n+import org.openhab.core.thing.type.ChannelTypeBuilder;\n+import org.openhab.core.thing.type.ChannelTypeUID;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.StateOption;\n+import org.openhab.core.types.TypeParser;\n+import org.openhab.core.types.UnDefType;\n+import org.osgi.service.jaxrs.client.SseEventSourceFactory;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+\n+/**\n+ * This bridge handler connects to Nest and handles all the API requests. It pulls down the\n+ * updated data, polls the system and does all the co-ordination with the other handlers\n+ * to get the data updated to the correct things.\n+ *\n+ * @author Laurent Garnier - Initial contribution\n+ */\n+@NonNullByDefault\n+public class RemoteopenhabThingHandler extends BaseThingHandler implements RemoteopenhabStreamingDataListener {\n+\n+    private static final String DATE_FORMAT_PATTERN = \"yyyy-MM-dd'T'HH:mm:ss.SSSZ\";\n+    private static final DateTimeFormatter FORMATTER_DATE = DateTimeFormatter.ofPattern(DATE_FORMAT_PATTERN);\n+\n+    private static final long CONNECTION_TIMEOUT_MILLIS = TimeUnit.MILLISECONDS.convert(5, TimeUnit.MINUTES);\n+\n+    private final Logger logger = LoggerFactory.getLogger(RemoteopenhabThingHandler.class);\n+\n+    private final ClientBuilder clientBuilder;\n+    private final SseEventSourceFactory eventSourceFactory;\n+    private final RemoteopenhabChannelTypeProvider channelTypeProvider;\n+    private final RemoteopenhabStateDescriptionOptionProvider stateDescriptionProvider;\n+    private final Gson jsonParser;\n+\n+    private final Object updateThingLock = new Object();\n+\n+    private @NonNullByDefault({}) RemoteopenhabInstanceConfiguration config;\n+\n+    private @Nullable ScheduledFuture<?> checkConnectionJob;\n+    private @Nullable RemoteopenhabRestClient restClient;\n+\n+    public RemoteopenhabThingHandler(Thing thing, ClientBuilder clientBuilder, SseEventSourceFactory eventSourceFactory,\n+            RemoteopenhabChannelTypeProvider channelTypeProvider,\n+            RemoteopenhabStateDescriptionOptionProvider stateDescriptionProvider, final Gson jsonParser) {\n+        super(thing);\n+        this.clientBuilder = clientBuilder;\n+        this.eventSourceFactory = eventSourceFactory;\n+        this.channelTypeProvider = channelTypeProvider;\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        this.jsonParser = jsonParser;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing remote openHAB thing handler\");\n+\n+        config = getConfigAs(RemoteopenhabInstanceConfiguration.class);\n+\n+        String url = getRestUrl();\n+        if (url.length() == 0 || !url.startsWith(\"http:\")) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"Please setup a HTTP REST URL in the thing configuration\");\n+        } else {\n+            logger.debug(\"REST URL = {}\", url);\n+\n+            RemoteopenhabRestClient client = new RemoteopenhabRestClient(clientBuilder, eventSourceFactory, jsonParser,\n+                    config.token, url);\n+            restClient = client;\n+\n+            updateStatus(ThingStatus.UNKNOWN);\n+\n+            startCheckConnectionJob(client);\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.debug(\"Disposing remote openHAB thing handler\");\n+        stopStreamingUpdates();\n+        stopCheckConnectionJob();\n+        this.restClient = null;\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (getThing().getStatus() != ThingStatus.ONLINE) {\n+            return;\n+        }\n+        RemoteopenhabRestClient client = restClient;\n+        if (client == null) {\n+            return;\n+        }\n+\n+        try {\n+            if (command instanceof RefreshType) {\n+                String state = client.getRemoteItemState(channelUID.getId());\n+                updateChannelState(channelUID.getId(), null, state);\n+            } else if (isLinked(channelUID)) {\n+                client.sendCommandToRemoteItem(channelUID.getId(), command);\n+                logger.debug(\"Sending command {} to remote item {} succeeded\",\n+                        command.toFullString().length() < 50 ? command.toFullString()\n+                                : command.toFullString().substring(0, 50) + \"...\",\n+                        channelUID.getId());\n+            }\n+        } catch (RemoteopenhabException e) {\n+            logger.debug(\"{}\", e.getMessage());\n+        }\n+    }\n+\n+    private String getRestUrl() {\n+        String url = config.restUrl.trim();\n+        if (url.endsWith(\"/\")) {\n+            url = url.substring(0, url.length() - 1);\n+        }\n+        return url;\n+    }\n+\n+    private void createChannels(List<Item> items, boolean replace) {\n+        synchronized (updateThingLock) {\n+            int nbGroups = 0;\n+            List<Channel> channels = new ArrayList<>();\n+            for (Item item : items) {\n+                String itemType = item.type;\n+                if (\"Group\".equals(itemType)) {\n+                    if (item.groupType.isEmpty()) {\n+                        // Standard groups are ignored\n+                        nbGroups++;\n+                        continue;\n+                    } else {\n+                        itemType = item.groupType;\n+                    }\n+                }\n+                String channelTypeId = String.format(\"item%s\", itemType.replace(\":\", \"\"));\n+                ChannelTypeUID channelTypeUID = new ChannelTypeUID(BINDING_ID, channelTypeId);\n+                ChannelType channelType = channelTypeProvider.getChannelType(channelTypeUID, null);\n+                String label;\n+                String description;\n+                if (channelType == null) {\n+                    logger.trace(\"Create the channel type {} for item type {}\", channelTypeUID, itemType);\n+                    label = String.format(\"Remote %s Item\", itemType);\n+                    description = String.format(\"An item of type %s from the remote server.\", itemType);\n+                    channelType = ChannelTypeBuilder.state(channelTypeUID, label, itemType).withDescription(description)\n+                            .withAutoUpdatePolicy(AutoUpdatePolicy.VETO).build();\n+                    channelTypeProvider.addChannelType(channelType);\n+                }\n+                ChannelUID channelUID = new ChannelUID(getThing().getUID(), item.name);\n+                logger.trace(\"Create the channel {} of type {}\", channelUID, channelTypeUID);\n+                label = item.name;\n+                description = String.format(\"Item %s from the remote server.\", item.name);\n+                channels.add(ChannelBuilder.create(channelUID, itemType).withType(channelTypeUID)\n+                        .withKind(ChannelKind.STATE).withLabel(label).withDescription(description).build());\n+            }\n+            ThingBuilder thingBuilder = editThing();\n+            if (replace) {\n+                thingBuilder.withChannels(channels);\n+                updateThing(thingBuilder.build());\n+                logger.debug(\"{} channels defined for the thing {} (from {} items including {} groups)\",\n+                        channels.size(), getThing().getUID(), items.size(), nbGroups);\n+            } else if (channels.size() > 0) {\n+                int nbRemoved = 0;\n+                for (Channel channel : channels) {\n+                    if (getThing().getChannel(channel.getUID()) != null) {\n+                        thingBuilder.withoutChannel(channel.getUID());\n+                        nbRemoved++;\n+                    }\n+                }\n+                if (nbRemoved > 0) {\n+                    logger.debug(\"{} channels removed for the thing {} (from {} items)\", nbRemoved, getThing().getUID(),\n+                            items.size());\n+                }\n+                for (Channel channel : channels) {\n+                    thingBuilder.withChannel(channel);\n+                }\n+                updateThing(thingBuilder.build());\n+                if (nbGroups > 0) {\n+                    logger.debug(\"{} channels added for the thing {} (from {} items including {} groups)\",\n+                            channels.size(), getThing().getUID(), items.size(), nbGroups);\n+                } else {\n+                    logger.debug(\"{} channels added for the thing {} (from {} items)\", channels.size(),\n+                            getThing().getUID(), items.size());\n+                }\n+            }\n+        }\n+    }\n+\n+    private void removeChannels(List<Item> items) {\n+        synchronized (updateThingLock) {\n+            int nbRemoved = 0;\n+            ThingBuilder thingBuilder = editThing();\n+            for (Item item : items) {\n+                Channel channel = getThing().getChannel(item.name);\n+                if (channel != null) {\n+                    thingBuilder.withoutChannel(channel.getUID());\n+                    nbRemoved++;\n+                }\n+            }\n+            if (nbRemoved > 0) {\n+                updateThing(thingBuilder.build());\n+                logger.debug(\"{} channels removed for the thing {} (from {} items)\", nbRemoved, getThing().getUID(),\n+                        items.size());\n+            }\n+        }\n+    }\n+\n+    private void setStateOptions(List<Item> items) {\n+        for (Item item : items) {\n+            Channel channel = getThing().getChannel(item.name);\n+            StateDescription descr = item.stateDescription;\n+            List<Option> options = descr == null ? null : descr.options;\n+            if (channel != null && options != null && options.size() > 0) {\n+                List<StateOption> stateOptions = new ArrayList<>();\n+                for (Option option : options) {\n+                    stateOptions.add(new StateOption(option.value, option.label));\n+                }\n+                stateDescriptionProvider.setStateOptions(channel.getUID(), stateOptions);\n+                logger.trace(\"{} options set for the channel {}\", options.size(), channel.getUID());\n+            }\n+        }\n+    }\n+\n+    public void checkConnection(RemoteopenhabRestClient client) {\n+        logger.debug(\"Try the root REST API...\");\n+        try {\n+            client.tryApi();\n+            if (client.getRestApiVersion() == null) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                        \"OH 1.x server not supported by the binding\");\n+            } else {\n+                List<Item> items = client.getRemoteItems();\n+\n+                createChannels(items, true);\n+                setStateOptions(items);\n+                for (Item item : items) {\n+                    updateChannelState(item.name, null, item.state);\n+                }\n+\n+                updateStatus(ThingStatus.ONLINE);\n+\n+                restartStreamingUpdates();\n+            }\n+        } catch (RemoteopenhabException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e.getMessage());\n+            stopStreamingUpdates();\n+        }\n+    }\n+\n+    private void startCheckConnectionJob(RemoteopenhabRestClient client) {\n+        ScheduledFuture<?> localCheckConnectionJob = checkConnectionJob;\n+        if (localCheckConnectionJob == null || localCheckConnectionJob.isCancelled()) {\n+            checkConnectionJob = scheduler.scheduleWithFixedDelay(() -> {\n+                long millisSinceLastEvent = System.currentTimeMillis() - client.getLastEventTimestamp();\n+                if (millisSinceLastEvent > CONNECTION_TIMEOUT_MILLIS) {\n+                    logger.debug(\"Check: Disconnected from streaming events, millisSinceLastEvent={}\",\n+                            millisSinceLastEvent);\n+                    checkConnection(client);\n+                } else {\n+                    logger.debug(\"Check: Receiving streaming events, millisSinceLastEvent={}\", millisSinceLastEvent);\n+                }\n+            }, 0, CONNECTION_TIMEOUT_MILLIS, TimeUnit.MILLISECONDS);\n+        }\n+    }\n+\n+    private void stopCheckConnectionJob() {\n+        ScheduledFuture<?> localCheckConnectionJob = checkConnectionJob;\n+        if (localCheckConnectionJob != null) {\n+            localCheckConnectionJob.cancel(true);\n+            checkConnectionJob = null;\n+        }\n+    }\n+\n+    private void restartStreamingUpdates() {\n+        synchronized (this) {\n+            stopStreamingUpdates();\n+            startStreamingUpdates();\n+        }\n+    }\n+\n+    private void startStreamingUpdates() {\n+        RemoteopenhabRestClient client = restClient;\n+        if (client != null) {\n+            synchronized (this) {\n+                client.addStreamingDataListener(this);\n+                client.start();\n+            }\n+        }\n+    }\n+\n+    private void stopStreamingUpdates() {\n+        RemoteopenhabRestClient client = restClient;\n+        if (client != null) {\n+            synchronized (this) {\n+                client.stop();\n+                client.removeStreamingDataListener(this);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void onConnected() {\n+        updateStatus(ThingStatus.ONLINE);\n+    }\n+\n+    @Override\n+    public void onError(String message) {\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, message);\n+    }\n+\n+    @Override\n+    public void onItemStateEvent(String itemName, String stateType, String state) {\n+        updateChannelState(itemName, stateType, state);\n+    }\n+\n+    @Override\n+    public void onItemAdded(Item item) {\n+        List<Item> items = new ArrayList<>();\n+        items.add(item);\n+        createChannels(items, false);\n+    }\n+\n+    @Override\n+    public void onItemRemoved(Item item) {\n+        List<Item> items = new ArrayList<>();\n+        items.add(item);\n+        removeChannels(items);\n+    }\n+\n+    @Override\n+    public void onItemUpdated(Item newItem, Item oldItem) {\n+        if (!newItem.type.equals(oldItem.type)) {\n+            List<Item> items = new ArrayList<>();\n+            items.add(newItem);\n+            createChannels(items, false);\n+        } else {\n+            logger.trace(\"Updated remote item {} ignored because item type {} is unchanged\", newItem.name,\n+                    newItem.type);\n+        }\n+    }\n+\n+    private void updateChannelState(String itemName, @Nullable String stateType, String state) {\n+        Channel channel = getThing().getChannel(itemName);\n+        if (channel == null) {\n+            logger.trace(\"No channel for item {}\", itemName);\n+            return;\n+        }\n+        String acceptedItemType = channel.getAcceptedItemType();\n+        if (acceptedItemType == null) {\n+            logger.trace(\"Channel without accepted item type for item {}\", itemName);\n+            return;\n+        }\n+        if (!isLinked(channel.getUID())) {\n+            logger.trace(\"Unlinked channel {}\", channel.getUID());\n+            return;\n+        }\n+        State channelState = null;\n+        if (stateType == null && \"NULL\".equals(state)) {\n+            channelState = UnDefType.NULL;\n+        } else if (stateType == null && \"UNDEF\".equals(state)) {\n+            channelState = UnDefType.UNDEF;\n+        } else if (\"UnDef\".equals(stateType)) {\n+            switch (state) {\n+                case \"NULL\":\n+                    channelState = UnDefType.NULL;\n+                    break;\n+                case \"UNDEF\":\n+                    channelState = UnDefType.UNDEF;\n+                    break;\n+                default:\n+                    logger.debug(\"Invalid UnDef value {} for item {}\", state, itemName);\n+                    break;\n+            }\n+        } else if (acceptedItemType.startsWith(CoreItemFactory.NUMBER + \":\")) {\n+            // Item type Number with dimension\n+            if (checkStateType(itemName, stateType, \"Quantity\")) {\n+                List<Class<? extends State>> stateTypes = Collections.singletonList(QuantityType.class);\n+                channelState = TypeParser.parseState(stateTypes, state);\n+            }\n+        } else {\n+            switch (acceptedItemType) {\n+                case CoreItemFactory.STRING:\n+                    if (checkStateType(itemName, stateType, \"String\")) {\n+                        channelState = new StringType(state);\n+                    }\n+                    break;\n+                case CoreItemFactory.NUMBER:\n+                    if (checkStateType(itemName, stateType, \"Decimal\")) {\n+                        channelState = new DecimalType(state);\n+                    }\n+                    break;\n+                case CoreItemFactory.SWITCH:\n+                    if (checkStateType(itemName, stateType, \"OnOff\")) {\n+                        channelState = \"ON\".equals(state) ? OnOffType.ON : OnOffType.OFF;\n+                    }\n+                    break;\n+                case CoreItemFactory.CONTACT:\n+                    if (checkStateType(itemName, stateType, \"OpenClosed\")) {\n+                        channelState = \"OPEN\".equals(state) ? OpenClosedType.OPEN : OpenClosedType.CLOSED;\n+                    }\n+                    break;\n+                case CoreItemFactory.DIMMER:\n+                    if (checkStateType(itemName, stateType, \"Percent\")) {\n+                        channelState = new PercentType(state);\n+                    }\n+                    break;\n+                case CoreItemFactory.COLOR:\n+                    if (checkStateType(itemName, stateType, \"HSB\")) {\n+                        channelState = HSBType.valueOf(state);\n+                    }\n+                    break;\n+                case CoreItemFactory.DATETIME:\n+                    if (checkStateType(itemName, stateType, \"DateTime\")) {\n+                        try {\n+                            channelState = new DateTimeType(ZonedDateTime.parse(state, FORMATTER_DATE));\n+                        } catch (DateTimeParseException e) {\n+                            logger.debug(\"Failed to parse date {} for item {}\", state, itemName);\n+                            channelState = null;\n+                        }\n+                    }\n+                    break;\n+                case CoreItemFactory.LOCATION:\n+                    if (checkStateType(itemName, stateType, \"Point\")) {\n+                        channelState = new PointType(state);\n+                    }\n+                    break;\n+                case CoreItemFactory.IMAGE:\n+                    if (checkStateType(itemName, stateType, \"Raw\")) {\n+                        channelState = RawType.valueOf(state);\n+                    }\n+                    break;\n+                case CoreItemFactory.PLAYER:\n+                    if (checkStateType(itemName, stateType, \"PlayPause\")) {\n+                        switch (state) {\n+                            case \"PLAY\":\n+                                channelState = PlayPauseType.PLAY;\n+                                break;\n+                            case \"PAUSE\":\n+                                channelState = PlayPauseType.PAUSE;\n+                                break;\n+                            default:\n+                                logger.debug(\"Unexpected value {} for item {}\", state, itemName);\n+                                break;\n+                        }\n+                    }\n+                    break;\n+                case CoreItemFactory.ROLLERSHUTTER:\n+                    if (checkStateType(itemName, stateType, \"Percent\")) {\n+                        channelState = new PercentType(state);\n+                    }\n+                    break;\n+                default:\n+                    logger.debug(\"Item type {} is not yet supported\", acceptedItemType);\n+                    break;\n+            }\n+        }\n+        if (channelState != null) {\n+            updateState(channel.getUID(), channelState);\n+            logger.debug(\"updateState {} with {}\", channel.getUID(),\n+                    channelState.toFullString().length() < 50 ? channelState.toFullString()\n+                            : channelState.toFullString().substring(0, 50) + \"...\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3dc867e53fe095f9925c318f8b1963318874020d"}, "originalPosition": 522}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTM1OTc0NA==", "bodyText": "Done", "url": "https://github.com/openhab/openhab-addons/pull/8791#discussion_r511359744", "createdAt": "2020-10-24T09:22:55Z", "author": {"login": "lolodomo"}, "path": "bundles/org.openhab.binding.remoteopenhab/src/main/java/org/openhab/binding/remoteopenhab/internal/handler/RemoteopenhabThingHandler.java", "diffHunk": "@@ -0,0 +1,535 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.remoteopenhab.internal.handler;\n+\n+import static org.openhab.binding.remoteopenhab.internal.RemoteopenhabBindingConstants.BINDING_ID;\n+\n+import java.time.ZonedDateTime;\n+import java.time.format.DateTimeFormatter;\n+import java.time.format.DateTimeParseException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.ws.rs.client.ClientBuilder;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.remoteopenhab.internal.RemoteopenhabChannelTypeProvider;\n+import org.openhab.binding.remoteopenhab.internal.RemoteopenhabStateDescriptionOptionProvider;\n+import org.openhab.binding.remoteopenhab.internal.config.RemoteopenhabInstanceConfiguration;\n+import org.openhab.binding.remoteopenhab.internal.data.Item;\n+import org.openhab.binding.remoteopenhab.internal.data.Option;\n+import org.openhab.binding.remoteopenhab.internal.data.StateDescription;\n+import org.openhab.binding.remoteopenhab.internal.exceptions.RemoteopenhabException;\n+import org.openhab.binding.remoteopenhab.internal.listener.RemoteopenhabStreamingDataListener;\n+import org.openhab.binding.remoteopenhab.internal.rest.RemoteopenhabRestClient;\n+import org.openhab.core.library.CoreItemFactory;\n+import org.openhab.core.library.types.DateTimeType;\n+import org.openhab.core.library.types.DecimalType;\n+import org.openhab.core.library.types.HSBType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.OpenClosedType;\n+import org.openhab.core.library.types.PercentType;\n+import org.openhab.core.library.types.PlayPauseType;\n+import org.openhab.core.library.types.PointType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.RawType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.builder.ChannelBuilder;\n+import org.openhab.core.thing.binding.builder.ThingBuilder;\n+import org.openhab.core.thing.type.AutoUpdatePolicy;\n+import org.openhab.core.thing.type.ChannelKind;\n+import org.openhab.core.thing.type.ChannelType;\n+import org.openhab.core.thing.type.ChannelTypeBuilder;\n+import org.openhab.core.thing.type.ChannelTypeUID;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.StateOption;\n+import org.openhab.core.types.TypeParser;\n+import org.openhab.core.types.UnDefType;\n+import org.osgi.service.jaxrs.client.SseEventSourceFactory;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+\n+/**\n+ * This bridge handler connects to Nest and handles all the API requests. It pulls down the\n+ * updated data, polls the system and does all the co-ordination with the other handlers\n+ * to get the data updated to the correct things.\n+ *\n+ * @author Laurent Garnier - Initial contribution\n+ */\n+@NonNullByDefault\n+public class RemoteopenhabThingHandler extends BaseThingHandler implements RemoteopenhabStreamingDataListener {\n+\n+    private static final String DATE_FORMAT_PATTERN = \"yyyy-MM-dd'T'HH:mm:ss.SSSZ\";\n+    private static final DateTimeFormatter FORMATTER_DATE = DateTimeFormatter.ofPattern(DATE_FORMAT_PATTERN);\n+\n+    private static final long CONNECTION_TIMEOUT_MILLIS = TimeUnit.MILLISECONDS.convert(5, TimeUnit.MINUTES);\n+\n+    private final Logger logger = LoggerFactory.getLogger(RemoteopenhabThingHandler.class);\n+\n+    private final ClientBuilder clientBuilder;\n+    private final SseEventSourceFactory eventSourceFactory;\n+    private final RemoteopenhabChannelTypeProvider channelTypeProvider;\n+    private final RemoteopenhabStateDescriptionOptionProvider stateDescriptionProvider;\n+    private final Gson jsonParser;\n+\n+    private final Object updateThingLock = new Object();\n+\n+    private @NonNullByDefault({}) RemoteopenhabInstanceConfiguration config;\n+\n+    private @Nullable ScheduledFuture<?> checkConnectionJob;\n+    private @Nullable RemoteopenhabRestClient restClient;\n+\n+    public RemoteopenhabThingHandler(Thing thing, ClientBuilder clientBuilder, SseEventSourceFactory eventSourceFactory,\n+            RemoteopenhabChannelTypeProvider channelTypeProvider,\n+            RemoteopenhabStateDescriptionOptionProvider stateDescriptionProvider, final Gson jsonParser) {\n+        super(thing);\n+        this.clientBuilder = clientBuilder;\n+        this.eventSourceFactory = eventSourceFactory;\n+        this.channelTypeProvider = channelTypeProvider;\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        this.jsonParser = jsonParser;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing remote openHAB thing handler\");\n+\n+        config = getConfigAs(RemoteopenhabInstanceConfiguration.class);\n+\n+        String url = getRestUrl();\n+        if (url.length() == 0 || !url.startsWith(\"http:\")) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"Please setup a HTTP REST URL in the thing configuration\");\n+        } else {\n+            logger.debug(\"REST URL = {}\", url);\n+\n+            RemoteopenhabRestClient client = new RemoteopenhabRestClient(clientBuilder, eventSourceFactory, jsonParser,\n+                    config.token, url);\n+            restClient = client;\n+\n+            updateStatus(ThingStatus.UNKNOWN);\n+\n+            startCheckConnectionJob(client);\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.debug(\"Disposing remote openHAB thing handler\");\n+        stopStreamingUpdates();\n+        stopCheckConnectionJob();\n+        this.restClient = null;\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (getThing().getStatus() != ThingStatus.ONLINE) {\n+            return;\n+        }\n+        RemoteopenhabRestClient client = restClient;\n+        if (client == null) {\n+            return;\n+        }\n+\n+        try {\n+            if (command instanceof RefreshType) {\n+                String state = client.getRemoteItemState(channelUID.getId());\n+                updateChannelState(channelUID.getId(), null, state);\n+            } else if (isLinked(channelUID)) {\n+                client.sendCommandToRemoteItem(channelUID.getId(), command);\n+                logger.debug(\"Sending command {} to remote item {} succeeded\",\n+                        command.toFullString().length() < 50 ? command.toFullString()\n+                                : command.toFullString().substring(0, 50) + \"...\",\n+                        channelUID.getId());\n+            }\n+        } catch (RemoteopenhabException e) {\n+            logger.debug(\"{}\", e.getMessage());\n+        }\n+    }\n+\n+    private String getRestUrl() {\n+        String url = config.restUrl.trim();\n+        if (url.endsWith(\"/\")) {\n+            url = url.substring(0, url.length() - 1);\n+        }\n+        return url;\n+    }\n+\n+    private void createChannels(List<Item> items, boolean replace) {\n+        synchronized (updateThingLock) {\n+            int nbGroups = 0;\n+            List<Channel> channels = new ArrayList<>();\n+            for (Item item : items) {\n+                String itemType = item.type;\n+                if (\"Group\".equals(itemType)) {\n+                    if (item.groupType.isEmpty()) {\n+                        // Standard groups are ignored\n+                        nbGroups++;\n+                        continue;\n+                    } else {\n+                        itemType = item.groupType;\n+                    }\n+                }\n+                String channelTypeId = String.format(\"item%s\", itemType.replace(\":\", \"\"));\n+                ChannelTypeUID channelTypeUID = new ChannelTypeUID(BINDING_ID, channelTypeId);\n+                ChannelType channelType = channelTypeProvider.getChannelType(channelTypeUID, null);\n+                String label;\n+                String description;\n+                if (channelType == null) {\n+                    logger.trace(\"Create the channel type {} for item type {}\", channelTypeUID, itemType);\n+                    label = String.format(\"Remote %s Item\", itemType);\n+                    description = String.format(\"An item of type %s from the remote server.\", itemType);\n+                    channelType = ChannelTypeBuilder.state(channelTypeUID, label, itemType).withDescription(description)\n+                            .withAutoUpdatePolicy(AutoUpdatePolicy.VETO).build();\n+                    channelTypeProvider.addChannelType(channelType);\n+                }\n+                ChannelUID channelUID = new ChannelUID(getThing().getUID(), item.name);\n+                logger.trace(\"Create the channel {} of type {}\", channelUID, channelTypeUID);\n+                label = item.name;\n+                description = String.format(\"Item %s from the remote server.\", item.name);\n+                channels.add(ChannelBuilder.create(channelUID, itemType).withType(channelTypeUID)\n+                        .withKind(ChannelKind.STATE).withLabel(label).withDescription(description).build());\n+            }\n+            ThingBuilder thingBuilder = editThing();\n+            if (replace) {\n+                thingBuilder.withChannels(channels);\n+                updateThing(thingBuilder.build());\n+                logger.debug(\"{} channels defined for the thing {} (from {} items including {} groups)\",\n+                        channels.size(), getThing().getUID(), items.size(), nbGroups);\n+            } else if (channels.size() > 0) {\n+                int nbRemoved = 0;\n+                for (Channel channel : channels) {\n+                    if (getThing().getChannel(channel.getUID()) != null) {\n+                        thingBuilder.withoutChannel(channel.getUID());\n+                        nbRemoved++;\n+                    }\n+                }\n+                if (nbRemoved > 0) {\n+                    logger.debug(\"{} channels removed for the thing {} (from {} items)\", nbRemoved, getThing().getUID(),\n+                            items.size());\n+                }\n+                for (Channel channel : channels) {\n+                    thingBuilder.withChannel(channel);\n+                }\n+                updateThing(thingBuilder.build());\n+                if (nbGroups > 0) {\n+                    logger.debug(\"{} channels added for the thing {} (from {} items including {} groups)\",\n+                            channels.size(), getThing().getUID(), items.size(), nbGroups);\n+                } else {\n+                    logger.debug(\"{} channels added for the thing {} (from {} items)\", channels.size(),\n+                            getThing().getUID(), items.size());\n+                }\n+            }\n+        }\n+    }\n+\n+    private void removeChannels(List<Item> items) {\n+        synchronized (updateThingLock) {\n+            int nbRemoved = 0;\n+            ThingBuilder thingBuilder = editThing();\n+            for (Item item : items) {\n+                Channel channel = getThing().getChannel(item.name);\n+                if (channel != null) {\n+                    thingBuilder.withoutChannel(channel.getUID());\n+                    nbRemoved++;\n+                }\n+            }\n+            if (nbRemoved > 0) {\n+                updateThing(thingBuilder.build());\n+                logger.debug(\"{} channels removed for the thing {} (from {} items)\", nbRemoved, getThing().getUID(),\n+                        items.size());\n+            }\n+        }\n+    }\n+\n+    private void setStateOptions(List<Item> items) {\n+        for (Item item : items) {\n+            Channel channel = getThing().getChannel(item.name);\n+            StateDescription descr = item.stateDescription;\n+            List<Option> options = descr == null ? null : descr.options;\n+            if (channel != null && options != null && options.size() > 0) {\n+                List<StateOption> stateOptions = new ArrayList<>();\n+                for (Option option : options) {\n+                    stateOptions.add(new StateOption(option.value, option.label));\n+                }\n+                stateDescriptionProvider.setStateOptions(channel.getUID(), stateOptions);\n+                logger.trace(\"{} options set for the channel {}\", options.size(), channel.getUID());\n+            }\n+        }\n+    }\n+\n+    public void checkConnection(RemoteopenhabRestClient client) {\n+        logger.debug(\"Try the root REST API...\");\n+        try {\n+            client.tryApi();\n+            if (client.getRestApiVersion() == null) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                        \"OH 1.x server not supported by the binding\");\n+            } else {\n+                List<Item> items = client.getRemoteItems();\n+\n+                createChannels(items, true);\n+                setStateOptions(items);\n+                for (Item item : items) {\n+                    updateChannelState(item.name, null, item.state);\n+                }\n+\n+                updateStatus(ThingStatus.ONLINE);\n+\n+                restartStreamingUpdates();\n+            }\n+        } catch (RemoteopenhabException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e.getMessage());\n+            stopStreamingUpdates();\n+        }\n+    }\n+\n+    private void startCheckConnectionJob(RemoteopenhabRestClient client) {\n+        ScheduledFuture<?> localCheckConnectionJob = checkConnectionJob;\n+        if (localCheckConnectionJob == null || localCheckConnectionJob.isCancelled()) {\n+            checkConnectionJob = scheduler.scheduleWithFixedDelay(() -> {\n+                long millisSinceLastEvent = System.currentTimeMillis() - client.getLastEventTimestamp();\n+                if (millisSinceLastEvent > CONNECTION_TIMEOUT_MILLIS) {\n+                    logger.debug(\"Check: Disconnected from streaming events, millisSinceLastEvent={}\",\n+                            millisSinceLastEvent);\n+                    checkConnection(client);\n+                } else {\n+                    logger.debug(\"Check: Receiving streaming events, millisSinceLastEvent={}\", millisSinceLastEvent);\n+                }\n+            }, 0, CONNECTION_TIMEOUT_MILLIS, TimeUnit.MILLISECONDS);\n+        }\n+    }\n+\n+    private void stopCheckConnectionJob() {\n+        ScheduledFuture<?> localCheckConnectionJob = checkConnectionJob;\n+        if (localCheckConnectionJob != null) {\n+            localCheckConnectionJob.cancel(true);\n+            checkConnectionJob = null;\n+        }\n+    }\n+\n+    private void restartStreamingUpdates() {\n+        synchronized (this) {\n+            stopStreamingUpdates();\n+            startStreamingUpdates();\n+        }\n+    }\n+\n+    private void startStreamingUpdates() {\n+        RemoteopenhabRestClient client = restClient;\n+        if (client != null) {\n+            synchronized (this) {\n+                client.addStreamingDataListener(this);\n+                client.start();\n+            }\n+        }\n+    }\n+\n+    private void stopStreamingUpdates() {\n+        RemoteopenhabRestClient client = restClient;\n+        if (client != null) {\n+            synchronized (this) {\n+                client.stop();\n+                client.removeStreamingDataListener(this);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void onConnected() {\n+        updateStatus(ThingStatus.ONLINE);\n+    }\n+\n+    @Override\n+    public void onError(String message) {\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, message);\n+    }\n+\n+    @Override\n+    public void onItemStateEvent(String itemName, String stateType, String state) {\n+        updateChannelState(itemName, stateType, state);\n+    }\n+\n+    @Override\n+    public void onItemAdded(Item item) {\n+        List<Item> items = new ArrayList<>();\n+        items.add(item);\n+        createChannels(items, false);\n+    }\n+\n+    @Override\n+    public void onItemRemoved(Item item) {\n+        List<Item> items = new ArrayList<>();\n+        items.add(item);\n+        removeChannels(items);\n+    }\n+\n+    @Override\n+    public void onItemUpdated(Item newItem, Item oldItem) {\n+        if (!newItem.type.equals(oldItem.type)) {\n+            List<Item> items = new ArrayList<>();\n+            items.add(newItem);\n+            createChannels(items, false);\n+        } else {\n+            logger.trace(\"Updated remote item {} ignored because item type {} is unchanged\", newItem.name,\n+                    newItem.type);\n+        }\n+    }\n+\n+    private void updateChannelState(String itemName, @Nullable String stateType, String state) {\n+        Channel channel = getThing().getChannel(itemName);\n+        if (channel == null) {\n+            logger.trace(\"No channel for item {}\", itemName);\n+            return;\n+        }\n+        String acceptedItemType = channel.getAcceptedItemType();\n+        if (acceptedItemType == null) {\n+            logger.trace(\"Channel without accepted item type for item {}\", itemName);\n+            return;\n+        }\n+        if (!isLinked(channel.getUID())) {\n+            logger.trace(\"Unlinked channel {}\", channel.getUID());\n+            return;\n+        }\n+        State channelState = null;\n+        if (stateType == null && \"NULL\".equals(state)) {\n+            channelState = UnDefType.NULL;\n+        } else if (stateType == null && \"UNDEF\".equals(state)) {\n+            channelState = UnDefType.UNDEF;\n+        } else if (\"UnDef\".equals(stateType)) {\n+            switch (state) {\n+                case \"NULL\":\n+                    channelState = UnDefType.NULL;\n+                    break;\n+                case \"UNDEF\":\n+                    channelState = UnDefType.UNDEF;\n+                    break;\n+                default:\n+                    logger.debug(\"Invalid UnDef value {} for item {}\", state, itemName);\n+                    break;\n+            }\n+        } else if (acceptedItemType.startsWith(CoreItemFactory.NUMBER + \":\")) {\n+            // Item type Number with dimension\n+            if (checkStateType(itemName, stateType, \"Quantity\")) {\n+                List<Class<? extends State>> stateTypes = Collections.singletonList(QuantityType.class);\n+                channelState = TypeParser.parseState(stateTypes, state);\n+            }\n+        } else {\n+            switch (acceptedItemType) {\n+                case CoreItemFactory.STRING:\n+                    if (checkStateType(itemName, stateType, \"String\")) {\n+                        channelState = new StringType(state);\n+                    }\n+                    break;\n+                case CoreItemFactory.NUMBER:\n+                    if (checkStateType(itemName, stateType, \"Decimal\")) {\n+                        channelState = new DecimalType(state);\n+                    }\n+                    break;\n+                case CoreItemFactory.SWITCH:\n+                    if (checkStateType(itemName, stateType, \"OnOff\")) {\n+                        channelState = \"ON\".equals(state) ? OnOffType.ON : OnOffType.OFF;\n+                    }\n+                    break;\n+                case CoreItemFactory.CONTACT:\n+                    if (checkStateType(itemName, stateType, \"OpenClosed\")) {\n+                        channelState = \"OPEN\".equals(state) ? OpenClosedType.OPEN : OpenClosedType.CLOSED;\n+                    }\n+                    break;\n+                case CoreItemFactory.DIMMER:\n+                    if (checkStateType(itemName, stateType, \"Percent\")) {\n+                        channelState = new PercentType(state);\n+                    }\n+                    break;\n+                case CoreItemFactory.COLOR:\n+                    if (checkStateType(itemName, stateType, \"HSB\")) {\n+                        channelState = HSBType.valueOf(state);\n+                    }\n+                    break;\n+                case CoreItemFactory.DATETIME:\n+                    if (checkStateType(itemName, stateType, \"DateTime\")) {\n+                        try {\n+                            channelState = new DateTimeType(ZonedDateTime.parse(state, FORMATTER_DATE));\n+                        } catch (DateTimeParseException e) {\n+                            logger.debug(\"Failed to parse date {} for item {}\", state, itemName);\n+                            channelState = null;\n+                        }\n+                    }\n+                    break;\n+                case CoreItemFactory.LOCATION:\n+                    if (checkStateType(itemName, stateType, \"Point\")) {\n+                        channelState = new PointType(state);\n+                    }\n+                    break;\n+                case CoreItemFactory.IMAGE:\n+                    if (checkStateType(itemName, stateType, \"Raw\")) {\n+                        channelState = RawType.valueOf(state);\n+                    }\n+                    break;\n+                case CoreItemFactory.PLAYER:\n+                    if (checkStateType(itemName, stateType, \"PlayPause\")) {\n+                        switch (state) {\n+                            case \"PLAY\":\n+                                channelState = PlayPauseType.PLAY;\n+                                break;\n+                            case \"PAUSE\":\n+                                channelState = PlayPauseType.PAUSE;\n+                                break;\n+                            default:\n+                                logger.debug(\"Unexpected value {} for item {}\", state, itemName);\n+                                break;\n+                        }\n+                    }\n+                    break;\n+                case CoreItemFactory.ROLLERSHUTTER:\n+                    if (checkStateType(itemName, stateType, \"Percent\")) {\n+                        channelState = new PercentType(state);\n+                    }\n+                    break;\n+                default:\n+                    logger.debug(\"Item type {} is not yet supported\", acceptedItemType);\n+                    break;\n+            }\n+        }\n+        if (channelState != null) {\n+            updateState(channel.getUID(), channelState);\n+            logger.debug(\"updateState {} with {}\", channel.getUID(),\n+                    channelState.toFullString().length() < 50 ? channelState.toFullString()\n+                            : channelState.toFullString().substring(0, 50) + \"...\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTMwMzE2OA=="}, "originalCommit": {"oid": "3dc867e53fe095f9925c318f8b1963318874020d"}, "originalPosition": 522}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIwMjk5MjkyOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.remoteopenhab/src/main/java/org/openhab/binding/remoteopenhab/internal/handler/RemoteopenhabThingHandler.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNFQwNDowNjozNFrOHnnlpQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNFQwOToyMjo0OFrOHnq61A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTMwNTEyNQ==", "bodyText": "same here", "url": "https://github.com/openhab/openhab-addons/pull/8791#discussion_r511305125", "createdAt": "2020-10-24T04:06:34Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.remoteopenhab/src/main/java/org/openhab/binding/remoteopenhab/internal/handler/RemoteopenhabThingHandler.java", "diffHunk": "@@ -0,0 +1,535 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.remoteopenhab.internal.handler;\n+\n+import static org.openhab.binding.remoteopenhab.internal.RemoteopenhabBindingConstants.BINDING_ID;\n+\n+import java.time.ZonedDateTime;\n+import java.time.format.DateTimeFormatter;\n+import java.time.format.DateTimeParseException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.ws.rs.client.ClientBuilder;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.remoteopenhab.internal.RemoteopenhabChannelTypeProvider;\n+import org.openhab.binding.remoteopenhab.internal.RemoteopenhabStateDescriptionOptionProvider;\n+import org.openhab.binding.remoteopenhab.internal.config.RemoteopenhabInstanceConfiguration;\n+import org.openhab.binding.remoteopenhab.internal.data.Item;\n+import org.openhab.binding.remoteopenhab.internal.data.Option;\n+import org.openhab.binding.remoteopenhab.internal.data.StateDescription;\n+import org.openhab.binding.remoteopenhab.internal.exceptions.RemoteopenhabException;\n+import org.openhab.binding.remoteopenhab.internal.listener.RemoteopenhabStreamingDataListener;\n+import org.openhab.binding.remoteopenhab.internal.rest.RemoteopenhabRestClient;\n+import org.openhab.core.library.CoreItemFactory;\n+import org.openhab.core.library.types.DateTimeType;\n+import org.openhab.core.library.types.DecimalType;\n+import org.openhab.core.library.types.HSBType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.OpenClosedType;\n+import org.openhab.core.library.types.PercentType;\n+import org.openhab.core.library.types.PlayPauseType;\n+import org.openhab.core.library.types.PointType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.RawType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.builder.ChannelBuilder;\n+import org.openhab.core.thing.binding.builder.ThingBuilder;\n+import org.openhab.core.thing.type.AutoUpdatePolicy;\n+import org.openhab.core.thing.type.ChannelKind;\n+import org.openhab.core.thing.type.ChannelType;\n+import org.openhab.core.thing.type.ChannelTypeBuilder;\n+import org.openhab.core.thing.type.ChannelTypeUID;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.StateOption;\n+import org.openhab.core.types.TypeParser;\n+import org.openhab.core.types.UnDefType;\n+import org.osgi.service.jaxrs.client.SseEventSourceFactory;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+\n+/**\n+ * This bridge handler connects to Nest and handles all the API requests. It pulls down the\n+ * updated data, polls the system and does all the co-ordination with the other handlers\n+ * to get the data updated to the correct things.\n+ *\n+ * @author Laurent Garnier - Initial contribution\n+ */\n+@NonNullByDefault\n+public class RemoteopenhabThingHandler extends BaseThingHandler implements RemoteopenhabStreamingDataListener {\n+\n+    private static final String DATE_FORMAT_PATTERN = \"yyyy-MM-dd'T'HH:mm:ss.SSSZ\";\n+    private static final DateTimeFormatter FORMATTER_DATE = DateTimeFormatter.ofPattern(DATE_FORMAT_PATTERN);\n+\n+    private static final long CONNECTION_TIMEOUT_MILLIS = TimeUnit.MILLISECONDS.convert(5, TimeUnit.MINUTES);\n+\n+    private final Logger logger = LoggerFactory.getLogger(RemoteopenhabThingHandler.class);\n+\n+    private final ClientBuilder clientBuilder;\n+    private final SseEventSourceFactory eventSourceFactory;\n+    private final RemoteopenhabChannelTypeProvider channelTypeProvider;\n+    private final RemoteopenhabStateDescriptionOptionProvider stateDescriptionProvider;\n+    private final Gson jsonParser;\n+\n+    private final Object updateThingLock = new Object();\n+\n+    private @NonNullByDefault({}) RemoteopenhabInstanceConfiguration config;\n+\n+    private @Nullable ScheduledFuture<?> checkConnectionJob;\n+    private @Nullable RemoteopenhabRestClient restClient;\n+\n+    public RemoteopenhabThingHandler(Thing thing, ClientBuilder clientBuilder, SseEventSourceFactory eventSourceFactory,\n+            RemoteopenhabChannelTypeProvider channelTypeProvider,\n+            RemoteopenhabStateDescriptionOptionProvider stateDescriptionProvider, final Gson jsonParser) {\n+        super(thing);\n+        this.clientBuilder = clientBuilder;\n+        this.eventSourceFactory = eventSourceFactory;\n+        this.channelTypeProvider = channelTypeProvider;\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        this.jsonParser = jsonParser;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing remote openHAB thing handler\");\n+\n+        config = getConfigAs(RemoteopenhabInstanceConfiguration.class);\n+\n+        String url = getRestUrl();\n+        if (url.length() == 0 || !url.startsWith(\"http:\")) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"Please setup a HTTP REST URL in the thing configuration\");\n+        } else {\n+            logger.debug(\"REST URL = {}\", url);\n+\n+            RemoteopenhabRestClient client = new RemoteopenhabRestClient(clientBuilder, eventSourceFactory, jsonParser,\n+                    config.token, url);\n+            restClient = client;\n+\n+            updateStatus(ThingStatus.UNKNOWN);\n+\n+            startCheckConnectionJob(client);\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.debug(\"Disposing remote openHAB thing handler\");\n+        stopStreamingUpdates();\n+        stopCheckConnectionJob();\n+        this.restClient = null;\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (getThing().getStatus() != ThingStatus.ONLINE) {\n+            return;\n+        }\n+        RemoteopenhabRestClient client = restClient;\n+        if (client == null) {\n+            return;\n+        }\n+\n+        try {\n+            if (command instanceof RefreshType) {\n+                String state = client.getRemoteItemState(channelUID.getId());\n+                updateChannelState(channelUID.getId(), null, state);\n+            } else if (isLinked(channelUID)) {\n+                client.sendCommandToRemoteItem(channelUID.getId(), command);\n+                logger.debug(\"Sending command {} to remote item {} succeeded\",\n+                        command.toFullString().length() < 50 ? command.toFullString()\n+                                : command.toFullString().substring(0, 50) + \"...\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3dc867e53fe095f9925c318f8b1963318874020d"}, "originalPosition": 166}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTM1OTcwMA==", "bodyText": "Done", "url": "https://github.com/openhab/openhab-addons/pull/8791#discussion_r511359700", "createdAt": "2020-10-24T09:22:48Z", "author": {"login": "lolodomo"}, "path": "bundles/org.openhab.binding.remoteopenhab/src/main/java/org/openhab/binding/remoteopenhab/internal/handler/RemoteopenhabThingHandler.java", "diffHunk": "@@ -0,0 +1,535 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.remoteopenhab.internal.handler;\n+\n+import static org.openhab.binding.remoteopenhab.internal.RemoteopenhabBindingConstants.BINDING_ID;\n+\n+import java.time.ZonedDateTime;\n+import java.time.format.DateTimeFormatter;\n+import java.time.format.DateTimeParseException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.ws.rs.client.ClientBuilder;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.remoteopenhab.internal.RemoteopenhabChannelTypeProvider;\n+import org.openhab.binding.remoteopenhab.internal.RemoteopenhabStateDescriptionOptionProvider;\n+import org.openhab.binding.remoteopenhab.internal.config.RemoteopenhabInstanceConfiguration;\n+import org.openhab.binding.remoteopenhab.internal.data.Item;\n+import org.openhab.binding.remoteopenhab.internal.data.Option;\n+import org.openhab.binding.remoteopenhab.internal.data.StateDescription;\n+import org.openhab.binding.remoteopenhab.internal.exceptions.RemoteopenhabException;\n+import org.openhab.binding.remoteopenhab.internal.listener.RemoteopenhabStreamingDataListener;\n+import org.openhab.binding.remoteopenhab.internal.rest.RemoteopenhabRestClient;\n+import org.openhab.core.library.CoreItemFactory;\n+import org.openhab.core.library.types.DateTimeType;\n+import org.openhab.core.library.types.DecimalType;\n+import org.openhab.core.library.types.HSBType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.OpenClosedType;\n+import org.openhab.core.library.types.PercentType;\n+import org.openhab.core.library.types.PlayPauseType;\n+import org.openhab.core.library.types.PointType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.RawType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.builder.ChannelBuilder;\n+import org.openhab.core.thing.binding.builder.ThingBuilder;\n+import org.openhab.core.thing.type.AutoUpdatePolicy;\n+import org.openhab.core.thing.type.ChannelKind;\n+import org.openhab.core.thing.type.ChannelType;\n+import org.openhab.core.thing.type.ChannelTypeBuilder;\n+import org.openhab.core.thing.type.ChannelTypeUID;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.StateOption;\n+import org.openhab.core.types.TypeParser;\n+import org.openhab.core.types.UnDefType;\n+import org.osgi.service.jaxrs.client.SseEventSourceFactory;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+\n+/**\n+ * This bridge handler connects to Nest and handles all the API requests. It pulls down the\n+ * updated data, polls the system and does all the co-ordination with the other handlers\n+ * to get the data updated to the correct things.\n+ *\n+ * @author Laurent Garnier - Initial contribution\n+ */\n+@NonNullByDefault\n+public class RemoteopenhabThingHandler extends BaseThingHandler implements RemoteopenhabStreamingDataListener {\n+\n+    private static final String DATE_FORMAT_PATTERN = \"yyyy-MM-dd'T'HH:mm:ss.SSSZ\";\n+    private static final DateTimeFormatter FORMATTER_DATE = DateTimeFormatter.ofPattern(DATE_FORMAT_PATTERN);\n+\n+    private static final long CONNECTION_TIMEOUT_MILLIS = TimeUnit.MILLISECONDS.convert(5, TimeUnit.MINUTES);\n+\n+    private final Logger logger = LoggerFactory.getLogger(RemoteopenhabThingHandler.class);\n+\n+    private final ClientBuilder clientBuilder;\n+    private final SseEventSourceFactory eventSourceFactory;\n+    private final RemoteopenhabChannelTypeProvider channelTypeProvider;\n+    private final RemoteopenhabStateDescriptionOptionProvider stateDescriptionProvider;\n+    private final Gson jsonParser;\n+\n+    private final Object updateThingLock = new Object();\n+\n+    private @NonNullByDefault({}) RemoteopenhabInstanceConfiguration config;\n+\n+    private @Nullable ScheduledFuture<?> checkConnectionJob;\n+    private @Nullable RemoteopenhabRestClient restClient;\n+\n+    public RemoteopenhabThingHandler(Thing thing, ClientBuilder clientBuilder, SseEventSourceFactory eventSourceFactory,\n+            RemoteopenhabChannelTypeProvider channelTypeProvider,\n+            RemoteopenhabStateDescriptionOptionProvider stateDescriptionProvider, final Gson jsonParser) {\n+        super(thing);\n+        this.clientBuilder = clientBuilder;\n+        this.eventSourceFactory = eventSourceFactory;\n+        this.channelTypeProvider = channelTypeProvider;\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        this.jsonParser = jsonParser;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing remote openHAB thing handler\");\n+\n+        config = getConfigAs(RemoteopenhabInstanceConfiguration.class);\n+\n+        String url = getRestUrl();\n+        if (url.length() == 0 || !url.startsWith(\"http:\")) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"Please setup a HTTP REST URL in the thing configuration\");\n+        } else {\n+            logger.debug(\"REST URL = {}\", url);\n+\n+            RemoteopenhabRestClient client = new RemoteopenhabRestClient(clientBuilder, eventSourceFactory, jsonParser,\n+                    config.token, url);\n+            restClient = client;\n+\n+            updateStatus(ThingStatus.UNKNOWN);\n+\n+            startCheckConnectionJob(client);\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.debug(\"Disposing remote openHAB thing handler\");\n+        stopStreamingUpdates();\n+        stopCheckConnectionJob();\n+        this.restClient = null;\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (getThing().getStatus() != ThingStatus.ONLINE) {\n+            return;\n+        }\n+        RemoteopenhabRestClient client = restClient;\n+        if (client == null) {\n+            return;\n+        }\n+\n+        try {\n+            if (command instanceof RefreshType) {\n+                String state = client.getRemoteItemState(channelUID.getId());\n+                updateChannelState(channelUID.getId(), null, state);\n+            } else if (isLinked(channelUID)) {\n+                client.sendCommandToRemoteItem(channelUID.getId(), command);\n+                logger.debug(\"Sending command {} to remote item {} succeeded\",\n+                        command.toFullString().length() < 50 ? command.toFullString()\n+                                : command.toFullString().substring(0, 50) + \"...\",", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTMwNTEyNQ=="}, "originalCommit": {"oid": "3dc867e53fe095f9925c318f8b1963318874020d"}, "originalPosition": 166}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIwMjk5NTg2OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.remoteopenhab/src/main/java/org/openhab/binding/remoteopenhab/internal/handler/RemoteopenhabThingHandler.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNFQwNDowNzo0NVrOHnnn5Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNFQwOToyMjozOVrOHnq6hw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTMwNTcwMQ==", "bodyText": "I think this javadoc needs to be updated", "url": "https://github.com/openhab/openhab-addons/pull/8791#discussion_r511305701", "createdAt": "2020-10-24T04:07:45Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.remoteopenhab/src/main/java/org/openhab/binding/remoteopenhab/internal/handler/RemoteopenhabThingHandler.java", "diffHunk": "@@ -0,0 +1,535 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.remoteopenhab.internal.handler;\n+\n+import static org.openhab.binding.remoteopenhab.internal.RemoteopenhabBindingConstants.BINDING_ID;\n+\n+import java.time.ZonedDateTime;\n+import java.time.format.DateTimeFormatter;\n+import java.time.format.DateTimeParseException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.ws.rs.client.ClientBuilder;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.remoteopenhab.internal.RemoteopenhabChannelTypeProvider;\n+import org.openhab.binding.remoteopenhab.internal.RemoteopenhabStateDescriptionOptionProvider;\n+import org.openhab.binding.remoteopenhab.internal.config.RemoteopenhabInstanceConfiguration;\n+import org.openhab.binding.remoteopenhab.internal.data.Item;\n+import org.openhab.binding.remoteopenhab.internal.data.Option;\n+import org.openhab.binding.remoteopenhab.internal.data.StateDescription;\n+import org.openhab.binding.remoteopenhab.internal.exceptions.RemoteopenhabException;\n+import org.openhab.binding.remoteopenhab.internal.listener.RemoteopenhabStreamingDataListener;\n+import org.openhab.binding.remoteopenhab.internal.rest.RemoteopenhabRestClient;\n+import org.openhab.core.library.CoreItemFactory;\n+import org.openhab.core.library.types.DateTimeType;\n+import org.openhab.core.library.types.DecimalType;\n+import org.openhab.core.library.types.HSBType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.OpenClosedType;\n+import org.openhab.core.library.types.PercentType;\n+import org.openhab.core.library.types.PlayPauseType;\n+import org.openhab.core.library.types.PointType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.RawType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.builder.ChannelBuilder;\n+import org.openhab.core.thing.binding.builder.ThingBuilder;\n+import org.openhab.core.thing.type.AutoUpdatePolicy;\n+import org.openhab.core.thing.type.ChannelKind;\n+import org.openhab.core.thing.type.ChannelType;\n+import org.openhab.core.thing.type.ChannelTypeBuilder;\n+import org.openhab.core.thing.type.ChannelTypeUID;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.StateOption;\n+import org.openhab.core.types.TypeParser;\n+import org.openhab.core.types.UnDefType;\n+import org.osgi.service.jaxrs.client.SseEventSourceFactory;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+\n+/**\n+ * This bridge handler connects to Nest and handles all the API requests. It pulls down the\n+ * updated data, polls the system and does all the co-ordination with the other handlers\n+ * to get the data updated to the correct things.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3dc867e53fe095f9925c318f8b1963318874020d"}, "originalPosition": 79}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTM1NDc2Nw==", "bodyText": "You see where was my initial inspiration :)", "url": "https://github.com/openhab/openhab-addons/pull/8791#discussion_r511354767", "createdAt": "2020-10-24T09:11:21Z", "author": {"login": "lolodomo"}, "path": "bundles/org.openhab.binding.remoteopenhab/src/main/java/org/openhab/binding/remoteopenhab/internal/handler/RemoteopenhabThingHandler.java", "diffHunk": "@@ -0,0 +1,535 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.remoteopenhab.internal.handler;\n+\n+import static org.openhab.binding.remoteopenhab.internal.RemoteopenhabBindingConstants.BINDING_ID;\n+\n+import java.time.ZonedDateTime;\n+import java.time.format.DateTimeFormatter;\n+import java.time.format.DateTimeParseException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.ws.rs.client.ClientBuilder;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.remoteopenhab.internal.RemoteopenhabChannelTypeProvider;\n+import org.openhab.binding.remoteopenhab.internal.RemoteopenhabStateDescriptionOptionProvider;\n+import org.openhab.binding.remoteopenhab.internal.config.RemoteopenhabInstanceConfiguration;\n+import org.openhab.binding.remoteopenhab.internal.data.Item;\n+import org.openhab.binding.remoteopenhab.internal.data.Option;\n+import org.openhab.binding.remoteopenhab.internal.data.StateDescription;\n+import org.openhab.binding.remoteopenhab.internal.exceptions.RemoteopenhabException;\n+import org.openhab.binding.remoteopenhab.internal.listener.RemoteopenhabStreamingDataListener;\n+import org.openhab.binding.remoteopenhab.internal.rest.RemoteopenhabRestClient;\n+import org.openhab.core.library.CoreItemFactory;\n+import org.openhab.core.library.types.DateTimeType;\n+import org.openhab.core.library.types.DecimalType;\n+import org.openhab.core.library.types.HSBType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.OpenClosedType;\n+import org.openhab.core.library.types.PercentType;\n+import org.openhab.core.library.types.PlayPauseType;\n+import org.openhab.core.library.types.PointType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.RawType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.builder.ChannelBuilder;\n+import org.openhab.core.thing.binding.builder.ThingBuilder;\n+import org.openhab.core.thing.type.AutoUpdatePolicy;\n+import org.openhab.core.thing.type.ChannelKind;\n+import org.openhab.core.thing.type.ChannelType;\n+import org.openhab.core.thing.type.ChannelTypeBuilder;\n+import org.openhab.core.thing.type.ChannelTypeUID;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.StateOption;\n+import org.openhab.core.types.TypeParser;\n+import org.openhab.core.types.UnDefType;\n+import org.osgi.service.jaxrs.client.SseEventSourceFactory;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+\n+/**\n+ * This bridge handler connects to Nest and handles all the API requests. It pulls down the\n+ * updated data, polls the system and does all the co-ordination with the other handlers\n+ * to get the data updated to the correct things.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTMwNTcwMQ=="}, "originalCommit": {"oid": "3dc867e53fe095f9925c318f8b1963318874020d"}, "originalPosition": 79}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTM1OTYyMw==", "bodyText": "Done", "url": "https://github.com/openhab/openhab-addons/pull/8791#discussion_r511359623", "createdAt": "2020-10-24T09:22:39Z", "author": {"login": "lolodomo"}, "path": "bundles/org.openhab.binding.remoteopenhab/src/main/java/org/openhab/binding/remoteopenhab/internal/handler/RemoteopenhabThingHandler.java", "diffHunk": "@@ -0,0 +1,535 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.remoteopenhab.internal.handler;\n+\n+import static org.openhab.binding.remoteopenhab.internal.RemoteopenhabBindingConstants.BINDING_ID;\n+\n+import java.time.ZonedDateTime;\n+import java.time.format.DateTimeFormatter;\n+import java.time.format.DateTimeParseException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.ws.rs.client.ClientBuilder;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.remoteopenhab.internal.RemoteopenhabChannelTypeProvider;\n+import org.openhab.binding.remoteopenhab.internal.RemoteopenhabStateDescriptionOptionProvider;\n+import org.openhab.binding.remoteopenhab.internal.config.RemoteopenhabInstanceConfiguration;\n+import org.openhab.binding.remoteopenhab.internal.data.Item;\n+import org.openhab.binding.remoteopenhab.internal.data.Option;\n+import org.openhab.binding.remoteopenhab.internal.data.StateDescription;\n+import org.openhab.binding.remoteopenhab.internal.exceptions.RemoteopenhabException;\n+import org.openhab.binding.remoteopenhab.internal.listener.RemoteopenhabStreamingDataListener;\n+import org.openhab.binding.remoteopenhab.internal.rest.RemoteopenhabRestClient;\n+import org.openhab.core.library.CoreItemFactory;\n+import org.openhab.core.library.types.DateTimeType;\n+import org.openhab.core.library.types.DecimalType;\n+import org.openhab.core.library.types.HSBType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.OpenClosedType;\n+import org.openhab.core.library.types.PercentType;\n+import org.openhab.core.library.types.PlayPauseType;\n+import org.openhab.core.library.types.PointType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.RawType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.builder.ChannelBuilder;\n+import org.openhab.core.thing.binding.builder.ThingBuilder;\n+import org.openhab.core.thing.type.AutoUpdatePolicy;\n+import org.openhab.core.thing.type.ChannelKind;\n+import org.openhab.core.thing.type.ChannelType;\n+import org.openhab.core.thing.type.ChannelTypeBuilder;\n+import org.openhab.core.thing.type.ChannelTypeUID;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.StateOption;\n+import org.openhab.core.types.TypeParser;\n+import org.openhab.core.types.UnDefType;\n+import org.osgi.service.jaxrs.client.SseEventSourceFactory;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+\n+/**\n+ * This bridge handler connects to Nest and handles all the API requests. It pulls down the\n+ * updated data, polls the system and does all the co-ordination with the other handlers\n+ * to get the data updated to the correct things.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTMwNTcwMQ=="}, "originalCommit": {"oid": "3dc867e53fe095f9925c318f8b1963318874020d"}, "originalPosition": 79}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIwNDQxMDcyOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.remoteopenhab/README.md", "isResolved": false, "comments": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNFQyMTo0MjowM1rOHn0ikw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNlQyMjo0NTozMlrOHu_1Fg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTUxNzMzMQ==", "bodyText": "May I ask why? Could that maybe be an optional configuration parameter, if people would like to have encrypted traffic in their local network?", "url": "https://github.com/openhab/openhab-addons/pull/8791#discussion_r511517331", "createdAt": "2020-10-24T21:42:03Z", "author": {"login": "kaikreuzer"}, "path": "bundles/org.openhab.binding.remoteopenhab/README.md", "diffHunk": "@@ -0,0 +1,64 @@\n+# Remote openHAB Binding\n+\n+The Remote openHAB binding allows to communicate with remote openHAB servers.\n+The communication is bidirectional.\n+The binding on the local server listens to any item state updates on the remote server and updates accordingly the linked channel on the local server.\n+It also transfers any item command from the local server to the remote server.\n+\n+One first usage is the distribution of your home automation system on a set of openHAB servers.\n+\n+A second usage is for users having old openHAB v1 bindings running that were not migrated to openHAB v2 or openHAB v3.\n+They can keep an openHAB v2 server to run their old openHAB v1 bindings and setup a new openHAB v3 server for everything else.\n+The Remote openHAB binding installed on the openHAB v3 server will then allow to use the openHAB v1 bindings through communication with the openHAB v2 server.\n+\n+A third usage is for users that would like to keep unchanged an existing openHAB v2 server but would like to use the new UI from openHAB v3; they can simply setup a new openHAB v3 server with the Remote openHAB binding linked to their openHAB v2 server.\n+\n+## Supported Things\n+\n+There is one unique supported thing : the `server` bridge thing \n+\n+## Discovery\n+\n+All openHAB servers in the local network are automatically discovered (through mDNS) by the binding.\n+You will find in the inbox one discovery thing per remote server interface.\n+So if your remote server has one IPv4 address and one IPv6 address, you will discover two things in the inbox.\n+Just choose one of the two things.\n+\n+## Binding Configuration\n+\n+The binding has no configuration options, all configuration is done at Thing level.\n+\n+## Thing Configuration\n+\n+The thing has the following configuration parameters:\n+\n+| Parameter | Required | Description                                                                                            |\n+|-----------|-------------------------------------------------------------------------------------------------------------------|\n+| restUrl   | yes      | The REST URL of the remote openHAB server.                                                             |\n+| token     | no       | The token to use when the remote openHAB server is setup to require authorization to run its REST API. |\n+\n+## Channels\n+\n+The channels are built dynamically and automatically by the binding.\n+One channel is created for each item from the remote server.\n+Only basic groups (with no state) are ignored.\n+The channel id of the built channel corresponds to the name of the item on the remote server.\n+\n+## Limitations\n+\n+* The binding will not try to communicate with an openHAB v1 server.\n+* The binding only uses the HTTP protocol for the communications with the remote server (not HTTPS).", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "81f2e2faf5d54ee22f8c579d08c37ef95508e197"}, "originalPosition": 50}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTUyMTcxMw==", "bodyText": "It is just not yet implemented.\nExcept for SSE, I am using HttpUtil.executeUrl to call the REST API. This utility method from the core framework does not work if you pass a HTTPS URL.\nThis would probably require to define a dedicated HttpClient with a SSL context.\nBut this was not my priority.", "url": "https://github.com/openhab/openhab-addons/pull/8791#discussion_r511521713", "createdAt": "2020-10-24T22:39:07Z", "author": {"login": "lolodomo"}, "path": "bundles/org.openhab.binding.remoteopenhab/README.md", "diffHunk": "@@ -0,0 +1,64 @@\n+# Remote openHAB Binding\n+\n+The Remote openHAB binding allows to communicate with remote openHAB servers.\n+The communication is bidirectional.\n+The binding on the local server listens to any item state updates on the remote server and updates accordingly the linked channel on the local server.\n+It also transfers any item command from the local server to the remote server.\n+\n+One first usage is the distribution of your home automation system on a set of openHAB servers.\n+\n+A second usage is for users having old openHAB v1 bindings running that were not migrated to openHAB v2 or openHAB v3.\n+They can keep an openHAB v2 server to run their old openHAB v1 bindings and setup a new openHAB v3 server for everything else.\n+The Remote openHAB binding installed on the openHAB v3 server will then allow to use the openHAB v1 bindings through communication with the openHAB v2 server.\n+\n+A third usage is for users that would like to keep unchanged an existing openHAB v2 server but would like to use the new UI from openHAB v3; they can simply setup a new openHAB v3 server with the Remote openHAB binding linked to their openHAB v2 server.\n+\n+## Supported Things\n+\n+There is one unique supported thing : the `server` bridge thing \n+\n+## Discovery\n+\n+All openHAB servers in the local network are automatically discovered (through mDNS) by the binding.\n+You will find in the inbox one discovery thing per remote server interface.\n+So if your remote server has one IPv4 address and one IPv6 address, you will discover two things in the inbox.\n+Just choose one of the two things.\n+\n+## Binding Configuration\n+\n+The binding has no configuration options, all configuration is done at Thing level.\n+\n+## Thing Configuration\n+\n+The thing has the following configuration parameters:\n+\n+| Parameter | Required | Description                                                                                            |\n+|-----------|-------------------------------------------------------------------------------------------------------------------|\n+| restUrl   | yes      | The REST URL of the remote openHAB server.                                                             |\n+| token     | no       | The token to use when the remote openHAB server is setup to require authorization to run its REST API. |\n+\n+## Channels\n+\n+The channels are built dynamically and automatically by the binding.\n+One channel is created for each item from the remote server.\n+Only basic groups (with no state) are ignored.\n+The channel id of the built channel corresponds to the name of the item on the remote server.\n+\n+## Limitations\n+\n+* The binding will not try to communicate with an openHAB v1 server.\n+* The binding only uses the HTTP protocol for the communications with the remote server (not HTTPS).", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTUxNzMzMQ=="}, "originalCommit": {"oid": "81f2e2faf5d54ee22f8c579d08c37ef95508e197"}, "originalPosition": 50}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTY0MTY0NQ==", "bodyText": "Ok, I see. I guess this is because of the self-signed certificate, so that the HttpUtil does not consider the connection to be secure.", "url": "https://github.com/openhab/openhab-addons/pull/8791#discussion_r511641645", "createdAt": "2020-10-25T20:01:28Z", "author": {"login": "kaikreuzer"}, "path": "bundles/org.openhab.binding.remoteopenhab/README.md", "diffHunk": "@@ -0,0 +1,64 @@\n+# Remote openHAB Binding\n+\n+The Remote openHAB binding allows to communicate with remote openHAB servers.\n+The communication is bidirectional.\n+The binding on the local server listens to any item state updates on the remote server and updates accordingly the linked channel on the local server.\n+It also transfers any item command from the local server to the remote server.\n+\n+One first usage is the distribution of your home automation system on a set of openHAB servers.\n+\n+A second usage is for users having old openHAB v1 bindings running that were not migrated to openHAB v2 or openHAB v3.\n+They can keep an openHAB v2 server to run their old openHAB v1 bindings and setup a new openHAB v3 server for everything else.\n+The Remote openHAB binding installed on the openHAB v3 server will then allow to use the openHAB v1 bindings through communication with the openHAB v2 server.\n+\n+A third usage is for users that would like to keep unchanged an existing openHAB v2 server but would like to use the new UI from openHAB v3; they can simply setup a new openHAB v3 server with the Remote openHAB binding linked to their openHAB v2 server.\n+\n+## Supported Things\n+\n+There is one unique supported thing : the `server` bridge thing \n+\n+## Discovery\n+\n+All openHAB servers in the local network are automatically discovered (through mDNS) by the binding.\n+You will find in the inbox one discovery thing per remote server interface.\n+So if your remote server has one IPv4 address and one IPv6 address, you will discover two things in the inbox.\n+Just choose one of the two things.\n+\n+## Binding Configuration\n+\n+The binding has no configuration options, all configuration is done at Thing level.\n+\n+## Thing Configuration\n+\n+The thing has the following configuration parameters:\n+\n+| Parameter | Required | Description                                                                                            |\n+|-----------|-------------------------------------------------------------------------------------------------------------------|\n+| restUrl   | yes      | The REST URL of the remote openHAB server.                                                             |\n+| token     | no       | The token to use when the remote openHAB server is setup to require authorization to run its REST API. |\n+\n+## Channels\n+\n+The channels are built dynamically and automatically by the binding.\n+One channel is created for each item from the remote server.\n+Only basic groups (with no state) are ignored.\n+The channel id of the built channel corresponds to the name of the item on the remote server.\n+\n+## Limitations\n+\n+* The binding will not try to communicate with an openHAB v1 server.\n+* The binding only uses the HTTP protocol for the communications with the remote server (not HTTPS).", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTUxNzMzMQ=="}, "originalCommit": {"oid": "81f2e2faf5d54ee22f8c579d08c37ef95508e197"}, "originalPosition": 50}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTY2Mjk4Mw==", "bodyText": "FYI, here is the exception I got. Note that I have no certificate set for my servers. Maybe it will work for users having a real certificate.\norg.openhab.binding.remoteopenhab.internal.exceptions.RemoteopenhabException: Failed to execute the root REST API\n\tat org.openhab.binding.remoteopenhab.internal.rest.RemoteopenhabRestClient.tryApi(RemoteopenhabRestClient.java:119)\n\tat org.openhab.binding.remoteopenhab.internal.handler.RemoteopenhabBridgeHandler.checkConnection(RemoteopenhabBridgeHandler.java:320)\n\tat org.openhab.binding.remoteopenhab.internal.handler.RemoteopenhabBridgeHandler.lambda$2(RemoteopenhabBridgeHandler.java:352)\n\tat java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:515)\n\tat java.base/java.util.concurrent.FutureTask.runAndReset(FutureTask.java:305)\n\tat java.base/java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:305)\n\tat java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128)\n\tat java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628)\n\tat java.base/java.lang.Thread.run(Thread.java:834)\nCaused by: java.io.IOException: java.util.concurrent.ExecutionException: javax.net.ssl.SSLHandshakeException: PKIX path building failed: sun.security.provider.certpath.SunCertPathBuilderException: unable to find valid certification path to requested target\n\tat org.openhab.core.io.net.http.HttpUtil.executeUrlAndGetReponse(HttpUtil.java:260)\n\tat org.openhab.core.io.net.http.HttpUtil.executeUrl(HttpUtil.java:156)\n\tat org.openhab.core.io.net.http.HttpUtil.executeUrl(HttpUtil.java:131)\n\tat org.openhab.binding.remoteopenhab.internal.rest.RemoteopenhabRestClient.tryApi(RemoteopenhabRestClient.java:95)\n\t... 8 common frames omitted\nCaused by: java.util.concurrent.ExecutionException: javax.net.ssl.SSLHandshakeException: PKIX path building failed: sun.security.provider.certpath.SunCertPathBuilderException: unable to find valid certification path to requested target\n\tat org.eclipse.jetty.client.util.FutureResponseListener.getResult(FutureResponseListener.java:118)\n\tat org.eclipse.jetty.client.util.FutureResponseListener.get(FutureResponseListener.java:101)\n\tat org.eclipse.jetty.client.HttpRequest.send(HttpRequest.java:685)\n\tat org.openhab.core.io.net.http.HttpUtil.executeUrlAndGetReponse(HttpUtil.java:251)\n\t... 11 common frames omitted\nCaused by: javax.net.ssl.SSLHandshakeException: PKIX path building failed: sun.security.provider.certpath.SunCertPathBuilderException: unable to find valid certification path to requested target\n\tat java.base/sun.security.ssl.Alert.createSSLException(Alert.java:131)\n\tat java.base/sun.security.ssl.TransportContext.fatal(TransportContext.java:326)\n\tat java.base/sun.security.ssl.TransportContext.fatal(TransportContext.java:269)\n\tat java.base/sun.security.ssl.TransportContext.fatal(TransportContext.java:264)\n\tat java.base/sun.security.ssl.CertificateMessage$T12CertificateConsumer.checkServerCerts(CertificateMessage.java:645)\n\tat java.base/sun.security.ssl.CertificateMessage$T12CertificateConsumer.onCertificate(CertificateMessage.java:464)\n\tat java.base/sun.security.ssl.CertificateMessage$T12CertificateConsumer.consume(CertificateMessage.java:360)\n\tat java.base/sun.security.ssl.SSLHandshake.consume(SSLHandshake.java:392)\n\tat java.base/sun.security.ssl.HandshakeContext.dispatch(HandshakeContext.java:444)\n\tat java.base/sun.security.ssl.SSLEngineImpl$DelegatedTask$DelegatedAction.run(SSLEngineImpl.java:1074)\n\tat java.base/sun.security.ssl.SSLEngineImpl$DelegatedTask$DelegatedAction.run(SSLEngineImpl.java:1061)\n\tat java.base/java.security.AccessController.doPrivileged(Native Method)\n\tat java.base/sun.security.ssl.SSLEngineImpl$DelegatedTask.run(SSLEngineImpl.java:1008)\n\tat org.eclipse.jetty.io.ssl.SslConnection$DecryptedEndPoint.fill(SslConnection.java:526)\n\tat org.eclipse.jetty.client.http.HttpReceiverOverHTTP.process(HttpReceiverOverHTTP.java:128)\n\tat org.eclipse.jetty.client.http.HttpReceiverOverHTTP.receive(HttpReceiverOverHTTP.java:73)\n\tat org.eclipse.jetty.client.http.HttpChannelOverHTTP.receive(HttpChannelOverHTTP.java:133)\n\tat org.eclipse.jetty.client.http.HttpConnectionOverHTTP.onFillable(HttpConnectionOverHTTP.java:154)\n\tat org.eclipse.jetty.io.AbstractConnection$ReadCallback.succeeded(AbstractConnection.java:311)\n\tat org.eclipse.jetty.io.FillInterest.fillable(FillInterest.java:103)\n\tat org.eclipse.jetty.io.ssl.SslConnection$DecryptedEndPoint.onFillable(SslConnection.java:426)\n\tat org.eclipse.jetty.io.ssl.SslConnection.onFillable(SslConnection.java:320)\n\tat org.eclipse.jetty.io.ssl.SslConnection$2.succeeded(SslConnection.java:158)\n\tat org.eclipse.jetty.io.FillInterest.fillable(FillInterest.java:103)\n\tat org.eclipse.jetty.io.ChannelEndPoint$2.run(ChannelEndPoint.java:117)\n\tat org.eclipse.jetty.util.thread.QueuedThreadPool.runJob(QueuedThreadPool.java:782)\n\tat org.eclipse.jetty.util.thread.QueuedThreadPool$Runner.run(QueuedThreadPool.java:918)\n\t... 1 common frames omitted\nCaused by: sun.security.validator.ValidatorException: PKIX path building failed: sun.security.provider.certpath.SunCertPathBuilderException: unable to find valid certification path to requested target\n\tat java.base/sun.security.validator.PKIXValidator.doBuild(PKIXValidator.java:439)\n\tat java.base/sun.security.validator.PKIXValidator.engineValidate(PKIXValidator.java:306)\n\tat java.base/sun.security.validator.Validator.validate(Validator.java:264)\n\tat java.base/sun.security.ssl.X509TrustManagerImpl.validate(X509TrustManagerImpl.java:313)\n\tat java.base/sun.security.ssl.X509TrustManagerImpl.checkTrusted(X509TrustManagerImpl.java:276)\n\tat java.base/sun.security.ssl.X509TrustManagerImpl.checkServerTrusted(X509TrustManagerImpl.java:141)\n\tat org.openhab.core.io.net.http.internal.ExtensibleTrustManagerImpl.checkServerTrusted(ExtensibleTrustManagerImpl.java:119)\n\tat java.base/sun.security.ssl.CertificateMessage$T12CertificateConsumer.checkServerCerts(CertificateMessage.java:623)\n\t... 23 common frames omitted\nCaused by: sun.security.provider.certpath.SunCertPathBuilderException: unable to find valid certification path to requested target\n\tat java.base/sun.security.provider.certpath.SunCertPathBuilder.build(SunCertPathBuilder.java:141)\n\tat java.base/sun.security.provider.certpath.SunCertPathBuilder.engineBuild(SunCertPathBuilder.java:126)\n\tat java.base/java.security.cert.CertPathBuilder.build(CertPathBuilder.java:297)\n\tat java.base/sun.security.validator.PKIXValidator.doBuild(PKIXValidator.java:434)\n\t... 30 common frames omitted", "url": "https://github.com/openhab/openhab-addons/pull/8791#discussion_r511662983", "createdAt": "2020-10-25T23:16:13Z", "author": {"login": "lolodomo"}, "path": "bundles/org.openhab.binding.remoteopenhab/README.md", "diffHunk": "@@ -0,0 +1,64 @@\n+# Remote openHAB Binding\n+\n+The Remote openHAB binding allows to communicate with remote openHAB servers.\n+The communication is bidirectional.\n+The binding on the local server listens to any item state updates on the remote server and updates accordingly the linked channel on the local server.\n+It also transfers any item command from the local server to the remote server.\n+\n+One first usage is the distribution of your home automation system on a set of openHAB servers.\n+\n+A second usage is for users having old openHAB v1 bindings running that were not migrated to openHAB v2 or openHAB v3.\n+They can keep an openHAB v2 server to run their old openHAB v1 bindings and setup a new openHAB v3 server for everything else.\n+The Remote openHAB binding installed on the openHAB v3 server will then allow to use the openHAB v1 bindings through communication with the openHAB v2 server.\n+\n+A third usage is for users that would like to keep unchanged an existing openHAB v2 server but would like to use the new UI from openHAB v3; they can simply setup a new openHAB v3 server with the Remote openHAB binding linked to their openHAB v2 server.\n+\n+## Supported Things\n+\n+There is one unique supported thing : the `server` bridge thing \n+\n+## Discovery\n+\n+All openHAB servers in the local network are automatically discovered (through mDNS) by the binding.\n+You will find in the inbox one discovery thing per remote server interface.\n+So if your remote server has one IPv4 address and one IPv6 address, you will discover two things in the inbox.\n+Just choose one of the two things.\n+\n+## Binding Configuration\n+\n+The binding has no configuration options, all configuration is done at Thing level.\n+\n+## Thing Configuration\n+\n+The thing has the following configuration parameters:\n+\n+| Parameter | Required | Description                                                                                            |\n+|-----------|-------------------------------------------------------------------------------------------------------------------|\n+| restUrl   | yes      | The REST URL of the remote openHAB server.                                                             |\n+| token     | no       | The token to use when the remote openHAB server is setup to require authorization to run its REST API. |\n+\n+## Channels\n+\n+The channels are built dynamically and automatically by the binding.\n+One channel is created for each item from the remote server.\n+Only basic groups (with no state) are ignored.\n+The channel id of the built channel corresponds to the name of the item on the remote server.\n+\n+## Limitations\n+\n+* The binding will not try to communicate with an openHAB v1 server.\n+* The binding only uses the HTTP protocol for the communications with the remote server (not HTTPS).", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTUxNzMzMQ=="}, "originalCommit": {"oid": "81f2e2faf5d54ee22f8c579d08c37ef95508e197"}, "originalPosition": 50}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTc1ODY0OA==", "bodyText": "@kaikreuzer : I will allow HTTPS later today mentioning in the documention the requirement of a valid SSL certificate for the remote openHAB server. Will you be able to validate that it works ?", "url": "https://github.com/openhab/openhab-addons/pull/8791#discussion_r511758648", "createdAt": "2020-10-26T07:25:59Z", "author": {"login": "lolodomo"}, "path": "bundles/org.openhab.binding.remoteopenhab/README.md", "diffHunk": "@@ -0,0 +1,64 @@\n+# Remote openHAB Binding\n+\n+The Remote openHAB binding allows to communicate with remote openHAB servers.\n+The communication is bidirectional.\n+The binding on the local server listens to any item state updates on the remote server and updates accordingly the linked channel on the local server.\n+It also transfers any item command from the local server to the remote server.\n+\n+One first usage is the distribution of your home automation system on a set of openHAB servers.\n+\n+A second usage is for users having old openHAB v1 bindings running that were not migrated to openHAB v2 or openHAB v3.\n+They can keep an openHAB v2 server to run their old openHAB v1 bindings and setup a new openHAB v3 server for everything else.\n+The Remote openHAB binding installed on the openHAB v3 server will then allow to use the openHAB v1 bindings through communication with the openHAB v2 server.\n+\n+A third usage is for users that would like to keep unchanged an existing openHAB v2 server but would like to use the new UI from openHAB v3; they can simply setup a new openHAB v3 server with the Remote openHAB binding linked to their openHAB v2 server.\n+\n+## Supported Things\n+\n+There is one unique supported thing : the `server` bridge thing \n+\n+## Discovery\n+\n+All openHAB servers in the local network are automatically discovered (through mDNS) by the binding.\n+You will find in the inbox one discovery thing per remote server interface.\n+So if your remote server has one IPv4 address and one IPv6 address, you will discover two things in the inbox.\n+Just choose one of the two things.\n+\n+## Binding Configuration\n+\n+The binding has no configuration options, all configuration is done at Thing level.\n+\n+## Thing Configuration\n+\n+The thing has the following configuration parameters:\n+\n+| Parameter | Required | Description                                                                                            |\n+|-----------|-------------------------------------------------------------------------------------------------------------------|\n+| restUrl   | yes      | The REST URL of the remote openHAB server.                                                             |\n+| token     | no       | The token to use when the remote openHAB server is setup to require authorization to run its REST API. |\n+\n+## Channels\n+\n+The channels are built dynamically and automatically by the binding.\n+One channel is created for each item from the remote server.\n+Only basic groups (with no state) are ignored.\n+The channel id of the built channel corresponds to the name of the item on the remote server.\n+\n+## Limitations\n+\n+* The binding will not try to communicate with an openHAB v1 server.\n+* The binding only uses the HTTP protocol for the communications with the remote server (not HTTPS).", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTUxNzMzMQ=="}, "originalCommit": {"oid": "81f2e2faf5d54ee22f8c579d08c37ef95508e197"}, "originalPosition": 50}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTc1OTkwMQ==", "bodyText": "Yes, that's what I expected, thanks.\nIf we had a hostname at hand, the solution would be to register a component like this one. When using IP addresses, this won't work, though, I'm afraid.\nSo fine for me to stick to HTTP for now and look at HTTPS support as a follow-up.", "url": "https://github.com/openhab/openhab-addons/pull/8791#discussion_r511759901", "createdAt": "2020-10-26T07:29:22Z", "author": {"login": "kaikreuzer"}, "path": "bundles/org.openhab.binding.remoteopenhab/README.md", "diffHunk": "@@ -0,0 +1,64 @@\n+# Remote openHAB Binding\n+\n+The Remote openHAB binding allows to communicate with remote openHAB servers.\n+The communication is bidirectional.\n+The binding on the local server listens to any item state updates on the remote server and updates accordingly the linked channel on the local server.\n+It also transfers any item command from the local server to the remote server.\n+\n+One first usage is the distribution of your home automation system on a set of openHAB servers.\n+\n+A second usage is for users having old openHAB v1 bindings running that were not migrated to openHAB v2 or openHAB v3.\n+They can keep an openHAB v2 server to run their old openHAB v1 bindings and setup a new openHAB v3 server for everything else.\n+The Remote openHAB binding installed on the openHAB v3 server will then allow to use the openHAB v1 bindings through communication with the openHAB v2 server.\n+\n+A third usage is for users that would like to keep unchanged an existing openHAB v2 server but would like to use the new UI from openHAB v3; they can simply setup a new openHAB v3 server with the Remote openHAB binding linked to their openHAB v2 server.\n+\n+## Supported Things\n+\n+There is one unique supported thing : the `server` bridge thing \n+\n+## Discovery\n+\n+All openHAB servers in the local network are automatically discovered (through mDNS) by the binding.\n+You will find in the inbox one discovery thing per remote server interface.\n+So if your remote server has one IPv4 address and one IPv6 address, you will discover two things in the inbox.\n+Just choose one of the two things.\n+\n+## Binding Configuration\n+\n+The binding has no configuration options, all configuration is done at Thing level.\n+\n+## Thing Configuration\n+\n+The thing has the following configuration parameters:\n+\n+| Parameter | Required | Description                                                                                            |\n+|-----------|-------------------------------------------------------------------------------------------------------------------|\n+| restUrl   | yes      | The REST URL of the remote openHAB server.                                                             |\n+| token     | no       | The token to use when the remote openHAB server is setup to require authorization to run its REST API. |\n+\n+## Channels\n+\n+The channels are built dynamically and automatically by the binding.\n+One channel is created for each item from the remote server.\n+Only basic groups (with no state) are ignored.\n+The channel id of the built channel corresponds to the name of the item on the remote server.\n+\n+## Limitations\n+\n+* The binding will not try to communicate with an openHAB v1 server.\n+* The binding only uses the HTTP protocol for the communications with the remote server (not HTTPS).", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTUxNzMzMQ=="}, "originalCommit": {"oid": "81f2e2faf5d54ee22f8c579d08c37ef95508e197"}, "originalPosition": 50}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTA0MjMyNg==", "bodyText": "FYI, I succeeded  with HTTPS. I am waiting for the merge of my second PR to create a third one for HTTPS.", "url": "https://github.com/openhab/openhab-addons/pull/8791#discussion_r519042326", "createdAt": "2020-11-06T22:45:32Z", "author": {"login": "lolodomo"}, "path": "bundles/org.openhab.binding.remoteopenhab/README.md", "diffHunk": "@@ -0,0 +1,64 @@\n+# Remote openHAB Binding\n+\n+The Remote openHAB binding allows to communicate with remote openHAB servers.\n+The communication is bidirectional.\n+The binding on the local server listens to any item state updates on the remote server and updates accordingly the linked channel on the local server.\n+It also transfers any item command from the local server to the remote server.\n+\n+One first usage is the distribution of your home automation system on a set of openHAB servers.\n+\n+A second usage is for users having old openHAB v1 bindings running that were not migrated to openHAB v2 or openHAB v3.\n+They can keep an openHAB v2 server to run their old openHAB v1 bindings and setup a new openHAB v3 server for everything else.\n+The Remote openHAB binding installed on the openHAB v3 server will then allow to use the openHAB v1 bindings through communication with the openHAB v2 server.\n+\n+A third usage is for users that would like to keep unchanged an existing openHAB v2 server but would like to use the new UI from openHAB v3; they can simply setup a new openHAB v3 server with the Remote openHAB binding linked to their openHAB v2 server.\n+\n+## Supported Things\n+\n+There is one unique supported thing : the `server` bridge thing \n+\n+## Discovery\n+\n+All openHAB servers in the local network are automatically discovered (through mDNS) by the binding.\n+You will find in the inbox one discovery thing per remote server interface.\n+So if your remote server has one IPv4 address and one IPv6 address, you will discover two things in the inbox.\n+Just choose one of the two things.\n+\n+## Binding Configuration\n+\n+The binding has no configuration options, all configuration is done at Thing level.\n+\n+## Thing Configuration\n+\n+The thing has the following configuration parameters:\n+\n+| Parameter | Required | Description                                                                                            |\n+|-----------|-------------------------------------------------------------------------------------------------------------------|\n+| restUrl   | yes      | The REST URL of the remote openHAB server.                                                             |\n+| token     | no       | The token to use when the remote openHAB server is setup to require authorization to run its REST API. |\n+\n+## Channels\n+\n+The channels are built dynamically and automatically by the binding.\n+One channel is created for each item from the remote server.\n+Only basic groups (with no state) are ignored.\n+The channel id of the built channel corresponds to the name of the item on the remote server.\n+\n+## Limitations\n+\n+* The binding will not try to communicate with an openHAB v1 server.\n+* The binding only uses the HTTP protocol for the communications with the remote server (not HTTPS).", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTUxNzMzMQ=="}, "originalCommit": {"oid": "81f2e2faf5d54ee22f8c579d08c37ef95508e197"}, "originalPosition": 50}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIwNDQxMjE2OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.remoteopenhab/README.md", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNFQyMTo0NDo1M1rOHn0jSA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNVQxMDozMjozNFrOHn4Oyw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTUxNzUxMg==", "bodyText": "I would find it much more straight forward to simply have the ip address (or hostname) as a configuration parameter - it is imho much more convenient for users when doing textual configuration. Furthermore, that's the standard way we also identify other devices/services on the network.", "url": "https://github.com/openhab/openhab-addons/pull/8791#discussion_r511517512", "createdAt": "2020-10-24T21:44:53Z", "author": {"login": "kaikreuzer"}, "path": "bundles/org.openhab.binding.remoteopenhab/README.md", "diffHunk": "@@ -0,0 +1,64 @@\n+# Remote openHAB Binding\n+\n+The Remote openHAB binding allows to communicate with remote openHAB servers.\n+The communication is bidirectional.\n+The binding on the local server listens to any item state updates on the remote server and updates accordingly the linked channel on the local server.\n+It also transfers any item command from the local server to the remote server.\n+\n+One first usage is the distribution of your home automation system on a set of openHAB servers.\n+\n+A second usage is for users having old openHAB v1 bindings running that were not migrated to openHAB v2 or openHAB v3.\n+They can keep an openHAB v2 server to run their old openHAB v1 bindings and setup a new openHAB v3 server for everything else.\n+The Remote openHAB binding installed on the openHAB v3 server will then allow to use the openHAB v1 bindings through communication with the openHAB v2 server.\n+\n+A third usage is for users that would like to keep unchanged an existing openHAB v2 server but would like to use the new UI from openHAB v3; they can simply setup a new openHAB v3 server with the Remote openHAB binding linked to their openHAB v2 server.\n+\n+## Supported Things\n+\n+There is one unique supported thing : the `server` bridge thing \n+\n+## Discovery\n+\n+All openHAB servers in the local network are automatically discovered (through mDNS) by the binding.\n+You will find in the inbox one discovery thing per remote server interface.\n+So if your remote server has one IPv4 address and one IPv6 address, you will discover two things in the inbox.\n+Just choose one of the two things.\n+\n+## Binding Configuration\n+\n+The binding has no configuration options, all configuration is done at Thing level.\n+\n+## Thing Configuration\n+\n+The thing has the following configuration parameters:\n+\n+| Parameter | Required | Description                                                                                            |\n+|-----------|-------------------------------------------------------------------------------------------------------------------|\n+| restUrl   | yes      | The REST URL of the remote openHAB server.                                                             |", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "81f2e2faf5d54ee22f8c579d08c37ef95508e197"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTUyMjAxNQ==", "bodyText": "This would require another setting for the port + another to choose between HTTP and HTTPS (when HTTPS will be possible).\nAnd the mDNS announcer is even providing the path (\"/rest\").\nSo the REST API URL as configuration setting looks like a good solution, to not say a better solution.\nBut of course, this can be changed.", "url": "https://github.com/openhab/openhab-addons/pull/8791#discussion_r511522015", "createdAt": "2020-10-24T22:43:54Z", "author": {"login": "lolodomo"}, "path": "bundles/org.openhab.binding.remoteopenhab/README.md", "diffHunk": "@@ -0,0 +1,64 @@\n+# Remote openHAB Binding\n+\n+The Remote openHAB binding allows to communicate with remote openHAB servers.\n+The communication is bidirectional.\n+The binding on the local server listens to any item state updates on the remote server and updates accordingly the linked channel on the local server.\n+It also transfers any item command from the local server to the remote server.\n+\n+One first usage is the distribution of your home automation system on a set of openHAB servers.\n+\n+A second usage is for users having old openHAB v1 bindings running that were not migrated to openHAB v2 or openHAB v3.\n+They can keep an openHAB v2 server to run their old openHAB v1 bindings and setup a new openHAB v3 server for everything else.\n+The Remote openHAB binding installed on the openHAB v3 server will then allow to use the openHAB v1 bindings through communication with the openHAB v2 server.\n+\n+A third usage is for users that would like to keep unchanged an existing openHAB v2 server but would like to use the new UI from openHAB v3; they can simply setup a new openHAB v3 server with the Remote openHAB binding linked to their openHAB v2 server.\n+\n+## Supported Things\n+\n+There is one unique supported thing : the `server` bridge thing \n+\n+## Discovery\n+\n+All openHAB servers in the local network are automatically discovered (through mDNS) by the binding.\n+You will find in the inbox one discovery thing per remote server interface.\n+So if your remote server has one IPv4 address and one IPv6 address, you will discover two things in the inbox.\n+Just choose one of the two things.\n+\n+## Binding Configuration\n+\n+The binding has no configuration options, all configuration is done at Thing level.\n+\n+## Thing Configuration\n+\n+The thing has the following configuration parameters:\n+\n+| Parameter | Required | Description                                                                                            |\n+|-----------|-------------------------------------------------------------------------------------------------------------------|\n+| restUrl   | yes      | The REST URL of the remote openHAB server.                                                             |", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTUxNzUxMg=="}, "originalCommit": {"oid": "81f2e2faf5d54ee22f8c579d08c37ef95508e197"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTU1NTQ4OA==", "bodyText": "Ok I am finally convinced, I will update in favor or several configuration settings.", "url": "https://github.com/openhab/openhab-addons/pull/8791#discussion_r511555488", "createdAt": "2020-10-25T06:49:55Z", "author": {"login": "lolodomo"}, "path": "bundles/org.openhab.binding.remoteopenhab/README.md", "diffHunk": "@@ -0,0 +1,64 @@\n+# Remote openHAB Binding\n+\n+The Remote openHAB binding allows to communicate with remote openHAB servers.\n+The communication is bidirectional.\n+The binding on the local server listens to any item state updates on the remote server and updates accordingly the linked channel on the local server.\n+It also transfers any item command from the local server to the remote server.\n+\n+One first usage is the distribution of your home automation system on a set of openHAB servers.\n+\n+A second usage is for users having old openHAB v1 bindings running that were not migrated to openHAB v2 or openHAB v3.\n+They can keep an openHAB v2 server to run their old openHAB v1 bindings and setup a new openHAB v3 server for everything else.\n+The Remote openHAB binding installed on the openHAB v3 server will then allow to use the openHAB v1 bindings through communication with the openHAB v2 server.\n+\n+A third usage is for users that would like to keep unchanged an existing openHAB v2 server but would like to use the new UI from openHAB v3; they can simply setup a new openHAB v3 server with the Remote openHAB binding linked to their openHAB v2 server.\n+\n+## Supported Things\n+\n+There is one unique supported thing : the `server` bridge thing \n+\n+## Discovery\n+\n+All openHAB servers in the local network are automatically discovered (through mDNS) by the binding.\n+You will find in the inbox one discovery thing per remote server interface.\n+So if your remote server has one IPv4 address and one IPv6 address, you will discover two things in the inbox.\n+Just choose one of the two things.\n+\n+## Binding Configuration\n+\n+The binding has no configuration options, all configuration is done at Thing level.\n+\n+## Thing Configuration\n+\n+The thing has the following configuration parameters:\n+\n+| Parameter | Required | Description                                                                                            |\n+|-----------|-------------------------------------------------------------------------------------------------------------------|\n+| restUrl   | yes      | The REST URL of the remote openHAB server.                                                             |", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTUxNzUxMg=="}, "originalCommit": {"oid": "81f2e2faf5d54ee22f8c579d08c37ef95508e197"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTU3NzgwMw==", "bodyText": "Done", "url": "https://github.com/openhab/openhab-addons/pull/8791#discussion_r511577803", "createdAt": "2020-10-25T10:32:34Z", "author": {"login": "lolodomo"}, "path": "bundles/org.openhab.binding.remoteopenhab/README.md", "diffHunk": "@@ -0,0 +1,64 @@\n+# Remote openHAB Binding\n+\n+The Remote openHAB binding allows to communicate with remote openHAB servers.\n+The communication is bidirectional.\n+The binding on the local server listens to any item state updates on the remote server and updates accordingly the linked channel on the local server.\n+It also transfers any item command from the local server to the remote server.\n+\n+One first usage is the distribution of your home automation system on a set of openHAB servers.\n+\n+A second usage is for users having old openHAB v1 bindings running that were not migrated to openHAB v2 or openHAB v3.\n+They can keep an openHAB v2 server to run their old openHAB v1 bindings and setup a new openHAB v3 server for everything else.\n+The Remote openHAB binding installed on the openHAB v3 server will then allow to use the openHAB v1 bindings through communication with the openHAB v2 server.\n+\n+A third usage is for users that would like to keep unchanged an existing openHAB v2 server but would like to use the new UI from openHAB v3; they can simply setup a new openHAB v3 server with the Remote openHAB binding linked to their openHAB v2 server.\n+\n+## Supported Things\n+\n+There is one unique supported thing : the `server` bridge thing \n+\n+## Discovery\n+\n+All openHAB servers in the local network are automatically discovered (through mDNS) by the binding.\n+You will find in the inbox one discovery thing per remote server interface.\n+So if your remote server has one IPv4 address and one IPv6 address, you will discover two things in the inbox.\n+Just choose one of the two things.\n+\n+## Binding Configuration\n+\n+The binding has no configuration options, all configuration is done at Thing level.\n+\n+## Thing Configuration\n+\n+The thing has the following configuration parameters:\n+\n+| Parameter | Required | Description                                                                                            |\n+|-----------|-------------------------------------------------------------------------------------------------------------------|\n+| restUrl   | yes      | The REST URL of the remote openHAB server.                                                             |", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTUxNzUxMg=="}, "originalCommit": {"oid": "81f2e2faf5d54ee22f8c579d08c37ef95508e197"}, "originalPosition": 37}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIwNDQxMzk3OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.remoteopenhab/README.md", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNFQyMTo0NjoyOVrOHn0kGg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNFQyMjo0NjozOVrOHn01yw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTUxNzcyMg==", "bodyText": "I'd suggest this change to make it clearer that \"Date\" is just some item name here (and not a type or keyword):\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            DateTime Date \"Date [%1$tA %1$td %1$tR]\" <calendar> { channel=\"remoteopenhab:server:oh2:Date\" }\n          \n          \n            \n            DateTime MyDate \"Date [%1$tA %1$td %1$tR]\" <calendar> { channel=\"remoteopenhab:server:oh2:MyDate\" }", "url": "https://github.com/openhab/openhab-addons/pull/8791#discussion_r511517722", "createdAt": "2020-10-24T21:46:29Z", "author": {"login": "kaikreuzer"}, "path": "bundles/org.openhab.binding.remoteopenhab/README.md", "diffHunk": "@@ -0,0 +1,64 @@\n+# Remote openHAB Binding\n+\n+The Remote openHAB binding allows to communicate with remote openHAB servers.\n+The communication is bidirectional.\n+The binding on the local server listens to any item state updates on the remote server and updates accordingly the linked channel on the local server.\n+It also transfers any item command from the local server to the remote server.\n+\n+One first usage is the distribution of your home automation system on a set of openHAB servers.\n+\n+A second usage is for users having old openHAB v1 bindings running that were not migrated to openHAB v2 or openHAB v3.\n+They can keep an openHAB v2 server to run their old openHAB v1 bindings and setup a new openHAB v3 server for everything else.\n+The Remote openHAB binding installed on the openHAB v3 server will then allow to use the openHAB v1 bindings through communication with the openHAB v2 server.\n+\n+A third usage is for users that would like to keep unchanged an existing openHAB v2 server but would like to use the new UI from openHAB v3; they can simply setup a new openHAB v3 server with the Remote openHAB binding linked to their openHAB v2 server.\n+\n+## Supported Things\n+\n+There is one unique supported thing : the `server` bridge thing \n+\n+## Discovery\n+\n+All openHAB servers in the local network are automatically discovered (through mDNS) by the binding.\n+You will find in the inbox one discovery thing per remote server interface.\n+So if your remote server has one IPv4 address and one IPv6 address, you will discover two things in the inbox.\n+Just choose one of the two things.\n+\n+## Binding Configuration\n+\n+The binding has no configuration options, all configuration is done at Thing level.\n+\n+## Thing Configuration\n+\n+The thing has the following configuration parameters:\n+\n+| Parameter | Required | Description                                                                                            |\n+|-----------|-------------------------------------------------------------------------------------------------------------------|\n+| restUrl   | yes      | The REST URL of the remote openHAB server.                                                             |\n+| token     | no       | The token to use when the remote openHAB server is setup to require authorization to run its REST API. |\n+\n+## Channels\n+\n+The channels are built dynamically and automatically by the binding.\n+One channel is created for each item from the remote server.\n+Only basic groups (with no state) are ignored.\n+The channel id of the built channel corresponds to the name of the item on the remote server.\n+\n+## Limitations\n+\n+* The binding will not try to communicate with an openHAB v1 server.\n+* The binding only uses the HTTP protocol for the communications with the remote server (not HTTPS).\n+\n+## Example\n+\n+### demo.things:\n+\n+```\n+Bridge remoteopenhab:server:oh2 \"OH2 server\" [ restUrl=\"http://192.168.0.100:8080/rest\" ]\n+```\n+\n+### demo.items:\n+\n+```\n+DateTime Date \"Date [%1$tA %1$td %1$tR]\" <calendar> { channel=\"remoteopenhab:server:oh2:Date\" }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "81f2e2faf5d54ee22f8c579d08c37ef95508e197"}, "originalPosition": 63}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTUyMjI1MQ==", "bodyText": "Changed", "url": "https://github.com/openhab/openhab-addons/pull/8791#discussion_r511522251", "createdAt": "2020-10-24T22:46:39Z", "author": {"login": "lolodomo"}, "path": "bundles/org.openhab.binding.remoteopenhab/README.md", "diffHunk": "@@ -0,0 +1,64 @@\n+# Remote openHAB Binding\n+\n+The Remote openHAB binding allows to communicate with remote openHAB servers.\n+The communication is bidirectional.\n+The binding on the local server listens to any item state updates on the remote server and updates accordingly the linked channel on the local server.\n+It also transfers any item command from the local server to the remote server.\n+\n+One first usage is the distribution of your home automation system on a set of openHAB servers.\n+\n+A second usage is for users having old openHAB v1 bindings running that were not migrated to openHAB v2 or openHAB v3.\n+They can keep an openHAB v2 server to run their old openHAB v1 bindings and setup a new openHAB v3 server for everything else.\n+The Remote openHAB binding installed on the openHAB v3 server will then allow to use the openHAB v1 bindings through communication with the openHAB v2 server.\n+\n+A third usage is for users that would like to keep unchanged an existing openHAB v2 server but would like to use the new UI from openHAB v3; they can simply setup a new openHAB v3 server with the Remote openHAB binding linked to their openHAB v2 server.\n+\n+## Supported Things\n+\n+There is one unique supported thing : the `server` bridge thing \n+\n+## Discovery\n+\n+All openHAB servers in the local network are automatically discovered (through mDNS) by the binding.\n+You will find in the inbox one discovery thing per remote server interface.\n+So if your remote server has one IPv4 address and one IPv6 address, you will discover two things in the inbox.\n+Just choose one of the two things.\n+\n+## Binding Configuration\n+\n+The binding has no configuration options, all configuration is done at Thing level.\n+\n+## Thing Configuration\n+\n+The thing has the following configuration parameters:\n+\n+| Parameter | Required | Description                                                                                            |\n+|-----------|-------------------------------------------------------------------------------------------------------------------|\n+| restUrl   | yes      | The REST URL of the remote openHAB server.                                                             |\n+| token     | no       | The token to use when the remote openHAB server is setup to require authorization to run its REST API. |\n+\n+## Channels\n+\n+The channels are built dynamically and automatically by the binding.\n+One channel is created for each item from the remote server.\n+Only basic groups (with no state) are ignored.\n+The channel id of the built channel corresponds to the name of the item on the remote server.\n+\n+## Limitations\n+\n+* The binding will not try to communicate with an openHAB v1 server.\n+* The binding only uses the HTTP protocol for the communications with the remote server (not HTTPS).\n+\n+## Example\n+\n+### demo.things:\n+\n+```\n+Bridge remoteopenhab:server:oh2 \"OH2 server\" [ restUrl=\"http://192.168.0.100:8080/rest\" ]\n+```\n+\n+### demo.items:\n+\n+```\n+DateTime Date \"Date [%1$tA %1$td %1$tR]\" <calendar> { channel=\"remoteopenhab:server:oh2:Date\" }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTUxNzcyMg=="}, "originalCommit": {"oid": "81f2e2faf5d54ee22f8c579d08c37ef95508e197"}, "originalPosition": 63}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIwNDQxNDU5OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.remoteopenhab/src/main/java/org/openhab/binding/remoteopenhab/internal/RemoteopenhabChannelTypeProvider.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNFQyMTo0NzoxOVrOHn0kZw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNFQyMjo1NDoxM1rOHn03kQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTUxNzc5OQ==", "bodyText": "Please at least one line of JavaDoc.", "url": "https://github.com/openhab/openhab-addons/pull/8791#discussion_r511517799", "createdAt": "2020-10-24T21:47:19Z", "author": {"login": "kaikreuzer"}, "path": "bundles/org.openhab.binding.remoteopenhab/src/main/java/org/openhab/binding/remoteopenhab/internal/RemoteopenhabChannelTypeProvider.java", "diffHunk": "@@ -0,0 +1,58 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.remoteopenhab.internal;\n+\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.core.thing.type.ChannelType;\n+import org.openhab.core.thing.type.ChannelTypeProvider;\n+import org.openhab.core.thing.type.ChannelTypeUID;\n+import org.osgi.service.component.annotations.Component;\n+\n+/**\n+ *", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "81f2e2faf5d54ee22f8c579d08c37ef95508e197"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTUyMjcwNQ==", "bodyText": "Done", "url": "https://github.com/openhab/openhab-addons/pull/8791#discussion_r511522705", "createdAt": "2020-10-24T22:54:13Z", "author": {"login": "lolodomo"}, "path": "bundles/org.openhab.binding.remoteopenhab/src/main/java/org/openhab/binding/remoteopenhab/internal/RemoteopenhabChannelTypeProvider.java", "diffHunk": "@@ -0,0 +1,58 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.remoteopenhab.internal;\n+\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.core.thing.type.ChannelType;\n+import org.openhab.core.thing.type.ChannelTypeProvider;\n+import org.openhab.core.thing.type.ChannelTypeUID;\n+import org.osgi.service.component.annotations.Component;\n+\n+/**\n+ *", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTUxNzc5OQ=="}, "originalCommit": {"oid": "81f2e2faf5d54ee22f8c579d08c37ef95508e197"}, "originalPosition": 28}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIwNDQxNjE0OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.remoteopenhab/src/main/java/org/openhab/binding/remoteopenhab/internal/discovery/RemoteopenhabDiscoveryParticipant.java", "isResolved": true, "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNFQyMTo0OTo0N1rOHn0lIw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNVQyMjo0MzoxNVrOHn9MQg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTUxNzk4Nw==", "bodyText": "Don't add the IP to the label, but make it the representation property instead.\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        String label = \"openHAB server IP \" + service.getHostAddresses()[0];\n          \n          \n            \n                        String label = \"openHAB Server\";", "url": "https://github.com/openhab/openhab-addons/pull/8791#discussion_r511517987", "createdAt": "2020-10-24T21:49:47Z", "author": {"login": "kaikreuzer"}, "path": "bundles/org.openhab.binding.remoteopenhab/src/main/java/org/openhab/binding/remoteopenhab/internal/discovery/RemoteopenhabDiscoveryParticipant.java", "diffHunk": "@@ -0,0 +1,89 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.remoteopenhab.internal.discovery;\n+\n+import static org.openhab.binding.remoteopenhab.internal.RemoteopenhabBindingConstants.*;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import javax.jmdns.ServiceInfo;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.remoteopenhab.internal.config.RemoteopenhabInstanceConfiguration;\n+import org.openhab.core.config.discovery.DiscoveryResult;\n+import org.openhab.core.config.discovery.DiscoveryResultBuilder;\n+import org.openhab.core.config.discovery.mdns.MDNSDiscoveryParticipant;\n+import org.openhab.core.thing.ThingTypeUID;\n+import org.openhab.core.thing.ThingUID;\n+import org.osgi.service.component.annotations.Component;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link RemoteopenhabDiscoveryParticipant} is responsible for discovering\n+ * the remote openHAB servers using mDNS discovery service.\n+ *\n+ * @author Laurent Garnier - Initial contribution\n+ */\n+@NonNullByDefault\n+@Component(service = MDNSDiscoveryParticipant.class, configurationPid = \"mdnsdiscovery.remoteopenhab\")\n+public class RemoteopenhabDiscoveryParticipant implements MDNSDiscoveryParticipant {\n+\n+    private final Logger logger = LoggerFactory.getLogger(RemoteopenhabDiscoveryParticipant.class);\n+\n+    private static final String SERVICE_TYPE = \"_openhab-server._tcp.local.\";\n+\n+    @Override\n+    public Set<ThingTypeUID> getSupportedThingTypeUIDs() {\n+        return SUPPORTED_THING_TYPES_UIDS;\n+    }\n+\n+    @Override\n+    public String getServiceType() {\n+        return SERVICE_TYPE;\n+    }\n+\n+    @Override\n+    public @Nullable ThingUID getThingUID(ServiceInfo service) {\n+        // We use the first host address as thing ID\n+        if (getServiceType().equals(service.getType()) && service.getHostAddresses() != null\n+                && service.getHostAddresses().length > 0 && !service.getHostAddresses()[0].isEmpty()) {\n+            return new ThingUID(BRIDGE_TYPE_SERVER, service.getHostAddresses()[0].replaceAll(\"[^A-Za-z0-9_]\", \"_\"));\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public @Nullable DiscoveryResult createResult(ServiceInfo service) {\n+        logger.debug(\"createResult ServiceInfo: {}\", service);\n+        DiscoveryResult result = null;\n+        String url = null;\n+        if (service.getURLs() != null && service.getURLs().length > 0 && !service.getURLs()[0].isEmpty()) {\n+            url = service.getURLs()[0];\n+        }\n+        String restPath = service.getPropertyString(\"uri\");\n+        ThingUID thingUID = getThingUID(service);\n+        if (thingUID != null && url != null && restPath != null) {\n+            String label = \"openHAB server IP \" + service.getHostAddresses()[0];", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "81f2e2faf5d54ee22f8c579d08c37ef95508e197"}, "originalPosition": 80}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTUyMzExOA==", "bodyText": "If I do that, we will have no way to distinguish servers in the inbox.", "url": "https://github.com/openhab/openhab-addons/pull/8791#discussion_r511523118", "createdAt": "2020-10-24T22:59:45Z", "author": {"login": "lolodomo"}, "path": "bundles/org.openhab.binding.remoteopenhab/src/main/java/org/openhab/binding/remoteopenhab/internal/discovery/RemoteopenhabDiscoveryParticipant.java", "diffHunk": "@@ -0,0 +1,89 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.remoteopenhab.internal.discovery;\n+\n+import static org.openhab.binding.remoteopenhab.internal.RemoteopenhabBindingConstants.*;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import javax.jmdns.ServiceInfo;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.remoteopenhab.internal.config.RemoteopenhabInstanceConfiguration;\n+import org.openhab.core.config.discovery.DiscoveryResult;\n+import org.openhab.core.config.discovery.DiscoveryResultBuilder;\n+import org.openhab.core.config.discovery.mdns.MDNSDiscoveryParticipant;\n+import org.openhab.core.thing.ThingTypeUID;\n+import org.openhab.core.thing.ThingUID;\n+import org.osgi.service.component.annotations.Component;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link RemoteopenhabDiscoveryParticipant} is responsible for discovering\n+ * the remote openHAB servers using mDNS discovery service.\n+ *\n+ * @author Laurent Garnier - Initial contribution\n+ */\n+@NonNullByDefault\n+@Component(service = MDNSDiscoveryParticipant.class, configurationPid = \"mdnsdiscovery.remoteopenhab\")\n+public class RemoteopenhabDiscoveryParticipant implements MDNSDiscoveryParticipant {\n+\n+    private final Logger logger = LoggerFactory.getLogger(RemoteopenhabDiscoveryParticipant.class);\n+\n+    private static final String SERVICE_TYPE = \"_openhab-server._tcp.local.\";\n+\n+    @Override\n+    public Set<ThingTypeUID> getSupportedThingTypeUIDs() {\n+        return SUPPORTED_THING_TYPES_UIDS;\n+    }\n+\n+    @Override\n+    public String getServiceType() {\n+        return SERVICE_TYPE;\n+    }\n+\n+    @Override\n+    public @Nullable ThingUID getThingUID(ServiceInfo service) {\n+        // We use the first host address as thing ID\n+        if (getServiceType().equals(service.getType()) && service.getHostAddresses() != null\n+                && service.getHostAddresses().length > 0 && !service.getHostAddresses()[0].isEmpty()) {\n+            return new ThingUID(BRIDGE_TYPE_SERVER, service.getHostAddresses()[0].replaceAll(\"[^A-Za-z0-9_]\", \"_\"));\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public @Nullable DiscoveryResult createResult(ServiceInfo service) {\n+        logger.debug(\"createResult ServiceInfo: {}\", service);\n+        DiscoveryResult result = null;\n+        String url = null;\n+        if (service.getURLs() != null && service.getURLs().length > 0 && !service.getURLs()[0].isEmpty()) {\n+            url = service.getURLs()[0];\n+        }\n+        String restPath = service.getPropertyString(\"uri\");\n+        ThingUID thingUID = getThingUID(service);\n+        if (thingUID != null && url != null && restPath != null) {\n+            String label = \"openHAB server IP \" + service.getHostAddresses()[0];", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTUxNzk4Nw=="}, "originalCommit": {"oid": "81f2e2faf5d54ee22f8c579d08c37ef95508e197"}, "originalPosition": 80}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTUyNDk3MA==", "bodyText": "Here is how it looks now:\n\nWith your proposed change, all entries would have the same name \"openHAB server\" in the inbox.", "url": "https://github.com/openhab/openhab-addons/pull/8791#discussion_r511524970", "createdAt": "2020-10-24T23:25:02Z", "author": {"login": "lolodomo"}, "path": "bundles/org.openhab.binding.remoteopenhab/src/main/java/org/openhab/binding/remoteopenhab/internal/discovery/RemoteopenhabDiscoveryParticipant.java", "diffHunk": "@@ -0,0 +1,89 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.remoteopenhab.internal.discovery;\n+\n+import static org.openhab.binding.remoteopenhab.internal.RemoteopenhabBindingConstants.*;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import javax.jmdns.ServiceInfo;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.remoteopenhab.internal.config.RemoteopenhabInstanceConfiguration;\n+import org.openhab.core.config.discovery.DiscoveryResult;\n+import org.openhab.core.config.discovery.DiscoveryResultBuilder;\n+import org.openhab.core.config.discovery.mdns.MDNSDiscoveryParticipant;\n+import org.openhab.core.thing.ThingTypeUID;\n+import org.openhab.core.thing.ThingUID;\n+import org.osgi.service.component.annotations.Component;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link RemoteopenhabDiscoveryParticipant} is responsible for discovering\n+ * the remote openHAB servers using mDNS discovery service.\n+ *\n+ * @author Laurent Garnier - Initial contribution\n+ */\n+@NonNullByDefault\n+@Component(service = MDNSDiscoveryParticipant.class, configurationPid = \"mdnsdiscovery.remoteopenhab\")\n+public class RemoteopenhabDiscoveryParticipant implements MDNSDiscoveryParticipant {\n+\n+    private final Logger logger = LoggerFactory.getLogger(RemoteopenhabDiscoveryParticipant.class);\n+\n+    private static final String SERVICE_TYPE = \"_openhab-server._tcp.local.\";\n+\n+    @Override\n+    public Set<ThingTypeUID> getSupportedThingTypeUIDs() {\n+        return SUPPORTED_THING_TYPES_UIDS;\n+    }\n+\n+    @Override\n+    public String getServiceType() {\n+        return SERVICE_TYPE;\n+    }\n+\n+    @Override\n+    public @Nullable ThingUID getThingUID(ServiceInfo service) {\n+        // We use the first host address as thing ID\n+        if (getServiceType().equals(service.getType()) && service.getHostAddresses() != null\n+                && service.getHostAddresses().length > 0 && !service.getHostAddresses()[0].isEmpty()) {\n+            return new ThingUID(BRIDGE_TYPE_SERVER, service.getHostAddresses()[0].replaceAll(\"[^A-Za-z0-9_]\", \"_\"));\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public @Nullable DiscoveryResult createResult(ServiceInfo service) {\n+        logger.debug(\"createResult ServiceInfo: {}\", service);\n+        DiscoveryResult result = null;\n+        String url = null;\n+        if (service.getURLs() != null && service.getURLs().length > 0 && !service.getURLs()[0].isEmpty()) {\n+            url = service.getURLs()[0];\n+        }\n+        String restPath = service.getPropertyString(\"uri\");\n+        ThingUID thingUID = getThingUID(service);\n+        if (thingUID != null && url != null && restPath != null) {\n+            String label = \"openHAB server IP \" + service.getHostAddresses()[0];", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTUxNzk4Nw=="}, "originalCommit": {"oid": "81f2e2faf5d54ee22f8c579d08c37ef95508e197"}, "originalPosition": 80}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTY0MTgyNQ==", "bodyText": "Yes, that's exactly the idea - the label should describe the \"what\" it found and the presentation property allows to differentiate identical devices from each other.\n@ghys, it seems then that the presentation property is not yet considered that way in the Inbox. Shall I enter an issue for that?", "url": "https://github.com/openhab/openhab-addons/pull/8791#discussion_r511641825", "createdAt": "2020-10-25T20:03:32Z", "author": {"login": "kaikreuzer"}, "path": "bundles/org.openhab.binding.remoteopenhab/src/main/java/org/openhab/binding/remoteopenhab/internal/discovery/RemoteopenhabDiscoveryParticipant.java", "diffHunk": "@@ -0,0 +1,89 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.remoteopenhab.internal.discovery;\n+\n+import static org.openhab.binding.remoteopenhab.internal.RemoteopenhabBindingConstants.*;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import javax.jmdns.ServiceInfo;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.remoteopenhab.internal.config.RemoteopenhabInstanceConfiguration;\n+import org.openhab.core.config.discovery.DiscoveryResult;\n+import org.openhab.core.config.discovery.DiscoveryResultBuilder;\n+import org.openhab.core.config.discovery.mdns.MDNSDiscoveryParticipant;\n+import org.openhab.core.thing.ThingTypeUID;\n+import org.openhab.core.thing.ThingUID;\n+import org.osgi.service.component.annotations.Component;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link RemoteopenhabDiscoveryParticipant} is responsible for discovering\n+ * the remote openHAB servers using mDNS discovery service.\n+ *\n+ * @author Laurent Garnier - Initial contribution\n+ */\n+@NonNullByDefault\n+@Component(service = MDNSDiscoveryParticipant.class, configurationPid = \"mdnsdiscovery.remoteopenhab\")\n+public class RemoteopenhabDiscoveryParticipant implements MDNSDiscoveryParticipant {\n+\n+    private final Logger logger = LoggerFactory.getLogger(RemoteopenhabDiscoveryParticipant.class);\n+\n+    private static final String SERVICE_TYPE = \"_openhab-server._tcp.local.\";\n+\n+    @Override\n+    public Set<ThingTypeUID> getSupportedThingTypeUIDs() {\n+        return SUPPORTED_THING_TYPES_UIDS;\n+    }\n+\n+    @Override\n+    public String getServiceType() {\n+        return SERVICE_TYPE;\n+    }\n+\n+    @Override\n+    public @Nullable ThingUID getThingUID(ServiceInfo service) {\n+        // We use the first host address as thing ID\n+        if (getServiceType().equals(service.getType()) && service.getHostAddresses() != null\n+                && service.getHostAddresses().length > 0 && !service.getHostAddresses()[0].isEmpty()) {\n+            return new ThingUID(BRIDGE_TYPE_SERVER, service.getHostAddresses()[0].replaceAll(\"[^A-Za-z0-9_]\", \"_\"));\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public @Nullable DiscoveryResult createResult(ServiceInfo service) {\n+        logger.debug(\"createResult ServiceInfo: {}\", service);\n+        DiscoveryResult result = null;\n+        String url = null;\n+        if (service.getURLs() != null && service.getURLs().length > 0 && !service.getURLs()[0].isEmpty()) {\n+            url = service.getURLs()[0];\n+        }\n+        String restPath = service.getPropertyString(\"uri\");\n+        ThingUID thingUID = getThingUID(service);\n+        if (thingUID != null && url != null && restPath != null) {\n+            String label = \"openHAB server IP \" + service.getHostAddresses()[0];", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTUxNzk4Nw=="}, "originalCommit": {"oid": "81f2e2faf5d54ee22f8c579d08c37ef95508e197"}, "originalPosition": 80}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTY1ODQyMg==", "bodyText": "@kaikreuzer : the representation property was not yet defined. With it added, I see the IP (representation property) on the second line.\n@ghys : don't loose your time ;)", "url": "https://github.com/openhab/openhab-addons/pull/8791#discussion_r511658422", "createdAt": "2020-10-25T22:37:46Z", "author": {"login": "lolodomo"}, "path": "bundles/org.openhab.binding.remoteopenhab/src/main/java/org/openhab/binding/remoteopenhab/internal/discovery/RemoteopenhabDiscoveryParticipant.java", "diffHunk": "@@ -0,0 +1,89 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.remoteopenhab.internal.discovery;\n+\n+import static org.openhab.binding.remoteopenhab.internal.RemoteopenhabBindingConstants.*;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import javax.jmdns.ServiceInfo;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.remoteopenhab.internal.config.RemoteopenhabInstanceConfiguration;\n+import org.openhab.core.config.discovery.DiscoveryResult;\n+import org.openhab.core.config.discovery.DiscoveryResultBuilder;\n+import org.openhab.core.config.discovery.mdns.MDNSDiscoveryParticipant;\n+import org.openhab.core.thing.ThingTypeUID;\n+import org.openhab.core.thing.ThingUID;\n+import org.osgi.service.component.annotations.Component;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link RemoteopenhabDiscoveryParticipant} is responsible for discovering\n+ * the remote openHAB servers using mDNS discovery service.\n+ *\n+ * @author Laurent Garnier - Initial contribution\n+ */\n+@NonNullByDefault\n+@Component(service = MDNSDiscoveryParticipant.class, configurationPid = \"mdnsdiscovery.remoteopenhab\")\n+public class RemoteopenhabDiscoveryParticipant implements MDNSDiscoveryParticipant {\n+\n+    private final Logger logger = LoggerFactory.getLogger(RemoteopenhabDiscoveryParticipant.class);\n+\n+    private static final String SERVICE_TYPE = \"_openhab-server._tcp.local.\";\n+\n+    @Override\n+    public Set<ThingTypeUID> getSupportedThingTypeUIDs() {\n+        return SUPPORTED_THING_TYPES_UIDS;\n+    }\n+\n+    @Override\n+    public String getServiceType() {\n+        return SERVICE_TYPE;\n+    }\n+\n+    @Override\n+    public @Nullable ThingUID getThingUID(ServiceInfo service) {\n+        // We use the first host address as thing ID\n+        if (getServiceType().equals(service.getType()) && service.getHostAddresses() != null\n+                && service.getHostAddresses().length > 0 && !service.getHostAddresses()[0].isEmpty()) {\n+            return new ThingUID(BRIDGE_TYPE_SERVER, service.getHostAddresses()[0].replaceAll(\"[^A-Za-z0-9_]\", \"_\"));\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public @Nullable DiscoveryResult createResult(ServiceInfo service) {\n+        logger.debug(\"createResult ServiceInfo: {}\", service);\n+        DiscoveryResult result = null;\n+        String url = null;\n+        if (service.getURLs() != null && service.getURLs().length > 0 && !service.getURLs()[0].isEmpty()) {\n+            url = service.getURLs()[0];\n+        }\n+        String restPath = service.getPropertyString(\"uri\");\n+        ThingUID thingUID = getThingUID(service);\n+        if (thingUID != null && url != null && restPath != null) {\n+            String label = \"openHAB server IP \" + service.getHostAddresses()[0];", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTUxNzk4Nw=="}, "originalCommit": {"oid": "81f2e2faf5d54ee22f8c579d08c37ef95508e197"}, "originalPosition": 80}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTY1OTA3NA==", "bodyText": "Done (simplified label + representation property added)", "url": "https://github.com/openhab/openhab-addons/pull/8791#discussion_r511659074", "createdAt": "2020-10-25T22:43:15Z", "author": {"login": "lolodomo"}, "path": "bundles/org.openhab.binding.remoteopenhab/src/main/java/org/openhab/binding/remoteopenhab/internal/discovery/RemoteopenhabDiscoveryParticipant.java", "diffHunk": "@@ -0,0 +1,89 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.remoteopenhab.internal.discovery;\n+\n+import static org.openhab.binding.remoteopenhab.internal.RemoteopenhabBindingConstants.*;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import javax.jmdns.ServiceInfo;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.remoteopenhab.internal.config.RemoteopenhabInstanceConfiguration;\n+import org.openhab.core.config.discovery.DiscoveryResult;\n+import org.openhab.core.config.discovery.DiscoveryResultBuilder;\n+import org.openhab.core.config.discovery.mdns.MDNSDiscoveryParticipant;\n+import org.openhab.core.thing.ThingTypeUID;\n+import org.openhab.core.thing.ThingUID;\n+import org.osgi.service.component.annotations.Component;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link RemoteopenhabDiscoveryParticipant} is responsible for discovering\n+ * the remote openHAB servers using mDNS discovery service.\n+ *\n+ * @author Laurent Garnier - Initial contribution\n+ */\n+@NonNullByDefault\n+@Component(service = MDNSDiscoveryParticipant.class, configurationPid = \"mdnsdiscovery.remoteopenhab\")\n+public class RemoteopenhabDiscoveryParticipant implements MDNSDiscoveryParticipant {\n+\n+    private final Logger logger = LoggerFactory.getLogger(RemoteopenhabDiscoveryParticipant.class);\n+\n+    private static final String SERVICE_TYPE = \"_openhab-server._tcp.local.\";\n+\n+    @Override\n+    public Set<ThingTypeUID> getSupportedThingTypeUIDs() {\n+        return SUPPORTED_THING_TYPES_UIDS;\n+    }\n+\n+    @Override\n+    public String getServiceType() {\n+        return SERVICE_TYPE;\n+    }\n+\n+    @Override\n+    public @Nullable ThingUID getThingUID(ServiceInfo service) {\n+        // We use the first host address as thing ID\n+        if (getServiceType().equals(service.getType()) && service.getHostAddresses() != null\n+                && service.getHostAddresses().length > 0 && !service.getHostAddresses()[0].isEmpty()) {\n+            return new ThingUID(BRIDGE_TYPE_SERVER, service.getHostAddresses()[0].replaceAll(\"[^A-Za-z0-9_]\", \"_\"));\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public @Nullable DiscoveryResult createResult(ServiceInfo service) {\n+        logger.debug(\"createResult ServiceInfo: {}\", service);\n+        DiscoveryResult result = null;\n+        String url = null;\n+        if (service.getURLs() != null && service.getURLs().length > 0 && !service.getURLs()[0].isEmpty()) {\n+            url = service.getURLs()[0];\n+        }\n+        String restPath = service.getPropertyString(\"uri\");\n+        ThingUID thingUID = getThingUID(service);\n+        if (thingUID != null && url != null && restPath != null) {\n+            String label = \"openHAB server IP \" + service.getHostAddresses()[0];", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTUxNzk4Nw=="}, "originalCommit": {"oid": "81f2e2faf5d54ee22f8c579d08c37ef95508e197"}, "originalPosition": 80}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIwNDQxNjMwOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.remoteopenhab/src/main/java/org/openhab/binding/remoteopenhab/internal/discovery/RemoteopenhabDiscoveryParticipant.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNFQyMTo0OTo1OFrOHn0lOw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNFQyMjo1Njo1M1rOHn04eA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTUxODAxMQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        logger.info(\"Created a DiscoveryResult for remote openHAB server {} with REST URL {}\", thingUID,\n          \n          \n            \n                        logger.debug(\"Created a DiscoveryResult for remote openHAB server {} with REST URL {}\", thingUID,", "url": "https://github.com/openhab/openhab-addons/pull/8791#discussion_r511518011", "createdAt": "2020-10-24T21:49:58Z", "author": {"login": "kaikreuzer"}, "path": "bundles/org.openhab.binding.remoteopenhab/src/main/java/org/openhab/binding/remoteopenhab/internal/discovery/RemoteopenhabDiscoveryParticipant.java", "diffHunk": "@@ -0,0 +1,89 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.remoteopenhab.internal.discovery;\n+\n+import static org.openhab.binding.remoteopenhab.internal.RemoteopenhabBindingConstants.*;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import javax.jmdns.ServiceInfo;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.remoteopenhab.internal.config.RemoteopenhabInstanceConfiguration;\n+import org.openhab.core.config.discovery.DiscoveryResult;\n+import org.openhab.core.config.discovery.DiscoveryResultBuilder;\n+import org.openhab.core.config.discovery.mdns.MDNSDiscoveryParticipant;\n+import org.openhab.core.thing.ThingTypeUID;\n+import org.openhab.core.thing.ThingUID;\n+import org.osgi.service.component.annotations.Component;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link RemoteopenhabDiscoveryParticipant} is responsible for discovering\n+ * the remote openHAB servers using mDNS discovery service.\n+ *\n+ * @author Laurent Garnier - Initial contribution\n+ */\n+@NonNullByDefault\n+@Component(service = MDNSDiscoveryParticipant.class, configurationPid = \"mdnsdiscovery.remoteopenhab\")\n+public class RemoteopenhabDiscoveryParticipant implements MDNSDiscoveryParticipant {\n+\n+    private final Logger logger = LoggerFactory.getLogger(RemoteopenhabDiscoveryParticipant.class);\n+\n+    private static final String SERVICE_TYPE = \"_openhab-server._tcp.local.\";\n+\n+    @Override\n+    public Set<ThingTypeUID> getSupportedThingTypeUIDs() {\n+        return SUPPORTED_THING_TYPES_UIDS;\n+    }\n+\n+    @Override\n+    public String getServiceType() {\n+        return SERVICE_TYPE;\n+    }\n+\n+    @Override\n+    public @Nullable ThingUID getThingUID(ServiceInfo service) {\n+        // We use the first host address as thing ID\n+        if (getServiceType().equals(service.getType()) && service.getHostAddresses() != null\n+                && service.getHostAddresses().length > 0 && !service.getHostAddresses()[0].isEmpty()) {\n+            return new ThingUID(BRIDGE_TYPE_SERVER, service.getHostAddresses()[0].replaceAll(\"[^A-Za-z0-9_]\", \"_\"));\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public @Nullable DiscoveryResult createResult(ServiceInfo service) {\n+        logger.debug(\"createResult ServiceInfo: {}\", service);\n+        DiscoveryResult result = null;\n+        String url = null;\n+        if (service.getURLs() != null && service.getURLs().length > 0 && !service.getURLs()[0].isEmpty()) {\n+            url = service.getURLs()[0];\n+        }\n+        String restPath = service.getPropertyString(\"uri\");\n+        ThingUID thingUID = getThingUID(service);\n+        if (thingUID != null && url != null && restPath != null) {\n+            String label = \"openHAB server IP \" + service.getHostAddresses()[0];\n+            logger.info(\"Created a DiscoveryResult for remote openHAB server {} with REST URL {}\", thingUID,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "81f2e2faf5d54ee22f8c579d08c37ef95508e197"}, "originalPosition": 81}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTUyMjkzNg==", "bodyText": "Ok", "url": "https://github.com/openhab/openhab-addons/pull/8791#discussion_r511522936", "createdAt": "2020-10-24T22:56:53Z", "author": {"login": "lolodomo"}, "path": "bundles/org.openhab.binding.remoteopenhab/src/main/java/org/openhab/binding/remoteopenhab/internal/discovery/RemoteopenhabDiscoveryParticipant.java", "diffHunk": "@@ -0,0 +1,89 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.remoteopenhab.internal.discovery;\n+\n+import static org.openhab.binding.remoteopenhab.internal.RemoteopenhabBindingConstants.*;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import javax.jmdns.ServiceInfo;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.remoteopenhab.internal.config.RemoteopenhabInstanceConfiguration;\n+import org.openhab.core.config.discovery.DiscoveryResult;\n+import org.openhab.core.config.discovery.DiscoveryResultBuilder;\n+import org.openhab.core.config.discovery.mdns.MDNSDiscoveryParticipant;\n+import org.openhab.core.thing.ThingTypeUID;\n+import org.openhab.core.thing.ThingUID;\n+import org.osgi.service.component.annotations.Component;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link RemoteopenhabDiscoveryParticipant} is responsible for discovering\n+ * the remote openHAB servers using mDNS discovery service.\n+ *\n+ * @author Laurent Garnier - Initial contribution\n+ */\n+@NonNullByDefault\n+@Component(service = MDNSDiscoveryParticipant.class, configurationPid = \"mdnsdiscovery.remoteopenhab\")\n+public class RemoteopenhabDiscoveryParticipant implements MDNSDiscoveryParticipant {\n+\n+    private final Logger logger = LoggerFactory.getLogger(RemoteopenhabDiscoveryParticipant.class);\n+\n+    private static final String SERVICE_TYPE = \"_openhab-server._tcp.local.\";\n+\n+    @Override\n+    public Set<ThingTypeUID> getSupportedThingTypeUIDs() {\n+        return SUPPORTED_THING_TYPES_UIDS;\n+    }\n+\n+    @Override\n+    public String getServiceType() {\n+        return SERVICE_TYPE;\n+    }\n+\n+    @Override\n+    public @Nullable ThingUID getThingUID(ServiceInfo service) {\n+        // We use the first host address as thing ID\n+        if (getServiceType().equals(service.getType()) && service.getHostAddresses() != null\n+                && service.getHostAddresses().length > 0 && !service.getHostAddresses()[0].isEmpty()) {\n+            return new ThingUID(BRIDGE_TYPE_SERVER, service.getHostAddresses()[0].replaceAll(\"[^A-Za-z0-9_]\", \"_\"));\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public @Nullable DiscoveryResult createResult(ServiceInfo service) {\n+        logger.debug(\"createResult ServiceInfo: {}\", service);\n+        DiscoveryResult result = null;\n+        String url = null;\n+        if (service.getURLs() != null && service.getURLs().length > 0 && !service.getURLs()[0].isEmpty()) {\n+            url = service.getURLs()[0];\n+        }\n+        String restPath = service.getPropertyString(\"uri\");\n+        ThingUID thingUID = getThingUID(service);\n+        if (thingUID != null && url != null && restPath != null) {\n+            String label = \"openHAB server IP \" + service.getHostAddresses()[0];\n+            logger.info(\"Created a DiscoveryResult for remote openHAB server {} with REST URL {}\", thingUID,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTUxODAxMQ=="}, "originalCommit": {"oid": "81f2e2faf5d54ee22f8c579d08c37ef95508e197"}, "originalPosition": 81}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIwNDQxODY4OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.remoteopenhab/src/main/resources/OH-INF/thing/thing-types.xml", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNFQyMTo1MzowMFrOHn0mVw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNFQyMjo1ODo0OVrOHn04zQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTUxODI5NQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\t<label>Remote Server</label>\n          \n          \n            \n            \t\t<label>Remote openHAB Server</label>", "url": "https://github.com/openhab/openhab-addons/pull/8791#discussion_r511518295", "createdAt": "2020-10-24T21:53:00Z", "author": {"login": "kaikreuzer"}, "path": "bundles/org.openhab.binding.remoteopenhab/src/main/resources/OH-INF/thing/thing-types.xml", "diffHunk": "@@ -0,0 +1,28 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"remoteopenhab\"\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\n+\t<bridge-type id=\"server\">\n+\t\t<label>Remote Server</label>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "81f2e2faf5d54ee22f8c579d08c37ef95508e197"}, "originalPosition": 8}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTUyMzAyMQ==", "bodyText": "Ok", "url": "https://github.com/openhab/openhab-addons/pull/8791#discussion_r511523021", "createdAt": "2020-10-24T22:58:49Z", "author": {"login": "lolodomo"}, "path": "bundles/org.openhab.binding.remoteopenhab/src/main/resources/OH-INF/thing/thing-types.xml", "diffHunk": "@@ -0,0 +1,28 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"remoteopenhab\"\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\n+\t<bridge-type id=\"server\">\n+\t\t<label>Remote Server</label>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTUxODI5NQ=="}, "originalCommit": {"oid": "81f2e2faf5d54ee22f8c579d08c37ef95508e197"}, "originalPosition": 8}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIwNDQ0MDY4OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.remoteopenhab/src/main/feature/feature.xml", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNFQyMjoyNjoyMFrOHn0waA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNFQyMzowNjoxMlrOHn07HQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTUyMDg3Mg==", "bodyText": "This suggestion will be automated by openhab/static-code-analysis#395:\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            <features name=\"org.openhab.binding.nest-${project.version}\" xmlns=\"http://karaf.apache.org/xmlns/features/v1.4.0\">\n          \n          \n            \n            <features name=\"org.openhab.binding.remoteopenhab-${project.version}\" xmlns=\"http://karaf.apache.org/xmlns/features/v1.4.0\">", "url": "https://github.com/openhab/openhab-addons/pull/8791#discussion_r511520872", "createdAt": "2020-10-24T22:26:20Z", "author": {"login": "wborn"}, "path": "bundles/org.openhab.binding.remoteopenhab/src/main/feature/feature.xml", "diffHunk": "@@ -0,0 +1,9 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<features name=\"org.openhab.binding.nest-${project.version}\" xmlns=\"http://karaf.apache.org/xmlns/features/v1.4.0\">", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "761b31eb8795e521e507859e4b4b381028b4d905"}, "originalPosition": 2}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTUyMzYxMw==", "bodyText": "Done.\nI run \"mvn spotless:apply\" too.", "url": "https://github.com/openhab/openhab-addons/pull/8791#discussion_r511523613", "createdAt": "2020-10-24T23:06:12Z", "author": {"login": "lolodomo"}, "path": "bundles/org.openhab.binding.remoteopenhab/src/main/feature/feature.xml", "diffHunk": "@@ -0,0 +1,9 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<features name=\"org.openhab.binding.nest-${project.version}\" xmlns=\"http://karaf.apache.org/xmlns/features/v1.4.0\">", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTUyMDg3Mg=="}, "originalCommit": {"oid": "761b31eb8795e521e507859e4b4b381028b4d905"}, "originalPosition": 2}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIwNDQ0NDQzOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.remoteopenhab/src/main/java/org/openhab/binding/remoteopenhab/internal/discovery/RemoteopenhabDiscoveryParticipant.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNFQyMjozMjoyOVrOHn0yHw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNFQyMzowODo0M1rOHn07pA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTUyMTMxMQ==", "bodyText": "This can be a one liner in Java 11:\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        Map<String, Object> properties = new HashMap<>(1);\n          \n          \n            \n                        properties.put(RemoteopenhabInstanceConfiguration.REST_URL, url + restPath);\n          \n          \n            \n                        Map<String, Object> properties = Map.of(RemoteopenhabInstanceConfiguration.REST_URL, url + restPath);", "url": "https://github.com/openhab/openhab-addons/pull/8791#discussion_r511521311", "createdAt": "2020-10-24T22:32:29Z", "author": {"login": "wborn"}, "path": "bundles/org.openhab.binding.remoteopenhab/src/main/java/org/openhab/binding/remoteopenhab/internal/discovery/RemoteopenhabDiscoveryParticipant.java", "diffHunk": "@@ -0,0 +1,101 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.remoteopenhab.internal.discovery;\n+\n+import static org.openhab.binding.remoteopenhab.internal.RemoteopenhabBindingConstants.*;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import javax.jmdns.ServiceInfo;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.remoteopenhab.internal.config.RemoteopenhabInstanceConfiguration;\n+import org.openhab.core.config.discovery.DiscoveryResult;\n+import org.openhab.core.config.discovery.DiscoveryResultBuilder;\n+import org.openhab.core.config.discovery.mdns.MDNSDiscoveryParticipant;\n+import org.openhab.core.net.NetUtil;\n+import org.openhab.core.thing.ThingTypeUID;\n+import org.openhab.core.thing.ThingUID;\n+import org.osgi.service.component.annotations.Component;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link RemoteopenhabDiscoveryParticipant} is responsible for discovering\n+ * the remote openHAB servers using mDNS discovery service.\n+ *\n+ * @author Laurent Garnier - Initial contribution\n+ */\n+@NonNullByDefault\n+@Component(service = MDNSDiscoveryParticipant.class, configurationPid = \"mdnsdiscovery.remoteopenhab\")\n+public class RemoteopenhabDiscoveryParticipant implements MDNSDiscoveryParticipant {\n+\n+    private static final String SERVICE_TYPE = \"_openhab-server._tcp.local.\";\n+\n+    private final Logger logger = LoggerFactory.getLogger(RemoteopenhabDiscoveryParticipant.class);\n+\n+    @Override\n+    public Set<ThingTypeUID> getSupportedThingTypeUIDs() {\n+        return SUPPORTED_THING_TYPES_UIDS;\n+    }\n+\n+    @Override\n+    public String getServiceType() {\n+        return SERVICE_TYPE;\n+    }\n+\n+    @Override\n+    public @Nullable ThingUID getThingUID(ServiceInfo service) {\n+        // We use the first host address as thing ID\n+        // Host address matching a local IP address are ignored\n+        if (getServiceType().equals(service.getType()) && service.getHostAddresses() != null\n+                && service.getHostAddresses().length > 0 && !service.getHostAddresses()[0].isEmpty()\n+                && !matchLocalIpAddress(service.getHostAddresses()[0])) {\n+            return new ThingUID(BRIDGE_TYPE_SERVER, service.getHostAddresses()[0].replaceAll(\"[^A-Za-z0-9_]\", \"_\"));\n+        }\n+        return null;\n+    }\n+\n+    private boolean matchLocalIpAddress(String serviceHostAddress) {\n+        List<String> localIpAddresses = NetUtil.getAllInterfaceAddresses().stream()\n+                .filter(a -> !a.getAddress().isLinkLocalAddress())\n+                .map(a -> a.getAddress().getHostAddress().split(\"%\")[0]).collect(Collectors.toList());\n+        return localIpAddresses.contains(serviceHostAddress.replaceAll(\"\\\\[|\\\\]\", \"\"));\n+    }\n+\n+    @Override\n+    public @Nullable DiscoveryResult createResult(ServiceInfo service) {\n+        logger.debug(\"createResult ServiceInfo: {}\", service);\n+        DiscoveryResult result = null;\n+        String url = null;\n+        if (service.getURLs() != null && service.getURLs().length > 0 && !service.getURLs()[0].isEmpty()) {\n+            url = service.getURLs()[0];\n+        }\n+        String restPath = service.getPropertyString(\"uri\");\n+        ThingUID thingUID = getThingUID(service);\n+        if (thingUID != null && url != null && restPath != null) {\n+            String label = \"openHAB server IP \" + service.getHostAddresses()[0];\n+            logger.info(\"Created a DiscoveryResult for remote openHAB server {} with REST URL {}\", thingUID,\n+                    url + restPath);\n+            Map<String, Object> properties = new HashMap<>(1);\n+            properties.put(RemoteopenhabInstanceConfiguration.REST_URL, url + restPath);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "761b31eb8795e521e507859e4b4b381028b4d905"}, "originalPosition": 96}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTUyMzc0OA==", "bodyText": "Ok", "url": "https://github.com/openhab/openhab-addons/pull/8791#discussion_r511523748", "createdAt": "2020-10-24T23:08:43Z", "author": {"login": "lolodomo"}, "path": "bundles/org.openhab.binding.remoteopenhab/src/main/java/org/openhab/binding/remoteopenhab/internal/discovery/RemoteopenhabDiscoveryParticipant.java", "diffHunk": "@@ -0,0 +1,101 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.remoteopenhab.internal.discovery;\n+\n+import static org.openhab.binding.remoteopenhab.internal.RemoteopenhabBindingConstants.*;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import javax.jmdns.ServiceInfo;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.remoteopenhab.internal.config.RemoteopenhabInstanceConfiguration;\n+import org.openhab.core.config.discovery.DiscoveryResult;\n+import org.openhab.core.config.discovery.DiscoveryResultBuilder;\n+import org.openhab.core.config.discovery.mdns.MDNSDiscoveryParticipant;\n+import org.openhab.core.net.NetUtil;\n+import org.openhab.core.thing.ThingTypeUID;\n+import org.openhab.core.thing.ThingUID;\n+import org.osgi.service.component.annotations.Component;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link RemoteopenhabDiscoveryParticipant} is responsible for discovering\n+ * the remote openHAB servers using mDNS discovery service.\n+ *\n+ * @author Laurent Garnier - Initial contribution\n+ */\n+@NonNullByDefault\n+@Component(service = MDNSDiscoveryParticipant.class, configurationPid = \"mdnsdiscovery.remoteopenhab\")\n+public class RemoteopenhabDiscoveryParticipant implements MDNSDiscoveryParticipant {\n+\n+    private static final String SERVICE_TYPE = \"_openhab-server._tcp.local.\";\n+\n+    private final Logger logger = LoggerFactory.getLogger(RemoteopenhabDiscoveryParticipant.class);\n+\n+    @Override\n+    public Set<ThingTypeUID> getSupportedThingTypeUIDs() {\n+        return SUPPORTED_THING_TYPES_UIDS;\n+    }\n+\n+    @Override\n+    public String getServiceType() {\n+        return SERVICE_TYPE;\n+    }\n+\n+    @Override\n+    public @Nullable ThingUID getThingUID(ServiceInfo service) {\n+        // We use the first host address as thing ID\n+        // Host address matching a local IP address are ignored\n+        if (getServiceType().equals(service.getType()) && service.getHostAddresses() != null\n+                && service.getHostAddresses().length > 0 && !service.getHostAddresses()[0].isEmpty()\n+                && !matchLocalIpAddress(service.getHostAddresses()[0])) {\n+            return new ThingUID(BRIDGE_TYPE_SERVER, service.getHostAddresses()[0].replaceAll(\"[^A-Za-z0-9_]\", \"_\"));\n+        }\n+        return null;\n+    }\n+\n+    private boolean matchLocalIpAddress(String serviceHostAddress) {\n+        List<String> localIpAddresses = NetUtil.getAllInterfaceAddresses().stream()\n+                .filter(a -> !a.getAddress().isLinkLocalAddress())\n+                .map(a -> a.getAddress().getHostAddress().split(\"%\")[0]).collect(Collectors.toList());\n+        return localIpAddresses.contains(serviceHostAddress.replaceAll(\"\\\\[|\\\\]\", \"\"));\n+    }\n+\n+    @Override\n+    public @Nullable DiscoveryResult createResult(ServiceInfo service) {\n+        logger.debug(\"createResult ServiceInfo: {}\", service);\n+        DiscoveryResult result = null;\n+        String url = null;\n+        if (service.getURLs() != null && service.getURLs().length > 0 && !service.getURLs()[0].isEmpty()) {\n+            url = service.getURLs()[0];\n+        }\n+        String restPath = service.getPropertyString(\"uri\");\n+        ThingUID thingUID = getThingUID(service);\n+        if (thingUID != null && url != null && restPath != null) {\n+            String label = \"openHAB server IP \" + service.getHostAddresses()[0];\n+            logger.info(\"Created a DiscoveryResult for remote openHAB server {} with REST URL {}\", thingUID,\n+                    url + restPath);\n+            Map<String, Object> properties = new HashMap<>(1);\n+            properties.put(RemoteopenhabInstanceConfiguration.REST_URL, url + restPath);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTUyMTMxMQ=="}, "originalCommit": {"oid": "761b31eb8795e521e507859e4b4b381028b4d905"}, "originalPosition": 96}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIwNDQ0NjU2OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.remoteopenhab/src/main/java/org/openhab/binding/remoteopenhab/internal/handler/RemoteopenhabBridgeHandler.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNFQyMjozNjowNlrOHn0zFA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNFQyMzoxMTo0NlrOHn08qQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTUyMTU1Ng==", "bodyText": "Can you turn the magic number 50 into a constant with a descriptive name? It's also used below on line 541.", "url": "https://github.com/openhab/openhab-addons/pull/8791#discussion_r511521556", "createdAt": "2020-10-24T22:36:06Z", "author": {"login": "wborn"}, "path": "bundles/org.openhab.binding.remoteopenhab/src/main/java/org/openhab/binding/remoteopenhab/internal/handler/RemoteopenhabBridgeHandler.java", "diffHunk": "@@ -0,0 +1,554 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.remoteopenhab.internal.handler;\n+\n+import static org.openhab.binding.remoteopenhab.internal.RemoteopenhabBindingConstants.BINDING_ID;\n+\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.time.ZonedDateTime;\n+import java.time.format.DateTimeFormatter;\n+import java.time.format.DateTimeParseException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+\n+import javax.ws.rs.client.ClientBuilder;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.remoteopenhab.internal.RemoteopenhabChannelTypeProvider;\n+import org.openhab.binding.remoteopenhab.internal.RemoteopenhabStateDescriptionOptionProvider;\n+import org.openhab.binding.remoteopenhab.internal.config.RemoteopenhabInstanceConfiguration;\n+import org.openhab.binding.remoteopenhab.internal.data.Item;\n+import org.openhab.binding.remoteopenhab.internal.data.Option;\n+import org.openhab.binding.remoteopenhab.internal.data.StateDescription;\n+import org.openhab.binding.remoteopenhab.internal.exceptions.RemoteopenhabException;\n+import org.openhab.binding.remoteopenhab.internal.listener.RemoteopenhabStreamingDataListener;\n+import org.openhab.binding.remoteopenhab.internal.rest.RemoteopenhabRestClient;\n+import org.openhab.core.library.CoreItemFactory;\n+import org.openhab.core.library.types.DateTimeType;\n+import org.openhab.core.library.types.DecimalType;\n+import org.openhab.core.library.types.HSBType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.OpenClosedType;\n+import org.openhab.core.library.types.PercentType;\n+import org.openhab.core.library.types.PlayPauseType;\n+import org.openhab.core.library.types.PointType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.RawType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.net.NetUtil;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseBridgeHandler;\n+import org.openhab.core.thing.binding.builder.ChannelBuilder;\n+import org.openhab.core.thing.binding.builder.ThingBuilder;\n+import org.openhab.core.thing.type.AutoUpdatePolicy;\n+import org.openhab.core.thing.type.ChannelKind;\n+import org.openhab.core.thing.type.ChannelType;\n+import org.openhab.core.thing.type.ChannelTypeBuilder;\n+import org.openhab.core.thing.type.ChannelTypeUID;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.StateOption;\n+import org.openhab.core.types.TypeParser;\n+import org.openhab.core.types.UnDefType;\n+import org.osgi.service.jaxrs.client.SseEventSourceFactory;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+\n+/**\n+ * The {@link RemoteopenhabBridgeHandler} is responsible for handling commands and updating states\n+ * using the REST API of the remote openHAB server.\n+ *\n+ * @author Laurent Garnier - Initial contribution\n+ */\n+@NonNullByDefault\n+public class RemoteopenhabBridgeHandler extends BaseBridgeHandler implements RemoteopenhabStreamingDataListener {\n+\n+    private static final String DATE_FORMAT_PATTERN = \"yyyy-MM-dd'T'HH:mm:ss.SSSZ\";\n+    private static final DateTimeFormatter FORMATTER_DATE = DateTimeFormatter.ofPattern(DATE_FORMAT_PATTERN);\n+\n+    private static final long CONNECTION_TIMEOUT_MILLIS = TimeUnit.MILLISECONDS.convert(5, TimeUnit.MINUTES);\n+\n+    private final Logger logger = LoggerFactory.getLogger(RemoteopenhabBridgeHandler.class);\n+\n+    private final ClientBuilder clientBuilder;\n+    private final SseEventSourceFactory eventSourceFactory;\n+    private final RemoteopenhabChannelTypeProvider channelTypeProvider;\n+    private final RemoteopenhabStateDescriptionOptionProvider stateDescriptionProvider;\n+    private final Gson jsonParser;\n+\n+    private final Object updateThingLock = new Object();\n+\n+    private @NonNullByDefault({}) RemoteopenhabInstanceConfiguration config;\n+\n+    private @Nullable ScheduledFuture<?> checkConnectionJob;\n+    private @Nullable RemoteopenhabRestClient restClient;\n+\n+    public RemoteopenhabBridgeHandler(Bridge bridge, ClientBuilder clientBuilder,\n+            SseEventSourceFactory eventSourceFactory, RemoteopenhabChannelTypeProvider channelTypeProvider,\n+            RemoteopenhabStateDescriptionOptionProvider stateDescriptionProvider, final Gson jsonParser) {\n+        super(bridge);\n+        this.clientBuilder = clientBuilder;\n+        this.eventSourceFactory = eventSourceFactory;\n+        this.channelTypeProvider = channelTypeProvider;\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        this.jsonParser = jsonParser;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing remote openHAB handler for bridge {}\", getThing().getUID());\n+\n+        config = getConfigAs(RemoteopenhabInstanceConfiguration.class);\n+\n+        if (config.restUrl.trim().length() == 0) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"Undefined REST URL setting in the thing configuration\");\n+            return;\n+        }\n+        URL url;\n+        try {\n+            url = new URL(config.restUrl.trim());\n+        } catch (MalformedURLException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"Invalid REST URL setting in the thing configuration\");\n+            return;\n+        }\n+        if (!\"http\".equals(url.getProtocol())) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"Use HTTP protocol for the REST URL setting in the thing configuration\");\n+            return;\n+        }\n+        List<String> localIpAddresses = NetUtil.getAllInterfaceAddresses().stream()\n+                .filter(a -> !a.getAddress().isLinkLocalAddress())\n+                .map(a -> a.getAddress().getHostAddress().split(\"%\")[0]).collect(Collectors.toList());\n+        if (localIpAddresses.contains(url.getHost().replaceAll(\"\\\\[|\\\\]\", \"\"))) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"Do not link the local server with the REST URL setting in the thing configuration\");\n+            return;\n+        }\n+\n+        String urlStr = url.toString();\n+        if (urlStr.endsWith(\"/\")) {\n+            urlStr = urlStr.substring(0, urlStr.length() - 1);\n+        }\n+        logger.debug(\"REST URL = {}\", urlStr);\n+\n+        RemoteopenhabRestClient client = new RemoteopenhabRestClient(clientBuilder, eventSourceFactory, jsonParser,\n+                config.token, urlStr);\n+        restClient = client;\n+\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        startCheckConnectionJob(client);\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.debug(\"Disposing remote openHAB handler for bridge {}\", getThing().getUID());\n+        stopStreamingUpdates();\n+        stopCheckConnectionJob();\n+        this.restClient = null;\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (getThing().getStatus() != ThingStatus.ONLINE) {\n+            return;\n+        }\n+        RemoteopenhabRestClient client = restClient;\n+        if (client == null) {\n+            return;\n+        }\n+\n+        try {\n+            if (command instanceof RefreshType) {\n+                String state = client.getRemoteItemState(channelUID.getId());\n+                updateChannelState(channelUID.getId(), null, state);\n+            } else if (isLinked(channelUID)) {\n+                client.sendCommandToRemoteItem(channelUID.getId(), command);\n+                String commandStr = command.toFullString();\n+                logger.debug(\"Sending command {} to remote item {} succeeded\",\n+                        commandStr.length() < 50 ? commandStr : commandStr.substring(0, 50) + \"...\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "761b31eb8795e521e507859e4b4b381028b4d905"}, "originalPosition": 194}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTUyNDAwOQ==", "bodyText": "Done", "url": "https://github.com/openhab/openhab-addons/pull/8791#discussion_r511524009", "createdAt": "2020-10-24T23:11:46Z", "author": {"login": "lolodomo"}, "path": "bundles/org.openhab.binding.remoteopenhab/src/main/java/org/openhab/binding/remoteopenhab/internal/handler/RemoteopenhabBridgeHandler.java", "diffHunk": "@@ -0,0 +1,554 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.remoteopenhab.internal.handler;\n+\n+import static org.openhab.binding.remoteopenhab.internal.RemoteopenhabBindingConstants.BINDING_ID;\n+\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.time.ZonedDateTime;\n+import java.time.format.DateTimeFormatter;\n+import java.time.format.DateTimeParseException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+\n+import javax.ws.rs.client.ClientBuilder;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.remoteopenhab.internal.RemoteopenhabChannelTypeProvider;\n+import org.openhab.binding.remoteopenhab.internal.RemoteopenhabStateDescriptionOptionProvider;\n+import org.openhab.binding.remoteopenhab.internal.config.RemoteopenhabInstanceConfiguration;\n+import org.openhab.binding.remoteopenhab.internal.data.Item;\n+import org.openhab.binding.remoteopenhab.internal.data.Option;\n+import org.openhab.binding.remoteopenhab.internal.data.StateDescription;\n+import org.openhab.binding.remoteopenhab.internal.exceptions.RemoteopenhabException;\n+import org.openhab.binding.remoteopenhab.internal.listener.RemoteopenhabStreamingDataListener;\n+import org.openhab.binding.remoteopenhab.internal.rest.RemoteopenhabRestClient;\n+import org.openhab.core.library.CoreItemFactory;\n+import org.openhab.core.library.types.DateTimeType;\n+import org.openhab.core.library.types.DecimalType;\n+import org.openhab.core.library.types.HSBType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.OpenClosedType;\n+import org.openhab.core.library.types.PercentType;\n+import org.openhab.core.library.types.PlayPauseType;\n+import org.openhab.core.library.types.PointType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.RawType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.net.NetUtil;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseBridgeHandler;\n+import org.openhab.core.thing.binding.builder.ChannelBuilder;\n+import org.openhab.core.thing.binding.builder.ThingBuilder;\n+import org.openhab.core.thing.type.AutoUpdatePolicy;\n+import org.openhab.core.thing.type.ChannelKind;\n+import org.openhab.core.thing.type.ChannelType;\n+import org.openhab.core.thing.type.ChannelTypeBuilder;\n+import org.openhab.core.thing.type.ChannelTypeUID;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.StateOption;\n+import org.openhab.core.types.TypeParser;\n+import org.openhab.core.types.UnDefType;\n+import org.osgi.service.jaxrs.client.SseEventSourceFactory;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+\n+/**\n+ * The {@link RemoteopenhabBridgeHandler} is responsible for handling commands and updating states\n+ * using the REST API of the remote openHAB server.\n+ *\n+ * @author Laurent Garnier - Initial contribution\n+ */\n+@NonNullByDefault\n+public class RemoteopenhabBridgeHandler extends BaseBridgeHandler implements RemoteopenhabStreamingDataListener {\n+\n+    private static final String DATE_FORMAT_PATTERN = \"yyyy-MM-dd'T'HH:mm:ss.SSSZ\";\n+    private static final DateTimeFormatter FORMATTER_DATE = DateTimeFormatter.ofPattern(DATE_FORMAT_PATTERN);\n+\n+    private static final long CONNECTION_TIMEOUT_MILLIS = TimeUnit.MILLISECONDS.convert(5, TimeUnit.MINUTES);\n+\n+    private final Logger logger = LoggerFactory.getLogger(RemoteopenhabBridgeHandler.class);\n+\n+    private final ClientBuilder clientBuilder;\n+    private final SseEventSourceFactory eventSourceFactory;\n+    private final RemoteopenhabChannelTypeProvider channelTypeProvider;\n+    private final RemoteopenhabStateDescriptionOptionProvider stateDescriptionProvider;\n+    private final Gson jsonParser;\n+\n+    private final Object updateThingLock = new Object();\n+\n+    private @NonNullByDefault({}) RemoteopenhabInstanceConfiguration config;\n+\n+    private @Nullable ScheduledFuture<?> checkConnectionJob;\n+    private @Nullable RemoteopenhabRestClient restClient;\n+\n+    public RemoteopenhabBridgeHandler(Bridge bridge, ClientBuilder clientBuilder,\n+            SseEventSourceFactory eventSourceFactory, RemoteopenhabChannelTypeProvider channelTypeProvider,\n+            RemoteopenhabStateDescriptionOptionProvider stateDescriptionProvider, final Gson jsonParser) {\n+        super(bridge);\n+        this.clientBuilder = clientBuilder;\n+        this.eventSourceFactory = eventSourceFactory;\n+        this.channelTypeProvider = channelTypeProvider;\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        this.jsonParser = jsonParser;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing remote openHAB handler for bridge {}\", getThing().getUID());\n+\n+        config = getConfigAs(RemoteopenhabInstanceConfiguration.class);\n+\n+        if (config.restUrl.trim().length() == 0) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"Undefined REST URL setting in the thing configuration\");\n+            return;\n+        }\n+        URL url;\n+        try {\n+            url = new URL(config.restUrl.trim());\n+        } catch (MalformedURLException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"Invalid REST URL setting in the thing configuration\");\n+            return;\n+        }\n+        if (!\"http\".equals(url.getProtocol())) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"Use HTTP protocol for the REST URL setting in the thing configuration\");\n+            return;\n+        }\n+        List<String> localIpAddresses = NetUtil.getAllInterfaceAddresses().stream()\n+                .filter(a -> !a.getAddress().isLinkLocalAddress())\n+                .map(a -> a.getAddress().getHostAddress().split(\"%\")[0]).collect(Collectors.toList());\n+        if (localIpAddresses.contains(url.getHost().replaceAll(\"\\\\[|\\\\]\", \"\"))) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"Do not link the local server with the REST URL setting in the thing configuration\");\n+            return;\n+        }\n+\n+        String urlStr = url.toString();\n+        if (urlStr.endsWith(\"/\")) {\n+            urlStr = urlStr.substring(0, urlStr.length() - 1);\n+        }\n+        logger.debug(\"REST URL = {}\", urlStr);\n+\n+        RemoteopenhabRestClient client = new RemoteopenhabRestClient(clientBuilder, eventSourceFactory, jsonParser,\n+                config.token, urlStr);\n+        restClient = client;\n+\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        startCheckConnectionJob(client);\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.debug(\"Disposing remote openHAB handler for bridge {}\", getThing().getUID());\n+        stopStreamingUpdates();\n+        stopCheckConnectionJob();\n+        this.restClient = null;\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (getThing().getStatus() != ThingStatus.ONLINE) {\n+            return;\n+        }\n+        RemoteopenhabRestClient client = restClient;\n+        if (client == null) {\n+            return;\n+        }\n+\n+        try {\n+            if (command instanceof RefreshType) {\n+                String state = client.getRemoteItemState(channelUID.getId());\n+                updateChannelState(channelUID.getId(), null, state);\n+            } else if (isLinked(channelUID)) {\n+                client.sendCommandToRemoteItem(channelUID.getId(), command);\n+                String commandStr = command.toFullString();\n+                logger.debug(\"Sending command {} to remote item {} succeeded\",\n+                        commandStr.length() < 50 ? commandStr : commandStr.substring(0, 50) + \"...\",", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTUyMTU1Ng=="}, "originalCommit": {"oid": "761b31eb8795e521e507859e4b4b381028b4d905"}, "originalPosition": 194}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIwNDQ0ODUxOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.remoteopenhab/src/main/java/org/openhab/binding/remoteopenhab/internal/handler/RemoteopenhabBridgeHandler.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNFQyMjozOTo0OVrOHn0z-A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNFQyMzoxNTozNVrOHn09uA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTUyMTc4NA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        List<Item> items = new ArrayList<>();\n          \n          \n            \n                        items.add(newItem);\n          \n          \n            \n                        createChannels(items, false);\n          \n          \n            \n                        createChannels(List.of(newItem), false);", "url": "https://github.com/openhab/openhab-addons/pull/8791#discussion_r511521784", "createdAt": "2020-10-24T22:39:49Z", "author": {"login": "wborn"}, "path": "bundles/org.openhab.binding.remoteopenhab/src/main/java/org/openhab/binding/remoteopenhab/internal/handler/RemoteopenhabBridgeHandler.java", "diffHunk": "@@ -0,0 +1,554 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.remoteopenhab.internal.handler;\n+\n+import static org.openhab.binding.remoteopenhab.internal.RemoteopenhabBindingConstants.BINDING_ID;\n+\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.time.ZonedDateTime;\n+import java.time.format.DateTimeFormatter;\n+import java.time.format.DateTimeParseException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+\n+import javax.ws.rs.client.ClientBuilder;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.remoteopenhab.internal.RemoteopenhabChannelTypeProvider;\n+import org.openhab.binding.remoteopenhab.internal.RemoteopenhabStateDescriptionOptionProvider;\n+import org.openhab.binding.remoteopenhab.internal.config.RemoteopenhabInstanceConfiguration;\n+import org.openhab.binding.remoteopenhab.internal.data.Item;\n+import org.openhab.binding.remoteopenhab.internal.data.Option;\n+import org.openhab.binding.remoteopenhab.internal.data.StateDescription;\n+import org.openhab.binding.remoteopenhab.internal.exceptions.RemoteopenhabException;\n+import org.openhab.binding.remoteopenhab.internal.listener.RemoteopenhabStreamingDataListener;\n+import org.openhab.binding.remoteopenhab.internal.rest.RemoteopenhabRestClient;\n+import org.openhab.core.library.CoreItemFactory;\n+import org.openhab.core.library.types.DateTimeType;\n+import org.openhab.core.library.types.DecimalType;\n+import org.openhab.core.library.types.HSBType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.OpenClosedType;\n+import org.openhab.core.library.types.PercentType;\n+import org.openhab.core.library.types.PlayPauseType;\n+import org.openhab.core.library.types.PointType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.RawType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.net.NetUtil;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseBridgeHandler;\n+import org.openhab.core.thing.binding.builder.ChannelBuilder;\n+import org.openhab.core.thing.binding.builder.ThingBuilder;\n+import org.openhab.core.thing.type.AutoUpdatePolicy;\n+import org.openhab.core.thing.type.ChannelKind;\n+import org.openhab.core.thing.type.ChannelType;\n+import org.openhab.core.thing.type.ChannelTypeBuilder;\n+import org.openhab.core.thing.type.ChannelTypeUID;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.StateOption;\n+import org.openhab.core.types.TypeParser;\n+import org.openhab.core.types.UnDefType;\n+import org.osgi.service.jaxrs.client.SseEventSourceFactory;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+\n+/**\n+ * The {@link RemoteopenhabBridgeHandler} is responsible for handling commands and updating states\n+ * using the REST API of the remote openHAB server.\n+ *\n+ * @author Laurent Garnier - Initial contribution\n+ */\n+@NonNullByDefault\n+public class RemoteopenhabBridgeHandler extends BaseBridgeHandler implements RemoteopenhabStreamingDataListener {\n+\n+    private static final String DATE_FORMAT_PATTERN = \"yyyy-MM-dd'T'HH:mm:ss.SSSZ\";\n+    private static final DateTimeFormatter FORMATTER_DATE = DateTimeFormatter.ofPattern(DATE_FORMAT_PATTERN);\n+\n+    private static final long CONNECTION_TIMEOUT_MILLIS = TimeUnit.MILLISECONDS.convert(5, TimeUnit.MINUTES);\n+\n+    private final Logger logger = LoggerFactory.getLogger(RemoteopenhabBridgeHandler.class);\n+\n+    private final ClientBuilder clientBuilder;\n+    private final SseEventSourceFactory eventSourceFactory;\n+    private final RemoteopenhabChannelTypeProvider channelTypeProvider;\n+    private final RemoteopenhabStateDescriptionOptionProvider stateDescriptionProvider;\n+    private final Gson jsonParser;\n+\n+    private final Object updateThingLock = new Object();\n+\n+    private @NonNullByDefault({}) RemoteopenhabInstanceConfiguration config;\n+\n+    private @Nullable ScheduledFuture<?> checkConnectionJob;\n+    private @Nullable RemoteopenhabRestClient restClient;\n+\n+    public RemoteopenhabBridgeHandler(Bridge bridge, ClientBuilder clientBuilder,\n+            SseEventSourceFactory eventSourceFactory, RemoteopenhabChannelTypeProvider channelTypeProvider,\n+            RemoteopenhabStateDescriptionOptionProvider stateDescriptionProvider, final Gson jsonParser) {\n+        super(bridge);\n+        this.clientBuilder = clientBuilder;\n+        this.eventSourceFactory = eventSourceFactory;\n+        this.channelTypeProvider = channelTypeProvider;\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        this.jsonParser = jsonParser;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing remote openHAB handler for bridge {}\", getThing().getUID());\n+\n+        config = getConfigAs(RemoteopenhabInstanceConfiguration.class);\n+\n+        if (config.restUrl.trim().length() == 0) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"Undefined REST URL setting in the thing configuration\");\n+            return;\n+        }\n+        URL url;\n+        try {\n+            url = new URL(config.restUrl.trim());\n+        } catch (MalformedURLException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"Invalid REST URL setting in the thing configuration\");\n+            return;\n+        }\n+        if (!\"http\".equals(url.getProtocol())) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"Use HTTP protocol for the REST URL setting in the thing configuration\");\n+            return;\n+        }\n+        List<String> localIpAddresses = NetUtil.getAllInterfaceAddresses().stream()\n+                .filter(a -> !a.getAddress().isLinkLocalAddress())\n+                .map(a -> a.getAddress().getHostAddress().split(\"%\")[0]).collect(Collectors.toList());\n+        if (localIpAddresses.contains(url.getHost().replaceAll(\"\\\\[|\\\\]\", \"\"))) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"Do not link the local server with the REST URL setting in the thing configuration\");\n+            return;\n+        }\n+\n+        String urlStr = url.toString();\n+        if (urlStr.endsWith(\"/\")) {\n+            urlStr = urlStr.substring(0, urlStr.length() - 1);\n+        }\n+        logger.debug(\"REST URL = {}\", urlStr);\n+\n+        RemoteopenhabRestClient client = new RemoteopenhabRestClient(clientBuilder, eventSourceFactory, jsonParser,\n+                config.token, urlStr);\n+        restClient = client;\n+\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        startCheckConnectionJob(client);\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.debug(\"Disposing remote openHAB handler for bridge {}\", getThing().getUID());\n+        stopStreamingUpdates();\n+        stopCheckConnectionJob();\n+        this.restClient = null;\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (getThing().getStatus() != ThingStatus.ONLINE) {\n+            return;\n+        }\n+        RemoteopenhabRestClient client = restClient;\n+        if (client == null) {\n+            return;\n+        }\n+\n+        try {\n+            if (command instanceof RefreshType) {\n+                String state = client.getRemoteItemState(channelUID.getId());\n+                updateChannelState(channelUID.getId(), null, state);\n+            } else if (isLinked(channelUID)) {\n+                client.sendCommandToRemoteItem(channelUID.getId(), command);\n+                String commandStr = command.toFullString();\n+                logger.debug(\"Sending command {} to remote item {} succeeded\",\n+                        commandStr.length() < 50 ? commandStr : commandStr.substring(0, 50) + \"...\",\n+                        channelUID.getId());\n+            }\n+        } catch (RemoteopenhabException e) {\n+            logger.debug(\"{}\", e.getMessage());\n+        }\n+    }\n+\n+    private void createChannels(List<Item> items, boolean replace) {\n+        synchronized (updateThingLock) {\n+            int nbGroups = 0;\n+            List<Channel> channels = new ArrayList<>();\n+            for (Item item : items) {\n+                String itemType = item.type;\n+                if (\"Group\".equals(itemType)) {\n+                    if (item.groupType.isEmpty()) {\n+                        // Standard groups are ignored\n+                        nbGroups++;\n+                        continue;\n+                    } else {\n+                        itemType = item.groupType;\n+                    }\n+                }\n+                String channelTypeId = String.format(\"item%s\", itemType.replace(\":\", \"\"));\n+                ChannelTypeUID channelTypeUID = new ChannelTypeUID(BINDING_ID, channelTypeId);\n+                ChannelType channelType = channelTypeProvider.getChannelType(channelTypeUID, null);\n+                String label;\n+                String description;\n+                if (channelType == null) {\n+                    logger.trace(\"Create the channel type {} for item type {}\", channelTypeUID, itemType);\n+                    label = String.format(\"Remote %s Item\", itemType);\n+                    description = String.format(\"An item of type %s from the remote server.\", itemType);\n+                    channelType = ChannelTypeBuilder.state(channelTypeUID, label, itemType).withDescription(description)\n+                            .withAutoUpdatePolicy(AutoUpdatePolicy.VETO).build();\n+                    channelTypeProvider.addChannelType(channelType);\n+                }\n+                ChannelUID channelUID = new ChannelUID(getThing().getUID(), item.name);\n+                logger.trace(\"Create the channel {} of type {}\", channelUID, channelTypeUID);\n+                label = item.name;\n+                description = String.format(\"Item %s from the remote server.\", item.name);\n+                channels.add(ChannelBuilder.create(channelUID, itemType).withType(channelTypeUID)\n+                        .withKind(ChannelKind.STATE).withLabel(label).withDescription(description).build());\n+            }\n+            ThingBuilder thingBuilder = editThing();\n+            if (replace) {\n+                thingBuilder.withChannels(channels);\n+                updateThing(thingBuilder.build());\n+                logger.debug(\"{} channels defined for the thing {} (from {} items including {} groups)\",\n+                        channels.size(), getThing().getUID(), items.size(), nbGroups);\n+            } else if (channels.size() > 0) {\n+                int nbRemoved = 0;\n+                for (Channel channel : channels) {\n+                    if (getThing().getChannel(channel.getUID()) != null) {\n+                        thingBuilder.withoutChannel(channel.getUID());\n+                        nbRemoved++;\n+                    }\n+                }\n+                if (nbRemoved > 0) {\n+                    logger.debug(\"{} channels removed for the thing {} (from {} items)\", nbRemoved, getThing().getUID(),\n+                            items.size());\n+                }\n+                for (Channel channel : channels) {\n+                    thingBuilder.withChannel(channel);\n+                }\n+                updateThing(thingBuilder.build());\n+                if (nbGroups > 0) {\n+                    logger.debug(\"{} channels added for the thing {} (from {} items including {} groups)\",\n+                            channels.size(), getThing().getUID(), items.size(), nbGroups);\n+                } else {\n+                    logger.debug(\"{} channels added for the thing {} (from {} items)\", channels.size(),\n+                            getThing().getUID(), items.size());\n+                }\n+            }\n+        }\n+    }\n+\n+    private void removeChannels(List<Item> items) {\n+        synchronized (updateThingLock) {\n+            int nbRemoved = 0;\n+            ThingBuilder thingBuilder = editThing();\n+            for (Item item : items) {\n+                Channel channel = getThing().getChannel(item.name);\n+                if (channel != null) {\n+                    thingBuilder.withoutChannel(channel.getUID());\n+                    nbRemoved++;\n+                }\n+            }\n+            if (nbRemoved > 0) {\n+                updateThing(thingBuilder.build());\n+                logger.debug(\"{} channels removed for the thing {} (from {} items)\", nbRemoved, getThing().getUID(),\n+                        items.size());\n+            }\n+        }\n+    }\n+\n+    private void setStateOptions(List<Item> items) {\n+        for (Item item : items) {\n+            Channel channel = getThing().getChannel(item.name);\n+            StateDescription descr = item.stateDescription;\n+            List<Option> options = descr == null ? null : descr.options;\n+            if (channel != null && options != null && options.size() > 0) {\n+                List<StateOption> stateOptions = new ArrayList<>();\n+                for (Option option : options) {\n+                    stateOptions.add(new StateOption(option.value, option.label));\n+                }\n+                stateDescriptionProvider.setStateOptions(channel.getUID(), stateOptions);\n+                logger.trace(\"{} options set for the channel {}\", options.size(), channel.getUID());\n+            }\n+        }\n+    }\n+\n+    public void checkConnection(RemoteopenhabRestClient client) {\n+        logger.debug(\"Try the root REST API...\");\n+        try {\n+            client.tryApi();\n+            if (client.getRestApiVersion() == null) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                        \"OH 1.x server not supported by the binding\");\n+            } else {\n+                List<Item> items = client.getRemoteItems();\n+\n+                createChannels(items, true);\n+                setStateOptions(items);\n+                for (Item item : items) {\n+                    updateChannelState(item.name, null, item.state);\n+                }\n+\n+                updateStatus(ThingStatus.ONLINE);\n+\n+                restartStreamingUpdates();\n+            }\n+        } catch (RemoteopenhabException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e.getMessage());\n+            stopStreamingUpdates();\n+        }\n+    }\n+\n+    private void startCheckConnectionJob(RemoteopenhabRestClient client) {\n+        ScheduledFuture<?> localCheckConnectionJob = checkConnectionJob;\n+        if (localCheckConnectionJob == null || localCheckConnectionJob.isCancelled()) {\n+            checkConnectionJob = scheduler.scheduleWithFixedDelay(() -> {\n+                long millisSinceLastEvent = System.currentTimeMillis() - client.getLastEventTimestamp();\n+                if (millisSinceLastEvent > CONNECTION_TIMEOUT_MILLIS) {\n+                    logger.debug(\"Check: Disconnected from streaming events, millisSinceLastEvent={}\",\n+                            millisSinceLastEvent);\n+                    checkConnection(client);\n+                } else {\n+                    logger.debug(\"Check: Receiving streaming events, millisSinceLastEvent={}\", millisSinceLastEvent);\n+                }\n+            }, 0, CONNECTION_TIMEOUT_MILLIS, TimeUnit.MILLISECONDS);\n+        }\n+    }\n+\n+    private void stopCheckConnectionJob() {\n+        ScheduledFuture<?> localCheckConnectionJob = checkConnectionJob;\n+        if (localCheckConnectionJob != null) {\n+            localCheckConnectionJob.cancel(true);\n+            checkConnectionJob = null;\n+        }\n+    }\n+\n+    private void restartStreamingUpdates() {\n+        RemoteopenhabRestClient client = restClient;\n+        if (client != null) {\n+            synchronized (client) {\n+                stopStreamingUpdates();\n+                startStreamingUpdates();\n+            }\n+        }\n+    }\n+\n+    private void startStreamingUpdates() {\n+        RemoteopenhabRestClient client = restClient;\n+        if (client != null) {\n+            synchronized (client) {\n+                client.addStreamingDataListener(this);\n+                client.start();\n+            }\n+        }\n+    }\n+\n+    private void stopStreamingUpdates() {\n+        RemoteopenhabRestClient client = restClient;\n+        if (client != null) {\n+            synchronized (client) {\n+                client.stop();\n+                client.removeStreamingDataListener(this);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void onConnected() {\n+        updateStatus(ThingStatus.ONLINE);\n+    }\n+\n+    @Override\n+    public void onError(String message) {\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, message);\n+    }\n+\n+    @Override\n+    public void onItemStateEvent(String itemName, String stateType, String state) {\n+        updateChannelState(itemName, stateType, state);\n+    }\n+\n+    @Override\n+    public void onItemAdded(Item item) {\n+        createChannels(List.of(item), false);\n+    }\n+\n+    @Override\n+    public void onItemRemoved(Item item) {\n+        removeChannels(List.of(item));\n+    }\n+\n+    @Override\n+    public void onItemUpdated(Item newItem, Item oldItem) {\n+        if (!newItem.type.equals(oldItem.type)) {\n+            List<Item> items = new ArrayList<>();\n+            items.add(newItem);\n+            createChannels(items, false);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "761b31eb8795e521e507859e4b4b381028b4d905"}, "originalPosition": 415}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTUyNDI4MA==", "bodyText": "I already changed 2 just below this morning but forgot this one.\nDone", "url": "https://github.com/openhab/openhab-addons/pull/8791#discussion_r511524280", "createdAt": "2020-10-24T23:15:35Z", "author": {"login": "lolodomo"}, "path": "bundles/org.openhab.binding.remoteopenhab/src/main/java/org/openhab/binding/remoteopenhab/internal/handler/RemoteopenhabBridgeHandler.java", "diffHunk": "@@ -0,0 +1,554 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.remoteopenhab.internal.handler;\n+\n+import static org.openhab.binding.remoteopenhab.internal.RemoteopenhabBindingConstants.BINDING_ID;\n+\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.time.ZonedDateTime;\n+import java.time.format.DateTimeFormatter;\n+import java.time.format.DateTimeParseException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+\n+import javax.ws.rs.client.ClientBuilder;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.remoteopenhab.internal.RemoteopenhabChannelTypeProvider;\n+import org.openhab.binding.remoteopenhab.internal.RemoteopenhabStateDescriptionOptionProvider;\n+import org.openhab.binding.remoteopenhab.internal.config.RemoteopenhabInstanceConfiguration;\n+import org.openhab.binding.remoteopenhab.internal.data.Item;\n+import org.openhab.binding.remoteopenhab.internal.data.Option;\n+import org.openhab.binding.remoteopenhab.internal.data.StateDescription;\n+import org.openhab.binding.remoteopenhab.internal.exceptions.RemoteopenhabException;\n+import org.openhab.binding.remoteopenhab.internal.listener.RemoteopenhabStreamingDataListener;\n+import org.openhab.binding.remoteopenhab.internal.rest.RemoteopenhabRestClient;\n+import org.openhab.core.library.CoreItemFactory;\n+import org.openhab.core.library.types.DateTimeType;\n+import org.openhab.core.library.types.DecimalType;\n+import org.openhab.core.library.types.HSBType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.OpenClosedType;\n+import org.openhab.core.library.types.PercentType;\n+import org.openhab.core.library.types.PlayPauseType;\n+import org.openhab.core.library.types.PointType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.RawType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.net.NetUtil;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseBridgeHandler;\n+import org.openhab.core.thing.binding.builder.ChannelBuilder;\n+import org.openhab.core.thing.binding.builder.ThingBuilder;\n+import org.openhab.core.thing.type.AutoUpdatePolicy;\n+import org.openhab.core.thing.type.ChannelKind;\n+import org.openhab.core.thing.type.ChannelType;\n+import org.openhab.core.thing.type.ChannelTypeBuilder;\n+import org.openhab.core.thing.type.ChannelTypeUID;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.StateOption;\n+import org.openhab.core.types.TypeParser;\n+import org.openhab.core.types.UnDefType;\n+import org.osgi.service.jaxrs.client.SseEventSourceFactory;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+\n+/**\n+ * The {@link RemoteopenhabBridgeHandler} is responsible for handling commands and updating states\n+ * using the REST API of the remote openHAB server.\n+ *\n+ * @author Laurent Garnier - Initial contribution\n+ */\n+@NonNullByDefault\n+public class RemoteopenhabBridgeHandler extends BaseBridgeHandler implements RemoteopenhabStreamingDataListener {\n+\n+    private static final String DATE_FORMAT_PATTERN = \"yyyy-MM-dd'T'HH:mm:ss.SSSZ\";\n+    private static final DateTimeFormatter FORMATTER_DATE = DateTimeFormatter.ofPattern(DATE_FORMAT_PATTERN);\n+\n+    private static final long CONNECTION_TIMEOUT_MILLIS = TimeUnit.MILLISECONDS.convert(5, TimeUnit.MINUTES);\n+\n+    private final Logger logger = LoggerFactory.getLogger(RemoteopenhabBridgeHandler.class);\n+\n+    private final ClientBuilder clientBuilder;\n+    private final SseEventSourceFactory eventSourceFactory;\n+    private final RemoteopenhabChannelTypeProvider channelTypeProvider;\n+    private final RemoteopenhabStateDescriptionOptionProvider stateDescriptionProvider;\n+    private final Gson jsonParser;\n+\n+    private final Object updateThingLock = new Object();\n+\n+    private @NonNullByDefault({}) RemoteopenhabInstanceConfiguration config;\n+\n+    private @Nullable ScheduledFuture<?> checkConnectionJob;\n+    private @Nullable RemoteopenhabRestClient restClient;\n+\n+    public RemoteopenhabBridgeHandler(Bridge bridge, ClientBuilder clientBuilder,\n+            SseEventSourceFactory eventSourceFactory, RemoteopenhabChannelTypeProvider channelTypeProvider,\n+            RemoteopenhabStateDescriptionOptionProvider stateDescriptionProvider, final Gson jsonParser) {\n+        super(bridge);\n+        this.clientBuilder = clientBuilder;\n+        this.eventSourceFactory = eventSourceFactory;\n+        this.channelTypeProvider = channelTypeProvider;\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        this.jsonParser = jsonParser;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing remote openHAB handler for bridge {}\", getThing().getUID());\n+\n+        config = getConfigAs(RemoteopenhabInstanceConfiguration.class);\n+\n+        if (config.restUrl.trim().length() == 0) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"Undefined REST URL setting in the thing configuration\");\n+            return;\n+        }\n+        URL url;\n+        try {\n+            url = new URL(config.restUrl.trim());\n+        } catch (MalformedURLException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"Invalid REST URL setting in the thing configuration\");\n+            return;\n+        }\n+        if (!\"http\".equals(url.getProtocol())) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"Use HTTP protocol for the REST URL setting in the thing configuration\");\n+            return;\n+        }\n+        List<String> localIpAddresses = NetUtil.getAllInterfaceAddresses().stream()\n+                .filter(a -> !a.getAddress().isLinkLocalAddress())\n+                .map(a -> a.getAddress().getHostAddress().split(\"%\")[0]).collect(Collectors.toList());\n+        if (localIpAddresses.contains(url.getHost().replaceAll(\"\\\\[|\\\\]\", \"\"))) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"Do not link the local server with the REST URL setting in the thing configuration\");\n+            return;\n+        }\n+\n+        String urlStr = url.toString();\n+        if (urlStr.endsWith(\"/\")) {\n+            urlStr = urlStr.substring(0, urlStr.length() - 1);\n+        }\n+        logger.debug(\"REST URL = {}\", urlStr);\n+\n+        RemoteopenhabRestClient client = new RemoteopenhabRestClient(clientBuilder, eventSourceFactory, jsonParser,\n+                config.token, urlStr);\n+        restClient = client;\n+\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        startCheckConnectionJob(client);\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.debug(\"Disposing remote openHAB handler for bridge {}\", getThing().getUID());\n+        stopStreamingUpdates();\n+        stopCheckConnectionJob();\n+        this.restClient = null;\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (getThing().getStatus() != ThingStatus.ONLINE) {\n+            return;\n+        }\n+        RemoteopenhabRestClient client = restClient;\n+        if (client == null) {\n+            return;\n+        }\n+\n+        try {\n+            if (command instanceof RefreshType) {\n+                String state = client.getRemoteItemState(channelUID.getId());\n+                updateChannelState(channelUID.getId(), null, state);\n+            } else if (isLinked(channelUID)) {\n+                client.sendCommandToRemoteItem(channelUID.getId(), command);\n+                String commandStr = command.toFullString();\n+                logger.debug(\"Sending command {} to remote item {} succeeded\",\n+                        commandStr.length() < 50 ? commandStr : commandStr.substring(0, 50) + \"...\",\n+                        channelUID.getId());\n+            }\n+        } catch (RemoteopenhabException e) {\n+            logger.debug(\"{}\", e.getMessage());\n+        }\n+    }\n+\n+    private void createChannels(List<Item> items, boolean replace) {\n+        synchronized (updateThingLock) {\n+            int nbGroups = 0;\n+            List<Channel> channels = new ArrayList<>();\n+            for (Item item : items) {\n+                String itemType = item.type;\n+                if (\"Group\".equals(itemType)) {\n+                    if (item.groupType.isEmpty()) {\n+                        // Standard groups are ignored\n+                        nbGroups++;\n+                        continue;\n+                    } else {\n+                        itemType = item.groupType;\n+                    }\n+                }\n+                String channelTypeId = String.format(\"item%s\", itemType.replace(\":\", \"\"));\n+                ChannelTypeUID channelTypeUID = new ChannelTypeUID(BINDING_ID, channelTypeId);\n+                ChannelType channelType = channelTypeProvider.getChannelType(channelTypeUID, null);\n+                String label;\n+                String description;\n+                if (channelType == null) {\n+                    logger.trace(\"Create the channel type {} for item type {}\", channelTypeUID, itemType);\n+                    label = String.format(\"Remote %s Item\", itemType);\n+                    description = String.format(\"An item of type %s from the remote server.\", itemType);\n+                    channelType = ChannelTypeBuilder.state(channelTypeUID, label, itemType).withDescription(description)\n+                            .withAutoUpdatePolicy(AutoUpdatePolicy.VETO).build();\n+                    channelTypeProvider.addChannelType(channelType);\n+                }\n+                ChannelUID channelUID = new ChannelUID(getThing().getUID(), item.name);\n+                logger.trace(\"Create the channel {} of type {}\", channelUID, channelTypeUID);\n+                label = item.name;\n+                description = String.format(\"Item %s from the remote server.\", item.name);\n+                channels.add(ChannelBuilder.create(channelUID, itemType).withType(channelTypeUID)\n+                        .withKind(ChannelKind.STATE).withLabel(label).withDescription(description).build());\n+            }\n+            ThingBuilder thingBuilder = editThing();\n+            if (replace) {\n+                thingBuilder.withChannels(channels);\n+                updateThing(thingBuilder.build());\n+                logger.debug(\"{} channels defined for the thing {} (from {} items including {} groups)\",\n+                        channels.size(), getThing().getUID(), items.size(), nbGroups);\n+            } else if (channels.size() > 0) {\n+                int nbRemoved = 0;\n+                for (Channel channel : channels) {\n+                    if (getThing().getChannel(channel.getUID()) != null) {\n+                        thingBuilder.withoutChannel(channel.getUID());\n+                        nbRemoved++;\n+                    }\n+                }\n+                if (nbRemoved > 0) {\n+                    logger.debug(\"{} channels removed for the thing {} (from {} items)\", nbRemoved, getThing().getUID(),\n+                            items.size());\n+                }\n+                for (Channel channel : channels) {\n+                    thingBuilder.withChannel(channel);\n+                }\n+                updateThing(thingBuilder.build());\n+                if (nbGroups > 0) {\n+                    logger.debug(\"{} channels added for the thing {} (from {} items including {} groups)\",\n+                            channels.size(), getThing().getUID(), items.size(), nbGroups);\n+                } else {\n+                    logger.debug(\"{} channels added for the thing {} (from {} items)\", channels.size(),\n+                            getThing().getUID(), items.size());\n+                }\n+            }\n+        }\n+    }\n+\n+    private void removeChannels(List<Item> items) {\n+        synchronized (updateThingLock) {\n+            int nbRemoved = 0;\n+            ThingBuilder thingBuilder = editThing();\n+            for (Item item : items) {\n+                Channel channel = getThing().getChannel(item.name);\n+                if (channel != null) {\n+                    thingBuilder.withoutChannel(channel.getUID());\n+                    nbRemoved++;\n+                }\n+            }\n+            if (nbRemoved > 0) {\n+                updateThing(thingBuilder.build());\n+                logger.debug(\"{} channels removed for the thing {} (from {} items)\", nbRemoved, getThing().getUID(),\n+                        items.size());\n+            }\n+        }\n+    }\n+\n+    private void setStateOptions(List<Item> items) {\n+        for (Item item : items) {\n+            Channel channel = getThing().getChannel(item.name);\n+            StateDescription descr = item.stateDescription;\n+            List<Option> options = descr == null ? null : descr.options;\n+            if (channel != null && options != null && options.size() > 0) {\n+                List<StateOption> stateOptions = new ArrayList<>();\n+                for (Option option : options) {\n+                    stateOptions.add(new StateOption(option.value, option.label));\n+                }\n+                stateDescriptionProvider.setStateOptions(channel.getUID(), stateOptions);\n+                logger.trace(\"{} options set for the channel {}\", options.size(), channel.getUID());\n+            }\n+        }\n+    }\n+\n+    public void checkConnection(RemoteopenhabRestClient client) {\n+        logger.debug(\"Try the root REST API...\");\n+        try {\n+            client.tryApi();\n+            if (client.getRestApiVersion() == null) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                        \"OH 1.x server not supported by the binding\");\n+            } else {\n+                List<Item> items = client.getRemoteItems();\n+\n+                createChannels(items, true);\n+                setStateOptions(items);\n+                for (Item item : items) {\n+                    updateChannelState(item.name, null, item.state);\n+                }\n+\n+                updateStatus(ThingStatus.ONLINE);\n+\n+                restartStreamingUpdates();\n+            }\n+        } catch (RemoteopenhabException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e.getMessage());\n+            stopStreamingUpdates();\n+        }\n+    }\n+\n+    private void startCheckConnectionJob(RemoteopenhabRestClient client) {\n+        ScheduledFuture<?> localCheckConnectionJob = checkConnectionJob;\n+        if (localCheckConnectionJob == null || localCheckConnectionJob.isCancelled()) {\n+            checkConnectionJob = scheduler.scheduleWithFixedDelay(() -> {\n+                long millisSinceLastEvent = System.currentTimeMillis() - client.getLastEventTimestamp();\n+                if (millisSinceLastEvent > CONNECTION_TIMEOUT_MILLIS) {\n+                    logger.debug(\"Check: Disconnected from streaming events, millisSinceLastEvent={}\",\n+                            millisSinceLastEvent);\n+                    checkConnection(client);\n+                } else {\n+                    logger.debug(\"Check: Receiving streaming events, millisSinceLastEvent={}\", millisSinceLastEvent);\n+                }\n+            }, 0, CONNECTION_TIMEOUT_MILLIS, TimeUnit.MILLISECONDS);\n+        }\n+    }\n+\n+    private void stopCheckConnectionJob() {\n+        ScheduledFuture<?> localCheckConnectionJob = checkConnectionJob;\n+        if (localCheckConnectionJob != null) {\n+            localCheckConnectionJob.cancel(true);\n+            checkConnectionJob = null;\n+        }\n+    }\n+\n+    private void restartStreamingUpdates() {\n+        RemoteopenhabRestClient client = restClient;\n+        if (client != null) {\n+            synchronized (client) {\n+                stopStreamingUpdates();\n+                startStreamingUpdates();\n+            }\n+        }\n+    }\n+\n+    private void startStreamingUpdates() {\n+        RemoteopenhabRestClient client = restClient;\n+        if (client != null) {\n+            synchronized (client) {\n+                client.addStreamingDataListener(this);\n+                client.start();\n+            }\n+        }\n+    }\n+\n+    private void stopStreamingUpdates() {\n+        RemoteopenhabRestClient client = restClient;\n+        if (client != null) {\n+            synchronized (client) {\n+                client.stop();\n+                client.removeStreamingDataListener(this);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void onConnected() {\n+        updateStatus(ThingStatus.ONLINE);\n+    }\n+\n+    @Override\n+    public void onError(String message) {\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, message);\n+    }\n+\n+    @Override\n+    public void onItemStateEvent(String itemName, String stateType, String state) {\n+        updateChannelState(itemName, stateType, state);\n+    }\n+\n+    @Override\n+    public void onItemAdded(Item item) {\n+        createChannels(List.of(item), false);\n+    }\n+\n+    @Override\n+    public void onItemRemoved(Item item) {\n+        removeChannels(List.of(item));\n+    }\n+\n+    @Override\n+    public void onItemUpdated(Item newItem, Item oldItem) {\n+        if (!newItem.type.equals(oldItem.type)) {\n+            List<Item> items = new ArrayList<>();\n+            items.add(newItem);\n+            createChannels(items, false);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTUyMTc4NA=="}, "originalCommit": {"oid": "761b31eb8795e521e507859e4b4b381028b4d905"}, "originalPosition": 415}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4091, "cost": 1, "resetAt": "2021-11-13T12:10:21Z"}}}