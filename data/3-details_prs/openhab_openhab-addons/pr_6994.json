{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzczMzk5MDE5", "number": 6994, "title": "[sunspec] Modbus: sunspec bundle auto discovery", "bodyText": "This pull request is the follow up of PR #6331 and adds the auto discovery feature to that.\nUntil PR #6331 is not merged this contains commits from that PR as well, so when reviewing please check the last commit only.\nSunSpec splits the data of the devices into blocks that have a type and a length. So what the auto discovery does is that it will iterate over all these blocks and add the supported types as new things.\nI didn't add more device types yet to keep the commit clean as much as possible", "createdAt": "2020-02-10T23:07:26Z", "url": "https://github.com/openhab/openhab-addons/pull/6994", "merged": true, "mergeCommit": {"oid": "47ecc505d10ae30caf9eff43a8ded6ca21d2b77a"}, "closed": true, "closedAt": "2020-04-20T15:28:35Z", "author": {"login": "mrbig"}, "timelineItems": {"totalCount": 12, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcNFPDgABqjMxMjQ5OTk3Njk=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcZg0D-gFqTM5NjU2MzE5NA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "091ac59feac5eefd69c2f69fc0743b6bd8715459", "author": {"user": {"login": "mrbig", "name": "Nagy Attila G\u00e1bor"}}, "url": "https://github.com/openhab/openhab-addons/commit/091ac59feac5eefd69c2f69fc0743b6bd8715459", "committedDate": "2020-01-31T21:44:00Z", "message": "[sunspec] Added discovery process\n\n\nSigned-off-by: Nagy Attila Gabor <mrbig@sneaker.hu>"}, "afterCommit": {"oid": "c79dfafc15635c3d5ea30a09bb2785bba6919288", "author": {"user": {"login": "mrbig", "name": "Nagy Attila G\u00e1bor"}}, "url": "https://github.com/openhab/openhab-addons/commit/c79dfafc15635c3d5ea30a09bb2785bba6919288", "committedDate": "2020-03-12T23:19:14Z", "message": "[sunspec] Added discovery process\n\n\nSigned-off-by: Nagy Attila Gabor <mrbig@sneaker.hu>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "c79dfafc15635c3d5ea30a09bb2785bba6919288", "author": {"user": {"login": "mrbig", "name": "Nagy Attila G\u00e1bor"}}, "url": "https://github.com/openhab/openhab-addons/commit/c79dfafc15635c3d5ea30a09bb2785bba6919288", "committedDate": "2020-03-12T23:19:14Z", "message": "[sunspec] Added discovery process\n\n\nSigned-off-by: Nagy Attila Gabor <mrbig@sneaker.hu>"}, "afterCommit": {"oid": "2dce455a3cb6f279720ceedbb33b9f61c08356c3", "author": {"user": {"login": "mrbig", "name": "Nagy Attila G\u00e1bor"}}, "url": "https://github.com/openhab/openhab-addons/commit/2dce455a3cb6f279720ceedbb33b9f61c08356c3", "committedDate": "2020-03-15T17:35:37Z", "message": "[sunspec] Added discovery process\n\n\nSigned-off-by: Nagy Attila Gabor <mrbig@sneaker.hu>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "2dce455a3cb6f279720ceedbb33b9f61c08356c3", "author": {"user": {"login": "mrbig", "name": "Nagy Attila G\u00e1bor"}}, "url": "https://github.com/openhab/openhab-addons/commit/2dce455a3cb6f279720ceedbb33b9f61c08356c3", "committedDate": "2020-03-15T17:35:37Z", "message": "[sunspec] Added discovery process\n\n\nSigned-off-by: Nagy Attila Gabor <mrbig@sneaker.hu>"}, "afterCommit": {"oid": "fb700437619f4982034d2df01b75d17d2881deb3", "author": {"user": {"login": "mrbig", "name": "Nagy Attila G\u00e1bor"}}, "url": "https://github.com/openhab/openhab-addons/commit/fb700437619f4982034d2df01b75d17d2881deb3", "committedDate": "2020-04-17T22:09:46Z", "message": "[sunspec] Added discovery process\n\n\nSigned-off-by: Nagy Attila Gabor <mrbig@sneaker.hu>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1cb2d390458d9ad3b81aed783520aa199f1cb7ef", "author": {"user": {"login": "mrbig", "name": "Nagy Attila G\u00e1bor"}}, "url": "https://github.com/openhab/openhab-addons/commit/1cb2d390458d9ad3b81aed783520aa199f1cb7ef", "committedDate": "2020-04-18T11:58:50Z", "message": "[sunspec] Added discovery process to SunSpec bundle\n\nThe discovery process will read the common model block of the device\nwhich must be supported by every SunSpec compatible device.\n\nFor there model types are organized into block, so we hop through\nall the supported blocks and emit them as discovered.\n\nDiscovered devices will contain theire start address and block length in\nthe configuration properties.\n\nSigned-off-by: Nagy Attila Gabor <mrbig@sneaker.hu>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "fb700437619f4982034d2df01b75d17d2881deb3", "author": {"user": {"login": "mrbig", "name": "Nagy Attila G\u00e1bor"}}, "url": "https://github.com/openhab/openhab-addons/commit/fb700437619f4982034d2df01b75d17d2881deb3", "committedDate": "2020-04-17T22:09:46Z", "message": "[sunspec] Added discovery process\n\n\nSigned-off-by: Nagy Attila Gabor <mrbig@sneaker.hu>"}, "afterCommit": {"oid": "1cb2d390458d9ad3b81aed783520aa199f1cb7ef", "author": {"user": {"login": "mrbig", "name": "Nagy Attila G\u00e1bor"}}, "url": "https://github.com/openhab/openhab-addons/commit/1cb2d390458d9ad3b81aed783520aa199f1cb7ef", "committedDate": "2020-04-18T11:58:50Z", "message": "[sunspec] Added discovery process to SunSpec bundle\n\nThe discovery process will read the common model block of the device\nwhich must be supported by every SunSpec compatible device.\n\nFor there model types are organized into block, so we hop through\nall the supported blocks and emit them as discovered.\n\nDiscovered devices will contain theire start address and block length in\nthe configuration properties.\n\nSigned-off-by: Nagy Attila Gabor <mrbig@sneaker.hu>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk1OTYxOTE0", "url": "https://github.com/openhab/openhab-addons/pull/6994#pullrequestreview-395961914", "createdAt": "2020-04-19T00:01:50Z", "commit": {"oid": "1cb2d390458d9ad3b81aed783520aa199f1cb7ef"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 10, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xOVQwMDowMTo1MFrOGHvwpg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xOVQwMDoyMDoyN1rOGHv6gg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDc3NTcxOA==", "bodyText": "Is this used?", "url": "https://github.com/openhab/openhab-addons/pull/6994#discussion_r410775718", "createdAt": "2020-04-19T00:01:50Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.modbus.sunspec/src/main/java/org/openhab/binding/modbus/sunspec/internal/discovery/SunspecDiscoveryProcess.java", "diffHunk": "@@ -0,0 +1,425 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.modbus.sunspec.internal.discovery;\n+\n+import static org.openhab.binding.modbus.sunspec.internal.SunSpecConstants.*;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResult;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResultBuilder;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.thing.ThingUID;\n+import org.openhab.binding.modbus.discovery.ModbusDiscoveryListener;\n+import org.openhab.binding.modbus.handler.EndpointNotInitializedException;\n+import org.openhab.binding.modbus.handler.ModbusEndpointThingHandler;\n+import org.openhab.binding.modbus.sunspec.internal.dto.CommonModelBlock;\n+import org.openhab.binding.modbus.sunspec.internal.dto.ModelBlock;\n+import org.openhab.binding.modbus.sunspec.internal.parser.CommonModelParser;\n+import org.openhab.io.transport.modbus.BasicModbusReadRequestBlueprint;\n+import org.openhab.io.transport.modbus.BasicPollTaskImpl;\n+import org.openhab.io.transport.modbus.BitArray;\n+import org.openhab.io.transport.modbus.ModbusBitUtilities;\n+import org.openhab.io.transport.modbus.ModbusConstants.ValueType;\n+import org.openhab.io.transport.modbus.ModbusReadCallback;\n+import org.openhab.io.transport.modbus.ModbusReadFunctionCode;\n+import org.openhab.io.transport.modbus.ModbusReadRequestBlueprint;\n+import org.openhab.io.transport.modbus.ModbusRegisterArray;\n+import org.openhab.io.transport.modbus.ModbusSlaveErrorResponseException;\n+import org.openhab.io.transport.modbus.PollTask;\n+import org.openhab.io.transport.modbus.endpoint.ModbusSlaveEndpoint;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * This class is used by the SunspecDiscoveryParticipant to detect\n+ * the model blocks defined by the given device.\n+ * It scans trough the defined model items and notifies the\n+ * discovery service about the discovered devices\n+ *\n+ * @author Nagy Attila Gabor - Initial contribution\n+ */\n+@NonNullByDefault\n+public class SunspecDiscoveryProcess {\n+\n+    /**\n+     * Logger instance\n+     */\n+    private final Logger logger = LoggerFactory.getLogger(SunspecDiscoveryProcess.class);\n+\n+    /**\n+     * The handler instance for this device\n+     */\n+    private final ModbusEndpointThingHandler handler;\n+\n+    /**\n+     * The endpoint where we can reach the device\n+     */\n+    private final Optional<ModbusSlaveEndpoint> endpoint;\n+\n+    /**\n+     * Listener for the discovered devices. We get this\n+     * from the main discovery service, and it is used to\n+     * submit any discovered Sunspec devices\n+     */\n+    private final ModbusDiscoveryListener listener;\n+\n+    /**\n+     * The endpoint's slave id\n+     */\n+    private Integer slaveId;\n+\n+    /**\n+     * Number of maximum retries\n+     */\n+    private Integer maxTries = 3;\n+\n+    /**\n+     * List of start addresses to try\n+     */\n+    private List<Integer> possibleAddresses;\n+\n+    /**\n+     * This is the base address where the next block should be searched for\n+     */\n+    private int baseAddress = 40000;\n+\n+    /**\n+     * Count of valid Sunspec blocks found\n+     */\n+    private int blocksFound = 0;\n+\n+    /**\n+     * Parser for commonblock\n+     */\n+    private final CommonModelParser commonBlockParser;\n+\n+    /**\n+     * The last common block found. This is used\n+     * to get the details of any found devices\n+     */\n+    private Optional<CommonModelBlock> lastCommonBlock = Optional.empty();\n+\n+    /**\n+     * New instances of this class should get a reference to the handler\n+     *\n+     * @throws EndpointNotInitializedException\n+     */\n+    public SunspecDiscoveryProcess(ModbusEndpointThingHandler handler, ModbusDiscoveryListener listener)\n+            throws EndpointNotInitializedException {\n+        this.handler = handler;\n+        ModbusSlaveEndpoint endpoint = this.handler.asSlaveEndpoint();\n+        if (endpoint != null) {\n+            this.endpoint = Optional.of(endpoint);\n+        } else {\n+            this.endpoint = Optional.empty();\n+        }\n+        slaveId = handler.getSlaveId();\n+        this.listener = listener;\n+        commonBlockParser = new CommonModelParser();\n+        possibleAddresses = new CopyOnWriteArrayList<>();\n+        // Preferred and alternate base registers\n+        // @see SunSpec Information Model Overview\n+        possibleAddresses.add(40000);\n+        possibleAddresses.add(50000);\n+        possibleAddresses.add(0);\n+    }\n+\n+    /**\n+     * Set the maximum number of retries for operations\n+     *\n+     * @param num the new value to set\n+     * @return\n+     */\n+    public SunspecDiscoveryProcess setMaxTries(Integer num) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1cb2d390458d9ad3b81aed783520aa199f1cb7ef"}, "originalPosition": 150}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDc3NjE1Mg==", "bodyText": "please remove this blank line", "url": "https://github.com/openhab/openhab-addons/pull/6994#discussion_r410776152", "createdAt": "2020-04-19T00:05:03Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.modbus.sunspec/src/main/java/org/openhab/binding/modbus/sunspec/internal/discovery/SunspecDiscoveryProcess.java", "diffHunk": "@@ -0,0 +1,425 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.modbus.sunspec.internal.discovery;\n+\n+import static org.openhab.binding.modbus.sunspec.internal.SunSpecConstants.*;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResult;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResultBuilder;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.thing.ThingUID;\n+import org.openhab.binding.modbus.discovery.ModbusDiscoveryListener;\n+import org.openhab.binding.modbus.handler.EndpointNotInitializedException;\n+import org.openhab.binding.modbus.handler.ModbusEndpointThingHandler;\n+import org.openhab.binding.modbus.sunspec.internal.dto.CommonModelBlock;\n+import org.openhab.binding.modbus.sunspec.internal.dto.ModelBlock;\n+import org.openhab.binding.modbus.sunspec.internal.parser.CommonModelParser;\n+import org.openhab.io.transport.modbus.BasicModbusReadRequestBlueprint;\n+import org.openhab.io.transport.modbus.BasicPollTaskImpl;\n+import org.openhab.io.transport.modbus.BitArray;\n+import org.openhab.io.transport.modbus.ModbusBitUtilities;\n+import org.openhab.io.transport.modbus.ModbusConstants.ValueType;\n+import org.openhab.io.transport.modbus.ModbusReadCallback;\n+import org.openhab.io.transport.modbus.ModbusReadFunctionCode;\n+import org.openhab.io.transport.modbus.ModbusReadRequestBlueprint;\n+import org.openhab.io.transport.modbus.ModbusRegisterArray;\n+import org.openhab.io.transport.modbus.ModbusSlaveErrorResponseException;\n+import org.openhab.io.transport.modbus.PollTask;\n+import org.openhab.io.transport.modbus.endpoint.ModbusSlaveEndpoint;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * This class is used by the SunspecDiscoveryParticipant to detect\n+ * the model blocks defined by the given device.\n+ * It scans trough the defined model items and notifies the\n+ * discovery service about the discovered devices\n+ *\n+ * @author Nagy Attila Gabor - Initial contribution\n+ */\n+@NonNullByDefault\n+public class SunspecDiscoveryProcess {\n+\n+    /**\n+     * Logger instance\n+     */\n+    private final Logger logger = LoggerFactory.getLogger(SunspecDiscoveryProcess.class);\n+\n+    /**\n+     * The handler instance for this device\n+     */\n+    private final ModbusEndpointThingHandler handler;\n+\n+    /**\n+     * The endpoint where we can reach the device\n+     */\n+    private final Optional<ModbusSlaveEndpoint> endpoint;\n+\n+    /**\n+     * Listener for the discovered devices. We get this\n+     * from the main discovery service, and it is used to\n+     * submit any discovered Sunspec devices\n+     */\n+    private final ModbusDiscoveryListener listener;\n+\n+    /**\n+     * The endpoint's slave id\n+     */\n+    private Integer slaveId;\n+\n+    /**\n+     * Number of maximum retries\n+     */\n+    private Integer maxTries = 3;\n+\n+    /**\n+     * List of start addresses to try\n+     */\n+    private List<Integer> possibleAddresses;\n+\n+    /**\n+     * This is the base address where the next block should be searched for\n+     */\n+    private int baseAddress = 40000;\n+\n+    /**\n+     * Count of valid Sunspec blocks found\n+     */\n+    private int blocksFound = 0;\n+\n+    /**\n+     * Parser for commonblock\n+     */\n+    private final CommonModelParser commonBlockParser;\n+\n+    /**\n+     * The last common block found. This is used\n+     * to get the details of any found devices\n+     */\n+    private Optional<CommonModelBlock> lastCommonBlock = Optional.empty();\n+\n+    /**\n+     * New instances of this class should get a reference to the handler\n+     *\n+     * @throws EndpointNotInitializedException\n+     */\n+    public SunspecDiscoveryProcess(ModbusEndpointThingHandler handler, ModbusDiscoveryListener listener)\n+            throws EndpointNotInitializedException {\n+        this.handler = handler;\n+        ModbusSlaveEndpoint endpoint = this.handler.asSlaveEndpoint();\n+        if (endpoint != null) {\n+            this.endpoint = Optional.of(endpoint);\n+        } else {\n+            this.endpoint = Optional.empty();\n+        }\n+        slaveId = handler.getSlaveId();\n+        this.listener = listener;\n+        commonBlockParser = new CommonModelParser();\n+        possibleAddresses = new CopyOnWriteArrayList<>();\n+        // Preferred and alternate base registers\n+        // @see SunSpec Information Model Overview\n+        possibleAddresses.add(40000);\n+        possibleAddresses.add(50000);\n+        possibleAddresses.add(0);\n+    }\n+\n+    /**\n+     * Set the maximum number of retries for operations\n+     *\n+     * @param num the new value to set\n+     * @return\n+     */\n+    public SunspecDiscoveryProcess setMaxTries(Integer num) {\n+        this.maxTries = num;\n+        return this;\n+    }\n+\n+    /**\n+     * Start model detection\n+     *\n+     * @param uid the thing type to look for\n+     * @throws EndpointNotInitializedException\n+     */\n+    public void detectModel() throws EndpointNotInitializedException {\n+\n+        if (!this.endpoint.isPresent()) {\n+            logger.debug(\"Endpoint is null, can not continue with discovery\");\n+            throw new EndpointNotInitializedException();\n+        }\n+\n+        if (possibleAddresses.size() < 1) {\n+            parsingFinished();\n+            return;\n+        }\n+        // Try the next address from the possibles\n+        baseAddress = possibleAddresses.get(0);\n+        logger.trace(\"Beginning scan for SunSpec device at address {}\", baseAddress);\n+\n+        BasicModbusReadRequestBlueprint request = new BasicModbusReadRequestBlueprint(slaveId,\n+                ModbusReadFunctionCode.READ_MULTIPLE_REGISTERS, baseAddress, // Start address\n+                SUNSPEC_ID_SIZE, // number or words to return\n+                maxTries);\n+\n+        PollTask task = new BasicPollTaskImpl(endpoint.get(), request, new ModbusReadCallback() {\n+\n+            @Override\n+            public void onRegisters(ModbusReadRequestBlueprint request, ModbusRegisterArray registers) {\n+\n+                headerReceived(registers);\n+\n+            }\n+\n+            @Override\n+            public void onError(ModbusReadRequestBlueprint request, Exception error) {\n+                handleError(error);\n+            }\n+\n+            @Override\n+            public void onBits(@Nullable ModbusReadRequestBlueprint request, @Nullable BitArray bits) {\n+                // don't care, we don't expect this result\n+            }\n+        });\n+\n+        handler.getManagerRef().get().submitOneTimePoll(task);\n+    }\n+\n+    /**\n+     * We received the first two words, that should equal to SunS\n+     */\n+    private void headerReceived(ModbusRegisterArray registers) {\n+        logger.trace(\"Received response from device {}\", registers.toString());\n+\n+        Optional<DecimalType> id = ModbusBitUtilities.extractStateFromRegisters(registers, 0, ValueType.UINT32);\n+\n+        if (!id.isPresent() || id.get().longValue() != SUNSPEC_ID) {\n+            logger.debug(\"Could not find SunSpec DID at address {}, received: {}, expected: {}\", baseAddress, id,\n+                    SUNSPEC_ID);\n+            possibleAddresses.remove(0);\n+            try {\n+                detectModel();\n+            } catch (EndpointNotInitializedException ex) {\n+                // This should not happen\n+                parsingFinished();\n+            }\n+            return;\n+        }\n+\n+        logger.trace(\"Header looks correct\");\n+        baseAddress += SUNSPEC_ID_SIZE;\n+\n+        lookForModelBlock();\n+    }\n+\n+    /**\n+     * Look for a valid model block at the current base address\n+     */\n+    private void lookForModelBlock() {\n+        BasicModbusReadRequestBlueprint request = new BasicModbusReadRequestBlueprint(slaveId,\n+                ModbusReadFunctionCode.READ_MULTIPLE_REGISTERS, baseAddress, // Start address\n+                MODEL_HEADER_SIZE, // number or words to return\n+                maxTries);\n+\n+        PollTask task = new BasicPollTaskImpl(endpoint.get(), request, new ModbusReadCallback() {\n+\n+            @Override\n+            public void onRegisters(ModbusReadRequestBlueprint request, ModbusRegisterArray registers) {\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1cb2d390458d9ad3b81aed783520aa199f1cb7ef"}, "originalPosition": 244}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDc3NjI3OQ==", "bodyText": "please remove blank line", "url": "https://github.com/openhab/openhab-addons/pull/6994#discussion_r410776279", "createdAt": "2020-04-19T00:06:02Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.modbus.sunspec/src/main/java/org/openhab/binding/modbus/sunspec/internal/discovery/SunspecDiscoveryProcess.java", "diffHunk": "@@ -0,0 +1,425 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.modbus.sunspec.internal.discovery;\n+\n+import static org.openhab.binding.modbus.sunspec.internal.SunSpecConstants.*;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResult;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResultBuilder;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.thing.ThingUID;\n+import org.openhab.binding.modbus.discovery.ModbusDiscoveryListener;\n+import org.openhab.binding.modbus.handler.EndpointNotInitializedException;\n+import org.openhab.binding.modbus.handler.ModbusEndpointThingHandler;\n+import org.openhab.binding.modbus.sunspec.internal.dto.CommonModelBlock;\n+import org.openhab.binding.modbus.sunspec.internal.dto.ModelBlock;\n+import org.openhab.binding.modbus.sunspec.internal.parser.CommonModelParser;\n+import org.openhab.io.transport.modbus.BasicModbusReadRequestBlueprint;\n+import org.openhab.io.transport.modbus.BasicPollTaskImpl;\n+import org.openhab.io.transport.modbus.BitArray;\n+import org.openhab.io.transport.modbus.ModbusBitUtilities;\n+import org.openhab.io.transport.modbus.ModbusConstants.ValueType;\n+import org.openhab.io.transport.modbus.ModbusReadCallback;\n+import org.openhab.io.transport.modbus.ModbusReadFunctionCode;\n+import org.openhab.io.transport.modbus.ModbusReadRequestBlueprint;\n+import org.openhab.io.transport.modbus.ModbusRegisterArray;\n+import org.openhab.io.transport.modbus.ModbusSlaveErrorResponseException;\n+import org.openhab.io.transport.modbus.PollTask;\n+import org.openhab.io.transport.modbus.endpoint.ModbusSlaveEndpoint;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * This class is used by the SunspecDiscoveryParticipant to detect\n+ * the model blocks defined by the given device.\n+ * It scans trough the defined model items and notifies the\n+ * discovery service about the discovered devices\n+ *\n+ * @author Nagy Attila Gabor - Initial contribution\n+ */\n+@NonNullByDefault\n+public class SunspecDiscoveryProcess {\n+\n+    /**\n+     * Logger instance\n+     */\n+    private final Logger logger = LoggerFactory.getLogger(SunspecDiscoveryProcess.class);\n+\n+    /**\n+     * The handler instance for this device\n+     */\n+    private final ModbusEndpointThingHandler handler;\n+\n+    /**\n+     * The endpoint where we can reach the device\n+     */\n+    private final Optional<ModbusSlaveEndpoint> endpoint;\n+\n+    /**\n+     * Listener for the discovered devices. We get this\n+     * from the main discovery service, and it is used to\n+     * submit any discovered Sunspec devices\n+     */\n+    private final ModbusDiscoveryListener listener;\n+\n+    /**\n+     * The endpoint's slave id\n+     */\n+    private Integer slaveId;\n+\n+    /**\n+     * Number of maximum retries\n+     */\n+    private Integer maxTries = 3;\n+\n+    /**\n+     * List of start addresses to try\n+     */\n+    private List<Integer> possibleAddresses;\n+\n+    /**\n+     * This is the base address where the next block should be searched for\n+     */\n+    private int baseAddress = 40000;\n+\n+    /**\n+     * Count of valid Sunspec blocks found\n+     */\n+    private int blocksFound = 0;\n+\n+    /**\n+     * Parser for commonblock\n+     */\n+    private final CommonModelParser commonBlockParser;\n+\n+    /**\n+     * The last common block found. This is used\n+     * to get the details of any found devices\n+     */\n+    private Optional<CommonModelBlock> lastCommonBlock = Optional.empty();\n+\n+    /**\n+     * New instances of this class should get a reference to the handler\n+     *\n+     * @throws EndpointNotInitializedException\n+     */\n+    public SunspecDiscoveryProcess(ModbusEndpointThingHandler handler, ModbusDiscoveryListener listener)\n+            throws EndpointNotInitializedException {\n+        this.handler = handler;\n+        ModbusSlaveEndpoint endpoint = this.handler.asSlaveEndpoint();\n+        if (endpoint != null) {\n+            this.endpoint = Optional.of(endpoint);\n+        } else {\n+            this.endpoint = Optional.empty();\n+        }\n+        slaveId = handler.getSlaveId();\n+        this.listener = listener;\n+        commonBlockParser = new CommonModelParser();\n+        possibleAddresses = new CopyOnWriteArrayList<>();\n+        // Preferred and alternate base registers\n+        // @see SunSpec Information Model Overview\n+        possibleAddresses.add(40000);\n+        possibleAddresses.add(50000);\n+        possibleAddresses.add(0);\n+    }\n+\n+    /**\n+     * Set the maximum number of retries for operations\n+     *\n+     * @param num the new value to set\n+     * @return\n+     */\n+    public SunspecDiscoveryProcess setMaxTries(Integer num) {\n+        this.maxTries = num;\n+        return this;\n+    }\n+\n+    /**\n+     * Start model detection\n+     *\n+     * @param uid the thing type to look for\n+     * @throws EndpointNotInitializedException\n+     */\n+    public void detectModel() throws EndpointNotInitializedException {\n+\n+        if (!this.endpoint.isPresent()) {\n+            logger.debug(\"Endpoint is null, can not continue with discovery\");\n+            throw new EndpointNotInitializedException();\n+        }\n+\n+        if (possibleAddresses.size() < 1) {\n+            parsingFinished();\n+            return;\n+        }\n+        // Try the next address from the possibles\n+        baseAddress = possibleAddresses.get(0);\n+        logger.trace(\"Beginning scan for SunSpec device at address {}\", baseAddress);\n+\n+        BasicModbusReadRequestBlueprint request = new BasicModbusReadRequestBlueprint(slaveId,\n+                ModbusReadFunctionCode.READ_MULTIPLE_REGISTERS, baseAddress, // Start address\n+                SUNSPEC_ID_SIZE, // number or words to return\n+                maxTries);\n+\n+        PollTask task = new BasicPollTaskImpl(endpoint.get(), request, new ModbusReadCallback() {\n+\n+            @Override\n+            public void onRegisters(ModbusReadRequestBlueprint request, ModbusRegisterArray registers) {\n+\n+                headerReceived(registers);\n+\n+            }\n+\n+            @Override\n+            public void onError(ModbusReadRequestBlueprint request, Exception error) {\n+                handleError(error);\n+            }\n+\n+            @Override\n+            public void onBits(@Nullable ModbusReadRequestBlueprint request, @Nullable BitArray bits) {\n+                // don't care, we don't expect this result\n+            }\n+        });\n+\n+        handler.getManagerRef().get().submitOneTimePoll(task);\n+    }\n+\n+    /**\n+     * We received the first two words, that should equal to SunS\n+     */\n+    private void headerReceived(ModbusRegisterArray registers) {\n+        logger.trace(\"Received response from device {}\", registers.toString());\n+\n+        Optional<DecimalType> id = ModbusBitUtilities.extractStateFromRegisters(registers, 0, ValueType.UINT32);\n+\n+        if (!id.isPresent() || id.get().longValue() != SUNSPEC_ID) {\n+            logger.debug(\"Could not find SunSpec DID at address {}, received: {}, expected: {}\", baseAddress, id,\n+                    SUNSPEC_ID);\n+            possibleAddresses.remove(0);\n+            try {\n+                detectModel();\n+            } catch (EndpointNotInitializedException ex) {\n+                // This should not happen\n+                parsingFinished();\n+            }\n+            return;\n+        }\n+\n+        logger.trace(\"Header looks correct\");\n+        baseAddress += SUNSPEC_ID_SIZE;\n+\n+        lookForModelBlock();\n+    }\n+\n+    /**\n+     * Look for a valid model block at the current base address\n+     */\n+    private void lookForModelBlock() {\n+        BasicModbusReadRequestBlueprint request = new BasicModbusReadRequestBlueprint(slaveId,\n+                ModbusReadFunctionCode.READ_MULTIPLE_REGISTERS, baseAddress, // Start address\n+                MODEL_HEADER_SIZE, // number or words to return\n+                maxTries);\n+\n+        PollTask task = new BasicPollTaskImpl(endpoint.get(), request, new ModbusReadCallback() {\n+\n+            @Override\n+            public void onRegisters(ModbusReadRequestBlueprint request, ModbusRegisterArray registers) {\n+\n+                modelBlockReceived(registers);\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1cb2d390458d9ad3b81aed783520aa199f1cb7ef"}, "originalPosition": 246}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDc3NjkxNA==", "bodyText": "The use of Optional here would be better substituted by returning a nullable ModelBlock instead.", "url": "https://github.com/openhab/openhab-addons/pull/6994#discussion_r410776914", "createdAt": "2020-04-19T00:10:49Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.modbus.sunspec/src/main/java/org/openhab/binding/modbus/sunspec/internal/handler/AbstractSunSpecHandler.java", "diffHunk": "@@ -164,6 +170,26 @@ private void startUp() {\n         }\n     }\n \n+    /**\n+     * Load and parse configuration from the properties\n+     * These will be set by the auto discovery process\n+     */\n+    private Optional<ModelBlock> getAddressFromProperties() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1cb2d390458d9ad3b81aed783520aa199f1cb7ef"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDc3NzUwNQ==", "bodyText": "I would prefer if this was a nullable field instead.", "url": "https://github.com/openhab/openhab-addons/pull/6994#discussion_r410777505", "createdAt": "2020-04-19T00:15:05Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.modbus.sunspec/src/main/java/org/openhab/binding/modbus/sunspec/internal/discovery/SunspecDiscoveryProcess.java", "diffHunk": "@@ -0,0 +1,425 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.modbus.sunspec.internal.discovery;\n+\n+import static org.openhab.binding.modbus.sunspec.internal.SunSpecConstants.*;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResult;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResultBuilder;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.thing.ThingUID;\n+import org.openhab.binding.modbus.discovery.ModbusDiscoveryListener;\n+import org.openhab.binding.modbus.handler.EndpointNotInitializedException;\n+import org.openhab.binding.modbus.handler.ModbusEndpointThingHandler;\n+import org.openhab.binding.modbus.sunspec.internal.dto.CommonModelBlock;\n+import org.openhab.binding.modbus.sunspec.internal.dto.ModelBlock;\n+import org.openhab.binding.modbus.sunspec.internal.parser.CommonModelParser;\n+import org.openhab.io.transport.modbus.BasicModbusReadRequestBlueprint;\n+import org.openhab.io.transport.modbus.BasicPollTaskImpl;\n+import org.openhab.io.transport.modbus.BitArray;\n+import org.openhab.io.transport.modbus.ModbusBitUtilities;\n+import org.openhab.io.transport.modbus.ModbusConstants.ValueType;\n+import org.openhab.io.transport.modbus.ModbusReadCallback;\n+import org.openhab.io.transport.modbus.ModbusReadFunctionCode;\n+import org.openhab.io.transport.modbus.ModbusReadRequestBlueprint;\n+import org.openhab.io.transport.modbus.ModbusRegisterArray;\n+import org.openhab.io.transport.modbus.ModbusSlaveErrorResponseException;\n+import org.openhab.io.transport.modbus.PollTask;\n+import org.openhab.io.transport.modbus.endpoint.ModbusSlaveEndpoint;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * This class is used by the SunspecDiscoveryParticipant to detect\n+ * the model blocks defined by the given device.\n+ * It scans trough the defined model items and notifies the\n+ * discovery service about the discovered devices\n+ *\n+ * @author Nagy Attila Gabor - Initial contribution\n+ */\n+@NonNullByDefault\n+public class SunspecDiscoveryProcess {\n+\n+    /**\n+     * Logger instance\n+     */\n+    private final Logger logger = LoggerFactory.getLogger(SunspecDiscoveryProcess.class);\n+\n+    /**\n+     * The handler instance for this device\n+     */\n+    private final ModbusEndpointThingHandler handler;\n+\n+    /**\n+     * The endpoint where we can reach the device\n+     */\n+    private final Optional<ModbusSlaveEndpoint> endpoint;\n+\n+    /**\n+     * Listener for the discovered devices. We get this\n+     * from the main discovery service, and it is used to\n+     * submit any discovered Sunspec devices\n+     */\n+    private final ModbusDiscoveryListener listener;\n+\n+    /**\n+     * The endpoint's slave id\n+     */\n+    private Integer slaveId;\n+\n+    /**\n+     * Number of maximum retries\n+     */\n+    private Integer maxTries = 3;\n+\n+    /**\n+     * List of start addresses to try\n+     */\n+    private List<Integer> possibleAddresses;\n+\n+    /**\n+     * This is the base address where the next block should be searched for\n+     */\n+    private int baseAddress = 40000;\n+\n+    /**\n+     * Count of valid Sunspec blocks found\n+     */\n+    private int blocksFound = 0;\n+\n+    /**\n+     * Parser for commonblock\n+     */\n+    private final CommonModelParser commonBlockParser;\n+\n+    /**\n+     * The last common block found. This is used\n+     * to get the details of any found devices\n+     */\n+    private Optional<CommonModelBlock> lastCommonBlock = Optional.empty();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1cb2d390458d9ad3b81aed783520aa199f1cb7ef"}, "originalPosition": 117}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDc3NzU4NA==", "bodyText": "Can you make this primitive?", "url": "https://github.com/openhab/openhab-addons/pull/6994#discussion_r410777584", "createdAt": "2020-04-19T00:15:45Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.modbus.sunspec/src/main/java/org/openhab/binding/modbus/sunspec/internal/discovery/SunspecDiscoveryProcess.java", "diffHunk": "@@ -0,0 +1,425 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.modbus.sunspec.internal.discovery;\n+\n+import static org.openhab.binding.modbus.sunspec.internal.SunSpecConstants.*;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResult;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResultBuilder;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.thing.ThingUID;\n+import org.openhab.binding.modbus.discovery.ModbusDiscoveryListener;\n+import org.openhab.binding.modbus.handler.EndpointNotInitializedException;\n+import org.openhab.binding.modbus.handler.ModbusEndpointThingHandler;\n+import org.openhab.binding.modbus.sunspec.internal.dto.CommonModelBlock;\n+import org.openhab.binding.modbus.sunspec.internal.dto.ModelBlock;\n+import org.openhab.binding.modbus.sunspec.internal.parser.CommonModelParser;\n+import org.openhab.io.transport.modbus.BasicModbusReadRequestBlueprint;\n+import org.openhab.io.transport.modbus.BasicPollTaskImpl;\n+import org.openhab.io.transport.modbus.BitArray;\n+import org.openhab.io.transport.modbus.ModbusBitUtilities;\n+import org.openhab.io.transport.modbus.ModbusConstants.ValueType;\n+import org.openhab.io.transport.modbus.ModbusReadCallback;\n+import org.openhab.io.transport.modbus.ModbusReadFunctionCode;\n+import org.openhab.io.transport.modbus.ModbusReadRequestBlueprint;\n+import org.openhab.io.transport.modbus.ModbusRegisterArray;\n+import org.openhab.io.transport.modbus.ModbusSlaveErrorResponseException;\n+import org.openhab.io.transport.modbus.PollTask;\n+import org.openhab.io.transport.modbus.endpoint.ModbusSlaveEndpoint;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * This class is used by the SunspecDiscoveryParticipant to detect\n+ * the model blocks defined by the given device.\n+ * It scans trough the defined model items and notifies the\n+ * discovery service about the discovered devices\n+ *\n+ * @author Nagy Attila Gabor - Initial contribution\n+ */\n+@NonNullByDefault\n+public class SunspecDiscoveryProcess {\n+\n+    /**\n+     * Logger instance\n+     */\n+    private final Logger logger = LoggerFactory.getLogger(SunspecDiscoveryProcess.class);\n+\n+    /**\n+     * The handler instance for this device\n+     */\n+    private final ModbusEndpointThingHandler handler;\n+\n+    /**\n+     * The endpoint where we can reach the device\n+     */\n+    private final Optional<ModbusSlaveEndpoint> endpoint;\n+\n+    /**\n+     * Listener for the discovered devices. We get this\n+     * from the main discovery service, and it is used to\n+     * submit any discovered Sunspec devices\n+     */\n+    private final ModbusDiscoveryListener listener;\n+\n+    /**\n+     * The endpoint's slave id\n+     */\n+    private Integer slaveId;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1cb2d390458d9ad3b81aed783520aa199f1cb7ef"}, "originalPosition": 86}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDc3NzYwMQ==", "bodyText": "Can you make this primitive?", "url": "https://github.com/openhab/openhab-addons/pull/6994#discussion_r410777601", "createdAt": "2020-04-19T00:15:54Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.modbus.sunspec/src/main/java/org/openhab/binding/modbus/sunspec/internal/discovery/SunspecDiscoveryProcess.java", "diffHunk": "@@ -0,0 +1,425 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.modbus.sunspec.internal.discovery;\n+\n+import static org.openhab.binding.modbus.sunspec.internal.SunSpecConstants.*;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResult;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResultBuilder;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.thing.ThingUID;\n+import org.openhab.binding.modbus.discovery.ModbusDiscoveryListener;\n+import org.openhab.binding.modbus.handler.EndpointNotInitializedException;\n+import org.openhab.binding.modbus.handler.ModbusEndpointThingHandler;\n+import org.openhab.binding.modbus.sunspec.internal.dto.CommonModelBlock;\n+import org.openhab.binding.modbus.sunspec.internal.dto.ModelBlock;\n+import org.openhab.binding.modbus.sunspec.internal.parser.CommonModelParser;\n+import org.openhab.io.transport.modbus.BasicModbusReadRequestBlueprint;\n+import org.openhab.io.transport.modbus.BasicPollTaskImpl;\n+import org.openhab.io.transport.modbus.BitArray;\n+import org.openhab.io.transport.modbus.ModbusBitUtilities;\n+import org.openhab.io.transport.modbus.ModbusConstants.ValueType;\n+import org.openhab.io.transport.modbus.ModbusReadCallback;\n+import org.openhab.io.transport.modbus.ModbusReadFunctionCode;\n+import org.openhab.io.transport.modbus.ModbusReadRequestBlueprint;\n+import org.openhab.io.transport.modbus.ModbusRegisterArray;\n+import org.openhab.io.transport.modbus.ModbusSlaveErrorResponseException;\n+import org.openhab.io.transport.modbus.PollTask;\n+import org.openhab.io.transport.modbus.endpoint.ModbusSlaveEndpoint;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * This class is used by the SunspecDiscoveryParticipant to detect\n+ * the model blocks defined by the given device.\n+ * It scans trough the defined model items and notifies the\n+ * discovery service about the discovered devices\n+ *\n+ * @author Nagy Attila Gabor - Initial contribution\n+ */\n+@NonNullByDefault\n+public class SunspecDiscoveryProcess {\n+\n+    /**\n+     * Logger instance\n+     */\n+    private final Logger logger = LoggerFactory.getLogger(SunspecDiscoveryProcess.class);\n+\n+    /**\n+     * The handler instance for this device\n+     */\n+    private final ModbusEndpointThingHandler handler;\n+\n+    /**\n+     * The endpoint where we can reach the device\n+     */\n+    private final Optional<ModbusSlaveEndpoint> endpoint;\n+\n+    /**\n+     * Listener for the discovered devices. We get this\n+     * from the main discovery service, and it is used to\n+     * submit any discovered Sunspec devices\n+     */\n+    private final ModbusDiscoveryListener listener;\n+\n+    /**\n+     * The endpoint's slave id\n+     */\n+    private Integer slaveId;\n+\n+    /**\n+     * Number of maximum retries\n+     */\n+    private Integer maxTries = 3;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1cb2d390458d9ad3b81aed783520aa199f1cb7ef"}, "originalPosition": 91}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDc3ODAyMw==", "bodyText": "You can make this a nullable field instead. Because the field is final you won't have to cache it to a local variable for null checks.", "url": "https://github.com/openhab/openhab-addons/pull/6994#discussion_r410778023", "createdAt": "2020-04-19T00:18:54Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.modbus.sunspec/src/main/java/org/openhab/binding/modbus/sunspec/internal/discovery/SunspecDiscoveryProcess.java", "diffHunk": "@@ -0,0 +1,425 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.modbus.sunspec.internal.discovery;\n+\n+import static org.openhab.binding.modbus.sunspec.internal.SunSpecConstants.*;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResult;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResultBuilder;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.thing.ThingUID;\n+import org.openhab.binding.modbus.discovery.ModbusDiscoveryListener;\n+import org.openhab.binding.modbus.handler.EndpointNotInitializedException;\n+import org.openhab.binding.modbus.handler.ModbusEndpointThingHandler;\n+import org.openhab.binding.modbus.sunspec.internal.dto.CommonModelBlock;\n+import org.openhab.binding.modbus.sunspec.internal.dto.ModelBlock;\n+import org.openhab.binding.modbus.sunspec.internal.parser.CommonModelParser;\n+import org.openhab.io.transport.modbus.BasicModbusReadRequestBlueprint;\n+import org.openhab.io.transport.modbus.BasicPollTaskImpl;\n+import org.openhab.io.transport.modbus.BitArray;\n+import org.openhab.io.transport.modbus.ModbusBitUtilities;\n+import org.openhab.io.transport.modbus.ModbusConstants.ValueType;\n+import org.openhab.io.transport.modbus.ModbusReadCallback;\n+import org.openhab.io.transport.modbus.ModbusReadFunctionCode;\n+import org.openhab.io.transport.modbus.ModbusReadRequestBlueprint;\n+import org.openhab.io.transport.modbus.ModbusRegisterArray;\n+import org.openhab.io.transport.modbus.ModbusSlaveErrorResponseException;\n+import org.openhab.io.transport.modbus.PollTask;\n+import org.openhab.io.transport.modbus.endpoint.ModbusSlaveEndpoint;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * This class is used by the SunspecDiscoveryParticipant to detect\n+ * the model blocks defined by the given device.\n+ * It scans trough the defined model items and notifies the\n+ * discovery service about the discovered devices\n+ *\n+ * @author Nagy Attila Gabor - Initial contribution\n+ */\n+@NonNullByDefault\n+public class SunspecDiscoveryProcess {\n+\n+    /**\n+     * Logger instance\n+     */\n+    private final Logger logger = LoggerFactory.getLogger(SunspecDiscoveryProcess.class);\n+\n+    /**\n+     * The handler instance for this device\n+     */\n+    private final ModbusEndpointThingHandler handler;\n+\n+    /**\n+     * The endpoint where we can reach the device\n+     */\n+    private final Optional<ModbusSlaveEndpoint> endpoint;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1cb2d390458d9ad3b81aed783520aa199f1cb7ef"}, "originalPosition": 74}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDc3ODA4Nw==", "bodyText": "Can you make this set static?", "url": "https://github.com/openhab/openhab-addons/pull/6994#discussion_r410778087", "createdAt": "2020-04-19T00:19:23Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.modbus.sunspec/src/main/java/org/openhab/binding/modbus/sunspec/internal/discovery/SunspecDiscoveryParticipant.java", "diffHunk": "@@ -0,0 +1,57 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.modbus.sunspec.internal.discovery;\n+\n+import static org.openhab.binding.modbus.sunspec.internal.SunSpecConstants.SUPPORTED_THING_TYPES_UIDS;\n+\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.openhab.binding.modbus.discovery.ModbusDiscoveryListener;\n+import org.openhab.binding.modbus.discovery.ModbusDiscoveryParticipant;\n+import org.openhab.binding.modbus.handler.EndpointNotInitializedException;\n+import org.openhab.binding.modbus.handler.ModbusEndpointThingHandler;\n+import org.osgi.service.component.annotations.Component;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Discovery service for sunspec\n+ *\n+ * @author Nagy Attila Gabor - initial contribution\n+ *\n+ */\n+@Component(immediate = true)\n+@NonNullByDefault\n+public class SunspecDiscoveryParticipant implements ModbusDiscoveryParticipant {\n+\n+    private final Logger logger = LoggerFactory.getLogger(SunspecDiscoveryParticipant.class);\n+\n+    @Override\n+    public Set<ThingTypeUID> getSupportedThingTypeUIDs() {\n+        return new HashSet<ThingTypeUID>(SUPPORTED_THING_TYPES_UIDS.values());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1cb2d390458d9ad3b81aed783520aa199f1cb7ef"}, "originalPosition": 44}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDc3ODI0Mg==", "bodyText": "any reason these Integer fields couldn't be int instead?", "url": "https://github.com/openhab/openhab-addons/pull/6994#discussion_r410778242", "createdAt": "2020-04-19T00:20:27Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.modbus.sunspec/src/main/java/org/openhab/binding/modbus/sunspec/internal/dto/CommonModelBlock.java", "diffHunk": "@@ -0,0 +1,47 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.modbus.sunspec.internal.dto;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+\n+/**\n+ * This class contains information parsed from the Common Model block\n+ *\n+ * @author Nagy Attila Gabor - Initial contribution\n+ *\n+ */\n+@NonNullByDefault\n+public class CommonModelBlock {\n+\n+    /**\n+     * Value = 0x0001. Uniquely identifies this as a SunSpec Common Model Block\n+     */\n+    public Integer sunSpecDID = 0x0001;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1cb2d390458d9ad3b81aed783520aa199f1cb7ef"}, "originalPosition": 29}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "83f52ba6affa07ea2846e6619418d74c176d6ba6", "author": {"user": {"login": "mrbig", "name": "Nagy Attila G\u00e1bor"}}, "url": "https://github.com/openhab/openhab-addons/commit/83f52ba6affa07ea2846e6619418d74c176d6ba6", "committedDate": "2020-04-19T07:14:40Z", "message": "[sunspec] object changed to primitives\n\nSigned-off-by: Nagy Attila Gabor <mrbig@sneaker.hu>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9f7721e9b26d8b2c834cb74ecbbc9a880d7ecdea", "author": {"user": {"login": "mrbig", "name": "Nagy Attila G\u00e1bor"}}, "url": "https://github.com/openhab/openhab-addons/commit/9f7721e9b26d8b2c834cb74ecbbc9a880d7ecdea", "committedDate": "2020-04-19T08:33:02Z", "message": "[sunspec] ModbusEndpoint changed to NonNull\n\nSigned-off-by: Nagy Attila Gabor <mrbig@sneaker.hu>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fc81ca045f9bb7f80dff8801e58bd68dd0e8badc", "author": {"user": {"login": "mrbig", "name": "Nagy Attila G\u00e1bor"}}, "url": "https://github.com/openhab/openhab-addons/commit/fc81ca045f9bb7f80dff8801e58bd68dd0e8badc", "committedDate": "2020-04-19T08:41:23Z", "message": "[sunspec] Optionals changed to nullable\n\nSigned-off-by: Nagy Attila Gabor <mrbig@sneaker.hu>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk2MTQzOTkx", "url": "https://github.com/openhab/openhab-addons/pull/6994#pullrequestreview-396143991", "createdAt": "2020-04-20T05:15:10Z", "commit": {"oid": "fc81ca045f9bb7f80dff8801e58bd68dd0e8badc"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQwNToxNToxMFrOGIDcZg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQwNTozOTowNlrOGID5tA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTA5ODIxNA==", "bodyText": "From the way you are using this field, it should be a Queue instead.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private List<Integer> possibleAddresses;\n          \n          \n            \n                private Queue<Integer> possibleAddresses;", "url": "https://github.com/openhab/openhab-addons/pull/6994#discussion_r411098214", "createdAt": "2020-04-20T05:15:10Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.modbus.sunspec/src/main/java/org/openhab/binding/modbus/sunspec/internal/discovery/SunspecDiscoveryProcess.java", "diffHunk": "@@ -0,0 +1,397 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.modbus.sunspec.internal.discovery;\n+\n+import static org.openhab.binding.modbus.sunspec.internal.SunSpecConstants.*;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResult;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResultBuilder;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.thing.ThingUID;\n+import org.openhab.binding.modbus.discovery.ModbusDiscoveryListener;\n+import org.openhab.binding.modbus.handler.EndpointNotInitializedException;\n+import org.openhab.binding.modbus.handler.ModbusEndpointThingHandler;\n+import org.openhab.binding.modbus.sunspec.internal.dto.CommonModelBlock;\n+import org.openhab.binding.modbus.sunspec.internal.dto.ModelBlock;\n+import org.openhab.binding.modbus.sunspec.internal.parser.CommonModelParser;\n+import org.openhab.io.transport.modbus.BasicModbusReadRequestBlueprint;\n+import org.openhab.io.transport.modbus.BasicPollTaskImpl;\n+import org.openhab.io.transport.modbus.BitArray;\n+import org.openhab.io.transport.modbus.ModbusBitUtilities;\n+import org.openhab.io.transport.modbus.ModbusConstants.ValueType;\n+import org.openhab.io.transport.modbus.ModbusReadCallback;\n+import org.openhab.io.transport.modbus.ModbusReadFunctionCode;\n+import org.openhab.io.transport.modbus.ModbusReadRequestBlueprint;\n+import org.openhab.io.transport.modbus.ModbusRegisterArray;\n+import org.openhab.io.transport.modbus.ModbusSlaveErrorResponseException;\n+import org.openhab.io.transport.modbus.PollTask;\n+import org.openhab.io.transport.modbus.endpoint.ModbusSlaveEndpoint;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * This class is used by the SunspecDiscoveryParticipant to detect\n+ * the model blocks defined by the given device.\n+ * It scans trough the defined model items and notifies the\n+ * discovery service about the discovered devices\n+ *\n+ * @author Nagy Attila Gabor - Initial contribution\n+ */\n+@NonNullByDefault\n+public class SunspecDiscoveryProcess {\n+\n+    /**\n+     * Logger instance\n+     */\n+    private final Logger logger = LoggerFactory.getLogger(SunspecDiscoveryProcess.class);\n+\n+    /**\n+     * The handler instance for this device\n+     */\n+    private final ModbusEndpointThingHandler handler;\n+\n+    /**\n+     * The endpoint where we can reach the device\n+     */\n+    private final ModbusSlaveEndpoint endpoint;\n+\n+    /**\n+     * Listener for the discovered devices. We get this\n+     * from the main discovery service, and it is used to\n+     * submit any discovered Sunspec devices\n+     */\n+    private final ModbusDiscoveryListener listener;\n+\n+    /**\n+     * The endpoint's slave id\n+     */\n+    private int slaveId;\n+\n+    /**\n+     * Number of maximum retries\n+     */\n+    private static final int maxTries = 3;\n+\n+    /**\n+     * List of start addresses to try\n+     */\n+    private List<Integer> possibleAddresses;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fc81ca045f9bb7f80dff8801e58bd68dd0e8badc"}, "originalPosition": 96}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTA5ODMxNg==", "bodyText": "If you want a thread-safe queue you can use this:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    possibleAddresses = new CopyOnWriteArrayList<>();\n          \n          \n            \n                    possibleAddresses = new ConcurrentLinkedQueue<>();\n          \n      \n    \n    \n  \n\nBut I'm not entirely sure that you need a thread-safe queue implementation here anyway...", "url": "https://github.com/openhab/openhab-addons/pull/6994#discussion_r411098316", "createdAt": "2020-04-20T05:15:29Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.modbus.sunspec/src/main/java/org/openhab/binding/modbus/sunspec/internal/discovery/SunspecDiscoveryProcess.java", "diffHunk": "@@ -0,0 +1,397 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.modbus.sunspec.internal.discovery;\n+\n+import static org.openhab.binding.modbus.sunspec.internal.SunSpecConstants.*;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResult;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResultBuilder;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.thing.ThingUID;\n+import org.openhab.binding.modbus.discovery.ModbusDiscoveryListener;\n+import org.openhab.binding.modbus.handler.EndpointNotInitializedException;\n+import org.openhab.binding.modbus.handler.ModbusEndpointThingHandler;\n+import org.openhab.binding.modbus.sunspec.internal.dto.CommonModelBlock;\n+import org.openhab.binding.modbus.sunspec.internal.dto.ModelBlock;\n+import org.openhab.binding.modbus.sunspec.internal.parser.CommonModelParser;\n+import org.openhab.io.transport.modbus.BasicModbusReadRequestBlueprint;\n+import org.openhab.io.transport.modbus.BasicPollTaskImpl;\n+import org.openhab.io.transport.modbus.BitArray;\n+import org.openhab.io.transport.modbus.ModbusBitUtilities;\n+import org.openhab.io.transport.modbus.ModbusConstants.ValueType;\n+import org.openhab.io.transport.modbus.ModbusReadCallback;\n+import org.openhab.io.transport.modbus.ModbusReadFunctionCode;\n+import org.openhab.io.transport.modbus.ModbusReadRequestBlueprint;\n+import org.openhab.io.transport.modbus.ModbusRegisterArray;\n+import org.openhab.io.transport.modbus.ModbusSlaveErrorResponseException;\n+import org.openhab.io.transport.modbus.PollTask;\n+import org.openhab.io.transport.modbus.endpoint.ModbusSlaveEndpoint;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * This class is used by the SunspecDiscoveryParticipant to detect\n+ * the model blocks defined by the given device.\n+ * It scans trough the defined model items and notifies the\n+ * discovery service about the discovered devices\n+ *\n+ * @author Nagy Attila Gabor - Initial contribution\n+ */\n+@NonNullByDefault\n+public class SunspecDiscoveryProcess {\n+\n+    /**\n+     * Logger instance\n+     */\n+    private final Logger logger = LoggerFactory.getLogger(SunspecDiscoveryProcess.class);\n+\n+    /**\n+     * The handler instance for this device\n+     */\n+    private final ModbusEndpointThingHandler handler;\n+\n+    /**\n+     * The endpoint where we can reach the device\n+     */\n+    private final ModbusSlaveEndpoint endpoint;\n+\n+    /**\n+     * Listener for the discovered devices. We get this\n+     * from the main discovery service, and it is used to\n+     * submit any discovered Sunspec devices\n+     */\n+    private final ModbusDiscoveryListener listener;\n+\n+    /**\n+     * The endpoint's slave id\n+     */\n+    private int slaveId;\n+\n+    /**\n+     * Number of maximum retries\n+     */\n+    private static final int maxTries = 3;\n+\n+    /**\n+     * List of start addresses to try\n+     */\n+    private List<Integer> possibleAddresses;\n+\n+    /**\n+     * This is the base address where the next block should be searched for\n+     */\n+    private int baseAddress = 40000;\n+\n+    /**\n+     * Count of valid Sunspec blocks found\n+     */\n+    private int blocksFound = 0;\n+\n+    /**\n+     * Parser for commonblock\n+     */\n+    private final CommonModelParser commonBlockParser;\n+\n+    /**\n+     * The last common block found. This is used\n+     * to get the details of any found devices\n+     */\n+    private @Nullable CommonModelBlock lastCommonBlock = null;\n+\n+    /**\n+     * New instances of this class should get a reference to the handler\n+     *\n+     * @throws EndpointNotInitializedException\n+     */\n+    public SunspecDiscoveryProcess(ModbusEndpointThingHandler handler, ModbusDiscoveryListener listener)\n+            throws EndpointNotInitializedException {\n+        this.handler = handler;\n+\n+        ModbusSlaveEndpoint endpoint = this.handler.asSlaveEndpoint();\n+        if (endpoint != null) {\n+            this.endpoint = endpoint;\n+        } else {\n+            throw new EndpointNotInitializedException();\n+        }\n+        slaveId = handler.getSlaveId();\n+        this.listener = listener;\n+        commonBlockParser = new CommonModelParser();\n+        possibleAddresses = new CopyOnWriteArrayList<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fc81ca045f9bb7f80dff8801e58bd68dd0e8badc"}, "originalPosition": 137}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTA5ODM5OQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    if (possibleAddresses.size() < 1) {\n          \n          \n            \n                    if (possibleAddresses.isEmpty()) {", "url": "https://github.com/openhab/openhab-addons/pull/6994#discussion_r411098399", "createdAt": "2020-04-20T05:15:42Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.modbus.sunspec/src/main/java/org/openhab/binding/modbus/sunspec/internal/discovery/SunspecDiscoveryProcess.java", "diffHunk": "@@ -0,0 +1,397 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.modbus.sunspec.internal.discovery;\n+\n+import static org.openhab.binding.modbus.sunspec.internal.SunSpecConstants.*;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResult;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResultBuilder;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.thing.ThingUID;\n+import org.openhab.binding.modbus.discovery.ModbusDiscoveryListener;\n+import org.openhab.binding.modbus.handler.EndpointNotInitializedException;\n+import org.openhab.binding.modbus.handler.ModbusEndpointThingHandler;\n+import org.openhab.binding.modbus.sunspec.internal.dto.CommonModelBlock;\n+import org.openhab.binding.modbus.sunspec.internal.dto.ModelBlock;\n+import org.openhab.binding.modbus.sunspec.internal.parser.CommonModelParser;\n+import org.openhab.io.transport.modbus.BasicModbusReadRequestBlueprint;\n+import org.openhab.io.transport.modbus.BasicPollTaskImpl;\n+import org.openhab.io.transport.modbus.BitArray;\n+import org.openhab.io.transport.modbus.ModbusBitUtilities;\n+import org.openhab.io.transport.modbus.ModbusConstants.ValueType;\n+import org.openhab.io.transport.modbus.ModbusReadCallback;\n+import org.openhab.io.transport.modbus.ModbusReadFunctionCode;\n+import org.openhab.io.transport.modbus.ModbusReadRequestBlueprint;\n+import org.openhab.io.transport.modbus.ModbusRegisterArray;\n+import org.openhab.io.transport.modbus.ModbusSlaveErrorResponseException;\n+import org.openhab.io.transport.modbus.PollTask;\n+import org.openhab.io.transport.modbus.endpoint.ModbusSlaveEndpoint;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * This class is used by the SunspecDiscoveryParticipant to detect\n+ * the model blocks defined by the given device.\n+ * It scans trough the defined model items and notifies the\n+ * discovery service about the discovered devices\n+ *\n+ * @author Nagy Attila Gabor - Initial contribution\n+ */\n+@NonNullByDefault\n+public class SunspecDiscoveryProcess {\n+\n+    /**\n+     * Logger instance\n+     */\n+    private final Logger logger = LoggerFactory.getLogger(SunspecDiscoveryProcess.class);\n+\n+    /**\n+     * The handler instance for this device\n+     */\n+    private final ModbusEndpointThingHandler handler;\n+\n+    /**\n+     * The endpoint where we can reach the device\n+     */\n+    private final ModbusSlaveEndpoint endpoint;\n+\n+    /**\n+     * Listener for the discovered devices. We get this\n+     * from the main discovery service, and it is used to\n+     * submit any discovered Sunspec devices\n+     */\n+    private final ModbusDiscoveryListener listener;\n+\n+    /**\n+     * The endpoint's slave id\n+     */\n+    private int slaveId;\n+\n+    /**\n+     * Number of maximum retries\n+     */\n+    private static final int maxTries = 3;\n+\n+    /**\n+     * List of start addresses to try\n+     */\n+    private List<Integer> possibleAddresses;\n+\n+    /**\n+     * This is the base address where the next block should be searched for\n+     */\n+    private int baseAddress = 40000;\n+\n+    /**\n+     * Count of valid Sunspec blocks found\n+     */\n+    private int blocksFound = 0;\n+\n+    /**\n+     * Parser for commonblock\n+     */\n+    private final CommonModelParser commonBlockParser;\n+\n+    /**\n+     * The last common block found. This is used\n+     * to get the details of any found devices\n+     */\n+    private @Nullable CommonModelBlock lastCommonBlock = null;\n+\n+    /**\n+     * New instances of this class should get a reference to the handler\n+     *\n+     * @throws EndpointNotInitializedException\n+     */\n+    public SunspecDiscoveryProcess(ModbusEndpointThingHandler handler, ModbusDiscoveryListener listener)\n+            throws EndpointNotInitializedException {\n+        this.handler = handler;\n+\n+        ModbusSlaveEndpoint endpoint = this.handler.asSlaveEndpoint();\n+        if (endpoint != null) {\n+            this.endpoint = endpoint;\n+        } else {\n+            throw new EndpointNotInitializedException();\n+        }\n+        slaveId = handler.getSlaveId();\n+        this.listener = listener;\n+        commonBlockParser = new CommonModelParser();\n+        possibleAddresses = new CopyOnWriteArrayList<>();\n+        // Preferred and alternate base registers\n+        // @see SunSpec Information Model Overview\n+        possibleAddresses.add(40000);\n+        possibleAddresses.add(50000);\n+        possibleAddresses.add(0);\n+    }\n+\n+    /**\n+     * Start model detection\n+     *\n+     * @param uid the thing type to look for\n+     * @throws EndpointNotInitializedException\n+     */\n+    public void detectModel() {\n+\n+        if (possibleAddresses.size() < 1) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fc81ca045f9bb7f80dff8801e58bd68dd0e8badc"}, "originalPosition": 153}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTA5ODcyMQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    baseAddress = possibleAddresses.get(0);\n          \n          \n            \n                    baseAddress = possibleAddresses.poll();", "url": "https://github.com/openhab/openhab-addons/pull/6994#discussion_r411098721", "createdAt": "2020-04-20T05:16:49Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.modbus.sunspec/src/main/java/org/openhab/binding/modbus/sunspec/internal/discovery/SunspecDiscoveryProcess.java", "diffHunk": "@@ -0,0 +1,397 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.modbus.sunspec.internal.discovery;\n+\n+import static org.openhab.binding.modbus.sunspec.internal.SunSpecConstants.*;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResult;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResultBuilder;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.thing.ThingUID;\n+import org.openhab.binding.modbus.discovery.ModbusDiscoveryListener;\n+import org.openhab.binding.modbus.handler.EndpointNotInitializedException;\n+import org.openhab.binding.modbus.handler.ModbusEndpointThingHandler;\n+import org.openhab.binding.modbus.sunspec.internal.dto.CommonModelBlock;\n+import org.openhab.binding.modbus.sunspec.internal.dto.ModelBlock;\n+import org.openhab.binding.modbus.sunspec.internal.parser.CommonModelParser;\n+import org.openhab.io.transport.modbus.BasicModbusReadRequestBlueprint;\n+import org.openhab.io.transport.modbus.BasicPollTaskImpl;\n+import org.openhab.io.transport.modbus.BitArray;\n+import org.openhab.io.transport.modbus.ModbusBitUtilities;\n+import org.openhab.io.transport.modbus.ModbusConstants.ValueType;\n+import org.openhab.io.transport.modbus.ModbusReadCallback;\n+import org.openhab.io.transport.modbus.ModbusReadFunctionCode;\n+import org.openhab.io.transport.modbus.ModbusReadRequestBlueprint;\n+import org.openhab.io.transport.modbus.ModbusRegisterArray;\n+import org.openhab.io.transport.modbus.ModbusSlaveErrorResponseException;\n+import org.openhab.io.transport.modbus.PollTask;\n+import org.openhab.io.transport.modbus.endpoint.ModbusSlaveEndpoint;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * This class is used by the SunspecDiscoveryParticipant to detect\n+ * the model blocks defined by the given device.\n+ * It scans trough the defined model items and notifies the\n+ * discovery service about the discovered devices\n+ *\n+ * @author Nagy Attila Gabor - Initial contribution\n+ */\n+@NonNullByDefault\n+public class SunspecDiscoveryProcess {\n+\n+    /**\n+     * Logger instance\n+     */\n+    private final Logger logger = LoggerFactory.getLogger(SunspecDiscoveryProcess.class);\n+\n+    /**\n+     * The handler instance for this device\n+     */\n+    private final ModbusEndpointThingHandler handler;\n+\n+    /**\n+     * The endpoint where we can reach the device\n+     */\n+    private final ModbusSlaveEndpoint endpoint;\n+\n+    /**\n+     * Listener for the discovered devices. We get this\n+     * from the main discovery service, and it is used to\n+     * submit any discovered Sunspec devices\n+     */\n+    private final ModbusDiscoveryListener listener;\n+\n+    /**\n+     * The endpoint's slave id\n+     */\n+    private int slaveId;\n+\n+    /**\n+     * Number of maximum retries\n+     */\n+    private static final int maxTries = 3;\n+\n+    /**\n+     * List of start addresses to try\n+     */\n+    private List<Integer> possibleAddresses;\n+\n+    /**\n+     * This is the base address where the next block should be searched for\n+     */\n+    private int baseAddress = 40000;\n+\n+    /**\n+     * Count of valid Sunspec blocks found\n+     */\n+    private int blocksFound = 0;\n+\n+    /**\n+     * Parser for commonblock\n+     */\n+    private final CommonModelParser commonBlockParser;\n+\n+    /**\n+     * The last common block found. This is used\n+     * to get the details of any found devices\n+     */\n+    private @Nullable CommonModelBlock lastCommonBlock = null;\n+\n+    /**\n+     * New instances of this class should get a reference to the handler\n+     *\n+     * @throws EndpointNotInitializedException\n+     */\n+    public SunspecDiscoveryProcess(ModbusEndpointThingHandler handler, ModbusDiscoveryListener listener)\n+            throws EndpointNotInitializedException {\n+        this.handler = handler;\n+\n+        ModbusSlaveEndpoint endpoint = this.handler.asSlaveEndpoint();\n+        if (endpoint != null) {\n+            this.endpoint = endpoint;\n+        } else {\n+            throw new EndpointNotInitializedException();\n+        }\n+        slaveId = handler.getSlaveId();\n+        this.listener = listener;\n+        commonBlockParser = new CommonModelParser();\n+        possibleAddresses = new CopyOnWriteArrayList<>();\n+        // Preferred and alternate base registers\n+        // @see SunSpec Information Model Overview\n+        possibleAddresses.add(40000);\n+        possibleAddresses.add(50000);\n+        possibleAddresses.add(0);\n+    }\n+\n+    /**\n+     * Start model detection\n+     *\n+     * @param uid the thing type to look for\n+     * @throws EndpointNotInitializedException\n+     */\n+    public void detectModel() {\n+\n+        if (possibleAddresses.size() < 1) {\n+            parsingFinished();\n+            return;\n+        }\n+        // Try the next address from the possibles\n+        baseAddress = possibleAddresses.get(0);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fc81ca045f9bb7f80dff8801e58bd68dd0e8badc"}, "originalPosition": 158}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTEwMzA4NQ==", "bodyText": "Why are you parsing as a double then casting it to an int? Are you expecting the properties to have decimal points?\nCould you just parse it as an int instead?", "url": "https://github.com/openhab/openhab-addons/pull/6994#discussion_r411103085", "createdAt": "2020-04-20T05:30:38Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.modbus.sunspec/src/main/java/org/openhab/binding/modbus/sunspec/internal/handler/AbstractSunSpecHandler.java", "diffHunk": "@@ -152,31 +152,58 @@ private void startUp() {\n             return;\n         }\n \n-        Optional<ModelBlock> mainBlock = getAddressFromConfig();\n-        if (mainBlock.isPresent()) {\n-            publishUniqueAddress(mainBlock.get());\n+        // Try properties first\n+        @Nullable\n+        ModelBlock mainBlock = getAddressFromProperties();\n+\n+        if (mainBlock == null) {\n+            mainBlock = getAddressFromConfig();\n+        }\n+\n+        if (mainBlock != null) {\n+            publishUniqueAddress(mainBlock);\n             updateStatus(ThingStatus.UNKNOWN);\n-            registerPollTask(mainBlock.get());\n+            registerPollTask(mainBlock);\n         } else {\n             updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n                     \"SunSpec item should either have the address and length configuration set or should been created by auto discovery\");\n             return;\n         }\n     }\n \n+    /**\n+     * Load and parse configuration from the properties\n+     * These will be set by the auto discovery process\n+     */\n+    private @Nullable ModelBlock getAddressFromProperties() {\n+        Map<String, String> properties = thing.getProperties();\n+        if (!properties.containsKey(PROPERTY_BLOCK_ADDRESS) || !properties.containsKey(PROPERTY_BLOCK_LENGTH)) {\n+            return null;\n+        }\n+        try {\n+            ModelBlock block = new ModelBlock();\n+            block.address = (int) Double.parseDouble(thing.getProperties().get(PROPERTY_BLOCK_ADDRESS));\n+            block.length = (int) Double.parseDouble(thing.getProperties().get(PROPERTY_BLOCK_LENGTH));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fc81ca045f9bb7f80dff8801e58bd68dd0e8badc"}, "originalPosition": 48}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTEwNTYzNA==", "bodyText": "If you poll within detectModel() you can remove this", "url": "https://github.com/openhab/openhab-addons/pull/6994#discussion_r411105634", "createdAt": "2020-04-20T05:38:49Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.modbus.sunspec/src/main/java/org/openhab/binding/modbus/sunspec/internal/discovery/SunspecDiscoveryProcess.java", "diffHunk": "@@ -0,0 +1,397 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.modbus.sunspec.internal.discovery;\n+\n+import static org.openhab.binding.modbus.sunspec.internal.SunSpecConstants.*;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResult;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResultBuilder;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.thing.ThingUID;\n+import org.openhab.binding.modbus.discovery.ModbusDiscoveryListener;\n+import org.openhab.binding.modbus.handler.EndpointNotInitializedException;\n+import org.openhab.binding.modbus.handler.ModbusEndpointThingHandler;\n+import org.openhab.binding.modbus.sunspec.internal.dto.CommonModelBlock;\n+import org.openhab.binding.modbus.sunspec.internal.dto.ModelBlock;\n+import org.openhab.binding.modbus.sunspec.internal.parser.CommonModelParser;\n+import org.openhab.io.transport.modbus.BasicModbusReadRequestBlueprint;\n+import org.openhab.io.transport.modbus.BasicPollTaskImpl;\n+import org.openhab.io.transport.modbus.BitArray;\n+import org.openhab.io.transport.modbus.ModbusBitUtilities;\n+import org.openhab.io.transport.modbus.ModbusConstants.ValueType;\n+import org.openhab.io.transport.modbus.ModbusReadCallback;\n+import org.openhab.io.transport.modbus.ModbusReadFunctionCode;\n+import org.openhab.io.transport.modbus.ModbusReadRequestBlueprint;\n+import org.openhab.io.transport.modbus.ModbusRegisterArray;\n+import org.openhab.io.transport.modbus.ModbusSlaveErrorResponseException;\n+import org.openhab.io.transport.modbus.PollTask;\n+import org.openhab.io.transport.modbus.endpoint.ModbusSlaveEndpoint;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * This class is used by the SunspecDiscoveryParticipant to detect\n+ * the model blocks defined by the given device.\n+ * It scans trough the defined model items and notifies the\n+ * discovery service about the discovered devices\n+ *\n+ * @author Nagy Attila Gabor - Initial contribution\n+ */\n+@NonNullByDefault\n+public class SunspecDiscoveryProcess {\n+\n+    /**\n+     * Logger instance\n+     */\n+    private final Logger logger = LoggerFactory.getLogger(SunspecDiscoveryProcess.class);\n+\n+    /**\n+     * The handler instance for this device\n+     */\n+    private final ModbusEndpointThingHandler handler;\n+\n+    /**\n+     * The endpoint where we can reach the device\n+     */\n+    private final ModbusSlaveEndpoint endpoint;\n+\n+    /**\n+     * Listener for the discovered devices. We get this\n+     * from the main discovery service, and it is used to\n+     * submit any discovered Sunspec devices\n+     */\n+    private final ModbusDiscoveryListener listener;\n+\n+    /**\n+     * The endpoint's slave id\n+     */\n+    private int slaveId;\n+\n+    /**\n+     * Number of maximum retries\n+     */\n+    private static final int maxTries = 3;\n+\n+    /**\n+     * List of start addresses to try\n+     */\n+    private List<Integer> possibleAddresses;\n+\n+    /**\n+     * This is the base address where the next block should be searched for\n+     */\n+    private int baseAddress = 40000;\n+\n+    /**\n+     * Count of valid Sunspec blocks found\n+     */\n+    private int blocksFound = 0;\n+\n+    /**\n+     * Parser for commonblock\n+     */\n+    private final CommonModelParser commonBlockParser;\n+\n+    /**\n+     * The last common block found. This is used\n+     * to get the details of any found devices\n+     */\n+    private @Nullable CommonModelBlock lastCommonBlock = null;\n+\n+    /**\n+     * New instances of this class should get a reference to the handler\n+     *\n+     * @throws EndpointNotInitializedException\n+     */\n+    public SunspecDiscoveryProcess(ModbusEndpointThingHandler handler, ModbusDiscoveryListener listener)\n+            throws EndpointNotInitializedException {\n+        this.handler = handler;\n+\n+        ModbusSlaveEndpoint endpoint = this.handler.asSlaveEndpoint();\n+        if (endpoint != null) {\n+            this.endpoint = endpoint;\n+        } else {\n+            throw new EndpointNotInitializedException();\n+        }\n+        slaveId = handler.getSlaveId();\n+        this.listener = listener;\n+        commonBlockParser = new CommonModelParser();\n+        possibleAddresses = new CopyOnWriteArrayList<>();\n+        // Preferred and alternate base registers\n+        // @see SunSpec Information Model Overview\n+        possibleAddresses.add(40000);\n+        possibleAddresses.add(50000);\n+        possibleAddresses.add(0);\n+    }\n+\n+    /**\n+     * Start model detection\n+     *\n+     * @param uid the thing type to look for\n+     * @throws EndpointNotInitializedException\n+     */\n+    public void detectModel() {\n+\n+        if (possibleAddresses.size() < 1) {\n+            parsingFinished();\n+            return;\n+        }\n+        // Try the next address from the possibles\n+        baseAddress = possibleAddresses.get(0);\n+        logger.trace(\"Beginning scan for SunSpec device at address {}\", baseAddress);\n+\n+        BasicModbusReadRequestBlueprint request = new BasicModbusReadRequestBlueprint(slaveId,\n+                ModbusReadFunctionCode.READ_MULTIPLE_REGISTERS, baseAddress, // Start address\n+                SUNSPEC_ID_SIZE, // number or words to return\n+                maxTries);\n+\n+        PollTask task = new BasicPollTaskImpl(endpoint, request, new ModbusReadCallback() {\n+\n+            @Override\n+            public void onRegisters(ModbusReadRequestBlueprint request, ModbusRegisterArray registers) {\n+                headerReceived(registers);\n+            }\n+\n+            @Override\n+            public void onError(ModbusReadRequestBlueprint request, Exception error) {\n+                handleError(error);\n+            }\n+\n+            @Override\n+            public void onBits(@Nullable ModbusReadRequestBlueprint request, @Nullable BitArray bits) {\n+                // don't care, we don't expect this result\n+            }\n+        });\n+\n+        handler.getManagerRef().get().submitOneTimePoll(task);\n+    }\n+\n+    /**\n+     * We received the first two words, that should equal to SunS\n+     */\n+    private void headerReceived(ModbusRegisterArray registers) {\n+        logger.trace(\"Received response from device {}\", registers.toString());\n+\n+        Optional<DecimalType> id = ModbusBitUtilities.extractStateFromRegisters(registers, 0, ValueType.UINT32);\n+\n+        if (!id.isPresent() || id.get().longValue() != SUNSPEC_ID) {\n+            logger.debug(\"Could not find SunSpec DID at address {}, received: {}, expected: {}\", baseAddress, id,\n+                    SUNSPEC_ID);\n+            possibleAddresses.remove(0);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fc81ca045f9bb7f80dff8801e58bd68dd0e8badc"}, "originalPosition": 198}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTEwNTcxNg==", "bodyText": "If you poll within detectModel() you can remove this", "url": "https://github.com/openhab/openhab-addons/pull/6994#discussion_r411105716", "createdAt": "2020-04-20T05:39:06Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.modbus.sunspec/src/main/java/org/openhab/binding/modbus/sunspec/internal/discovery/SunspecDiscoveryProcess.java", "diffHunk": "@@ -0,0 +1,397 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.modbus.sunspec.internal.discovery;\n+\n+import static org.openhab.binding.modbus.sunspec.internal.SunSpecConstants.*;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResult;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResultBuilder;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.thing.ThingUID;\n+import org.openhab.binding.modbus.discovery.ModbusDiscoveryListener;\n+import org.openhab.binding.modbus.handler.EndpointNotInitializedException;\n+import org.openhab.binding.modbus.handler.ModbusEndpointThingHandler;\n+import org.openhab.binding.modbus.sunspec.internal.dto.CommonModelBlock;\n+import org.openhab.binding.modbus.sunspec.internal.dto.ModelBlock;\n+import org.openhab.binding.modbus.sunspec.internal.parser.CommonModelParser;\n+import org.openhab.io.transport.modbus.BasicModbusReadRequestBlueprint;\n+import org.openhab.io.transport.modbus.BasicPollTaskImpl;\n+import org.openhab.io.transport.modbus.BitArray;\n+import org.openhab.io.transport.modbus.ModbusBitUtilities;\n+import org.openhab.io.transport.modbus.ModbusConstants.ValueType;\n+import org.openhab.io.transport.modbus.ModbusReadCallback;\n+import org.openhab.io.transport.modbus.ModbusReadFunctionCode;\n+import org.openhab.io.transport.modbus.ModbusReadRequestBlueprint;\n+import org.openhab.io.transport.modbus.ModbusRegisterArray;\n+import org.openhab.io.transport.modbus.ModbusSlaveErrorResponseException;\n+import org.openhab.io.transport.modbus.PollTask;\n+import org.openhab.io.transport.modbus.endpoint.ModbusSlaveEndpoint;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * This class is used by the SunspecDiscoveryParticipant to detect\n+ * the model blocks defined by the given device.\n+ * It scans trough the defined model items and notifies the\n+ * discovery service about the discovered devices\n+ *\n+ * @author Nagy Attila Gabor - Initial contribution\n+ */\n+@NonNullByDefault\n+public class SunspecDiscoveryProcess {\n+\n+    /**\n+     * Logger instance\n+     */\n+    private final Logger logger = LoggerFactory.getLogger(SunspecDiscoveryProcess.class);\n+\n+    /**\n+     * The handler instance for this device\n+     */\n+    private final ModbusEndpointThingHandler handler;\n+\n+    /**\n+     * The endpoint where we can reach the device\n+     */\n+    private final ModbusSlaveEndpoint endpoint;\n+\n+    /**\n+     * Listener for the discovered devices. We get this\n+     * from the main discovery service, and it is used to\n+     * submit any discovered Sunspec devices\n+     */\n+    private final ModbusDiscoveryListener listener;\n+\n+    /**\n+     * The endpoint's slave id\n+     */\n+    private int slaveId;\n+\n+    /**\n+     * Number of maximum retries\n+     */\n+    private static final int maxTries = 3;\n+\n+    /**\n+     * List of start addresses to try\n+     */\n+    private List<Integer> possibleAddresses;\n+\n+    /**\n+     * This is the base address where the next block should be searched for\n+     */\n+    private int baseAddress = 40000;\n+\n+    /**\n+     * Count of valid Sunspec blocks found\n+     */\n+    private int blocksFound = 0;\n+\n+    /**\n+     * Parser for commonblock\n+     */\n+    private final CommonModelParser commonBlockParser;\n+\n+    /**\n+     * The last common block found. This is used\n+     * to get the details of any found devices\n+     */\n+    private @Nullable CommonModelBlock lastCommonBlock = null;\n+\n+    /**\n+     * New instances of this class should get a reference to the handler\n+     *\n+     * @throws EndpointNotInitializedException\n+     */\n+    public SunspecDiscoveryProcess(ModbusEndpointThingHandler handler, ModbusDiscoveryListener listener)\n+            throws EndpointNotInitializedException {\n+        this.handler = handler;\n+\n+        ModbusSlaveEndpoint endpoint = this.handler.asSlaveEndpoint();\n+        if (endpoint != null) {\n+            this.endpoint = endpoint;\n+        } else {\n+            throw new EndpointNotInitializedException();\n+        }\n+        slaveId = handler.getSlaveId();\n+        this.listener = listener;\n+        commonBlockParser = new CommonModelParser();\n+        possibleAddresses = new CopyOnWriteArrayList<>();\n+        // Preferred and alternate base registers\n+        // @see SunSpec Information Model Overview\n+        possibleAddresses.add(40000);\n+        possibleAddresses.add(50000);\n+        possibleAddresses.add(0);\n+    }\n+\n+    /**\n+     * Start model detection\n+     *\n+     * @param uid the thing type to look for\n+     * @throws EndpointNotInitializedException\n+     */\n+    public void detectModel() {\n+\n+        if (possibleAddresses.size() < 1) {\n+            parsingFinished();\n+            return;\n+        }\n+        // Try the next address from the possibles\n+        baseAddress = possibleAddresses.get(0);\n+        logger.trace(\"Beginning scan for SunSpec device at address {}\", baseAddress);\n+\n+        BasicModbusReadRequestBlueprint request = new BasicModbusReadRequestBlueprint(slaveId,\n+                ModbusReadFunctionCode.READ_MULTIPLE_REGISTERS, baseAddress, // Start address\n+                SUNSPEC_ID_SIZE, // number or words to return\n+                maxTries);\n+\n+        PollTask task = new BasicPollTaskImpl(endpoint, request, new ModbusReadCallback() {\n+\n+            @Override\n+            public void onRegisters(ModbusReadRequestBlueprint request, ModbusRegisterArray registers) {\n+                headerReceived(registers);\n+            }\n+\n+            @Override\n+            public void onError(ModbusReadRequestBlueprint request, Exception error) {\n+                handleError(error);\n+            }\n+\n+            @Override\n+            public void onBits(@Nullable ModbusReadRequestBlueprint request, @Nullable BitArray bits) {\n+                // don't care, we don't expect this result\n+            }\n+        });\n+\n+        handler.getManagerRef().get().submitOneTimePoll(task);\n+    }\n+\n+    /**\n+     * We received the first two words, that should equal to SunS\n+     */\n+    private void headerReceived(ModbusRegisterArray registers) {\n+        logger.trace(\"Received response from device {}\", registers.toString());\n+\n+        Optional<DecimalType> id = ModbusBitUtilities.extractStateFromRegisters(registers, 0, ValueType.UINT32);\n+\n+        if (!id.isPresent() || id.get().longValue() != SUNSPEC_ID) {\n+            logger.debug(\"Could not find SunSpec DID at address {}, received: {}, expected: {}\", baseAddress, id,\n+                    SUNSPEC_ID);\n+            possibleAddresses.remove(0);\n+            detectModel();\n+            return;\n+        }\n+\n+        logger.trace(\"Header looks correct\");\n+        baseAddress += SUNSPEC_ID_SIZE;\n+\n+        lookForModelBlock();\n+    }\n+\n+    /**\n+     * Look for a valid model block at the current base address\n+     */\n+    private void lookForModelBlock() {\n+\n+        BasicModbusReadRequestBlueprint request = new BasicModbusReadRequestBlueprint(slaveId,\n+                ModbusReadFunctionCode.READ_MULTIPLE_REGISTERS, baseAddress, // Start address\n+                MODEL_HEADER_SIZE, // number or words to return\n+                maxTries);\n+\n+        PollTask task = new BasicPollTaskImpl(endpoint, request, new ModbusReadCallback() {\n+\n+            @Override\n+            public void onRegisters(ModbusReadRequestBlueprint request, ModbusRegisterArray registers) {\n+                modelBlockReceived(registers);\n+            }\n+\n+            @Override\n+            public void onError(ModbusReadRequestBlueprint request, Exception error) {\n+                handleError(error);\n+            }\n+\n+            @Override\n+            public void onBits(@Nullable ModbusReadRequestBlueprint request, @Nullable BitArray bits) {\n+                // don't care, we don't expect this result\n+            }\n+        });\n+\n+        handler.getManagerRef().get().submitOneTimePoll(task);\n+    }\n+\n+    /**\n+     * We received a model block header\n+     */\n+    private void modelBlockReceived(ModbusRegisterArray registers) {\n+        logger.debug(\"Received response from device {}\", registers.toString());\n+\n+        Optional<DecimalType> moduleID = ModbusBitUtilities.extractStateFromRegisters(registers, 0, ValueType.UINT16);\n+        Optional<DecimalType> blockLength = ModbusBitUtilities.extractStateFromRegisters(registers, 1,\n+                ValueType.UINT16);\n+\n+        if (!moduleID.isPresent() || !blockLength.isPresent()) {\n+            logger.info(\"Could not find valid module id or block length field.\");\n+            parsingFinished();\n+            return;\n+        }\n+        ModelBlock block = new ModelBlock();\n+        block.address = baseAddress;\n+        block.moduleID = moduleID.get().intValue();\n+        block.length = blockLength.get().intValue() + MODEL_HEADER_SIZE;\n+        logger.debug(\"SunSpec detector found block {}\", block);\n+\n+        blocksFound++;\n+\n+        if (block.moduleID == FINAL_BLOCK) {\n+            parsingFinished();\n+        } else {\n+            baseAddress += block.length;\n+            if (block.moduleID == COMMON_BLOCK) {\n+                readCommonBlock(block); // This is an asynchronous task\n+                return;\n+            } else {\n+                createDiscoveryResult(block);\n+                lookForModelBlock();\n+            }\n+\n+        }\n+    }\n+\n+    /**\n+     * Start reading common block\n+     *\n+     * @param block\n+     */\n+    private void readCommonBlock(ModelBlock block) {\n+        BasicModbusReadRequestBlueprint request = new BasicModbusReadRequestBlueprint(slaveId,\n+                ModbusReadFunctionCode.READ_MULTIPLE_REGISTERS, block.address, // Start address\n+                block.length, // number or words to return\n+                maxTries);\n+\n+        PollTask task = new BasicPollTaskImpl(endpoint, request, new ModbusReadCallback() {\n+\n+            @Override\n+            public void onRegisters(ModbusReadRequestBlueprint request, ModbusRegisterArray registers) {\n+                parseCommonBlock(registers);\n+            }\n+\n+            @Override\n+            public void onError(ModbusReadRequestBlueprint request, Exception error) {\n+                handleError(error);\n+            }\n+\n+            @Override\n+            public void onBits(@Nullable ModbusReadRequestBlueprint request, @Nullable BitArray bits) {\n+                // don't care, we don't expect this result\n+            }\n+        });\n+\n+        handler.getManagerRef().get().submitOneTimePoll(task);\n+    }\n+\n+    /**\n+     * We've read the details of a common block now parse it, and\n+     * store for later use\n+     *\n+     * @param registers\n+     */\n+    private void parseCommonBlock(ModbusRegisterArray registers) {\n+        logger.trace(\"Got common block data: {}\", registers);\n+        lastCommonBlock = commonBlockParser.parse(registers);\n+        lookForModelBlock(); // Continue parsing\n+    }\n+\n+    /**\n+     * Create a discovery result from a model block\n+     *\n+     * @param block the block we've found\n+     */\n+    private void createDiscoveryResult(ModelBlock block) {\n+        if (!SUPPORTED_THING_TYPES_UIDS.containsKey(block.moduleID)) {\n+            logger.debug(\"ModuleID {} is not supported, skipping this block\", block.moduleID);\n+            return;\n+        }\n+\n+        CommonModelBlock commonBlock = lastCommonBlock;\n+\n+        if (commonBlock == null) {\n+            logger.warn(\n+                    \"Found model block without a preceding common block. Can't add device because details are unkown\");\n+            return;\n+        }\n+\n+        ThingUID thingUID = new ThingUID(SUPPORTED_THING_TYPES_UIDS.get(block.moduleID), handler.getUID(),\n+                Integer.toString(block.address));\n+\n+        Map<String, Object> properties = new HashMap<>();\n+        properties.put(PROPERTY_VENDOR, commonBlock.manufacturer);\n+        properties.put(PROPERTY_MODEL, commonBlock.model);\n+        properties.put(PROPERTY_SERIAL_NUMBER, commonBlock.serialNumber);\n+        properties.put(PROPERTY_VERSION, commonBlock.version);\n+        properties.put(PROPERTY_BLOCK_ADDRESS, block.address);\n+        properties.put(PROPERTY_BLOCK_LENGTH, block.length);\n+        properties.put(PROPERTY_UNIQUE_ADDRESS, handler.getUID().getAsString() + \":\" + block.address);\n+\n+        DiscoveryResult result = DiscoveryResultBuilder.create(thingUID).withProperties(properties)\n+                .withRepresentationProperty(PROPERTY_UNIQUE_ADDRESS).withBridge(handler.getUID())\n+                .withLabel(commonBlock.manufacturer + \" \" + commonBlock.model).build();\n+\n+        listener.thingDiscovered(result);\n+    }\n+\n+    /**\n+     * Parsing of model blocks finished\n+     * Now we have to report back to the handler the common block and the block we were looking for\n+     */\n+    private void parsingFinished() {\n+        listener.discoveryFinished();\n+    }\n+\n+    /**\n+     * Handle errors received during communication\n+     */\n+    private void handleError(Exception error) {\n+        String msg = \"\";\n+        String cls = \"\";\n+\n+        if (blocksFound > 1 && error instanceof ModbusSlaveErrorResponseException) {\n+            int code = ((ModbusSlaveErrorResponseException) error).getExceptionCode();\n+            if (code == ModbusSlaveErrorResponseException.ILLEGAL_DATA_ACCESS\n+                    || code == ModbusSlaveErrorResponseException.ILLEGAL_DATA_VALUE) {\n+                // It is very likely that the slave does not report an end block (0xffff) after the main blocks\n+                // so we treat this situation as normal.\n+                logger.debug(\n+                        \"Seems like slave device does not report an end block. Continouing with the dectected blocks\");\n+                parsingFinished();\n+                return;\n+            }\n+        }\n+\n+        cls = error.getClass().getName();\n+        msg = error.getMessage();\n+\n+        logger.warn(\"Error with read at address {}: {} {}\", baseAddress, cls, msg);\n+\n+        possibleAddresses.remove(0); // Drop the current base address, and continue with the next one", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fc81ca045f9bb7f80dff8801e58bd68dd0e8badc"}, "originalPosition": 393}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f8e83ce9e09bdda8f811abed0eef808be8b1fd22", "author": {"user": {"login": "mrbig", "name": "Nagy Attila G\u00e1bor"}}, "url": "https://github.com/openhab/openhab-addons/commit/f8e83ce9e09bdda8f811abed0eef808be8b1fd22", "committedDate": "2020-04-20T07:19:19Z", "message": "[sunspec] discovery process thread safe refactoring\n\n\nSigned-off-by: Nagy Attila Gabor <mrbig@sneaker.hu>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk2NTYzMTk0", "url": "https://github.com/openhab/openhab-addons/pull/6994#pullrequestreview-396563194", "createdAt": "2020-04-20T15:28:02Z", "commit": {"oid": "f8e83ce9e09bdda8f811abed0eef808be8b1fd22"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1435, "cost": 1, "resetAt": "2021-10-28T19:08:13Z"}}}