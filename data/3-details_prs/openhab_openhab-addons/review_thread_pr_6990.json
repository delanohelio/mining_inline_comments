{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzcyODc1ODYz", "number": 6990, "reviewThreads": {"totalCount": 71, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wM1QxMjoyOTowOVrOEf962A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xM1QxNzoxNjozOFrOEi5JDw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAxOTU1ODAwOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.jablotron/src/main/resources/ESH-INF/config/config.xml", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wM1QxMjoyOTowOVrOHMkSug==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNlQxOToyNTozMlrOHNrcug==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjkzOTU3OA==", "bodyText": "Use the attribute required instead of the element required. The latter is deprecated:\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t<config-description uri=\"bridge-type:jablotron:bridge\">\n          \n          \n            \n            \t<config-description uri=\"bridge-type:jablotron:bridge\" required=\"true\">\n          \n      \n    \n    \n  \n\nAlso check other paramters.", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r482939578", "createdAt": "2020-09-03T12:29:09Z", "author": {"login": "Hilbrand"}, "path": "bundles/org.openhab.binding.jablotron/src/main/resources/ESH-INF/config/config.xml", "diffHunk": "@@ -0,0 +1,79 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<config-description:config-descriptions xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\t\t\t\t\t\t\t\t\t\txmlns:config-description=\"https://openhab.org/schemas/config-description/v1.0.0\"\n+\t\t\t\t\t\t\t\t\t\txsi:schemaLocation=\"https://openhab.org/schemas/config-description/v1.0.0 https://openhab.org/schemas/config-description-1.0.0.xsd\">\n+\n+\t<config-description uri=\"thing-type:jablotron:device\">\n+\t\t<parameter name=\"refresh\" type=\"integer\" required=\"false\">\n+\t\t\t<label>Refresh</label>\n+\t\t\t<description>Specifies the refresh time of thing channels in seconds</description>\n+\t\t\t<default>60</default>\n+\t\t</parameter>\n+\t</config-description>\n+\n+\t<config-description uri=\"thing-type:jablotron:ja100device\">\n+\t\t<parameter name=\"refresh\" type=\"integer\" required=\"false\">\n+\t\t\t<label>Refresh</label>\n+\t\t\t<description>Specifies the refresh time of thing channels in seconds</description>\n+\t\t\t<default>60</default>\n+\t\t</parameter>\n+\n+\t\t<parameter name=\"code\" type=\"text\">\n+\t\t\t<context>password</context>\n+\t\t\t<label>Code</label>\n+\t\t\t<description>Master code for the JA100 alarm</description>\n+\t\t\t<required>false</required>\n+\t\t</parameter>\n+\t</config-description>\n+\n+\t<config-description uri=\"bridge-type:jablotron:bridge\">", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "36775963f2d1f6fd1e9689f06b070bfa8e6a859e"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDEwNTQwMg==", "bodyText": "ok, fixed", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r484105402", "createdAt": "2020-09-06T19:25:32Z", "author": {"login": "octa22"}, "path": "bundles/org.openhab.binding.jablotron/src/main/resources/ESH-INF/config/config.xml", "diffHunk": "@@ -0,0 +1,79 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<config-description:config-descriptions xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\t\t\t\t\t\t\t\t\t\txmlns:config-description=\"https://openhab.org/schemas/config-description/v1.0.0\"\n+\t\t\t\t\t\t\t\t\t\txsi:schemaLocation=\"https://openhab.org/schemas/config-description/v1.0.0 https://openhab.org/schemas/config-description-1.0.0.xsd\">\n+\n+\t<config-description uri=\"thing-type:jablotron:device\">\n+\t\t<parameter name=\"refresh\" type=\"integer\" required=\"false\">\n+\t\t\t<label>Refresh</label>\n+\t\t\t<description>Specifies the refresh time of thing channels in seconds</description>\n+\t\t\t<default>60</default>\n+\t\t</parameter>\n+\t</config-description>\n+\n+\t<config-description uri=\"thing-type:jablotron:ja100device\">\n+\t\t<parameter name=\"refresh\" type=\"integer\" required=\"false\">\n+\t\t\t<label>Refresh</label>\n+\t\t\t<description>Specifies the refresh time of thing channels in seconds</description>\n+\t\t\t<default>60</default>\n+\t\t</parameter>\n+\n+\t\t<parameter name=\"code\" type=\"text\">\n+\t\t\t<context>password</context>\n+\t\t\t<label>Code</label>\n+\t\t\t<description>Master code for the JA100 alarm</description>\n+\t\t\t<required>false</required>\n+\t\t</parameter>\n+\t</config-description>\n+\n+\t<config-description uri=\"bridge-type:jablotron:bridge\">", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjkzOTU3OA=="}, "originalCommit": {"oid": "36775963f2d1f6fd1e9689f06b070bfa8e6a859e"}, "originalPosition": 29}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAxOTU1OTYyOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.jablotron/src/main/resources/ESH-INF/config/config.xml", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wM1QxMjoyOTozNVrOHMkTug==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNlQxOToyNTo0NVrOHNrczw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjkzOTgzNA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\t\t<label>Refresh refresh</label>\n          \n          \n            \n            \t\t\t<label>Refresh</label>", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r482939834", "createdAt": "2020-09-03T12:29:35Z", "author": {"login": "Hilbrand"}, "path": "bundles/org.openhab.binding.jablotron/src/main/resources/ESH-INF/config/config.xml", "diffHunk": "@@ -0,0 +1,79 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<config-description:config-descriptions xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\t\t\t\t\t\t\t\t\t\txmlns:config-description=\"https://openhab.org/schemas/config-description/v1.0.0\"\n+\t\t\t\t\t\t\t\t\t\txsi:schemaLocation=\"https://openhab.org/schemas/config-description/v1.0.0 https://openhab.org/schemas/config-description-1.0.0.xsd\">\n+\n+\t<config-description uri=\"thing-type:jablotron:device\">\n+\t\t<parameter name=\"refresh\" type=\"integer\" required=\"false\">\n+\t\t\t<label>Refresh</label>\n+\t\t\t<description>Specifies the refresh time of thing channels in seconds</description>\n+\t\t\t<default>60</default>\n+\t\t</parameter>\n+\t</config-description>\n+\n+\t<config-description uri=\"thing-type:jablotron:ja100device\">\n+\t\t<parameter name=\"refresh\" type=\"integer\" required=\"false\">\n+\t\t\t<label>Refresh</label>\n+\t\t\t<description>Specifies the refresh time of thing channels in seconds</description>\n+\t\t\t<default>60</default>\n+\t\t</parameter>\n+\n+\t\t<parameter name=\"code\" type=\"text\">\n+\t\t\t<context>password</context>\n+\t\t\t<label>Code</label>\n+\t\t\t<description>Master code for the JA100 alarm</description>\n+\t\t\t<required>false</required>\n+\t\t</parameter>\n+\t</config-description>\n+\n+\t<config-description uri=\"bridge-type:jablotron:bridge\">\n+\t\t<parameter name=\"login\" type=\"text\">\n+\t\t\t<label>Login</label>\n+\t\t\t<description>Login for Jablonet portal</description>\n+\t\t\t<required>true</required>\n+\t\t</parameter>\n+\n+\t\t<parameter name=\"password\" type=\"text\">\n+\t\t\t<context>password</context>\n+\t\t\t<label>Password</label>\n+\t\t\t<description>Password for Jablonet portal</description>\n+\t\t\t<required>true</required>\n+\t\t</parameter>\n+\n+\t\t<parameter name=\"lang\" type=\"text\">\n+\t\t\t<default>en</default>\n+\t\t\t<label>Language</label>\n+\t\t\t<description>Language for Jablonet portal</description>\n+\t\t\t<options>\n+\t\t\t\t<option value=\"cs\">\u010cesky</option>\n+\t\t\t\t<option value=\"da\">Dansk</option>\n+\t\t\t\t<option value=\"de\">Deutsch</option>\n+\t\t\t\t<option value=\"en\">English</option>\n+\t\t\t\t<option value=\"es\">Espa\u00f1ol</option>\n+\t\t\t\t<option value=\"fr\">Fran\u00e7ais</option>\n+\t\t\t\t<option value=\"hr\">Hrvatski</option>\n+\t\t\t\t<option value=\"it\">Italiano</option>\n+\t\t\t\t<option value=\"hu\">Magyar</option>\n+\t\t\t\t<option value=\"nl\">Nederlands</option>\n+\t\t\t\t<option value=\"vi\">Ng\u01b0\u1eddi vi\u1ec7t nam</option>\n+\t\t\t\t<option value=\"no\">Norsk</option>\n+\t\t\t\t<option value=\"pl\">Polski</option>\n+\t\t\t\t<option value=\"pt\">Portugues</option>\n+\t\t\t\t<option value=\"ro\">Rom\u00e2n\u0103</option>\n+\t\t\t\t<option value=\"sl\">Slovenski</option>\n+\t\t\t\t<option value=\"sk\">Slovensky</option>\n+\t\t\t\t<option value=\"sr\">Srpski</option>\n+\t\t\t\t<option value=\"fi\">Suomi</option>\n+\t\t\t\t<option value=\"sv\">Svenska</option>\n+\t\t\t\t<option value=\"tr\">T\u00fcrk\u00e7e</option>\n+\t\t\t</options>\n+\t\t\t<required>true</required>\n+\t\t</parameter>\n+\n+\t\t<parameter name=\"refresh\" type=\"integer\" required=\"false\">\n+\t\t\t<label>Refresh refresh</label>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "36775963f2d1f6fd1e9689f06b070bfa8e6a859e"}, "originalPosition": 74}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDEwNTQyMw==", "bodyText": "fixed", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r484105423", "createdAt": "2020-09-06T19:25:45Z", "author": {"login": "octa22"}, "path": "bundles/org.openhab.binding.jablotron/src/main/resources/ESH-INF/config/config.xml", "diffHunk": "@@ -0,0 +1,79 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<config-description:config-descriptions xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\t\t\t\t\t\t\t\t\t\txmlns:config-description=\"https://openhab.org/schemas/config-description/v1.0.0\"\n+\t\t\t\t\t\t\t\t\t\txsi:schemaLocation=\"https://openhab.org/schemas/config-description/v1.0.0 https://openhab.org/schemas/config-description-1.0.0.xsd\">\n+\n+\t<config-description uri=\"thing-type:jablotron:device\">\n+\t\t<parameter name=\"refresh\" type=\"integer\" required=\"false\">\n+\t\t\t<label>Refresh</label>\n+\t\t\t<description>Specifies the refresh time of thing channels in seconds</description>\n+\t\t\t<default>60</default>\n+\t\t</parameter>\n+\t</config-description>\n+\n+\t<config-description uri=\"thing-type:jablotron:ja100device\">\n+\t\t<parameter name=\"refresh\" type=\"integer\" required=\"false\">\n+\t\t\t<label>Refresh</label>\n+\t\t\t<description>Specifies the refresh time of thing channels in seconds</description>\n+\t\t\t<default>60</default>\n+\t\t</parameter>\n+\n+\t\t<parameter name=\"code\" type=\"text\">\n+\t\t\t<context>password</context>\n+\t\t\t<label>Code</label>\n+\t\t\t<description>Master code for the JA100 alarm</description>\n+\t\t\t<required>false</required>\n+\t\t</parameter>\n+\t</config-description>\n+\n+\t<config-description uri=\"bridge-type:jablotron:bridge\">\n+\t\t<parameter name=\"login\" type=\"text\">\n+\t\t\t<label>Login</label>\n+\t\t\t<description>Login for Jablonet portal</description>\n+\t\t\t<required>true</required>\n+\t\t</parameter>\n+\n+\t\t<parameter name=\"password\" type=\"text\">\n+\t\t\t<context>password</context>\n+\t\t\t<label>Password</label>\n+\t\t\t<description>Password for Jablonet portal</description>\n+\t\t\t<required>true</required>\n+\t\t</parameter>\n+\n+\t\t<parameter name=\"lang\" type=\"text\">\n+\t\t\t<default>en</default>\n+\t\t\t<label>Language</label>\n+\t\t\t<description>Language for Jablonet portal</description>\n+\t\t\t<options>\n+\t\t\t\t<option value=\"cs\">\u010cesky</option>\n+\t\t\t\t<option value=\"da\">Dansk</option>\n+\t\t\t\t<option value=\"de\">Deutsch</option>\n+\t\t\t\t<option value=\"en\">English</option>\n+\t\t\t\t<option value=\"es\">Espa\u00f1ol</option>\n+\t\t\t\t<option value=\"fr\">Fran\u00e7ais</option>\n+\t\t\t\t<option value=\"hr\">Hrvatski</option>\n+\t\t\t\t<option value=\"it\">Italiano</option>\n+\t\t\t\t<option value=\"hu\">Magyar</option>\n+\t\t\t\t<option value=\"nl\">Nederlands</option>\n+\t\t\t\t<option value=\"vi\">Ng\u01b0\u1eddi vi\u1ec7t nam</option>\n+\t\t\t\t<option value=\"no\">Norsk</option>\n+\t\t\t\t<option value=\"pl\">Polski</option>\n+\t\t\t\t<option value=\"pt\">Portugues</option>\n+\t\t\t\t<option value=\"ro\">Rom\u00e2n\u0103</option>\n+\t\t\t\t<option value=\"sl\">Slovenski</option>\n+\t\t\t\t<option value=\"sk\">Slovensky</option>\n+\t\t\t\t<option value=\"sr\">Srpski</option>\n+\t\t\t\t<option value=\"fi\">Suomi</option>\n+\t\t\t\t<option value=\"sv\">Svenska</option>\n+\t\t\t\t<option value=\"tr\">T\u00fcrk\u00e7e</option>\n+\t\t\t</options>\n+\t\t\t<required>true</required>\n+\t\t</parameter>\n+\n+\t\t<parameter name=\"refresh\" type=\"integer\" required=\"false\">\n+\t\t\t<label>Refresh refresh</label>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjkzOTgzNA=="}, "originalCommit": {"oid": "36775963f2d1f6fd1e9689f06b070bfa8e6a859e"}, "originalPosition": 74}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAxOTU2MTc4OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.jablotron/src/main/resources/ESH-INF/thing/bridge.xml", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wM1QxMjozMDowNlrOHMkVCQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNlQxOToyOTo0N1rOHNreFQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mjk0MDE2OQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\t<label>Jablotron Jablonet Bridge</label>\n          \n          \n            \n            \t\t<label>Jablonet Bridge</label>", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r482940169", "createdAt": "2020-09-03T12:30:06Z", "author": {"login": "Hilbrand"}, "path": "bundles/org.openhab.binding.jablotron/src/main/resources/ESH-INF/thing/bridge.xml", "diffHunk": "@@ -0,0 +1,14 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"jablotron\"\n+\t\t\t\t\t\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\t\t\t\t\t\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\t\t\t\t\t\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\t<!-- Jablonet -->\n+\t<bridge-type id=\"bridge\">\n+\t\t<label>Jablotron Jablonet Bridge</label>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "36775963f2d1f6fd1e9689f06b070bfa8e6a859e"}, "originalPosition": 8}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDEwNTc0OQ==", "bodyText": "fixed", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r484105749", "createdAt": "2020-09-06T19:29:47Z", "author": {"login": "octa22"}, "path": "bundles/org.openhab.binding.jablotron/src/main/resources/ESH-INF/thing/bridge.xml", "diffHunk": "@@ -0,0 +1,14 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"jablotron\"\n+\t\t\t\t\t\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\t\t\t\t\t\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\t\t\t\t\t\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\t<!-- Jablonet -->\n+\t<bridge-type id=\"bridge\">\n+\t\t<label>Jablotron Jablonet Bridge</label>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mjk0MDE2OQ=="}, "originalCommit": {"oid": "36775963f2d1f6fd1e9689f06b070bfa8e6a859e"}, "originalPosition": 8}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAxOTU2NTEyOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.jablotron/src/main/resources/ESH-INF/thing/channels.xml", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wM1QxMjozMDo1OFrOHMkW_A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOFQxOToyMzo0MVrOHOq5nQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mjk0MDY2OA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\t<label>Alarm state</label>\n          \n          \n            \n            \t\t<label>Alarm State</label>\n          \n      \n    \n    \n  \n\nAlso check others labels. Words must be uppercase, with some exceptions: https://www.openhab.org/docs/developer/bindings/thing-xml.html#formatting-labels-and-descriptions", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r482940668", "createdAt": "2020-09-03T12:30:58Z", "author": {"login": "Hilbrand"}, "path": "bundles/org.openhab.binding.jablotron/src/main/resources/ESH-INF/thing/channels.xml", "diffHunk": "@@ -0,0 +1,164 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"jablotron\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\t\t\t\t\t\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\t\t\t\t\t\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\t<!-- Oasis -->\n+\t<!-- StatusA -->\n+\t<channel-type id=\"statusA\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Alarm Zone A Status Channel</label>\n+\t\t<description>Status of the A zone of your alarm</description>\n+\t\t<state readOnly=\"true\"/>\n+\t</channel-type>\n+\n+\t<!-- StatusB -->\n+\t<channel-type id=\"statusB\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Alarm B Status Channel</label>\n+\t\t<description>Status of the B zone of your alarm</description>\n+\t\t<state readOnly=\"true\"/>\n+\t</channel-type>\n+\n+\t<!-- StatusABC -->\n+\t<channel-type id=\"statusABC\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Alarm Zone ABC Status Channel</label>\n+\t\t<description>Status of the ABC zone of your alarm</description>\n+\t\t<state readOnly=\"true\"/>\n+\t</channel-type>\n+\n+\t<!-- StatusPGX -->\n+\t<channel-type id=\"statusPGX\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>OASIS PGX Status Channel</label>\n+\t\t<description>Status of the PGX switch of your OASIS alarm</description>\n+\t</channel-type>\n+\n+\t<!-- StatusPGY -->\n+\t<channel-type id=\"statusPGY\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>OASIS PGY Status Channel</label>\n+\t\t<description>Status of the PGY switch of your OASIS alarm</description>\n+\t</channel-type>\n+\n+\t<!-- JA100 -->\n+\t<channel-type id=\"status\">\n+\t\t<item-type>Number</item-type>\n+\t\t<label>Alarm Section Status Channel</label>\n+\t\t<description>Status of the section of your alarm</description>\n+\t</channel-type>\n+\n+\t<!-- StatusPGM -->\n+\t<channel-type id=\"statusPGM\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>JA-100 PGM Status Channel</label>\n+\t\t<description>Status of the PGM switch of your JA-100 alarm</description>\n+\t</channel-type>\n+\n+\t<!-- Alarm -->\n+\t<channel-type id=\"alarm\">\n+\t\t<kind>trigger</kind>\n+\t\t<label>Alarm Channel</label>\n+\t\t<description>Status of the alarm of your alarm</description>\n+\t\t<state readOnly=\"true\"/>\n+\t</channel-type>\n+\n+\t<!-- Command -->\n+\t<channel-type id=\"command\">\n+\t\t<item-type>String</item-type>\n+\t\t<label>Alarm Command Channel</label>\n+\t\t<description>Channel for sending commands to your alarm</description>\n+\t</channel-type>\n+\n+\t<!-- LastEvent -->\n+\t<channel-type id=\"lastEvent\">\n+\t\t<item-type>String</item-type>\n+\t\t<label>Alarm Last Event Text Description Channel</label>\n+\t\t<description>Text description of the last event of your alarm</description>\n+\t\t<state readOnly=\"true\"/>\n+\t</channel-type>\n+\n+\t<!-- LastEventClass -->\n+\t<channel-type id=\"lastEventClass\">\n+\t\t<item-type>String</item-type>\n+\t\t<label>Alarm Last Event Class Channel</label>\n+\t\t<description>Class of the last event of your alarm (arm, disarm, ...)</description>\n+\t\t<state readOnly=\"true\"/>\n+\t</channel-type>\n+\n+\t<!-- LastEventSection -->\n+\t<channel-type id=\"lastEventSection\">\n+\t\t<item-type>String</item-type>\n+\t\t<label>Alarm Last Event Section Channel</label>\n+\t\t<description>The last event section of your alarm</description>\n+\t\t<state readOnly=\"true\"/>\n+\t</channel-type>\n+\n+\t<!-- LastEventInvoker -->\n+\t<channel-type id=\"lastEventInvoker\">\n+\t\t<item-type>String</item-type>\n+\t\t<label>Alarm Last Event Invoker Channel</label>\n+\t\t<description>The last event invoker</description>\n+\t\t<state readOnly=\"true\"/>\n+\t</channel-type>\n+\n+\t<!-- LastEventTime -->\n+\t<channel-type id=\"lastEventTime\">\n+\t\t<item-type>DateTime</item-type>\n+\t\t<label>Alarm Last Event Time Channel</label>\n+\t\t<description>Date and time of the last event of your alarm</description>\n+\t\t<state readOnly=\"true\"/>\n+\t</channel-type>\n+\n+\t<!-- LastCheckTime -->\n+\t<channel-type id=\"lastCheckTime\">\n+\t\t<item-type>DateTime</item-type>\n+\t\t<label>Alarm Last Check Time Channel</label>\n+\t\t<description>Date and time of last status check of your alarm</description>\n+\t\t<state readOnly=\"true\"/>\n+\t</channel-type>\n+\n+\t<!-- alarm_state -->\n+\t<channel-type id=\"alarm_state\">\n+\t\t<item-type>String</item-type>\n+\t\t<label>Alarm state</label>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "36775963f2d1f6fd1e9689f06b070bfa8e6a859e"}, "originalPosition": 124}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDEwNTY0NA==", "bodyText": "fixed and checked", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r484105644", "createdAt": "2020-09-06T19:28:44Z", "author": {"login": "octa22"}, "path": "bundles/org.openhab.binding.jablotron/src/main/resources/ESH-INF/thing/channels.xml", "diffHunk": "@@ -0,0 +1,164 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"jablotron\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\t\t\t\t\t\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\t\t\t\t\t\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\t<!-- Oasis -->\n+\t<!-- StatusA -->\n+\t<channel-type id=\"statusA\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Alarm Zone A Status Channel</label>\n+\t\t<description>Status of the A zone of your alarm</description>\n+\t\t<state readOnly=\"true\"/>\n+\t</channel-type>\n+\n+\t<!-- StatusB -->\n+\t<channel-type id=\"statusB\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Alarm B Status Channel</label>\n+\t\t<description>Status of the B zone of your alarm</description>\n+\t\t<state readOnly=\"true\"/>\n+\t</channel-type>\n+\n+\t<!-- StatusABC -->\n+\t<channel-type id=\"statusABC\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Alarm Zone ABC Status Channel</label>\n+\t\t<description>Status of the ABC zone of your alarm</description>\n+\t\t<state readOnly=\"true\"/>\n+\t</channel-type>\n+\n+\t<!-- StatusPGX -->\n+\t<channel-type id=\"statusPGX\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>OASIS PGX Status Channel</label>\n+\t\t<description>Status of the PGX switch of your OASIS alarm</description>\n+\t</channel-type>\n+\n+\t<!-- StatusPGY -->\n+\t<channel-type id=\"statusPGY\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>OASIS PGY Status Channel</label>\n+\t\t<description>Status of the PGY switch of your OASIS alarm</description>\n+\t</channel-type>\n+\n+\t<!-- JA100 -->\n+\t<channel-type id=\"status\">\n+\t\t<item-type>Number</item-type>\n+\t\t<label>Alarm Section Status Channel</label>\n+\t\t<description>Status of the section of your alarm</description>\n+\t</channel-type>\n+\n+\t<!-- StatusPGM -->\n+\t<channel-type id=\"statusPGM\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>JA-100 PGM Status Channel</label>\n+\t\t<description>Status of the PGM switch of your JA-100 alarm</description>\n+\t</channel-type>\n+\n+\t<!-- Alarm -->\n+\t<channel-type id=\"alarm\">\n+\t\t<kind>trigger</kind>\n+\t\t<label>Alarm Channel</label>\n+\t\t<description>Status of the alarm of your alarm</description>\n+\t\t<state readOnly=\"true\"/>\n+\t</channel-type>\n+\n+\t<!-- Command -->\n+\t<channel-type id=\"command\">\n+\t\t<item-type>String</item-type>\n+\t\t<label>Alarm Command Channel</label>\n+\t\t<description>Channel for sending commands to your alarm</description>\n+\t</channel-type>\n+\n+\t<!-- LastEvent -->\n+\t<channel-type id=\"lastEvent\">\n+\t\t<item-type>String</item-type>\n+\t\t<label>Alarm Last Event Text Description Channel</label>\n+\t\t<description>Text description of the last event of your alarm</description>\n+\t\t<state readOnly=\"true\"/>\n+\t</channel-type>\n+\n+\t<!-- LastEventClass -->\n+\t<channel-type id=\"lastEventClass\">\n+\t\t<item-type>String</item-type>\n+\t\t<label>Alarm Last Event Class Channel</label>\n+\t\t<description>Class of the last event of your alarm (arm, disarm, ...)</description>\n+\t\t<state readOnly=\"true\"/>\n+\t</channel-type>\n+\n+\t<!-- LastEventSection -->\n+\t<channel-type id=\"lastEventSection\">\n+\t\t<item-type>String</item-type>\n+\t\t<label>Alarm Last Event Section Channel</label>\n+\t\t<description>The last event section of your alarm</description>\n+\t\t<state readOnly=\"true\"/>\n+\t</channel-type>\n+\n+\t<!-- LastEventInvoker -->\n+\t<channel-type id=\"lastEventInvoker\">\n+\t\t<item-type>String</item-type>\n+\t\t<label>Alarm Last Event Invoker Channel</label>\n+\t\t<description>The last event invoker</description>\n+\t\t<state readOnly=\"true\"/>\n+\t</channel-type>\n+\n+\t<!-- LastEventTime -->\n+\t<channel-type id=\"lastEventTime\">\n+\t\t<item-type>DateTime</item-type>\n+\t\t<label>Alarm Last Event Time Channel</label>\n+\t\t<description>Date and time of the last event of your alarm</description>\n+\t\t<state readOnly=\"true\"/>\n+\t</channel-type>\n+\n+\t<!-- LastCheckTime -->\n+\t<channel-type id=\"lastCheckTime\">\n+\t\t<item-type>DateTime</item-type>\n+\t\t<label>Alarm Last Check Time Channel</label>\n+\t\t<description>Date and time of last status check of your alarm</description>\n+\t\t<state readOnly=\"true\"/>\n+\t</channel-type>\n+\n+\t<!-- alarm_state -->\n+\t<channel-type id=\"alarm_state\">\n+\t\t<item-type>String</item-type>\n+\t\t<label>Alarm state</label>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mjk0MDY2OA=="}, "originalCommit": {"oid": "36775963f2d1f6fd1e9689f06b070bfa8e6a859e"}, "originalPosition": 124}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE0NDk4OQ==", "bodyText": "This one is still having a lower case word", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r485144989", "createdAt": "2020-09-08T19:23:41Z", "author": {"login": "Hilbrand"}, "path": "bundles/org.openhab.binding.jablotron/src/main/resources/ESH-INF/thing/channels.xml", "diffHunk": "@@ -0,0 +1,164 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"jablotron\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\t\t\t\t\t\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\t\t\t\t\t\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\t<!-- Oasis -->\n+\t<!-- StatusA -->\n+\t<channel-type id=\"statusA\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Alarm Zone A Status Channel</label>\n+\t\t<description>Status of the A zone of your alarm</description>\n+\t\t<state readOnly=\"true\"/>\n+\t</channel-type>\n+\n+\t<!-- StatusB -->\n+\t<channel-type id=\"statusB\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Alarm B Status Channel</label>\n+\t\t<description>Status of the B zone of your alarm</description>\n+\t\t<state readOnly=\"true\"/>\n+\t</channel-type>\n+\n+\t<!-- StatusABC -->\n+\t<channel-type id=\"statusABC\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Alarm Zone ABC Status Channel</label>\n+\t\t<description>Status of the ABC zone of your alarm</description>\n+\t\t<state readOnly=\"true\"/>\n+\t</channel-type>\n+\n+\t<!-- StatusPGX -->\n+\t<channel-type id=\"statusPGX\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>OASIS PGX Status Channel</label>\n+\t\t<description>Status of the PGX switch of your OASIS alarm</description>\n+\t</channel-type>\n+\n+\t<!-- StatusPGY -->\n+\t<channel-type id=\"statusPGY\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>OASIS PGY Status Channel</label>\n+\t\t<description>Status of the PGY switch of your OASIS alarm</description>\n+\t</channel-type>\n+\n+\t<!-- JA100 -->\n+\t<channel-type id=\"status\">\n+\t\t<item-type>Number</item-type>\n+\t\t<label>Alarm Section Status Channel</label>\n+\t\t<description>Status of the section of your alarm</description>\n+\t</channel-type>\n+\n+\t<!-- StatusPGM -->\n+\t<channel-type id=\"statusPGM\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>JA-100 PGM Status Channel</label>\n+\t\t<description>Status of the PGM switch of your JA-100 alarm</description>\n+\t</channel-type>\n+\n+\t<!-- Alarm -->\n+\t<channel-type id=\"alarm\">\n+\t\t<kind>trigger</kind>\n+\t\t<label>Alarm Channel</label>\n+\t\t<description>Status of the alarm of your alarm</description>\n+\t\t<state readOnly=\"true\"/>\n+\t</channel-type>\n+\n+\t<!-- Command -->\n+\t<channel-type id=\"command\">\n+\t\t<item-type>String</item-type>\n+\t\t<label>Alarm Command Channel</label>\n+\t\t<description>Channel for sending commands to your alarm</description>\n+\t</channel-type>\n+\n+\t<!-- LastEvent -->\n+\t<channel-type id=\"lastEvent\">\n+\t\t<item-type>String</item-type>\n+\t\t<label>Alarm Last Event Text Description Channel</label>\n+\t\t<description>Text description of the last event of your alarm</description>\n+\t\t<state readOnly=\"true\"/>\n+\t</channel-type>\n+\n+\t<!-- LastEventClass -->\n+\t<channel-type id=\"lastEventClass\">\n+\t\t<item-type>String</item-type>\n+\t\t<label>Alarm Last Event Class Channel</label>\n+\t\t<description>Class of the last event of your alarm (arm, disarm, ...)</description>\n+\t\t<state readOnly=\"true\"/>\n+\t</channel-type>\n+\n+\t<!-- LastEventSection -->\n+\t<channel-type id=\"lastEventSection\">\n+\t\t<item-type>String</item-type>\n+\t\t<label>Alarm Last Event Section Channel</label>\n+\t\t<description>The last event section of your alarm</description>\n+\t\t<state readOnly=\"true\"/>\n+\t</channel-type>\n+\n+\t<!-- LastEventInvoker -->\n+\t<channel-type id=\"lastEventInvoker\">\n+\t\t<item-type>String</item-type>\n+\t\t<label>Alarm Last Event Invoker Channel</label>\n+\t\t<description>The last event invoker</description>\n+\t\t<state readOnly=\"true\"/>\n+\t</channel-type>\n+\n+\t<!-- LastEventTime -->\n+\t<channel-type id=\"lastEventTime\">\n+\t\t<item-type>DateTime</item-type>\n+\t\t<label>Alarm Last Event Time Channel</label>\n+\t\t<description>Date and time of the last event of your alarm</description>\n+\t\t<state readOnly=\"true\"/>\n+\t</channel-type>\n+\n+\t<!-- LastCheckTime -->\n+\t<channel-type id=\"lastCheckTime\">\n+\t\t<item-type>DateTime</item-type>\n+\t\t<label>Alarm Last Check Time Channel</label>\n+\t\t<description>Date and time of last status check of your alarm</description>\n+\t\t<state readOnly=\"true\"/>\n+\t</channel-type>\n+\n+\t<!-- alarm_state -->\n+\t<channel-type id=\"alarm_state\">\n+\t\t<item-type>String</item-type>\n+\t\t<label>Alarm state</label>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mjk0MDY2OA=="}, "originalCommit": {"oid": "36775963f2d1f6fd1e9689f06b070bfa8e6a859e"}, "originalPosition": 124}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAxOTU3ODg0OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.jablotron/pom.xml", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wM1QxMjozNDozOVrOHMkfGg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNlQyMDoyMToxN1rOHNru-A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mjk0Mjc0Ng==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    <version>2.5.8-SNAPSHOT</version>\n          \n          \n            \n                    <version>2.5.9-SNAPSHOT</version>", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r482942746", "createdAt": "2020-09-03T12:34:39Z", "author": {"login": "Hilbrand"}, "path": "bundles/org.openhab.binding.jablotron/pom.xml", "diffHunk": "@@ -0,0 +1,18 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<project xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns=\"http://maven.apache.org/POM/4.0.0\"\n+         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd\">\n+\n+    <modelVersion>4.0.0</modelVersion>\n+\n+    <parent>\n+        <groupId>org.openhab.addons.bundles</groupId>\n+        <artifactId>org.openhab.addons.reactor.bundles</artifactId>\n+        <version>2.5.8-SNAPSHOT</version>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "36775963f2d1f6fd1e9689f06b070bfa8e6a859e"}, "originalPosition": 10}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDExMDA3Mg==", "bodyText": "updated the version", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r484110072", "createdAt": "2020-09-06T20:21:17Z", "author": {"login": "octa22"}, "path": "bundles/org.openhab.binding.jablotron/pom.xml", "diffHunk": "@@ -0,0 +1,18 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<project xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns=\"http://maven.apache.org/POM/4.0.0\"\n+         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd\">\n+\n+    <modelVersion>4.0.0</modelVersion>\n+\n+    <parent>\n+        <groupId>org.openhab.addons.bundles</groupId>\n+        <artifactId>org.openhab.addons.reactor.bundles</artifactId>\n+        <version>2.5.8-SNAPSHOT</version>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mjk0Mjc0Ng=="}, "originalCommit": {"oid": "36775963f2d1f6fd1e9689f06b070bfa8e6a859e"}, "originalPosition": 10}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAxOTYyMjI4OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.jablotron/src/main/java/org/openhab/binding/jablotron/internal/JablotronHandlerFactory.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wM1QxMjo0NjowNVrOHMk5xA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNlQyMjo1Njo0NlrOHNskGA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mjk0OTU3Mg==", "bodyText": "Can you implement registration of a bridge bound discovery as a ThingHandlerService. See this preview documentation on how that works: https://deploy-preview-1262--openhab-docs-preview.netlify.app/docs/developer/bindings/#discovery-that-is-bound-to-a-thing", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r482949572", "createdAt": "2020-09-03T12:46:05Z", "author": {"login": "Hilbrand"}, "path": "bundles/org.openhab.binding.jablotron/src/main/java/org/openhab/binding/jablotron/internal/JablotronHandlerFactory.java", "diffHunk": "@@ -0,0 +1,107 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.jablotron.internal;\n+\n+import static org.openhab.binding.jablotron.JablotronBindingConstants.*;\n+\n+import java.util.*;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.config.discovery.DiscoveryService;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.thing.ThingUID;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandlerFactory;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerFactory;\n+import org.eclipse.smarthome.io.net.http.HttpClientFactory;\n+import org.openhab.binding.jablotron.internal.discovery.JablotronDiscoveryService;\n+import org.openhab.binding.jablotron.internal.handler.JablotronBridgeHandler;\n+import org.openhab.binding.jablotron.internal.handler.JablotronJa100FHandler;\n+import org.openhab.binding.jablotron.internal.handler.JablotronJa100Handler;\n+import org.openhab.binding.jablotron.internal.handler.JablotronOasisHandler;\n+import org.osgi.framework.ServiceRegistration;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Reference;\n+\n+/**\n+ * The {@link JablotronHandlerFactory} is responsible for creating things and thing\n+ * handlers.\n+ *\n+ * @author Ondrej Pecta - Initial contribution\n+ */\n+@NonNullByDefault\n+@Component(service = ThingHandlerFactory.class, immediate = true)\n+public class JablotronHandlerFactory extends BaseThingHandlerFactory {\n+\n+    private Map<ThingUID, ServiceRegistration<?>> discoveryServiceRegs = new HashMap<>();\n+    private final HttpClientFactory httpClientFactory;\n+\n+    @Activate\n+    public JablotronHandlerFactory(@Reference HttpClientFactory httpClientFactory) {\n+        this.httpClientFactory = httpClientFactory;\n+    }\n+\n+    @Override\n+    public boolean supportsThingType(ThingTypeUID thingTypeUID) {\n+        return THING_TYPE_BRIDGE.equals(thingTypeUID) || SUPPORTED_THING_TYPES_UIDS.contains(thingTypeUID);\n+    }\n+\n+    @Override\n+    protected @Nullable ThingHandler createHandler(Thing thing) {\n+        ThingTypeUID thingTypeUID = thing.getThingTypeUID();\n+\n+        if (thingTypeUID.equals(THING_TYPE_BRIDGE)) {\n+            JablotronBridgeHandler handler = new JablotronBridgeHandler((Bridge) thing, httpClientFactory.getCommonHttpClient());\n+            registerItemDiscoveryService(handler);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "36775963f2d1f6fd1e9689f06b070bfa8e6a859e"}, "originalPosition": 69}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDEyMzY3Mg==", "bodyText": "ok, done", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r484123672", "createdAt": "2020-09-06T22:56:46Z", "author": {"login": "octa22"}, "path": "bundles/org.openhab.binding.jablotron/src/main/java/org/openhab/binding/jablotron/internal/JablotronHandlerFactory.java", "diffHunk": "@@ -0,0 +1,107 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.jablotron.internal;\n+\n+import static org.openhab.binding.jablotron.JablotronBindingConstants.*;\n+\n+import java.util.*;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.config.discovery.DiscoveryService;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.thing.ThingUID;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandlerFactory;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerFactory;\n+import org.eclipse.smarthome.io.net.http.HttpClientFactory;\n+import org.openhab.binding.jablotron.internal.discovery.JablotronDiscoveryService;\n+import org.openhab.binding.jablotron.internal.handler.JablotronBridgeHandler;\n+import org.openhab.binding.jablotron.internal.handler.JablotronJa100FHandler;\n+import org.openhab.binding.jablotron.internal.handler.JablotronJa100Handler;\n+import org.openhab.binding.jablotron.internal.handler.JablotronOasisHandler;\n+import org.osgi.framework.ServiceRegistration;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Reference;\n+\n+/**\n+ * The {@link JablotronHandlerFactory} is responsible for creating things and thing\n+ * handlers.\n+ *\n+ * @author Ondrej Pecta - Initial contribution\n+ */\n+@NonNullByDefault\n+@Component(service = ThingHandlerFactory.class, immediate = true)\n+public class JablotronHandlerFactory extends BaseThingHandlerFactory {\n+\n+    private Map<ThingUID, ServiceRegistration<?>> discoveryServiceRegs = new HashMap<>();\n+    private final HttpClientFactory httpClientFactory;\n+\n+    @Activate\n+    public JablotronHandlerFactory(@Reference HttpClientFactory httpClientFactory) {\n+        this.httpClientFactory = httpClientFactory;\n+    }\n+\n+    @Override\n+    public boolean supportsThingType(ThingTypeUID thingTypeUID) {\n+        return THING_TYPE_BRIDGE.equals(thingTypeUID) || SUPPORTED_THING_TYPES_UIDS.contains(thingTypeUID);\n+    }\n+\n+    @Override\n+    protected @Nullable ThingHandler createHandler(Thing thing) {\n+        ThingTypeUID thingTypeUID = thing.getThingTypeUID();\n+\n+        if (thingTypeUID.equals(THING_TYPE_BRIDGE)) {\n+            JablotronBridgeHandler handler = new JablotronBridgeHandler((Bridge) thing, httpClientFactory.getCommonHttpClient());\n+            registerItemDiscoveryService(handler);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mjk0OTU3Mg=="}, "originalCommit": {"oid": "36775963f2d1f6fd1e9689f06b070bfa8e6a859e"}, "originalPosition": 69}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAxOTYyNTUwOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.jablotron/src/main/java/org/openhab/binding/jablotron/internal/discovery/JablotronDiscoveryService.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wM1QxMjo0Njo0OVrOHMk7nQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNlQyMTo0NzoyNlrOHNsL2Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mjk1MDA0NQ==", "bodyText": "static final should be above other fields.", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r482950045", "createdAt": "2020-09-03T12:46:49Z", "author": {"login": "Hilbrand"}, "path": "bundles/org.openhab.binding.jablotron/src/main/java/org/openhab/binding/jablotron/internal/discovery/JablotronDiscoveryService.java", "diffHunk": "@@ -0,0 +1,175 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.jablotron.internal.discovery;\n+\n+import static org.openhab.binding.jablotron.JablotronBindingConstants.*;\n+\n+import java.util.*;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.config.discovery.AbstractDiscoveryService;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResultBuilder;\n+import org.eclipse.smarthome.config.discovery.DiscoveryServiceCallback;\n+import org.eclipse.smarthome.config.discovery.ExtendedDiscoveryService;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.thing.ThingUID;\n+import org.openhab.binding.jablotron.internal.handler.JablotronBridgeHandler;\n+import org.openhab.binding.jablotron.internal.model.JablotronDiscoveredService;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Deactivate;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link JablotronDiscoveryService} is responsible for the thing discovery\n+ * process.\n+ *\n+ * @author Ondrej Pecta - Initial contribution\n+ */\n+@NonNullByDefault\n+public class JablotronDiscoveryService extends AbstractDiscoveryService implements ExtendedDiscoveryService {\n+    private final Logger logger = LoggerFactory.getLogger(JablotronDiscoveryService.class);\n+    private JablotronBridgeHandler bridge;\n+    private @Nullable DiscoveryServiceCallback discoveryServiceCallback;\n+\n+    private @Nullable ScheduledFuture<?> discoveryJob = null;\n+\n+    private static final int DISCOVERY_TIMEOUT_SEC = 10;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "36775963f2d1f6fd1e9689f06b070bfa8e6a859e"}, "originalPosition": 51}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDExNzQ2NQ==", "bodyText": "moved to JablotronBindingConstants class", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r484117465", "createdAt": "2020-09-06T21:47:26Z", "author": {"login": "octa22"}, "path": "bundles/org.openhab.binding.jablotron/src/main/java/org/openhab/binding/jablotron/internal/discovery/JablotronDiscoveryService.java", "diffHunk": "@@ -0,0 +1,175 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.jablotron.internal.discovery;\n+\n+import static org.openhab.binding.jablotron.JablotronBindingConstants.*;\n+\n+import java.util.*;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.config.discovery.AbstractDiscoveryService;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResultBuilder;\n+import org.eclipse.smarthome.config.discovery.DiscoveryServiceCallback;\n+import org.eclipse.smarthome.config.discovery.ExtendedDiscoveryService;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.thing.ThingUID;\n+import org.openhab.binding.jablotron.internal.handler.JablotronBridgeHandler;\n+import org.openhab.binding.jablotron.internal.model.JablotronDiscoveredService;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Deactivate;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link JablotronDiscoveryService} is responsible for the thing discovery\n+ * process.\n+ *\n+ * @author Ondrej Pecta - Initial contribution\n+ */\n+@NonNullByDefault\n+public class JablotronDiscoveryService extends AbstractDiscoveryService implements ExtendedDiscoveryService {\n+    private final Logger logger = LoggerFactory.getLogger(JablotronDiscoveryService.class);\n+    private JablotronBridgeHandler bridge;\n+    private @Nullable DiscoveryServiceCallback discoveryServiceCallback;\n+\n+    private @Nullable ScheduledFuture<?> discoveryJob = null;\n+\n+    private static final int DISCOVERY_TIMEOUT_SEC = 10;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mjk1MDA0NQ=="}, "originalCommit": {"oid": "36775963f2d1f6fd1e9689f06b070bfa8e6a859e"}, "originalPosition": 51}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAxOTYzMDUxOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.jablotron/src/main/java/org/openhab/binding/jablotron/internal/discovery/JablotronDiscoveryService.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wM1QxMjo0ODoxM1rOHMk-zw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNlQyMTo0NTozOVrOHNsLUg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mjk1MDg2Mw==", "bodyText": "Can you catch the specific exception.", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r482950863", "createdAt": "2020-09-03T12:48:13Z", "author": {"login": "Hilbrand"}, "path": "bundles/org.openhab.binding.jablotron/src/main/java/org/openhab/binding/jablotron/internal/discovery/JablotronDiscoveryService.java", "diffHunk": "@@ -0,0 +1,175 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.jablotron.internal.discovery;\n+\n+import static org.openhab.binding.jablotron.JablotronBindingConstants.*;\n+\n+import java.util.*;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.config.discovery.AbstractDiscoveryService;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResultBuilder;\n+import org.eclipse.smarthome.config.discovery.DiscoveryServiceCallback;\n+import org.eclipse.smarthome.config.discovery.ExtendedDiscoveryService;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.thing.ThingUID;\n+import org.openhab.binding.jablotron.internal.handler.JablotronBridgeHandler;\n+import org.openhab.binding.jablotron.internal.model.JablotronDiscoveredService;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Deactivate;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link JablotronDiscoveryService} is responsible for the thing discovery\n+ * process.\n+ *\n+ * @author Ondrej Pecta - Initial contribution\n+ */\n+@NonNullByDefault\n+public class JablotronDiscoveryService extends AbstractDiscoveryService implements ExtendedDiscoveryService {\n+    private final Logger logger = LoggerFactory.getLogger(JablotronDiscoveryService.class);\n+    private JablotronBridgeHandler bridge;\n+    private @Nullable DiscoveryServiceCallback discoveryServiceCallback;\n+\n+    private @Nullable ScheduledFuture<?> discoveryJob = null;\n+\n+    private static final int DISCOVERY_TIMEOUT_SEC = 10;\n+\n+    public JablotronDiscoveryService(JablotronBridgeHandler bridgeHandler) {\n+        super(DISCOVERY_TIMEOUT_SEC);\n+        logger.debug(\"Creating discovery service\");\n+        this.bridge = bridgeHandler;\n+    }\n+\n+    private void startDiscovery() {\n+        if (this.bridge.getThing().getStatus() == ThingStatus.ONLINE) {\n+            discoverServices();\n+        }\n+    }\n+\n+    @Override\n+    protected void stopBackgroundDiscovery() {\n+        super.stopBackgroundDiscovery();\n+        if (discoveryJob != null) {\n+            discoveryJob.cancel(true);\n+        }\n+    }\n+\n+    @Override\n+    protected void startBackgroundDiscovery() {\n+        logger.debug(\"Starting Jablotron background discovery\");\n+\n+        if (discoveryJob == null || discoveryJob.isCancelled()) {\n+            discoveryJob = scheduler.scheduleWithFixedDelay(this::startDiscovery, 10, 3600,\n+                    TimeUnit.SECONDS);\n+        }\n+    }\n+\n+    /**\n+     * Called on component activation.\n+     */\n+    @Override\n+    @Activate\n+    public void activate(@Nullable Map<String, @Nullable Object> configProperties) {\n+        super.activate(configProperties);\n+    }\n+\n+    @Deactivate\n+    @Override\n+    public void deactivate() {\n+        super.deactivate();\n+        if (discoveryJob != null) {\n+            discoveryJob.cancel(true);\n+        }\n+    }\n+\n+    @Override\n+    public Set<ThingTypeUID> getSupportedThingTypes() {\n+        return SUPPORTED_THING_TYPES_UIDS;\n+    }\n+\n+    @Override\n+    public void setDiscoveryServiceCallback(DiscoveryServiceCallback discoveryServiceCallback) {\n+        this.discoveryServiceCallback = discoveryServiceCallback;\n+    }\n+\n+    @Override\n+    protected void startScan() {\n+        logger.debug(\"Starting scanning for items...\");\n+        startDiscovery();\n+    }\n+\n+    public void oasisDiscovered(String label, String serviceId) {\n+        ThingUID thingUID = new ThingUID(THING_TYPE_OASIS, bridge.getThing().getUID(), serviceId);\n+\n+        logger.debug(\"Detected an OASIS alarm with service id: {}\", serviceId);\n+        thingDiscovered(\n+                DiscoveryResultBuilder.create(thingUID).withThingType(THING_TYPE_OASIS)\n+                        .withLabel(label)\n+                        .withBridge(bridge.getThing().getUID()).build());\n+    }\n+\n+    public void ja100Discovered(String label, String serviceId) {\n+        ThingUID thingUID = new ThingUID(THING_TYPE_JA100, bridge.getThing().getUID(), serviceId);\n+\n+        logger.debug(\"Detected a JA100 alarm with service id: {}\", serviceId);\n+        thingDiscovered(\n+                DiscoveryResultBuilder.create(thingUID).withThingType(THING_TYPE_JA100)\n+                        .withLabel(label)\n+                        .withBridge(bridge.getThing().getUID()).build());\n+    }\n+\n+    public void ja100fDiscovered(String label, String serviceId) {\n+        ThingUID thingUID = new ThingUID(THING_TYPE_JA100F, bridge.getThing().getUID(), serviceId);\n+\n+        logger.debug(\"Detected a JA100+ alarm with service id: {}\", serviceId);\n+        thingDiscovered(\n+                DiscoveryResultBuilder.create(thingUID).withThingType(THING_TYPE_JA100F)\n+                        .withLabel(label)\n+                        .withBridge(bridge.getThing().getUID()).build());\n+    }\n+\n+    private synchronized void discoverServices() {\n+        try {\n+            List<JablotronDiscoveredService> services = bridge.discoverServices();\n+\n+            if (services == null || services.size() == 0) {\n+                logger.info(\"Cannot find any Jablotron device\");\n+                return;\n+            }\n+\n+            for (JablotronDiscoveredService service : services) {\n+                String serviceId = String.valueOf(service.getId());\n+                logger.debug(\"Found Jablotron service: {} id: {}\", service.getName(), serviceId);\n+\n+                String serviceType = service.getServiceType().toLowerCase();\n+                if (serviceType.equals(THING_TYPE_OASIS.getId())) {\n+                    oasisDiscovered(\"Jablotron OASIS Alarm : \" + service.getName(), serviceId);\n+                } else if (serviceType.equals(THING_TYPE_JA100.getId())) {\n+                    ja100Discovered(\"Jablotron JA100 Alarm : \" + service.getName(), serviceId);\n+                } else if (serviceType.equals(THING_TYPE_JA100F.getId())) {\n+                    ja100fDiscovered(\"Jablotron JA100+ Alarm : \" + service.getName(), serviceId);\n+                } else {\n+                    logger.info(\"Unsupported device type discovered: {} with serviceId: {} and type: {}\", service.getName(), serviceId, service.getServiceType());\n+                }\n+            }\n+        } catch (Exception ex) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "36775963f2d1f6fd1e9689f06b070bfa8e6a859e"}, "originalPosition": 171}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDExNzMzMA==", "bodyText": "removed, not necessary to catch the generic exception", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r484117330", "createdAt": "2020-09-06T21:45:39Z", "author": {"login": "octa22"}, "path": "bundles/org.openhab.binding.jablotron/src/main/java/org/openhab/binding/jablotron/internal/discovery/JablotronDiscoveryService.java", "diffHunk": "@@ -0,0 +1,175 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.jablotron.internal.discovery;\n+\n+import static org.openhab.binding.jablotron.JablotronBindingConstants.*;\n+\n+import java.util.*;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.config.discovery.AbstractDiscoveryService;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResultBuilder;\n+import org.eclipse.smarthome.config.discovery.DiscoveryServiceCallback;\n+import org.eclipse.smarthome.config.discovery.ExtendedDiscoveryService;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.thing.ThingUID;\n+import org.openhab.binding.jablotron.internal.handler.JablotronBridgeHandler;\n+import org.openhab.binding.jablotron.internal.model.JablotronDiscoveredService;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Deactivate;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link JablotronDiscoveryService} is responsible for the thing discovery\n+ * process.\n+ *\n+ * @author Ondrej Pecta - Initial contribution\n+ */\n+@NonNullByDefault\n+public class JablotronDiscoveryService extends AbstractDiscoveryService implements ExtendedDiscoveryService {\n+    private final Logger logger = LoggerFactory.getLogger(JablotronDiscoveryService.class);\n+    private JablotronBridgeHandler bridge;\n+    private @Nullable DiscoveryServiceCallback discoveryServiceCallback;\n+\n+    private @Nullable ScheduledFuture<?> discoveryJob = null;\n+\n+    private static final int DISCOVERY_TIMEOUT_SEC = 10;\n+\n+    public JablotronDiscoveryService(JablotronBridgeHandler bridgeHandler) {\n+        super(DISCOVERY_TIMEOUT_SEC);\n+        logger.debug(\"Creating discovery service\");\n+        this.bridge = bridgeHandler;\n+    }\n+\n+    private void startDiscovery() {\n+        if (this.bridge.getThing().getStatus() == ThingStatus.ONLINE) {\n+            discoverServices();\n+        }\n+    }\n+\n+    @Override\n+    protected void stopBackgroundDiscovery() {\n+        super.stopBackgroundDiscovery();\n+        if (discoveryJob != null) {\n+            discoveryJob.cancel(true);\n+        }\n+    }\n+\n+    @Override\n+    protected void startBackgroundDiscovery() {\n+        logger.debug(\"Starting Jablotron background discovery\");\n+\n+        if (discoveryJob == null || discoveryJob.isCancelled()) {\n+            discoveryJob = scheduler.scheduleWithFixedDelay(this::startDiscovery, 10, 3600,\n+                    TimeUnit.SECONDS);\n+        }\n+    }\n+\n+    /**\n+     * Called on component activation.\n+     */\n+    @Override\n+    @Activate\n+    public void activate(@Nullable Map<String, @Nullable Object> configProperties) {\n+        super.activate(configProperties);\n+    }\n+\n+    @Deactivate\n+    @Override\n+    public void deactivate() {\n+        super.deactivate();\n+        if (discoveryJob != null) {\n+            discoveryJob.cancel(true);\n+        }\n+    }\n+\n+    @Override\n+    public Set<ThingTypeUID> getSupportedThingTypes() {\n+        return SUPPORTED_THING_TYPES_UIDS;\n+    }\n+\n+    @Override\n+    public void setDiscoveryServiceCallback(DiscoveryServiceCallback discoveryServiceCallback) {\n+        this.discoveryServiceCallback = discoveryServiceCallback;\n+    }\n+\n+    @Override\n+    protected void startScan() {\n+        logger.debug(\"Starting scanning for items...\");\n+        startDiscovery();\n+    }\n+\n+    public void oasisDiscovered(String label, String serviceId) {\n+        ThingUID thingUID = new ThingUID(THING_TYPE_OASIS, bridge.getThing().getUID(), serviceId);\n+\n+        logger.debug(\"Detected an OASIS alarm with service id: {}\", serviceId);\n+        thingDiscovered(\n+                DiscoveryResultBuilder.create(thingUID).withThingType(THING_TYPE_OASIS)\n+                        .withLabel(label)\n+                        .withBridge(bridge.getThing().getUID()).build());\n+    }\n+\n+    public void ja100Discovered(String label, String serviceId) {\n+        ThingUID thingUID = new ThingUID(THING_TYPE_JA100, bridge.getThing().getUID(), serviceId);\n+\n+        logger.debug(\"Detected a JA100 alarm with service id: {}\", serviceId);\n+        thingDiscovered(\n+                DiscoveryResultBuilder.create(thingUID).withThingType(THING_TYPE_JA100)\n+                        .withLabel(label)\n+                        .withBridge(bridge.getThing().getUID()).build());\n+    }\n+\n+    public void ja100fDiscovered(String label, String serviceId) {\n+        ThingUID thingUID = new ThingUID(THING_TYPE_JA100F, bridge.getThing().getUID(), serviceId);\n+\n+        logger.debug(\"Detected a JA100+ alarm with service id: {}\", serviceId);\n+        thingDiscovered(\n+                DiscoveryResultBuilder.create(thingUID).withThingType(THING_TYPE_JA100F)\n+                        .withLabel(label)\n+                        .withBridge(bridge.getThing().getUID()).build());\n+    }\n+\n+    private synchronized void discoverServices() {\n+        try {\n+            List<JablotronDiscoveredService> services = bridge.discoverServices();\n+\n+            if (services == null || services.size() == 0) {\n+                logger.info(\"Cannot find any Jablotron device\");\n+                return;\n+            }\n+\n+            for (JablotronDiscoveredService service : services) {\n+                String serviceId = String.valueOf(service.getId());\n+                logger.debug(\"Found Jablotron service: {} id: {}\", service.getName(), serviceId);\n+\n+                String serviceType = service.getServiceType().toLowerCase();\n+                if (serviceType.equals(THING_TYPE_OASIS.getId())) {\n+                    oasisDiscovered(\"Jablotron OASIS Alarm : \" + service.getName(), serviceId);\n+                } else if (serviceType.equals(THING_TYPE_JA100.getId())) {\n+                    ja100Discovered(\"Jablotron JA100 Alarm : \" + service.getName(), serviceId);\n+                } else if (serviceType.equals(THING_TYPE_JA100F.getId())) {\n+                    ja100fDiscovered(\"Jablotron JA100+ Alarm : \" + service.getName(), serviceId);\n+                } else {\n+                    logger.info(\"Unsupported device type discovered: {} with serviceId: {} and type: {}\", service.getName(), serviceId, service.getServiceType());\n+                }\n+            }\n+        } catch (Exception ex) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mjk1MDg2Mw=="}, "originalCommit": {"oid": "36775963f2d1f6fd1e9689f06b070bfa8e6a859e"}, "originalPosition": 171}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAxOTYzMTIwOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.jablotron/src/main/java/org/openhab/binding/jablotron/internal/discovery/JablotronDiscoveryService.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wM1QxMjo0ODoyNlrOHMk_Rw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNlQyMTo0Mzo1OFrOHNsKqA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mjk1MDk4Mw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        if (services == null || services.size() == 0) {\n          \n          \n            \n                        if (services == null || services.isEmpty()) {", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r482950983", "createdAt": "2020-09-03T12:48:26Z", "author": {"login": "Hilbrand"}, "path": "bundles/org.openhab.binding.jablotron/src/main/java/org/openhab/binding/jablotron/internal/discovery/JablotronDiscoveryService.java", "diffHunk": "@@ -0,0 +1,175 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.jablotron.internal.discovery;\n+\n+import static org.openhab.binding.jablotron.JablotronBindingConstants.*;\n+\n+import java.util.*;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.config.discovery.AbstractDiscoveryService;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResultBuilder;\n+import org.eclipse.smarthome.config.discovery.DiscoveryServiceCallback;\n+import org.eclipse.smarthome.config.discovery.ExtendedDiscoveryService;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.thing.ThingUID;\n+import org.openhab.binding.jablotron.internal.handler.JablotronBridgeHandler;\n+import org.openhab.binding.jablotron.internal.model.JablotronDiscoveredService;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Deactivate;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link JablotronDiscoveryService} is responsible for the thing discovery\n+ * process.\n+ *\n+ * @author Ondrej Pecta - Initial contribution\n+ */\n+@NonNullByDefault\n+public class JablotronDiscoveryService extends AbstractDiscoveryService implements ExtendedDiscoveryService {\n+    private final Logger logger = LoggerFactory.getLogger(JablotronDiscoveryService.class);\n+    private JablotronBridgeHandler bridge;\n+    private @Nullable DiscoveryServiceCallback discoveryServiceCallback;\n+\n+    private @Nullable ScheduledFuture<?> discoveryJob = null;\n+\n+    private static final int DISCOVERY_TIMEOUT_SEC = 10;\n+\n+    public JablotronDiscoveryService(JablotronBridgeHandler bridgeHandler) {\n+        super(DISCOVERY_TIMEOUT_SEC);\n+        logger.debug(\"Creating discovery service\");\n+        this.bridge = bridgeHandler;\n+    }\n+\n+    private void startDiscovery() {\n+        if (this.bridge.getThing().getStatus() == ThingStatus.ONLINE) {\n+            discoverServices();\n+        }\n+    }\n+\n+    @Override\n+    protected void stopBackgroundDiscovery() {\n+        super.stopBackgroundDiscovery();\n+        if (discoveryJob != null) {\n+            discoveryJob.cancel(true);\n+        }\n+    }\n+\n+    @Override\n+    protected void startBackgroundDiscovery() {\n+        logger.debug(\"Starting Jablotron background discovery\");\n+\n+        if (discoveryJob == null || discoveryJob.isCancelled()) {\n+            discoveryJob = scheduler.scheduleWithFixedDelay(this::startDiscovery, 10, 3600,\n+                    TimeUnit.SECONDS);\n+        }\n+    }\n+\n+    /**\n+     * Called on component activation.\n+     */\n+    @Override\n+    @Activate\n+    public void activate(@Nullable Map<String, @Nullable Object> configProperties) {\n+        super.activate(configProperties);\n+    }\n+\n+    @Deactivate\n+    @Override\n+    public void deactivate() {\n+        super.deactivate();\n+        if (discoveryJob != null) {\n+            discoveryJob.cancel(true);\n+        }\n+    }\n+\n+    @Override\n+    public Set<ThingTypeUID> getSupportedThingTypes() {\n+        return SUPPORTED_THING_TYPES_UIDS;\n+    }\n+\n+    @Override\n+    public void setDiscoveryServiceCallback(DiscoveryServiceCallback discoveryServiceCallback) {\n+        this.discoveryServiceCallback = discoveryServiceCallback;\n+    }\n+\n+    @Override\n+    protected void startScan() {\n+        logger.debug(\"Starting scanning for items...\");\n+        startDiscovery();\n+    }\n+\n+    public void oasisDiscovered(String label, String serviceId) {\n+        ThingUID thingUID = new ThingUID(THING_TYPE_OASIS, bridge.getThing().getUID(), serviceId);\n+\n+        logger.debug(\"Detected an OASIS alarm with service id: {}\", serviceId);\n+        thingDiscovered(\n+                DiscoveryResultBuilder.create(thingUID).withThingType(THING_TYPE_OASIS)\n+                        .withLabel(label)\n+                        .withBridge(bridge.getThing().getUID()).build());\n+    }\n+\n+    public void ja100Discovered(String label, String serviceId) {\n+        ThingUID thingUID = new ThingUID(THING_TYPE_JA100, bridge.getThing().getUID(), serviceId);\n+\n+        logger.debug(\"Detected a JA100 alarm with service id: {}\", serviceId);\n+        thingDiscovered(\n+                DiscoveryResultBuilder.create(thingUID).withThingType(THING_TYPE_JA100)\n+                        .withLabel(label)\n+                        .withBridge(bridge.getThing().getUID()).build());\n+    }\n+\n+    public void ja100fDiscovered(String label, String serviceId) {\n+        ThingUID thingUID = new ThingUID(THING_TYPE_JA100F, bridge.getThing().getUID(), serviceId);\n+\n+        logger.debug(\"Detected a JA100+ alarm with service id: {}\", serviceId);\n+        thingDiscovered(\n+                DiscoveryResultBuilder.create(thingUID).withThingType(THING_TYPE_JA100F)\n+                        .withLabel(label)\n+                        .withBridge(bridge.getThing().getUID()).build());\n+    }\n+\n+    private synchronized void discoverServices() {\n+        try {\n+            List<JablotronDiscoveredService> services = bridge.discoverServices();\n+\n+            if (services == null || services.size() == 0) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "36775963f2d1f6fd1e9689f06b070bfa8e6a859e"}, "originalPosition": 151}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDExNzE2MA==", "bodyText": "ok", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r484117160", "createdAt": "2020-09-06T21:43:58Z", "author": {"login": "octa22"}, "path": "bundles/org.openhab.binding.jablotron/src/main/java/org/openhab/binding/jablotron/internal/discovery/JablotronDiscoveryService.java", "diffHunk": "@@ -0,0 +1,175 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.jablotron.internal.discovery;\n+\n+import static org.openhab.binding.jablotron.JablotronBindingConstants.*;\n+\n+import java.util.*;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.config.discovery.AbstractDiscoveryService;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResultBuilder;\n+import org.eclipse.smarthome.config.discovery.DiscoveryServiceCallback;\n+import org.eclipse.smarthome.config.discovery.ExtendedDiscoveryService;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.thing.ThingUID;\n+import org.openhab.binding.jablotron.internal.handler.JablotronBridgeHandler;\n+import org.openhab.binding.jablotron.internal.model.JablotronDiscoveredService;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Deactivate;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link JablotronDiscoveryService} is responsible for the thing discovery\n+ * process.\n+ *\n+ * @author Ondrej Pecta - Initial contribution\n+ */\n+@NonNullByDefault\n+public class JablotronDiscoveryService extends AbstractDiscoveryService implements ExtendedDiscoveryService {\n+    private final Logger logger = LoggerFactory.getLogger(JablotronDiscoveryService.class);\n+    private JablotronBridgeHandler bridge;\n+    private @Nullable DiscoveryServiceCallback discoveryServiceCallback;\n+\n+    private @Nullable ScheduledFuture<?> discoveryJob = null;\n+\n+    private static final int DISCOVERY_TIMEOUT_SEC = 10;\n+\n+    public JablotronDiscoveryService(JablotronBridgeHandler bridgeHandler) {\n+        super(DISCOVERY_TIMEOUT_SEC);\n+        logger.debug(\"Creating discovery service\");\n+        this.bridge = bridgeHandler;\n+    }\n+\n+    private void startDiscovery() {\n+        if (this.bridge.getThing().getStatus() == ThingStatus.ONLINE) {\n+            discoverServices();\n+        }\n+    }\n+\n+    @Override\n+    protected void stopBackgroundDiscovery() {\n+        super.stopBackgroundDiscovery();\n+        if (discoveryJob != null) {\n+            discoveryJob.cancel(true);\n+        }\n+    }\n+\n+    @Override\n+    protected void startBackgroundDiscovery() {\n+        logger.debug(\"Starting Jablotron background discovery\");\n+\n+        if (discoveryJob == null || discoveryJob.isCancelled()) {\n+            discoveryJob = scheduler.scheduleWithFixedDelay(this::startDiscovery, 10, 3600,\n+                    TimeUnit.SECONDS);\n+        }\n+    }\n+\n+    /**\n+     * Called on component activation.\n+     */\n+    @Override\n+    @Activate\n+    public void activate(@Nullable Map<String, @Nullable Object> configProperties) {\n+        super.activate(configProperties);\n+    }\n+\n+    @Deactivate\n+    @Override\n+    public void deactivate() {\n+        super.deactivate();\n+        if (discoveryJob != null) {\n+            discoveryJob.cancel(true);\n+        }\n+    }\n+\n+    @Override\n+    public Set<ThingTypeUID> getSupportedThingTypes() {\n+        return SUPPORTED_THING_TYPES_UIDS;\n+    }\n+\n+    @Override\n+    public void setDiscoveryServiceCallback(DiscoveryServiceCallback discoveryServiceCallback) {\n+        this.discoveryServiceCallback = discoveryServiceCallback;\n+    }\n+\n+    @Override\n+    protected void startScan() {\n+        logger.debug(\"Starting scanning for items...\");\n+        startDiscovery();\n+    }\n+\n+    public void oasisDiscovered(String label, String serviceId) {\n+        ThingUID thingUID = new ThingUID(THING_TYPE_OASIS, bridge.getThing().getUID(), serviceId);\n+\n+        logger.debug(\"Detected an OASIS alarm with service id: {}\", serviceId);\n+        thingDiscovered(\n+                DiscoveryResultBuilder.create(thingUID).withThingType(THING_TYPE_OASIS)\n+                        .withLabel(label)\n+                        .withBridge(bridge.getThing().getUID()).build());\n+    }\n+\n+    public void ja100Discovered(String label, String serviceId) {\n+        ThingUID thingUID = new ThingUID(THING_TYPE_JA100, bridge.getThing().getUID(), serviceId);\n+\n+        logger.debug(\"Detected a JA100 alarm with service id: {}\", serviceId);\n+        thingDiscovered(\n+                DiscoveryResultBuilder.create(thingUID).withThingType(THING_TYPE_JA100)\n+                        .withLabel(label)\n+                        .withBridge(bridge.getThing().getUID()).build());\n+    }\n+\n+    public void ja100fDiscovered(String label, String serviceId) {\n+        ThingUID thingUID = new ThingUID(THING_TYPE_JA100F, bridge.getThing().getUID(), serviceId);\n+\n+        logger.debug(\"Detected a JA100+ alarm with service id: {}\", serviceId);\n+        thingDiscovered(\n+                DiscoveryResultBuilder.create(thingUID).withThingType(THING_TYPE_JA100F)\n+                        .withLabel(label)\n+                        .withBridge(bridge.getThing().getUID()).build());\n+    }\n+\n+    private synchronized void discoverServices() {\n+        try {\n+            List<JablotronDiscoveredService> services = bridge.discoverServices();\n+\n+            if (services == null || services.size() == 0) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mjk1MDk4Mw=="}, "originalCommit": {"oid": "36775963f2d1f6fd1e9689f06b070bfa8e6a859e"}, "originalPosition": 151}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAxOTY0NDM2OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.jablotron/README.md", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wM1QxMjo1MTo0M1rOHMlHMQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNlQyMTo1MToyN1rOHNsNJg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mjk1MzAwOQ==", "bodyText": "This table seems to contains tabs. Can you format it. You can use http://markdowntable.com/", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r482953009", "createdAt": "2020-09-03T12:51:43Z", "author": {"login": "Hilbrand"}, "path": "bundles/org.openhab.binding.jablotron/README.md", "diffHunk": "@@ -0,0 +1,119 @@\n+# Jablotron Alarm Binding\n+\n+This is the OH2.x binding for Jablotron alarms.\n+https://www.jablotron.com/en/jablotron-products/alarms/\n+\n+## Supported Things\n+\n+| thing   | note                                      |\n+|---------|-------------------------------------------|\n+| bridge  | the bridge to your Jablonet cloud account |\n+| JA-80   | the OASIS alarm                           |\n+| JA-100  | with the thermometer support              |\n+| JA-100F | without the thermometer support           |\n+ \n+## Discovery\n+\n+This binding supports auto discovery. Just manually add a bridge thing and supply login & password to your Jablonet account.\n+\n+## Binding Configuration\n+\n+Binding itself doesn't require specific configuration.\n+\n+## Thing Configuration\n+\n+| thing                | config parameter name | description                                                                        | type                  |\n+|----------------------|-----------------------|------------------------------------------------------------------------------------|-----------------------|\n+| bridge               | login                 | the login to your Jablonet account                                                 | mandatory             |\n+| bridge               | password              | the password to your Jablonet account                                              | mandatory             |\n+| bridge               | refresh               | the refresh time for all alarm warnings (ALARM, TAMPER triggers and SERVICE state) | optional, default=30s |\n+| bridge               | lang                  | the language of the alarm texts                                                    | optional, default=en  |\n+| JA-80/JA-100/JA-100F | refresh               | the channels refresh period in seconds                                             | optional, default=60s |\n+| JA-100/JA-100F       | code                  | the master code for controlling sections                                           | optional              |\n+\n+## Channels\n+\n+| thing                | channel name     | description                                               |\n+|----------------------|------------------|-----------------------------------------------------------|\n+| bridge               | N/A              | the bridge does not expose any channels                   |\n+| JA-80                | statusA          | the status of the A section                                   |\n+| JA-80                | statusB          | the status of the AB/B section                                |\n+| JA-80                | statusABC        | the status of the ABC section                                 |", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "36775963f2d1f6fd1e9689f06b070bfa8e6a859e"}, "originalPosition": 41}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDExNzc5OA==", "bodyText": "done", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r484117798", "createdAt": "2020-09-06T21:51:27Z", "author": {"login": "octa22"}, "path": "bundles/org.openhab.binding.jablotron/README.md", "diffHunk": "@@ -0,0 +1,119 @@\n+# Jablotron Alarm Binding\n+\n+This is the OH2.x binding for Jablotron alarms.\n+https://www.jablotron.com/en/jablotron-products/alarms/\n+\n+## Supported Things\n+\n+| thing   | note                                      |\n+|---------|-------------------------------------------|\n+| bridge  | the bridge to your Jablonet cloud account |\n+| JA-80   | the OASIS alarm                           |\n+| JA-100  | with the thermometer support              |\n+| JA-100F | without the thermometer support           |\n+ \n+## Discovery\n+\n+This binding supports auto discovery. Just manually add a bridge thing and supply login & password to your Jablonet account.\n+\n+## Binding Configuration\n+\n+Binding itself doesn't require specific configuration.\n+\n+## Thing Configuration\n+\n+| thing                | config parameter name | description                                                                        | type                  |\n+|----------------------|-----------------------|------------------------------------------------------------------------------------|-----------------------|\n+| bridge               | login                 | the login to your Jablonet account                                                 | mandatory             |\n+| bridge               | password              | the password to your Jablonet account                                              | mandatory             |\n+| bridge               | refresh               | the refresh time for all alarm warnings (ALARM, TAMPER triggers and SERVICE state) | optional, default=30s |\n+| bridge               | lang                  | the language of the alarm texts                                                    | optional, default=en  |\n+| JA-80/JA-100/JA-100F | refresh               | the channels refresh period in seconds                                             | optional, default=60s |\n+| JA-100/JA-100F       | code                  | the master code for controlling sections                                           | optional              |\n+\n+## Channels\n+\n+| thing                | channel name     | description                                               |\n+|----------------------|------------------|-----------------------------------------------------------|\n+| bridge               | N/A              | the bridge does not expose any channels                   |\n+| JA-80                | statusA          | the status of the A section                                   |\n+| JA-80                | statusB          | the status of the AB/B section                                |\n+| JA-80                | statusABC        | the status of the ABC section                                 |", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mjk1MzAwOQ=="}, "originalCommit": {"oid": "36775963f2d1f6fd1e9689f06b070bfa8e6a859e"}, "originalPosition": 41}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAxOTY1ODg5OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.jablotron/src/main/java/org/openhab/binding/jablotron/internal/handler/JablotronAlarmHandler.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wM1QxMjo1NTowNVrOHMlQEQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNlQyMTozODo1MlrOHNsI_A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mjk1NTI4MQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    scheduler.execute(() -> {\n          \n          \n            \n                        doInit();\n          \n          \n            \n                    });\n          \n          \n            \n                    scheduler.execute(this::doInit);", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r482955281", "createdAt": "2020-09-03T12:55:05Z", "author": {"login": "Hilbrand"}, "path": "bundles/org.openhab.binding.jablotron/src/main/java/org/openhab/binding/jablotron/internal/handler/JablotronAlarmHandler.java", "diffHunk": "@@ -0,0 +1,221 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.jablotron.internal.handler;\n+\n+import static org.openhab.binding.jablotron.JablotronBindingConstants.*;\n+\n+import java.time.ZoneId;\n+import java.time.ZonedDateTime;\n+import java.time.format.DateTimeFormatter;\n+import java.util.Calendar;\n+import java.util.List;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import com.google.gson.Gson;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DateTimeType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.ThingStatusInfo;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.jablotron.internal.config.JablotronDeviceConfig;\n+import org.openhab.binding.jablotron.internal.model.*;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link JablotronAlarmHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Ondrej Pecta - Initial contribution\n+ */\n+@NonNullByDefault\n+public abstract class JablotronAlarmHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(JablotronAlarmHandler.class);\n+\n+    protected Gson gson = new Gson();\n+\n+    protected JablotronDeviceConfig thingConfig = new JablotronDeviceConfig();\n+\n+    private String lastWarningTime = \"\";\n+\n+    protected String alarmName = \"\";\n+\n+    private boolean inService = false;\n+\n+    @Nullable\n+    ScheduledFuture<?> future = null;\n+\n+    public JablotronAlarmHandler(Thing thing, String alarmName) {\n+        super(thing);\n+        this.alarmName = alarmName;\n+    }\n+\n+    @Override\n+    public void bridgeStatusChanged(ThingStatusInfo bridgeStatusInfo) {\n+        super.bridgeStatusChanged(bridgeStatusInfo);\n+        if (ThingStatus.UNINITIALIZED == bridgeStatusInfo.getStatus()) {\n+            cleanup();\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        super.dispose();\n+        cleanup();\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        thingConfig = getConfigAs(JablotronDeviceConfig.class);\n+        scheduler.execute(() -> {\n+            doInit();\n+        });", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "36775963f2d1f6fd1e9689f06b070bfa8e6a859e"}, "originalPosition": 89}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDExNjczMg==", "bodyText": "ok", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r484116732", "createdAt": "2020-09-06T21:38:52Z", "author": {"login": "octa22"}, "path": "bundles/org.openhab.binding.jablotron/src/main/java/org/openhab/binding/jablotron/internal/handler/JablotronAlarmHandler.java", "diffHunk": "@@ -0,0 +1,221 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.jablotron.internal.handler;\n+\n+import static org.openhab.binding.jablotron.JablotronBindingConstants.*;\n+\n+import java.time.ZoneId;\n+import java.time.ZonedDateTime;\n+import java.time.format.DateTimeFormatter;\n+import java.util.Calendar;\n+import java.util.List;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import com.google.gson.Gson;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DateTimeType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.ThingStatusInfo;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.jablotron.internal.config.JablotronDeviceConfig;\n+import org.openhab.binding.jablotron.internal.model.*;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link JablotronAlarmHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Ondrej Pecta - Initial contribution\n+ */\n+@NonNullByDefault\n+public abstract class JablotronAlarmHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(JablotronAlarmHandler.class);\n+\n+    protected Gson gson = new Gson();\n+\n+    protected JablotronDeviceConfig thingConfig = new JablotronDeviceConfig();\n+\n+    private String lastWarningTime = \"\";\n+\n+    protected String alarmName = \"\";\n+\n+    private boolean inService = false;\n+\n+    @Nullable\n+    ScheduledFuture<?> future = null;\n+\n+    public JablotronAlarmHandler(Thing thing, String alarmName) {\n+        super(thing);\n+        this.alarmName = alarmName;\n+    }\n+\n+    @Override\n+    public void bridgeStatusChanged(ThingStatusInfo bridgeStatusInfo) {\n+        super.bridgeStatusChanged(bridgeStatusInfo);\n+        if (ThingStatus.UNINITIALIZED == bridgeStatusInfo.getStatus()) {\n+            cleanup();\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        super.dispose();\n+        cleanup();\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        thingConfig = getConfigAs(JablotronDeviceConfig.class);\n+        scheduler.execute(() -> {\n+            doInit();\n+        });", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mjk1NTI4MQ=="}, "originalCommit": {"oid": "36775963f2d1f6fd1e9689f06b070bfa8e6a859e"}, "originalPosition": 89}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAxOTY2MTEwOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.jablotron/src/main/java/org/openhab/binding/jablotron/internal/handler/JablotronAlarmHandler.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wM1QxMjo1NTozOVrOHMlReQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNlQyMTo0ODo0MVrOHNsMOQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mjk1NTY0MQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                @Nullable\n          \n          \n            \n                ScheduledFuture<?> future = null;\n          \n          \n            \n                @Nullable ScheduledFuture<?> future = null;\n          \n      \n    \n    \n  \n\nprotected?", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r482955641", "createdAt": "2020-09-03T12:55:39Z", "author": {"login": "Hilbrand"}, "path": "bundles/org.openhab.binding.jablotron/src/main/java/org/openhab/binding/jablotron/internal/handler/JablotronAlarmHandler.java", "diffHunk": "@@ -0,0 +1,221 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.jablotron.internal.handler;\n+\n+import static org.openhab.binding.jablotron.JablotronBindingConstants.*;\n+\n+import java.time.ZoneId;\n+import java.time.ZonedDateTime;\n+import java.time.format.DateTimeFormatter;\n+import java.util.Calendar;\n+import java.util.List;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import com.google.gson.Gson;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DateTimeType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.ThingStatusInfo;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.jablotron.internal.config.JablotronDeviceConfig;\n+import org.openhab.binding.jablotron.internal.model.*;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link JablotronAlarmHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Ondrej Pecta - Initial contribution\n+ */\n+@NonNullByDefault\n+public abstract class JablotronAlarmHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(JablotronAlarmHandler.class);\n+\n+    protected Gson gson = new Gson();\n+\n+    protected JablotronDeviceConfig thingConfig = new JablotronDeviceConfig();\n+\n+    private String lastWarningTime = \"\";\n+\n+    protected String alarmName = \"\";\n+\n+    private boolean inService = false;\n+\n+    @Nullable\n+    ScheduledFuture<?> future = null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "36775963f2d1f6fd1e9689f06b070bfa8e6a859e"}, "originalPosition": 63}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDExNzU2MQ==", "bodyText": "fixed", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r484117561", "createdAt": "2020-09-06T21:48:41Z", "author": {"login": "octa22"}, "path": "bundles/org.openhab.binding.jablotron/src/main/java/org/openhab/binding/jablotron/internal/handler/JablotronAlarmHandler.java", "diffHunk": "@@ -0,0 +1,221 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.jablotron.internal.handler;\n+\n+import static org.openhab.binding.jablotron.JablotronBindingConstants.*;\n+\n+import java.time.ZoneId;\n+import java.time.ZonedDateTime;\n+import java.time.format.DateTimeFormatter;\n+import java.util.Calendar;\n+import java.util.List;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import com.google.gson.Gson;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DateTimeType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.ThingStatusInfo;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.jablotron.internal.config.JablotronDeviceConfig;\n+import org.openhab.binding.jablotron.internal.model.*;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link JablotronAlarmHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Ondrej Pecta - Initial contribution\n+ */\n+@NonNullByDefault\n+public abstract class JablotronAlarmHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(JablotronAlarmHandler.class);\n+\n+    protected Gson gson = new Gson();\n+\n+    protected JablotronDeviceConfig thingConfig = new JablotronDeviceConfig();\n+\n+    private String lastWarningTime = \"\";\n+\n+    protected String alarmName = \"\";\n+\n+    private boolean inService = false;\n+\n+    @Nullable\n+    ScheduledFuture<?> future = null;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mjk1NTY0MQ=="}, "originalCommit": {"oid": "36775963f2d1f6fd1e9689f06b070bfa8e6a859e"}, "originalPosition": 63}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAxOTY2MzE3OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.jablotron/src/main/java/org/openhab/binding/jablotron/internal/handler/JablotronAlarmHandler.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wM1QxMjo1NjowOVrOHMlSyA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNlQyMTozOToyNVrOHNsJMg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mjk1NTk3Ng==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                protected Gson gson = new Gson();\n          \n          \n            \n                protected final Gson gson = new Gson();", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r482955976", "createdAt": "2020-09-03T12:56:09Z", "author": {"login": "Hilbrand"}, "path": "bundles/org.openhab.binding.jablotron/src/main/java/org/openhab/binding/jablotron/internal/handler/JablotronAlarmHandler.java", "diffHunk": "@@ -0,0 +1,221 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.jablotron.internal.handler;\n+\n+import static org.openhab.binding.jablotron.JablotronBindingConstants.*;\n+\n+import java.time.ZoneId;\n+import java.time.ZonedDateTime;\n+import java.time.format.DateTimeFormatter;\n+import java.util.Calendar;\n+import java.util.List;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import com.google.gson.Gson;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DateTimeType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.ThingStatusInfo;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.jablotron.internal.config.JablotronDeviceConfig;\n+import org.openhab.binding.jablotron.internal.model.*;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link JablotronAlarmHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Ondrej Pecta - Initial contribution\n+ */\n+@NonNullByDefault\n+public abstract class JablotronAlarmHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(JablotronAlarmHandler.class);\n+\n+    protected Gson gson = new Gson();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "36775963f2d1f6fd1e9689f06b070bfa8e6a859e"}, "originalPosition": 52}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDExNjc4Ng==", "bodyText": "made final", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r484116786", "createdAt": "2020-09-06T21:39:25Z", "author": {"login": "octa22"}, "path": "bundles/org.openhab.binding.jablotron/src/main/java/org/openhab/binding/jablotron/internal/handler/JablotronAlarmHandler.java", "diffHunk": "@@ -0,0 +1,221 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.jablotron.internal.handler;\n+\n+import static org.openhab.binding.jablotron.JablotronBindingConstants.*;\n+\n+import java.time.ZoneId;\n+import java.time.ZonedDateTime;\n+import java.time.format.DateTimeFormatter;\n+import java.util.Calendar;\n+import java.util.List;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import com.google.gson.Gson;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DateTimeType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.ThingStatusInfo;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.jablotron.internal.config.JablotronDeviceConfig;\n+import org.openhab.binding.jablotron.internal.model.*;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link JablotronAlarmHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Ondrej Pecta - Initial contribution\n+ */\n+@NonNullByDefault\n+public abstract class JablotronAlarmHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(JablotronAlarmHandler.class);\n+\n+    protected Gson gson = new Gson();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mjk1NTk3Ng=="}, "originalCommit": {"oid": "36775963f2d1f6fd1e9689f06b070bfa8e6a859e"}, "originalPosition": 52}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAyMjY4OTE5OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.jablotron/src/main/java/org/openhab/binding/jablotron/internal/discovery/JablotronDiscoveryService.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNFQwNzowMToyN1rOHNCB4A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNlQyMjo1NzowOVrOHNskPg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzQyNjc4NA==", "bodyText": "It this needed?", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r483426784", "createdAt": "2020-09-04T07:01:27Z", "author": {"login": "Hilbrand"}, "path": "bundles/org.openhab.binding.jablotron/src/main/java/org/openhab/binding/jablotron/internal/discovery/JablotronDiscoveryService.java", "diffHunk": "@@ -0,0 +1,175 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.jablotron.internal.discovery;\n+\n+import static org.openhab.binding.jablotron.JablotronBindingConstants.*;\n+\n+import java.util.*;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.config.discovery.AbstractDiscoveryService;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResultBuilder;\n+import org.eclipse.smarthome.config.discovery.DiscoveryServiceCallback;\n+import org.eclipse.smarthome.config.discovery.ExtendedDiscoveryService;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.thing.ThingUID;\n+import org.openhab.binding.jablotron.internal.handler.JablotronBridgeHandler;\n+import org.openhab.binding.jablotron.internal.model.JablotronDiscoveredService;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Deactivate;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link JablotronDiscoveryService} is responsible for the thing discovery\n+ * process.\n+ *\n+ * @author Ondrej Pecta - Initial contribution\n+ */\n+@NonNullByDefault\n+public class JablotronDiscoveryService extends AbstractDiscoveryService implements ExtendedDiscoveryService {\n+    private final Logger logger = LoggerFactory.getLogger(JablotronDiscoveryService.class);\n+    private JablotronBridgeHandler bridge;\n+    private @Nullable DiscoveryServiceCallback discoveryServiceCallback;\n+\n+    private @Nullable ScheduledFuture<?> discoveryJob = null;\n+\n+    private static final int DISCOVERY_TIMEOUT_SEC = 10;\n+\n+    public JablotronDiscoveryService(JablotronBridgeHandler bridgeHandler) {\n+        super(DISCOVERY_TIMEOUT_SEC);\n+        logger.debug(\"Creating discovery service\");\n+        this.bridge = bridgeHandler;\n+    }\n+\n+    private void startDiscovery() {\n+        if (this.bridge.getThing().getStatus() == ThingStatus.ONLINE) {\n+            discoverServices();\n+        }\n+    }\n+\n+    @Override\n+    protected void stopBackgroundDiscovery() {\n+        super.stopBackgroundDiscovery();\n+        if (discoveryJob != null) {\n+            discoveryJob.cancel(true);\n+        }\n+    }\n+\n+    @Override\n+    protected void startBackgroundDiscovery() {\n+        logger.debug(\"Starting Jablotron background discovery\");\n+\n+        if (discoveryJob == null || discoveryJob.isCancelled()) {\n+            discoveryJob = scheduler.scheduleWithFixedDelay(this::startDiscovery, 10, 3600,\n+                    TimeUnit.SECONDS);\n+        }\n+    }\n+\n+    /**\n+     * Called on component activation.\n+     */\n+    @Override\n+    @Activate\n+    public void activate(@Nullable Map<String, @Nullable Object> configProperties) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "36775963f2d1f6fd1e9689f06b070bfa8e6a859e"}, "originalPosition": 88}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDEyMzcxMA==", "bodyText": "removed", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r484123710", "createdAt": "2020-09-06T22:57:09Z", "author": {"login": "octa22"}, "path": "bundles/org.openhab.binding.jablotron/src/main/java/org/openhab/binding/jablotron/internal/discovery/JablotronDiscoveryService.java", "diffHunk": "@@ -0,0 +1,175 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.jablotron.internal.discovery;\n+\n+import static org.openhab.binding.jablotron.JablotronBindingConstants.*;\n+\n+import java.util.*;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.config.discovery.AbstractDiscoveryService;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResultBuilder;\n+import org.eclipse.smarthome.config.discovery.DiscoveryServiceCallback;\n+import org.eclipse.smarthome.config.discovery.ExtendedDiscoveryService;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.thing.ThingUID;\n+import org.openhab.binding.jablotron.internal.handler.JablotronBridgeHandler;\n+import org.openhab.binding.jablotron.internal.model.JablotronDiscoveredService;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Deactivate;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link JablotronDiscoveryService} is responsible for the thing discovery\n+ * process.\n+ *\n+ * @author Ondrej Pecta - Initial contribution\n+ */\n+@NonNullByDefault\n+public class JablotronDiscoveryService extends AbstractDiscoveryService implements ExtendedDiscoveryService {\n+    private final Logger logger = LoggerFactory.getLogger(JablotronDiscoveryService.class);\n+    private JablotronBridgeHandler bridge;\n+    private @Nullable DiscoveryServiceCallback discoveryServiceCallback;\n+\n+    private @Nullable ScheduledFuture<?> discoveryJob = null;\n+\n+    private static final int DISCOVERY_TIMEOUT_SEC = 10;\n+\n+    public JablotronDiscoveryService(JablotronBridgeHandler bridgeHandler) {\n+        super(DISCOVERY_TIMEOUT_SEC);\n+        logger.debug(\"Creating discovery service\");\n+        this.bridge = bridgeHandler;\n+    }\n+\n+    private void startDiscovery() {\n+        if (this.bridge.getThing().getStatus() == ThingStatus.ONLINE) {\n+            discoverServices();\n+        }\n+    }\n+\n+    @Override\n+    protected void stopBackgroundDiscovery() {\n+        super.stopBackgroundDiscovery();\n+        if (discoveryJob != null) {\n+            discoveryJob.cancel(true);\n+        }\n+    }\n+\n+    @Override\n+    protected void startBackgroundDiscovery() {\n+        logger.debug(\"Starting Jablotron background discovery\");\n+\n+        if (discoveryJob == null || discoveryJob.isCancelled()) {\n+            discoveryJob = scheduler.scheduleWithFixedDelay(this::startDiscovery, 10, 3600,\n+                    TimeUnit.SECONDS);\n+        }\n+    }\n+\n+    /**\n+     * Called on component activation.\n+     */\n+    @Override\n+    @Activate\n+    public void activate(@Nullable Map<String, @Nullable Object> configProperties) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzQyNjc4NA=="}, "originalCommit": {"oid": "36775963f2d1f6fd1e9689f06b070bfa8e6a859e"}, "originalPosition": 88}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAyMjY5MDUwOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.jablotron/src/main/java/org/openhab/binding/jablotron/internal/discovery/JablotronDiscoveryService.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNFQwNzowMTo1N1rOHNCCpw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNlQyMTo1MjoyNFrOHNsNlw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzQyNjk4Mw==", "bodyText": "This is probably not needed as it is already done in stopBackgroundDiscovery.", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r483426983", "createdAt": "2020-09-04T07:01:57Z", "author": {"login": "Hilbrand"}, "path": "bundles/org.openhab.binding.jablotron/src/main/java/org/openhab/binding/jablotron/internal/discovery/JablotronDiscoveryService.java", "diffHunk": "@@ -0,0 +1,175 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.jablotron.internal.discovery;\n+\n+import static org.openhab.binding.jablotron.JablotronBindingConstants.*;\n+\n+import java.util.*;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.config.discovery.AbstractDiscoveryService;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResultBuilder;\n+import org.eclipse.smarthome.config.discovery.DiscoveryServiceCallback;\n+import org.eclipse.smarthome.config.discovery.ExtendedDiscoveryService;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.thing.ThingUID;\n+import org.openhab.binding.jablotron.internal.handler.JablotronBridgeHandler;\n+import org.openhab.binding.jablotron.internal.model.JablotronDiscoveredService;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Deactivate;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link JablotronDiscoveryService} is responsible for the thing discovery\n+ * process.\n+ *\n+ * @author Ondrej Pecta - Initial contribution\n+ */\n+@NonNullByDefault\n+public class JablotronDiscoveryService extends AbstractDiscoveryService implements ExtendedDiscoveryService {\n+    private final Logger logger = LoggerFactory.getLogger(JablotronDiscoveryService.class);\n+    private JablotronBridgeHandler bridge;\n+    private @Nullable DiscoveryServiceCallback discoveryServiceCallback;\n+\n+    private @Nullable ScheduledFuture<?> discoveryJob = null;\n+\n+    private static final int DISCOVERY_TIMEOUT_SEC = 10;\n+\n+    public JablotronDiscoveryService(JablotronBridgeHandler bridgeHandler) {\n+        super(DISCOVERY_TIMEOUT_SEC);\n+        logger.debug(\"Creating discovery service\");\n+        this.bridge = bridgeHandler;\n+    }\n+\n+    private void startDiscovery() {\n+        if (this.bridge.getThing().getStatus() == ThingStatus.ONLINE) {\n+            discoverServices();\n+        }\n+    }\n+\n+    @Override\n+    protected void stopBackgroundDiscovery() {\n+        super.stopBackgroundDiscovery();\n+        if (discoveryJob != null) {\n+            discoveryJob.cancel(true);\n+        }\n+    }\n+\n+    @Override\n+    protected void startBackgroundDiscovery() {\n+        logger.debug(\"Starting Jablotron background discovery\");\n+\n+        if (discoveryJob == null || discoveryJob.isCancelled()) {\n+            discoveryJob = scheduler.scheduleWithFixedDelay(this::startDiscovery, 10, 3600,\n+                    TimeUnit.SECONDS);\n+        }\n+    }\n+\n+    /**\n+     * Called on component activation.\n+     */\n+    @Override\n+    @Activate\n+    public void activate(@Nullable Map<String, @Nullable Object> configProperties) {\n+        super.activate(configProperties);\n+    }\n+\n+    @Deactivate\n+    @Override\n+    public void deactivate() {\n+        super.deactivate();\n+        if (discoveryJob != null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "36775963f2d1f6fd1e9689f06b070bfa8e6a859e"}, "originalPosition": 96}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDExNzkxMQ==", "bodyText": "agree", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r484117911", "createdAt": "2020-09-06T21:52:24Z", "author": {"login": "octa22"}, "path": "bundles/org.openhab.binding.jablotron/src/main/java/org/openhab/binding/jablotron/internal/discovery/JablotronDiscoveryService.java", "diffHunk": "@@ -0,0 +1,175 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.jablotron.internal.discovery;\n+\n+import static org.openhab.binding.jablotron.JablotronBindingConstants.*;\n+\n+import java.util.*;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.config.discovery.AbstractDiscoveryService;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResultBuilder;\n+import org.eclipse.smarthome.config.discovery.DiscoveryServiceCallback;\n+import org.eclipse.smarthome.config.discovery.ExtendedDiscoveryService;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.thing.ThingUID;\n+import org.openhab.binding.jablotron.internal.handler.JablotronBridgeHandler;\n+import org.openhab.binding.jablotron.internal.model.JablotronDiscoveredService;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Deactivate;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link JablotronDiscoveryService} is responsible for the thing discovery\n+ * process.\n+ *\n+ * @author Ondrej Pecta - Initial contribution\n+ */\n+@NonNullByDefault\n+public class JablotronDiscoveryService extends AbstractDiscoveryService implements ExtendedDiscoveryService {\n+    private final Logger logger = LoggerFactory.getLogger(JablotronDiscoveryService.class);\n+    private JablotronBridgeHandler bridge;\n+    private @Nullable DiscoveryServiceCallback discoveryServiceCallback;\n+\n+    private @Nullable ScheduledFuture<?> discoveryJob = null;\n+\n+    private static final int DISCOVERY_TIMEOUT_SEC = 10;\n+\n+    public JablotronDiscoveryService(JablotronBridgeHandler bridgeHandler) {\n+        super(DISCOVERY_TIMEOUT_SEC);\n+        logger.debug(\"Creating discovery service\");\n+        this.bridge = bridgeHandler;\n+    }\n+\n+    private void startDiscovery() {\n+        if (this.bridge.getThing().getStatus() == ThingStatus.ONLINE) {\n+            discoverServices();\n+        }\n+    }\n+\n+    @Override\n+    protected void stopBackgroundDiscovery() {\n+        super.stopBackgroundDiscovery();\n+        if (discoveryJob != null) {\n+            discoveryJob.cancel(true);\n+        }\n+    }\n+\n+    @Override\n+    protected void startBackgroundDiscovery() {\n+        logger.debug(\"Starting Jablotron background discovery\");\n+\n+        if (discoveryJob == null || discoveryJob.isCancelled()) {\n+            discoveryJob = scheduler.scheduleWithFixedDelay(this::startDiscovery, 10, 3600,\n+                    TimeUnit.SECONDS);\n+        }\n+    }\n+\n+    /**\n+     * Called on component activation.\n+     */\n+    @Override\n+    @Activate\n+    public void activate(@Nullable Map<String, @Nullable Object> configProperties) {\n+        super.activate(configProperties);\n+    }\n+\n+    @Deactivate\n+    @Override\n+    public void deactivate() {\n+        super.deactivate();\n+        if (discoveryJob != null) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzQyNjk4Mw=="}, "originalCommit": {"oid": "36775963f2d1f6fd1e9689f06b070bfa8e6a859e"}, "originalPosition": 96}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAyMjY5Mjg1OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.jablotron/src/main/java/org/openhab/binding/jablotron/internal/handler/JablotronAlarmHandler.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNFQwNzowMjo1N1rOHNCEIw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNlQyMTo0Mjo1OVrOHNsKdQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzQyNzM2Mw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    future = scheduler.scheduleWithFixedDelay(() -> {\n          \n          \n            \n                        updateAlarmStatus();\n          \n          \n            \n                    }, 1, thingConfig.getRefresh(), TimeUnit.SECONDS);\n          \n          \n            \n                    future = scheduler.scheduleWithFixedDelay(this::updateAlarmStatus, 1, thingConfig.getRefresh(), TimeUnit.SECONDS);", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r483427363", "createdAt": "2020-09-04T07:02:57Z", "author": {"login": "Hilbrand"}, "path": "bundles/org.openhab.binding.jablotron/src/main/java/org/openhab/binding/jablotron/internal/handler/JablotronAlarmHandler.java", "diffHunk": "@@ -0,0 +1,221 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.jablotron.internal.handler;\n+\n+import static org.openhab.binding.jablotron.JablotronBindingConstants.*;\n+\n+import java.time.ZoneId;\n+import java.time.ZonedDateTime;\n+import java.time.format.DateTimeFormatter;\n+import java.util.Calendar;\n+import java.util.List;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import com.google.gson.Gson;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DateTimeType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.ThingStatusInfo;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.jablotron.internal.config.JablotronDeviceConfig;\n+import org.openhab.binding.jablotron.internal.model.*;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link JablotronAlarmHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Ondrej Pecta - Initial contribution\n+ */\n+@NonNullByDefault\n+public abstract class JablotronAlarmHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(JablotronAlarmHandler.class);\n+\n+    protected Gson gson = new Gson();\n+\n+    protected JablotronDeviceConfig thingConfig = new JablotronDeviceConfig();\n+\n+    private String lastWarningTime = \"\";\n+\n+    protected String alarmName = \"\";\n+\n+    private boolean inService = false;\n+\n+    @Nullable\n+    ScheduledFuture<?> future = null;\n+\n+    public JablotronAlarmHandler(Thing thing, String alarmName) {\n+        super(thing);\n+        this.alarmName = alarmName;\n+    }\n+\n+    @Override\n+    public void bridgeStatusChanged(ThingStatusInfo bridgeStatusInfo) {\n+        super.bridgeStatusChanged(bridgeStatusInfo);\n+        if (ThingStatus.UNINITIALIZED == bridgeStatusInfo.getStatus()) {\n+            cleanup();\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        super.dispose();\n+        cleanup();\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        thingConfig = getConfigAs(JablotronDeviceConfig.class);\n+        scheduler.execute(() -> {\n+            doInit();\n+        });\n+        updateStatus(ThingStatus.ONLINE);\n+    }\n+\n+    public boolean isInService() {\n+        return inService;\n+    }\n+\n+    public String getAlarmName() {\n+        return alarmName;\n+    }\n+\n+    protected void updateSegmentStatus(JablotronServiceDetailSegment segment) {\n+    }\n+\n+    private void cleanup() {\n+        logger.debug(\"doing cleanup...\");\n+        if (future != null) {\n+            future.cancel(true);\n+        }\n+    }\n+\n+    protected State getCheckTime() {\n+        ZonedDateTime zdt = ZonedDateTime.ofInstant(Calendar.getInstance().toInstant(), ZoneId.systemDefault());\n+        return new DateTimeType(zdt);\n+    }\n+\n+    protected void doInit() {\n+        future = scheduler.scheduleWithFixedDelay(() -> {\n+            updateAlarmStatus();\n+        }, 1, thingConfig.getRefresh(), TimeUnit.SECONDS);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "36775963f2d1f6fd1e9689f06b070bfa8e6a859e"}, "originalPosition": 119}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDExNzEwOQ==", "bodyText": "ok", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r484117109", "createdAt": "2020-09-06T21:42:59Z", "author": {"login": "octa22"}, "path": "bundles/org.openhab.binding.jablotron/src/main/java/org/openhab/binding/jablotron/internal/handler/JablotronAlarmHandler.java", "diffHunk": "@@ -0,0 +1,221 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.jablotron.internal.handler;\n+\n+import static org.openhab.binding.jablotron.JablotronBindingConstants.*;\n+\n+import java.time.ZoneId;\n+import java.time.ZonedDateTime;\n+import java.time.format.DateTimeFormatter;\n+import java.util.Calendar;\n+import java.util.List;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import com.google.gson.Gson;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DateTimeType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.ThingStatusInfo;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.jablotron.internal.config.JablotronDeviceConfig;\n+import org.openhab.binding.jablotron.internal.model.*;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link JablotronAlarmHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Ondrej Pecta - Initial contribution\n+ */\n+@NonNullByDefault\n+public abstract class JablotronAlarmHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(JablotronAlarmHandler.class);\n+\n+    protected Gson gson = new Gson();\n+\n+    protected JablotronDeviceConfig thingConfig = new JablotronDeviceConfig();\n+\n+    private String lastWarningTime = \"\";\n+\n+    protected String alarmName = \"\";\n+\n+    private boolean inService = false;\n+\n+    @Nullable\n+    ScheduledFuture<?> future = null;\n+\n+    public JablotronAlarmHandler(Thing thing, String alarmName) {\n+        super(thing);\n+        this.alarmName = alarmName;\n+    }\n+\n+    @Override\n+    public void bridgeStatusChanged(ThingStatusInfo bridgeStatusInfo) {\n+        super.bridgeStatusChanged(bridgeStatusInfo);\n+        if (ThingStatus.UNINITIALIZED == bridgeStatusInfo.getStatus()) {\n+            cleanup();\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        super.dispose();\n+        cleanup();\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        thingConfig = getConfigAs(JablotronDeviceConfig.class);\n+        scheduler.execute(() -> {\n+            doInit();\n+        });\n+        updateStatus(ThingStatus.ONLINE);\n+    }\n+\n+    public boolean isInService() {\n+        return inService;\n+    }\n+\n+    public String getAlarmName() {\n+        return alarmName;\n+    }\n+\n+    protected void updateSegmentStatus(JablotronServiceDetailSegment segment) {\n+    }\n+\n+    private void cleanup() {\n+        logger.debug(\"doing cleanup...\");\n+        if (future != null) {\n+            future.cancel(true);\n+        }\n+    }\n+\n+    protected State getCheckTime() {\n+        ZonedDateTime zdt = ZonedDateTime.ofInstant(Calendar.getInstance().toInstant(), ZoneId.systemDefault());\n+        return new DateTimeType(zdt);\n+    }\n+\n+    protected void doInit() {\n+        future = scheduler.scheduleWithFixedDelay(() -> {\n+            updateAlarmStatus();\n+        }, 1, thingConfig.getRefresh(), TimeUnit.SECONDS);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzQyNzM2Mw=="}, "originalCommit": {"oid": "36775963f2d1f6fd1e9689f06b070bfa8e6a859e"}, "originalPosition": 119}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAyMjcwMjE3OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.jablotron/src/main/java/org/openhab/binding/jablotron/internal/handler/JablotronBridgeHandler.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNFQwNzowNjoxMFrOHNCJlA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOFQxOTowMjowOVrOHOqOcA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzQyODc1Ng==", "bodyText": "To make this class a lot readable better move the generic parts in these methods to a single method and call that from the other methods.", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r483428756", "createdAt": "2020-09-04T07:06:10Z", "author": {"login": "Hilbrand"}, "path": "bundles/org.openhab.binding.jablotron/src/main/java/org/openhab/binding/jablotron/internal/handler/JablotronBridgeHandler.java", "diffHunk": "@@ -0,0 +1,452 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.jablotron.internal.handler;\n+\n+import static org.openhab.binding.jablotron.JablotronBindingConstants.*;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.JsonSyntaxException;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.eclipse.jetty.http.HttpHeader;\n+import org.eclipse.jetty.http.HttpMethod;\n+import org.eclipse.smarthome.config.core.status.ConfigStatusMessage;\n+import org.eclipse.smarthome.core.thing.*;\n+import org.eclipse.smarthome.core.thing.binding.ConfigStatusBridgeHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.openhab.binding.jablotron.internal.config.JablotronBridgeConfig;\n+import org.openhab.binding.jablotron.internal.model.*;\n+import org.openhab.binding.jablotron.internal.model.ja100f.JablotronGetPGResponse;\n+import org.openhab.binding.jablotron.internal.model.ja100f.JablotronGetSectionsResponse;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link JablotronBridgeHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Ondrej Pecta - Initial contribution\n+ */\n+@NonNullByDefault\n+public class JablotronBridgeHandler extends ConfigStatusBridgeHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(JablotronBridgeHandler.class);\n+\n+    private Gson gson = new Gson();\n+\n+    final HttpClient httpClient;\n+\n+    @Nullable\n+    ScheduledFuture<?> future = null;\n+\n+    /**\n+     * Our configuration\n+     */\n+    public JablotronBridgeConfig bridgeConfig = new JablotronBridgeConfig();\n+\n+    public JablotronBridgeHandler(Bridge thing, HttpClient httpClient) {\n+        super(thing);\n+        this.httpClient = httpClient;\n+    }\n+\n+    @Override\n+    public Collection<ConfigStatusMessage> getConfigStatus() {\n+        return Collections.emptyList();\n+    }\n+\n+    @Override\n+    public void childHandlerInitialized(ThingHandler thingHandler, Thing thing) {\n+    }\n+\n+    @Override\n+    public void childHandlerDisposed(ThingHandler thingHandler, Thing thing) {\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        bridgeConfig = getConfigAs(JablotronBridgeConfig.class);\n+        scheduler.execute(this::login);\n+        future = scheduler.scheduleWithFixedDelay(() -> updateAlarmThings(), 30, bridgeConfig.getRefresh(), TimeUnit.SECONDS);\n+    }\n+\n+    private void updateAlarmThings() {\n+        List<JablotronDiscoveredService> services = discoverServices();\n+        if (services != null) {\n+            for (JablotronDiscoveredService service : services) {\n+                updateAlarmThing(service);\n+            }\n+        }\n+    }\n+\n+    private void updateAlarmThing(JablotronDiscoveredService service) {\n+        for (Thing th : getThing().getThings()) {\n+            if (String.valueOf(service.getId()).equals(th.getUID().getId())) {\n+                JablotronAlarmHandler handler = (JablotronAlarmHandler) th.getHandler();\n+                if (handler == null) {\n+                    logger.debug(\"Thing handler is null\");\n+                    continue;\n+                }\n+                if (\"ENABLED\".equals(service.getStatus())) {\n+                    if (!\"\".equals(service.getWarning())) {\n+                        logger.debug(\"Alarm with service id: {} warning: {}\", service.getId(), service.getWarning());\n+                    }\n+                    handler.setStatus(ThingStatus.ONLINE, ThingStatusDetail.NONE, service.getWarning());\n+                    if (\"ALARM\".equals(service.getWarning()) || \"TAMPER\".equals(service.getWarning())) {\n+                        handler.triggerAlarm(service);\n+                    }\n+                    handler.setInService(\"SERVICE\".equals(service.getWarning()));\n+                } else {\n+                    logger.debug(\"Alarm with service id: {} is offline\", service.getId());\n+                    handler.setStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, service.getStatus());\n+                }\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        super.dispose();\n+        if (future != null) {\n+            future.cancel(true);\n+        }\n+        logout();\n+    }\n+\n+    protected synchronized void login() {\n+        try {\n+            String url = JABLOTRON_API_URL + \"userAuthorize.json\";\n+            String urlParameters = \"{\\\"login\\\":\\\"\" + bridgeConfig.getLogin() + \"\\\", \\\"password\\\":\\\"\" + bridgeConfig.getPassword() + \"\\\"}\";\n+\n+            ContentResponse resp = createRequest(url)\n+                    .header(HttpHeader.ACCEPT, APPLICATION_JSON)\n+                    .content(new StringContentProvider(urlParameters), APPLICATION_JSON)\n+                    .send();\n+\n+            String line = resp.getContentAsString();\n+            logger.trace(\"login response: {}\", line);\n+            JablotronLoginResponse response = gson.fromJson(line, JablotronLoginResponse.class);\n+            if (response.getHttpCode() != 200) {\n+                logger.debug(\"Error during login, got http error: {}\", response.getHttpCode());\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, \"Http error: \" + String.valueOf(response.getHttpCode()));\n+            } else {\n+                logger.debug(\"Successfully logged in\");\n+                updateStatus(ThingStatus.ONLINE);\n+            }\n+        } catch (TimeoutException e) {\n+            logger.debug(\"Timeout during getting login cookie\", e);\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, \"Cannot login to Jablonet cloud\");\n+        } catch (ExecutionException | InterruptedException | JsonSyntaxException e) {\n+            logger.debug(\"Cannot get Jablotron login cookie\", e);\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, \"Cannot login to Jablonet cloud\");\n+        }\n+    }\n+\n+    protected synchronized void logout() {\n+        String url = JABLOTRON_API_URL + \"logout.json\";\n+        String urlParameters = \"system=\" + SYSTEM;\n+\n+        try {\n+            ContentResponse resp = createRequest(url)\n+                    .content(new StringContentProvider(urlParameters), \"application/x-www-form-urlencoded; charset=UTF-8\")\n+                    .send();\n+            String line = resp.getContentAsString();\n+\n+            logger.trace(\"logout response: {}\", line);\n+        } catch (ExecutionException | TimeoutException | InterruptedException e) {\n+            //Silence\n+        }\n+    }\n+\n+    public synchronized @Nullable List<JablotronDiscoveredService> discoverServices() {\n+        try {\n+            String url = JABLOTRON_API_URL + \"serviceListGet.json\";\n+            String urlParameters = \"{\\\"list-type\\\": \\\"EXTENDED\\\",\\\"visibility\\\": \\\"VISIBLE\\\"}\";\n+\n+            ContentResponse resp = createRequest(url)\n+                    .header(HttpHeader.ACCEPT, APPLICATION_JSON)\n+                    .content(new StringContentProvider(urlParameters), APPLICATION_JSON)\n+                    .send();\n+\n+            String line = resp.getContentAsString();\n+\n+            logger.trace(\"Response: {}\", line);\n+            JablotronGetServiceResponse response = gson.fromJson(line, JablotronGetServiceResponse.class);\n+\n+            if (response.getHttpCode() != 200) {\n+                logger.debug(\"Error during service discovery, got http code: {}\", response.getHttpCode());\n+            }\n+\n+            return response.getData().getServices();\n+        } catch (TimeoutException e) {\n+            logger.debug(\"Timeout during discovering services\", e);\n+        } catch (InterruptedException e) {\n+            logger.debug(\"Error during discovering services\", e);\n+        } catch (JsonSyntaxException e) {\n+            logger.debug(\"JSON syntax exception\", e);\n+        } catch (ExecutionException e) {\n+            if (e.getMessage().contains(AUTHENTICATION_CHALLENGE)) {\n+                relogin();\n+            } else {\n+                logger.debug(\"Error during discovering services\", e);\n+            }\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "36775963f2d1f6fd1e9689f06b070bfa8e6a859e"}, "originalPosition": 219}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTEzMzkzNg==", "bodyText": "I did some changes to make this class more readable", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r485133936", "createdAt": "2020-09-08T19:02:09Z", "author": {"login": "octa22"}, "path": "bundles/org.openhab.binding.jablotron/src/main/java/org/openhab/binding/jablotron/internal/handler/JablotronBridgeHandler.java", "diffHunk": "@@ -0,0 +1,452 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.jablotron.internal.handler;\n+\n+import static org.openhab.binding.jablotron.JablotronBindingConstants.*;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.JsonSyntaxException;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.eclipse.jetty.http.HttpHeader;\n+import org.eclipse.jetty.http.HttpMethod;\n+import org.eclipse.smarthome.config.core.status.ConfigStatusMessage;\n+import org.eclipse.smarthome.core.thing.*;\n+import org.eclipse.smarthome.core.thing.binding.ConfigStatusBridgeHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.openhab.binding.jablotron.internal.config.JablotronBridgeConfig;\n+import org.openhab.binding.jablotron.internal.model.*;\n+import org.openhab.binding.jablotron.internal.model.ja100f.JablotronGetPGResponse;\n+import org.openhab.binding.jablotron.internal.model.ja100f.JablotronGetSectionsResponse;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link JablotronBridgeHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Ondrej Pecta - Initial contribution\n+ */\n+@NonNullByDefault\n+public class JablotronBridgeHandler extends ConfigStatusBridgeHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(JablotronBridgeHandler.class);\n+\n+    private Gson gson = new Gson();\n+\n+    final HttpClient httpClient;\n+\n+    @Nullable\n+    ScheduledFuture<?> future = null;\n+\n+    /**\n+     * Our configuration\n+     */\n+    public JablotronBridgeConfig bridgeConfig = new JablotronBridgeConfig();\n+\n+    public JablotronBridgeHandler(Bridge thing, HttpClient httpClient) {\n+        super(thing);\n+        this.httpClient = httpClient;\n+    }\n+\n+    @Override\n+    public Collection<ConfigStatusMessage> getConfigStatus() {\n+        return Collections.emptyList();\n+    }\n+\n+    @Override\n+    public void childHandlerInitialized(ThingHandler thingHandler, Thing thing) {\n+    }\n+\n+    @Override\n+    public void childHandlerDisposed(ThingHandler thingHandler, Thing thing) {\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        bridgeConfig = getConfigAs(JablotronBridgeConfig.class);\n+        scheduler.execute(this::login);\n+        future = scheduler.scheduleWithFixedDelay(() -> updateAlarmThings(), 30, bridgeConfig.getRefresh(), TimeUnit.SECONDS);\n+    }\n+\n+    private void updateAlarmThings() {\n+        List<JablotronDiscoveredService> services = discoverServices();\n+        if (services != null) {\n+            for (JablotronDiscoveredService service : services) {\n+                updateAlarmThing(service);\n+            }\n+        }\n+    }\n+\n+    private void updateAlarmThing(JablotronDiscoveredService service) {\n+        for (Thing th : getThing().getThings()) {\n+            if (String.valueOf(service.getId()).equals(th.getUID().getId())) {\n+                JablotronAlarmHandler handler = (JablotronAlarmHandler) th.getHandler();\n+                if (handler == null) {\n+                    logger.debug(\"Thing handler is null\");\n+                    continue;\n+                }\n+                if (\"ENABLED\".equals(service.getStatus())) {\n+                    if (!\"\".equals(service.getWarning())) {\n+                        logger.debug(\"Alarm with service id: {} warning: {}\", service.getId(), service.getWarning());\n+                    }\n+                    handler.setStatus(ThingStatus.ONLINE, ThingStatusDetail.NONE, service.getWarning());\n+                    if (\"ALARM\".equals(service.getWarning()) || \"TAMPER\".equals(service.getWarning())) {\n+                        handler.triggerAlarm(service);\n+                    }\n+                    handler.setInService(\"SERVICE\".equals(service.getWarning()));\n+                } else {\n+                    logger.debug(\"Alarm with service id: {} is offline\", service.getId());\n+                    handler.setStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, service.getStatus());\n+                }\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        super.dispose();\n+        if (future != null) {\n+            future.cancel(true);\n+        }\n+        logout();\n+    }\n+\n+    protected synchronized void login() {\n+        try {\n+            String url = JABLOTRON_API_URL + \"userAuthorize.json\";\n+            String urlParameters = \"{\\\"login\\\":\\\"\" + bridgeConfig.getLogin() + \"\\\", \\\"password\\\":\\\"\" + bridgeConfig.getPassword() + \"\\\"}\";\n+\n+            ContentResponse resp = createRequest(url)\n+                    .header(HttpHeader.ACCEPT, APPLICATION_JSON)\n+                    .content(new StringContentProvider(urlParameters), APPLICATION_JSON)\n+                    .send();\n+\n+            String line = resp.getContentAsString();\n+            logger.trace(\"login response: {}\", line);\n+            JablotronLoginResponse response = gson.fromJson(line, JablotronLoginResponse.class);\n+            if (response.getHttpCode() != 200) {\n+                logger.debug(\"Error during login, got http error: {}\", response.getHttpCode());\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, \"Http error: \" + String.valueOf(response.getHttpCode()));\n+            } else {\n+                logger.debug(\"Successfully logged in\");\n+                updateStatus(ThingStatus.ONLINE);\n+            }\n+        } catch (TimeoutException e) {\n+            logger.debug(\"Timeout during getting login cookie\", e);\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, \"Cannot login to Jablonet cloud\");\n+        } catch (ExecutionException | InterruptedException | JsonSyntaxException e) {\n+            logger.debug(\"Cannot get Jablotron login cookie\", e);\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, \"Cannot login to Jablonet cloud\");\n+        }\n+    }\n+\n+    protected synchronized void logout() {\n+        String url = JABLOTRON_API_URL + \"logout.json\";\n+        String urlParameters = \"system=\" + SYSTEM;\n+\n+        try {\n+            ContentResponse resp = createRequest(url)\n+                    .content(new StringContentProvider(urlParameters), \"application/x-www-form-urlencoded; charset=UTF-8\")\n+                    .send();\n+            String line = resp.getContentAsString();\n+\n+            logger.trace(\"logout response: {}\", line);\n+        } catch (ExecutionException | TimeoutException | InterruptedException e) {\n+            //Silence\n+        }\n+    }\n+\n+    public synchronized @Nullable List<JablotronDiscoveredService> discoverServices() {\n+        try {\n+            String url = JABLOTRON_API_URL + \"serviceListGet.json\";\n+            String urlParameters = \"{\\\"list-type\\\": \\\"EXTENDED\\\",\\\"visibility\\\": \\\"VISIBLE\\\"}\";\n+\n+            ContentResponse resp = createRequest(url)\n+                    .header(HttpHeader.ACCEPT, APPLICATION_JSON)\n+                    .content(new StringContentProvider(urlParameters), APPLICATION_JSON)\n+                    .send();\n+\n+            String line = resp.getContentAsString();\n+\n+            logger.trace(\"Response: {}\", line);\n+            JablotronGetServiceResponse response = gson.fromJson(line, JablotronGetServiceResponse.class);\n+\n+            if (response.getHttpCode() != 200) {\n+                logger.debug(\"Error during service discovery, got http code: {}\", response.getHttpCode());\n+            }\n+\n+            return response.getData().getServices();\n+        } catch (TimeoutException e) {\n+            logger.debug(\"Timeout during discovering services\", e);\n+        } catch (InterruptedException e) {\n+            logger.debug(\"Error during discovering services\", e);\n+        } catch (JsonSyntaxException e) {\n+            logger.debug(\"JSON syntax exception\", e);\n+        } catch (ExecutionException e) {\n+            if (e.getMessage().contains(AUTHENTICATION_CHALLENGE)) {\n+                relogin();\n+            } else {\n+                logger.debug(\"Error during discovering services\", e);\n+            }\n+        }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzQyODc1Ng=="}, "originalCommit": {"oid": "36775963f2d1f6fd1e9689f06b070bfa8e6a859e"}, "originalPosition": 219}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAyMjcwNTE5OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.jablotron/src/main/java/org/openhab/binding/jablotron/internal/handler/JablotronOasisHandler.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNFQwNzowNzowOFrOHNCLWg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNlQyMTo0MToyMVrOHNsJ8Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzQyOTIxMA==", "bodyText": "Is this Exception thrown or can it be a specific exception that is being catched here?", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r483429210", "createdAt": "2020-09-04T07:07:08Z", "author": {"login": "Hilbrand"}, "path": "bundles/org.openhab.binding.jablotron/src/main/java/org/openhab/binding/jablotron/internal/handler/JablotronOasisHandler.java", "diffHunk": "@@ -0,0 +1,119 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.jablotron.internal.handler;\n+\n+import static org.openhab.binding.jablotron.JablotronBindingConstants.*;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.jablotron.internal.model.JablotronControlResponse;\n+import org.openhab.binding.jablotron.internal.model.JablotronServiceDetailSegment;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link JablotronOasisHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Ondrej Pecta - Initial contribution\n+ */\n+@NonNullByDefault\n+public class JablotronOasisHandler extends JablotronAlarmHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(JablotronOasisHandler.class);\n+\n+    public JablotronOasisHandler(Thing thing, String alarmName) {\n+        super(thing, alarmName);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (channelUID.getId().equals(CHANNEL_COMMAND) && command instanceof StringType) {\n+            scheduler.execute(() -> {\n+                sendCommand(command.toString());\n+            });\n+        }\n+\n+        if (channelUID.getId().equals(CHANNEL_STATUS_PGX) && command instanceof OnOffType) {\n+            scheduler.execute(() -> {\n+                controlSection(\"PGM_1\", command.equals(OnOffType.ON) ? \"set\" : \"unset\");\n+            });\n+        }\n+\n+        if (channelUID.getId().equals(CHANNEL_STATUS_PGY) && command instanceof OnOffType) {\n+            scheduler.execute(() -> {\n+                controlSection(\"PGM_2\", command.equals(OnOffType.ON) ? \"set\" : \"unset\");\n+            });\n+        }\n+    }\n+\n+    @Override\n+    protected void updateSegmentStatus(JablotronServiceDetailSegment segment) {\n+        logger.debug(\"Segment id: {} and status: {}\", segment.getSegmentId(), segment.getSegmentState());\n+        State newState = \"unset\".equals(segment.getSegmentState()) ? OnOffType.OFF : OnOffType.ON;\n+        switch (segment.getSegmentId()) {\n+            case \"STATE_1\":\n+                updateState(CHANNEL_STATUS_A, newState);\n+                break;\n+            case \"STATE_2\":\n+                updateState(CHANNEL_STATUS_B, newState);\n+                break;\n+            case \"STATE_3\":\n+                updateState(CHANNEL_STATUS_ABC, newState);\n+                break;\n+            case \"PGM_1\":\n+                updateState(CHANNEL_STATUS_PGX, newState);\n+                break;\n+            case \"PGM_2\":\n+                updateState(CHANNEL_STATUS_PGY, newState);\n+                break;\n+            default:\n+                logger.debug(\"Unknown segment received: {} with state: {}\", segment.getSegmentId(), segment.getSegmentState());\n+        }\n+    }\n+\n+    public synchronized void controlSection(String section, String status) {\n+        logger.debug(\"Controlling section: {} with status: {}\", section, status);\n+        JablotronControlResponse response = sendUserCode(section, section.toLowerCase(), status, \"\");\n+\n+        updateAlarmStatus();\n+        if (response == null) {\n+            logger.debug(\"null response/status received\");\n+        }\n+    }\n+\n+    public synchronized void sendCommand(String code) {\n+        try {\n+            JablotronControlResponse response = sendUserCode(code);\n+            scheduler.schedule(this::updateAlarmStatus, 1, TimeUnit.SECONDS);\n+\n+            if (response == null) {\n+                logger.debug(\"null response/status received\");\n+            }\n+        } catch (Exception e) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "36775963f2d1f6fd1e9689f06b070bfa8e6a859e"}, "originalPosition": 111}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDExNjk3Nw==", "bodyText": "removed catching of this generic exception", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r484116977", "createdAt": "2020-09-06T21:41:21Z", "author": {"login": "octa22"}, "path": "bundles/org.openhab.binding.jablotron/src/main/java/org/openhab/binding/jablotron/internal/handler/JablotronOasisHandler.java", "diffHunk": "@@ -0,0 +1,119 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.jablotron.internal.handler;\n+\n+import static org.openhab.binding.jablotron.JablotronBindingConstants.*;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.jablotron.internal.model.JablotronControlResponse;\n+import org.openhab.binding.jablotron.internal.model.JablotronServiceDetailSegment;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link JablotronOasisHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Ondrej Pecta - Initial contribution\n+ */\n+@NonNullByDefault\n+public class JablotronOasisHandler extends JablotronAlarmHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(JablotronOasisHandler.class);\n+\n+    public JablotronOasisHandler(Thing thing, String alarmName) {\n+        super(thing, alarmName);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (channelUID.getId().equals(CHANNEL_COMMAND) && command instanceof StringType) {\n+            scheduler.execute(() -> {\n+                sendCommand(command.toString());\n+            });\n+        }\n+\n+        if (channelUID.getId().equals(CHANNEL_STATUS_PGX) && command instanceof OnOffType) {\n+            scheduler.execute(() -> {\n+                controlSection(\"PGM_1\", command.equals(OnOffType.ON) ? \"set\" : \"unset\");\n+            });\n+        }\n+\n+        if (channelUID.getId().equals(CHANNEL_STATUS_PGY) && command instanceof OnOffType) {\n+            scheduler.execute(() -> {\n+                controlSection(\"PGM_2\", command.equals(OnOffType.ON) ? \"set\" : \"unset\");\n+            });\n+        }\n+    }\n+\n+    @Override\n+    protected void updateSegmentStatus(JablotronServiceDetailSegment segment) {\n+        logger.debug(\"Segment id: {} and status: {}\", segment.getSegmentId(), segment.getSegmentState());\n+        State newState = \"unset\".equals(segment.getSegmentState()) ? OnOffType.OFF : OnOffType.ON;\n+        switch (segment.getSegmentId()) {\n+            case \"STATE_1\":\n+                updateState(CHANNEL_STATUS_A, newState);\n+                break;\n+            case \"STATE_2\":\n+                updateState(CHANNEL_STATUS_B, newState);\n+                break;\n+            case \"STATE_3\":\n+                updateState(CHANNEL_STATUS_ABC, newState);\n+                break;\n+            case \"PGM_1\":\n+                updateState(CHANNEL_STATUS_PGX, newState);\n+                break;\n+            case \"PGM_2\":\n+                updateState(CHANNEL_STATUS_PGY, newState);\n+                break;\n+            default:\n+                logger.debug(\"Unknown segment received: {} with state: {}\", segment.getSegmentId(), segment.getSegmentState());\n+        }\n+    }\n+\n+    public synchronized void controlSection(String section, String status) {\n+        logger.debug(\"Controlling section: {} with status: {}\", section, status);\n+        JablotronControlResponse response = sendUserCode(section, section.toLowerCase(), status, \"\");\n+\n+        updateAlarmStatus();\n+        if (response == null) {\n+            logger.debug(\"null response/status received\");\n+        }\n+    }\n+\n+    public synchronized void sendCommand(String code) {\n+        try {\n+            JablotronControlResponse response = sendUserCode(code);\n+            scheduler.schedule(this::updateAlarmStatus, 1, TimeUnit.SECONDS);\n+\n+            if (response == null) {\n+                logger.debug(\"null response/status received\");\n+            }\n+        } catch (Exception e) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzQyOTIxMA=="}, "originalCommit": {"oid": "36775963f2d1f6fd1e9689f06b070bfa8e6a859e"}, "originalPosition": 111}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAyNTA1MTcxOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.jablotron/src/main/java/org/openhab/binding/jablotron/internal/handler/JablotronJa100Handler.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNFQxODo1MDoxMVrOHNYeqA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNlQxOTozNzo1NFrOHNrgtg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mzc5NDYwMA==", "bodyText": "Maybe add some context to this debug message. Like what was send.", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r483794600", "createdAt": "2020-09-04T18:50:11Z", "author": {"login": "Hilbrand"}, "path": "bundles/org.openhab.binding.jablotron/src/main/java/org/openhab/binding/jablotron/internal/handler/JablotronJa100Handler.java", "diffHunk": "@@ -0,0 +1,198 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.jablotron.internal.handler;\n+\n+import java.util.List;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.binding.builder.ChannelBuilder;\n+import org.eclipse.smarthome.core.thing.binding.builder.ThingBuilder;\n+import org.eclipse.smarthome.core.thing.type.ChannelTypeUID;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.jablotron.internal.model.JablotronControlResponse;\n+import org.openhab.binding.jablotron.internal.model.JablotronServiceDetailSegment;\n+import org.openhab.binding.jablotron.internal.model.JablotronServiceDetailSegmentInfo;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link JablotronJa100Handler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Ondrej Pecta - Initial contribution\n+ */\n+@NonNullByDefault\n+public class JablotronJa100Handler extends JablotronAlarmHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(JablotronJa100Handler.class);\n+\n+    public JablotronJa100Handler(Thing thing, String alarmName) {\n+        super(thing, alarmName);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (channelUID.getId().startsWith(\"STATE_\") && command instanceof StringType) {\n+            scheduler.execute(() -> {\n+                controlSTATESection(channelUID.getId(), command.toString());\n+            });\n+        }\n+\n+        if (channelUID.getId().startsWith(\"PGM_\") && command instanceof OnOffType) {\n+            scheduler.execute(() -> {\n+                controlPGMSection(channelUID.getId(), command.equals(OnOffType.ON) ? \"set\" : \"unset\");\n+            });\n+        }\n+    }\n+\n+    private void createChannel(JablotronServiceDetailSegment section) {\n+        if (section.getSegmentId().startsWith(\"PGM_\")) {\n+            createPGMChannel(section.getSegmentId(), section.getSegmentName());\n+        } else {\n+            createStateChannel(section.getSegmentId(), section.getSegmentName());\n+        }\n+    }\n+\n+    private void createTempChannel(String name, String label) {\n+        ChannelTypeUID temperature = new ChannelTypeUID(\"jablotron\", \"temperature\");\n+        ThingBuilder thingBuilder = editThing();\n+        Channel channel = ChannelBuilder.create(new ChannelUID(thing.getUID(), name), \"Number:Temperature\").withLabel(label).withType(temperature).build();\n+        thingBuilder.withChannel(channel);\n+        updateThing(thingBuilder.build());\n+    }\n+\n+    private void createThermostatChannel(String name, String label) {\n+        ChannelTypeUID temperature = new ChannelTypeUID(\"jablotron\", \"thermostat\");\n+        ThingBuilder thingBuilder = editThing();\n+        Channel channel = ChannelBuilder.create(new ChannelUID(thing.getUID(), name), \"Number:Temperature\").withLabel(label).withType(temperature).build();\n+        thingBuilder.withChannel(channel);\n+        updateThing(thingBuilder.build());\n+    }\n+\n+    private void createPGMChannel(String name, String label) {\n+        ThingBuilder thingBuilder = editThing();\n+        Channel channel = ChannelBuilder.create(new ChannelUID(thing.getUID(), name), \"Switch\").withLabel(label).build();\n+        thingBuilder.withChannel(channel);\n+        updateThing(thingBuilder.build());\n+    }\n+\n+    private void createStateChannel(String name, String label) {\n+        ChannelTypeUID alarmStatus = new ChannelTypeUID(\"jablotron\", \"alarm_state\");\n+        ThingBuilder thingBuilder = editThing();\n+        Channel channel = ChannelBuilder.create(new ChannelUID(thing.getUID(), name), \"String\").withLabel(label).withType(alarmStatus).build();\n+        thingBuilder.withChannel(channel);\n+        updateThing(thingBuilder.build());\n+    }\n+\n+    @Override\n+    protected void updateSegmentStatus(JablotronServiceDetailSegment segment) {\n+        logger.debug(\"Segment id: {} and status: {}\", segment.getSegmentId(), segment.getSegmentState());\n+        String segmentId = segment.getSegmentId();\n+\n+        if (segmentId.startsWith(\"STATE_\") || segmentId.startsWith(\"PGM_\")) {\n+            processSection(segment);\n+        } else if (segmentId.startsWith(\"THERMOMETER_\")) {\n+            processThermometer(segment);\n+        } else if (segmentId.startsWith(\"THERMOSTAT_\")) {\n+            processThermostat(segment);\n+        }\n+        else {\n+            logger.debug(\"Unknown segment received: {} with state: {}\", segment.getSegmentId(), segment.getSegmentState());\n+        }\n+    }\n+\n+    private void processSection(JablotronServiceDetailSegment segment) {\n+        String segmentId = segment.getSegmentId();\n+        Channel channel = getThing().getChannel(segmentId);\n+        if (channel == null) {\n+            logger.debug(\"Creating a new channel: {}\", segmentId);\n+            createChannel(segment);\n+        }\n+        channel = getThing().getChannel(segmentId);\n+        if (channel != null) {\n+            logger.debug(\"Updating channel: {} to value: {}\", channel.getUID(), segment.getSegmentState());\n+            State newState;\n+            if (segmentId.startsWith(\"PGM_\")) {\n+                newState = \"unset\".equals(segment.getSegmentState()) ? OnOffType.OFF : OnOffType.ON;\n+            } else {\n+                newState = new StringType(segment.getSegmentState());\n+            }\n+            updateState(channel.getUID(), newState);\n+        } else {\n+            logger.debug(\"The channel: {} still doesn't exist!\", segmentId);\n+        }\n+    }\n+\n+    private void processThermometer(JablotronServiceDetailSegment segment) {\n+        String segmentId = segment.getSegmentId();\n+        Channel channel = getThing().getChannel(segmentId);\n+        if (channel == null) {\n+            logger.debug(\"Creating a new temperature channel: {}\", segmentId);\n+            createTempChannel(segmentId, segment.getSegmentName());\n+        }\n+        updateTemperatureChannel(channel, segment);\n+    }\n+\n+    private void processThermostat(JablotronServiceDetailSegment segment) {\n+        String segmentId = segment.getSegmentId();\n+        Channel channel = getThing().getChannel(segmentId);\n+        if (channel == null) {\n+            logger.debug(\"Creating a new thermostat channel: {}\", segmentId);\n+            createThermostatChannel(segmentId, segment.getSegmentName());\n+        }\n+        updateTemperatureChannel(channel, segment);\n+    }\n+\n+    private void updateTemperatureChannel(Channel channel, JablotronServiceDetailSegment segment) {\n+        String segmentId = segment.getSegmentId();\n+        if (channel != null) {\n+            List<JablotronServiceDetailSegmentInfo> infos = segment.getSegmentInfos();\n+            if (infos.size() > 0) {\n+                logger.debug(\"Found value: {} and type: {}\", infos.get(0).getValue(), infos.get(0).getType());\n+                DecimalType newState = new DecimalType(infos.get(0).getValue());\n+                updateState(channel.getUID(), newState);\n+            } else {\n+                logger.debug(\"No segment information received\");\n+            }\n+        } else {\n+            logger.debug(\"The channel: {} still doesn't exist!\", segmentId);\n+        }\n+    }\n+\n+    public synchronized void controlPGMSection(String section, String status) {\n+        logger.debug(\"Controlling section: {} with status: {}\", section, status);\n+        JablotronControlResponse response = sendUserCode(section, section.toLowerCase(), status, thingConfig.getCode());\n+\n+        updateAlarmStatus();\n+        if (response == null) {\n+            logger.debug(\"null response/status received\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "36775963f2d1f6fd1e9689f06b070bfa8e6a859e"}, "originalPosition": 185}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDEwNjQyMg==", "bodyText": "added context", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r484106422", "createdAt": "2020-09-06T19:37:54Z", "author": {"login": "octa22"}, "path": "bundles/org.openhab.binding.jablotron/src/main/java/org/openhab/binding/jablotron/internal/handler/JablotronJa100Handler.java", "diffHunk": "@@ -0,0 +1,198 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.jablotron.internal.handler;\n+\n+import java.util.List;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.binding.builder.ChannelBuilder;\n+import org.eclipse.smarthome.core.thing.binding.builder.ThingBuilder;\n+import org.eclipse.smarthome.core.thing.type.ChannelTypeUID;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.jablotron.internal.model.JablotronControlResponse;\n+import org.openhab.binding.jablotron.internal.model.JablotronServiceDetailSegment;\n+import org.openhab.binding.jablotron.internal.model.JablotronServiceDetailSegmentInfo;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link JablotronJa100Handler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Ondrej Pecta - Initial contribution\n+ */\n+@NonNullByDefault\n+public class JablotronJa100Handler extends JablotronAlarmHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(JablotronJa100Handler.class);\n+\n+    public JablotronJa100Handler(Thing thing, String alarmName) {\n+        super(thing, alarmName);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (channelUID.getId().startsWith(\"STATE_\") && command instanceof StringType) {\n+            scheduler.execute(() -> {\n+                controlSTATESection(channelUID.getId(), command.toString());\n+            });\n+        }\n+\n+        if (channelUID.getId().startsWith(\"PGM_\") && command instanceof OnOffType) {\n+            scheduler.execute(() -> {\n+                controlPGMSection(channelUID.getId(), command.equals(OnOffType.ON) ? \"set\" : \"unset\");\n+            });\n+        }\n+    }\n+\n+    private void createChannel(JablotronServiceDetailSegment section) {\n+        if (section.getSegmentId().startsWith(\"PGM_\")) {\n+            createPGMChannel(section.getSegmentId(), section.getSegmentName());\n+        } else {\n+            createStateChannel(section.getSegmentId(), section.getSegmentName());\n+        }\n+    }\n+\n+    private void createTempChannel(String name, String label) {\n+        ChannelTypeUID temperature = new ChannelTypeUID(\"jablotron\", \"temperature\");\n+        ThingBuilder thingBuilder = editThing();\n+        Channel channel = ChannelBuilder.create(new ChannelUID(thing.getUID(), name), \"Number:Temperature\").withLabel(label).withType(temperature).build();\n+        thingBuilder.withChannel(channel);\n+        updateThing(thingBuilder.build());\n+    }\n+\n+    private void createThermostatChannel(String name, String label) {\n+        ChannelTypeUID temperature = new ChannelTypeUID(\"jablotron\", \"thermostat\");\n+        ThingBuilder thingBuilder = editThing();\n+        Channel channel = ChannelBuilder.create(new ChannelUID(thing.getUID(), name), \"Number:Temperature\").withLabel(label).withType(temperature).build();\n+        thingBuilder.withChannel(channel);\n+        updateThing(thingBuilder.build());\n+    }\n+\n+    private void createPGMChannel(String name, String label) {\n+        ThingBuilder thingBuilder = editThing();\n+        Channel channel = ChannelBuilder.create(new ChannelUID(thing.getUID(), name), \"Switch\").withLabel(label).build();\n+        thingBuilder.withChannel(channel);\n+        updateThing(thingBuilder.build());\n+    }\n+\n+    private void createStateChannel(String name, String label) {\n+        ChannelTypeUID alarmStatus = new ChannelTypeUID(\"jablotron\", \"alarm_state\");\n+        ThingBuilder thingBuilder = editThing();\n+        Channel channel = ChannelBuilder.create(new ChannelUID(thing.getUID(), name), \"String\").withLabel(label).withType(alarmStatus).build();\n+        thingBuilder.withChannel(channel);\n+        updateThing(thingBuilder.build());\n+    }\n+\n+    @Override\n+    protected void updateSegmentStatus(JablotronServiceDetailSegment segment) {\n+        logger.debug(\"Segment id: {} and status: {}\", segment.getSegmentId(), segment.getSegmentState());\n+        String segmentId = segment.getSegmentId();\n+\n+        if (segmentId.startsWith(\"STATE_\") || segmentId.startsWith(\"PGM_\")) {\n+            processSection(segment);\n+        } else if (segmentId.startsWith(\"THERMOMETER_\")) {\n+            processThermometer(segment);\n+        } else if (segmentId.startsWith(\"THERMOSTAT_\")) {\n+            processThermostat(segment);\n+        }\n+        else {\n+            logger.debug(\"Unknown segment received: {} with state: {}\", segment.getSegmentId(), segment.getSegmentState());\n+        }\n+    }\n+\n+    private void processSection(JablotronServiceDetailSegment segment) {\n+        String segmentId = segment.getSegmentId();\n+        Channel channel = getThing().getChannel(segmentId);\n+        if (channel == null) {\n+            logger.debug(\"Creating a new channel: {}\", segmentId);\n+            createChannel(segment);\n+        }\n+        channel = getThing().getChannel(segmentId);\n+        if (channel != null) {\n+            logger.debug(\"Updating channel: {} to value: {}\", channel.getUID(), segment.getSegmentState());\n+            State newState;\n+            if (segmentId.startsWith(\"PGM_\")) {\n+                newState = \"unset\".equals(segment.getSegmentState()) ? OnOffType.OFF : OnOffType.ON;\n+            } else {\n+                newState = new StringType(segment.getSegmentState());\n+            }\n+            updateState(channel.getUID(), newState);\n+        } else {\n+            logger.debug(\"The channel: {} still doesn't exist!\", segmentId);\n+        }\n+    }\n+\n+    private void processThermometer(JablotronServiceDetailSegment segment) {\n+        String segmentId = segment.getSegmentId();\n+        Channel channel = getThing().getChannel(segmentId);\n+        if (channel == null) {\n+            logger.debug(\"Creating a new temperature channel: {}\", segmentId);\n+            createTempChannel(segmentId, segment.getSegmentName());\n+        }\n+        updateTemperatureChannel(channel, segment);\n+    }\n+\n+    private void processThermostat(JablotronServiceDetailSegment segment) {\n+        String segmentId = segment.getSegmentId();\n+        Channel channel = getThing().getChannel(segmentId);\n+        if (channel == null) {\n+            logger.debug(\"Creating a new thermostat channel: {}\", segmentId);\n+            createThermostatChannel(segmentId, segment.getSegmentName());\n+        }\n+        updateTemperatureChannel(channel, segment);\n+    }\n+\n+    private void updateTemperatureChannel(Channel channel, JablotronServiceDetailSegment segment) {\n+        String segmentId = segment.getSegmentId();\n+        if (channel != null) {\n+            List<JablotronServiceDetailSegmentInfo> infos = segment.getSegmentInfos();\n+            if (infos.size() > 0) {\n+                logger.debug(\"Found value: {} and type: {}\", infos.get(0).getValue(), infos.get(0).getType());\n+                DecimalType newState = new DecimalType(infos.get(0).getValue());\n+                updateState(channel.getUID(), newState);\n+            } else {\n+                logger.debug(\"No segment information received\");\n+            }\n+        } else {\n+            logger.debug(\"The channel: {} still doesn't exist!\", segmentId);\n+        }\n+    }\n+\n+    public synchronized void controlPGMSection(String section, String status) {\n+        logger.debug(\"Controlling section: {} with status: {}\", section, status);\n+        JablotronControlResponse response = sendUserCode(section, section.toLowerCase(), status, thingConfig.getCode());\n+\n+        updateAlarmStatus();\n+        if (response == null) {\n+            logger.debug(\"null response/status received\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mzc5NDYwMA=="}, "originalCommit": {"oid": "36775963f2d1f6fd1e9689f06b070bfa8e6a859e"}, "originalPosition": 185}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAyNTA2MDU0OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.jablotron/src/main/java/org/openhab/binding/jablotron/internal/handler/JablotronBridgeHandler.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNFQxODo1Mzo0N1rOHNYkLg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNlQxOTozODozNlrOHNrg8A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mzc5NjAxNA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                ScheduledFuture<?> future = null;\n          \n          \n            \n                @Nullable ScheduledFuture<?> future = null;", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r483796014", "createdAt": "2020-09-04T18:53:47Z", "author": {"login": "Hilbrand"}, "path": "bundles/org.openhab.binding.jablotron/src/main/java/org/openhab/binding/jablotron/internal/handler/JablotronBridgeHandler.java", "diffHunk": "@@ -0,0 +1,452 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.jablotron.internal.handler;\n+\n+import static org.openhab.binding.jablotron.JablotronBindingConstants.*;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.JsonSyntaxException;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.eclipse.jetty.http.HttpHeader;\n+import org.eclipse.jetty.http.HttpMethod;\n+import org.eclipse.smarthome.config.core.status.ConfigStatusMessage;\n+import org.eclipse.smarthome.core.thing.*;\n+import org.eclipse.smarthome.core.thing.binding.ConfigStatusBridgeHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.openhab.binding.jablotron.internal.config.JablotronBridgeConfig;\n+import org.openhab.binding.jablotron.internal.model.*;\n+import org.openhab.binding.jablotron.internal.model.ja100f.JablotronGetPGResponse;\n+import org.openhab.binding.jablotron.internal.model.ja100f.JablotronGetSectionsResponse;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link JablotronBridgeHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Ondrej Pecta - Initial contribution\n+ */\n+@NonNullByDefault\n+public class JablotronBridgeHandler extends ConfigStatusBridgeHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(JablotronBridgeHandler.class);\n+\n+    private Gson gson = new Gson();\n+\n+    final HttpClient httpClient;\n+\n+    @Nullable\n+    ScheduledFuture<?> future = null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "36775963f2d1f6fd1e9689f06b070bfa8e6a859e"}, "originalPosition": 63}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDEwNjQ4MA==", "bodyText": "fixed", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r484106480", "createdAt": "2020-09-06T19:38:36Z", "author": {"login": "octa22"}, "path": "bundles/org.openhab.binding.jablotron/src/main/java/org/openhab/binding/jablotron/internal/handler/JablotronBridgeHandler.java", "diffHunk": "@@ -0,0 +1,452 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.jablotron.internal.handler;\n+\n+import static org.openhab.binding.jablotron.JablotronBindingConstants.*;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.JsonSyntaxException;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.eclipse.jetty.http.HttpHeader;\n+import org.eclipse.jetty.http.HttpMethod;\n+import org.eclipse.smarthome.config.core.status.ConfigStatusMessage;\n+import org.eclipse.smarthome.core.thing.*;\n+import org.eclipse.smarthome.core.thing.binding.ConfigStatusBridgeHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.openhab.binding.jablotron.internal.config.JablotronBridgeConfig;\n+import org.openhab.binding.jablotron.internal.model.*;\n+import org.openhab.binding.jablotron.internal.model.ja100f.JablotronGetPGResponse;\n+import org.openhab.binding.jablotron.internal.model.ja100f.JablotronGetSectionsResponse;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link JablotronBridgeHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Ondrej Pecta - Initial contribution\n+ */\n+@NonNullByDefault\n+public class JablotronBridgeHandler extends ConfigStatusBridgeHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(JablotronBridgeHandler.class);\n+\n+    private Gson gson = new Gson();\n+\n+    final HttpClient httpClient;\n+\n+    @Nullable\n+    ScheduledFuture<?> future = null;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mzc5NjAxNA=="}, "originalCommit": {"oid": "36775963f2d1f6fd1e9689f06b070bfa8e6a859e"}, "originalPosition": 63}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAyNTA2MDgyOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.jablotron/src/main/java/org/openhab/binding/jablotron/internal/handler/JablotronBridgeHandler.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNFQxODo1Mzo1OFrOHNYkXw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNlQxOTo0MTo0NVrOHNrh2w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mzc5NjA2Mw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private Gson gson = new Gson();\n          \n          \n            \n                private final Gson gson = new Gson();", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r483796063", "createdAt": "2020-09-04T18:53:58Z", "author": {"login": "Hilbrand"}, "path": "bundles/org.openhab.binding.jablotron/src/main/java/org/openhab/binding/jablotron/internal/handler/JablotronBridgeHandler.java", "diffHunk": "@@ -0,0 +1,452 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.jablotron.internal.handler;\n+\n+import static org.openhab.binding.jablotron.JablotronBindingConstants.*;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.JsonSyntaxException;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.eclipse.jetty.http.HttpHeader;\n+import org.eclipse.jetty.http.HttpMethod;\n+import org.eclipse.smarthome.config.core.status.ConfigStatusMessage;\n+import org.eclipse.smarthome.core.thing.*;\n+import org.eclipse.smarthome.core.thing.binding.ConfigStatusBridgeHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.openhab.binding.jablotron.internal.config.JablotronBridgeConfig;\n+import org.openhab.binding.jablotron.internal.model.*;\n+import org.openhab.binding.jablotron.internal.model.ja100f.JablotronGetPGResponse;\n+import org.openhab.binding.jablotron.internal.model.ja100f.JablotronGetSectionsResponse;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link JablotronBridgeHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Ondrej Pecta - Initial contribution\n+ */\n+@NonNullByDefault\n+public class JablotronBridgeHandler extends ConfigStatusBridgeHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(JablotronBridgeHandler.class);\n+\n+    private Gson gson = new Gson();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "36775963f2d1f6fd1e9689f06b070bfa8e6a859e"}, "originalPosition": 58}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDEwNjcxNQ==", "bodyText": "added final", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r484106715", "createdAt": "2020-09-06T19:41:45Z", "author": {"login": "octa22"}, "path": "bundles/org.openhab.binding.jablotron/src/main/java/org/openhab/binding/jablotron/internal/handler/JablotronBridgeHandler.java", "diffHunk": "@@ -0,0 +1,452 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.jablotron.internal.handler;\n+\n+import static org.openhab.binding.jablotron.JablotronBindingConstants.*;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.JsonSyntaxException;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.eclipse.jetty.http.HttpHeader;\n+import org.eclipse.jetty.http.HttpMethod;\n+import org.eclipse.smarthome.config.core.status.ConfigStatusMessage;\n+import org.eclipse.smarthome.core.thing.*;\n+import org.eclipse.smarthome.core.thing.binding.ConfigStatusBridgeHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.openhab.binding.jablotron.internal.config.JablotronBridgeConfig;\n+import org.openhab.binding.jablotron.internal.model.*;\n+import org.openhab.binding.jablotron.internal.model.ja100f.JablotronGetPGResponse;\n+import org.openhab.binding.jablotron.internal.model.ja100f.JablotronGetSectionsResponse;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link JablotronBridgeHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Ondrej Pecta - Initial contribution\n+ */\n+@NonNullByDefault\n+public class JablotronBridgeHandler extends ConfigStatusBridgeHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(JablotronBridgeHandler.class);\n+\n+    private Gson gson = new Gson();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mzc5NjA2Mw=="}, "originalCommit": {"oid": "36775963f2d1f6fd1e9689f06b070bfa8e6a859e"}, "originalPosition": 58}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAyNTA2NDM5OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.jablotron/src/main/java/org/openhab/binding/jablotron/internal/handler/JablotronBridgeHandler.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNFQxODo1NTowOFrOHNYmbA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNlQxOTo0MDoxNFrOHNrhcA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mzc5NjU4OA==", "bodyText": "Is this necessay to override?. Same for disposed method?", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r483796588", "createdAt": "2020-09-04T18:55:08Z", "author": {"login": "Hilbrand"}, "path": "bundles/org.openhab.binding.jablotron/src/main/java/org/openhab/binding/jablotron/internal/handler/JablotronBridgeHandler.java", "diffHunk": "@@ -0,0 +1,452 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.jablotron.internal.handler;\n+\n+import static org.openhab.binding.jablotron.JablotronBindingConstants.*;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.JsonSyntaxException;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.eclipse.jetty.http.HttpHeader;\n+import org.eclipse.jetty.http.HttpMethod;\n+import org.eclipse.smarthome.config.core.status.ConfigStatusMessage;\n+import org.eclipse.smarthome.core.thing.*;\n+import org.eclipse.smarthome.core.thing.binding.ConfigStatusBridgeHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.openhab.binding.jablotron.internal.config.JablotronBridgeConfig;\n+import org.openhab.binding.jablotron.internal.model.*;\n+import org.openhab.binding.jablotron.internal.model.ja100f.JablotronGetPGResponse;\n+import org.openhab.binding.jablotron.internal.model.ja100f.JablotronGetSectionsResponse;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link JablotronBridgeHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Ondrej Pecta - Initial contribution\n+ */\n+@NonNullByDefault\n+public class JablotronBridgeHandler extends ConfigStatusBridgeHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(JablotronBridgeHandler.class);\n+\n+    private Gson gson = new Gson();\n+\n+    final HttpClient httpClient;\n+\n+    @Nullable\n+    ScheduledFuture<?> future = null;\n+\n+    /**\n+     * Our configuration\n+     */\n+    public JablotronBridgeConfig bridgeConfig = new JablotronBridgeConfig();\n+\n+    public JablotronBridgeHandler(Bridge thing, HttpClient httpClient) {\n+        super(thing);\n+        this.httpClient = httpClient;\n+    }\n+\n+    @Override\n+    public Collection<ConfigStatusMessage> getConfigStatus() {\n+        return Collections.emptyList();\n+    }\n+\n+    @Override\n+    public void childHandlerInitialized(ThingHandler thingHandler, Thing thing) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "36775963f2d1f6fd1e9689f06b070bfa8e6a859e"}, "originalPosition": 81}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDEwNjYwOA==", "bodyText": "removed, you were right, not necessary", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r484106608", "createdAt": "2020-09-06T19:40:14Z", "author": {"login": "octa22"}, "path": "bundles/org.openhab.binding.jablotron/src/main/java/org/openhab/binding/jablotron/internal/handler/JablotronBridgeHandler.java", "diffHunk": "@@ -0,0 +1,452 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.jablotron.internal.handler;\n+\n+import static org.openhab.binding.jablotron.JablotronBindingConstants.*;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.JsonSyntaxException;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.eclipse.jetty.http.HttpHeader;\n+import org.eclipse.jetty.http.HttpMethod;\n+import org.eclipse.smarthome.config.core.status.ConfigStatusMessage;\n+import org.eclipse.smarthome.core.thing.*;\n+import org.eclipse.smarthome.core.thing.binding.ConfigStatusBridgeHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.openhab.binding.jablotron.internal.config.JablotronBridgeConfig;\n+import org.openhab.binding.jablotron.internal.model.*;\n+import org.openhab.binding.jablotron.internal.model.ja100f.JablotronGetPGResponse;\n+import org.openhab.binding.jablotron.internal.model.ja100f.JablotronGetSectionsResponse;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link JablotronBridgeHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Ondrej Pecta - Initial contribution\n+ */\n+@NonNullByDefault\n+public class JablotronBridgeHandler extends ConfigStatusBridgeHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(JablotronBridgeHandler.class);\n+\n+    private Gson gson = new Gson();\n+\n+    final HttpClient httpClient;\n+\n+    @Nullable\n+    ScheduledFuture<?> future = null;\n+\n+    /**\n+     * Our configuration\n+     */\n+    public JablotronBridgeConfig bridgeConfig = new JablotronBridgeConfig();\n+\n+    public JablotronBridgeHandler(Bridge thing, HttpClient httpClient) {\n+        super(thing);\n+        this.httpClient = httpClient;\n+    }\n+\n+    @Override\n+    public Collection<ConfigStatusMessage> getConfigStatus() {\n+        return Collections.emptyList();\n+    }\n+\n+    @Override\n+    public void childHandlerInitialized(ThingHandler thingHandler, Thing thing) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mzc5NjU4OA=="}, "originalCommit": {"oid": "36775963f2d1f6fd1e9689f06b070bfa8e6a859e"}, "originalPosition": 81}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAyNTEwMzMzOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.jablotron/src/main/java/org/openhab/binding/jablotron/internal/handler/JablotronBridgeHandler.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNFQxOToxMDoxMVrOHNY9gQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNlQyMDoyMDo0NVrOHNru1Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzgwMjQ5Nw==", "bodyText": "The design you have used here is that a thing id represents a identiffier. However, convention is that the id of a thing should not be used, but can freely be defined by the user. The design should be that the serviceId is a parameter of a thing.", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r483802497", "createdAt": "2020-09-04T19:10:11Z", "author": {"login": "Hilbrand"}, "path": "bundles/org.openhab.binding.jablotron/src/main/java/org/openhab/binding/jablotron/internal/handler/JablotronBridgeHandler.java", "diffHunk": "@@ -0,0 +1,452 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.jablotron.internal.handler;\n+\n+import static org.openhab.binding.jablotron.JablotronBindingConstants.*;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.JsonSyntaxException;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.eclipse.jetty.http.HttpHeader;\n+import org.eclipse.jetty.http.HttpMethod;\n+import org.eclipse.smarthome.config.core.status.ConfigStatusMessage;\n+import org.eclipse.smarthome.core.thing.*;\n+import org.eclipse.smarthome.core.thing.binding.ConfigStatusBridgeHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.openhab.binding.jablotron.internal.config.JablotronBridgeConfig;\n+import org.openhab.binding.jablotron.internal.model.*;\n+import org.openhab.binding.jablotron.internal.model.ja100f.JablotronGetPGResponse;\n+import org.openhab.binding.jablotron.internal.model.ja100f.JablotronGetSectionsResponse;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link JablotronBridgeHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Ondrej Pecta - Initial contribution\n+ */\n+@NonNullByDefault\n+public class JablotronBridgeHandler extends ConfigStatusBridgeHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(JablotronBridgeHandler.class);\n+\n+    private Gson gson = new Gson();\n+\n+    final HttpClient httpClient;\n+\n+    @Nullable\n+    ScheduledFuture<?> future = null;\n+\n+    /**\n+     * Our configuration\n+     */\n+    public JablotronBridgeConfig bridgeConfig = new JablotronBridgeConfig();\n+\n+    public JablotronBridgeHandler(Bridge thing, HttpClient httpClient) {\n+        super(thing);\n+        this.httpClient = httpClient;\n+    }\n+\n+    @Override\n+    public Collection<ConfigStatusMessage> getConfigStatus() {\n+        return Collections.emptyList();\n+    }\n+\n+    @Override\n+    public void childHandlerInitialized(ThingHandler thingHandler, Thing thing) {\n+    }\n+\n+    @Override\n+    public void childHandlerDisposed(ThingHandler thingHandler, Thing thing) {\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        bridgeConfig = getConfigAs(JablotronBridgeConfig.class);\n+        scheduler.execute(this::login);\n+        future = scheduler.scheduleWithFixedDelay(() -> updateAlarmThings(), 30, bridgeConfig.getRefresh(), TimeUnit.SECONDS);\n+    }\n+\n+    private void updateAlarmThings() {\n+        List<JablotronDiscoveredService> services = discoverServices();\n+        if (services != null) {\n+            for (JablotronDiscoveredService service : services) {\n+                updateAlarmThing(service);\n+            }\n+        }\n+    }\n+\n+    private void updateAlarmThing(JablotronDiscoveredService service) {\n+        for (Thing th : getThing().getThings()) {\n+            if (String.valueOf(service.getId()).equals(th.getUID().getId())) {\n+                JablotronAlarmHandler handler = (JablotronAlarmHandler) th.getHandler();\n+                if (handler == null) {\n+                    logger.debug(\"Thing handler is null\");\n+                    continue;\n+                }\n+                if (\"ENABLED\".equals(service.getStatus())) {\n+                    if (!\"\".equals(service.getWarning())) {\n+                        logger.debug(\"Alarm with service id: {} warning: {}\", service.getId(), service.getWarning());\n+                    }\n+                    handler.setStatus(ThingStatus.ONLINE, ThingStatusDetail.NONE, service.getWarning());\n+                    if (\"ALARM\".equals(service.getWarning()) || \"TAMPER\".equals(service.getWarning())) {\n+                        handler.triggerAlarm(service);\n+                    }\n+                    handler.setInService(\"SERVICE\".equals(service.getWarning()));\n+                } else {\n+                    logger.debug(\"Alarm with service id: {} is offline\", service.getId());\n+                    handler.setStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, service.getStatus());\n+                }\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        super.dispose();\n+        if (future != null) {\n+            future.cancel(true);\n+        }\n+        logout();\n+    }\n+\n+    protected synchronized void login() {\n+        try {\n+            String url = JABLOTRON_API_URL + \"userAuthorize.json\";\n+            String urlParameters = \"{\\\"login\\\":\\\"\" + bridgeConfig.getLogin() + \"\\\", \\\"password\\\":\\\"\" + bridgeConfig.getPassword() + \"\\\"}\";\n+\n+            ContentResponse resp = createRequest(url)\n+                    .header(HttpHeader.ACCEPT, APPLICATION_JSON)\n+                    .content(new StringContentProvider(urlParameters), APPLICATION_JSON)\n+                    .send();\n+\n+            String line = resp.getContentAsString();\n+            logger.trace(\"login response: {}\", line);\n+            JablotronLoginResponse response = gson.fromJson(line, JablotronLoginResponse.class);\n+            if (response.getHttpCode() != 200) {\n+                logger.debug(\"Error during login, got http error: {}\", response.getHttpCode());\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, \"Http error: \" + String.valueOf(response.getHttpCode()));\n+            } else {\n+                logger.debug(\"Successfully logged in\");\n+                updateStatus(ThingStatus.ONLINE);\n+            }\n+        } catch (TimeoutException e) {\n+            logger.debug(\"Timeout during getting login cookie\", e);\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, \"Cannot login to Jablonet cloud\");\n+        } catch (ExecutionException | InterruptedException | JsonSyntaxException e) {\n+            logger.debug(\"Cannot get Jablotron login cookie\", e);\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, \"Cannot login to Jablonet cloud\");\n+        }\n+    }\n+\n+    protected synchronized void logout() {\n+        String url = JABLOTRON_API_URL + \"logout.json\";\n+        String urlParameters = \"system=\" + SYSTEM;\n+\n+        try {\n+            ContentResponse resp = createRequest(url)\n+                    .content(new StringContentProvider(urlParameters), \"application/x-www-form-urlencoded; charset=UTF-8\")\n+                    .send();\n+            String line = resp.getContentAsString();\n+\n+            logger.trace(\"logout response: {}\", line);\n+        } catch (ExecutionException | TimeoutException | InterruptedException e) {\n+            //Silence\n+        }\n+    }\n+\n+    public synchronized @Nullable List<JablotronDiscoveredService> discoverServices() {\n+        try {\n+            String url = JABLOTRON_API_URL + \"serviceListGet.json\";\n+            String urlParameters = \"{\\\"list-type\\\": \\\"EXTENDED\\\",\\\"visibility\\\": \\\"VISIBLE\\\"}\";\n+\n+            ContentResponse resp = createRequest(url)\n+                    .header(HttpHeader.ACCEPT, APPLICATION_JSON)\n+                    .content(new StringContentProvider(urlParameters), APPLICATION_JSON)\n+                    .send();\n+\n+            String line = resp.getContentAsString();\n+\n+            logger.trace(\"Response: {}\", line);\n+            JablotronGetServiceResponse response = gson.fromJson(line, JablotronGetServiceResponse.class);\n+\n+            if (response.getHttpCode() != 200) {\n+                logger.debug(\"Error during service discovery, got http code: {}\", response.getHttpCode());\n+            }\n+\n+            return response.getData().getServices();\n+        } catch (TimeoutException e) {\n+            logger.debug(\"Timeout during discovering services\", e);\n+        } catch (InterruptedException e) {\n+            logger.debug(\"Error during discovering services\", e);\n+        } catch (JsonSyntaxException e) {\n+            logger.debug(\"JSON syntax exception\", e);\n+        } catch (ExecutionException e) {\n+            if (e.getMessage().contains(AUTHENTICATION_CHALLENGE)) {\n+                relogin();\n+            } else {\n+                logger.debug(\"Error during discovering services\", e);\n+            }\n+        }\n+        return null;\n+    }\n+\n+    protected synchronized @Nullable JablotronControlResponse sendUserCode(Thing th, String section, String key, String status, String code) throws SecurityException {\n+        String url;\n+        JablotronAlarmHandler handler = (JablotronAlarmHandler) th.getHandler();\n+\n+        if (handler == null) {\n+            logger.debug(\"Thing handler is null\");\n+            return null;\n+        }\n+\n+        if (handler.isInService()) {\n+            logger.debug(\"Cannot send command because the alarm is in the service mode\");\n+            return null;\n+        }\n+\n+        try {\n+            url = JABLOTRON_API_URL + \"controlSegment.json\";\n+            String urlParameters = \"service=\" + th.getThingTypeUID().getId() + \"&serviceId=\" + th.getUID().getId() + \"&segmentId=\" + section + \"&segmentKey=\" + key + \"&expected_status=\" + status + \"&control_time=0&control_code=\" + code + \"&system=\" + SYSTEM;\n+            logger.debug(\"Sending POST to url address: {} to control section: {}\", url, section);\n+            logger.trace(\"Url parameters: {}\", urlParameters);\n+\n+            ContentResponse resp = createRequest(url)\n+                    .content(new StringContentProvider(urlParameters), \"application/x-www-form-urlencoded; charset=UTF-8\")\n+                    .send();\n+\n+            String line = resp.getContentAsString();\n+\n+            logger.trace(\"Control response: {}\", line);\n+            JablotronControlResponse response = gson.fromJson(line, JablotronControlResponse.class);\n+            if (!response.isStatus()) {\n+                logger.debug(\"Error during sending user code: {}\", response.getErrorMessage());\n+            }\n+            return response;\n+        } catch (TimeoutException e) {\n+            logger.debug(\"sendUserCode timeout exception\", e);\n+        } catch (InterruptedException e) {\n+            logger.debug(\"sendUserCode exception\", e);\n+        } catch (JsonSyntaxException e) {\n+            logger.debug(\"JSON syntax exception\", e);\n+        } catch (ExecutionException e) {\n+            if (e.getMessage().contains(AUTHENTICATION_CHALLENGE)) {\n+                relogin();\n+                throw new SecurityException(AUTHENTICATION_CHALLENGE);\n+            } else {\n+                logger.debug(\"sendUserCode exception\", e);\n+            }\n+        }\n+        return null;\n+    }\n+\n+    protected synchronized @Nullable List<JablotronHistoryDataEvent> sendGetEventHistory(Thing th, String alarm) {\n+        String url = JABLOTRON_API_URL + alarm + \"/eventHistoryGet.json\";\n+        String urlParameters = \"{\\\"limit\\\":1, \\\"service-id\\\":\" + th.getUID().getId() + \"}\";\n+\n+        try {\n+            ContentResponse resp = createRequest(url)\n+                    .header(HttpHeader.ACCEPT, APPLICATION_JSON)\n+                    .content(new StringContentProvider(urlParameters), APPLICATION_JSON)\n+                    .send();\n+\n+            String line = resp.getContentAsString();\n+            logger.trace(\"get event history: {}\", line);\n+            JablotronGetEventHistoryResponse response = gson.fromJson(line, JablotronGetEventHistoryResponse.class);\n+            if (200 != response.getHttpCode()) {\n+                logger.debug(\"Got error while getting history with http code: {}\", response.getHttpCode());\n+            }\n+            return response.getData().getEvents();\n+        } catch (TimeoutException e) {\n+            logger.debug(\"Timeout during getting alarm history!\", e);\n+        } catch (InterruptedException e) {\n+            logger.debug(\"sendGetEventHistory exception\", e);\n+        } catch (JsonSyntaxException e) {\n+            logger.debug(\"JSON syntax exception\", e);\n+        } catch (ExecutionException e) {\n+            if (e.getMessage().contains(AUTHENTICATION_CHALLENGE)) {\n+                relogin();\n+            } else {\n+                logger.debug(\"sendGetEventHistory exception\", e);\n+            }\n+        }\n+        return null;\n+    }\n+\n+    protected synchronized @Nullable JablotronDataUpdateResponse sendGetStatusRequest(Thing th) {\n+        String url = JABLOTRON_API_URL + \"dataUpdate.json\";\n+        String urlParameters = \"data=[{ \\\"filter_data\\\":[{\\\"data_type\\\":\\\"section\\\"},{\\\"data_type\\\":\\\"pgm\\\"},{\\\"data_type\\\":\\\"thermometer\\\"},{\\\"data_type\\\":\\\"thermostat\\\"}],\\\"service_type\\\":\\\"\" + th.getThingTypeUID().getId() + \"\\\",\\\"service_id\\\":\" + th.getUID().getId() + \",\\\"data_group\\\":\\\"serviceData\\\"}]&system=\" + SYSTEM;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "36775963f2d1f6fd1e9689f06b070bfa8e6a859e"}, "originalPosition": 307}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDExMDAzNw==", "bodyText": "OK, changed design so the serviceId is a parameter of the thing", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r484110037", "createdAt": "2020-09-06T20:20:45Z", "author": {"login": "octa22"}, "path": "bundles/org.openhab.binding.jablotron/src/main/java/org/openhab/binding/jablotron/internal/handler/JablotronBridgeHandler.java", "diffHunk": "@@ -0,0 +1,452 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.jablotron.internal.handler;\n+\n+import static org.openhab.binding.jablotron.JablotronBindingConstants.*;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.JsonSyntaxException;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.eclipse.jetty.http.HttpHeader;\n+import org.eclipse.jetty.http.HttpMethod;\n+import org.eclipse.smarthome.config.core.status.ConfigStatusMessage;\n+import org.eclipse.smarthome.core.thing.*;\n+import org.eclipse.smarthome.core.thing.binding.ConfigStatusBridgeHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.openhab.binding.jablotron.internal.config.JablotronBridgeConfig;\n+import org.openhab.binding.jablotron.internal.model.*;\n+import org.openhab.binding.jablotron.internal.model.ja100f.JablotronGetPGResponse;\n+import org.openhab.binding.jablotron.internal.model.ja100f.JablotronGetSectionsResponse;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link JablotronBridgeHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Ondrej Pecta - Initial contribution\n+ */\n+@NonNullByDefault\n+public class JablotronBridgeHandler extends ConfigStatusBridgeHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(JablotronBridgeHandler.class);\n+\n+    private Gson gson = new Gson();\n+\n+    final HttpClient httpClient;\n+\n+    @Nullable\n+    ScheduledFuture<?> future = null;\n+\n+    /**\n+     * Our configuration\n+     */\n+    public JablotronBridgeConfig bridgeConfig = new JablotronBridgeConfig();\n+\n+    public JablotronBridgeHandler(Bridge thing, HttpClient httpClient) {\n+        super(thing);\n+        this.httpClient = httpClient;\n+    }\n+\n+    @Override\n+    public Collection<ConfigStatusMessage> getConfigStatus() {\n+        return Collections.emptyList();\n+    }\n+\n+    @Override\n+    public void childHandlerInitialized(ThingHandler thingHandler, Thing thing) {\n+    }\n+\n+    @Override\n+    public void childHandlerDisposed(ThingHandler thingHandler, Thing thing) {\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        bridgeConfig = getConfigAs(JablotronBridgeConfig.class);\n+        scheduler.execute(this::login);\n+        future = scheduler.scheduleWithFixedDelay(() -> updateAlarmThings(), 30, bridgeConfig.getRefresh(), TimeUnit.SECONDS);\n+    }\n+\n+    private void updateAlarmThings() {\n+        List<JablotronDiscoveredService> services = discoverServices();\n+        if (services != null) {\n+            for (JablotronDiscoveredService service : services) {\n+                updateAlarmThing(service);\n+            }\n+        }\n+    }\n+\n+    private void updateAlarmThing(JablotronDiscoveredService service) {\n+        for (Thing th : getThing().getThings()) {\n+            if (String.valueOf(service.getId()).equals(th.getUID().getId())) {\n+                JablotronAlarmHandler handler = (JablotronAlarmHandler) th.getHandler();\n+                if (handler == null) {\n+                    logger.debug(\"Thing handler is null\");\n+                    continue;\n+                }\n+                if (\"ENABLED\".equals(service.getStatus())) {\n+                    if (!\"\".equals(service.getWarning())) {\n+                        logger.debug(\"Alarm with service id: {} warning: {}\", service.getId(), service.getWarning());\n+                    }\n+                    handler.setStatus(ThingStatus.ONLINE, ThingStatusDetail.NONE, service.getWarning());\n+                    if (\"ALARM\".equals(service.getWarning()) || \"TAMPER\".equals(service.getWarning())) {\n+                        handler.triggerAlarm(service);\n+                    }\n+                    handler.setInService(\"SERVICE\".equals(service.getWarning()));\n+                } else {\n+                    logger.debug(\"Alarm with service id: {} is offline\", service.getId());\n+                    handler.setStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, service.getStatus());\n+                }\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        super.dispose();\n+        if (future != null) {\n+            future.cancel(true);\n+        }\n+        logout();\n+    }\n+\n+    protected synchronized void login() {\n+        try {\n+            String url = JABLOTRON_API_URL + \"userAuthorize.json\";\n+            String urlParameters = \"{\\\"login\\\":\\\"\" + bridgeConfig.getLogin() + \"\\\", \\\"password\\\":\\\"\" + bridgeConfig.getPassword() + \"\\\"}\";\n+\n+            ContentResponse resp = createRequest(url)\n+                    .header(HttpHeader.ACCEPT, APPLICATION_JSON)\n+                    .content(new StringContentProvider(urlParameters), APPLICATION_JSON)\n+                    .send();\n+\n+            String line = resp.getContentAsString();\n+            logger.trace(\"login response: {}\", line);\n+            JablotronLoginResponse response = gson.fromJson(line, JablotronLoginResponse.class);\n+            if (response.getHttpCode() != 200) {\n+                logger.debug(\"Error during login, got http error: {}\", response.getHttpCode());\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, \"Http error: \" + String.valueOf(response.getHttpCode()));\n+            } else {\n+                logger.debug(\"Successfully logged in\");\n+                updateStatus(ThingStatus.ONLINE);\n+            }\n+        } catch (TimeoutException e) {\n+            logger.debug(\"Timeout during getting login cookie\", e);\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, \"Cannot login to Jablonet cloud\");\n+        } catch (ExecutionException | InterruptedException | JsonSyntaxException e) {\n+            logger.debug(\"Cannot get Jablotron login cookie\", e);\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, \"Cannot login to Jablonet cloud\");\n+        }\n+    }\n+\n+    protected synchronized void logout() {\n+        String url = JABLOTRON_API_URL + \"logout.json\";\n+        String urlParameters = \"system=\" + SYSTEM;\n+\n+        try {\n+            ContentResponse resp = createRequest(url)\n+                    .content(new StringContentProvider(urlParameters), \"application/x-www-form-urlencoded; charset=UTF-8\")\n+                    .send();\n+            String line = resp.getContentAsString();\n+\n+            logger.trace(\"logout response: {}\", line);\n+        } catch (ExecutionException | TimeoutException | InterruptedException e) {\n+            //Silence\n+        }\n+    }\n+\n+    public synchronized @Nullable List<JablotronDiscoveredService> discoverServices() {\n+        try {\n+            String url = JABLOTRON_API_URL + \"serviceListGet.json\";\n+            String urlParameters = \"{\\\"list-type\\\": \\\"EXTENDED\\\",\\\"visibility\\\": \\\"VISIBLE\\\"}\";\n+\n+            ContentResponse resp = createRequest(url)\n+                    .header(HttpHeader.ACCEPT, APPLICATION_JSON)\n+                    .content(new StringContentProvider(urlParameters), APPLICATION_JSON)\n+                    .send();\n+\n+            String line = resp.getContentAsString();\n+\n+            logger.trace(\"Response: {}\", line);\n+            JablotronGetServiceResponse response = gson.fromJson(line, JablotronGetServiceResponse.class);\n+\n+            if (response.getHttpCode() != 200) {\n+                logger.debug(\"Error during service discovery, got http code: {}\", response.getHttpCode());\n+            }\n+\n+            return response.getData().getServices();\n+        } catch (TimeoutException e) {\n+            logger.debug(\"Timeout during discovering services\", e);\n+        } catch (InterruptedException e) {\n+            logger.debug(\"Error during discovering services\", e);\n+        } catch (JsonSyntaxException e) {\n+            logger.debug(\"JSON syntax exception\", e);\n+        } catch (ExecutionException e) {\n+            if (e.getMessage().contains(AUTHENTICATION_CHALLENGE)) {\n+                relogin();\n+            } else {\n+                logger.debug(\"Error during discovering services\", e);\n+            }\n+        }\n+        return null;\n+    }\n+\n+    protected synchronized @Nullable JablotronControlResponse sendUserCode(Thing th, String section, String key, String status, String code) throws SecurityException {\n+        String url;\n+        JablotronAlarmHandler handler = (JablotronAlarmHandler) th.getHandler();\n+\n+        if (handler == null) {\n+            logger.debug(\"Thing handler is null\");\n+            return null;\n+        }\n+\n+        if (handler.isInService()) {\n+            logger.debug(\"Cannot send command because the alarm is in the service mode\");\n+            return null;\n+        }\n+\n+        try {\n+            url = JABLOTRON_API_URL + \"controlSegment.json\";\n+            String urlParameters = \"service=\" + th.getThingTypeUID().getId() + \"&serviceId=\" + th.getUID().getId() + \"&segmentId=\" + section + \"&segmentKey=\" + key + \"&expected_status=\" + status + \"&control_time=0&control_code=\" + code + \"&system=\" + SYSTEM;\n+            logger.debug(\"Sending POST to url address: {} to control section: {}\", url, section);\n+            logger.trace(\"Url parameters: {}\", urlParameters);\n+\n+            ContentResponse resp = createRequest(url)\n+                    .content(new StringContentProvider(urlParameters), \"application/x-www-form-urlencoded; charset=UTF-8\")\n+                    .send();\n+\n+            String line = resp.getContentAsString();\n+\n+            logger.trace(\"Control response: {}\", line);\n+            JablotronControlResponse response = gson.fromJson(line, JablotronControlResponse.class);\n+            if (!response.isStatus()) {\n+                logger.debug(\"Error during sending user code: {}\", response.getErrorMessage());\n+            }\n+            return response;\n+        } catch (TimeoutException e) {\n+            logger.debug(\"sendUserCode timeout exception\", e);\n+        } catch (InterruptedException e) {\n+            logger.debug(\"sendUserCode exception\", e);\n+        } catch (JsonSyntaxException e) {\n+            logger.debug(\"JSON syntax exception\", e);\n+        } catch (ExecutionException e) {\n+            if (e.getMessage().contains(AUTHENTICATION_CHALLENGE)) {\n+                relogin();\n+                throw new SecurityException(AUTHENTICATION_CHALLENGE);\n+            } else {\n+                logger.debug(\"sendUserCode exception\", e);\n+            }\n+        }\n+        return null;\n+    }\n+\n+    protected synchronized @Nullable List<JablotronHistoryDataEvent> sendGetEventHistory(Thing th, String alarm) {\n+        String url = JABLOTRON_API_URL + alarm + \"/eventHistoryGet.json\";\n+        String urlParameters = \"{\\\"limit\\\":1, \\\"service-id\\\":\" + th.getUID().getId() + \"}\";\n+\n+        try {\n+            ContentResponse resp = createRequest(url)\n+                    .header(HttpHeader.ACCEPT, APPLICATION_JSON)\n+                    .content(new StringContentProvider(urlParameters), APPLICATION_JSON)\n+                    .send();\n+\n+            String line = resp.getContentAsString();\n+            logger.trace(\"get event history: {}\", line);\n+            JablotronGetEventHistoryResponse response = gson.fromJson(line, JablotronGetEventHistoryResponse.class);\n+            if (200 != response.getHttpCode()) {\n+                logger.debug(\"Got error while getting history with http code: {}\", response.getHttpCode());\n+            }\n+            return response.getData().getEvents();\n+        } catch (TimeoutException e) {\n+            logger.debug(\"Timeout during getting alarm history!\", e);\n+        } catch (InterruptedException e) {\n+            logger.debug(\"sendGetEventHistory exception\", e);\n+        } catch (JsonSyntaxException e) {\n+            logger.debug(\"JSON syntax exception\", e);\n+        } catch (ExecutionException e) {\n+            if (e.getMessage().contains(AUTHENTICATION_CHALLENGE)) {\n+                relogin();\n+            } else {\n+                logger.debug(\"sendGetEventHistory exception\", e);\n+            }\n+        }\n+        return null;\n+    }\n+\n+    protected synchronized @Nullable JablotronDataUpdateResponse sendGetStatusRequest(Thing th) {\n+        String url = JABLOTRON_API_URL + \"dataUpdate.json\";\n+        String urlParameters = \"data=[{ \\\"filter_data\\\":[{\\\"data_type\\\":\\\"section\\\"},{\\\"data_type\\\":\\\"pgm\\\"},{\\\"data_type\\\":\\\"thermometer\\\"},{\\\"data_type\\\":\\\"thermostat\\\"}],\\\"service_type\\\":\\\"\" + th.getThingTypeUID().getId() + \"\\\",\\\"service_id\\\":\" + th.getUID().getId() + \",\\\"data_group\\\":\\\"serviceData\\\"}]&system=\" + SYSTEM;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzgwMjQ5Nw=="}, "originalCommit": {"oid": "36775963f2d1f6fd1e9689f06b070bfa8e6a859e"}, "originalPosition": 307}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAzNDM2MDE3OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.jablotron/src/main/java/org/openhab/binding/jablotron/internal/JablotronHandlerFactory.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOFQxOTowOToxOFrOHOqcqQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOFQyMToxMjozM1rOHOuMYw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTEzNzU3Nw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            @Component(service = ThingHandlerFactory.class, immediate = true)\n          \n          \n            \n            @Component(service = ThingHandlerFactory.class)", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r485137577", "createdAt": "2020-09-08T19:09:18Z", "author": {"login": "Hilbrand"}, "path": "bundles/org.openhab.binding.jablotron/src/main/java/org/openhab/binding/jablotron/internal/JablotronHandlerFactory.java", "diffHunk": "@@ -0,0 +1,77 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.jablotron.internal;\n+\n+import static org.openhab.binding.jablotron.JablotronBindingConstants.*;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.thing.ThingUID;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandlerFactory;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerFactory;\n+import org.eclipse.smarthome.io.net.http.HttpClientFactory;\n+import org.openhab.binding.jablotron.internal.handler.JablotronBridgeHandler;\n+import org.openhab.binding.jablotron.internal.handler.JablotronJa100FHandler;\n+import org.openhab.binding.jablotron.internal.handler.JablotronJa100Handler;\n+import org.openhab.binding.jablotron.internal.handler.JablotronOasisHandler;\n+import org.osgi.framework.ServiceRegistration;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Reference;\n+\n+/**\n+ * The {@link JablotronHandlerFactory} is responsible for creating things and thing\n+ * handlers.\n+ *\n+ * @author Ondrej Pecta - Initial contribution\n+ */\n+@NonNullByDefault\n+@Component(service = ThingHandlerFactory.class, immediate = true)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c1ffbb591d92a8b648e7420168c9b836c0bf9b10"}, "originalPosition": 46}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE5ODk0Nw==", "bodyText": "fixed", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r485198947", "createdAt": "2020-09-08T21:12:33Z", "author": {"login": "octa22"}, "path": "bundles/org.openhab.binding.jablotron/src/main/java/org/openhab/binding/jablotron/internal/JablotronHandlerFactory.java", "diffHunk": "@@ -0,0 +1,77 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.jablotron.internal;\n+\n+import static org.openhab.binding.jablotron.JablotronBindingConstants.*;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.thing.ThingUID;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandlerFactory;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerFactory;\n+import org.eclipse.smarthome.io.net.http.HttpClientFactory;\n+import org.openhab.binding.jablotron.internal.handler.JablotronBridgeHandler;\n+import org.openhab.binding.jablotron.internal.handler.JablotronJa100FHandler;\n+import org.openhab.binding.jablotron.internal.handler.JablotronJa100Handler;\n+import org.openhab.binding.jablotron.internal.handler.JablotronOasisHandler;\n+import org.osgi.framework.ServiceRegistration;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Reference;\n+\n+/**\n+ * The {@link JablotronHandlerFactory} is responsible for creating things and thing\n+ * handlers.\n+ *\n+ * @author Ondrej Pecta - Initial contribution\n+ */\n+@NonNullByDefault\n+@Component(service = ThingHandlerFactory.class, immediate = true)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTEzNzU3Nw=="}, "originalCommit": {"oid": "c1ffbb591d92a8b648e7420168c9b836c0bf9b10"}, "originalPosition": 46}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAzNDM2MTQwOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.jablotron/src/main/java/org/openhab/binding/jablotron/internal/JablotronHandlerFactory.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOFQxOTowOTo0M1rOHOqdcg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOFQyMToxMzoyOFrOHOuN7A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTEzNzc3OA==", "bodyText": "This field can be removed.", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r485137778", "createdAt": "2020-09-08T19:09:43Z", "author": {"login": "Hilbrand"}, "path": "bundles/org.openhab.binding.jablotron/src/main/java/org/openhab/binding/jablotron/internal/JablotronHandlerFactory.java", "diffHunk": "@@ -0,0 +1,77 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.jablotron.internal;\n+\n+import static org.openhab.binding.jablotron.JablotronBindingConstants.*;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.thing.ThingUID;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandlerFactory;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerFactory;\n+import org.eclipse.smarthome.io.net.http.HttpClientFactory;\n+import org.openhab.binding.jablotron.internal.handler.JablotronBridgeHandler;\n+import org.openhab.binding.jablotron.internal.handler.JablotronJa100FHandler;\n+import org.openhab.binding.jablotron.internal.handler.JablotronJa100Handler;\n+import org.openhab.binding.jablotron.internal.handler.JablotronOasisHandler;\n+import org.osgi.framework.ServiceRegistration;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Reference;\n+\n+/**\n+ * The {@link JablotronHandlerFactory} is responsible for creating things and thing\n+ * handlers.\n+ *\n+ * @author Ondrej Pecta - Initial contribution\n+ */\n+@NonNullByDefault\n+@Component(service = ThingHandlerFactory.class, immediate = true)\n+public class JablotronHandlerFactory extends BaseThingHandlerFactory {\n+\n+    private Map<ThingUID, ServiceRegistration<?>> discoveryServiceRegs = new HashMap<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c1ffbb591d92a8b648e7420168c9b836c0bf9b10"}, "originalPosition": 49}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE5OTM0MA==", "bodyText": "removed", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r485199340", "createdAt": "2020-09-08T21:13:28Z", "author": {"login": "octa22"}, "path": "bundles/org.openhab.binding.jablotron/src/main/java/org/openhab/binding/jablotron/internal/JablotronHandlerFactory.java", "diffHunk": "@@ -0,0 +1,77 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.jablotron.internal;\n+\n+import static org.openhab.binding.jablotron.JablotronBindingConstants.*;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.thing.ThingUID;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandlerFactory;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerFactory;\n+import org.eclipse.smarthome.io.net.http.HttpClientFactory;\n+import org.openhab.binding.jablotron.internal.handler.JablotronBridgeHandler;\n+import org.openhab.binding.jablotron.internal.handler.JablotronJa100FHandler;\n+import org.openhab.binding.jablotron.internal.handler.JablotronJa100Handler;\n+import org.openhab.binding.jablotron.internal.handler.JablotronOasisHandler;\n+import org.osgi.framework.ServiceRegistration;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Reference;\n+\n+/**\n+ * The {@link JablotronHandlerFactory} is responsible for creating things and thing\n+ * handlers.\n+ *\n+ * @author Ondrej Pecta - Initial contribution\n+ */\n+@NonNullByDefault\n+@Component(service = ThingHandlerFactory.class, immediate = true)\n+public class JablotronHandlerFactory extends BaseThingHandlerFactory {\n+\n+    private Map<ThingUID, ServiceRegistration<?>> discoveryServiceRegs = new HashMap<>();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTEzNzc3OA=="}, "originalCommit": {"oid": "c1ffbb591d92a8b648e7420168c9b836c0bf9b10"}, "originalPosition": 49}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAzNDM3MzI3OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.jablotron/src/main/java/org/openhab/binding/jablotron/JablotronBindingConstants.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOFQxOToxMzoyNFrOHOqksA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOFQyMToxNDowOVrOHOuPFA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTEzOTYzMg==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public static final int TIMEOUT = 10;\n          \n          \n            \n                public static final int TIMEOUT_SEC = 10;", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r485139632", "createdAt": "2020-09-08T19:13:24Z", "author": {"login": "Hilbrand"}, "path": "bundles/org.openhab.binding.jablotron/src/main/java/org/openhab/binding/jablotron/JablotronBindingConstants.java", "diffHunk": "@@ -0,0 +1,71 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.jablotron;\n+\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+\n+/**\n+ * The {@link JablotronBindingConstants} class defines common constants, which are\n+ * used across the whole binding.\n+ *\n+ * @author Ondrej Pecta - Initial contribution\n+ */\n+@NonNullByDefault\n+public class JablotronBindingConstants {\n+\n+    private static final String BINDING_ID = \"jablotron\";\n+\n+    // List of all Thing Type UIDs\n+    public static final ThingTypeUID THING_TYPE_BRIDGE = new ThingTypeUID(BINDING_ID, \"bridge\");\n+    public static final ThingTypeUID THING_TYPE_OASIS = new ThingTypeUID(BINDING_ID, \"oasis\");\n+    public static final ThingTypeUID THING_TYPE_JA100 = new ThingTypeUID(BINDING_ID, \"ja100\");\n+    public static final ThingTypeUID THING_TYPE_JA100F = new ThingTypeUID(BINDING_ID, \"ja100f\");\n+\n+    // Common alarm channels\n+    public static final String CHANNEL_ALARM = \"alarm\";\n+    public static final String CHANNEL_LAST_CHECK_TIME = \"lastCheckTime\";\n+    public static final String CHANNEL_LAST_EVENT = \"lastEvent\";\n+    public static final String CHANNEL_LAST_EVENT_CLASS = \"lastEventClass\";\n+    public static final String CHANNEL_LAST_EVENT_TIME = \"lastEventTime\";\n+    public static final String CHANNEL_LAST_EVENT_INVOKER = \"lastEventInvoker\";\n+    public static final String CHANNEL_LAST_EVENT_SECTION = \"lastEventSection\";\n+\n+    // List of all OASIS Channel ids\n+    public static final String CHANNEL_COMMAND = \"command\";\n+    public static final String CHANNEL_STATUS_A = \"statusA\";\n+    public static final String CHANNEL_STATUS_B = \"statusB\";\n+    public static final String CHANNEL_STATUS_ABC = \"statusABC\";\n+    public static final String CHANNEL_STATUS_PGX = \"statusPGX\";\n+    public static final String CHANNEL_STATUS_PGY = \"statusPGY\";\n+\n+    // Constants\n+    public static final String JABLOTRON_API_URL = \"https://api.jablonet.net/api/1.6/\";\n+    public static final String AGENT = \"Swagger-Codegen/1.0.0/android\";\n+    public static final int TIMEOUT = 10;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c1ffbb591d92a8b648e7420168c9b836c0bf9b10"}, "originalPosition": 59}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE5OTYzNg==", "bodyText": "renamed", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r485199636", "createdAt": "2020-09-08T21:14:09Z", "author": {"login": "octa22"}, "path": "bundles/org.openhab.binding.jablotron/src/main/java/org/openhab/binding/jablotron/JablotronBindingConstants.java", "diffHunk": "@@ -0,0 +1,71 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.jablotron;\n+\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+\n+/**\n+ * The {@link JablotronBindingConstants} class defines common constants, which are\n+ * used across the whole binding.\n+ *\n+ * @author Ondrej Pecta - Initial contribution\n+ */\n+@NonNullByDefault\n+public class JablotronBindingConstants {\n+\n+    private static final String BINDING_ID = \"jablotron\";\n+\n+    // List of all Thing Type UIDs\n+    public static final ThingTypeUID THING_TYPE_BRIDGE = new ThingTypeUID(BINDING_ID, \"bridge\");\n+    public static final ThingTypeUID THING_TYPE_OASIS = new ThingTypeUID(BINDING_ID, \"oasis\");\n+    public static final ThingTypeUID THING_TYPE_JA100 = new ThingTypeUID(BINDING_ID, \"ja100\");\n+    public static final ThingTypeUID THING_TYPE_JA100F = new ThingTypeUID(BINDING_ID, \"ja100f\");\n+\n+    // Common alarm channels\n+    public static final String CHANNEL_ALARM = \"alarm\";\n+    public static final String CHANNEL_LAST_CHECK_TIME = \"lastCheckTime\";\n+    public static final String CHANNEL_LAST_EVENT = \"lastEvent\";\n+    public static final String CHANNEL_LAST_EVENT_CLASS = \"lastEventClass\";\n+    public static final String CHANNEL_LAST_EVENT_TIME = \"lastEventTime\";\n+    public static final String CHANNEL_LAST_EVENT_INVOKER = \"lastEventInvoker\";\n+    public static final String CHANNEL_LAST_EVENT_SECTION = \"lastEventSection\";\n+\n+    // List of all OASIS Channel ids\n+    public static final String CHANNEL_COMMAND = \"command\";\n+    public static final String CHANNEL_STATUS_A = \"statusA\";\n+    public static final String CHANNEL_STATUS_B = \"statusB\";\n+    public static final String CHANNEL_STATUS_ABC = \"statusABC\";\n+    public static final String CHANNEL_STATUS_PGX = \"statusPGX\";\n+    public static final String CHANNEL_STATUS_PGY = \"statusPGY\";\n+\n+    // Constants\n+    public static final String JABLOTRON_API_URL = \"https://api.jablonet.net/api/1.6/\";\n+    public static final String AGENT = \"Swagger-Codegen/1.0.0/android\";\n+    public static final int TIMEOUT = 10;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTEzOTYzMg=="}, "originalCommit": {"oid": "c1ffbb591d92a8b648e7420168c9b836c0bf9b10"}, "originalPosition": 59}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAzNDM3NTA3OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.jablotron/README.md", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOFQxOToxMzo1OFrOHOql1Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOFQyMToxNDo0NVrOHOuQNg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTEzOTkyNQ==", "bodyText": "This won't age well \ud83d\ude09\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            This is the OH2.x binding for Jablotron alarms.\n          \n          \n            \n            This is the binding for Jablotron alarms.", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r485139925", "createdAt": "2020-09-08T19:13:58Z", "author": {"login": "Hilbrand"}, "path": "bundles/org.openhab.binding.jablotron/README.md", "diffHunk": "@@ -0,0 +1,120 @@\n+# Jablotron Alarm Binding\n+\n+This is the OH2.x binding for Jablotron alarms.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c1ffbb591d92a8b648e7420168c9b836c0bf9b10"}, "originalPosition": 3}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE5OTkyNg==", "bodyText": "fixed", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r485199926", "createdAt": "2020-09-08T21:14:45Z", "author": {"login": "octa22"}, "path": "bundles/org.openhab.binding.jablotron/README.md", "diffHunk": "@@ -0,0 +1,120 @@\n+# Jablotron Alarm Binding\n+\n+This is the OH2.x binding for Jablotron alarms.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTEzOTkyNQ=="}, "originalCommit": {"oid": "c1ffbb591d92a8b648e7420168c9b836c0bf9b10"}, "originalPosition": 3}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAzNDM4MzQ3OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.jablotron/src/main/java/org/openhab/binding/jablotron/internal/handler/JablotronAlarmHandler.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOFQxOToxNjoyMlrOHOqqtQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOFQyMToxNToyMlrOHOuRhw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE0MTE3Mw==", "bodyText": "As this is an abstract class maybe use getClass() to know which specific subclass logs:\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private final Logger logger = LoggerFactory.getLogger(JablotronAlarmHandler.class);\n          \n          \n            \n                private final Logger logger = LoggerFactory.getLogger(getClass());", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r485141173", "createdAt": "2020-09-08T19:16:22Z", "author": {"login": "Hilbrand"}, "path": "bundles/org.openhab.binding.jablotron/src/main/java/org/openhab/binding/jablotron/internal/handler/JablotronAlarmHandler.java", "diffHunk": "@@ -0,0 +1,219 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.jablotron.internal.handler;\n+\n+import static org.openhab.binding.jablotron.JablotronBindingConstants.*;\n+\n+import java.time.ZoneId;\n+import java.time.ZonedDateTime;\n+import java.time.format.DateTimeFormatter;\n+import java.util.Calendar;\n+import java.util.List;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DateTimeType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.ThingStatusInfo;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.jablotron.internal.config.JablotronDeviceConfig;\n+import org.openhab.binding.jablotron.internal.model.*;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+\n+/**\n+ * The {@link JablotronAlarmHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Ondrej Pecta - Initial contribution\n+ */\n+@NonNullByDefault\n+public abstract class JablotronAlarmHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(JablotronAlarmHandler.class);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c1ffbb591d92a8b648e7420168c9b836c0bf9b10"}, "originalPosition": 51}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTIwMDI2Mw==", "bodyText": "ok, fixed", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r485200263", "createdAt": "2020-09-08T21:15:22Z", "author": {"login": "octa22"}, "path": "bundles/org.openhab.binding.jablotron/src/main/java/org/openhab/binding/jablotron/internal/handler/JablotronAlarmHandler.java", "diffHunk": "@@ -0,0 +1,219 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.jablotron.internal.handler;\n+\n+import static org.openhab.binding.jablotron.JablotronBindingConstants.*;\n+\n+import java.time.ZoneId;\n+import java.time.ZonedDateTime;\n+import java.time.format.DateTimeFormatter;\n+import java.util.Calendar;\n+import java.util.List;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DateTimeType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.ThingStatusInfo;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.jablotron.internal.config.JablotronDeviceConfig;\n+import org.openhab.binding.jablotron.internal.model.*;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+\n+/**\n+ * The {@link JablotronAlarmHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Ondrej Pecta - Initial contribution\n+ */\n+@NonNullByDefault\n+public abstract class JablotronAlarmHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(JablotronAlarmHandler.class);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE0MTE3Mw=="}, "originalCommit": {"oid": "c1ffbb591d92a8b648e7420168c9b836c0bf9b10"}, "originalPosition": 51}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAzNDY4NTUwOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.jablotron/src/main/resources/ESH-INF/thing/channels.xml", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOFQyMDo0OTowNFrOHOthAg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOFQyMToxNzo0MFrOHOuVog==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE4Nzg0Mg==", "bodyText": "You can drop the word  Channel from all labels. It's redundanti information and only makes the labels unnecessary longer.\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\t<label>Alarm Zone A Status Channel</label>\n          \n          \n            \n            \t\t<label>Alarm Zone A Status</label>", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r485187842", "createdAt": "2020-09-08T20:49:04Z", "author": {"login": "Hilbrand"}, "path": "bundles/org.openhab.binding.jablotron/src/main/resources/ESH-INF/thing/channels.xml", "diffHunk": "@@ -0,0 +1,165 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"jablotron\"\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\t<!-- Oasis -->\n+\t<!-- StatusA -->\n+\t<channel-type id=\"statusA\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Alarm Zone A Status Channel</label>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c1ffbb591d92a8b648e7420168c9b836c0bf9b10"}, "originalPosition": 10}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTIwMTMxNA==", "bodyText": "removed from all the labels", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r485201314", "createdAt": "2020-09-08T21:17:40Z", "author": {"login": "octa22"}, "path": "bundles/org.openhab.binding.jablotron/src/main/resources/ESH-INF/thing/channels.xml", "diffHunk": "@@ -0,0 +1,165 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"jablotron\"\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\t<!-- Oasis -->\n+\t<!-- StatusA -->\n+\t<channel-type id=\"statusA\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Alarm Zone A Status Channel</label>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE4Nzg0Mg=="}, "originalCommit": {"oid": "c1ffbb591d92a8b648e7420168c9b836c0bf9b10"}, "originalPosition": 10}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA0MzYxNTgzOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.jablotron/README.md", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMFQxOToyODowNFrOHQCubg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMVQxNToyNDo1N1rOHQjbQA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjU4MzkxOA==", "bodyText": "Same for below\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            #items file for JA80\n          \n          \n            \n            # items file for JA80", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r486583918", "createdAt": "2020-09-10T19:28:04Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.jablotron/README.md", "diffHunk": "@@ -0,0 +1,120 @@\n+# Jablotron Alarm Binding\n+\n+This is the binding for Jablotron alarms.\n+https://www.jablotron.com/en/jablotron-products/alarms/\n+\n+## Supported Things\n+\n+| thing   | note                                      |\n+|---------|-------------------------------------------|\n+| bridge  | the bridge to your Jablonet cloud account |\n+| JA-80   | the OASIS alarm                           |\n+| JA-100  | with the thermometer support              |\n+| JA-100F | without the thermometer support           |\n+ \n+## Discovery\n+\n+This binding supports auto discovery. Just manually add a bridge thing and supply login & password to your Jablonet account.\n+\n+## Binding Configuration\n+\n+Binding itself doesn't require specific configuration.\n+\n+## Thing Configuration\n+\n+| thing                | config parameter name | description                                                                        | type                  |\n+|----------------------|-----------------------|------------------------------------------------------------------------------------|-----------------------|\n+| bridge               | login                 | the login to your Jablonet account                                                 | mandatory             |\n+| bridge               | password              | the password to your Jablonet account                                              | mandatory             |\n+| bridge               | refresh               | the refresh time for all alarm warnings (ALARM, TAMPER triggers and SERVICE state) | optional, default=30s |\n+| bridge               | lang                  | the language of the alarm texts                                                    | optional, default=en  |\n+| JA-80/JA-100/JA-100F | refresh               | the channels refresh period in seconds                                             | optional, default=60s |\n+| JA-80/JA-100/JA-100F | serviceId             | the service ID which identifies the alarm                                          | mandatory             |\n+| JA-100/JA-100F       | code                  | the master code for controlling sections                                           | optional              |\n+\n+## Channels\n+\n+| thing                | channel name     | description                                               |\n+|----------------------|------------------|-----------------------------------------------------------|\n+| bridge               | N/A              | the bridge does not expose any channels                   |\n+| JA-80                | statusA          | the status of the A section                               |\n+| JA-80                | statusB          | the status of the AB/B section                            |\n+| JA-80                | statusABC        | the status of the ABC section                             |\n+| JA-80                | statusPGX        | the status of PGX                                         |\n+| JA-80                | statusPGY        | the status of PGY                                         |\n+| JA-80                | command          | the channel for sending keyboard codes to the OASIS alarm |\n+| JA-80/JA-100/JA-100F | lastEvent        | the text description of the last event                    |\n+| JA-80/JA-100/JA-100F | lastEventClass   | the class of the last event - e.g. arm, disarm, ...       |\n+| JA-80/JA-100/JA-100F | lastEventInvoker | the invoker of the last event                             |\n+| JA-80/JA-100/JA-100F | lastEventTime    | the time of the last event                                |\n+| JA-80/JA-100/JA-100F | lastCheckTime    | the time of the last checking                             |\n+| JA-80/JA-100/JA-100F | alarm            | the alarm trigger, might fire ALARM or TAMPER events      |\n+| JA-100/JA-100F       | lastEventSection | the section of the last event                             |\n+\n+all other channels for the JA-100/JA-100F alarms (sections, PGs and thermometers for JA-100) are dynamically created according to your configuration\n+\n+* The sections are represented by String channels (with possible values \"set\", \"unset\", \"partialSet\" for JA-100 and \n+possible values \"ARM\", \"PARTIAL_ARM\" and \"DISARM\" for JA100-F)\n+* The PGs (programmable gates) are represented by Switch channels \n+\n+## Full Example\n+\n+#items file for JA80", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a590e81e68f4bb50a74b76dce0635a7906ca04ab"}, "originalPosition": 62}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzExOTY4MA==", "bodyText": "OK, fixed", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r487119680", "createdAt": "2020-09-11T15:24:57Z", "author": {"login": "octa22"}, "path": "bundles/org.openhab.binding.jablotron/README.md", "diffHunk": "@@ -0,0 +1,120 @@\n+# Jablotron Alarm Binding\n+\n+This is the binding for Jablotron alarms.\n+https://www.jablotron.com/en/jablotron-products/alarms/\n+\n+## Supported Things\n+\n+| thing   | note                                      |\n+|---------|-------------------------------------------|\n+| bridge  | the bridge to your Jablonet cloud account |\n+| JA-80   | the OASIS alarm                           |\n+| JA-100  | with the thermometer support              |\n+| JA-100F | without the thermometer support           |\n+ \n+## Discovery\n+\n+This binding supports auto discovery. Just manually add a bridge thing and supply login & password to your Jablonet account.\n+\n+## Binding Configuration\n+\n+Binding itself doesn't require specific configuration.\n+\n+## Thing Configuration\n+\n+| thing                | config parameter name | description                                                                        | type                  |\n+|----------------------|-----------------------|------------------------------------------------------------------------------------|-----------------------|\n+| bridge               | login                 | the login to your Jablonet account                                                 | mandatory             |\n+| bridge               | password              | the password to your Jablonet account                                              | mandatory             |\n+| bridge               | refresh               | the refresh time for all alarm warnings (ALARM, TAMPER triggers and SERVICE state) | optional, default=30s |\n+| bridge               | lang                  | the language of the alarm texts                                                    | optional, default=en  |\n+| JA-80/JA-100/JA-100F | refresh               | the channels refresh period in seconds                                             | optional, default=60s |\n+| JA-80/JA-100/JA-100F | serviceId             | the service ID which identifies the alarm                                          | mandatory             |\n+| JA-100/JA-100F       | code                  | the master code for controlling sections                                           | optional              |\n+\n+## Channels\n+\n+| thing                | channel name     | description                                               |\n+|----------------------|------------------|-----------------------------------------------------------|\n+| bridge               | N/A              | the bridge does not expose any channels                   |\n+| JA-80                | statusA          | the status of the A section                               |\n+| JA-80                | statusB          | the status of the AB/B section                            |\n+| JA-80                | statusABC        | the status of the ABC section                             |\n+| JA-80                | statusPGX        | the status of PGX                                         |\n+| JA-80                | statusPGY        | the status of PGY                                         |\n+| JA-80                | command          | the channel for sending keyboard codes to the OASIS alarm |\n+| JA-80/JA-100/JA-100F | lastEvent        | the text description of the last event                    |\n+| JA-80/JA-100/JA-100F | lastEventClass   | the class of the last event - e.g. arm, disarm, ...       |\n+| JA-80/JA-100/JA-100F | lastEventInvoker | the invoker of the last event                             |\n+| JA-80/JA-100/JA-100F | lastEventTime    | the time of the last event                                |\n+| JA-80/JA-100/JA-100F | lastCheckTime    | the time of the last checking                             |\n+| JA-80/JA-100/JA-100F | alarm            | the alarm trigger, might fire ALARM or TAMPER events      |\n+| JA-100/JA-100F       | lastEventSection | the section of the last event                             |\n+\n+all other channels for the JA-100/JA-100F alarms (sections, PGs and thermometers for JA-100) are dynamically created according to your configuration\n+\n+* The sections are represented by String channels (with possible values \"set\", \"unset\", \"partialSet\" for JA-100 and \n+possible values \"ARM\", \"PARTIAL_ARM\" and \"DISARM\" for JA100-F)\n+* The PGs (programmable gates) are represented by Switch channels \n+\n+## Full Example\n+\n+#items file for JA80", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjU4MzkxOA=="}, "originalCommit": {"oid": "a590e81e68f4bb50a74b76dce0635a7906ca04ab"}, "originalPosition": 62}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA0MzYxNzkwOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.jablotron/README.md", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMFQxOToyODo1MVrOHQCv0Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMVQxNTozOTo0MlrOHQj-vg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjU4NDI3Mw==", "bodyText": "Is there a reason why you didn't document them here?", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r486584273", "createdAt": "2020-09-10T19:28:51Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.jablotron/README.md", "diffHunk": "@@ -0,0 +1,120 @@\n+# Jablotron Alarm Binding\n+\n+This is the binding for Jablotron alarms.\n+https://www.jablotron.com/en/jablotron-products/alarms/\n+\n+## Supported Things\n+\n+| thing   | note                                      |\n+|---------|-------------------------------------------|\n+| bridge  | the bridge to your Jablonet cloud account |\n+| JA-80   | the OASIS alarm                           |\n+| JA-100  | with the thermometer support              |\n+| JA-100F | without the thermometer support           |\n+ \n+## Discovery\n+\n+This binding supports auto discovery. Just manually add a bridge thing and supply login & password to your Jablonet account.\n+\n+## Binding Configuration\n+\n+Binding itself doesn't require specific configuration.\n+\n+## Thing Configuration\n+\n+| thing                | config parameter name | description                                                                        | type                  |\n+|----------------------|-----------------------|------------------------------------------------------------------------------------|-----------------------|\n+| bridge               | login                 | the login to your Jablonet account                                                 | mandatory             |\n+| bridge               | password              | the password to your Jablonet account                                              | mandatory             |\n+| bridge               | refresh               | the refresh time for all alarm warnings (ALARM, TAMPER triggers and SERVICE state) | optional, default=30s |\n+| bridge               | lang                  | the language of the alarm texts                                                    | optional, default=en  |\n+| JA-80/JA-100/JA-100F | refresh               | the channels refresh period in seconds                                             | optional, default=60s |\n+| JA-80/JA-100/JA-100F | serviceId             | the service ID which identifies the alarm                                          | mandatory             |\n+| JA-100/JA-100F       | code                  | the master code for controlling sections                                           | optional              |\n+\n+## Channels\n+\n+| thing                | channel name     | description                                               |\n+|----------------------|------------------|-----------------------------------------------------------|\n+| bridge               | N/A              | the bridge does not expose any channels                   |\n+| JA-80                | statusA          | the status of the A section                               |\n+| JA-80                | statusB          | the status of the AB/B section                            |\n+| JA-80                | statusABC        | the status of the ABC section                             |\n+| JA-80                | statusPGX        | the status of PGX                                         |\n+| JA-80                | statusPGY        | the status of PGY                                         |\n+| JA-80                | command          | the channel for sending keyboard codes to the OASIS alarm |\n+| JA-80/JA-100/JA-100F | lastEvent        | the text description of the last event                    |\n+| JA-80/JA-100/JA-100F | lastEventClass   | the class of the last event - e.g. arm, disarm, ...       |\n+| JA-80/JA-100/JA-100F | lastEventInvoker | the invoker of the last event                             |\n+| JA-80/JA-100/JA-100F | lastEventTime    | the time of the last event                                |\n+| JA-80/JA-100/JA-100F | lastCheckTime    | the time of the last checking                             |\n+| JA-80/JA-100/JA-100F | alarm            | the alarm trigger, might fire ALARM or TAMPER events      |\n+| JA-100/JA-100F       | lastEventSection | the section of the last event                             |\n+\n+all other channels for the JA-100/JA-100F alarms (sections, PGs and thermometers for JA-100) are dynamically created according to your configuration", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a590e81e68f4bb50a74b76dce0635a7906ca04ab"}, "originalPosition": 54}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzEyODc2Ng==", "bodyText": "Added documentation for the dynamic channels as well", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r487128766", "createdAt": "2020-09-11T15:39:42Z", "author": {"login": "octa22"}, "path": "bundles/org.openhab.binding.jablotron/README.md", "diffHunk": "@@ -0,0 +1,120 @@\n+# Jablotron Alarm Binding\n+\n+This is the binding for Jablotron alarms.\n+https://www.jablotron.com/en/jablotron-products/alarms/\n+\n+## Supported Things\n+\n+| thing   | note                                      |\n+|---------|-------------------------------------------|\n+| bridge  | the bridge to your Jablonet cloud account |\n+| JA-80   | the OASIS alarm                           |\n+| JA-100  | with the thermometer support              |\n+| JA-100F | without the thermometer support           |\n+ \n+## Discovery\n+\n+This binding supports auto discovery. Just manually add a bridge thing and supply login & password to your Jablonet account.\n+\n+## Binding Configuration\n+\n+Binding itself doesn't require specific configuration.\n+\n+## Thing Configuration\n+\n+| thing                | config parameter name | description                                                                        | type                  |\n+|----------------------|-----------------------|------------------------------------------------------------------------------------|-----------------------|\n+| bridge               | login                 | the login to your Jablonet account                                                 | mandatory             |\n+| bridge               | password              | the password to your Jablonet account                                              | mandatory             |\n+| bridge               | refresh               | the refresh time for all alarm warnings (ALARM, TAMPER triggers and SERVICE state) | optional, default=30s |\n+| bridge               | lang                  | the language of the alarm texts                                                    | optional, default=en  |\n+| JA-80/JA-100/JA-100F | refresh               | the channels refresh period in seconds                                             | optional, default=60s |\n+| JA-80/JA-100/JA-100F | serviceId             | the service ID which identifies the alarm                                          | mandatory             |\n+| JA-100/JA-100F       | code                  | the master code for controlling sections                                           | optional              |\n+\n+## Channels\n+\n+| thing                | channel name     | description                                               |\n+|----------------------|------------------|-----------------------------------------------------------|\n+| bridge               | N/A              | the bridge does not expose any channels                   |\n+| JA-80                | statusA          | the status of the A section                               |\n+| JA-80                | statusB          | the status of the AB/B section                            |\n+| JA-80                | statusABC        | the status of the ABC section                             |\n+| JA-80                | statusPGX        | the status of PGX                                         |\n+| JA-80                | statusPGY        | the status of PGY                                         |\n+| JA-80                | command          | the channel for sending keyboard codes to the OASIS alarm |\n+| JA-80/JA-100/JA-100F | lastEvent        | the text description of the last event                    |\n+| JA-80/JA-100/JA-100F | lastEventClass   | the class of the last event - e.g. arm, disarm, ...       |\n+| JA-80/JA-100/JA-100F | lastEventInvoker | the invoker of the last event                             |\n+| JA-80/JA-100/JA-100F | lastEventTime    | the time of the last event                                |\n+| JA-80/JA-100/JA-100F | lastCheckTime    | the time of the last checking                             |\n+| JA-80/JA-100/JA-100F | alarm            | the alarm trigger, might fire ALARM or TAMPER events      |\n+| JA-100/JA-100F       | lastEventSection | the section of the last event                             |\n+\n+all other channels for the JA-100/JA-100F alarms (sections, PGs and thermometers for JA-100) are dynamically created according to your configuration", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjU4NDI3Mw=="}, "originalCommit": {"oid": "a590e81e68f4bb50a74b76dce0635a7906ca04ab"}, "originalPosition": 54}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA0MzYyODU5OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.jablotron/src/main/java/org/openhab/binding/jablotron/internal/discovery/JablotronDiscoveryService.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMFQxOTozMTo0NFrOHQC2Jg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMVQxNTo0ODo0NVrOHQkTbA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjU4NTg5NA==", "bodyText": "Logging to info should be used rarely. This could be debug. Same for below.", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r486585894", "createdAt": "2020-09-10T19:31:44Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.jablotron/src/main/java/org/openhab/binding/jablotron/internal/discovery/JablotronDiscoveryService.java", "diffHunk": "@@ -0,0 +1,171 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.jablotron.internal.discovery;\n+\n+import static org.openhab.binding.jablotron.JablotronBindingConstants.*;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.config.discovery.*;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.thing.ThingUID;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.openhab.binding.jablotron.internal.handler.JablotronBridgeHandler;\n+import org.openhab.binding.jablotron.internal.model.JablotronDiscoveredService;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link JablotronDiscoveryService} is responsible for the thing discovery\n+ * process.\n+ *\n+ * @author Ondrej Pecta - Initial contribution\n+ */\n+@NonNullByDefault\n+public class JablotronDiscoveryService extends AbstractDiscoveryService\n+        implements DiscoveryService, ThingHandlerService {\n+    private final Logger logger = LoggerFactory.getLogger(JablotronDiscoveryService.class);\n+\n+    private @Nullable JablotronBridgeHandler bridgeHandler;\n+\n+    private @Nullable ScheduledFuture<?> discoveryJob = null;\n+\n+    public JablotronDiscoveryService() {\n+        super(DISCOVERY_TIMEOUT_SEC);\n+        logger.debug(\"Creating discovery service\");\n+    }\n+\n+    private void startDiscovery() {\n+        if (this.bridgeHandler.getThing().getStatus() == ThingStatus.ONLINE) {\n+            discoverServices();\n+        }\n+    }\n+\n+    @Override\n+    public void setThingHandler(@Nullable ThingHandler thingHandler) {\n+        if (thingHandler instanceof JablotronBridgeHandler) {\n+            bridgeHandler = (JablotronBridgeHandler) thingHandler;\n+        }\n+    }\n+\n+    @Override\n+    public @Nullable ThingHandler getThingHandler() {\n+        return bridgeHandler;\n+    }\n+\n+    @Override\n+    protected void stopBackgroundDiscovery() {\n+        super.stopBackgroundDiscovery();\n+        if (discoveryJob != null) {\n+            discoveryJob.cancel(true);\n+        }\n+    }\n+\n+    @Override\n+    protected void startBackgroundDiscovery() {\n+        logger.debug(\"Starting Jablotron background discovery\");\n+\n+        if (discoveryJob == null || discoveryJob.isCancelled()) {\n+            discoveryJob = scheduler.scheduleWithFixedDelay(this::startDiscovery, 10, 3600, TimeUnit.SECONDS);\n+        }\n+    }\n+\n+    @Override\n+    public void activate() {\n+        super.activate(null);\n+    }\n+\n+    @Override\n+    public void deactivate() {\n+        super.deactivate();\n+    }\n+\n+    @Override\n+    public Set<ThingTypeUID> getSupportedThingTypes() {\n+        return SUPPORTED_THING_TYPES_UIDS;\n+    }\n+\n+    @Override\n+    protected void startScan() {\n+        logger.debug(\"Starting scanning for items...\");\n+        startDiscovery();\n+    }\n+\n+    public void oasisDiscovered(String label, String serviceId) {\n+        ThingUID thingUID = new ThingUID(THING_TYPE_OASIS, bridgeHandler.getThing().getUID(), serviceId);\n+        Map<String, Object> properties = new HashMap<>();\n+        properties.put(PROPERTY_SERVICE_ID, serviceId);\n+\n+        logger.debug(\"Detected an OASIS alarm with service id: {}\", serviceId);\n+        thingDiscovered(DiscoveryResultBuilder.create(thingUID).withThingType(THING_TYPE_OASIS).withLabel(label)\n+                .withProperties(properties).withRepresentationProperty(PROPERTY_SERVICE_ID)\n+                .withBridge(bridgeHandler.getThing().getUID()).build());\n+    }\n+\n+    public void ja100Discovered(String label, String serviceId) {\n+        ThingUID thingUID = new ThingUID(THING_TYPE_JA100, bridgeHandler.getThing().getUID(), serviceId);\n+        Map<String, Object> properties = new HashMap<>();\n+        properties.put(PROPERTY_SERVICE_ID, serviceId);\n+\n+        logger.debug(\"Detected a JA100 alarm with service id: {}\", serviceId);\n+        thingDiscovered(DiscoveryResultBuilder.create(thingUID).withThingType(THING_TYPE_JA100).withLabel(label)\n+                .withProperties(properties).withRepresentationProperty(PROPERTY_SERVICE_ID)\n+                .withBridge(bridgeHandler.getThing().getUID()).build());\n+    }\n+\n+    public void ja100fDiscovered(String label, String serviceId) {\n+        ThingUID thingUID = new ThingUID(THING_TYPE_JA100F, bridgeHandler.getThing().getUID(), serviceId);\n+        Map<String, Object> properties = new HashMap<>();\n+        properties.put(PROPERTY_SERVICE_ID, serviceId);\n+\n+        logger.debug(\"Detected a JA100+ alarm with service id: {}\", serviceId);\n+        thingDiscovered(DiscoveryResultBuilder.create(thingUID).withThingType(THING_TYPE_JA100F).withLabel(label)\n+                .withProperties(properties).withRepresentationProperty(PROPERTY_SERVICE_ID)\n+                .withBridge(bridgeHandler.getThing().getUID()).build());\n+    }\n+\n+    private synchronized void discoverServices() {\n+        List<JablotronDiscoveredService> services = bridgeHandler.discoverServices();\n+\n+        if (services == null || services.isEmpty()) {\n+            logger.info(\"Cannot find any Jablotron device\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a590e81e68f4bb50a74b76dce0635a7906ca04ab"}, "originalPosition": 150}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzEzMzQxMw==", "bodyText": "Agreed. Changed the severity to debug", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r487133413", "createdAt": "2020-09-11T15:47:29Z", "author": {"login": "octa22"}, "path": "bundles/org.openhab.binding.jablotron/src/main/java/org/openhab/binding/jablotron/internal/discovery/JablotronDiscoveryService.java", "diffHunk": "@@ -0,0 +1,171 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.jablotron.internal.discovery;\n+\n+import static org.openhab.binding.jablotron.JablotronBindingConstants.*;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.config.discovery.*;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.thing.ThingUID;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.openhab.binding.jablotron.internal.handler.JablotronBridgeHandler;\n+import org.openhab.binding.jablotron.internal.model.JablotronDiscoveredService;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link JablotronDiscoveryService} is responsible for the thing discovery\n+ * process.\n+ *\n+ * @author Ondrej Pecta - Initial contribution\n+ */\n+@NonNullByDefault\n+public class JablotronDiscoveryService extends AbstractDiscoveryService\n+        implements DiscoveryService, ThingHandlerService {\n+    private final Logger logger = LoggerFactory.getLogger(JablotronDiscoveryService.class);\n+\n+    private @Nullable JablotronBridgeHandler bridgeHandler;\n+\n+    private @Nullable ScheduledFuture<?> discoveryJob = null;\n+\n+    public JablotronDiscoveryService() {\n+        super(DISCOVERY_TIMEOUT_SEC);\n+        logger.debug(\"Creating discovery service\");\n+    }\n+\n+    private void startDiscovery() {\n+        if (this.bridgeHandler.getThing().getStatus() == ThingStatus.ONLINE) {\n+            discoverServices();\n+        }\n+    }\n+\n+    @Override\n+    public void setThingHandler(@Nullable ThingHandler thingHandler) {\n+        if (thingHandler instanceof JablotronBridgeHandler) {\n+            bridgeHandler = (JablotronBridgeHandler) thingHandler;\n+        }\n+    }\n+\n+    @Override\n+    public @Nullable ThingHandler getThingHandler() {\n+        return bridgeHandler;\n+    }\n+\n+    @Override\n+    protected void stopBackgroundDiscovery() {\n+        super.stopBackgroundDiscovery();\n+        if (discoveryJob != null) {\n+            discoveryJob.cancel(true);\n+        }\n+    }\n+\n+    @Override\n+    protected void startBackgroundDiscovery() {\n+        logger.debug(\"Starting Jablotron background discovery\");\n+\n+        if (discoveryJob == null || discoveryJob.isCancelled()) {\n+            discoveryJob = scheduler.scheduleWithFixedDelay(this::startDiscovery, 10, 3600, TimeUnit.SECONDS);\n+        }\n+    }\n+\n+    @Override\n+    public void activate() {\n+        super.activate(null);\n+    }\n+\n+    @Override\n+    public void deactivate() {\n+        super.deactivate();\n+    }\n+\n+    @Override\n+    public Set<ThingTypeUID> getSupportedThingTypes() {\n+        return SUPPORTED_THING_TYPES_UIDS;\n+    }\n+\n+    @Override\n+    protected void startScan() {\n+        logger.debug(\"Starting scanning for items...\");\n+        startDiscovery();\n+    }\n+\n+    public void oasisDiscovered(String label, String serviceId) {\n+        ThingUID thingUID = new ThingUID(THING_TYPE_OASIS, bridgeHandler.getThing().getUID(), serviceId);\n+        Map<String, Object> properties = new HashMap<>();\n+        properties.put(PROPERTY_SERVICE_ID, serviceId);\n+\n+        logger.debug(\"Detected an OASIS alarm with service id: {}\", serviceId);\n+        thingDiscovered(DiscoveryResultBuilder.create(thingUID).withThingType(THING_TYPE_OASIS).withLabel(label)\n+                .withProperties(properties).withRepresentationProperty(PROPERTY_SERVICE_ID)\n+                .withBridge(bridgeHandler.getThing().getUID()).build());\n+    }\n+\n+    public void ja100Discovered(String label, String serviceId) {\n+        ThingUID thingUID = new ThingUID(THING_TYPE_JA100, bridgeHandler.getThing().getUID(), serviceId);\n+        Map<String, Object> properties = new HashMap<>();\n+        properties.put(PROPERTY_SERVICE_ID, serviceId);\n+\n+        logger.debug(\"Detected a JA100 alarm with service id: {}\", serviceId);\n+        thingDiscovered(DiscoveryResultBuilder.create(thingUID).withThingType(THING_TYPE_JA100).withLabel(label)\n+                .withProperties(properties).withRepresentationProperty(PROPERTY_SERVICE_ID)\n+                .withBridge(bridgeHandler.getThing().getUID()).build());\n+    }\n+\n+    public void ja100fDiscovered(String label, String serviceId) {\n+        ThingUID thingUID = new ThingUID(THING_TYPE_JA100F, bridgeHandler.getThing().getUID(), serviceId);\n+        Map<String, Object> properties = new HashMap<>();\n+        properties.put(PROPERTY_SERVICE_ID, serviceId);\n+\n+        logger.debug(\"Detected a JA100+ alarm with service id: {}\", serviceId);\n+        thingDiscovered(DiscoveryResultBuilder.create(thingUID).withThingType(THING_TYPE_JA100F).withLabel(label)\n+                .withProperties(properties).withRepresentationProperty(PROPERTY_SERVICE_ID)\n+                .withBridge(bridgeHandler.getThing().getUID()).build());\n+    }\n+\n+    private synchronized void discoverServices() {\n+        List<JablotronDiscoveredService> services = bridgeHandler.discoverServices();\n+\n+        if (services == null || services.isEmpty()) {\n+            logger.info(\"Cannot find any Jablotron device\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjU4NTg5NA=="}, "originalCommit": {"oid": "a590e81e68f4bb50a74b76dce0635a7906ca04ab"}, "originalPosition": 150}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzEzNDA2MA==", "bodyText": "The below info severity is important for creating an issue. I would keep it as info so we can easily find out the ids of unsupported alarms", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r487134060", "createdAt": "2020-09-11T15:48:45Z", "author": {"login": "octa22"}, "path": "bundles/org.openhab.binding.jablotron/src/main/java/org/openhab/binding/jablotron/internal/discovery/JablotronDiscoveryService.java", "diffHunk": "@@ -0,0 +1,171 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.jablotron.internal.discovery;\n+\n+import static org.openhab.binding.jablotron.JablotronBindingConstants.*;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.config.discovery.*;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.thing.ThingUID;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.openhab.binding.jablotron.internal.handler.JablotronBridgeHandler;\n+import org.openhab.binding.jablotron.internal.model.JablotronDiscoveredService;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link JablotronDiscoveryService} is responsible for the thing discovery\n+ * process.\n+ *\n+ * @author Ondrej Pecta - Initial contribution\n+ */\n+@NonNullByDefault\n+public class JablotronDiscoveryService extends AbstractDiscoveryService\n+        implements DiscoveryService, ThingHandlerService {\n+    private final Logger logger = LoggerFactory.getLogger(JablotronDiscoveryService.class);\n+\n+    private @Nullable JablotronBridgeHandler bridgeHandler;\n+\n+    private @Nullable ScheduledFuture<?> discoveryJob = null;\n+\n+    public JablotronDiscoveryService() {\n+        super(DISCOVERY_TIMEOUT_SEC);\n+        logger.debug(\"Creating discovery service\");\n+    }\n+\n+    private void startDiscovery() {\n+        if (this.bridgeHandler.getThing().getStatus() == ThingStatus.ONLINE) {\n+            discoverServices();\n+        }\n+    }\n+\n+    @Override\n+    public void setThingHandler(@Nullable ThingHandler thingHandler) {\n+        if (thingHandler instanceof JablotronBridgeHandler) {\n+            bridgeHandler = (JablotronBridgeHandler) thingHandler;\n+        }\n+    }\n+\n+    @Override\n+    public @Nullable ThingHandler getThingHandler() {\n+        return bridgeHandler;\n+    }\n+\n+    @Override\n+    protected void stopBackgroundDiscovery() {\n+        super.stopBackgroundDiscovery();\n+        if (discoveryJob != null) {\n+            discoveryJob.cancel(true);\n+        }\n+    }\n+\n+    @Override\n+    protected void startBackgroundDiscovery() {\n+        logger.debug(\"Starting Jablotron background discovery\");\n+\n+        if (discoveryJob == null || discoveryJob.isCancelled()) {\n+            discoveryJob = scheduler.scheduleWithFixedDelay(this::startDiscovery, 10, 3600, TimeUnit.SECONDS);\n+        }\n+    }\n+\n+    @Override\n+    public void activate() {\n+        super.activate(null);\n+    }\n+\n+    @Override\n+    public void deactivate() {\n+        super.deactivate();\n+    }\n+\n+    @Override\n+    public Set<ThingTypeUID> getSupportedThingTypes() {\n+        return SUPPORTED_THING_TYPES_UIDS;\n+    }\n+\n+    @Override\n+    protected void startScan() {\n+        logger.debug(\"Starting scanning for items...\");\n+        startDiscovery();\n+    }\n+\n+    public void oasisDiscovered(String label, String serviceId) {\n+        ThingUID thingUID = new ThingUID(THING_TYPE_OASIS, bridgeHandler.getThing().getUID(), serviceId);\n+        Map<String, Object> properties = new HashMap<>();\n+        properties.put(PROPERTY_SERVICE_ID, serviceId);\n+\n+        logger.debug(\"Detected an OASIS alarm with service id: {}\", serviceId);\n+        thingDiscovered(DiscoveryResultBuilder.create(thingUID).withThingType(THING_TYPE_OASIS).withLabel(label)\n+                .withProperties(properties).withRepresentationProperty(PROPERTY_SERVICE_ID)\n+                .withBridge(bridgeHandler.getThing().getUID()).build());\n+    }\n+\n+    public void ja100Discovered(String label, String serviceId) {\n+        ThingUID thingUID = new ThingUID(THING_TYPE_JA100, bridgeHandler.getThing().getUID(), serviceId);\n+        Map<String, Object> properties = new HashMap<>();\n+        properties.put(PROPERTY_SERVICE_ID, serviceId);\n+\n+        logger.debug(\"Detected a JA100 alarm with service id: {}\", serviceId);\n+        thingDiscovered(DiscoveryResultBuilder.create(thingUID).withThingType(THING_TYPE_JA100).withLabel(label)\n+                .withProperties(properties).withRepresentationProperty(PROPERTY_SERVICE_ID)\n+                .withBridge(bridgeHandler.getThing().getUID()).build());\n+    }\n+\n+    public void ja100fDiscovered(String label, String serviceId) {\n+        ThingUID thingUID = new ThingUID(THING_TYPE_JA100F, bridgeHandler.getThing().getUID(), serviceId);\n+        Map<String, Object> properties = new HashMap<>();\n+        properties.put(PROPERTY_SERVICE_ID, serviceId);\n+\n+        logger.debug(\"Detected a JA100+ alarm with service id: {}\", serviceId);\n+        thingDiscovered(DiscoveryResultBuilder.create(thingUID).withThingType(THING_TYPE_JA100F).withLabel(label)\n+                .withProperties(properties).withRepresentationProperty(PROPERTY_SERVICE_ID)\n+                .withBridge(bridgeHandler.getThing().getUID()).build());\n+    }\n+\n+    private synchronized void discoverServices() {\n+        List<JablotronDiscoveredService> services = bridgeHandler.discoverServices();\n+\n+        if (services == null || services.isEmpty()) {\n+            logger.info(\"Cannot find any Jablotron device\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjU4NTg5NA=="}, "originalCommit": {"oid": "a590e81e68f4bb50a74b76dce0635a7906ca04ab"}, "originalPosition": 150}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA0MzYzOTg3OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.jablotron/src/main/java/org/openhab/binding/jablotron/internal/handler/JablotronAlarmHandler.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMFQxOTozNToyNlrOHQC9Pw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMVQyMDowMzo0M1rOHQsO5g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjU4NzcxMQ==", "bodyText": "What's the purpose of this method?", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r486587711", "createdAt": "2020-09-10T19:35:26Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.jablotron/src/main/java/org/openhab/binding/jablotron/internal/handler/JablotronAlarmHandler.java", "diffHunk": "@@ -0,0 +1,219 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.jablotron.internal.handler;\n+\n+import static org.openhab.binding.jablotron.JablotronBindingConstants.*;\n+\n+import java.time.ZoneId;\n+import java.time.ZonedDateTime;\n+import java.time.format.DateTimeFormatter;\n+import java.util.Calendar;\n+import java.util.List;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DateTimeType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.ThingStatusInfo;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.jablotron.internal.config.JablotronDeviceConfig;\n+import org.openhab.binding.jablotron.internal.model.*;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+\n+/**\n+ * The {@link JablotronAlarmHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Ondrej Pecta - Initial contribution\n+ */\n+@NonNullByDefault\n+public abstract class JablotronAlarmHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(getClass());\n+\n+    protected final Gson gson = new Gson();\n+\n+    protected JablotronDeviceConfig thingConfig = new JablotronDeviceConfig();\n+\n+    private String lastWarningTime = \"\";\n+\n+    protected String alarmName = \"\";\n+\n+    private boolean inService = false;\n+\n+    protected @Nullable ScheduledFuture<?> future = null;\n+\n+    public JablotronAlarmHandler(Thing thing, String alarmName) {\n+        super(thing);\n+        this.alarmName = alarmName;\n+    }\n+\n+    @Override\n+    public void bridgeStatusChanged(ThingStatusInfo bridgeStatusInfo) {\n+        super.bridgeStatusChanged(bridgeStatusInfo);\n+        if (ThingStatus.UNINITIALIZED == bridgeStatusInfo.getStatus()) {\n+            cleanup();\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        super.dispose();\n+        cleanup();\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        thingConfig = getConfigAs(JablotronDeviceConfig.class);\n+        scheduler.execute(this::doInit);\n+        updateStatus(ThingStatus.ONLINE);\n+    }\n+\n+    public boolean isInService() {\n+        return inService;\n+    }\n+\n+    public String getAlarmName() {\n+        return alarmName;\n+    }\n+\n+    protected void updateSegmentStatus(JablotronServiceDetailSegment segment) {\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a590e81e68f4bb50a74b76dce0635a7906ca04ab"}, "originalPosition": 100}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzEzMjE1MA==", "bodyText": "older alarms (JA80, JA100) override this method to correctly update the sections/segments status.\nThe JA100F alarm does not need it at all, so it is not abstract.", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r487132150", "createdAt": "2020-09-11T15:45:23Z", "author": {"login": "octa22"}, "path": "bundles/org.openhab.binding.jablotron/src/main/java/org/openhab/binding/jablotron/internal/handler/JablotronAlarmHandler.java", "diffHunk": "@@ -0,0 +1,219 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.jablotron.internal.handler;\n+\n+import static org.openhab.binding.jablotron.JablotronBindingConstants.*;\n+\n+import java.time.ZoneId;\n+import java.time.ZonedDateTime;\n+import java.time.format.DateTimeFormatter;\n+import java.util.Calendar;\n+import java.util.List;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DateTimeType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.ThingStatusInfo;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.jablotron.internal.config.JablotronDeviceConfig;\n+import org.openhab.binding.jablotron.internal.model.*;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+\n+/**\n+ * The {@link JablotronAlarmHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Ondrej Pecta - Initial contribution\n+ */\n+@NonNullByDefault\n+public abstract class JablotronAlarmHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(getClass());\n+\n+    protected final Gson gson = new Gson();\n+\n+    protected JablotronDeviceConfig thingConfig = new JablotronDeviceConfig();\n+\n+    private String lastWarningTime = \"\";\n+\n+    protected String alarmName = \"\";\n+\n+    private boolean inService = false;\n+\n+    protected @Nullable ScheduledFuture<?> future = null;\n+\n+    public JablotronAlarmHandler(Thing thing, String alarmName) {\n+        super(thing);\n+        this.alarmName = alarmName;\n+    }\n+\n+    @Override\n+    public void bridgeStatusChanged(ThingStatusInfo bridgeStatusInfo) {\n+        super.bridgeStatusChanged(bridgeStatusInfo);\n+        if (ThingStatus.UNINITIALIZED == bridgeStatusInfo.getStatus()) {\n+            cleanup();\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        super.dispose();\n+        cleanup();\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        thingConfig = getConfigAs(JablotronDeviceConfig.class);\n+        scheduler.execute(this::doInit);\n+        updateStatus(ThingStatus.ONLINE);\n+    }\n+\n+    public boolean isInService() {\n+        return inService;\n+    }\n+\n+    public String getAlarmName() {\n+        return alarmName;\n+    }\n+\n+    protected void updateSegmentStatus(JablotronServiceDetailSegment segment) {\n+    }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjU4NzcxMQ=="}, "originalCommit": {"oid": "a590e81e68f4bb50a74b76dce0635a7906ca04ab"}, "originalPosition": 100}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzIyMjYwOQ==", "bodyText": "In this case it's good practice to make it abstract to show that this method is meant to be overwritten. In the single class, which doesn't override it, you could add a comment like \"// nothing\" in the method.", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r487222609", "createdAt": "2020-09-11T18:39:12Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.jablotron/src/main/java/org/openhab/binding/jablotron/internal/handler/JablotronAlarmHandler.java", "diffHunk": "@@ -0,0 +1,219 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.jablotron.internal.handler;\n+\n+import static org.openhab.binding.jablotron.JablotronBindingConstants.*;\n+\n+import java.time.ZoneId;\n+import java.time.ZonedDateTime;\n+import java.time.format.DateTimeFormatter;\n+import java.util.Calendar;\n+import java.util.List;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DateTimeType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.ThingStatusInfo;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.jablotron.internal.config.JablotronDeviceConfig;\n+import org.openhab.binding.jablotron.internal.model.*;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+\n+/**\n+ * The {@link JablotronAlarmHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Ondrej Pecta - Initial contribution\n+ */\n+@NonNullByDefault\n+public abstract class JablotronAlarmHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(getClass());\n+\n+    protected final Gson gson = new Gson();\n+\n+    protected JablotronDeviceConfig thingConfig = new JablotronDeviceConfig();\n+\n+    private String lastWarningTime = \"\";\n+\n+    protected String alarmName = \"\";\n+\n+    private boolean inService = false;\n+\n+    protected @Nullable ScheduledFuture<?> future = null;\n+\n+    public JablotronAlarmHandler(Thing thing, String alarmName) {\n+        super(thing);\n+        this.alarmName = alarmName;\n+    }\n+\n+    @Override\n+    public void bridgeStatusChanged(ThingStatusInfo bridgeStatusInfo) {\n+        super.bridgeStatusChanged(bridgeStatusInfo);\n+        if (ThingStatus.UNINITIALIZED == bridgeStatusInfo.getStatus()) {\n+            cleanup();\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        super.dispose();\n+        cleanup();\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        thingConfig = getConfigAs(JablotronDeviceConfig.class);\n+        scheduler.execute(this::doInit);\n+        updateStatus(ThingStatus.ONLINE);\n+    }\n+\n+    public boolean isInService() {\n+        return inService;\n+    }\n+\n+    public String getAlarmName() {\n+        return alarmName;\n+    }\n+\n+    protected void updateSegmentStatus(JablotronServiceDetailSegment segment) {\n+    }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjU4NzcxMQ=="}, "originalCommit": {"oid": "a590e81e68f4bb50a74b76dce0635a7906ca04ab"}, "originalPosition": 100}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzI2Mzk3NA==", "bodyText": "OK, I will do it abstract", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r487263974", "createdAt": "2020-09-11T20:03:43Z", "author": {"login": "octa22"}, "path": "bundles/org.openhab.binding.jablotron/src/main/java/org/openhab/binding/jablotron/internal/handler/JablotronAlarmHandler.java", "diffHunk": "@@ -0,0 +1,219 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.jablotron.internal.handler;\n+\n+import static org.openhab.binding.jablotron.JablotronBindingConstants.*;\n+\n+import java.time.ZoneId;\n+import java.time.ZonedDateTime;\n+import java.time.format.DateTimeFormatter;\n+import java.util.Calendar;\n+import java.util.List;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DateTimeType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.ThingStatusInfo;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.jablotron.internal.config.JablotronDeviceConfig;\n+import org.openhab.binding.jablotron.internal.model.*;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+\n+/**\n+ * The {@link JablotronAlarmHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Ondrej Pecta - Initial contribution\n+ */\n+@NonNullByDefault\n+public abstract class JablotronAlarmHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(getClass());\n+\n+    protected final Gson gson = new Gson();\n+\n+    protected JablotronDeviceConfig thingConfig = new JablotronDeviceConfig();\n+\n+    private String lastWarningTime = \"\";\n+\n+    protected String alarmName = \"\";\n+\n+    private boolean inService = false;\n+\n+    protected @Nullable ScheduledFuture<?> future = null;\n+\n+    public JablotronAlarmHandler(Thing thing, String alarmName) {\n+        super(thing);\n+        this.alarmName = alarmName;\n+    }\n+\n+    @Override\n+    public void bridgeStatusChanged(ThingStatusInfo bridgeStatusInfo) {\n+        super.bridgeStatusChanged(bridgeStatusInfo);\n+        if (ThingStatus.UNINITIALIZED == bridgeStatusInfo.getStatus()) {\n+            cleanup();\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        super.dispose();\n+        cleanup();\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        thingConfig = getConfigAs(JablotronDeviceConfig.class);\n+        scheduler.execute(this::doInit);\n+        updateStatus(ThingStatus.ONLINE);\n+    }\n+\n+    public boolean isInService() {\n+        return inService;\n+    }\n+\n+    public String getAlarmName() {\n+        return alarmName;\n+    }\n+\n+    protected void updateSegmentStatus(JablotronServiceDetailSegment segment) {\n+    }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjU4NzcxMQ=="}, "originalCommit": {"oid": "a590e81e68f4bb50a74b76dce0635a7906ca04ab"}, "originalPosition": 100}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA0MzY0NDc3OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.jablotron/src/main/java/org/openhab/binding/jablotron/internal/handler/JablotronAlarmHandler.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMFQxOTozNjo1NlrOHQDATw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMVQxNTo0OTo1MVrOHQkVvg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjU4ODQ5NQ==", "bodyText": "Calendar is old fashioned. You could do this:\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    ZonedDateTime zdt = ZonedDateTime.ofInstant(Calendar.getInstance().toInstant(), ZoneId.systemDefault());\n          \n          \n            \n                    ZonedDateTime zdt = ZonedDateTime.ofInstant(Instant.now(), ZoneId.systemDefault());", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r486588495", "createdAt": "2020-09-10T19:36:56Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.jablotron/src/main/java/org/openhab/binding/jablotron/internal/handler/JablotronAlarmHandler.java", "diffHunk": "@@ -0,0 +1,219 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.jablotron.internal.handler;\n+\n+import static org.openhab.binding.jablotron.JablotronBindingConstants.*;\n+\n+import java.time.ZoneId;\n+import java.time.ZonedDateTime;\n+import java.time.format.DateTimeFormatter;\n+import java.util.Calendar;\n+import java.util.List;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DateTimeType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.ThingStatusInfo;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.jablotron.internal.config.JablotronDeviceConfig;\n+import org.openhab.binding.jablotron.internal.model.*;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+\n+/**\n+ * The {@link JablotronAlarmHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Ondrej Pecta - Initial contribution\n+ */\n+@NonNullByDefault\n+public abstract class JablotronAlarmHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(getClass());\n+\n+    protected final Gson gson = new Gson();\n+\n+    protected JablotronDeviceConfig thingConfig = new JablotronDeviceConfig();\n+\n+    private String lastWarningTime = \"\";\n+\n+    protected String alarmName = \"\";\n+\n+    private boolean inService = false;\n+\n+    protected @Nullable ScheduledFuture<?> future = null;\n+\n+    public JablotronAlarmHandler(Thing thing, String alarmName) {\n+        super(thing);\n+        this.alarmName = alarmName;\n+    }\n+\n+    @Override\n+    public void bridgeStatusChanged(ThingStatusInfo bridgeStatusInfo) {\n+        super.bridgeStatusChanged(bridgeStatusInfo);\n+        if (ThingStatus.UNINITIALIZED == bridgeStatusInfo.getStatus()) {\n+            cleanup();\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        super.dispose();\n+        cleanup();\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        thingConfig = getConfigAs(JablotronDeviceConfig.class);\n+        scheduler.execute(this::doInit);\n+        updateStatus(ThingStatus.ONLINE);\n+    }\n+\n+    public boolean isInService() {\n+        return inService;\n+    }\n+\n+    public String getAlarmName() {\n+        return alarmName;\n+    }\n+\n+    protected void updateSegmentStatus(JablotronServiceDetailSegment segment) {\n+    }\n+\n+    private void cleanup() {\n+        logger.debug(\"doing cleanup...\");\n+        if (future != null) {\n+            future.cancel(true);\n+        }\n+    }\n+\n+    protected State getCheckTime() {\n+        ZonedDateTime zdt = ZonedDateTime.ofInstant(Calendar.getInstance().toInstant(), ZoneId.systemDefault());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a590e81e68f4bb50a74b76dce0635a7906ca04ab"}, "originalPosition": 110}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzEzNDY1NA==", "bodyText": "OK, Fixed", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r487134654", "createdAt": "2020-09-11T15:49:51Z", "author": {"login": "octa22"}, "path": "bundles/org.openhab.binding.jablotron/src/main/java/org/openhab/binding/jablotron/internal/handler/JablotronAlarmHandler.java", "diffHunk": "@@ -0,0 +1,219 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.jablotron.internal.handler;\n+\n+import static org.openhab.binding.jablotron.JablotronBindingConstants.*;\n+\n+import java.time.ZoneId;\n+import java.time.ZonedDateTime;\n+import java.time.format.DateTimeFormatter;\n+import java.util.Calendar;\n+import java.util.List;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DateTimeType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.ThingStatusInfo;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.jablotron.internal.config.JablotronDeviceConfig;\n+import org.openhab.binding.jablotron.internal.model.*;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+\n+/**\n+ * The {@link JablotronAlarmHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Ondrej Pecta - Initial contribution\n+ */\n+@NonNullByDefault\n+public abstract class JablotronAlarmHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(getClass());\n+\n+    protected final Gson gson = new Gson();\n+\n+    protected JablotronDeviceConfig thingConfig = new JablotronDeviceConfig();\n+\n+    private String lastWarningTime = \"\";\n+\n+    protected String alarmName = \"\";\n+\n+    private boolean inService = false;\n+\n+    protected @Nullable ScheduledFuture<?> future = null;\n+\n+    public JablotronAlarmHandler(Thing thing, String alarmName) {\n+        super(thing);\n+        this.alarmName = alarmName;\n+    }\n+\n+    @Override\n+    public void bridgeStatusChanged(ThingStatusInfo bridgeStatusInfo) {\n+        super.bridgeStatusChanged(bridgeStatusInfo);\n+        if (ThingStatus.UNINITIALIZED == bridgeStatusInfo.getStatus()) {\n+            cleanup();\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        super.dispose();\n+        cleanup();\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        thingConfig = getConfigAs(JablotronDeviceConfig.class);\n+        scheduler.execute(this::doInit);\n+        updateStatus(ThingStatus.ONLINE);\n+    }\n+\n+    public boolean isInService() {\n+        return inService;\n+    }\n+\n+    public String getAlarmName() {\n+        return alarmName;\n+    }\n+\n+    protected void updateSegmentStatus(JablotronServiceDetailSegment segment) {\n+    }\n+\n+    private void cleanup() {\n+        logger.debug(\"doing cleanup...\");\n+        if (future != null) {\n+            future.cancel(true);\n+        }\n+    }\n+\n+    protected State getCheckTime() {\n+        ZonedDateTime zdt = ZonedDateTime.ofInstant(Calendar.getInstance().toInstant(), ZoneId.systemDefault());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjU4ODQ5NQ=="}, "originalCommit": {"oid": "a590e81e68f4bb50a74b76dce0635a7906ca04ab"}, "originalPosition": 110}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA0MzY0ODMyOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.jablotron/src/main/java/org/openhab/binding/jablotron/internal/handler/JablotronAlarmHandler.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMFQxOTozODowNFrOHQDCdw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMVQxNjoxODoyMVrOHQlUZA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjU4OTA0Nw==", "bodyText": "Is this necessary to be executed asynchronously? You could schedule the updateAlarmStatus() task directly here.", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r486589047", "createdAt": "2020-09-10T19:38:04Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.jablotron/src/main/java/org/openhab/binding/jablotron/internal/handler/JablotronAlarmHandler.java", "diffHunk": "@@ -0,0 +1,219 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.jablotron.internal.handler;\n+\n+import static org.openhab.binding.jablotron.JablotronBindingConstants.*;\n+\n+import java.time.ZoneId;\n+import java.time.ZonedDateTime;\n+import java.time.format.DateTimeFormatter;\n+import java.util.Calendar;\n+import java.util.List;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DateTimeType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.ThingStatusInfo;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.jablotron.internal.config.JablotronDeviceConfig;\n+import org.openhab.binding.jablotron.internal.model.*;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+\n+/**\n+ * The {@link JablotronAlarmHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Ondrej Pecta - Initial contribution\n+ */\n+@NonNullByDefault\n+public abstract class JablotronAlarmHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(getClass());\n+\n+    protected final Gson gson = new Gson();\n+\n+    protected JablotronDeviceConfig thingConfig = new JablotronDeviceConfig();\n+\n+    private String lastWarningTime = \"\";\n+\n+    protected String alarmName = \"\";\n+\n+    private boolean inService = false;\n+\n+    protected @Nullable ScheduledFuture<?> future = null;\n+\n+    public JablotronAlarmHandler(Thing thing, String alarmName) {\n+        super(thing);\n+        this.alarmName = alarmName;\n+    }\n+\n+    @Override\n+    public void bridgeStatusChanged(ThingStatusInfo bridgeStatusInfo) {\n+        super.bridgeStatusChanged(bridgeStatusInfo);\n+        if (ThingStatus.UNINITIALIZED == bridgeStatusInfo.getStatus()) {\n+            cleanup();\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        super.dispose();\n+        cleanup();\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        thingConfig = getConfigAs(JablotronDeviceConfig.class);\n+        scheduler.execute(this::doInit);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a590e81e68f4bb50a74b76dce0635a7906ca04ab"}, "originalPosition": 87}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzE1MDY5Mg==", "bodyText": "good hint, fixed", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r487150692", "createdAt": "2020-09-11T16:18:21Z", "author": {"login": "octa22"}, "path": "bundles/org.openhab.binding.jablotron/src/main/java/org/openhab/binding/jablotron/internal/handler/JablotronAlarmHandler.java", "diffHunk": "@@ -0,0 +1,219 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.jablotron.internal.handler;\n+\n+import static org.openhab.binding.jablotron.JablotronBindingConstants.*;\n+\n+import java.time.ZoneId;\n+import java.time.ZonedDateTime;\n+import java.time.format.DateTimeFormatter;\n+import java.util.Calendar;\n+import java.util.List;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DateTimeType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.ThingStatusInfo;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.jablotron.internal.config.JablotronDeviceConfig;\n+import org.openhab.binding.jablotron.internal.model.*;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+\n+/**\n+ * The {@link JablotronAlarmHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Ondrej Pecta - Initial contribution\n+ */\n+@NonNullByDefault\n+public abstract class JablotronAlarmHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(getClass());\n+\n+    protected final Gson gson = new Gson();\n+\n+    protected JablotronDeviceConfig thingConfig = new JablotronDeviceConfig();\n+\n+    private String lastWarningTime = \"\";\n+\n+    protected String alarmName = \"\";\n+\n+    private boolean inService = false;\n+\n+    protected @Nullable ScheduledFuture<?> future = null;\n+\n+    public JablotronAlarmHandler(Thing thing, String alarmName) {\n+        super(thing);\n+        this.alarmName = alarmName;\n+    }\n+\n+    @Override\n+    public void bridgeStatusChanged(ThingStatusInfo bridgeStatusInfo) {\n+        super.bridgeStatusChanged(bridgeStatusInfo);\n+        if (ThingStatus.UNINITIALIZED == bridgeStatusInfo.getStatus()) {\n+            cleanup();\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        super.dispose();\n+        cleanup();\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        thingConfig = getConfigAs(JablotronDeviceConfig.class);\n+        scheduler.execute(this::doInit);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjU4OTA0Nw=="}, "originalCommit": {"oid": "a590e81e68f4bb50a74b76dce0635a7906ca04ab"}, "originalPosition": 87}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA0MzY3MTI3OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.jablotron/src/main/java/org/openhab/binding/jablotron/internal/handler/JablotronAlarmHandler.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMFQxOTo0NToyMFrOHQDQlw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMVQxNjowNTo0OFrOHQk5oQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjU5MjY2Mw==", "bodyText": "You could fix the compiler warning by storing the result of getBridge() into a local variable and work with that.", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r486592663", "createdAt": "2020-09-10T19:45:20Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.jablotron/src/main/java/org/openhab/binding/jablotron/internal/handler/JablotronAlarmHandler.java", "diffHunk": "@@ -0,0 +1,219 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.jablotron.internal.handler;\n+\n+import static org.openhab.binding.jablotron.JablotronBindingConstants.*;\n+\n+import java.time.ZoneId;\n+import java.time.ZonedDateTime;\n+import java.time.format.DateTimeFormatter;\n+import java.util.Calendar;\n+import java.util.List;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DateTimeType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.ThingStatusInfo;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.jablotron.internal.config.JablotronDeviceConfig;\n+import org.openhab.binding.jablotron.internal.model.*;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+\n+/**\n+ * The {@link JablotronAlarmHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Ondrej Pecta - Initial contribution\n+ */\n+@NonNullByDefault\n+public abstract class JablotronAlarmHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(getClass());\n+\n+    protected final Gson gson = new Gson();\n+\n+    protected JablotronDeviceConfig thingConfig = new JablotronDeviceConfig();\n+\n+    private String lastWarningTime = \"\";\n+\n+    protected String alarmName = \"\";\n+\n+    private boolean inService = false;\n+\n+    protected @Nullable ScheduledFuture<?> future = null;\n+\n+    public JablotronAlarmHandler(Thing thing, String alarmName) {\n+        super(thing);\n+        this.alarmName = alarmName;\n+    }\n+\n+    @Override\n+    public void bridgeStatusChanged(ThingStatusInfo bridgeStatusInfo) {\n+        super.bridgeStatusChanged(bridgeStatusInfo);\n+        if (ThingStatus.UNINITIALIZED == bridgeStatusInfo.getStatus()) {\n+            cleanup();\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        super.dispose();\n+        cleanup();\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        thingConfig = getConfigAs(JablotronDeviceConfig.class);\n+        scheduler.execute(this::doInit);\n+        updateStatus(ThingStatus.ONLINE);\n+    }\n+\n+    public boolean isInService() {\n+        return inService;\n+    }\n+\n+    public String getAlarmName() {\n+        return alarmName;\n+    }\n+\n+    protected void updateSegmentStatus(JablotronServiceDetailSegment segment) {\n+    }\n+\n+    private void cleanup() {\n+        logger.debug(\"doing cleanup...\");\n+        if (future != null) {\n+            future.cancel(true);\n+        }\n+    }\n+\n+    protected State getCheckTime() {\n+        ZonedDateTime zdt = ZonedDateTime.ofInstant(Calendar.getInstance().toInstant(), ZoneId.systemDefault());\n+        return new DateTimeType(zdt);\n+    }\n+\n+    protected void doInit() {\n+        future = scheduler.scheduleWithFixedDelay(this::updateAlarmStatus, 1, thingConfig.getRefresh(),\n+                TimeUnit.SECONDS);\n+    }\n+\n+    protected synchronized @Nullable JablotronDataUpdateResponse sendGetStatusRequest() {\n+        JablotronBridgeHandler handler = getBridgeHandler();\n+        if (handler != null) {\n+            return handler.sendGetStatusRequest(getThing());\n+        }\n+        return null;\n+    }\n+\n+    protected synchronized boolean updateAlarmStatus() {\n+        JablotronDataUpdateResponse dataUpdate = sendGetStatusRequest();\n+        if (dataUpdate == null) {\n+            return false;\n+        }\n+\n+        if (dataUpdate.isStatus()) {\n+            updateState(CHANNEL_LAST_CHECK_TIME, getCheckTime());\n+            List<JablotronServiceData> serviceData = dataUpdate.getData().getServiceData();\n+            for (JablotronServiceData data : serviceData) {\n+                List<JablotronService> services = data.getData();\n+                for (JablotronService service : services) {\n+                    JablotronServiceDetail detail = service.getData();\n+                    for (JablotronServiceDetailSegment segment : detail.getSegments()) {\n+                        updateSegmentStatus(segment);\n+                    }\n+                }\n+\n+            }\n+        } else {\n+            logger.debug(\"Error during alarm status update: {}\", dataUpdate.getErrorMessage());\n+        }\n+\n+        List<JablotronHistoryDataEvent> events = sendGetEventHistory(alarmName);\n+        if (events != null && events.size() > 0) {\n+            JablotronHistoryDataEvent event = events.get(0);\n+            updateLastEvent(event);\n+        }\n+\n+        return true;\n+    }\n+\n+    protected @Nullable List<JablotronHistoryDataEvent> sendGetEventHistory(String alarm) {\n+        JablotronBridgeHandler handler = getBridgeHandler();\n+        if (handler != null) {\n+            return handler.sendGetEventHistory(getThing(), alarm);\n+        }\n+        return null;\n+    }\n+\n+    protected void updateLastEvent(JablotronHistoryDataEvent event) {\n+        updateState(CHANNEL_LAST_EVENT_TIME, new DateTimeType(getZonedDateTime(event.getDate())));\n+        updateState(CHANNEL_LAST_EVENT, new StringType(event.getEventText()));\n+        updateState(CHANNEL_LAST_EVENT_CLASS, new StringType(event.getIconType()));\n+        updateState(CHANNEL_LAST_EVENT_INVOKER, new StringType(event.getInvokerName()));\n+\n+        // oasis does not have sections\n+        if (getThing().getChannel(CHANNEL_LAST_EVENT_SECTION) != null) {\n+            updateState(CHANNEL_LAST_EVENT_SECTION, new StringType(event.getSectionName()));\n+        }\n+    }\n+\n+    public ZonedDateTime getZonedDateTime(String date) {\n+        return ZonedDateTime.parse(date.substring(0, 22) + \":\" + date.substring(22, 24),\n+                DateTimeFormatter.ISO_DATE_TIME);\n+    }\n+\n+    protected @Nullable JablotronControlResponse sendUserCode(String section, String key, String status, String code) {\n+        JablotronControlResponse response = null;\n+        JablotronBridgeHandler handler = getBridgeHandler();\n+        if (handler != null) {\n+            try {\n+                response = handler.sendUserCode(getThing(), section, key, status, code);\n+            } catch (SecurityException se) {\n+                response = handler.sendUserCode(getThing(), section, key, status, code);\n+            }\n+        }\n+        return response;\n+    }\n+\n+    protected @Nullable JablotronBridgeHandler getBridgeHandler() {\n+        if (getBridge() != null && getBridge().getHandler() != null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a590e81e68f4bb50a74b76dce0635a7906ca04ab"}, "originalPosition": 198}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzE0Mzg0MQ==", "bodyText": "introduced the local var.", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r487143841", "createdAt": "2020-09-11T16:05:48Z", "author": {"login": "octa22"}, "path": "bundles/org.openhab.binding.jablotron/src/main/java/org/openhab/binding/jablotron/internal/handler/JablotronAlarmHandler.java", "diffHunk": "@@ -0,0 +1,219 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.jablotron.internal.handler;\n+\n+import static org.openhab.binding.jablotron.JablotronBindingConstants.*;\n+\n+import java.time.ZoneId;\n+import java.time.ZonedDateTime;\n+import java.time.format.DateTimeFormatter;\n+import java.util.Calendar;\n+import java.util.List;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DateTimeType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.ThingStatusInfo;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.jablotron.internal.config.JablotronDeviceConfig;\n+import org.openhab.binding.jablotron.internal.model.*;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+\n+/**\n+ * The {@link JablotronAlarmHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Ondrej Pecta - Initial contribution\n+ */\n+@NonNullByDefault\n+public abstract class JablotronAlarmHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(getClass());\n+\n+    protected final Gson gson = new Gson();\n+\n+    protected JablotronDeviceConfig thingConfig = new JablotronDeviceConfig();\n+\n+    private String lastWarningTime = \"\";\n+\n+    protected String alarmName = \"\";\n+\n+    private boolean inService = false;\n+\n+    protected @Nullable ScheduledFuture<?> future = null;\n+\n+    public JablotronAlarmHandler(Thing thing, String alarmName) {\n+        super(thing);\n+        this.alarmName = alarmName;\n+    }\n+\n+    @Override\n+    public void bridgeStatusChanged(ThingStatusInfo bridgeStatusInfo) {\n+        super.bridgeStatusChanged(bridgeStatusInfo);\n+        if (ThingStatus.UNINITIALIZED == bridgeStatusInfo.getStatus()) {\n+            cleanup();\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        super.dispose();\n+        cleanup();\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        thingConfig = getConfigAs(JablotronDeviceConfig.class);\n+        scheduler.execute(this::doInit);\n+        updateStatus(ThingStatus.ONLINE);\n+    }\n+\n+    public boolean isInService() {\n+        return inService;\n+    }\n+\n+    public String getAlarmName() {\n+        return alarmName;\n+    }\n+\n+    protected void updateSegmentStatus(JablotronServiceDetailSegment segment) {\n+    }\n+\n+    private void cleanup() {\n+        logger.debug(\"doing cleanup...\");\n+        if (future != null) {\n+            future.cancel(true);\n+        }\n+    }\n+\n+    protected State getCheckTime() {\n+        ZonedDateTime zdt = ZonedDateTime.ofInstant(Calendar.getInstance().toInstant(), ZoneId.systemDefault());\n+        return new DateTimeType(zdt);\n+    }\n+\n+    protected void doInit() {\n+        future = scheduler.scheduleWithFixedDelay(this::updateAlarmStatus, 1, thingConfig.getRefresh(),\n+                TimeUnit.SECONDS);\n+    }\n+\n+    protected synchronized @Nullable JablotronDataUpdateResponse sendGetStatusRequest() {\n+        JablotronBridgeHandler handler = getBridgeHandler();\n+        if (handler != null) {\n+            return handler.sendGetStatusRequest(getThing());\n+        }\n+        return null;\n+    }\n+\n+    protected synchronized boolean updateAlarmStatus() {\n+        JablotronDataUpdateResponse dataUpdate = sendGetStatusRequest();\n+        if (dataUpdate == null) {\n+            return false;\n+        }\n+\n+        if (dataUpdate.isStatus()) {\n+            updateState(CHANNEL_LAST_CHECK_TIME, getCheckTime());\n+            List<JablotronServiceData> serviceData = dataUpdate.getData().getServiceData();\n+            for (JablotronServiceData data : serviceData) {\n+                List<JablotronService> services = data.getData();\n+                for (JablotronService service : services) {\n+                    JablotronServiceDetail detail = service.getData();\n+                    for (JablotronServiceDetailSegment segment : detail.getSegments()) {\n+                        updateSegmentStatus(segment);\n+                    }\n+                }\n+\n+            }\n+        } else {\n+            logger.debug(\"Error during alarm status update: {}\", dataUpdate.getErrorMessage());\n+        }\n+\n+        List<JablotronHistoryDataEvent> events = sendGetEventHistory(alarmName);\n+        if (events != null && events.size() > 0) {\n+            JablotronHistoryDataEvent event = events.get(0);\n+            updateLastEvent(event);\n+        }\n+\n+        return true;\n+    }\n+\n+    protected @Nullable List<JablotronHistoryDataEvent> sendGetEventHistory(String alarm) {\n+        JablotronBridgeHandler handler = getBridgeHandler();\n+        if (handler != null) {\n+            return handler.sendGetEventHistory(getThing(), alarm);\n+        }\n+        return null;\n+    }\n+\n+    protected void updateLastEvent(JablotronHistoryDataEvent event) {\n+        updateState(CHANNEL_LAST_EVENT_TIME, new DateTimeType(getZonedDateTime(event.getDate())));\n+        updateState(CHANNEL_LAST_EVENT, new StringType(event.getEventText()));\n+        updateState(CHANNEL_LAST_EVENT_CLASS, new StringType(event.getIconType()));\n+        updateState(CHANNEL_LAST_EVENT_INVOKER, new StringType(event.getInvokerName()));\n+\n+        // oasis does not have sections\n+        if (getThing().getChannel(CHANNEL_LAST_EVENT_SECTION) != null) {\n+            updateState(CHANNEL_LAST_EVENT_SECTION, new StringType(event.getSectionName()));\n+        }\n+    }\n+\n+    public ZonedDateTime getZonedDateTime(String date) {\n+        return ZonedDateTime.parse(date.substring(0, 22) + \":\" + date.substring(22, 24),\n+                DateTimeFormatter.ISO_DATE_TIME);\n+    }\n+\n+    protected @Nullable JablotronControlResponse sendUserCode(String section, String key, String status, String code) {\n+        JablotronControlResponse response = null;\n+        JablotronBridgeHandler handler = getBridgeHandler();\n+        if (handler != null) {\n+            try {\n+                response = handler.sendUserCode(getThing(), section, key, status, code);\n+            } catch (SecurityException se) {\n+                response = handler.sendUserCode(getThing(), section, key, status, code);\n+            }\n+        }\n+        return response;\n+    }\n+\n+    protected @Nullable JablotronBridgeHandler getBridgeHandler() {\n+        if (getBridge() != null && getBridge().getHandler() != null) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjU5MjY2Mw=="}, "originalCommit": {"oid": "a590e81e68f4bb50a74b76dce0635a7906ca04ab"}, "originalPosition": 198}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA0MzY3NDM1OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.jablotron/src/main/java/org/openhab/binding/jablotron/internal/handler/JablotronBridgeHandler.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMFQxOTo0NjoyNFrOHQDSew==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMVQxNjowMzoxOFrOHQkz2Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjU5MzE0Nw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                @Nullable\n          \n          \n            \n                ScheduledFuture<?> future = null;\n          \n          \n            \n                private @Nullable ScheduledFuture<?> future = null;", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r486593147", "createdAt": "2020-09-10T19:46:24Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.jablotron/src/main/java/org/openhab/binding/jablotron/internal/handler/JablotronBridgeHandler.java", "diffHunk": "@@ -0,0 +1,385 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.jablotron.internal.handler;\n+\n+import static org.openhab.binding.jablotron.JablotronBindingConstants.*;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.eclipse.jetty.http.HttpHeader;\n+import org.eclipse.jetty.http.HttpMethod;\n+import org.eclipse.smarthome.core.thing.*;\n+import org.eclipse.smarthome.core.thing.binding.BaseBridgeHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.openhab.binding.jablotron.internal.config.JablotronBridgeConfig;\n+import org.openhab.binding.jablotron.internal.discovery.JablotronDiscoveryService;\n+import org.openhab.binding.jablotron.internal.model.*;\n+import org.openhab.binding.jablotron.internal.model.ja100f.JablotronGetPGResponse;\n+import org.openhab.binding.jablotron.internal.model.ja100f.JablotronGetSectionsResponse;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.JsonSyntaxException;\n+\n+/**\n+ * The {@link JablotronBridgeHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Ondrej Pecta - Initial contribution\n+ */\n+@NonNullByDefault\n+public class JablotronBridgeHandler extends BaseBridgeHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(JablotronBridgeHandler.class);\n+\n+    private final Gson gson = new Gson();\n+\n+    final HttpClient httpClient;\n+\n+    @Nullable\n+    ScheduledFuture<?> future = null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a590e81e68f4bb50a74b76dce0635a7906ca04ab"}, "originalPosition": 64}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzE0MjM2MQ==", "bodyText": "fixed", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r487142361", "createdAt": "2020-09-11T16:03:18Z", "author": {"login": "octa22"}, "path": "bundles/org.openhab.binding.jablotron/src/main/java/org/openhab/binding/jablotron/internal/handler/JablotronBridgeHandler.java", "diffHunk": "@@ -0,0 +1,385 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.jablotron.internal.handler;\n+\n+import static org.openhab.binding.jablotron.JablotronBindingConstants.*;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.eclipse.jetty.http.HttpHeader;\n+import org.eclipse.jetty.http.HttpMethod;\n+import org.eclipse.smarthome.core.thing.*;\n+import org.eclipse.smarthome.core.thing.binding.BaseBridgeHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.openhab.binding.jablotron.internal.config.JablotronBridgeConfig;\n+import org.openhab.binding.jablotron.internal.discovery.JablotronDiscoveryService;\n+import org.openhab.binding.jablotron.internal.model.*;\n+import org.openhab.binding.jablotron.internal.model.ja100f.JablotronGetPGResponse;\n+import org.openhab.binding.jablotron.internal.model.ja100f.JablotronGetSectionsResponse;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.JsonSyntaxException;\n+\n+/**\n+ * The {@link JablotronBridgeHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Ondrej Pecta - Initial contribution\n+ */\n+@NonNullByDefault\n+public class JablotronBridgeHandler extends BaseBridgeHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(JablotronBridgeHandler.class);\n+\n+    private final Gson gson = new Gson();\n+\n+    final HttpClient httpClient;\n+\n+    @Nullable\n+    ScheduledFuture<?> future = null;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjU5MzE0Nw=="}, "originalCommit": {"oid": "a590e81e68f4bb50a74b76dce0635a7906ca04ab"}, "originalPosition": 64}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA0MzY3ODg3OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.jablotron/src/main/java/org/openhab/binding/jablotron/internal/handler/JablotronBridgeHandler.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMFQxOTo0Nzo1MVrOHQDVQA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMVQxNjowNDoxNFrOHQk2Ag==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjU5Mzg1Ng==", "bodyText": "The annotation could be removed, as the compiler is more intelligent on local variables to see, that you're doing a null check.", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r486593856", "createdAt": "2020-09-10T19:47:51Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.jablotron/src/main/java/org/openhab/binding/jablotron/internal/handler/JablotronBridgeHandler.java", "diffHunk": "@@ -0,0 +1,385 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.jablotron.internal.handler;\n+\n+import static org.openhab.binding.jablotron.JablotronBindingConstants.*;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.eclipse.jetty.http.HttpHeader;\n+import org.eclipse.jetty.http.HttpMethod;\n+import org.eclipse.smarthome.core.thing.*;\n+import org.eclipse.smarthome.core.thing.binding.BaseBridgeHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.openhab.binding.jablotron.internal.config.JablotronBridgeConfig;\n+import org.openhab.binding.jablotron.internal.discovery.JablotronDiscoveryService;\n+import org.openhab.binding.jablotron.internal.model.*;\n+import org.openhab.binding.jablotron.internal.model.ja100f.JablotronGetPGResponse;\n+import org.openhab.binding.jablotron.internal.model.ja100f.JablotronGetSectionsResponse;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.JsonSyntaxException;\n+\n+/**\n+ * The {@link JablotronBridgeHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Ondrej Pecta - Initial contribution\n+ */\n+@NonNullByDefault\n+public class JablotronBridgeHandler extends BaseBridgeHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(JablotronBridgeHandler.class);\n+\n+    private final Gson gson = new Gson();\n+\n+    final HttpClient httpClient;\n+\n+    @Nullable\n+    ScheduledFuture<?> future = null;\n+\n+    /**\n+     * Our configuration\n+     */\n+    public JablotronBridgeConfig bridgeConfig = new JablotronBridgeConfig();\n+\n+    public JablotronBridgeHandler(Bridge thing, HttpClient httpClient) {\n+        super(thing);\n+        this.httpClient = httpClient;\n+    }\n+\n+    @Override\n+    public Collection<Class<? extends ThingHandlerService>> getServices() {\n+        return Collections.singleton(JablotronDiscoveryService.class);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        bridgeConfig = getConfigAs(JablotronBridgeConfig.class);\n+        scheduler.execute(this::login);\n+        future = scheduler.scheduleWithFixedDelay(this::updateAlarmThings, 30, bridgeConfig.getRefresh(),\n+                TimeUnit.SECONDS);\n+    }\n+\n+    private void updateAlarmThings() {\n+        @Nullable\n+        List<JablotronDiscoveredService> services = discoverServices();\n+        if (services != null) {\n+            for (JablotronDiscoveredService service : services) {\n+                updateAlarmThing(service);\n+            }\n+        }\n+    }\n+\n+    private void updateAlarmThing(JablotronDiscoveredService service) {\n+        for (Thing th : getThing().getThings()) {\n+            @Nullable\n+            JablotronAlarmHandler handler = (JablotronAlarmHandler) th.getHandler();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a590e81e68f4bb50a74b76dce0635a7906ca04ab"}, "originalPosition": 106}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzE0MjkxNA==", "bodyText": "ok", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r487142914", "createdAt": "2020-09-11T16:04:14Z", "author": {"login": "octa22"}, "path": "bundles/org.openhab.binding.jablotron/src/main/java/org/openhab/binding/jablotron/internal/handler/JablotronBridgeHandler.java", "diffHunk": "@@ -0,0 +1,385 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.jablotron.internal.handler;\n+\n+import static org.openhab.binding.jablotron.JablotronBindingConstants.*;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.eclipse.jetty.http.HttpHeader;\n+import org.eclipse.jetty.http.HttpMethod;\n+import org.eclipse.smarthome.core.thing.*;\n+import org.eclipse.smarthome.core.thing.binding.BaseBridgeHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.openhab.binding.jablotron.internal.config.JablotronBridgeConfig;\n+import org.openhab.binding.jablotron.internal.discovery.JablotronDiscoveryService;\n+import org.openhab.binding.jablotron.internal.model.*;\n+import org.openhab.binding.jablotron.internal.model.ja100f.JablotronGetPGResponse;\n+import org.openhab.binding.jablotron.internal.model.ja100f.JablotronGetSectionsResponse;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.JsonSyntaxException;\n+\n+/**\n+ * The {@link JablotronBridgeHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Ondrej Pecta - Initial contribution\n+ */\n+@NonNullByDefault\n+public class JablotronBridgeHandler extends BaseBridgeHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(JablotronBridgeHandler.class);\n+\n+    private final Gson gson = new Gson();\n+\n+    final HttpClient httpClient;\n+\n+    @Nullable\n+    ScheduledFuture<?> future = null;\n+\n+    /**\n+     * Our configuration\n+     */\n+    public JablotronBridgeConfig bridgeConfig = new JablotronBridgeConfig();\n+\n+    public JablotronBridgeHandler(Bridge thing, HttpClient httpClient) {\n+        super(thing);\n+        this.httpClient = httpClient;\n+    }\n+\n+    @Override\n+    public Collection<Class<? extends ThingHandlerService>> getServices() {\n+        return Collections.singleton(JablotronDiscoveryService.class);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        bridgeConfig = getConfigAs(JablotronBridgeConfig.class);\n+        scheduler.execute(this::login);\n+        future = scheduler.scheduleWithFixedDelay(this::updateAlarmThings, 30, bridgeConfig.getRefresh(),\n+                TimeUnit.SECONDS);\n+    }\n+\n+    private void updateAlarmThings() {\n+        @Nullable\n+        List<JablotronDiscoveredService> services = discoverServices();\n+        if (services != null) {\n+            for (JablotronDiscoveredService service : services) {\n+                updateAlarmThing(service);\n+            }\n+        }\n+    }\n+\n+    private void updateAlarmThing(JablotronDiscoveredService service) {\n+        for (Thing th : getThing().getThings()) {\n+            @Nullable\n+            JablotronAlarmHandler handler = (JablotronAlarmHandler) th.getHandler();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjU5Mzg1Ng=="}, "originalCommit": {"oid": "a590e81e68f4bb50a74b76dce0635a7906ca04ab"}, "originalPosition": 106}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA0MzY4MzI4OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.jablotron/src/main/java/org/openhab/binding/jablotron/internal/handler/JablotronBridgeHandler.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMFQxOTo0OToyMVrOHQDX6A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMVQxNjowNjoyNVrOHQk66A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjU5NDUzNg==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                if (!\"\".equals(service.getWarning())) {\n          \n          \n            \n                                if (!service.getWarning().isEmpty()) {", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r486594536", "createdAt": "2020-09-10T19:49:21Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.jablotron/src/main/java/org/openhab/binding/jablotron/internal/handler/JablotronBridgeHandler.java", "diffHunk": "@@ -0,0 +1,385 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.jablotron.internal.handler;\n+\n+import static org.openhab.binding.jablotron.JablotronBindingConstants.*;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.eclipse.jetty.http.HttpHeader;\n+import org.eclipse.jetty.http.HttpMethod;\n+import org.eclipse.smarthome.core.thing.*;\n+import org.eclipse.smarthome.core.thing.binding.BaseBridgeHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.openhab.binding.jablotron.internal.config.JablotronBridgeConfig;\n+import org.openhab.binding.jablotron.internal.discovery.JablotronDiscoveryService;\n+import org.openhab.binding.jablotron.internal.model.*;\n+import org.openhab.binding.jablotron.internal.model.ja100f.JablotronGetPGResponse;\n+import org.openhab.binding.jablotron.internal.model.ja100f.JablotronGetSectionsResponse;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.JsonSyntaxException;\n+\n+/**\n+ * The {@link JablotronBridgeHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Ondrej Pecta - Initial contribution\n+ */\n+@NonNullByDefault\n+public class JablotronBridgeHandler extends BaseBridgeHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(JablotronBridgeHandler.class);\n+\n+    private final Gson gson = new Gson();\n+\n+    final HttpClient httpClient;\n+\n+    @Nullable\n+    ScheduledFuture<?> future = null;\n+\n+    /**\n+     * Our configuration\n+     */\n+    public JablotronBridgeConfig bridgeConfig = new JablotronBridgeConfig();\n+\n+    public JablotronBridgeHandler(Bridge thing, HttpClient httpClient) {\n+        super(thing);\n+        this.httpClient = httpClient;\n+    }\n+\n+    @Override\n+    public Collection<Class<? extends ThingHandlerService>> getServices() {\n+        return Collections.singleton(JablotronDiscoveryService.class);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        bridgeConfig = getConfigAs(JablotronBridgeConfig.class);\n+        scheduler.execute(this::login);\n+        future = scheduler.scheduleWithFixedDelay(this::updateAlarmThings, 30, bridgeConfig.getRefresh(),\n+                TimeUnit.SECONDS);\n+    }\n+\n+    private void updateAlarmThings() {\n+        @Nullable\n+        List<JablotronDiscoveredService> services = discoverServices();\n+        if (services != null) {\n+            for (JablotronDiscoveredService service : services) {\n+                updateAlarmThing(service);\n+            }\n+        }\n+    }\n+\n+    private void updateAlarmThing(JablotronDiscoveredService service) {\n+        for (Thing th : getThing().getThings()) {\n+            @Nullable\n+            JablotronAlarmHandler handler = (JablotronAlarmHandler) th.getHandler();\n+\n+            if (handler == null) {\n+                logger.debug(\"Thing handler is null\");\n+                continue;\n+            }\n+\n+            if (String.valueOf(service.getId()).equals(handler.thingConfig.getServiceId())) {\n+                if (\"ENABLED\".equals(service.getStatus())) {\n+                    if (!\"\".equals(service.getWarning())) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a590e81e68f4bb50a74b76dce0635a7906ca04ab"}, "originalPosition": 115}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzE0NDE2OA==", "bodyText": "fixed", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r487144168", "createdAt": "2020-09-11T16:06:25Z", "author": {"login": "octa22"}, "path": "bundles/org.openhab.binding.jablotron/src/main/java/org/openhab/binding/jablotron/internal/handler/JablotronBridgeHandler.java", "diffHunk": "@@ -0,0 +1,385 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.jablotron.internal.handler;\n+\n+import static org.openhab.binding.jablotron.JablotronBindingConstants.*;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.eclipse.jetty.http.HttpHeader;\n+import org.eclipse.jetty.http.HttpMethod;\n+import org.eclipse.smarthome.core.thing.*;\n+import org.eclipse.smarthome.core.thing.binding.BaseBridgeHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.openhab.binding.jablotron.internal.config.JablotronBridgeConfig;\n+import org.openhab.binding.jablotron.internal.discovery.JablotronDiscoveryService;\n+import org.openhab.binding.jablotron.internal.model.*;\n+import org.openhab.binding.jablotron.internal.model.ja100f.JablotronGetPGResponse;\n+import org.openhab.binding.jablotron.internal.model.ja100f.JablotronGetSectionsResponse;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.JsonSyntaxException;\n+\n+/**\n+ * The {@link JablotronBridgeHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Ondrej Pecta - Initial contribution\n+ */\n+@NonNullByDefault\n+public class JablotronBridgeHandler extends BaseBridgeHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(JablotronBridgeHandler.class);\n+\n+    private final Gson gson = new Gson();\n+\n+    final HttpClient httpClient;\n+\n+    @Nullable\n+    ScheduledFuture<?> future = null;\n+\n+    /**\n+     * Our configuration\n+     */\n+    public JablotronBridgeConfig bridgeConfig = new JablotronBridgeConfig();\n+\n+    public JablotronBridgeHandler(Bridge thing, HttpClient httpClient) {\n+        super(thing);\n+        this.httpClient = httpClient;\n+    }\n+\n+    @Override\n+    public Collection<Class<? extends ThingHandlerService>> getServices() {\n+        return Collections.singleton(JablotronDiscoveryService.class);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        bridgeConfig = getConfigAs(JablotronBridgeConfig.class);\n+        scheduler.execute(this::login);\n+        future = scheduler.scheduleWithFixedDelay(this::updateAlarmThings, 30, bridgeConfig.getRefresh(),\n+                TimeUnit.SECONDS);\n+    }\n+\n+    private void updateAlarmThings() {\n+        @Nullable\n+        List<JablotronDiscoveredService> services = discoverServices();\n+        if (services != null) {\n+            for (JablotronDiscoveredService service : services) {\n+                updateAlarmThing(service);\n+            }\n+        }\n+    }\n+\n+    private void updateAlarmThing(JablotronDiscoveredService service) {\n+        for (Thing th : getThing().getThings()) {\n+            @Nullable\n+            JablotronAlarmHandler handler = (JablotronAlarmHandler) th.getHandler();\n+\n+            if (handler == null) {\n+                logger.debug(\"Thing handler is null\");\n+                continue;\n+            }\n+\n+            if (String.valueOf(service.getId()).equals(handler.thingConfig.getServiceId())) {\n+                if (\"ENABLED\".equals(service.getStatus())) {\n+                    if (!\"\".equals(service.getWarning())) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjU5NDUzNg=="}, "originalCommit": {"oid": "a590e81e68f4bb50a74b76dce0635a7906ca04ab"}, "originalPosition": 115}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA0MzY4NTk1OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.jablotron/src/main/java/org/openhab/binding/jablotron/internal/handler/JablotronBridgeHandler.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMFQxOTo1MDoxMFrOHQDZfg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMlQwOTo1MzozOFrOHQ0EUg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjU5NDk0Mg==", "bodyText": "The log message could be removed, as the status update is already logged by the framework.", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r486594942", "createdAt": "2020-09-10T19:50:10Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.jablotron/src/main/java/org/openhab/binding/jablotron/internal/handler/JablotronBridgeHandler.java", "diffHunk": "@@ -0,0 +1,385 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.jablotron.internal.handler;\n+\n+import static org.openhab.binding.jablotron.JablotronBindingConstants.*;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.eclipse.jetty.http.HttpHeader;\n+import org.eclipse.jetty.http.HttpMethod;\n+import org.eclipse.smarthome.core.thing.*;\n+import org.eclipse.smarthome.core.thing.binding.BaseBridgeHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.openhab.binding.jablotron.internal.config.JablotronBridgeConfig;\n+import org.openhab.binding.jablotron.internal.discovery.JablotronDiscoveryService;\n+import org.openhab.binding.jablotron.internal.model.*;\n+import org.openhab.binding.jablotron.internal.model.ja100f.JablotronGetPGResponse;\n+import org.openhab.binding.jablotron.internal.model.ja100f.JablotronGetSectionsResponse;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.JsonSyntaxException;\n+\n+/**\n+ * The {@link JablotronBridgeHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Ondrej Pecta - Initial contribution\n+ */\n+@NonNullByDefault\n+public class JablotronBridgeHandler extends BaseBridgeHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(JablotronBridgeHandler.class);\n+\n+    private final Gson gson = new Gson();\n+\n+    final HttpClient httpClient;\n+\n+    @Nullable\n+    ScheduledFuture<?> future = null;\n+\n+    /**\n+     * Our configuration\n+     */\n+    public JablotronBridgeConfig bridgeConfig = new JablotronBridgeConfig();\n+\n+    public JablotronBridgeHandler(Bridge thing, HttpClient httpClient) {\n+        super(thing);\n+        this.httpClient = httpClient;\n+    }\n+\n+    @Override\n+    public Collection<Class<? extends ThingHandlerService>> getServices() {\n+        return Collections.singleton(JablotronDiscoveryService.class);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        bridgeConfig = getConfigAs(JablotronBridgeConfig.class);\n+        scheduler.execute(this::login);\n+        future = scheduler.scheduleWithFixedDelay(this::updateAlarmThings, 30, bridgeConfig.getRefresh(),\n+                TimeUnit.SECONDS);\n+    }\n+\n+    private void updateAlarmThings() {\n+        @Nullable\n+        List<JablotronDiscoveredService> services = discoverServices();\n+        if (services != null) {\n+            for (JablotronDiscoveredService service : services) {\n+                updateAlarmThing(service);\n+            }\n+        }\n+    }\n+\n+    private void updateAlarmThing(JablotronDiscoveredService service) {\n+        for (Thing th : getThing().getThings()) {\n+            @Nullable\n+            JablotronAlarmHandler handler = (JablotronAlarmHandler) th.getHandler();\n+\n+            if (handler == null) {\n+                logger.debug(\"Thing handler is null\");\n+                continue;\n+            }\n+\n+            if (String.valueOf(service.getId()).equals(handler.thingConfig.getServiceId())) {\n+                if (\"ENABLED\".equals(service.getStatus())) {\n+                    if (!\"\".equals(service.getWarning())) {\n+                        logger.debug(\"Alarm with service id: {} warning: {}\", service.getId(), service.getWarning());\n+                    }\n+                    handler.setStatus(ThingStatus.ONLINE, ThingStatusDetail.NONE, service.getWarning());\n+                    if (\"ALARM\".equals(service.getWarning()) || \"TAMPER\".equals(service.getWarning())) {\n+                        handler.triggerAlarm(service);\n+                    }\n+                    handler.setInService(\"SERVICE\".equals(service.getWarning()));\n+                } else {\n+                    logger.debug(\"Alarm with service id: {} is offline\", service.getId());\n+                    handler.setStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, service.getStatus());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a590e81e68f4bb50a74b76dce0635a7906ca04ab"}, "originalPosition": 125}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzE0NTUwMQ==", "bodyText": "hmm I do not get it. The logger logs something different than status update. Keeping", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r487145501", "createdAt": "2020-09-11T16:08:45Z", "author": {"login": "octa22"}, "path": "bundles/org.openhab.binding.jablotron/src/main/java/org/openhab/binding/jablotron/internal/handler/JablotronBridgeHandler.java", "diffHunk": "@@ -0,0 +1,385 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.jablotron.internal.handler;\n+\n+import static org.openhab.binding.jablotron.JablotronBindingConstants.*;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.eclipse.jetty.http.HttpHeader;\n+import org.eclipse.jetty.http.HttpMethod;\n+import org.eclipse.smarthome.core.thing.*;\n+import org.eclipse.smarthome.core.thing.binding.BaseBridgeHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.openhab.binding.jablotron.internal.config.JablotronBridgeConfig;\n+import org.openhab.binding.jablotron.internal.discovery.JablotronDiscoveryService;\n+import org.openhab.binding.jablotron.internal.model.*;\n+import org.openhab.binding.jablotron.internal.model.ja100f.JablotronGetPGResponse;\n+import org.openhab.binding.jablotron.internal.model.ja100f.JablotronGetSectionsResponse;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.JsonSyntaxException;\n+\n+/**\n+ * The {@link JablotronBridgeHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Ondrej Pecta - Initial contribution\n+ */\n+@NonNullByDefault\n+public class JablotronBridgeHandler extends BaseBridgeHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(JablotronBridgeHandler.class);\n+\n+    private final Gson gson = new Gson();\n+\n+    final HttpClient httpClient;\n+\n+    @Nullable\n+    ScheduledFuture<?> future = null;\n+\n+    /**\n+     * Our configuration\n+     */\n+    public JablotronBridgeConfig bridgeConfig = new JablotronBridgeConfig();\n+\n+    public JablotronBridgeHandler(Bridge thing, HttpClient httpClient) {\n+        super(thing);\n+        this.httpClient = httpClient;\n+    }\n+\n+    @Override\n+    public Collection<Class<? extends ThingHandlerService>> getServices() {\n+        return Collections.singleton(JablotronDiscoveryService.class);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        bridgeConfig = getConfigAs(JablotronBridgeConfig.class);\n+        scheduler.execute(this::login);\n+        future = scheduler.scheduleWithFixedDelay(this::updateAlarmThings, 30, bridgeConfig.getRefresh(),\n+                TimeUnit.SECONDS);\n+    }\n+\n+    private void updateAlarmThings() {\n+        @Nullable\n+        List<JablotronDiscoveredService> services = discoverServices();\n+        if (services != null) {\n+            for (JablotronDiscoveredService service : services) {\n+                updateAlarmThing(service);\n+            }\n+        }\n+    }\n+\n+    private void updateAlarmThing(JablotronDiscoveredService service) {\n+        for (Thing th : getThing().getThings()) {\n+            @Nullable\n+            JablotronAlarmHandler handler = (JablotronAlarmHandler) th.getHandler();\n+\n+            if (handler == null) {\n+                logger.debug(\"Thing handler is null\");\n+                continue;\n+            }\n+\n+            if (String.valueOf(service.getId()).equals(handler.thingConfig.getServiceId())) {\n+                if (\"ENABLED\".equals(service.getStatus())) {\n+                    if (!\"\".equals(service.getWarning())) {\n+                        logger.debug(\"Alarm with service id: {} warning: {}\", service.getId(), service.getWarning());\n+                    }\n+                    handler.setStatus(ThingStatus.ONLINE, ThingStatusDetail.NONE, service.getWarning());\n+                    if (\"ALARM\".equals(service.getWarning()) || \"TAMPER\".equals(service.getWarning())) {\n+                        handler.triggerAlarm(service);\n+                    }\n+                    handler.setInService(\"SERVICE\".equals(service.getWarning()));\n+                } else {\n+                    logger.debug(\"Alarm with service id: {} is offline\", service.getId());\n+                    handler.setStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, service.getStatus());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjU5NDk0Mg=="}, "originalCommit": {"oid": "a590e81e68f4bb50a74b76dce0635a7906ca04ab"}, "originalPosition": 125}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzM5MjMzOA==", "bodyText": "You're right, sorry.", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r487392338", "createdAt": "2020-09-12T09:53:38Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.jablotron/src/main/java/org/openhab/binding/jablotron/internal/handler/JablotronBridgeHandler.java", "diffHunk": "@@ -0,0 +1,385 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.jablotron.internal.handler;\n+\n+import static org.openhab.binding.jablotron.JablotronBindingConstants.*;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.eclipse.jetty.http.HttpHeader;\n+import org.eclipse.jetty.http.HttpMethod;\n+import org.eclipse.smarthome.core.thing.*;\n+import org.eclipse.smarthome.core.thing.binding.BaseBridgeHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.openhab.binding.jablotron.internal.config.JablotronBridgeConfig;\n+import org.openhab.binding.jablotron.internal.discovery.JablotronDiscoveryService;\n+import org.openhab.binding.jablotron.internal.model.*;\n+import org.openhab.binding.jablotron.internal.model.ja100f.JablotronGetPGResponse;\n+import org.openhab.binding.jablotron.internal.model.ja100f.JablotronGetSectionsResponse;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.JsonSyntaxException;\n+\n+/**\n+ * The {@link JablotronBridgeHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Ondrej Pecta - Initial contribution\n+ */\n+@NonNullByDefault\n+public class JablotronBridgeHandler extends BaseBridgeHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(JablotronBridgeHandler.class);\n+\n+    private final Gson gson = new Gson();\n+\n+    final HttpClient httpClient;\n+\n+    @Nullable\n+    ScheduledFuture<?> future = null;\n+\n+    /**\n+     * Our configuration\n+     */\n+    public JablotronBridgeConfig bridgeConfig = new JablotronBridgeConfig();\n+\n+    public JablotronBridgeHandler(Bridge thing, HttpClient httpClient) {\n+        super(thing);\n+        this.httpClient = httpClient;\n+    }\n+\n+    @Override\n+    public Collection<Class<? extends ThingHandlerService>> getServices() {\n+        return Collections.singleton(JablotronDiscoveryService.class);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        bridgeConfig = getConfigAs(JablotronBridgeConfig.class);\n+        scheduler.execute(this::login);\n+        future = scheduler.scheduleWithFixedDelay(this::updateAlarmThings, 30, bridgeConfig.getRefresh(),\n+                TimeUnit.SECONDS);\n+    }\n+\n+    private void updateAlarmThings() {\n+        @Nullable\n+        List<JablotronDiscoveredService> services = discoverServices();\n+        if (services != null) {\n+            for (JablotronDiscoveredService service : services) {\n+                updateAlarmThing(service);\n+            }\n+        }\n+    }\n+\n+    private void updateAlarmThing(JablotronDiscoveredService service) {\n+        for (Thing th : getThing().getThings()) {\n+            @Nullable\n+            JablotronAlarmHandler handler = (JablotronAlarmHandler) th.getHandler();\n+\n+            if (handler == null) {\n+                logger.debug(\"Thing handler is null\");\n+                continue;\n+            }\n+\n+            if (String.valueOf(service.getId()).equals(handler.thingConfig.getServiceId())) {\n+                if (\"ENABLED\".equals(service.getStatus())) {\n+                    if (!\"\".equals(service.getWarning())) {\n+                        logger.debug(\"Alarm with service id: {} warning: {}\", service.getId(), service.getWarning());\n+                    }\n+                    handler.setStatus(ThingStatus.ONLINE, ThingStatusDetail.NONE, service.getWarning());\n+                    if (\"ALARM\".equals(service.getWarning()) || \"TAMPER\".equals(service.getWarning())) {\n+                        handler.triggerAlarm(service);\n+                    }\n+                    handler.setInService(\"SERVICE\".equals(service.getWarning()));\n+                } else {\n+                    logger.debug(\"Alarm with service id: {} is offline\", service.getId());\n+                    handler.setStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, service.getStatus());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjU5NDk0Mg=="}, "originalCommit": {"oid": "a590e81e68f4bb50a74b76dce0635a7906ca04ab"}, "originalPosition": 125}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA0MzY5MzE1OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.jablotron/src/main/java/org/openhab/binding/jablotron/internal/handler/JablotronBridgeHandler.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMFQxOTo1MjoyNVrOHQDd_A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMVQxNjowOTozNFrOHQlBww==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjU5NjA5Mg==", "bodyText": "The log message could be removed, as the status update is already logged by the framework. Same for below.", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r486596092", "createdAt": "2020-09-10T19:52:25Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.jablotron/src/main/java/org/openhab/binding/jablotron/internal/handler/JablotronBridgeHandler.java", "diffHunk": "@@ -0,0 +1,385 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.jablotron.internal.handler;\n+\n+import static org.openhab.binding.jablotron.JablotronBindingConstants.*;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.eclipse.jetty.http.HttpHeader;\n+import org.eclipse.jetty.http.HttpMethod;\n+import org.eclipse.smarthome.core.thing.*;\n+import org.eclipse.smarthome.core.thing.binding.BaseBridgeHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.openhab.binding.jablotron.internal.config.JablotronBridgeConfig;\n+import org.openhab.binding.jablotron.internal.discovery.JablotronDiscoveryService;\n+import org.openhab.binding.jablotron.internal.model.*;\n+import org.openhab.binding.jablotron.internal.model.ja100f.JablotronGetPGResponse;\n+import org.openhab.binding.jablotron.internal.model.ja100f.JablotronGetSectionsResponse;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.JsonSyntaxException;\n+\n+/**\n+ * The {@link JablotronBridgeHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Ondrej Pecta - Initial contribution\n+ */\n+@NonNullByDefault\n+public class JablotronBridgeHandler extends BaseBridgeHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(JablotronBridgeHandler.class);\n+\n+    private final Gson gson = new Gson();\n+\n+    final HttpClient httpClient;\n+\n+    @Nullable\n+    ScheduledFuture<?> future = null;\n+\n+    /**\n+     * Our configuration\n+     */\n+    public JablotronBridgeConfig bridgeConfig = new JablotronBridgeConfig();\n+\n+    public JablotronBridgeHandler(Bridge thing, HttpClient httpClient) {\n+        super(thing);\n+        this.httpClient = httpClient;\n+    }\n+\n+    @Override\n+    public Collection<Class<? extends ThingHandlerService>> getServices() {\n+        return Collections.singleton(JablotronDiscoveryService.class);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        bridgeConfig = getConfigAs(JablotronBridgeConfig.class);\n+        scheduler.execute(this::login);\n+        future = scheduler.scheduleWithFixedDelay(this::updateAlarmThings, 30, bridgeConfig.getRefresh(),\n+                TimeUnit.SECONDS);\n+    }\n+\n+    private void updateAlarmThings() {\n+        @Nullable\n+        List<JablotronDiscoveredService> services = discoverServices();\n+        if (services != null) {\n+            for (JablotronDiscoveredService service : services) {\n+                updateAlarmThing(service);\n+            }\n+        }\n+    }\n+\n+    private void updateAlarmThing(JablotronDiscoveredService service) {\n+        for (Thing th : getThing().getThings()) {\n+            @Nullable\n+            JablotronAlarmHandler handler = (JablotronAlarmHandler) th.getHandler();\n+\n+            if (handler == null) {\n+                logger.debug(\"Thing handler is null\");\n+                continue;\n+            }\n+\n+            if (String.valueOf(service.getId()).equals(handler.thingConfig.getServiceId())) {\n+                if (\"ENABLED\".equals(service.getStatus())) {\n+                    if (!\"\".equals(service.getWarning())) {\n+                        logger.debug(\"Alarm with service id: {} warning: {}\", service.getId(), service.getWarning());\n+                    }\n+                    handler.setStatus(ThingStatus.ONLINE, ThingStatusDetail.NONE, service.getWarning());\n+                    if (\"ALARM\".equals(service.getWarning()) || \"TAMPER\".equals(service.getWarning())) {\n+                        handler.triggerAlarm(service);\n+                    }\n+                    handler.setInService(\"SERVICE\".equals(service.getWarning()));\n+                } else {\n+                    logger.debug(\"Alarm with service id: {} is offline\", service.getId());\n+                    handler.setStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, service.getStatus());\n+                }\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        super.dispose();\n+        if (future != null) {\n+            future.cancel(true);\n+        }\n+        logout();\n+    }\n+\n+    private @Nullable <T> T sendJsonMessage(String url, String urlParameters, Class<T> classOfT) {\n+        return sendMessage(url, urlParameters, classOfT, APPLICATION_JSON, true);\n+    }\n+\n+    private @Nullable <T> T sendJsonMessage(String url, String urlParameters, Class<T> classOfT, boolean relogin) {\n+        return sendMessage(url, urlParameters, classOfT, APPLICATION_JSON, relogin);\n+    }\n+\n+    private @Nullable <T> T sendUrlEncodedMessage(String url, String urlParameters, Class<T> classOfT) {\n+        return sendMessage(url, urlParameters, classOfT, WWW_FORM_URLENCODED, true);\n+    }\n+\n+    private @Nullable <T> T sendMessage(String url, String urlParameters, Class<T> classOfT, String encoding,\n+            boolean relogin) {\n+        try {\n+            ContentResponse resp = createRequest(url).content(new StringContentProvider(urlParameters), encoding)\n+                    .send();\n+\n+            logger.trace(\"Request: {} with data: {}\", url, urlParameters);\n+            String line = resp.getContentAsString();\n+            logger.trace(\"Response: {}\", line);\n+            return gson.fromJson(line, classOfT);\n+        } catch (TimeoutException e) {\n+            logger.debug(\"Timeout during calling url: {}\", url, e);\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                    \"Timeout during calling url: \" + url);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a590e81e68f4bb50a74b76dce0635a7906ca04ab"}, "originalPosition": 165}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzE0NTkyMw==", "bodyText": "OK", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r487145923", "createdAt": "2020-09-11T16:09:34Z", "author": {"login": "octa22"}, "path": "bundles/org.openhab.binding.jablotron/src/main/java/org/openhab/binding/jablotron/internal/handler/JablotronBridgeHandler.java", "diffHunk": "@@ -0,0 +1,385 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.jablotron.internal.handler;\n+\n+import static org.openhab.binding.jablotron.JablotronBindingConstants.*;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.eclipse.jetty.http.HttpHeader;\n+import org.eclipse.jetty.http.HttpMethod;\n+import org.eclipse.smarthome.core.thing.*;\n+import org.eclipse.smarthome.core.thing.binding.BaseBridgeHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.openhab.binding.jablotron.internal.config.JablotronBridgeConfig;\n+import org.openhab.binding.jablotron.internal.discovery.JablotronDiscoveryService;\n+import org.openhab.binding.jablotron.internal.model.*;\n+import org.openhab.binding.jablotron.internal.model.ja100f.JablotronGetPGResponse;\n+import org.openhab.binding.jablotron.internal.model.ja100f.JablotronGetSectionsResponse;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.JsonSyntaxException;\n+\n+/**\n+ * The {@link JablotronBridgeHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Ondrej Pecta - Initial contribution\n+ */\n+@NonNullByDefault\n+public class JablotronBridgeHandler extends BaseBridgeHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(JablotronBridgeHandler.class);\n+\n+    private final Gson gson = new Gson();\n+\n+    final HttpClient httpClient;\n+\n+    @Nullable\n+    ScheduledFuture<?> future = null;\n+\n+    /**\n+     * Our configuration\n+     */\n+    public JablotronBridgeConfig bridgeConfig = new JablotronBridgeConfig();\n+\n+    public JablotronBridgeHandler(Bridge thing, HttpClient httpClient) {\n+        super(thing);\n+        this.httpClient = httpClient;\n+    }\n+\n+    @Override\n+    public Collection<Class<? extends ThingHandlerService>> getServices() {\n+        return Collections.singleton(JablotronDiscoveryService.class);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        bridgeConfig = getConfigAs(JablotronBridgeConfig.class);\n+        scheduler.execute(this::login);\n+        future = scheduler.scheduleWithFixedDelay(this::updateAlarmThings, 30, bridgeConfig.getRefresh(),\n+                TimeUnit.SECONDS);\n+    }\n+\n+    private void updateAlarmThings() {\n+        @Nullable\n+        List<JablotronDiscoveredService> services = discoverServices();\n+        if (services != null) {\n+            for (JablotronDiscoveredService service : services) {\n+                updateAlarmThing(service);\n+            }\n+        }\n+    }\n+\n+    private void updateAlarmThing(JablotronDiscoveredService service) {\n+        for (Thing th : getThing().getThings()) {\n+            @Nullable\n+            JablotronAlarmHandler handler = (JablotronAlarmHandler) th.getHandler();\n+\n+            if (handler == null) {\n+                logger.debug(\"Thing handler is null\");\n+                continue;\n+            }\n+\n+            if (String.valueOf(service.getId()).equals(handler.thingConfig.getServiceId())) {\n+                if (\"ENABLED\".equals(service.getStatus())) {\n+                    if (!\"\".equals(service.getWarning())) {\n+                        logger.debug(\"Alarm with service id: {} warning: {}\", service.getId(), service.getWarning());\n+                    }\n+                    handler.setStatus(ThingStatus.ONLINE, ThingStatusDetail.NONE, service.getWarning());\n+                    if (\"ALARM\".equals(service.getWarning()) || \"TAMPER\".equals(service.getWarning())) {\n+                        handler.triggerAlarm(service);\n+                    }\n+                    handler.setInService(\"SERVICE\".equals(service.getWarning()));\n+                } else {\n+                    logger.debug(\"Alarm with service id: {} is offline\", service.getId());\n+                    handler.setStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, service.getStatus());\n+                }\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        super.dispose();\n+        if (future != null) {\n+            future.cancel(true);\n+        }\n+        logout();\n+    }\n+\n+    private @Nullable <T> T sendJsonMessage(String url, String urlParameters, Class<T> classOfT) {\n+        return sendMessage(url, urlParameters, classOfT, APPLICATION_JSON, true);\n+    }\n+\n+    private @Nullable <T> T sendJsonMessage(String url, String urlParameters, Class<T> classOfT, boolean relogin) {\n+        return sendMessage(url, urlParameters, classOfT, APPLICATION_JSON, relogin);\n+    }\n+\n+    private @Nullable <T> T sendUrlEncodedMessage(String url, String urlParameters, Class<T> classOfT) {\n+        return sendMessage(url, urlParameters, classOfT, WWW_FORM_URLENCODED, true);\n+    }\n+\n+    private @Nullable <T> T sendMessage(String url, String urlParameters, Class<T> classOfT, String encoding,\n+            boolean relogin) {\n+        try {\n+            ContentResponse resp = createRequest(url).content(new StringContentProvider(urlParameters), encoding)\n+                    .send();\n+\n+            logger.trace(\"Request: {} with data: {}\", url, urlParameters);\n+            String line = resp.getContentAsString();\n+            logger.trace(\"Response: {}\", line);\n+            return gson.fromJson(line, classOfT);\n+        } catch (TimeoutException e) {\n+            logger.debug(\"Timeout during calling url: {}\", url, e);\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                    \"Timeout during calling url: \" + url);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjU5NjA5Mg=="}, "originalCommit": {"oid": "a590e81e68f4bb50a74b76dce0635a7906ca04ab"}, "originalPosition": 165}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA0MzY5NTQyOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.jablotron/src/main/java/org/openhab/binding/jablotron/internal/handler/JablotronBridgeHandler.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMFQxOTo1MzoxMlrOHQDffg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMVQxNjoxMjoxMVrOHQlHTQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjU5NjQ3OA==", "bodyText": "Same for below.\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    @Nullable", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r486596478", "createdAt": "2020-09-10T19:53:12Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.jablotron/src/main/java/org/openhab/binding/jablotron/internal/handler/JablotronBridgeHandler.java", "diffHunk": "@@ -0,0 +1,385 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.jablotron.internal.handler;\n+\n+import static org.openhab.binding.jablotron.JablotronBindingConstants.*;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.eclipse.jetty.http.HttpHeader;\n+import org.eclipse.jetty.http.HttpMethod;\n+import org.eclipse.smarthome.core.thing.*;\n+import org.eclipse.smarthome.core.thing.binding.BaseBridgeHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.openhab.binding.jablotron.internal.config.JablotronBridgeConfig;\n+import org.openhab.binding.jablotron.internal.discovery.JablotronDiscoveryService;\n+import org.openhab.binding.jablotron.internal.model.*;\n+import org.openhab.binding.jablotron.internal.model.ja100f.JablotronGetPGResponse;\n+import org.openhab.binding.jablotron.internal.model.ja100f.JablotronGetSectionsResponse;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.JsonSyntaxException;\n+\n+/**\n+ * The {@link JablotronBridgeHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Ondrej Pecta - Initial contribution\n+ */\n+@NonNullByDefault\n+public class JablotronBridgeHandler extends BaseBridgeHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(JablotronBridgeHandler.class);\n+\n+    private final Gson gson = new Gson();\n+\n+    final HttpClient httpClient;\n+\n+    @Nullable\n+    ScheduledFuture<?> future = null;\n+\n+    /**\n+     * Our configuration\n+     */\n+    public JablotronBridgeConfig bridgeConfig = new JablotronBridgeConfig();\n+\n+    public JablotronBridgeHandler(Bridge thing, HttpClient httpClient) {\n+        super(thing);\n+        this.httpClient = httpClient;\n+    }\n+\n+    @Override\n+    public Collection<Class<? extends ThingHandlerService>> getServices() {\n+        return Collections.singleton(JablotronDiscoveryService.class);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        bridgeConfig = getConfigAs(JablotronBridgeConfig.class);\n+        scheduler.execute(this::login);\n+        future = scheduler.scheduleWithFixedDelay(this::updateAlarmThings, 30, bridgeConfig.getRefresh(),\n+                TimeUnit.SECONDS);\n+    }\n+\n+    private void updateAlarmThings() {\n+        @Nullable\n+        List<JablotronDiscoveredService> services = discoverServices();\n+        if (services != null) {\n+            for (JablotronDiscoveredService service : services) {\n+                updateAlarmThing(service);\n+            }\n+        }\n+    }\n+\n+    private void updateAlarmThing(JablotronDiscoveredService service) {\n+        for (Thing th : getThing().getThings()) {\n+            @Nullable\n+            JablotronAlarmHandler handler = (JablotronAlarmHandler) th.getHandler();\n+\n+            if (handler == null) {\n+                logger.debug(\"Thing handler is null\");\n+                continue;\n+            }\n+\n+            if (String.valueOf(service.getId()).equals(handler.thingConfig.getServiceId())) {\n+                if (\"ENABLED\".equals(service.getStatus())) {\n+                    if (!\"\".equals(service.getWarning())) {\n+                        logger.debug(\"Alarm with service id: {} warning: {}\", service.getId(), service.getWarning());\n+                    }\n+                    handler.setStatus(ThingStatus.ONLINE, ThingStatusDetail.NONE, service.getWarning());\n+                    if (\"ALARM\".equals(service.getWarning()) || \"TAMPER\".equals(service.getWarning())) {\n+                        handler.triggerAlarm(service);\n+                    }\n+                    handler.setInService(\"SERVICE\".equals(service.getWarning()));\n+                } else {\n+                    logger.debug(\"Alarm with service id: {} is offline\", service.getId());\n+                    handler.setStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, service.getStatus());\n+                }\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        super.dispose();\n+        if (future != null) {\n+            future.cancel(true);\n+        }\n+        logout();\n+    }\n+\n+    private @Nullable <T> T sendJsonMessage(String url, String urlParameters, Class<T> classOfT) {\n+        return sendMessage(url, urlParameters, classOfT, APPLICATION_JSON, true);\n+    }\n+\n+    private @Nullable <T> T sendJsonMessage(String url, String urlParameters, Class<T> classOfT, boolean relogin) {\n+        return sendMessage(url, urlParameters, classOfT, APPLICATION_JSON, relogin);\n+    }\n+\n+    private @Nullable <T> T sendUrlEncodedMessage(String url, String urlParameters, Class<T> classOfT) {\n+        return sendMessage(url, urlParameters, classOfT, WWW_FORM_URLENCODED, true);\n+    }\n+\n+    private @Nullable <T> T sendMessage(String url, String urlParameters, Class<T> classOfT, String encoding,\n+            boolean relogin) {\n+        try {\n+            ContentResponse resp = createRequest(url).content(new StringContentProvider(urlParameters), encoding)\n+                    .send();\n+\n+            logger.trace(\"Request: {} with data: {}\", url, urlParameters);\n+            String line = resp.getContentAsString();\n+            logger.trace(\"Response: {}\", line);\n+            return gson.fromJson(line, classOfT);\n+        } catch (TimeoutException e) {\n+            logger.debug(\"Timeout during calling url: {}\", url, e);\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                    \"Timeout during calling url: \" + url);\n+        } catch (InterruptedException e) {\n+            logger.debug(\"Interrupt during calling url: {}\", url, e);\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                    \"Interrupt during calling url: \" + url);\n+            Thread.currentThread().interrupt();\n+        } catch (JsonSyntaxException e) {\n+            logger.debug(\"Syntax error during calling url: {}\", url, e);\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                    \"Syntax error during calling url: \" + url);\n+        } catch (ExecutionException e) {\n+            if (relogin) {\n+                if (e.getMessage().contains(AUTHENTICATION_CHALLENGE)) {\n+                    relogin();\n+                    return null;\n+                }\n+            }\n+            logger.debug(\"Error during calling url: {}\", url, e);\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                    \"Error during calling url: \" + url);\n+        }\n+        return null;\n+    }\n+\n+    protected synchronized void login() {\n+        String url = JABLOTRON_API_URL + \"userAuthorize.json\";\n+        String urlParameters = \"{\\\"login\\\":\\\"\" + bridgeConfig.getLogin() + \"\\\", \\\"password\\\":\\\"\"\n+                + bridgeConfig.getPassword() + \"\\\"}\";\n+        @Nullable", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a590e81e68f4bb50a74b76dce0635a7906ca04ab"}, "originalPosition": 193}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzE0NzM0MQ==", "bodyText": "fixed, including the occurences below", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r487147341", "createdAt": "2020-09-11T16:12:11Z", "author": {"login": "octa22"}, "path": "bundles/org.openhab.binding.jablotron/src/main/java/org/openhab/binding/jablotron/internal/handler/JablotronBridgeHandler.java", "diffHunk": "@@ -0,0 +1,385 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.jablotron.internal.handler;\n+\n+import static org.openhab.binding.jablotron.JablotronBindingConstants.*;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.eclipse.jetty.http.HttpHeader;\n+import org.eclipse.jetty.http.HttpMethod;\n+import org.eclipse.smarthome.core.thing.*;\n+import org.eclipse.smarthome.core.thing.binding.BaseBridgeHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.openhab.binding.jablotron.internal.config.JablotronBridgeConfig;\n+import org.openhab.binding.jablotron.internal.discovery.JablotronDiscoveryService;\n+import org.openhab.binding.jablotron.internal.model.*;\n+import org.openhab.binding.jablotron.internal.model.ja100f.JablotronGetPGResponse;\n+import org.openhab.binding.jablotron.internal.model.ja100f.JablotronGetSectionsResponse;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.JsonSyntaxException;\n+\n+/**\n+ * The {@link JablotronBridgeHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Ondrej Pecta - Initial contribution\n+ */\n+@NonNullByDefault\n+public class JablotronBridgeHandler extends BaseBridgeHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(JablotronBridgeHandler.class);\n+\n+    private final Gson gson = new Gson();\n+\n+    final HttpClient httpClient;\n+\n+    @Nullable\n+    ScheduledFuture<?> future = null;\n+\n+    /**\n+     * Our configuration\n+     */\n+    public JablotronBridgeConfig bridgeConfig = new JablotronBridgeConfig();\n+\n+    public JablotronBridgeHandler(Bridge thing, HttpClient httpClient) {\n+        super(thing);\n+        this.httpClient = httpClient;\n+    }\n+\n+    @Override\n+    public Collection<Class<? extends ThingHandlerService>> getServices() {\n+        return Collections.singleton(JablotronDiscoveryService.class);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        bridgeConfig = getConfigAs(JablotronBridgeConfig.class);\n+        scheduler.execute(this::login);\n+        future = scheduler.scheduleWithFixedDelay(this::updateAlarmThings, 30, bridgeConfig.getRefresh(),\n+                TimeUnit.SECONDS);\n+    }\n+\n+    private void updateAlarmThings() {\n+        @Nullable\n+        List<JablotronDiscoveredService> services = discoverServices();\n+        if (services != null) {\n+            for (JablotronDiscoveredService service : services) {\n+                updateAlarmThing(service);\n+            }\n+        }\n+    }\n+\n+    private void updateAlarmThing(JablotronDiscoveredService service) {\n+        for (Thing th : getThing().getThings()) {\n+            @Nullable\n+            JablotronAlarmHandler handler = (JablotronAlarmHandler) th.getHandler();\n+\n+            if (handler == null) {\n+                logger.debug(\"Thing handler is null\");\n+                continue;\n+            }\n+\n+            if (String.valueOf(service.getId()).equals(handler.thingConfig.getServiceId())) {\n+                if (\"ENABLED\".equals(service.getStatus())) {\n+                    if (!\"\".equals(service.getWarning())) {\n+                        logger.debug(\"Alarm with service id: {} warning: {}\", service.getId(), service.getWarning());\n+                    }\n+                    handler.setStatus(ThingStatus.ONLINE, ThingStatusDetail.NONE, service.getWarning());\n+                    if (\"ALARM\".equals(service.getWarning()) || \"TAMPER\".equals(service.getWarning())) {\n+                        handler.triggerAlarm(service);\n+                    }\n+                    handler.setInService(\"SERVICE\".equals(service.getWarning()));\n+                } else {\n+                    logger.debug(\"Alarm with service id: {} is offline\", service.getId());\n+                    handler.setStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, service.getStatus());\n+                }\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        super.dispose();\n+        if (future != null) {\n+            future.cancel(true);\n+        }\n+        logout();\n+    }\n+\n+    private @Nullable <T> T sendJsonMessage(String url, String urlParameters, Class<T> classOfT) {\n+        return sendMessage(url, urlParameters, classOfT, APPLICATION_JSON, true);\n+    }\n+\n+    private @Nullable <T> T sendJsonMessage(String url, String urlParameters, Class<T> classOfT, boolean relogin) {\n+        return sendMessage(url, urlParameters, classOfT, APPLICATION_JSON, relogin);\n+    }\n+\n+    private @Nullable <T> T sendUrlEncodedMessage(String url, String urlParameters, Class<T> classOfT) {\n+        return sendMessage(url, urlParameters, classOfT, WWW_FORM_URLENCODED, true);\n+    }\n+\n+    private @Nullable <T> T sendMessage(String url, String urlParameters, Class<T> classOfT, String encoding,\n+            boolean relogin) {\n+        try {\n+            ContentResponse resp = createRequest(url).content(new StringContentProvider(urlParameters), encoding)\n+                    .send();\n+\n+            logger.trace(\"Request: {} with data: {}\", url, urlParameters);\n+            String line = resp.getContentAsString();\n+            logger.trace(\"Response: {}\", line);\n+            return gson.fromJson(line, classOfT);\n+        } catch (TimeoutException e) {\n+            logger.debug(\"Timeout during calling url: {}\", url, e);\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                    \"Timeout during calling url: \" + url);\n+        } catch (InterruptedException e) {\n+            logger.debug(\"Interrupt during calling url: {}\", url, e);\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                    \"Interrupt during calling url: \" + url);\n+            Thread.currentThread().interrupt();\n+        } catch (JsonSyntaxException e) {\n+            logger.debug(\"Syntax error during calling url: {}\", url, e);\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                    \"Syntax error during calling url: \" + url);\n+        } catch (ExecutionException e) {\n+            if (relogin) {\n+                if (e.getMessage().contains(AUTHENTICATION_CHALLENGE)) {\n+                    relogin();\n+                    return null;\n+                }\n+            }\n+            logger.debug(\"Error during calling url: {}\", url, e);\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                    \"Error during calling url: \" + url);\n+        }\n+        return null;\n+    }\n+\n+    protected synchronized void login() {\n+        String url = JABLOTRON_API_URL + \"userAuthorize.json\";\n+        String urlParameters = \"{\\\"login\\\":\\\"\" + bridgeConfig.getLogin() + \"\\\", \\\"password\\\":\\\"\"\n+                + bridgeConfig.getPassword() + \"\\\"}\";\n+        @Nullable", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjU5NjQ3OA=="}, "originalCommit": {"oid": "a590e81e68f4bb50a74b76dce0635a7906ca04ab"}, "originalPosition": 193}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA0MzcwMzcyOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.jablotron/src/main/java/org/openhab/binding/jablotron/internal/handler/JablotronJa100FHandler.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMFQxOTo1NTozOVrOHQDkWA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMVQyMzowODo1MVrOHQwHaw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjU5NzcyMA==", "bodyText": "Can you handle the RefreshType command?", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r486597720", "createdAt": "2020-09-10T19:55:39Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.jablotron/src/main/java/org/openhab/binding/jablotron/internal/handler/JablotronJa100FHandler.java", "diffHunk": "@@ -0,0 +1,182 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.jablotron.internal.handler;\n+\n+import static org.openhab.binding.jablotron.JablotronBindingConstants.CHANNEL_LAST_CHECK_TIME;\n+\n+import java.util.List;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.binding.builder.ChannelBuilder;\n+import org.eclipse.smarthome.core.thing.binding.builder.ThingBuilder;\n+import org.eclipse.smarthome.core.thing.type.ChannelTypeUID;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.jablotron.internal.model.JablotronHistoryDataEvent;\n+import org.openhab.binding.jablotron.internal.model.ja100f.JablotronGetPGResponse;\n+import org.openhab.binding.jablotron.internal.model.ja100f.JablotronGetSectionsResponse;\n+import org.openhab.binding.jablotron.internal.model.ja100f.JablotronSection;\n+import org.openhab.binding.jablotron.internal.model.ja100f.JablotronState;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link JablotronJa100FHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Ondrej Pecta - Initial contribution\n+ */\n+@NonNullByDefault\n+public class JablotronJa100FHandler extends JablotronAlarmHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(JablotronJa100FHandler.class);\n+\n+    public JablotronJa100FHandler(Thing thing, String alarmName) {\n+        super(thing, alarmName);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (channelUID.getId().startsWith(\"SEC-\") && command instanceof StringType) {\n+            if (\"PARTIAL_ARM\".equals(command.toString())) {\n+                controlComponent(channelUID.getId(), \"CONTROL-SECTION\", \"DISARM\");\n+            }\n+            scheduler.execute(() -> controlComponent(channelUID.getId(), \"CONTROL-SECTION\", command.toString()));\n+        }\n+\n+        if (channelUID.getId().startsWith(\"PG-\") && command instanceof OnOffType) {\n+            scheduler.execute(() -> controlComponent(channelUID.getId(), \"CONTROL-PG\", command.toString()));\n+        }\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a590e81e68f4bb50a74b76dce0635a7906ca04ab"}, "originalPosition": 65}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzE1MTcyNQ==", "bodyText": "their API is very slow, often experiences timeouts. Since I can update the status only of the whole alarm including all channels, calling this update method for each channel would kill this binding.", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r487151725", "createdAt": "2020-09-11T16:20:14Z", "author": {"login": "octa22"}, "path": "bundles/org.openhab.binding.jablotron/src/main/java/org/openhab/binding/jablotron/internal/handler/JablotronJa100FHandler.java", "diffHunk": "@@ -0,0 +1,182 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.jablotron.internal.handler;\n+\n+import static org.openhab.binding.jablotron.JablotronBindingConstants.CHANNEL_LAST_CHECK_TIME;\n+\n+import java.util.List;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.binding.builder.ChannelBuilder;\n+import org.eclipse.smarthome.core.thing.binding.builder.ThingBuilder;\n+import org.eclipse.smarthome.core.thing.type.ChannelTypeUID;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.jablotron.internal.model.JablotronHistoryDataEvent;\n+import org.openhab.binding.jablotron.internal.model.ja100f.JablotronGetPGResponse;\n+import org.openhab.binding.jablotron.internal.model.ja100f.JablotronGetSectionsResponse;\n+import org.openhab.binding.jablotron.internal.model.ja100f.JablotronSection;\n+import org.openhab.binding.jablotron.internal.model.ja100f.JablotronState;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link JablotronJa100FHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Ondrej Pecta - Initial contribution\n+ */\n+@NonNullByDefault\n+public class JablotronJa100FHandler extends JablotronAlarmHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(JablotronJa100FHandler.class);\n+\n+    public JablotronJa100FHandler(Thing thing, String alarmName) {\n+        super(thing, alarmName);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (channelUID.getId().startsWith(\"SEC-\") && command instanceof StringType) {\n+            if (\"PARTIAL_ARM\".equals(command.toString())) {\n+                controlComponent(channelUID.getId(), \"CONTROL-SECTION\", \"DISARM\");\n+            }\n+            scheduler.execute(() -> controlComponent(channelUID.getId(), \"CONTROL-SECTION\", command.toString()));\n+        }\n+\n+        if (channelUID.getId().startsWith(\"PG-\") && command instanceof OnOffType) {\n+            scheduler.execute(() -> controlComponent(channelUID.getId(), \"CONTROL-PG\", command.toString()));\n+        }\n+    }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjU5NzcyMA=="}, "originalCommit": {"oid": "a590e81e68f4bb50a74b76dce0635a7906ca04ab"}, "originalPosition": 65}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzIxNDE4Nw==", "bodyText": "This challenges many bindings. For this use case ExpiringCache has been introduced. See https://www.openhab.org/javadoc/v2.5/org/eclipse/smarthome/core/cache/expiringcache", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r487214187", "createdAt": "2020-09-11T18:21:43Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.jablotron/src/main/java/org/openhab/binding/jablotron/internal/handler/JablotronJa100FHandler.java", "diffHunk": "@@ -0,0 +1,182 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.jablotron.internal.handler;\n+\n+import static org.openhab.binding.jablotron.JablotronBindingConstants.CHANNEL_LAST_CHECK_TIME;\n+\n+import java.util.List;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.binding.builder.ChannelBuilder;\n+import org.eclipse.smarthome.core.thing.binding.builder.ThingBuilder;\n+import org.eclipse.smarthome.core.thing.type.ChannelTypeUID;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.jablotron.internal.model.JablotronHistoryDataEvent;\n+import org.openhab.binding.jablotron.internal.model.ja100f.JablotronGetPGResponse;\n+import org.openhab.binding.jablotron.internal.model.ja100f.JablotronGetSectionsResponse;\n+import org.openhab.binding.jablotron.internal.model.ja100f.JablotronSection;\n+import org.openhab.binding.jablotron.internal.model.ja100f.JablotronState;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link JablotronJa100FHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Ondrej Pecta - Initial contribution\n+ */\n+@NonNullByDefault\n+public class JablotronJa100FHandler extends JablotronAlarmHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(JablotronJa100FHandler.class);\n+\n+    public JablotronJa100FHandler(Thing thing, String alarmName) {\n+        super(thing, alarmName);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (channelUID.getId().startsWith(\"SEC-\") && command instanceof StringType) {\n+            if (\"PARTIAL_ARM\".equals(command.toString())) {\n+                controlComponent(channelUID.getId(), \"CONTROL-SECTION\", \"DISARM\");\n+            }\n+            scheduler.execute(() -> controlComponent(channelUID.getId(), \"CONTROL-SECTION\", command.toString()));\n+        }\n+\n+        if (channelUID.getId().startsWith(\"PG-\") && command instanceof OnOffType) {\n+            scheduler.execute(() -> controlComponent(channelUID.getId(), \"CONTROL-PG\", command.toString()));\n+        }\n+    }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjU5NzcyMA=="}, "originalCommit": {"oid": "a590e81e68f4bb50a74b76dce0635a7906ca04ab"}, "originalPosition": 65}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzMyNzU5NQ==", "bodyText": "ok, implemented the expiring cache", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r487327595", "createdAt": "2020-09-11T23:08:51Z", "author": {"login": "octa22"}, "path": "bundles/org.openhab.binding.jablotron/src/main/java/org/openhab/binding/jablotron/internal/handler/JablotronJa100FHandler.java", "diffHunk": "@@ -0,0 +1,182 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.jablotron.internal.handler;\n+\n+import static org.openhab.binding.jablotron.JablotronBindingConstants.CHANNEL_LAST_CHECK_TIME;\n+\n+import java.util.List;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.binding.builder.ChannelBuilder;\n+import org.eclipse.smarthome.core.thing.binding.builder.ThingBuilder;\n+import org.eclipse.smarthome.core.thing.type.ChannelTypeUID;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.jablotron.internal.model.JablotronHistoryDataEvent;\n+import org.openhab.binding.jablotron.internal.model.ja100f.JablotronGetPGResponse;\n+import org.openhab.binding.jablotron.internal.model.ja100f.JablotronGetSectionsResponse;\n+import org.openhab.binding.jablotron.internal.model.ja100f.JablotronSection;\n+import org.openhab.binding.jablotron.internal.model.ja100f.JablotronState;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link JablotronJa100FHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Ondrej Pecta - Initial contribution\n+ */\n+@NonNullByDefault\n+public class JablotronJa100FHandler extends JablotronAlarmHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(JablotronJa100FHandler.class);\n+\n+    public JablotronJa100FHandler(Thing thing, String alarmName) {\n+        super(thing, alarmName);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (channelUID.getId().startsWith(\"SEC-\") && command instanceof StringType) {\n+            if (\"PARTIAL_ARM\".equals(command.toString())) {\n+                controlComponent(channelUID.getId(), \"CONTROL-SECTION\", \"DISARM\");\n+            }\n+            scheduler.execute(() -> controlComponent(channelUID.getId(), \"CONTROL-SECTION\", command.toString()));\n+        }\n+\n+        if (channelUID.getId().startsWith(\"PG-\") && command instanceof OnOffType) {\n+            scheduler.execute(() -> controlComponent(channelUID.getId(), \"CONTROL-PG\", command.toString()));\n+        }\n+    }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjU5NzcyMA=="}, "originalCommit": {"oid": "a590e81e68f4bb50a74b76dce0635a7906ca04ab"}, "originalPosition": 65}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA0MzcyMDczOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.jablotron/src/main/java/org/openhab/binding/jablotron/internal/handler/JablotronJa100Handler.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMFQyMDowMToxMFrOHQDvEQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMVQxNjoyMDo0OFrOHQlZkw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjYwMDQ2NQ==", "bodyText": "See above. Handle refresh.", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r486600465", "createdAt": "2020-09-10T20:01:10Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.jablotron/src/main/java/org/openhab/binding/jablotron/internal/handler/JablotronJa100Handler.java", "diffHunk": "@@ -0,0 +1,203 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.jablotron.internal.handler;\n+\n+import java.util.List;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.binding.builder.ChannelBuilder;\n+import org.eclipse.smarthome.core.thing.binding.builder.ThingBuilder;\n+import org.eclipse.smarthome.core.thing.type.ChannelTypeUID;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.jablotron.internal.model.JablotronControlResponse;\n+import org.openhab.binding.jablotron.internal.model.JablotronServiceDetailSegment;\n+import org.openhab.binding.jablotron.internal.model.JablotronServiceDetailSegmentInfo;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link JablotronJa100Handler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Ondrej Pecta - Initial contribution\n+ */\n+@NonNullByDefault\n+public class JablotronJa100Handler extends JablotronAlarmHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(JablotronJa100Handler.class);\n+\n+    public JablotronJa100Handler(Thing thing, String alarmName) {\n+        super(thing, alarmName);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (channelUID.getId().startsWith(\"STATE_\") && command instanceof StringType) {\n+            scheduler.execute(() -> {\n+                controlSTATESection(channelUID.getId(), command.toString());\n+            });\n+        }\n+\n+        if (channelUID.getId().startsWith(\"PGM_\") && command instanceof OnOffType) {\n+            scheduler.execute(() -> {\n+                controlPGMSection(channelUID.getId(), command.equals(OnOffType.ON) ? \"set\" : \"unset\");\n+            });\n+        }\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a590e81e68f4bb50a74b76dce0635a7906ca04ab"}, "originalPosition": 63}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzE1MjAxOQ==", "bodyText": "their API is very slow, often experiences timeouts. Since I can update the status only of the whole alarm including all channels, calling this update method for each channel would kill this binding.", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r487152019", "createdAt": "2020-09-11T16:20:48Z", "author": {"login": "octa22"}, "path": "bundles/org.openhab.binding.jablotron/src/main/java/org/openhab/binding/jablotron/internal/handler/JablotronJa100Handler.java", "diffHunk": "@@ -0,0 +1,203 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.jablotron.internal.handler;\n+\n+import java.util.List;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.binding.builder.ChannelBuilder;\n+import org.eclipse.smarthome.core.thing.binding.builder.ThingBuilder;\n+import org.eclipse.smarthome.core.thing.type.ChannelTypeUID;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.jablotron.internal.model.JablotronControlResponse;\n+import org.openhab.binding.jablotron.internal.model.JablotronServiceDetailSegment;\n+import org.openhab.binding.jablotron.internal.model.JablotronServiceDetailSegmentInfo;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link JablotronJa100Handler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Ondrej Pecta - Initial contribution\n+ */\n+@NonNullByDefault\n+public class JablotronJa100Handler extends JablotronAlarmHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(JablotronJa100Handler.class);\n+\n+    public JablotronJa100Handler(Thing thing, String alarmName) {\n+        super(thing, alarmName);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (channelUID.getId().startsWith(\"STATE_\") && command instanceof StringType) {\n+            scheduler.execute(() -> {\n+                controlSTATESection(channelUID.getId(), command.toString());\n+            });\n+        }\n+\n+        if (channelUID.getId().startsWith(\"PGM_\") && command instanceof OnOffType) {\n+            scheduler.execute(() -> {\n+                controlPGMSection(channelUID.getId(), command.equals(OnOffType.ON) ? \"set\" : \"unset\");\n+            });\n+        }\n+    }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjYwMDQ2NQ=="}, "originalCommit": {"oid": "a590e81e68f4bb50a74b76dce0635a7906ca04ab"}, "originalPosition": 63}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA0MzczNjE1OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.jablotron/src/main/java/org/openhab/binding/jablotron/internal/handler/JablotronJa100Handler.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMFQyMDowNjowMFrOHQD4dw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMVQxNjoxMzo0OFrOHQlKrw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjYwMjg3MQ==", "bodyText": "Is there a reason why you create the temperature Channel dynamically? Is the temperature sensor not always present at JA-100 devices?", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r486602871", "createdAt": "2020-09-10T20:06:00Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.jablotron/src/main/java/org/openhab/binding/jablotron/internal/handler/JablotronJa100Handler.java", "diffHunk": "@@ -0,0 +1,203 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.jablotron.internal.handler;\n+\n+import java.util.List;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.binding.builder.ChannelBuilder;\n+import org.eclipse.smarthome.core.thing.binding.builder.ThingBuilder;\n+import org.eclipse.smarthome.core.thing.type.ChannelTypeUID;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.jablotron.internal.model.JablotronControlResponse;\n+import org.openhab.binding.jablotron.internal.model.JablotronServiceDetailSegment;\n+import org.openhab.binding.jablotron.internal.model.JablotronServiceDetailSegmentInfo;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link JablotronJa100Handler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Ondrej Pecta - Initial contribution\n+ */\n+@NonNullByDefault\n+public class JablotronJa100Handler extends JablotronAlarmHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(JablotronJa100Handler.class);\n+\n+    public JablotronJa100Handler(Thing thing, String alarmName) {\n+        super(thing, alarmName);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (channelUID.getId().startsWith(\"STATE_\") && command instanceof StringType) {\n+            scheduler.execute(() -> {\n+                controlSTATESection(channelUID.getId(), command.toString());\n+            });\n+        }\n+\n+        if (channelUID.getId().startsWith(\"PGM_\") && command instanceof OnOffType) {\n+            scheduler.execute(() -> {\n+                controlPGMSection(channelUID.getId(), command.equals(OnOffType.ON) ? \"set\" : \"unset\");\n+            });\n+        }\n+    }\n+\n+    private void createChannel(JablotronServiceDetailSegment section) {\n+        if (section.getSegmentId().startsWith(\"PGM_\")) {\n+            createPGMChannel(section.getSegmentId(), section.getSegmentName());\n+        } else {\n+            createStateChannel(section.getSegmentId(), section.getSegmentName());\n+        }\n+    }\n+\n+    private void createTempChannel(String name, String label) {\n+        ChannelTypeUID temperature = new ChannelTypeUID(\"jablotron\", \"temperature\");\n+        ThingBuilder thingBuilder = editThing();\n+        Channel channel = ChannelBuilder.create(new ChannelUID(thing.getUID(), name), \"Number:Temperature\")\n+                .withLabel(label).withType(temperature).build();\n+        thingBuilder.withChannel(channel);\n+        updateThing(thingBuilder.build());\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a590e81e68f4bb50a74b76dce0635a7906ca04ab"}, "originalPosition": 80}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzE0ODIwNw==", "bodyText": "It makes sense only to create it dynamically, it is not included out of the box, but as an optional peripheral.", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r487148207", "createdAt": "2020-09-11T16:13:48Z", "author": {"login": "octa22"}, "path": "bundles/org.openhab.binding.jablotron/src/main/java/org/openhab/binding/jablotron/internal/handler/JablotronJa100Handler.java", "diffHunk": "@@ -0,0 +1,203 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.jablotron.internal.handler;\n+\n+import java.util.List;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.binding.builder.ChannelBuilder;\n+import org.eclipse.smarthome.core.thing.binding.builder.ThingBuilder;\n+import org.eclipse.smarthome.core.thing.type.ChannelTypeUID;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.jablotron.internal.model.JablotronControlResponse;\n+import org.openhab.binding.jablotron.internal.model.JablotronServiceDetailSegment;\n+import org.openhab.binding.jablotron.internal.model.JablotronServiceDetailSegmentInfo;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link JablotronJa100Handler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Ondrej Pecta - Initial contribution\n+ */\n+@NonNullByDefault\n+public class JablotronJa100Handler extends JablotronAlarmHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(JablotronJa100Handler.class);\n+\n+    public JablotronJa100Handler(Thing thing, String alarmName) {\n+        super(thing, alarmName);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (channelUID.getId().startsWith(\"STATE_\") && command instanceof StringType) {\n+            scheduler.execute(() -> {\n+                controlSTATESection(channelUID.getId(), command.toString());\n+            });\n+        }\n+\n+        if (channelUID.getId().startsWith(\"PGM_\") && command instanceof OnOffType) {\n+            scheduler.execute(() -> {\n+                controlPGMSection(channelUID.getId(), command.equals(OnOffType.ON) ? \"set\" : \"unset\");\n+            });\n+        }\n+    }\n+\n+    private void createChannel(JablotronServiceDetailSegment section) {\n+        if (section.getSegmentId().startsWith(\"PGM_\")) {\n+            createPGMChannel(section.getSegmentId(), section.getSegmentName());\n+        } else {\n+            createStateChannel(section.getSegmentId(), section.getSegmentName());\n+        }\n+    }\n+\n+    private void createTempChannel(String name, String label) {\n+        ChannelTypeUID temperature = new ChannelTypeUID(\"jablotron\", \"temperature\");\n+        ThingBuilder thingBuilder = editThing();\n+        Channel channel = ChannelBuilder.create(new ChannelUID(thing.getUID(), name), \"Number:Temperature\")\n+                .withLabel(label).withType(temperature).build();\n+        thingBuilder.withChannel(channel);\n+        updateThing(thingBuilder.build());\n+    }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjYwMjg3MQ=="}, "originalCommit": {"oid": "a590e81e68f4bb50a74b76dce0635a7906ca04ab"}, "originalPosition": 80}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA0Mzc0NTY2OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.jablotron/src/main/java/org/openhab/binding/jablotron/internal/handler/JablotronJa100Handler.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMFQyMDowOTowMFrOHQD-Eg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMVQxNjoxNDowOVrOHQlLlQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjYwNDMwNg==", "bodyText": "Did you test this? Are there Channels starting with STATE_?", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r486604306", "createdAt": "2020-09-10T20:09:00Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.jablotron/src/main/java/org/openhab/binding/jablotron/internal/handler/JablotronJa100Handler.java", "diffHunk": "@@ -0,0 +1,203 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.jablotron.internal.handler;\n+\n+import java.util.List;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.binding.builder.ChannelBuilder;\n+import org.eclipse.smarthome.core.thing.binding.builder.ThingBuilder;\n+import org.eclipse.smarthome.core.thing.type.ChannelTypeUID;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.jablotron.internal.model.JablotronControlResponse;\n+import org.openhab.binding.jablotron.internal.model.JablotronServiceDetailSegment;\n+import org.openhab.binding.jablotron.internal.model.JablotronServiceDetailSegmentInfo;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link JablotronJa100Handler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Ondrej Pecta - Initial contribution\n+ */\n+@NonNullByDefault\n+public class JablotronJa100Handler extends JablotronAlarmHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(JablotronJa100Handler.class);\n+\n+    public JablotronJa100Handler(Thing thing, String alarmName) {\n+        super(thing, alarmName);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (channelUID.getId().startsWith(\"STATE_\") && command instanceof StringType) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a590e81e68f4bb50a74b76dce0635a7906ca04ab"}, "originalPosition": 52}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzE0ODQzNw==", "bodyText": "Yes, the dynamically created", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r487148437", "createdAt": "2020-09-11T16:14:09Z", "author": {"login": "octa22"}, "path": "bundles/org.openhab.binding.jablotron/src/main/java/org/openhab/binding/jablotron/internal/handler/JablotronJa100Handler.java", "diffHunk": "@@ -0,0 +1,203 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.jablotron.internal.handler;\n+\n+import java.util.List;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.binding.builder.ChannelBuilder;\n+import org.eclipse.smarthome.core.thing.binding.builder.ThingBuilder;\n+import org.eclipse.smarthome.core.thing.type.ChannelTypeUID;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.jablotron.internal.model.JablotronControlResponse;\n+import org.openhab.binding.jablotron.internal.model.JablotronServiceDetailSegment;\n+import org.openhab.binding.jablotron.internal.model.JablotronServiceDetailSegmentInfo;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link JablotronJa100Handler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Ondrej Pecta - Initial contribution\n+ */\n+@NonNullByDefault\n+public class JablotronJa100Handler extends JablotronAlarmHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(JablotronJa100Handler.class);\n+\n+    public JablotronJa100Handler(Thing thing, String alarmName) {\n+        super(thing, alarmName);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (channelUID.getId().startsWith(\"STATE_\") && command instanceof StringType) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjYwNDMwNg=="}, "originalCommit": {"oid": "a590e81e68f4bb50a74b76dce0635a7906ca04ab"}, "originalPosition": 52}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA0Mzc1Nzc5OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.jablotron/src/main/java/org/openhab/binding/jablotron/internal/handler/JablotronOasisHandler.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMFQyMDoxMjo1N1rOHQEFhw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMVQxNjoyMToyNlrOHQla7w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjYwNjIxNQ==", "bodyText": "See above. refresh", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r486606215", "createdAt": "2020-09-10T20:12:57Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.jablotron/src/main/java/org/openhab/binding/jablotron/internal/handler/JablotronOasisHandler.java", "diffHunk": "@@ -0,0 +1,116 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.jablotron.internal.handler;\n+\n+import static org.openhab.binding.jablotron.JablotronBindingConstants.*;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.jablotron.internal.model.JablotronControlResponse;\n+import org.openhab.binding.jablotron.internal.model.JablotronServiceDetailSegment;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link JablotronOasisHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Ondrej Pecta - Initial contribution\n+ */\n+@NonNullByDefault\n+public class JablotronOasisHandler extends JablotronAlarmHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(JablotronOasisHandler.class);\n+\n+    public JablotronOasisHandler(Thing thing, String alarmName) {\n+        super(thing, alarmName);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (channelUID.getId().equals(CHANNEL_COMMAND) && command instanceof StringType) {\n+            scheduler.execute(() -> {\n+                sendCommand(command.toString());\n+            });\n+        }\n+\n+        if (channelUID.getId().equals(CHANNEL_STATUS_PGX) && command instanceof OnOffType) {\n+            scheduler.execute(() -> {\n+                controlSection(\"PGM_1\", command.equals(OnOffType.ON) ? \"set\" : \"unset\");\n+            });\n+        }\n+\n+        if (channelUID.getId().equals(CHANNEL_STATUS_PGY) && command instanceof OnOffType) {\n+            scheduler.execute(() -> {\n+                controlSection(\"PGM_2\", command.equals(OnOffType.ON) ? \"set\" : \"unset\");\n+            });\n+        }\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a590e81e68f4bb50a74b76dce0635a7906ca04ab"}, "originalPosition": 66}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzE1MjM2Nw==", "bodyText": "their API is very slow, often experiences timeouts. Since I can update the status only of the whole alarm including all channels, calling this update method for each channel would kill this binding.", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r487152367", "createdAt": "2020-09-11T16:21:26Z", "author": {"login": "octa22"}, "path": "bundles/org.openhab.binding.jablotron/src/main/java/org/openhab/binding/jablotron/internal/handler/JablotronOasisHandler.java", "diffHunk": "@@ -0,0 +1,116 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.jablotron.internal.handler;\n+\n+import static org.openhab.binding.jablotron.JablotronBindingConstants.*;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.jablotron.internal.model.JablotronControlResponse;\n+import org.openhab.binding.jablotron.internal.model.JablotronServiceDetailSegment;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link JablotronOasisHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Ondrej Pecta - Initial contribution\n+ */\n+@NonNullByDefault\n+public class JablotronOasisHandler extends JablotronAlarmHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(JablotronOasisHandler.class);\n+\n+    public JablotronOasisHandler(Thing thing, String alarmName) {\n+        super(thing, alarmName);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (channelUID.getId().equals(CHANNEL_COMMAND) && command instanceof StringType) {\n+            scheduler.execute(() -> {\n+                sendCommand(command.toString());\n+            });\n+        }\n+\n+        if (channelUID.getId().equals(CHANNEL_STATUS_PGX) && command instanceof OnOffType) {\n+            scheduler.execute(() -> {\n+                controlSection(\"PGM_1\", command.equals(OnOffType.ON) ? \"set\" : \"unset\");\n+            });\n+        }\n+\n+        if (channelUID.getId().equals(CHANNEL_STATUS_PGY) && command instanceof OnOffType) {\n+            scheduler.execute(() -> {\n+                controlSection(\"PGM_2\", command.equals(OnOffType.ON) ? \"set\" : \"unset\");\n+            });\n+        }\n+    }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjYwNjIxNQ=="}, "originalCommit": {"oid": "a590e81e68f4bb50a74b76dce0635a7906ca04ab"}, "originalPosition": 66}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA0Mzc3MTg2OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.jablotron/src/main/java/org/openhab/binding/jablotron/internal/handler/JablotronOasisHandler.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMFQyMDoxNzoxMlrOHQEOGQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMVQxNjoxNTowMVrOHQlNWQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjYwODQwOQ==", "bodyText": "You don't need to poll the state, as the Channel has already the new value, the user set before.\nOr does setting one Channel affect the state of another Channel?", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r486608409", "createdAt": "2020-09-10T20:17:12Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.jablotron/src/main/java/org/openhab/binding/jablotron/internal/handler/JablotronOasisHandler.java", "diffHunk": "@@ -0,0 +1,116 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.jablotron.internal.handler;\n+\n+import static org.openhab.binding.jablotron.JablotronBindingConstants.*;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.jablotron.internal.model.JablotronControlResponse;\n+import org.openhab.binding.jablotron.internal.model.JablotronServiceDetailSegment;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link JablotronOasisHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Ondrej Pecta - Initial contribution\n+ */\n+@NonNullByDefault\n+public class JablotronOasisHandler extends JablotronAlarmHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(JablotronOasisHandler.class);\n+\n+    public JablotronOasisHandler(Thing thing, String alarmName) {\n+        super(thing, alarmName);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (channelUID.getId().equals(CHANNEL_COMMAND) && command instanceof StringType) {\n+            scheduler.execute(() -> {\n+                sendCommand(command.toString());\n+            });\n+        }\n+\n+        if (channelUID.getId().equals(CHANNEL_STATUS_PGX) && command instanceof OnOffType) {\n+            scheduler.execute(() -> {\n+                controlSection(\"PGM_1\", command.equals(OnOffType.ON) ? \"set\" : \"unset\");\n+            });\n+        }\n+\n+        if (channelUID.getId().equals(CHANNEL_STATUS_PGY) && command instanceof OnOffType) {\n+            scheduler.execute(() -> {\n+                controlSection(\"PGM_2\", command.equals(OnOffType.ON) ? \"set\" : \"unset\");\n+            });\n+        }\n+    }\n+\n+    @Override\n+    protected void updateSegmentStatus(JablotronServiceDetailSegment segment) {\n+        logger.debug(\"Segment id: {} and status: {}\", segment.getSegmentId(), segment.getSegmentState());\n+        State newState = \"unset\".equals(segment.getSegmentState()) ? OnOffType.OFF : OnOffType.ON;\n+        switch (segment.getSegmentId()) {\n+            case \"STATE_1\":\n+                updateState(CHANNEL_STATUS_A, newState);\n+                break;\n+            case \"STATE_2\":\n+                updateState(CHANNEL_STATUS_B, newState);\n+                break;\n+            case \"STATE_3\":\n+                updateState(CHANNEL_STATUS_ABC, newState);\n+                break;\n+            case \"PGM_1\":\n+                updateState(CHANNEL_STATUS_PGX, newState);\n+                break;\n+            case \"PGM_2\":\n+                updateState(CHANNEL_STATUS_PGY, newState);\n+                break;\n+            default:\n+                logger.debug(\"Unknown segment received: {} with state: {}\", segment.getSegmentId(),\n+                        segment.getSegmentState());\n+        }\n+    }\n+\n+    public synchronized void controlSection(String section, String status) {\n+        logger.debug(\"Controlling section: {} with status: {}\", section, status);\n+        JablotronControlResponse response = sendUserCode(section, section.toLowerCase(), status, \"\");\n+\n+        updateAlarmStatus();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a590e81e68f4bb50a74b76dce0635a7906ca04ab"}, "originalPosition": 98}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzE0ODg4OQ==", "bodyText": "Yes, sending a user code immediately changes states of the sections. So it is the fastest way how to update the other channels states.", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r487148889", "createdAt": "2020-09-11T16:15:01Z", "author": {"login": "octa22"}, "path": "bundles/org.openhab.binding.jablotron/src/main/java/org/openhab/binding/jablotron/internal/handler/JablotronOasisHandler.java", "diffHunk": "@@ -0,0 +1,116 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.jablotron.internal.handler;\n+\n+import static org.openhab.binding.jablotron.JablotronBindingConstants.*;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.jablotron.internal.model.JablotronControlResponse;\n+import org.openhab.binding.jablotron.internal.model.JablotronServiceDetailSegment;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link JablotronOasisHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Ondrej Pecta - Initial contribution\n+ */\n+@NonNullByDefault\n+public class JablotronOasisHandler extends JablotronAlarmHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(JablotronOasisHandler.class);\n+\n+    public JablotronOasisHandler(Thing thing, String alarmName) {\n+        super(thing, alarmName);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (channelUID.getId().equals(CHANNEL_COMMAND) && command instanceof StringType) {\n+            scheduler.execute(() -> {\n+                sendCommand(command.toString());\n+            });\n+        }\n+\n+        if (channelUID.getId().equals(CHANNEL_STATUS_PGX) && command instanceof OnOffType) {\n+            scheduler.execute(() -> {\n+                controlSection(\"PGM_1\", command.equals(OnOffType.ON) ? \"set\" : \"unset\");\n+            });\n+        }\n+\n+        if (channelUID.getId().equals(CHANNEL_STATUS_PGY) && command instanceof OnOffType) {\n+            scheduler.execute(() -> {\n+                controlSection(\"PGM_2\", command.equals(OnOffType.ON) ? \"set\" : \"unset\");\n+            });\n+        }\n+    }\n+\n+    @Override\n+    protected void updateSegmentStatus(JablotronServiceDetailSegment segment) {\n+        logger.debug(\"Segment id: {} and status: {}\", segment.getSegmentId(), segment.getSegmentState());\n+        State newState = \"unset\".equals(segment.getSegmentState()) ? OnOffType.OFF : OnOffType.ON;\n+        switch (segment.getSegmentId()) {\n+            case \"STATE_1\":\n+                updateState(CHANNEL_STATUS_A, newState);\n+                break;\n+            case \"STATE_2\":\n+                updateState(CHANNEL_STATUS_B, newState);\n+                break;\n+            case \"STATE_3\":\n+                updateState(CHANNEL_STATUS_ABC, newState);\n+                break;\n+            case \"PGM_1\":\n+                updateState(CHANNEL_STATUS_PGX, newState);\n+                break;\n+            case \"PGM_2\":\n+                updateState(CHANNEL_STATUS_PGY, newState);\n+                break;\n+            default:\n+                logger.debug(\"Unknown segment received: {} with state: {}\", segment.getSegmentId(),\n+                        segment.getSegmentState());\n+        }\n+    }\n+\n+    public synchronized void controlSection(String section, String status) {\n+        logger.debug(\"Controlling section: {} with status: {}\", section, status);\n+        JablotronControlResponse response = sendUserCode(section, section.toLowerCase(), status, \"\");\n+\n+        updateAlarmStatus();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjYwODQwOQ=="}, "originalCommit": {"oid": "a590e81e68f4bb50a74b76dce0635a7906ca04ab"}, "originalPosition": 98}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA0Mzc3MjM5OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.jablotron/src/main/java/org/openhab/binding/jablotron/internal/handler/JablotronOasisHandler.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMFQyMDoxNzoyNVrOHQEOew==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMVQxNjoxNToyMVrOHQlOCg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjYwODUwNw==", "bodyText": "See above", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r486608507", "createdAt": "2020-09-10T20:17:25Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.jablotron/src/main/java/org/openhab/binding/jablotron/internal/handler/JablotronOasisHandler.java", "diffHunk": "@@ -0,0 +1,116 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.jablotron.internal.handler;\n+\n+import static org.openhab.binding.jablotron.JablotronBindingConstants.*;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.jablotron.internal.model.JablotronControlResponse;\n+import org.openhab.binding.jablotron.internal.model.JablotronServiceDetailSegment;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link JablotronOasisHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Ondrej Pecta - Initial contribution\n+ */\n+@NonNullByDefault\n+public class JablotronOasisHandler extends JablotronAlarmHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(JablotronOasisHandler.class);\n+\n+    public JablotronOasisHandler(Thing thing, String alarmName) {\n+        super(thing, alarmName);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (channelUID.getId().equals(CHANNEL_COMMAND) && command instanceof StringType) {\n+            scheduler.execute(() -> {\n+                sendCommand(command.toString());\n+            });\n+        }\n+\n+        if (channelUID.getId().equals(CHANNEL_STATUS_PGX) && command instanceof OnOffType) {\n+            scheduler.execute(() -> {\n+                controlSection(\"PGM_1\", command.equals(OnOffType.ON) ? \"set\" : \"unset\");\n+            });\n+        }\n+\n+        if (channelUID.getId().equals(CHANNEL_STATUS_PGY) && command instanceof OnOffType) {\n+            scheduler.execute(() -> {\n+                controlSection(\"PGM_2\", command.equals(OnOffType.ON) ? \"set\" : \"unset\");\n+            });\n+        }\n+    }\n+\n+    @Override\n+    protected void updateSegmentStatus(JablotronServiceDetailSegment segment) {\n+        logger.debug(\"Segment id: {} and status: {}\", segment.getSegmentId(), segment.getSegmentState());\n+        State newState = \"unset\".equals(segment.getSegmentState()) ? OnOffType.OFF : OnOffType.ON;\n+        switch (segment.getSegmentId()) {\n+            case \"STATE_1\":\n+                updateState(CHANNEL_STATUS_A, newState);\n+                break;\n+            case \"STATE_2\":\n+                updateState(CHANNEL_STATUS_B, newState);\n+                break;\n+            case \"STATE_3\":\n+                updateState(CHANNEL_STATUS_ABC, newState);\n+                break;\n+            case \"PGM_1\":\n+                updateState(CHANNEL_STATUS_PGX, newState);\n+                break;\n+            case \"PGM_2\":\n+                updateState(CHANNEL_STATUS_PGY, newState);\n+                break;\n+            default:\n+                logger.debug(\"Unknown segment received: {} with state: {}\", segment.getSegmentId(),\n+                        segment.getSegmentState());\n+        }\n+    }\n+\n+    public synchronized void controlSection(String section, String status) {\n+        logger.debug(\"Controlling section: {} with status: {}\", section, status);\n+        JablotronControlResponse response = sendUserCode(section, section.toLowerCase(), status, \"\");\n+\n+        updateAlarmStatus();\n+        if (response == null) {\n+            logger.debug(\"null response/status received during the control of section: {}\", section);\n+        }\n+    }\n+\n+    public synchronized void sendCommand(String code) {\n+        JablotronControlResponse response = sendUserCode(code);\n+        scheduler.schedule(this::updateAlarmStatus, 1, TimeUnit.SECONDS);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a590e81e68f4bb50a74b76dce0635a7906ca04ab"}, "originalPosition": 106}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzE0OTA2Ng==", "bodyText": "the same as above", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r487149066", "createdAt": "2020-09-11T16:15:21Z", "author": {"login": "octa22"}, "path": "bundles/org.openhab.binding.jablotron/src/main/java/org/openhab/binding/jablotron/internal/handler/JablotronOasisHandler.java", "diffHunk": "@@ -0,0 +1,116 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.jablotron.internal.handler;\n+\n+import static org.openhab.binding.jablotron.JablotronBindingConstants.*;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.jablotron.internal.model.JablotronControlResponse;\n+import org.openhab.binding.jablotron.internal.model.JablotronServiceDetailSegment;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link JablotronOasisHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Ondrej Pecta - Initial contribution\n+ */\n+@NonNullByDefault\n+public class JablotronOasisHandler extends JablotronAlarmHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(JablotronOasisHandler.class);\n+\n+    public JablotronOasisHandler(Thing thing, String alarmName) {\n+        super(thing, alarmName);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (channelUID.getId().equals(CHANNEL_COMMAND) && command instanceof StringType) {\n+            scheduler.execute(() -> {\n+                sendCommand(command.toString());\n+            });\n+        }\n+\n+        if (channelUID.getId().equals(CHANNEL_STATUS_PGX) && command instanceof OnOffType) {\n+            scheduler.execute(() -> {\n+                controlSection(\"PGM_1\", command.equals(OnOffType.ON) ? \"set\" : \"unset\");\n+            });\n+        }\n+\n+        if (channelUID.getId().equals(CHANNEL_STATUS_PGY) && command instanceof OnOffType) {\n+            scheduler.execute(() -> {\n+                controlSection(\"PGM_2\", command.equals(OnOffType.ON) ? \"set\" : \"unset\");\n+            });\n+        }\n+    }\n+\n+    @Override\n+    protected void updateSegmentStatus(JablotronServiceDetailSegment segment) {\n+        logger.debug(\"Segment id: {} and status: {}\", segment.getSegmentId(), segment.getSegmentState());\n+        State newState = \"unset\".equals(segment.getSegmentState()) ? OnOffType.OFF : OnOffType.ON;\n+        switch (segment.getSegmentId()) {\n+            case \"STATE_1\":\n+                updateState(CHANNEL_STATUS_A, newState);\n+                break;\n+            case \"STATE_2\":\n+                updateState(CHANNEL_STATUS_B, newState);\n+                break;\n+            case \"STATE_3\":\n+                updateState(CHANNEL_STATUS_ABC, newState);\n+                break;\n+            case \"PGM_1\":\n+                updateState(CHANNEL_STATUS_PGX, newState);\n+                break;\n+            case \"PGM_2\":\n+                updateState(CHANNEL_STATUS_PGY, newState);\n+                break;\n+            default:\n+                logger.debug(\"Unknown segment received: {} with state: {}\", segment.getSegmentId(),\n+                        segment.getSegmentState());\n+        }\n+    }\n+\n+    public synchronized void controlSection(String section, String status) {\n+        logger.debug(\"Controlling section: {} with status: {}\", section, status);\n+        JablotronControlResponse response = sendUserCode(section, section.toLowerCase(), status, \"\");\n+\n+        updateAlarmStatus();\n+        if (response == null) {\n+            logger.debug(\"null response/status received during the control of section: {}\", section);\n+        }\n+    }\n+\n+    public synchronized void sendCommand(String code) {\n+        JablotronControlResponse response = sendUserCode(code);\n+        scheduler.schedule(this::updateAlarmStatus, 1, TimeUnit.SECONDS);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjYwODUwNw=="}, "originalCommit": {"oid": "a590e81e68f4bb50a74b76dce0635a7906ca04ab"}, "originalPosition": 106}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA0Mzc3NzgzOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.jablotron/README.md", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMFQyMDoxOToxM1rOHQESDA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMlQwOTozMjowNVrOHQz9YQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjYwOTQyMA==", "bodyText": "This sound rather an Action than a Channel.", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r486609420", "createdAt": "2020-09-10T20:19:13Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.jablotron/README.md", "diffHunk": "@@ -0,0 +1,120 @@\n+# Jablotron Alarm Binding\n+\n+This is the binding for Jablotron alarms.\n+https://www.jablotron.com/en/jablotron-products/alarms/\n+\n+## Supported Things\n+\n+| thing   | note                                      |\n+|---------|-------------------------------------------|\n+| bridge  | the bridge to your Jablonet cloud account |\n+| JA-80   | the OASIS alarm                           |\n+| JA-100  | with the thermometer support              |\n+| JA-100F | without the thermometer support           |\n+ \n+## Discovery\n+\n+This binding supports auto discovery. Just manually add a bridge thing and supply login & password to your Jablonet account.\n+\n+## Binding Configuration\n+\n+Binding itself doesn't require specific configuration.\n+\n+## Thing Configuration\n+\n+| thing                | config parameter name | description                                                                        | type                  |\n+|----------------------|-----------------------|------------------------------------------------------------------------------------|-----------------------|\n+| bridge               | login                 | the login to your Jablonet account                                                 | mandatory             |\n+| bridge               | password              | the password to your Jablonet account                                              | mandatory             |\n+| bridge               | refresh               | the refresh time for all alarm warnings (ALARM, TAMPER triggers and SERVICE state) | optional, default=30s |\n+| bridge               | lang                  | the language of the alarm texts                                                    | optional, default=en  |\n+| JA-80/JA-100/JA-100F | refresh               | the channels refresh period in seconds                                             | optional, default=60s |\n+| JA-80/JA-100/JA-100F | serviceId             | the service ID which identifies the alarm                                          | mandatory             |\n+| JA-100/JA-100F       | code                  | the master code for controlling sections                                           | optional              |\n+\n+## Channels\n+\n+| thing                | channel name     | description                                               |\n+|----------------------|------------------|-----------------------------------------------------------|\n+| bridge               | N/A              | the bridge does not expose any channels                   |\n+| JA-80                | statusA          | the status of the A section                               |\n+| JA-80                | statusB          | the status of the AB/B section                            |\n+| JA-80                | statusABC        | the status of the ABC section                             |\n+| JA-80                | statusPGX        | the status of PGX                                         |\n+| JA-80                | statusPGY        | the status of PGY                                         |\n+| JA-80                | command          | the channel for sending keyboard codes to the OASIS alarm |", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a590e81e68f4bb50a74b76dce0635a7906ca04ab"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzE1NjUyOA==", "bodyText": "Are you insisting on this? I have to study this a bit, so it will take some time...", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r487156528", "createdAt": "2020-09-11T16:29:10Z", "author": {"login": "octa22"}, "path": "bundles/org.openhab.binding.jablotron/README.md", "diffHunk": "@@ -0,0 +1,120 @@\n+# Jablotron Alarm Binding\n+\n+This is the binding for Jablotron alarms.\n+https://www.jablotron.com/en/jablotron-products/alarms/\n+\n+## Supported Things\n+\n+| thing   | note                                      |\n+|---------|-------------------------------------------|\n+| bridge  | the bridge to your Jablonet cloud account |\n+| JA-80   | the OASIS alarm                           |\n+| JA-100  | with the thermometer support              |\n+| JA-100F | without the thermometer support           |\n+ \n+## Discovery\n+\n+This binding supports auto discovery. Just manually add a bridge thing and supply login & password to your Jablonet account.\n+\n+## Binding Configuration\n+\n+Binding itself doesn't require specific configuration.\n+\n+## Thing Configuration\n+\n+| thing                | config parameter name | description                                                                        | type                  |\n+|----------------------|-----------------------|------------------------------------------------------------------------------------|-----------------------|\n+| bridge               | login                 | the login to your Jablonet account                                                 | mandatory             |\n+| bridge               | password              | the password to your Jablonet account                                              | mandatory             |\n+| bridge               | refresh               | the refresh time for all alarm warnings (ALARM, TAMPER triggers and SERVICE state) | optional, default=30s |\n+| bridge               | lang                  | the language of the alarm texts                                                    | optional, default=en  |\n+| JA-80/JA-100/JA-100F | refresh               | the channels refresh period in seconds                                             | optional, default=60s |\n+| JA-80/JA-100/JA-100F | serviceId             | the service ID which identifies the alarm                                          | mandatory             |\n+| JA-100/JA-100F       | code                  | the master code for controlling sections                                           | optional              |\n+\n+## Channels\n+\n+| thing                | channel name     | description                                               |\n+|----------------------|------------------|-----------------------------------------------------------|\n+| bridge               | N/A              | the bridge does not expose any channels                   |\n+| JA-80                | statusA          | the status of the A section                               |\n+| JA-80                | statusB          | the status of the AB/B section                            |\n+| JA-80                | statusABC        | the status of the ABC section                             |\n+| JA-80                | statusPGX        | the status of PGX                                         |\n+| JA-80                | statusPGY        | the status of PGY                                         |\n+| JA-80                | command          | the channel for sending keyboard codes to the OASIS alarm |", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjYwOTQyMA=="}, "originalCommit": {"oid": "a590e81e68f4bb50a74b76dce0635a7906ca04ab"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzE2MjAzNw==", "bodyText": "After some investigation, I would keep it as is, since the action would make the calling more complicated (even it may a good candidate)\nnow it is possible to simply use this statement in a .sitemap file\nSwitch item=JablotronCode label=\"Arm\" mappings=[1234=\" A \", 2345=\" B \", 3456=\"ABC\"]", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r487162037", "createdAt": "2020-09-11T16:39:38Z", "author": {"login": "octa22"}, "path": "bundles/org.openhab.binding.jablotron/README.md", "diffHunk": "@@ -0,0 +1,120 @@\n+# Jablotron Alarm Binding\n+\n+This is the binding for Jablotron alarms.\n+https://www.jablotron.com/en/jablotron-products/alarms/\n+\n+## Supported Things\n+\n+| thing   | note                                      |\n+|---------|-------------------------------------------|\n+| bridge  | the bridge to your Jablonet cloud account |\n+| JA-80   | the OASIS alarm                           |\n+| JA-100  | with the thermometer support              |\n+| JA-100F | without the thermometer support           |\n+ \n+## Discovery\n+\n+This binding supports auto discovery. Just manually add a bridge thing and supply login & password to your Jablonet account.\n+\n+## Binding Configuration\n+\n+Binding itself doesn't require specific configuration.\n+\n+## Thing Configuration\n+\n+| thing                | config parameter name | description                                                                        | type                  |\n+|----------------------|-----------------------|------------------------------------------------------------------------------------|-----------------------|\n+| bridge               | login                 | the login to your Jablonet account                                                 | mandatory             |\n+| bridge               | password              | the password to your Jablonet account                                              | mandatory             |\n+| bridge               | refresh               | the refresh time for all alarm warnings (ALARM, TAMPER triggers and SERVICE state) | optional, default=30s |\n+| bridge               | lang                  | the language of the alarm texts                                                    | optional, default=en  |\n+| JA-80/JA-100/JA-100F | refresh               | the channels refresh period in seconds                                             | optional, default=60s |\n+| JA-80/JA-100/JA-100F | serviceId             | the service ID which identifies the alarm                                          | mandatory             |\n+| JA-100/JA-100F       | code                  | the master code for controlling sections                                           | optional              |\n+\n+## Channels\n+\n+| thing                | channel name     | description                                               |\n+|----------------------|------------------|-----------------------------------------------------------|\n+| bridge               | N/A              | the bridge does not expose any channels                   |\n+| JA-80                | statusA          | the status of the A section                               |\n+| JA-80                | statusB          | the status of the AB/B section                            |\n+| JA-80                | statusABC        | the status of the ABC section                             |\n+| JA-80                | statusPGX        | the status of PGX                                         |\n+| JA-80                | statusPGY        | the status of PGY                                         |\n+| JA-80                | command          | the channel for sending keyboard codes to the OASIS alarm |", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjYwOTQyMA=="}, "originalCommit": {"oid": "a590e81e68f4bb50a74b76dce0635a7906ca04ab"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzM5MDU2MQ==", "bodyText": "Ok", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r487390561", "createdAt": "2020-09-12T09:32:05Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.jablotron/README.md", "diffHunk": "@@ -0,0 +1,120 @@\n+# Jablotron Alarm Binding\n+\n+This is the binding for Jablotron alarms.\n+https://www.jablotron.com/en/jablotron-products/alarms/\n+\n+## Supported Things\n+\n+| thing   | note                                      |\n+|---------|-------------------------------------------|\n+| bridge  | the bridge to your Jablonet cloud account |\n+| JA-80   | the OASIS alarm                           |\n+| JA-100  | with the thermometer support              |\n+| JA-100F | without the thermometer support           |\n+ \n+## Discovery\n+\n+This binding supports auto discovery. Just manually add a bridge thing and supply login & password to your Jablonet account.\n+\n+## Binding Configuration\n+\n+Binding itself doesn't require specific configuration.\n+\n+## Thing Configuration\n+\n+| thing                | config parameter name | description                                                                        | type                  |\n+|----------------------|-----------------------|------------------------------------------------------------------------------------|-----------------------|\n+| bridge               | login                 | the login to your Jablonet account                                                 | mandatory             |\n+| bridge               | password              | the password to your Jablonet account                                              | mandatory             |\n+| bridge               | refresh               | the refresh time for all alarm warnings (ALARM, TAMPER triggers and SERVICE state) | optional, default=30s |\n+| bridge               | lang                  | the language of the alarm texts                                                    | optional, default=en  |\n+| JA-80/JA-100/JA-100F | refresh               | the channels refresh period in seconds                                             | optional, default=60s |\n+| JA-80/JA-100/JA-100F | serviceId             | the service ID which identifies the alarm                                          | mandatory             |\n+| JA-100/JA-100F       | code                  | the master code for controlling sections                                           | optional              |\n+\n+## Channels\n+\n+| thing                | channel name     | description                                               |\n+|----------------------|------------------|-----------------------------------------------------------|\n+| bridge               | N/A              | the bridge does not expose any channels                   |\n+| JA-80                | statusA          | the status of the A section                               |\n+| JA-80                | statusB          | the status of the AB/B section                            |\n+| JA-80                | statusABC        | the status of the ABC section                             |\n+| JA-80                | statusPGX        | the status of PGX                                         |\n+| JA-80                | statusPGY        | the status of PGY                                         |\n+| JA-80                | command          | the channel for sending keyboard codes to the OASIS alarm |", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjYwOTQyMA=="}, "originalCommit": {"oid": "a590e81e68f4bb50a74b76dce0635a7906ca04ab"}, "originalPosition": 45}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA0Mzc4NjUxOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.jablotron/src/main/resources/ESH-INF/binding/binding.xml", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMFQyMDoyMTozMlrOHQEW8A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMVQxNTo1MDoxOVrOHQkW5g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjYxMDY3Mg==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t<description>This is the binding for Jablotron.</description>\n          \n          \n            \n            \t<description>This is the binding for Jablotron Alarm Systems.</description>", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r486610672", "createdAt": "2020-09-10T20:21:32Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.jablotron/src/main/resources/ESH-INF/binding/binding.xml", "diffHunk": "@@ -0,0 +1,10 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<binding:binding id=\"jablotron\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:binding=\"https://openhab.org/schemas/binding/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/binding/v1.0.0 https://openhab.org/schemas/binding-1.0.0.xsd\">\n+\n+\t<name>Jablotron Binding</name>\n+\t<description>This is the binding for Jablotron.</description>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a590e81e68f4bb50a74b76dce0635a7906ca04ab"}, "originalPosition": 7}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzEzNDk1MA==", "bodyText": "OK", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r487134950", "createdAt": "2020-09-11T15:50:19Z", "author": {"login": "octa22"}, "path": "bundles/org.openhab.binding.jablotron/src/main/resources/ESH-INF/binding/binding.xml", "diffHunk": "@@ -0,0 +1,10 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<binding:binding id=\"jablotron\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:binding=\"https://openhab.org/schemas/binding/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/binding/v1.0.0 https://openhab.org/schemas/binding-1.0.0.xsd\">\n+\n+\t<name>Jablotron Binding</name>\n+\t<description>This is the binding for Jablotron.</description>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjYxMDY3Mg=="}, "originalCommit": {"oid": "a590e81e68f4bb50a74b76dce0635a7906ca04ab"}, "originalPosition": 7}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA0Mzc4NzM3OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.jablotron/src/main/resources/ESH-INF/config/config.xml", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMFQyMDoyMTo0N1rOHQEXcg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMVQxNTo1MzozNVrOHQkeQg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjYxMDgwMg==", "bodyText": "Better specify a reasonable min value (e.g. 1) to prevent entering 0 or a negative number, which would crash your binding. Same for below.\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\t<parameter name=\"refresh\" type=\"integer\" required=\"false\">\n          \n          \n            \n            \t\t<parameter name=\"refresh\" type=\"integer\" required=\"false\" unit=\"s\">", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r486610802", "createdAt": "2020-09-10T20:21:47Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.jablotron/src/main/resources/ESH-INF/config/config.xml", "diffHunk": "@@ -0,0 +1,86 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<config-description:config-descriptions\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:config-description=\"https://openhab.org/schemas/config-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/config-description/v1.0.0 https://openhab.org/schemas/config-description-1.0.0.xsd\">\n+\n+\t<config-description uri=\"thing-type:jablotron:device\">\n+\t\t<parameter name=\"refresh\" type=\"integer\" required=\"false\">", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a590e81e68f4bb50a74b76dce0635a7906ca04ab"}, "originalPosition": 8}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzEzNjgzNA==", "bodyText": "added unit as well as min value", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r487136834", "createdAt": "2020-09-11T15:53:35Z", "author": {"login": "octa22"}, "path": "bundles/org.openhab.binding.jablotron/src/main/resources/ESH-INF/config/config.xml", "diffHunk": "@@ -0,0 +1,86 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<config-description:config-descriptions\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:config-description=\"https://openhab.org/schemas/config-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/config-description/v1.0.0 https://openhab.org/schemas/config-description-1.0.0.xsd\">\n+\n+\t<config-description uri=\"thing-type:jablotron:device\">\n+\t\t<parameter name=\"refresh\" type=\"integer\" required=\"false\">", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjYxMDgwMg=="}, "originalCommit": {"oid": "a590e81e68f4bb50a74b76dce0635a7906ca04ab"}, "originalPosition": 8}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA0MzgwNDI2OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.jablotron/src/main/resources/ESH-INF/thing/channels.xml", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMFQyMDoyNjo0MFrOHQEheg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMVQxNTo1OTo1NFrOHQkspQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjYxMzM3MA==", "bodyText": "As this trigger Channel has payload, the <event /> tag shall be specified. See https://www.openhab.org/docs/developer/bindings/thing-xml.html#trigger-channel-types", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r486613370", "createdAt": "2020-09-10T20:26:40Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.jablotron/src/main/resources/ESH-INF/thing/channels.xml", "diffHunk": "@@ -0,0 +1,165 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"jablotron\"\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\t<!-- Oasis -->\n+\t<!-- StatusA -->\n+\t<channel-type id=\"statusA\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Alarm Zone A Status</label>\n+\t\t<description>Status of the A zone of your alarm</description>\n+\t\t<state readOnly=\"true\"/>\n+\t</channel-type>\n+\n+\t<!-- StatusB -->\n+\t<channel-type id=\"statusB\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Alarm B Status</label>\n+\t\t<description>Status of the B zone of your alarm</description>\n+\t\t<state readOnly=\"true\"/>\n+\t</channel-type>\n+\n+\t<!-- StatusABC -->\n+\t<channel-type id=\"statusABC\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Alarm Zone ABC Status</label>\n+\t\t<description>Status of the ABC zone of your alarm</description>\n+\t\t<state readOnly=\"true\"/>\n+\t</channel-type>\n+\n+\t<!-- StatusPGX -->\n+\t<channel-type id=\"statusPGX\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>OASIS PGX Status</label>\n+\t\t<description>Status of the PGX switch of your OASIS alarm</description>\n+\t</channel-type>\n+\n+\t<!-- StatusPGY -->\n+\t<channel-type id=\"statusPGY\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>OASIS PGY Status</label>\n+\t\t<description>Status of the PGY switch of your OASIS alarm</description>\n+\t</channel-type>\n+\n+\t<!-- JA100 -->\n+\t<channel-type id=\"status\">\n+\t\t<item-type>Number</item-type>\n+\t\t<label>Alarm Section Status</label>\n+\t\t<description>Status of the section of your alarm</description>\n+\t</channel-type>\n+\n+\t<!-- StatusPGM -->\n+\t<channel-type id=\"statusPGM\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>JA-100 PGM Status</label>\n+\t\t<description>Status of the PGM switch of your JA-100 alarm</description>\n+\t</channel-type>\n+\n+\t<!-- Alarm -->\n+\t<channel-type id=\"alarm\">\n+\t\t<kind>trigger</kind>\n+\t\t<label>Alarm</label>\n+\t\t<description>Status of the alarm of your alarm</description>\n+\t\t<state readOnly=\"true\"/>\n+\t</channel-type>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a590e81e68f4bb50a74b76dce0635a7906ca04ab"}, "originalPosition": 65}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzE0MDUxNw==", "bodyText": "specified the events", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r487140517", "createdAt": "2020-09-11T15:59:54Z", "author": {"login": "octa22"}, "path": "bundles/org.openhab.binding.jablotron/src/main/resources/ESH-INF/thing/channels.xml", "diffHunk": "@@ -0,0 +1,165 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"jablotron\"\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\t<!-- Oasis -->\n+\t<!-- StatusA -->\n+\t<channel-type id=\"statusA\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Alarm Zone A Status</label>\n+\t\t<description>Status of the A zone of your alarm</description>\n+\t\t<state readOnly=\"true\"/>\n+\t</channel-type>\n+\n+\t<!-- StatusB -->\n+\t<channel-type id=\"statusB\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Alarm B Status</label>\n+\t\t<description>Status of the B zone of your alarm</description>\n+\t\t<state readOnly=\"true\"/>\n+\t</channel-type>\n+\n+\t<!-- StatusABC -->\n+\t<channel-type id=\"statusABC\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Alarm Zone ABC Status</label>\n+\t\t<description>Status of the ABC zone of your alarm</description>\n+\t\t<state readOnly=\"true\"/>\n+\t</channel-type>\n+\n+\t<!-- StatusPGX -->\n+\t<channel-type id=\"statusPGX\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>OASIS PGX Status</label>\n+\t\t<description>Status of the PGX switch of your OASIS alarm</description>\n+\t</channel-type>\n+\n+\t<!-- StatusPGY -->\n+\t<channel-type id=\"statusPGY\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>OASIS PGY Status</label>\n+\t\t<description>Status of the PGY switch of your OASIS alarm</description>\n+\t</channel-type>\n+\n+\t<!-- JA100 -->\n+\t<channel-type id=\"status\">\n+\t\t<item-type>Number</item-type>\n+\t\t<label>Alarm Section Status</label>\n+\t\t<description>Status of the section of your alarm</description>\n+\t</channel-type>\n+\n+\t<!-- StatusPGM -->\n+\t<channel-type id=\"statusPGM\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>JA-100 PGM Status</label>\n+\t\t<description>Status of the PGM switch of your JA-100 alarm</description>\n+\t</channel-type>\n+\n+\t<!-- Alarm -->\n+\t<channel-type id=\"alarm\">\n+\t\t<kind>trigger</kind>\n+\t\t<label>Alarm</label>\n+\t\t<description>Status of the alarm of your alarm</description>\n+\t\t<state readOnly=\"true\"/>\n+\t</channel-type>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjYxMzM3MA=="}, "originalCommit": {"oid": "a590e81e68f4bb50a74b76dce0635a7906ca04ab"}, "originalPosition": 65}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA0MzgzOTg3OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.jablotron/src/main/java/org/openhab/binding/jablotron/internal/discovery/JablotronDiscoveryService.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMFQyMDozNzoyMFrOHQE2-Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMlQxNToyMjowMFrOHQ1vtg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjYxODg3Mw==", "bodyText": "As bridgeHandler is Nullable, you have to do a null check before accessing it. You can store it to a local variable and do the null check on that. Same for the others in this file.", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r486618873", "createdAt": "2020-09-10T20:37:20Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.jablotron/src/main/java/org/openhab/binding/jablotron/internal/discovery/JablotronDiscoveryService.java", "diffHunk": "@@ -0,0 +1,171 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.jablotron.internal.discovery;\n+\n+import static org.openhab.binding.jablotron.JablotronBindingConstants.*;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.config.discovery.*;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.thing.ThingUID;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.openhab.binding.jablotron.internal.handler.JablotronBridgeHandler;\n+import org.openhab.binding.jablotron.internal.model.JablotronDiscoveredService;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link JablotronDiscoveryService} is responsible for the thing discovery\n+ * process.\n+ *\n+ * @author Ondrej Pecta - Initial contribution\n+ */\n+@NonNullByDefault\n+public class JablotronDiscoveryService extends AbstractDiscoveryService\n+        implements DiscoveryService, ThingHandlerService {\n+    private final Logger logger = LoggerFactory.getLogger(JablotronDiscoveryService.class);\n+\n+    private @Nullable JablotronBridgeHandler bridgeHandler;\n+\n+    private @Nullable ScheduledFuture<?> discoveryJob = null;\n+\n+    public JablotronDiscoveryService() {\n+        super(DISCOVERY_TIMEOUT_SEC);\n+        logger.debug(\"Creating discovery service\");\n+    }\n+\n+    private void startDiscovery() {\n+        if (this.bridgeHandler.getThing().getStatus() == ThingStatus.ONLINE) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a590e81e68f4bb50a74b76dce0635a7906ca04ab"}, "originalPosition": 58}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzQxOTgzMA==", "bodyText": "fixed", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r487419830", "createdAt": "2020-09-12T15:22:00Z", "author": {"login": "octa22"}, "path": "bundles/org.openhab.binding.jablotron/src/main/java/org/openhab/binding/jablotron/internal/discovery/JablotronDiscoveryService.java", "diffHunk": "@@ -0,0 +1,171 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.jablotron.internal.discovery;\n+\n+import static org.openhab.binding.jablotron.JablotronBindingConstants.*;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.config.discovery.*;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.thing.ThingUID;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.openhab.binding.jablotron.internal.handler.JablotronBridgeHandler;\n+import org.openhab.binding.jablotron.internal.model.JablotronDiscoveredService;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link JablotronDiscoveryService} is responsible for the thing discovery\n+ * process.\n+ *\n+ * @author Ondrej Pecta - Initial contribution\n+ */\n+@NonNullByDefault\n+public class JablotronDiscoveryService extends AbstractDiscoveryService\n+        implements DiscoveryService, ThingHandlerService {\n+    private final Logger logger = LoggerFactory.getLogger(JablotronDiscoveryService.class);\n+\n+    private @Nullable JablotronBridgeHandler bridgeHandler;\n+\n+    private @Nullable ScheduledFuture<?> discoveryJob = null;\n+\n+    public JablotronDiscoveryService() {\n+        super(DISCOVERY_TIMEOUT_SEC);\n+        logger.debug(\"Creating discovery service\");\n+    }\n+\n+    private void startDiscovery() {\n+        if (this.bridgeHandler.getThing().getStatus() == ThingStatus.ONLINE) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjYxODg3Mw=="}, "originalCommit": {"oid": "a590e81e68f4bb50a74b76dce0635a7906ca04ab"}, "originalPosition": 58}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA0ODg2Mjk3OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.jablotron/src/main/java/org/openhab/binding/jablotron/internal/handler/JablotronJa100FHandler.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMlQwOToyMDowOVrOHQz5UQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMlQxNjowMzoxMlrOHQ19aw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzM4OTUyMQ==", "bodyText": "These don't need to be nullable, as they are initialized in the constructor.", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r487389521", "createdAt": "2020-09-12T09:20:09Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.jablotron/src/main/java/org/openhab/binding/jablotron/internal/handler/JablotronJa100FHandler.java", "diffHunk": "@@ -0,0 +1,251 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.jablotron.internal.handler;\n+\n+import static org.openhab.binding.jablotron.JablotronBindingConstants.CACHE_TIMEOUT_MS;\n+import static org.openhab.binding.jablotron.JablotronBindingConstants.CHANNEL_LAST_CHECK_TIME;\n+\n+import java.util.List;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.cache.ExpiringCache;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.binding.builder.ChannelBuilder;\n+import org.eclipse.smarthome.core.thing.binding.builder.ThingBuilder;\n+import org.eclipse.smarthome.core.thing.type.ChannelTypeUID;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.jablotron.internal.model.JablotronHistoryDataEvent;\n+import org.openhab.binding.jablotron.internal.model.JablotronServiceDetailSegment;\n+import org.openhab.binding.jablotron.internal.model.ja100f.JablotronGetPGResponse;\n+import org.openhab.binding.jablotron.internal.model.ja100f.JablotronGetSectionsResponse;\n+import org.openhab.binding.jablotron.internal.model.ja100f.JablotronSection;\n+import org.openhab.binding.jablotron.internal.model.ja100f.JablotronState;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link JablotronJa100FHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Ondrej Pecta - Initial contribution\n+ */\n+@NonNullByDefault\n+public class JablotronJa100FHandler extends JablotronAlarmHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(JablotronJa100FHandler.class);\n+\n+    private @Nullable ExpiringCache<JablotronGetSectionsResponse> sectionCache;\n+    private @Nullable ExpiringCache<JablotronGetPGResponse> pgCache;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bb824dab23246fe665151e79780dc81f6fe4928f"}, "originalPosition": 55}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzQyMzMzOQ==", "bodyText": "ok, removed nullable", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r487423339", "createdAt": "2020-09-12T16:03:12Z", "author": {"login": "octa22"}, "path": "bundles/org.openhab.binding.jablotron/src/main/java/org/openhab/binding/jablotron/internal/handler/JablotronJa100FHandler.java", "diffHunk": "@@ -0,0 +1,251 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.jablotron.internal.handler;\n+\n+import static org.openhab.binding.jablotron.JablotronBindingConstants.CACHE_TIMEOUT_MS;\n+import static org.openhab.binding.jablotron.JablotronBindingConstants.CHANNEL_LAST_CHECK_TIME;\n+\n+import java.util.List;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.cache.ExpiringCache;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.binding.builder.ChannelBuilder;\n+import org.eclipse.smarthome.core.thing.binding.builder.ThingBuilder;\n+import org.eclipse.smarthome.core.thing.type.ChannelTypeUID;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.jablotron.internal.model.JablotronHistoryDataEvent;\n+import org.openhab.binding.jablotron.internal.model.JablotronServiceDetailSegment;\n+import org.openhab.binding.jablotron.internal.model.ja100f.JablotronGetPGResponse;\n+import org.openhab.binding.jablotron.internal.model.ja100f.JablotronGetSectionsResponse;\n+import org.openhab.binding.jablotron.internal.model.ja100f.JablotronSection;\n+import org.openhab.binding.jablotron.internal.model.ja100f.JablotronState;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link JablotronJa100FHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Ondrej Pecta - Initial contribution\n+ */\n+@NonNullByDefault\n+public class JablotronJa100FHandler extends JablotronAlarmHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(JablotronJa100FHandler.class);\n+\n+    private @Nullable ExpiringCache<JablotronGetSectionsResponse> sectionCache;\n+    private @Nullable ExpiringCache<JablotronGetPGResponse> pgCache;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzM4OTUyMQ=="}, "originalCommit": {"oid": "bb824dab23246fe665151e79780dc81f6fe4928f"}, "originalPosition": 55}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA0ODg2MzczOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.jablotron/src/main/java/org/openhab/binding/jablotron/internal/handler/JablotronJa100FHandler.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMlQwOToyMToyNFrOHQz5tQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMlQxNTo0ODowMFrOHQ14fw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzM4OTYyMQ==", "bodyText": "To eliminate the compiler warnings, you could move this initialization to the JablotronAlarmHandler constructor.", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r487389621", "createdAt": "2020-09-12T09:21:24Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.jablotron/src/main/java/org/openhab/binding/jablotron/internal/handler/JablotronJa100FHandler.java", "diffHunk": "@@ -0,0 +1,251 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.jablotron.internal.handler;\n+\n+import static org.openhab.binding.jablotron.JablotronBindingConstants.CACHE_TIMEOUT_MS;\n+import static org.openhab.binding.jablotron.JablotronBindingConstants.CHANNEL_LAST_CHECK_TIME;\n+\n+import java.util.List;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.cache.ExpiringCache;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.binding.builder.ChannelBuilder;\n+import org.eclipse.smarthome.core.thing.binding.builder.ThingBuilder;\n+import org.eclipse.smarthome.core.thing.type.ChannelTypeUID;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.jablotron.internal.model.JablotronHistoryDataEvent;\n+import org.openhab.binding.jablotron.internal.model.JablotronServiceDetailSegment;\n+import org.openhab.binding.jablotron.internal.model.ja100f.JablotronGetPGResponse;\n+import org.openhab.binding.jablotron.internal.model.ja100f.JablotronGetSectionsResponse;\n+import org.openhab.binding.jablotron.internal.model.ja100f.JablotronSection;\n+import org.openhab.binding.jablotron.internal.model.ja100f.JablotronState;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link JablotronJa100FHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Ondrej Pecta - Initial contribution\n+ */\n+@NonNullByDefault\n+public class JablotronJa100FHandler extends JablotronAlarmHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(JablotronJa100FHandler.class);\n+\n+    private @Nullable ExpiringCache<JablotronGetSectionsResponse> sectionCache;\n+    private @Nullable ExpiringCache<JablotronGetPGResponse> pgCache;\n+\n+    public JablotronJa100FHandler(Thing thing, String alarmName) {\n+        super(thing, alarmName);\n+        eventCache = new ExpiringCache<>(CACHE_TIMEOUT_MS, this::sendGetEventHistory);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bb824dab23246fe665151e79780dc81f6fe4928f"}, "originalPosition": 59}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzQyMjA3OQ==", "bodyText": "moved to constructor", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r487422079", "createdAt": "2020-09-12T15:48:00Z", "author": {"login": "octa22"}, "path": "bundles/org.openhab.binding.jablotron/src/main/java/org/openhab/binding/jablotron/internal/handler/JablotronJa100FHandler.java", "diffHunk": "@@ -0,0 +1,251 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.jablotron.internal.handler;\n+\n+import static org.openhab.binding.jablotron.JablotronBindingConstants.CACHE_TIMEOUT_MS;\n+import static org.openhab.binding.jablotron.JablotronBindingConstants.CHANNEL_LAST_CHECK_TIME;\n+\n+import java.util.List;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.cache.ExpiringCache;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.binding.builder.ChannelBuilder;\n+import org.eclipse.smarthome.core.thing.binding.builder.ThingBuilder;\n+import org.eclipse.smarthome.core.thing.type.ChannelTypeUID;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.jablotron.internal.model.JablotronHistoryDataEvent;\n+import org.openhab.binding.jablotron.internal.model.JablotronServiceDetailSegment;\n+import org.openhab.binding.jablotron.internal.model.ja100f.JablotronGetPGResponse;\n+import org.openhab.binding.jablotron.internal.model.ja100f.JablotronGetSectionsResponse;\n+import org.openhab.binding.jablotron.internal.model.ja100f.JablotronSection;\n+import org.openhab.binding.jablotron.internal.model.ja100f.JablotronState;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link JablotronJa100FHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Ondrej Pecta - Initial contribution\n+ */\n+@NonNullByDefault\n+public class JablotronJa100FHandler extends JablotronAlarmHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(JablotronJa100FHandler.class);\n+\n+    private @Nullable ExpiringCache<JablotronGetSectionsResponse> sectionCache;\n+    private @Nullable ExpiringCache<JablotronGetPGResponse> pgCache;\n+\n+    public JablotronJa100FHandler(Thing thing, String alarmName) {\n+        super(thing, alarmName);\n+        eventCache = new ExpiringCache<>(CACHE_TIMEOUT_MS, this::sendGetEventHistory);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzM4OTYyMQ=="}, "originalCommit": {"oid": "bb824dab23246fe665151e79780dc81f6fe4928f"}, "originalPosition": 59}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA0ODg2ODgyOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.jablotron/src/main/java/org/openhab/binding/jablotron/internal/handler/JablotronAlarmHandler.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMlQwOToyODo0N1rOHQz8Cw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMlQxNTo0NzozNFrOHQ14Xw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzM5MDIxOQ==", "bodyText": "If I see correctly, eventCache is always non-null in your implementation.", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r487390219", "createdAt": "2020-09-12T09:28:47Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.jablotron/src/main/java/org/openhab/binding/jablotron/internal/handler/JablotronAlarmHandler.java", "diffHunk": "@@ -0,0 +1,268 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.jablotron.internal.handler;\n+\n+import static org.openhab.binding.jablotron.JablotronBindingConstants.*;\n+\n+import java.time.Instant;\n+import java.time.ZoneId;\n+import java.time.ZonedDateTime;\n+import java.time.format.DateTimeFormatter;\n+import java.util.List;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.cache.ExpiringCache;\n+import org.eclipse.smarthome.core.library.types.DateTimeType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.*;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.jablotron.internal.config.JablotronDeviceConfig;\n+import org.openhab.binding.jablotron.internal.model.*;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+\n+/**\n+ * The {@link JablotronAlarmHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Ondrej Pecta - Initial contribution\n+ */\n+@NonNullByDefault\n+public abstract class JablotronAlarmHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(getClass());\n+\n+    protected final Gson gson = new Gson();\n+\n+    protected JablotronDeviceConfig thingConfig = new JablotronDeviceConfig();\n+\n+    private String lastWarningTime = \"\";\n+\n+    protected String alarmName = \"\";\n+\n+    private boolean inService = false;\n+\n+    protected @Nullable ScheduledFuture<?> future = null;\n+\n+    protected @Nullable ExpiringCache<JablotronDataUpdateResponse> dataCache;\n+    protected @Nullable ExpiringCache<List<JablotronHistoryDataEvent>> eventCache;\n+\n+    public JablotronAlarmHandler(Thing thing, String alarmName) {\n+        super(thing);\n+        this.alarmName = alarmName;\n+    }\n+\n+    @Override\n+    public void bridgeStatusChanged(ThingStatusInfo bridgeStatusInfo) {\n+        super.bridgeStatusChanged(bridgeStatusInfo);\n+        if (ThingStatus.UNINITIALIZED == bridgeStatusInfo.getStatus()) {\n+            cleanup();\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        super.dispose();\n+        cleanup();\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        thingConfig = getConfigAs(JablotronDeviceConfig.class);\n+        future = scheduler.scheduleWithFixedDelay(this::updateAlarmStatus, 1, thingConfig.getRefresh(),\n+                TimeUnit.SECONDS);\n+        updateStatus(ThingStatus.ONLINE);\n+    }\n+\n+    public boolean isInService() {\n+        return inService;\n+    }\n+\n+    public String getAlarmName() {\n+        return alarmName;\n+    }\n+\n+    protected abstract void updateSegmentStatus(JablotronServiceDetailSegment segment);\n+\n+    protected void updateSegmentStatus(String segmentName, @Nullable JablotronDataUpdateResponse dataUpdate) {\n+        if (dataUpdate == null || !dataUpdate.isStatus()) {\n+            return;\n+        }\n+        List<JablotronServiceData> serviceData = dataUpdate.getData().getServiceData();\n+        for (JablotronServiceData data : serviceData) {\n+            if (!thingConfig.getServiceId().equals(data.getServiceId())) {\n+                continue;\n+            }\n+            List<JablotronService> services = data.getData();\n+            for (JablotronService service : services) {\n+                JablotronServiceDetail detail = service.getData();\n+                for (JablotronServiceDetailSegment segment : detail.getSegments()) {\n+                    if (segmentName.equals(segment.getSegmentId())) {\n+                        updateSegmentStatus(segment);\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    private void cleanup() {\n+        logger.debug(\"doing cleanup...\");\n+        if (future != null) {\n+            future.cancel(true);\n+        }\n+    }\n+\n+    protected State getCheckTime() {\n+        ZonedDateTime zdt = ZonedDateTime.ofInstant(Instant.now(), ZoneId.systemDefault());\n+        return new DateTimeType(zdt);\n+    }\n+\n+    protected synchronized @Nullable JablotronDataUpdateResponse sendGetStatusRequest() {\n+        JablotronBridgeHandler handler = getBridgeHandler();\n+        if (handler != null) {\n+            return handler.sendGetStatusRequest(getThing());\n+        }\n+        return null;\n+    }\n+\n+    protected synchronized boolean updateAlarmStatus() {\n+        JablotronDataUpdateResponse dataUpdate = sendGetStatusRequest();\n+        if (dataUpdate == null) {\n+            return false;\n+        }\n+\n+        if (dataUpdate.isStatus()) {\n+            updateState(CHANNEL_LAST_CHECK_TIME, getCheckTime());\n+            List<JablotronServiceData> serviceData = dataUpdate.getData().getServiceData();\n+            for (JablotronServiceData data : serviceData) {\n+                if (!thingConfig.getServiceId().equals(data.getServiceId())) {\n+                    continue;\n+                }\n+                List<JablotronService> services = data.getData();\n+                for (JablotronService service : services) {\n+                    JablotronServiceDetail detail = service.getData();\n+                    for (JablotronServiceDetailSegment segment : detail.getSegments()) {\n+                        updateSegmentStatus(segment);\n+                    }\n+                }\n+\n+            }\n+        } else {\n+            logger.debug(\"Error during alarm status update: {}\", dataUpdate.getErrorMessage());\n+        }\n+\n+        List<JablotronHistoryDataEvent> events = sendGetEventHistory();\n+        if (events != null && events.size() > 0) {\n+            JablotronHistoryDataEvent event = events.get(0);\n+            updateLastEvent(event);\n+        }\n+\n+        return true;\n+    }\n+\n+    protected @Nullable List<JablotronHistoryDataEvent> sendGetEventHistory() {\n+        return sendGetEventHistory(alarmName);\n+    }\n+\n+    private @Nullable List<JablotronHistoryDataEvent> sendGetEventHistory(String alarm) {\n+        JablotronBridgeHandler handler = getBridgeHandler();\n+        if (handler != null) {\n+            return handler.sendGetEventHistory(getThing(), alarm);\n+        }\n+        return null;\n+    }\n+\n+    protected void updateLastEvent(JablotronHistoryDataEvent event) {\n+        updateState(CHANNEL_LAST_EVENT_TIME, new DateTimeType(getZonedDateTime(event.getDate())));\n+        updateState(CHANNEL_LAST_EVENT, new StringType(event.getEventText()));\n+        updateState(CHANNEL_LAST_EVENT_CLASS, new StringType(event.getIconType()));\n+        updateState(CHANNEL_LAST_EVENT_INVOKER, new StringType(event.getInvokerName()));\n+\n+        // oasis does not have sections\n+        if (getThing().getChannel(CHANNEL_LAST_EVENT_SECTION) != null) {\n+            updateState(CHANNEL_LAST_EVENT_SECTION, new StringType(event.getSectionName()));\n+        }\n+    }\n+\n+    protected void updateEventChannel(String channel) {\n+        List<JablotronHistoryDataEvent> events = eventCache != null ? eventCache.getValue() : null;\n+        if (events != null && events.size() > 0) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bb824dab23246fe665151e79780dc81f6fe4928f"}, "originalPosition": 205}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzQyMjA0Nw==", "bodyText": "fixed", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r487422047", "createdAt": "2020-09-12T15:47:34Z", "author": {"login": "octa22"}, "path": "bundles/org.openhab.binding.jablotron/src/main/java/org/openhab/binding/jablotron/internal/handler/JablotronAlarmHandler.java", "diffHunk": "@@ -0,0 +1,268 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.jablotron.internal.handler;\n+\n+import static org.openhab.binding.jablotron.JablotronBindingConstants.*;\n+\n+import java.time.Instant;\n+import java.time.ZoneId;\n+import java.time.ZonedDateTime;\n+import java.time.format.DateTimeFormatter;\n+import java.util.List;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.cache.ExpiringCache;\n+import org.eclipse.smarthome.core.library.types.DateTimeType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.*;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.jablotron.internal.config.JablotronDeviceConfig;\n+import org.openhab.binding.jablotron.internal.model.*;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+\n+/**\n+ * The {@link JablotronAlarmHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Ondrej Pecta - Initial contribution\n+ */\n+@NonNullByDefault\n+public abstract class JablotronAlarmHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(getClass());\n+\n+    protected final Gson gson = new Gson();\n+\n+    protected JablotronDeviceConfig thingConfig = new JablotronDeviceConfig();\n+\n+    private String lastWarningTime = \"\";\n+\n+    protected String alarmName = \"\";\n+\n+    private boolean inService = false;\n+\n+    protected @Nullable ScheduledFuture<?> future = null;\n+\n+    protected @Nullable ExpiringCache<JablotronDataUpdateResponse> dataCache;\n+    protected @Nullable ExpiringCache<List<JablotronHistoryDataEvent>> eventCache;\n+\n+    public JablotronAlarmHandler(Thing thing, String alarmName) {\n+        super(thing);\n+        this.alarmName = alarmName;\n+    }\n+\n+    @Override\n+    public void bridgeStatusChanged(ThingStatusInfo bridgeStatusInfo) {\n+        super.bridgeStatusChanged(bridgeStatusInfo);\n+        if (ThingStatus.UNINITIALIZED == bridgeStatusInfo.getStatus()) {\n+            cleanup();\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        super.dispose();\n+        cleanup();\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        thingConfig = getConfigAs(JablotronDeviceConfig.class);\n+        future = scheduler.scheduleWithFixedDelay(this::updateAlarmStatus, 1, thingConfig.getRefresh(),\n+                TimeUnit.SECONDS);\n+        updateStatus(ThingStatus.ONLINE);\n+    }\n+\n+    public boolean isInService() {\n+        return inService;\n+    }\n+\n+    public String getAlarmName() {\n+        return alarmName;\n+    }\n+\n+    protected abstract void updateSegmentStatus(JablotronServiceDetailSegment segment);\n+\n+    protected void updateSegmentStatus(String segmentName, @Nullable JablotronDataUpdateResponse dataUpdate) {\n+        if (dataUpdate == null || !dataUpdate.isStatus()) {\n+            return;\n+        }\n+        List<JablotronServiceData> serviceData = dataUpdate.getData().getServiceData();\n+        for (JablotronServiceData data : serviceData) {\n+            if (!thingConfig.getServiceId().equals(data.getServiceId())) {\n+                continue;\n+            }\n+            List<JablotronService> services = data.getData();\n+            for (JablotronService service : services) {\n+                JablotronServiceDetail detail = service.getData();\n+                for (JablotronServiceDetailSegment segment : detail.getSegments()) {\n+                    if (segmentName.equals(segment.getSegmentId())) {\n+                        updateSegmentStatus(segment);\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    private void cleanup() {\n+        logger.debug(\"doing cleanup...\");\n+        if (future != null) {\n+            future.cancel(true);\n+        }\n+    }\n+\n+    protected State getCheckTime() {\n+        ZonedDateTime zdt = ZonedDateTime.ofInstant(Instant.now(), ZoneId.systemDefault());\n+        return new DateTimeType(zdt);\n+    }\n+\n+    protected synchronized @Nullable JablotronDataUpdateResponse sendGetStatusRequest() {\n+        JablotronBridgeHandler handler = getBridgeHandler();\n+        if (handler != null) {\n+            return handler.sendGetStatusRequest(getThing());\n+        }\n+        return null;\n+    }\n+\n+    protected synchronized boolean updateAlarmStatus() {\n+        JablotronDataUpdateResponse dataUpdate = sendGetStatusRequest();\n+        if (dataUpdate == null) {\n+            return false;\n+        }\n+\n+        if (dataUpdate.isStatus()) {\n+            updateState(CHANNEL_LAST_CHECK_TIME, getCheckTime());\n+            List<JablotronServiceData> serviceData = dataUpdate.getData().getServiceData();\n+            for (JablotronServiceData data : serviceData) {\n+                if (!thingConfig.getServiceId().equals(data.getServiceId())) {\n+                    continue;\n+                }\n+                List<JablotronService> services = data.getData();\n+                for (JablotronService service : services) {\n+                    JablotronServiceDetail detail = service.getData();\n+                    for (JablotronServiceDetailSegment segment : detail.getSegments()) {\n+                        updateSegmentStatus(segment);\n+                    }\n+                }\n+\n+            }\n+        } else {\n+            logger.debug(\"Error during alarm status update: {}\", dataUpdate.getErrorMessage());\n+        }\n+\n+        List<JablotronHistoryDataEvent> events = sendGetEventHistory();\n+        if (events != null && events.size() > 0) {\n+            JablotronHistoryDataEvent event = events.get(0);\n+            updateLastEvent(event);\n+        }\n+\n+        return true;\n+    }\n+\n+    protected @Nullable List<JablotronHistoryDataEvent> sendGetEventHistory() {\n+        return sendGetEventHistory(alarmName);\n+    }\n+\n+    private @Nullable List<JablotronHistoryDataEvent> sendGetEventHistory(String alarm) {\n+        JablotronBridgeHandler handler = getBridgeHandler();\n+        if (handler != null) {\n+            return handler.sendGetEventHistory(getThing(), alarm);\n+        }\n+        return null;\n+    }\n+\n+    protected void updateLastEvent(JablotronHistoryDataEvent event) {\n+        updateState(CHANNEL_LAST_EVENT_TIME, new DateTimeType(getZonedDateTime(event.getDate())));\n+        updateState(CHANNEL_LAST_EVENT, new StringType(event.getEventText()));\n+        updateState(CHANNEL_LAST_EVENT_CLASS, new StringType(event.getIconType()));\n+        updateState(CHANNEL_LAST_EVENT_INVOKER, new StringType(event.getInvokerName()));\n+\n+        // oasis does not have sections\n+        if (getThing().getChannel(CHANNEL_LAST_EVENT_SECTION) != null) {\n+            updateState(CHANNEL_LAST_EVENT_SECTION, new StringType(event.getSectionName()));\n+        }\n+    }\n+\n+    protected void updateEventChannel(String channel) {\n+        List<JablotronHistoryDataEvent> events = eventCache != null ? eventCache.getValue() : null;\n+        if (events != null && events.size() > 0) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzM5MDIxOQ=="}, "originalCommit": {"oid": "bb824dab23246fe665151e79780dc81f6fe4928f"}, "originalPosition": 205}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA0ODg3MTA3OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.jablotron/src/main/java/org/openhab/binding/jablotron/internal/handler/JablotronJa100Handler.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMlQwOTozMDo1MlrOHQz9Ag==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMlQxNTozNTowOVrOHQ10ZA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzM5MDQ2Ng==", "bodyText": "channel cannot be null at this point.", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r487390466", "createdAt": "2020-09-12T09:30:52Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.jablotron/src/main/java/org/openhab/binding/jablotron/internal/handler/JablotronJa100Handler.java", "diffHunk": "@@ -0,0 +1,226 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.jablotron.internal.handler;\n+\n+import static org.openhab.binding.jablotron.JablotronBindingConstants.CACHE_TIMEOUT_MS;\n+import static org.openhab.binding.jablotron.JablotronBindingConstants.CHANNEL_LAST_CHECK_TIME;\n+\n+import java.util.List;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.smarthome.core.cache.ExpiringCache;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.binding.builder.ChannelBuilder;\n+import org.eclipse.smarthome.core.thing.binding.builder.ThingBuilder;\n+import org.eclipse.smarthome.core.thing.type.ChannelTypeUID;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.jablotron.internal.model.JablotronControlResponse;\n+import org.openhab.binding.jablotron.internal.model.JablotronServiceDetailSegment;\n+import org.openhab.binding.jablotron.internal.model.JablotronServiceDetailSegmentInfo;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link JablotronJa100Handler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Ondrej Pecta - Initial contribution\n+ */\n+@NonNullByDefault\n+public class JablotronJa100Handler extends JablotronAlarmHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(JablotronJa100Handler.class);\n+\n+    public JablotronJa100Handler(Thing thing, String alarmName) {\n+        super(thing, alarmName);\n+        dataCache = new ExpiringCache<>(CACHE_TIMEOUT_MS, this::sendGetStatusRequest);\n+        eventCache = new ExpiringCache<>(CACHE_TIMEOUT_MS, this::sendGetEventHistory);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (RefreshType.REFRESH.equals(command)) {\n+            logger.debug(\"refreshing channel: {}\", channelUID.getId());\n+            updateChannel(channelUID.getId());\n+        } else {\n+            if (channelUID.getId().startsWith(\"STATE_\") && command instanceof StringType) {\n+                scheduler.execute(() -> {\n+                    controlSTATESection(channelUID.getId(), command.toString());\n+                });\n+            }\n+\n+            if (channelUID.getId().startsWith(\"PGM_\") && command instanceof OnOffType) {\n+                scheduler.execute(() -> {\n+                    controlPGMSection(channelUID.getId(), command.equals(OnOffType.ON) ? \"set\" : \"unset\");\n+                });\n+            }\n+        }\n+    }\n+\n+    private void updateChannel(String channel) {\n+        if (channel.startsWith(\"STATE_\") || channel.startsWith(\"PGM_\") || channel.startsWith(\"THERMOMETER_\")\n+                || channel.startsWith(\"THERMOSTAT_\")) {\n+            updateSegmentStatus(channel, dataCache.getValue());\n+        } else if (CHANNEL_LAST_CHECK_TIME.equals(channel)) {\n+            // not updating\n+        } else {\n+            updateEventChannel(channel);\n+        }\n+    }\n+\n+    private void createChannel(JablotronServiceDetailSegment section) {\n+        if (section.getSegmentId().startsWith(\"PGM_\")) {\n+            createPGMChannel(section.getSegmentId(), section.getSegmentName());\n+        } else {\n+            createStateChannel(section.getSegmentId(), section.getSegmentName());\n+        }\n+    }\n+\n+    private void createTempChannel(String name, String label) {\n+        ChannelTypeUID temperature = new ChannelTypeUID(\"jablotron\", \"temperature\");\n+        ThingBuilder thingBuilder = editThing();\n+        Channel channel = ChannelBuilder.create(new ChannelUID(thing.getUID(), name), \"Number:Temperature\")\n+                .withLabel(label).withType(temperature).build();\n+        thingBuilder.withChannel(channel);\n+        updateThing(thingBuilder.build());\n+    }\n+\n+    private void createThermostatChannel(String name, String label) {\n+        ChannelTypeUID temperature = new ChannelTypeUID(\"jablotron\", \"thermostat\");\n+        ThingBuilder thingBuilder = editThing();\n+        Channel channel = ChannelBuilder.create(new ChannelUID(thing.getUID(), name), \"Number:Temperature\")\n+                .withLabel(label).withType(temperature).build();\n+        thingBuilder.withChannel(channel);\n+        updateThing(thingBuilder.build());\n+    }\n+\n+    private void createPGMChannel(String name, String label) {\n+        ThingBuilder thingBuilder = editThing();\n+        Channel channel = ChannelBuilder.create(new ChannelUID(thing.getUID(), name), \"Switch\").withLabel(label)\n+                .build();\n+        thingBuilder.withChannel(channel);\n+        updateThing(thingBuilder.build());\n+    }\n+\n+    private void createStateChannel(String name, String label) {\n+        ChannelTypeUID alarmStatus = new ChannelTypeUID(\"jablotron\", \"alarm_state\");\n+        ThingBuilder thingBuilder = editThing();\n+        Channel channel = ChannelBuilder.create(new ChannelUID(thing.getUID(), name), \"String\").withLabel(label)\n+                .withType(alarmStatus).build();\n+        thingBuilder.withChannel(channel);\n+        updateThing(thingBuilder.build());\n+    }\n+\n+    @Override\n+    protected void updateSegmentStatus(JablotronServiceDetailSegment segment) {\n+        logger.debug(\"Segment id: {} and status: {}\", segment.getSegmentId(), segment.getSegmentState());\n+        String segmentId = segment.getSegmentId();\n+\n+        if (segmentId.startsWith(\"STATE_\") || segmentId.startsWith(\"PGM_\")) {\n+            processSection(segment);\n+        } else if (segmentId.startsWith(\"THERMOMETER_\")) {\n+            processThermometer(segment);\n+        } else if (segmentId.startsWith(\"THERMOSTAT_\")) {\n+            processThermostat(segment);\n+        } else {\n+            logger.debug(\"Unknown segment received: {} with state: {}\", segment.getSegmentId(),\n+                    segment.getSegmentState());\n+        }\n+    }\n+\n+    private void processSection(JablotronServiceDetailSegment segment) {\n+        String segmentId = segment.getSegmentId();\n+        Channel channel = getThing().getChannel(segmentId);\n+        if (channel == null) {\n+            logger.debug(\"Creating a new channel: {}\", segmentId);\n+            createChannel(segment);\n+        }\n+        channel = getThing().getChannel(segmentId);\n+        if (channel != null) {\n+            logger.debug(\"Updating channel: {} to value: {}\", channel.getUID(), segment.getSegmentState());\n+            State newState;\n+            if (segmentId.startsWith(\"PGM_\")) {\n+                newState = \"unset\".equals(segment.getSegmentState()) ? OnOffType.OFF : OnOffType.ON;\n+            } else {\n+                newState = new StringType(segment.getSegmentState());\n+            }\n+            updateState(channel.getUID(), newState);\n+        } else {\n+            logger.debug(\"The channel: {} still doesn't exist!\", segmentId);\n+        }\n+    }\n+\n+    private void processThermometer(JablotronServiceDetailSegment segment) {\n+        String segmentId = segment.getSegmentId();\n+        Channel channel = getThing().getChannel(segmentId);\n+        if (channel == null) {\n+            logger.debug(\"Creating a new temperature channel: {}\", segmentId);\n+            createTempChannel(segmentId, segment.getSegmentName());\n+        }\n+        updateTemperatureChannel(channel, segment);\n+    }\n+\n+    private void processThermostat(JablotronServiceDetailSegment segment) {\n+        String segmentId = segment.getSegmentId();\n+        Channel channel = getThing().getChannel(segmentId);\n+        if (channel == null) {\n+            logger.debug(\"Creating a new thermostat channel: {}\", segmentId);\n+            createThermostatChannel(segmentId, segment.getSegmentName());\n+        }\n+        updateTemperatureChannel(channel, segment);\n+    }\n+\n+    private void updateTemperatureChannel(Channel channel, JablotronServiceDetailSegment segment) {\n+        String segmentId = segment.getSegmentId();\n+        if (channel != null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bb824dab23246fe665151e79780dc81f6fe4928f"}, "originalPosition": 192}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzQyMTAyOA==", "bodyText": "ok", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r487421028", "createdAt": "2020-09-12T15:35:09Z", "author": {"login": "octa22"}, "path": "bundles/org.openhab.binding.jablotron/src/main/java/org/openhab/binding/jablotron/internal/handler/JablotronJa100Handler.java", "diffHunk": "@@ -0,0 +1,226 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.jablotron.internal.handler;\n+\n+import static org.openhab.binding.jablotron.JablotronBindingConstants.CACHE_TIMEOUT_MS;\n+import static org.openhab.binding.jablotron.JablotronBindingConstants.CHANNEL_LAST_CHECK_TIME;\n+\n+import java.util.List;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.smarthome.core.cache.ExpiringCache;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.binding.builder.ChannelBuilder;\n+import org.eclipse.smarthome.core.thing.binding.builder.ThingBuilder;\n+import org.eclipse.smarthome.core.thing.type.ChannelTypeUID;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.jablotron.internal.model.JablotronControlResponse;\n+import org.openhab.binding.jablotron.internal.model.JablotronServiceDetailSegment;\n+import org.openhab.binding.jablotron.internal.model.JablotronServiceDetailSegmentInfo;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link JablotronJa100Handler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Ondrej Pecta - Initial contribution\n+ */\n+@NonNullByDefault\n+public class JablotronJa100Handler extends JablotronAlarmHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(JablotronJa100Handler.class);\n+\n+    public JablotronJa100Handler(Thing thing, String alarmName) {\n+        super(thing, alarmName);\n+        dataCache = new ExpiringCache<>(CACHE_TIMEOUT_MS, this::sendGetStatusRequest);\n+        eventCache = new ExpiringCache<>(CACHE_TIMEOUT_MS, this::sendGetEventHistory);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (RefreshType.REFRESH.equals(command)) {\n+            logger.debug(\"refreshing channel: {}\", channelUID.getId());\n+            updateChannel(channelUID.getId());\n+        } else {\n+            if (channelUID.getId().startsWith(\"STATE_\") && command instanceof StringType) {\n+                scheduler.execute(() -> {\n+                    controlSTATESection(channelUID.getId(), command.toString());\n+                });\n+            }\n+\n+            if (channelUID.getId().startsWith(\"PGM_\") && command instanceof OnOffType) {\n+                scheduler.execute(() -> {\n+                    controlPGMSection(channelUID.getId(), command.equals(OnOffType.ON) ? \"set\" : \"unset\");\n+                });\n+            }\n+        }\n+    }\n+\n+    private void updateChannel(String channel) {\n+        if (channel.startsWith(\"STATE_\") || channel.startsWith(\"PGM_\") || channel.startsWith(\"THERMOMETER_\")\n+                || channel.startsWith(\"THERMOSTAT_\")) {\n+            updateSegmentStatus(channel, dataCache.getValue());\n+        } else if (CHANNEL_LAST_CHECK_TIME.equals(channel)) {\n+            // not updating\n+        } else {\n+            updateEventChannel(channel);\n+        }\n+    }\n+\n+    private void createChannel(JablotronServiceDetailSegment section) {\n+        if (section.getSegmentId().startsWith(\"PGM_\")) {\n+            createPGMChannel(section.getSegmentId(), section.getSegmentName());\n+        } else {\n+            createStateChannel(section.getSegmentId(), section.getSegmentName());\n+        }\n+    }\n+\n+    private void createTempChannel(String name, String label) {\n+        ChannelTypeUID temperature = new ChannelTypeUID(\"jablotron\", \"temperature\");\n+        ThingBuilder thingBuilder = editThing();\n+        Channel channel = ChannelBuilder.create(new ChannelUID(thing.getUID(), name), \"Number:Temperature\")\n+                .withLabel(label).withType(temperature).build();\n+        thingBuilder.withChannel(channel);\n+        updateThing(thingBuilder.build());\n+    }\n+\n+    private void createThermostatChannel(String name, String label) {\n+        ChannelTypeUID temperature = new ChannelTypeUID(\"jablotron\", \"thermostat\");\n+        ThingBuilder thingBuilder = editThing();\n+        Channel channel = ChannelBuilder.create(new ChannelUID(thing.getUID(), name), \"Number:Temperature\")\n+                .withLabel(label).withType(temperature).build();\n+        thingBuilder.withChannel(channel);\n+        updateThing(thingBuilder.build());\n+    }\n+\n+    private void createPGMChannel(String name, String label) {\n+        ThingBuilder thingBuilder = editThing();\n+        Channel channel = ChannelBuilder.create(new ChannelUID(thing.getUID(), name), \"Switch\").withLabel(label)\n+                .build();\n+        thingBuilder.withChannel(channel);\n+        updateThing(thingBuilder.build());\n+    }\n+\n+    private void createStateChannel(String name, String label) {\n+        ChannelTypeUID alarmStatus = new ChannelTypeUID(\"jablotron\", \"alarm_state\");\n+        ThingBuilder thingBuilder = editThing();\n+        Channel channel = ChannelBuilder.create(new ChannelUID(thing.getUID(), name), \"String\").withLabel(label)\n+                .withType(alarmStatus).build();\n+        thingBuilder.withChannel(channel);\n+        updateThing(thingBuilder.build());\n+    }\n+\n+    @Override\n+    protected void updateSegmentStatus(JablotronServiceDetailSegment segment) {\n+        logger.debug(\"Segment id: {} and status: {}\", segment.getSegmentId(), segment.getSegmentState());\n+        String segmentId = segment.getSegmentId();\n+\n+        if (segmentId.startsWith(\"STATE_\") || segmentId.startsWith(\"PGM_\")) {\n+            processSection(segment);\n+        } else if (segmentId.startsWith(\"THERMOMETER_\")) {\n+            processThermometer(segment);\n+        } else if (segmentId.startsWith(\"THERMOSTAT_\")) {\n+            processThermostat(segment);\n+        } else {\n+            logger.debug(\"Unknown segment received: {} with state: {}\", segment.getSegmentId(),\n+                    segment.getSegmentState());\n+        }\n+    }\n+\n+    private void processSection(JablotronServiceDetailSegment segment) {\n+        String segmentId = segment.getSegmentId();\n+        Channel channel = getThing().getChannel(segmentId);\n+        if (channel == null) {\n+            logger.debug(\"Creating a new channel: {}\", segmentId);\n+            createChannel(segment);\n+        }\n+        channel = getThing().getChannel(segmentId);\n+        if (channel != null) {\n+            logger.debug(\"Updating channel: {} to value: {}\", channel.getUID(), segment.getSegmentState());\n+            State newState;\n+            if (segmentId.startsWith(\"PGM_\")) {\n+                newState = \"unset\".equals(segment.getSegmentState()) ? OnOffType.OFF : OnOffType.ON;\n+            } else {\n+                newState = new StringType(segment.getSegmentState());\n+            }\n+            updateState(channel.getUID(), newState);\n+        } else {\n+            logger.debug(\"The channel: {} still doesn't exist!\", segmentId);\n+        }\n+    }\n+\n+    private void processThermometer(JablotronServiceDetailSegment segment) {\n+        String segmentId = segment.getSegmentId();\n+        Channel channel = getThing().getChannel(segmentId);\n+        if (channel == null) {\n+            logger.debug(\"Creating a new temperature channel: {}\", segmentId);\n+            createTempChannel(segmentId, segment.getSegmentName());\n+        }\n+        updateTemperatureChannel(channel, segment);\n+    }\n+\n+    private void processThermostat(JablotronServiceDetailSegment segment) {\n+        String segmentId = segment.getSegmentId();\n+        Channel channel = getThing().getChannel(segmentId);\n+        if (channel == null) {\n+            logger.debug(\"Creating a new thermostat channel: {}\", segmentId);\n+            createThermostatChannel(segmentId, segment.getSegmentName());\n+        }\n+        updateTemperatureChannel(channel, segment);\n+    }\n+\n+    private void updateTemperatureChannel(Channel channel, JablotronServiceDetailSegment segment) {\n+        String segmentId = segment.getSegmentId();\n+        if (channel != null) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzM5MDQ2Ng=="}, "originalCommit": {"oid": "bb824dab23246fe665151e79780dc81f6fe4928f"}, "originalPosition": 192}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA0ODg3MzY1OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.jablotron/README.md", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMlQwOTozNDozNlrOHQz-Iw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMlQxNjozNzoyMVrOHQ2JdA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzM5MDc1NQ==", "bodyText": "Sorry, I overlooked, that the Item Type column is missing. That could replace the footnote partially.", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r487390755", "createdAt": "2020-09-12T09:34:36Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.jablotron/README.md", "diffHunk": "@@ -0,0 +1,126 @@\n+# Jablotron Alarm Binding\n+\n+This is the binding for Jablotron alarms.\n+https://www.jablotron.com/en/jablotron-products/alarms/\n+\n+## Supported Things\n+\n+| thing   | note                                      |\n+|---------|-------------------------------------------|\n+| bridge  | the bridge to your Jablonet cloud account |\n+| JA-80   | the OASIS alarm                           |\n+| JA-100  | with the thermometer support              |\n+| JA-100F | without the thermometer support           |\n+ \n+## Discovery\n+\n+This binding supports auto discovery. Just manually add a bridge thing and supply login & password to your Jablonet account.\n+\n+## Binding Configuration\n+\n+Binding itself doesn't require specific configuration.\n+\n+## Thing Configuration\n+\n+| thing                | config parameter name | description                                                                        | type                  |\n+|----------------------|-----------------------|------------------------------------------------------------------------------------|-----------------------|\n+| bridge               | login                 | the login to your Jablonet account                                                 | mandatory             |\n+| bridge               | password              | the password to your Jablonet account                                              | mandatory             |\n+| bridge               | refresh               | the refresh time for all alarm warnings (ALARM, TAMPER triggers and SERVICE state) | optional, default=30s |\n+| bridge               | lang                  | the language of the alarm texts                                                    | optional, default=en  |\n+| JA-80/JA-100/JA-100F | refresh               | the channels refresh period in seconds                                             | optional, default=60s |\n+| JA-80/JA-100/JA-100F | serviceId             | the service ID which identifies the alarm                                          | mandatory             |\n+| JA-100/JA-100F       | code                  | the master code for controlling sections                                           | optional              |\n+\n+## Channels\n+\n+| thing                | channel name     | description                                               |", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bb824dab23246fe665151e79780dc81f6fe4928f"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzQyNjQyMA==", "bodyText": "right, added the item type column", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r487426420", "createdAt": "2020-09-12T16:37:21Z", "author": {"login": "octa22"}, "path": "bundles/org.openhab.binding.jablotron/README.md", "diffHunk": "@@ -0,0 +1,126 @@\n+# Jablotron Alarm Binding\n+\n+This is the binding for Jablotron alarms.\n+https://www.jablotron.com/en/jablotron-products/alarms/\n+\n+## Supported Things\n+\n+| thing   | note                                      |\n+|---------|-------------------------------------------|\n+| bridge  | the bridge to your Jablonet cloud account |\n+| JA-80   | the OASIS alarm                           |\n+| JA-100  | with the thermometer support              |\n+| JA-100F | without the thermometer support           |\n+ \n+## Discovery\n+\n+This binding supports auto discovery. Just manually add a bridge thing and supply login & password to your Jablonet account.\n+\n+## Binding Configuration\n+\n+Binding itself doesn't require specific configuration.\n+\n+## Thing Configuration\n+\n+| thing                | config parameter name | description                                                                        | type                  |\n+|----------------------|-----------------------|------------------------------------------------------------------------------------|-----------------------|\n+| bridge               | login                 | the login to your Jablonet account                                                 | mandatory             |\n+| bridge               | password              | the password to your Jablonet account                                              | mandatory             |\n+| bridge               | refresh               | the refresh time for all alarm warnings (ALARM, TAMPER triggers and SERVICE state) | optional, default=30s |\n+| bridge               | lang                  | the language of the alarm texts                                                    | optional, default=en  |\n+| JA-80/JA-100/JA-100F | refresh               | the channels refresh period in seconds                                             | optional, default=60s |\n+| JA-80/JA-100/JA-100F | serviceId             | the service ID which identifies the alarm                                          | mandatory             |\n+| JA-100/JA-100F       | code                  | the master code for controlling sections                                           | optional              |\n+\n+## Channels\n+\n+| thing                | channel name     | description                                               |", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzM5MDc1NQ=="}, "originalCommit": {"oid": "bb824dab23246fe665151e79780dc81f6fe4928f"}, "originalPosition": 37}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA0ODg3NDcxOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.jablotron/README.md", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMlQwOTozNTo0OFrOHQz-kw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMlQxOTo0MjoxM1rOHQ3Fvw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzM5MDg2Nw==", "bodyText": "Although these are special, as they are dynamically created, they should be camelCase, too.", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r487390867", "createdAt": "2020-09-12T09:35:48Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.jablotron/README.md", "diffHunk": "@@ -0,0 +1,126 @@\n+# Jablotron Alarm Binding\n+\n+This is the binding for Jablotron alarms.\n+https://www.jablotron.com/en/jablotron-products/alarms/\n+\n+## Supported Things\n+\n+| thing   | note                                      |\n+|---------|-------------------------------------------|\n+| bridge  | the bridge to your Jablonet cloud account |\n+| JA-80   | the OASIS alarm                           |\n+| JA-100  | with the thermometer support              |\n+| JA-100F | without the thermometer support           |\n+ \n+## Discovery\n+\n+This binding supports auto discovery. Just manually add a bridge thing and supply login & password to your Jablonet account.\n+\n+## Binding Configuration\n+\n+Binding itself doesn't require specific configuration.\n+\n+## Thing Configuration\n+\n+| thing                | config parameter name | description                                                                        | type                  |\n+|----------------------|-----------------------|------------------------------------------------------------------------------------|-----------------------|\n+| bridge               | login                 | the login to your Jablonet account                                                 | mandatory             |\n+| bridge               | password              | the password to your Jablonet account                                              | mandatory             |\n+| bridge               | refresh               | the refresh time for all alarm warnings (ALARM, TAMPER triggers and SERVICE state) | optional, default=30s |\n+| bridge               | lang                  | the language of the alarm texts                                                    | optional, default=en  |\n+| JA-80/JA-100/JA-100F | refresh               | the channels refresh period in seconds                                             | optional, default=60s |\n+| JA-80/JA-100/JA-100F | serviceId             | the service ID which identifies the alarm                                          | mandatory             |\n+| JA-100/JA-100F       | code                  | the master code for controlling sections                                           | optional              |\n+\n+## Channels\n+\n+| thing                | channel name     | description                                               |\n+|----------------------|------------------|-----------------------------------------------------------|\n+| bridge               | N/A              | the bridge does not expose any channels                   |\n+| JA-80                | statusA          | the status of the A section                               |\n+| JA-80                | statusB          | the status of the AB/B section                            |\n+| JA-80                | statusABC        | the status of the ABC section                             |\n+| JA-80                | statusPGX        | the status of PGX                                         |\n+| JA-80                | statusPGY        | the status of PGY                                         |\n+| JA-80                | command          | the channel for sending keyboard codes to the OASIS alarm |\n+| JA-80/JA-100/JA-100F | lastEvent        | the text description of the last event                    |\n+| JA-80/JA-100/JA-100F | lastEventClass   | the class of the last event - e.g. arm, disarm, ...       |\n+| JA-80/JA-100/JA-100F | lastEventInvoker | the invoker of the last event                             |\n+| JA-80/JA-100/JA-100F | lastEventTime    | the time of the last event                                |\n+| JA-80/JA-100/JA-100F | lastCheckTime    | the time of the last checking                             |\n+| JA-80/JA-100/JA-100F | alarm            | the alarm trigger, might fire ALARM or TAMPER events      |\n+| JA-100/JA-100F       | lastEventSection | the section of the last event                             |\n+| JA-100               | STATE_%nr%       | the section %nr% status/control                           |\n+| JA-100               | PGM_%nr%         | the PG section %nr% status/control                        |\n+| JA-100               | THERMOMETER_%nr% | the thermometer %nr% value                                |\n+| JA-100               | THERMOSTAT_%nr%  | the thermostat %nr% value                                 |\n+| JA-100F              | SEC-%nr%         | the section %nr% status/control                           |\n+| JA-100F              | PG-%nr%          | the PG section %nr% status/control                        |", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bb824dab23246fe665151e79780dc81f6fe4928f"}, "originalPosition": 58}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzQyMjUwMw==", "bodyText": "these dynamically created channels 1:1 match the internal alarm representation, which simplifies the overall binding functionality. Changing it is very dangerous since I cannot test it, I won't change these channel names.", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r487422503", "createdAt": "2020-09-12T15:53:25Z", "author": {"login": "octa22"}, "path": "bundles/org.openhab.binding.jablotron/README.md", "diffHunk": "@@ -0,0 +1,126 @@\n+# Jablotron Alarm Binding\n+\n+This is the binding for Jablotron alarms.\n+https://www.jablotron.com/en/jablotron-products/alarms/\n+\n+## Supported Things\n+\n+| thing   | note                                      |\n+|---------|-------------------------------------------|\n+| bridge  | the bridge to your Jablonet cloud account |\n+| JA-80   | the OASIS alarm                           |\n+| JA-100  | with the thermometer support              |\n+| JA-100F | without the thermometer support           |\n+ \n+## Discovery\n+\n+This binding supports auto discovery. Just manually add a bridge thing and supply login & password to your Jablonet account.\n+\n+## Binding Configuration\n+\n+Binding itself doesn't require specific configuration.\n+\n+## Thing Configuration\n+\n+| thing                | config parameter name | description                                                                        | type                  |\n+|----------------------|-----------------------|------------------------------------------------------------------------------------|-----------------------|\n+| bridge               | login                 | the login to your Jablonet account                                                 | mandatory             |\n+| bridge               | password              | the password to your Jablonet account                                              | mandatory             |\n+| bridge               | refresh               | the refresh time for all alarm warnings (ALARM, TAMPER triggers and SERVICE state) | optional, default=30s |\n+| bridge               | lang                  | the language of the alarm texts                                                    | optional, default=en  |\n+| JA-80/JA-100/JA-100F | refresh               | the channels refresh period in seconds                                             | optional, default=60s |\n+| JA-80/JA-100/JA-100F | serviceId             | the service ID which identifies the alarm                                          | mandatory             |\n+| JA-100/JA-100F       | code                  | the master code for controlling sections                                           | optional              |\n+\n+## Channels\n+\n+| thing                | channel name     | description                                               |\n+|----------------------|------------------|-----------------------------------------------------------|\n+| bridge               | N/A              | the bridge does not expose any channels                   |\n+| JA-80                | statusA          | the status of the A section                               |\n+| JA-80                | statusB          | the status of the AB/B section                            |\n+| JA-80                | statusABC        | the status of the ABC section                             |\n+| JA-80                | statusPGX        | the status of PGX                                         |\n+| JA-80                | statusPGY        | the status of PGY                                         |\n+| JA-80                | command          | the channel for sending keyboard codes to the OASIS alarm |\n+| JA-80/JA-100/JA-100F | lastEvent        | the text description of the last event                    |\n+| JA-80/JA-100/JA-100F | lastEventClass   | the class of the last event - e.g. arm, disarm, ...       |\n+| JA-80/JA-100/JA-100F | lastEventInvoker | the invoker of the last event                             |\n+| JA-80/JA-100/JA-100F | lastEventTime    | the time of the last event                                |\n+| JA-80/JA-100/JA-100F | lastCheckTime    | the time of the last checking                             |\n+| JA-80/JA-100/JA-100F | alarm            | the alarm trigger, might fire ALARM or TAMPER events      |\n+| JA-100/JA-100F       | lastEventSection | the section of the last event                             |\n+| JA-100               | STATE_%nr%       | the section %nr% status/control                           |\n+| JA-100               | PGM_%nr%         | the PG section %nr% status/control                        |\n+| JA-100               | THERMOMETER_%nr% | the thermometer %nr% value                                |\n+| JA-100               | THERMOSTAT_%nr%  | the thermostat %nr% value                                 |\n+| JA-100F              | SEC-%nr%         | the section %nr% status/control                           |\n+| JA-100F              | PG-%nr%          | the PG section %nr% status/control                        |", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzM5MDg2Nw=="}, "originalCommit": {"oid": "bb824dab23246fe665151e79780dc81f6fe4928f"}, "originalPosition": 58}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzQzMDY0Ng==", "bodyText": "I don't think it adds much complexity. Some .toLowerCase() should be sufficient.", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r487430646", "createdAt": "2020-09-12T17:27:35Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.jablotron/README.md", "diffHunk": "@@ -0,0 +1,126 @@\n+# Jablotron Alarm Binding\n+\n+This is the binding for Jablotron alarms.\n+https://www.jablotron.com/en/jablotron-products/alarms/\n+\n+## Supported Things\n+\n+| thing   | note                                      |\n+|---------|-------------------------------------------|\n+| bridge  | the bridge to your Jablonet cloud account |\n+| JA-80   | the OASIS alarm                           |\n+| JA-100  | with the thermometer support              |\n+| JA-100F | without the thermometer support           |\n+ \n+## Discovery\n+\n+This binding supports auto discovery. Just manually add a bridge thing and supply login & password to your Jablonet account.\n+\n+## Binding Configuration\n+\n+Binding itself doesn't require specific configuration.\n+\n+## Thing Configuration\n+\n+| thing                | config parameter name | description                                                                        | type                  |\n+|----------------------|-----------------------|------------------------------------------------------------------------------------|-----------------------|\n+| bridge               | login                 | the login to your Jablonet account                                                 | mandatory             |\n+| bridge               | password              | the password to your Jablonet account                                              | mandatory             |\n+| bridge               | refresh               | the refresh time for all alarm warnings (ALARM, TAMPER triggers and SERVICE state) | optional, default=30s |\n+| bridge               | lang                  | the language of the alarm texts                                                    | optional, default=en  |\n+| JA-80/JA-100/JA-100F | refresh               | the channels refresh period in seconds                                             | optional, default=60s |\n+| JA-80/JA-100/JA-100F | serviceId             | the service ID which identifies the alarm                                          | mandatory             |\n+| JA-100/JA-100F       | code                  | the master code for controlling sections                                           | optional              |\n+\n+## Channels\n+\n+| thing                | channel name     | description                                               |\n+|----------------------|------------------|-----------------------------------------------------------|\n+| bridge               | N/A              | the bridge does not expose any channels                   |\n+| JA-80                | statusA          | the status of the A section                               |\n+| JA-80                | statusB          | the status of the AB/B section                            |\n+| JA-80                | statusABC        | the status of the ABC section                             |\n+| JA-80                | statusPGX        | the status of PGX                                         |\n+| JA-80                | statusPGY        | the status of PGY                                         |\n+| JA-80                | command          | the channel for sending keyboard codes to the OASIS alarm |\n+| JA-80/JA-100/JA-100F | lastEvent        | the text description of the last event                    |\n+| JA-80/JA-100/JA-100F | lastEventClass   | the class of the last event - e.g. arm, disarm, ...       |\n+| JA-80/JA-100/JA-100F | lastEventInvoker | the invoker of the last event                             |\n+| JA-80/JA-100/JA-100F | lastEventTime    | the time of the last event                                |\n+| JA-80/JA-100/JA-100F | lastCheckTime    | the time of the last checking                             |\n+| JA-80/JA-100/JA-100F | alarm            | the alarm trigger, might fire ALARM or TAMPER events      |\n+| JA-100/JA-100F       | lastEventSection | the section of the last event                             |\n+| JA-100               | STATE_%nr%       | the section %nr% status/control                           |\n+| JA-100               | PGM_%nr%         | the PG section %nr% status/control                        |\n+| JA-100               | THERMOMETER_%nr% | the thermometer %nr% value                                |\n+| JA-100               | THERMOSTAT_%nr%  | the thermostat %nr% value                                 |\n+| JA-100F              | SEC-%nr%         | the section %nr% status/control                           |\n+| JA-100F              | PG-%nr%          | the PG section %nr% status/control                        |", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzM5MDg2Nw=="}, "originalCommit": {"oid": "bb824dab23246fe665151e79780dc81f6fe4928f"}, "originalPosition": 58}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzQ0MTg1NQ==", "bodyText": "not only .toLowerCase() unfortunately\nI changed it, but cannot test it because I do no have JA100/f", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r487441855", "createdAt": "2020-09-12T19:42:13Z", "author": {"login": "octa22"}, "path": "bundles/org.openhab.binding.jablotron/README.md", "diffHunk": "@@ -0,0 +1,126 @@\n+# Jablotron Alarm Binding\n+\n+This is the binding for Jablotron alarms.\n+https://www.jablotron.com/en/jablotron-products/alarms/\n+\n+## Supported Things\n+\n+| thing   | note                                      |\n+|---------|-------------------------------------------|\n+| bridge  | the bridge to your Jablonet cloud account |\n+| JA-80   | the OASIS alarm                           |\n+| JA-100  | with the thermometer support              |\n+| JA-100F | without the thermometer support           |\n+ \n+## Discovery\n+\n+This binding supports auto discovery. Just manually add a bridge thing and supply login & password to your Jablonet account.\n+\n+## Binding Configuration\n+\n+Binding itself doesn't require specific configuration.\n+\n+## Thing Configuration\n+\n+| thing                | config parameter name | description                                                                        | type                  |\n+|----------------------|-----------------------|------------------------------------------------------------------------------------|-----------------------|\n+| bridge               | login                 | the login to your Jablonet account                                                 | mandatory             |\n+| bridge               | password              | the password to your Jablonet account                                              | mandatory             |\n+| bridge               | refresh               | the refresh time for all alarm warnings (ALARM, TAMPER triggers and SERVICE state) | optional, default=30s |\n+| bridge               | lang                  | the language of the alarm texts                                                    | optional, default=en  |\n+| JA-80/JA-100/JA-100F | refresh               | the channels refresh period in seconds                                             | optional, default=60s |\n+| JA-80/JA-100/JA-100F | serviceId             | the service ID which identifies the alarm                                          | mandatory             |\n+| JA-100/JA-100F       | code                  | the master code for controlling sections                                           | optional              |\n+\n+## Channels\n+\n+| thing                | channel name     | description                                               |\n+|----------------------|------------------|-----------------------------------------------------------|\n+| bridge               | N/A              | the bridge does not expose any channels                   |\n+| JA-80                | statusA          | the status of the A section                               |\n+| JA-80                | statusB          | the status of the AB/B section                            |\n+| JA-80                | statusABC        | the status of the ABC section                             |\n+| JA-80                | statusPGX        | the status of PGX                                         |\n+| JA-80                | statusPGY        | the status of PGY                                         |\n+| JA-80                | command          | the channel for sending keyboard codes to the OASIS alarm |\n+| JA-80/JA-100/JA-100F | lastEvent        | the text description of the last event                    |\n+| JA-80/JA-100/JA-100F | lastEventClass   | the class of the last event - e.g. arm, disarm, ...       |\n+| JA-80/JA-100/JA-100F | lastEventInvoker | the invoker of the last event                             |\n+| JA-80/JA-100/JA-100F | lastEventTime    | the time of the last event                                |\n+| JA-80/JA-100/JA-100F | lastCheckTime    | the time of the last checking                             |\n+| JA-80/JA-100/JA-100F | alarm            | the alarm trigger, might fire ALARM or TAMPER events      |\n+| JA-100/JA-100F       | lastEventSection | the section of the last event                             |\n+| JA-100               | STATE_%nr%       | the section %nr% status/control                           |\n+| JA-100               | PGM_%nr%         | the PG section %nr% status/control                        |\n+| JA-100               | THERMOMETER_%nr% | the thermometer %nr% value                                |\n+| JA-100               | THERMOSTAT_%nr%  | the thermostat %nr% value                                 |\n+| JA-100F              | SEC-%nr%         | the section %nr% status/control                           |\n+| JA-100F              | PG-%nr%          | the PG section %nr% status/control                        |", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzM5MDg2Nw=="}, "originalCommit": {"oid": "bb824dab23246fe665151e79780dc81f6fe4928f"}, "originalPosition": 58}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA0ODg4MTk5OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.jablotron/src/main/java/org/openhab/binding/jablotron/internal/JablotronHandlerFactory.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMlQwOTo0NTo1MlrOHQ0B4A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMlQxNTo1NToyM1rOHQ161Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzM5MTcxMg==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            @Component(service = ThingHandlerFactory.class)\n          \n          \n            \n            @Component(configurationPid = \"binding.jablotron\", service = ThingHandlerFactory.class)", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r487391712", "createdAt": "2020-09-12T09:45:52Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.jablotron/src/main/java/org/openhab/binding/jablotron/internal/JablotronHandlerFactory.java", "diffHunk": "@@ -0,0 +1,71 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.jablotron.internal;\n+\n+import static org.openhab.binding.jablotron.JablotronBindingConstants.*;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandlerFactory;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerFactory;\n+import org.eclipse.smarthome.io.net.http.HttpClientFactory;\n+import org.openhab.binding.jablotron.internal.handler.JablotronBridgeHandler;\n+import org.openhab.binding.jablotron.internal.handler.JablotronJa100FHandler;\n+import org.openhab.binding.jablotron.internal.handler.JablotronJa100Handler;\n+import org.openhab.binding.jablotron.internal.handler.JablotronOasisHandler;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Reference;\n+\n+/**\n+ * The {@link JablotronHandlerFactory} is responsible for creating things and thing\n+ * handlers.\n+ *\n+ * @author Ondrej Pecta - Initial contribution\n+ */\n+@NonNullByDefault\n+@Component(service = ThingHandlerFactory.class)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bb824dab23246fe665151e79780dc81f6fe4928f"}, "originalPosition": 41}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzQyMjY3Nw==", "bodyText": "added the conf. pid", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r487422677", "createdAt": "2020-09-12T15:55:23Z", "author": {"login": "octa22"}, "path": "bundles/org.openhab.binding.jablotron/src/main/java/org/openhab/binding/jablotron/internal/JablotronHandlerFactory.java", "diffHunk": "@@ -0,0 +1,71 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.jablotron.internal;\n+\n+import static org.openhab.binding.jablotron.JablotronBindingConstants.*;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandlerFactory;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerFactory;\n+import org.eclipse.smarthome.io.net.http.HttpClientFactory;\n+import org.openhab.binding.jablotron.internal.handler.JablotronBridgeHandler;\n+import org.openhab.binding.jablotron.internal.handler.JablotronJa100FHandler;\n+import org.openhab.binding.jablotron.internal.handler.JablotronJa100Handler;\n+import org.openhab.binding.jablotron.internal.handler.JablotronOasisHandler;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Reference;\n+\n+/**\n+ * The {@link JablotronHandlerFactory} is responsible for creating things and thing\n+ * handlers.\n+ *\n+ * @author Ondrej Pecta - Initial contribution\n+ */\n+@NonNullByDefault\n+@Component(service = ThingHandlerFactory.class)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzM5MTcxMg=="}, "originalCommit": {"oid": "bb824dab23246fe665151e79780dc81f6fe4928f"}, "originalPosition": 41}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA0ODg4NjY0OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.jablotron/src/main/java/org/openhab/binding/jablotron/internal/handler/JablotronAlarmHandler.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMlQwOTo1Mjo0NFrOHQ0EEg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMlQxNTo0MzowOFrOHQ127A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzM5MjI3NA==", "bodyText": "Is is a retry code?", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r487392274", "createdAt": "2020-09-12T09:52:44Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.jablotron/src/main/java/org/openhab/binding/jablotron/internal/handler/JablotronAlarmHandler.java", "diffHunk": "@@ -0,0 +1,268 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.jablotron.internal.handler;\n+\n+import static org.openhab.binding.jablotron.JablotronBindingConstants.*;\n+\n+import java.time.Instant;\n+import java.time.ZoneId;\n+import java.time.ZonedDateTime;\n+import java.time.format.DateTimeFormatter;\n+import java.util.List;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.cache.ExpiringCache;\n+import org.eclipse.smarthome.core.library.types.DateTimeType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.*;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.jablotron.internal.config.JablotronDeviceConfig;\n+import org.openhab.binding.jablotron.internal.model.*;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+\n+/**\n+ * The {@link JablotronAlarmHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Ondrej Pecta - Initial contribution\n+ */\n+@NonNullByDefault\n+public abstract class JablotronAlarmHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(getClass());\n+\n+    protected final Gson gson = new Gson();\n+\n+    protected JablotronDeviceConfig thingConfig = new JablotronDeviceConfig();\n+\n+    private String lastWarningTime = \"\";\n+\n+    protected String alarmName = \"\";\n+\n+    private boolean inService = false;\n+\n+    protected @Nullable ScheduledFuture<?> future = null;\n+\n+    protected @Nullable ExpiringCache<JablotronDataUpdateResponse> dataCache;\n+    protected @Nullable ExpiringCache<List<JablotronHistoryDataEvent>> eventCache;\n+\n+    public JablotronAlarmHandler(Thing thing, String alarmName) {\n+        super(thing);\n+        this.alarmName = alarmName;\n+    }\n+\n+    @Override\n+    public void bridgeStatusChanged(ThingStatusInfo bridgeStatusInfo) {\n+        super.bridgeStatusChanged(bridgeStatusInfo);\n+        if (ThingStatus.UNINITIALIZED == bridgeStatusInfo.getStatus()) {\n+            cleanup();\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        super.dispose();\n+        cleanup();\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        thingConfig = getConfigAs(JablotronDeviceConfig.class);\n+        future = scheduler.scheduleWithFixedDelay(this::updateAlarmStatus, 1, thingConfig.getRefresh(),\n+                TimeUnit.SECONDS);\n+        updateStatus(ThingStatus.ONLINE);\n+    }\n+\n+    public boolean isInService() {\n+        return inService;\n+    }\n+\n+    public String getAlarmName() {\n+        return alarmName;\n+    }\n+\n+    protected abstract void updateSegmentStatus(JablotronServiceDetailSegment segment);\n+\n+    protected void updateSegmentStatus(String segmentName, @Nullable JablotronDataUpdateResponse dataUpdate) {\n+        if (dataUpdate == null || !dataUpdate.isStatus()) {\n+            return;\n+        }\n+        List<JablotronServiceData> serviceData = dataUpdate.getData().getServiceData();\n+        for (JablotronServiceData data : serviceData) {\n+            if (!thingConfig.getServiceId().equals(data.getServiceId())) {\n+                continue;\n+            }\n+            List<JablotronService> services = data.getData();\n+            for (JablotronService service : services) {\n+                JablotronServiceDetail detail = service.getData();\n+                for (JablotronServiceDetailSegment segment : detail.getSegments()) {\n+                    if (segmentName.equals(segment.getSegmentId())) {\n+                        updateSegmentStatus(segment);\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    private void cleanup() {\n+        logger.debug(\"doing cleanup...\");\n+        if (future != null) {\n+            future.cancel(true);\n+        }\n+    }\n+\n+    protected State getCheckTime() {\n+        ZonedDateTime zdt = ZonedDateTime.ofInstant(Instant.now(), ZoneId.systemDefault());\n+        return new DateTimeType(zdt);\n+    }\n+\n+    protected synchronized @Nullable JablotronDataUpdateResponse sendGetStatusRequest() {\n+        JablotronBridgeHandler handler = getBridgeHandler();\n+        if (handler != null) {\n+            return handler.sendGetStatusRequest(getThing());\n+        }\n+        return null;\n+    }\n+\n+    protected synchronized boolean updateAlarmStatus() {\n+        JablotronDataUpdateResponse dataUpdate = sendGetStatusRequest();\n+        if (dataUpdate == null) {\n+            return false;\n+        }\n+\n+        if (dataUpdate.isStatus()) {\n+            updateState(CHANNEL_LAST_CHECK_TIME, getCheckTime());\n+            List<JablotronServiceData> serviceData = dataUpdate.getData().getServiceData();\n+            for (JablotronServiceData data : serviceData) {\n+                if (!thingConfig.getServiceId().equals(data.getServiceId())) {\n+                    continue;\n+                }\n+                List<JablotronService> services = data.getData();\n+                for (JablotronService service : services) {\n+                    JablotronServiceDetail detail = service.getData();\n+                    for (JablotronServiceDetailSegment segment : detail.getSegments()) {\n+                        updateSegmentStatus(segment);\n+                    }\n+                }\n+\n+            }\n+        } else {\n+            logger.debug(\"Error during alarm status update: {}\", dataUpdate.getErrorMessage());\n+        }\n+\n+        List<JablotronHistoryDataEvent> events = sendGetEventHistory();\n+        if (events != null && events.size() > 0) {\n+            JablotronHistoryDataEvent event = events.get(0);\n+            updateLastEvent(event);\n+        }\n+\n+        return true;\n+    }\n+\n+    protected @Nullable List<JablotronHistoryDataEvent> sendGetEventHistory() {\n+        return sendGetEventHistory(alarmName);\n+    }\n+\n+    private @Nullable List<JablotronHistoryDataEvent> sendGetEventHistory(String alarm) {\n+        JablotronBridgeHandler handler = getBridgeHandler();\n+        if (handler != null) {\n+            return handler.sendGetEventHistory(getThing(), alarm);\n+        }\n+        return null;\n+    }\n+\n+    protected void updateLastEvent(JablotronHistoryDataEvent event) {\n+        updateState(CHANNEL_LAST_EVENT_TIME, new DateTimeType(getZonedDateTime(event.getDate())));\n+        updateState(CHANNEL_LAST_EVENT, new StringType(event.getEventText()));\n+        updateState(CHANNEL_LAST_EVENT_CLASS, new StringType(event.getIconType()));\n+        updateState(CHANNEL_LAST_EVENT_INVOKER, new StringType(event.getInvokerName()));\n+\n+        // oasis does not have sections\n+        if (getThing().getChannel(CHANNEL_LAST_EVENT_SECTION) != null) {\n+            updateState(CHANNEL_LAST_EVENT_SECTION, new StringType(event.getSectionName()));\n+        }\n+    }\n+\n+    protected void updateEventChannel(String channel) {\n+        List<JablotronHistoryDataEvent> events = eventCache != null ? eventCache.getValue() : null;\n+        if (events != null && events.size() > 0) {\n+            JablotronHistoryDataEvent event = events.get(0);\n+            switch (channel) {\n+                case CHANNEL_LAST_EVENT_TIME:\n+                    updateState(CHANNEL_LAST_EVENT_TIME, new DateTimeType(getZonedDateTime(event.getDate())));\n+                    break;\n+                case CHANNEL_LAST_EVENT:\n+                    updateState(CHANNEL_LAST_EVENT, new StringType(event.getEventText()));\n+                    break;\n+                case CHANNEL_LAST_EVENT_CLASS:\n+                    updateState(CHANNEL_LAST_EVENT_CLASS, new StringType(event.getIconType()));\n+                    break;\n+                case CHANNEL_LAST_EVENT_INVOKER:\n+                    updateState(CHANNEL_LAST_EVENT_INVOKER, new StringType(event.getInvokerName()));\n+                    break;\n+                case CHANNEL_LAST_EVENT_SECTION:\n+                    updateState(CHANNEL_LAST_EVENT_SECTION, new StringType(event.getSectionName()));\n+                    break;\n+            }\n+        }\n+    }\n+\n+    public ZonedDateTime getZonedDateTime(String date) {\n+        return ZonedDateTime.parse(date.substring(0, 22) + \":\" + date.substring(22, 24),\n+                DateTimeFormatter.ISO_DATE_TIME);\n+    }\n+\n+    protected @Nullable JablotronControlResponse sendUserCode(String section, String key, String status, String code) {\n+        JablotronControlResponse response = null;\n+        JablotronBridgeHandler handler = getBridgeHandler();\n+        if (handler != null) {\n+            try {\n+                response = handler.sendUserCode(getThing(), section, key, status, code);\n+            } catch (SecurityException se) {\n+                response = handler.sendUserCode(getThing(), section, key, status, code);\n+            }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bb824dab23246fe665151e79780dc81f6fe4928f"}, "originalPosition": 240}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzQyMTY3Ng==", "bodyText": "old retry code, removed", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r487421676", "createdAt": "2020-09-12T15:43:08Z", "author": {"login": "octa22"}, "path": "bundles/org.openhab.binding.jablotron/src/main/java/org/openhab/binding/jablotron/internal/handler/JablotronAlarmHandler.java", "diffHunk": "@@ -0,0 +1,268 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.jablotron.internal.handler;\n+\n+import static org.openhab.binding.jablotron.JablotronBindingConstants.*;\n+\n+import java.time.Instant;\n+import java.time.ZoneId;\n+import java.time.ZonedDateTime;\n+import java.time.format.DateTimeFormatter;\n+import java.util.List;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.cache.ExpiringCache;\n+import org.eclipse.smarthome.core.library.types.DateTimeType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.*;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.jablotron.internal.config.JablotronDeviceConfig;\n+import org.openhab.binding.jablotron.internal.model.*;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+\n+/**\n+ * The {@link JablotronAlarmHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Ondrej Pecta - Initial contribution\n+ */\n+@NonNullByDefault\n+public abstract class JablotronAlarmHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(getClass());\n+\n+    protected final Gson gson = new Gson();\n+\n+    protected JablotronDeviceConfig thingConfig = new JablotronDeviceConfig();\n+\n+    private String lastWarningTime = \"\";\n+\n+    protected String alarmName = \"\";\n+\n+    private boolean inService = false;\n+\n+    protected @Nullable ScheduledFuture<?> future = null;\n+\n+    protected @Nullable ExpiringCache<JablotronDataUpdateResponse> dataCache;\n+    protected @Nullable ExpiringCache<List<JablotronHistoryDataEvent>> eventCache;\n+\n+    public JablotronAlarmHandler(Thing thing, String alarmName) {\n+        super(thing);\n+        this.alarmName = alarmName;\n+    }\n+\n+    @Override\n+    public void bridgeStatusChanged(ThingStatusInfo bridgeStatusInfo) {\n+        super.bridgeStatusChanged(bridgeStatusInfo);\n+        if (ThingStatus.UNINITIALIZED == bridgeStatusInfo.getStatus()) {\n+            cleanup();\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        super.dispose();\n+        cleanup();\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        thingConfig = getConfigAs(JablotronDeviceConfig.class);\n+        future = scheduler.scheduleWithFixedDelay(this::updateAlarmStatus, 1, thingConfig.getRefresh(),\n+                TimeUnit.SECONDS);\n+        updateStatus(ThingStatus.ONLINE);\n+    }\n+\n+    public boolean isInService() {\n+        return inService;\n+    }\n+\n+    public String getAlarmName() {\n+        return alarmName;\n+    }\n+\n+    protected abstract void updateSegmentStatus(JablotronServiceDetailSegment segment);\n+\n+    protected void updateSegmentStatus(String segmentName, @Nullable JablotronDataUpdateResponse dataUpdate) {\n+        if (dataUpdate == null || !dataUpdate.isStatus()) {\n+            return;\n+        }\n+        List<JablotronServiceData> serviceData = dataUpdate.getData().getServiceData();\n+        for (JablotronServiceData data : serviceData) {\n+            if (!thingConfig.getServiceId().equals(data.getServiceId())) {\n+                continue;\n+            }\n+            List<JablotronService> services = data.getData();\n+            for (JablotronService service : services) {\n+                JablotronServiceDetail detail = service.getData();\n+                for (JablotronServiceDetailSegment segment : detail.getSegments()) {\n+                    if (segmentName.equals(segment.getSegmentId())) {\n+                        updateSegmentStatus(segment);\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    private void cleanup() {\n+        logger.debug(\"doing cleanup...\");\n+        if (future != null) {\n+            future.cancel(true);\n+        }\n+    }\n+\n+    protected State getCheckTime() {\n+        ZonedDateTime zdt = ZonedDateTime.ofInstant(Instant.now(), ZoneId.systemDefault());\n+        return new DateTimeType(zdt);\n+    }\n+\n+    protected synchronized @Nullable JablotronDataUpdateResponse sendGetStatusRequest() {\n+        JablotronBridgeHandler handler = getBridgeHandler();\n+        if (handler != null) {\n+            return handler.sendGetStatusRequest(getThing());\n+        }\n+        return null;\n+    }\n+\n+    protected synchronized boolean updateAlarmStatus() {\n+        JablotronDataUpdateResponse dataUpdate = sendGetStatusRequest();\n+        if (dataUpdate == null) {\n+            return false;\n+        }\n+\n+        if (dataUpdate.isStatus()) {\n+            updateState(CHANNEL_LAST_CHECK_TIME, getCheckTime());\n+            List<JablotronServiceData> serviceData = dataUpdate.getData().getServiceData();\n+            for (JablotronServiceData data : serviceData) {\n+                if (!thingConfig.getServiceId().equals(data.getServiceId())) {\n+                    continue;\n+                }\n+                List<JablotronService> services = data.getData();\n+                for (JablotronService service : services) {\n+                    JablotronServiceDetail detail = service.getData();\n+                    for (JablotronServiceDetailSegment segment : detail.getSegments()) {\n+                        updateSegmentStatus(segment);\n+                    }\n+                }\n+\n+            }\n+        } else {\n+            logger.debug(\"Error during alarm status update: {}\", dataUpdate.getErrorMessage());\n+        }\n+\n+        List<JablotronHistoryDataEvent> events = sendGetEventHistory();\n+        if (events != null && events.size() > 0) {\n+            JablotronHistoryDataEvent event = events.get(0);\n+            updateLastEvent(event);\n+        }\n+\n+        return true;\n+    }\n+\n+    protected @Nullable List<JablotronHistoryDataEvent> sendGetEventHistory() {\n+        return sendGetEventHistory(alarmName);\n+    }\n+\n+    private @Nullable List<JablotronHistoryDataEvent> sendGetEventHistory(String alarm) {\n+        JablotronBridgeHandler handler = getBridgeHandler();\n+        if (handler != null) {\n+            return handler.sendGetEventHistory(getThing(), alarm);\n+        }\n+        return null;\n+    }\n+\n+    protected void updateLastEvent(JablotronHistoryDataEvent event) {\n+        updateState(CHANNEL_LAST_EVENT_TIME, new DateTimeType(getZonedDateTime(event.getDate())));\n+        updateState(CHANNEL_LAST_EVENT, new StringType(event.getEventText()));\n+        updateState(CHANNEL_LAST_EVENT_CLASS, new StringType(event.getIconType()));\n+        updateState(CHANNEL_LAST_EVENT_INVOKER, new StringType(event.getInvokerName()));\n+\n+        // oasis does not have sections\n+        if (getThing().getChannel(CHANNEL_LAST_EVENT_SECTION) != null) {\n+            updateState(CHANNEL_LAST_EVENT_SECTION, new StringType(event.getSectionName()));\n+        }\n+    }\n+\n+    protected void updateEventChannel(String channel) {\n+        List<JablotronHistoryDataEvent> events = eventCache != null ? eventCache.getValue() : null;\n+        if (events != null && events.size() > 0) {\n+            JablotronHistoryDataEvent event = events.get(0);\n+            switch (channel) {\n+                case CHANNEL_LAST_EVENT_TIME:\n+                    updateState(CHANNEL_LAST_EVENT_TIME, new DateTimeType(getZonedDateTime(event.getDate())));\n+                    break;\n+                case CHANNEL_LAST_EVENT:\n+                    updateState(CHANNEL_LAST_EVENT, new StringType(event.getEventText()));\n+                    break;\n+                case CHANNEL_LAST_EVENT_CLASS:\n+                    updateState(CHANNEL_LAST_EVENT_CLASS, new StringType(event.getIconType()));\n+                    break;\n+                case CHANNEL_LAST_EVENT_INVOKER:\n+                    updateState(CHANNEL_LAST_EVENT_INVOKER, new StringType(event.getInvokerName()));\n+                    break;\n+                case CHANNEL_LAST_EVENT_SECTION:\n+                    updateState(CHANNEL_LAST_EVENT_SECTION, new StringType(event.getSectionName()));\n+                    break;\n+            }\n+        }\n+    }\n+\n+    public ZonedDateTime getZonedDateTime(String date) {\n+        return ZonedDateTime.parse(date.substring(0, 22) + \":\" + date.substring(22, 24),\n+                DateTimeFormatter.ISO_DATE_TIME);\n+    }\n+\n+    protected @Nullable JablotronControlResponse sendUserCode(String section, String key, String status, String code) {\n+        JablotronControlResponse response = null;\n+        JablotronBridgeHandler handler = getBridgeHandler();\n+        if (handler != null) {\n+            try {\n+                response = handler.sendUserCode(getThing(), section, key, status, code);\n+            } catch (SecurityException se) {\n+                response = handler.sendUserCode(getThing(), section, key, status, code);\n+            }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzM5MjI3NA=="}, "originalCommit": {"oid": "bb824dab23246fe665151e79780dc81f6fe4928f"}, "originalPosition": 240}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA0ODg4Nzg3OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.jablotron/src/main/java/org/openhab/binding/jablotron/internal/handler/JablotronBridgeHandler.java", "isResolved": true, "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMlQwOTo1NDozN1rOHQ0EpQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xM1QxMDo1NToxM1rOHQ7f_w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzM5MjQyMQ==", "bodyText": "But these are redundant.", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r487392421", "createdAt": "2020-09-12T09:54:37Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.jablotron/src/main/java/org/openhab/binding/jablotron/internal/handler/JablotronBridgeHandler.java", "diffHunk": "@@ -0,0 +1,370 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.jablotron.internal.handler;\n+\n+import static org.openhab.binding.jablotron.JablotronBindingConstants.*;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.eclipse.jetty.http.HttpHeader;\n+import org.eclipse.jetty.http.HttpMethod;\n+import org.eclipse.smarthome.core.thing.*;\n+import org.eclipse.smarthome.core.thing.binding.BaseBridgeHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.openhab.binding.jablotron.internal.config.JablotronBridgeConfig;\n+import org.openhab.binding.jablotron.internal.discovery.JablotronDiscoveryService;\n+import org.openhab.binding.jablotron.internal.model.*;\n+import org.openhab.binding.jablotron.internal.model.ja100f.JablotronGetPGResponse;\n+import org.openhab.binding.jablotron.internal.model.ja100f.JablotronGetSectionsResponse;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.JsonSyntaxException;\n+\n+/**\n+ * The {@link JablotronBridgeHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Ondrej Pecta - Initial contribution\n+ */\n+@NonNullByDefault\n+public class JablotronBridgeHandler extends BaseBridgeHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(JablotronBridgeHandler.class);\n+\n+    private final Gson gson = new Gson();\n+\n+    final HttpClient httpClient;\n+\n+    private @Nullable ScheduledFuture<?> future = null;\n+\n+    /**\n+     * Our configuration\n+     */\n+    public JablotronBridgeConfig bridgeConfig = new JablotronBridgeConfig();\n+\n+    public JablotronBridgeHandler(Bridge thing, HttpClient httpClient) {\n+        super(thing);\n+        this.httpClient = httpClient;\n+    }\n+\n+    @Override\n+    public Collection<Class<? extends ThingHandlerService>> getServices() {\n+        return Collections.singleton(JablotronDiscoveryService.class);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        bridgeConfig = getConfigAs(JablotronBridgeConfig.class);\n+        scheduler.execute(this::login);\n+        future = scheduler.scheduleWithFixedDelay(this::updateAlarmThings, 30, bridgeConfig.getRefresh(),\n+                TimeUnit.SECONDS);\n+    }\n+\n+    private void updateAlarmThings() {\n+        @Nullable\n+        List<JablotronDiscoveredService> services = discoverServices();\n+        if (services != null) {\n+            for (JablotronDiscoveredService service : services) {\n+                updateAlarmThing(service);\n+            }\n+        }\n+    }\n+\n+    private void updateAlarmThing(JablotronDiscoveredService service) {\n+        for (Thing th : getThing().getThings()) {\n+            JablotronAlarmHandler handler = (JablotronAlarmHandler) th.getHandler();\n+\n+            if (handler == null) {\n+                logger.debug(\"Thing handler is null\");\n+                continue;\n+            }\n+\n+            if (String.valueOf(service.getId()).equals(handler.thingConfig.getServiceId())) {\n+                if (\"ENABLED\".equals(service.getStatus())) {\n+                    if (!service.getWarning().isEmpty()) {\n+                        logger.debug(\"Alarm with service id: {} warning: {}\", service.getId(), service.getWarning());\n+                    }\n+                    handler.setStatus(ThingStatus.ONLINE, ThingStatusDetail.NONE, service.getWarning());\n+                    if (\"ALARM\".equals(service.getWarning()) || \"TAMPER\".equals(service.getWarning())) {\n+                        handler.triggerAlarm(service);\n+                    }\n+                    handler.setInService(\"SERVICE\".equals(service.getWarning()));\n+                } else {\n+                    logger.debug(\"Alarm with service id: {} is offline\", service.getId());\n+                    handler.setStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, service.getStatus());\n+                }\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        super.dispose();\n+        if (future != null) {\n+            future.cancel(true);\n+        }\n+        logout();\n+    }\n+\n+    private @Nullable <T> T sendJsonMessage(String url, String urlParameters, Class<T> classOfT) {\n+        return sendMessage(url, urlParameters, classOfT, APPLICATION_JSON, true);\n+    }\n+\n+    private @Nullable <T> T sendJsonMessage(String url, String urlParameters, Class<T> classOfT, boolean relogin) {\n+        return sendMessage(url, urlParameters, classOfT, APPLICATION_JSON, relogin);\n+    }\n+\n+    private @Nullable <T> T sendUrlEncodedMessage(String url, String urlParameters, Class<T> classOfT) {\n+        return sendMessage(url, urlParameters, classOfT, WWW_FORM_URLENCODED, true);\n+    }\n+\n+    private @Nullable <T> T sendMessage(String url, String urlParameters, Class<T> classOfT, String encoding,\n+            boolean relogin) {\n+        try {\n+            ContentResponse resp = createRequest(url).content(new StringContentProvider(urlParameters), encoding)\n+                    .send();\n+\n+            logger.trace(\"Request: {} with data: {}\", url, urlParameters);\n+            String line = resp.getContentAsString();\n+            logger.trace(\"Response: {}\", line);\n+            return gson.fromJson(line, classOfT);\n+        } catch (TimeoutException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                    \"Timeout during calling url: \" + url);\n+        } catch (InterruptedException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                    \"Interrupt during calling url: \" + url);\n+            Thread.currentThread().interrupt();\n+        } catch (JsonSyntaxException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                    \"Syntax error during calling url: \" + url);\n+        } catch (ExecutionException e) {\n+            if (relogin) {\n+                if (e.getMessage().contains(AUTHENTICATION_CHALLENGE)) {\n+                    relogin();\n+                    return null;\n+                }\n+            }\n+            logger.debug(\"Error during calling url: {}\", url, e);\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                    \"Error during calling url: \" + url);\n+        }\n+        return null;\n+    }\n+\n+    protected synchronized void login() {\n+        String url = JABLOTRON_API_URL + \"userAuthorize.json\";\n+        String urlParameters = \"{\\\"login\\\":\\\"\" + bridgeConfig.getLogin() + \"\\\", \\\"password\\\":\\\"\"\n+                + bridgeConfig.getPassword() + \"\\\"}\";\n+        JablotronLoginResponse response = sendJsonMessage(url, urlParameters, JablotronLoginResponse.class, false);\n+\n+        if (response == null) {\n+            return;\n+        }\n+\n+        if (response.getHttpCode() != 200) {\n+            logger.debug(\"Error during login, got http error: {}\", response.getHttpCode());\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                    \"Http error: \" + response.getHttpCode());\n+        } else {\n+            logger.debug(\"Successfully logged in\");\n+            updateStatus(ThingStatus.ONLINE);\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bb824dab23246fe665151e79780dc81f6fe4928f"}, "originalPosition": 201}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzQyMjg4NQ==", "bodyText": "I don't think so, I need the 200 error code to be sure everyting is ok", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r487422885", "createdAt": "2020-09-12T15:58:06Z", "author": {"login": "octa22"}, "path": "bundles/org.openhab.binding.jablotron/src/main/java/org/openhab/binding/jablotron/internal/handler/JablotronBridgeHandler.java", "diffHunk": "@@ -0,0 +1,370 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.jablotron.internal.handler;\n+\n+import static org.openhab.binding.jablotron.JablotronBindingConstants.*;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.eclipse.jetty.http.HttpHeader;\n+import org.eclipse.jetty.http.HttpMethod;\n+import org.eclipse.smarthome.core.thing.*;\n+import org.eclipse.smarthome.core.thing.binding.BaseBridgeHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.openhab.binding.jablotron.internal.config.JablotronBridgeConfig;\n+import org.openhab.binding.jablotron.internal.discovery.JablotronDiscoveryService;\n+import org.openhab.binding.jablotron.internal.model.*;\n+import org.openhab.binding.jablotron.internal.model.ja100f.JablotronGetPGResponse;\n+import org.openhab.binding.jablotron.internal.model.ja100f.JablotronGetSectionsResponse;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.JsonSyntaxException;\n+\n+/**\n+ * The {@link JablotronBridgeHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Ondrej Pecta - Initial contribution\n+ */\n+@NonNullByDefault\n+public class JablotronBridgeHandler extends BaseBridgeHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(JablotronBridgeHandler.class);\n+\n+    private final Gson gson = new Gson();\n+\n+    final HttpClient httpClient;\n+\n+    private @Nullable ScheduledFuture<?> future = null;\n+\n+    /**\n+     * Our configuration\n+     */\n+    public JablotronBridgeConfig bridgeConfig = new JablotronBridgeConfig();\n+\n+    public JablotronBridgeHandler(Bridge thing, HttpClient httpClient) {\n+        super(thing);\n+        this.httpClient = httpClient;\n+    }\n+\n+    @Override\n+    public Collection<Class<? extends ThingHandlerService>> getServices() {\n+        return Collections.singleton(JablotronDiscoveryService.class);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        bridgeConfig = getConfigAs(JablotronBridgeConfig.class);\n+        scheduler.execute(this::login);\n+        future = scheduler.scheduleWithFixedDelay(this::updateAlarmThings, 30, bridgeConfig.getRefresh(),\n+                TimeUnit.SECONDS);\n+    }\n+\n+    private void updateAlarmThings() {\n+        @Nullable\n+        List<JablotronDiscoveredService> services = discoverServices();\n+        if (services != null) {\n+            for (JablotronDiscoveredService service : services) {\n+                updateAlarmThing(service);\n+            }\n+        }\n+    }\n+\n+    private void updateAlarmThing(JablotronDiscoveredService service) {\n+        for (Thing th : getThing().getThings()) {\n+            JablotronAlarmHandler handler = (JablotronAlarmHandler) th.getHandler();\n+\n+            if (handler == null) {\n+                logger.debug(\"Thing handler is null\");\n+                continue;\n+            }\n+\n+            if (String.valueOf(service.getId()).equals(handler.thingConfig.getServiceId())) {\n+                if (\"ENABLED\".equals(service.getStatus())) {\n+                    if (!service.getWarning().isEmpty()) {\n+                        logger.debug(\"Alarm with service id: {} warning: {}\", service.getId(), service.getWarning());\n+                    }\n+                    handler.setStatus(ThingStatus.ONLINE, ThingStatusDetail.NONE, service.getWarning());\n+                    if (\"ALARM\".equals(service.getWarning()) || \"TAMPER\".equals(service.getWarning())) {\n+                        handler.triggerAlarm(service);\n+                    }\n+                    handler.setInService(\"SERVICE\".equals(service.getWarning()));\n+                } else {\n+                    logger.debug(\"Alarm with service id: {} is offline\", service.getId());\n+                    handler.setStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, service.getStatus());\n+                }\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        super.dispose();\n+        if (future != null) {\n+            future.cancel(true);\n+        }\n+        logout();\n+    }\n+\n+    private @Nullable <T> T sendJsonMessage(String url, String urlParameters, Class<T> classOfT) {\n+        return sendMessage(url, urlParameters, classOfT, APPLICATION_JSON, true);\n+    }\n+\n+    private @Nullable <T> T sendJsonMessage(String url, String urlParameters, Class<T> classOfT, boolean relogin) {\n+        return sendMessage(url, urlParameters, classOfT, APPLICATION_JSON, relogin);\n+    }\n+\n+    private @Nullable <T> T sendUrlEncodedMessage(String url, String urlParameters, Class<T> classOfT) {\n+        return sendMessage(url, urlParameters, classOfT, WWW_FORM_URLENCODED, true);\n+    }\n+\n+    private @Nullable <T> T sendMessage(String url, String urlParameters, Class<T> classOfT, String encoding,\n+            boolean relogin) {\n+        try {\n+            ContentResponse resp = createRequest(url).content(new StringContentProvider(urlParameters), encoding)\n+                    .send();\n+\n+            logger.trace(\"Request: {} with data: {}\", url, urlParameters);\n+            String line = resp.getContentAsString();\n+            logger.trace(\"Response: {}\", line);\n+            return gson.fromJson(line, classOfT);\n+        } catch (TimeoutException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                    \"Timeout during calling url: \" + url);\n+        } catch (InterruptedException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                    \"Interrupt during calling url: \" + url);\n+            Thread.currentThread().interrupt();\n+        } catch (JsonSyntaxException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                    \"Syntax error during calling url: \" + url);\n+        } catch (ExecutionException e) {\n+            if (relogin) {\n+                if (e.getMessage().contains(AUTHENTICATION_CHALLENGE)) {\n+                    relogin();\n+                    return null;\n+                }\n+            }\n+            logger.debug(\"Error during calling url: {}\", url, e);\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                    \"Error during calling url: \" + url);\n+        }\n+        return null;\n+    }\n+\n+    protected synchronized void login() {\n+        String url = JABLOTRON_API_URL + \"userAuthorize.json\";\n+        String urlParameters = \"{\\\"login\\\":\\\"\" + bridgeConfig.getLogin() + \"\\\", \\\"password\\\":\\\"\"\n+                + bridgeConfig.getPassword() + \"\\\"}\";\n+        JablotronLoginResponse response = sendJsonMessage(url, urlParameters, JablotronLoginResponse.class, false);\n+\n+        if (response == null) {\n+            return;\n+        }\n+\n+        if (response.getHttpCode() != 200) {\n+            logger.debug(\"Error during login, got http error: {}\", response.getHttpCode());\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                    \"Http error: \" + response.getHttpCode());\n+        } else {\n+            logger.debug(\"Successfully logged in\");\n+            updateStatus(ThingStatus.ONLINE);\n+        }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzM5MjQyMQ=="}, "originalCommit": {"oid": "bb824dab23246fe665151e79780dc81f6fe4928f"}, "originalPosition": 201}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzQzMDQzNQ==", "bodyText": "I meant only the logger lines 195 and 199. Updating the Thing state is fine.", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r487430435", "createdAt": "2020-09-12T17:25:10Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.jablotron/src/main/java/org/openhab/binding/jablotron/internal/handler/JablotronBridgeHandler.java", "diffHunk": "@@ -0,0 +1,370 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.jablotron.internal.handler;\n+\n+import static org.openhab.binding.jablotron.JablotronBindingConstants.*;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.eclipse.jetty.http.HttpHeader;\n+import org.eclipse.jetty.http.HttpMethod;\n+import org.eclipse.smarthome.core.thing.*;\n+import org.eclipse.smarthome.core.thing.binding.BaseBridgeHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.openhab.binding.jablotron.internal.config.JablotronBridgeConfig;\n+import org.openhab.binding.jablotron.internal.discovery.JablotronDiscoveryService;\n+import org.openhab.binding.jablotron.internal.model.*;\n+import org.openhab.binding.jablotron.internal.model.ja100f.JablotronGetPGResponse;\n+import org.openhab.binding.jablotron.internal.model.ja100f.JablotronGetSectionsResponse;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.JsonSyntaxException;\n+\n+/**\n+ * The {@link JablotronBridgeHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Ondrej Pecta - Initial contribution\n+ */\n+@NonNullByDefault\n+public class JablotronBridgeHandler extends BaseBridgeHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(JablotronBridgeHandler.class);\n+\n+    private final Gson gson = new Gson();\n+\n+    final HttpClient httpClient;\n+\n+    private @Nullable ScheduledFuture<?> future = null;\n+\n+    /**\n+     * Our configuration\n+     */\n+    public JablotronBridgeConfig bridgeConfig = new JablotronBridgeConfig();\n+\n+    public JablotronBridgeHandler(Bridge thing, HttpClient httpClient) {\n+        super(thing);\n+        this.httpClient = httpClient;\n+    }\n+\n+    @Override\n+    public Collection<Class<? extends ThingHandlerService>> getServices() {\n+        return Collections.singleton(JablotronDiscoveryService.class);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        bridgeConfig = getConfigAs(JablotronBridgeConfig.class);\n+        scheduler.execute(this::login);\n+        future = scheduler.scheduleWithFixedDelay(this::updateAlarmThings, 30, bridgeConfig.getRefresh(),\n+                TimeUnit.SECONDS);\n+    }\n+\n+    private void updateAlarmThings() {\n+        @Nullable\n+        List<JablotronDiscoveredService> services = discoverServices();\n+        if (services != null) {\n+            for (JablotronDiscoveredService service : services) {\n+                updateAlarmThing(service);\n+            }\n+        }\n+    }\n+\n+    private void updateAlarmThing(JablotronDiscoveredService service) {\n+        for (Thing th : getThing().getThings()) {\n+            JablotronAlarmHandler handler = (JablotronAlarmHandler) th.getHandler();\n+\n+            if (handler == null) {\n+                logger.debug(\"Thing handler is null\");\n+                continue;\n+            }\n+\n+            if (String.valueOf(service.getId()).equals(handler.thingConfig.getServiceId())) {\n+                if (\"ENABLED\".equals(service.getStatus())) {\n+                    if (!service.getWarning().isEmpty()) {\n+                        logger.debug(\"Alarm with service id: {} warning: {}\", service.getId(), service.getWarning());\n+                    }\n+                    handler.setStatus(ThingStatus.ONLINE, ThingStatusDetail.NONE, service.getWarning());\n+                    if (\"ALARM\".equals(service.getWarning()) || \"TAMPER\".equals(service.getWarning())) {\n+                        handler.triggerAlarm(service);\n+                    }\n+                    handler.setInService(\"SERVICE\".equals(service.getWarning()));\n+                } else {\n+                    logger.debug(\"Alarm with service id: {} is offline\", service.getId());\n+                    handler.setStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, service.getStatus());\n+                }\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        super.dispose();\n+        if (future != null) {\n+            future.cancel(true);\n+        }\n+        logout();\n+    }\n+\n+    private @Nullable <T> T sendJsonMessage(String url, String urlParameters, Class<T> classOfT) {\n+        return sendMessage(url, urlParameters, classOfT, APPLICATION_JSON, true);\n+    }\n+\n+    private @Nullable <T> T sendJsonMessage(String url, String urlParameters, Class<T> classOfT, boolean relogin) {\n+        return sendMessage(url, urlParameters, classOfT, APPLICATION_JSON, relogin);\n+    }\n+\n+    private @Nullable <T> T sendUrlEncodedMessage(String url, String urlParameters, Class<T> classOfT) {\n+        return sendMessage(url, urlParameters, classOfT, WWW_FORM_URLENCODED, true);\n+    }\n+\n+    private @Nullable <T> T sendMessage(String url, String urlParameters, Class<T> classOfT, String encoding,\n+            boolean relogin) {\n+        try {\n+            ContentResponse resp = createRequest(url).content(new StringContentProvider(urlParameters), encoding)\n+                    .send();\n+\n+            logger.trace(\"Request: {} with data: {}\", url, urlParameters);\n+            String line = resp.getContentAsString();\n+            logger.trace(\"Response: {}\", line);\n+            return gson.fromJson(line, classOfT);\n+        } catch (TimeoutException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                    \"Timeout during calling url: \" + url);\n+        } catch (InterruptedException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                    \"Interrupt during calling url: \" + url);\n+            Thread.currentThread().interrupt();\n+        } catch (JsonSyntaxException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                    \"Syntax error during calling url: \" + url);\n+        } catch (ExecutionException e) {\n+            if (relogin) {\n+                if (e.getMessage().contains(AUTHENTICATION_CHALLENGE)) {\n+                    relogin();\n+                    return null;\n+                }\n+            }\n+            logger.debug(\"Error during calling url: {}\", url, e);\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                    \"Error during calling url: \" + url);\n+        }\n+        return null;\n+    }\n+\n+    protected synchronized void login() {\n+        String url = JABLOTRON_API_URL + \"userAuthorize.json\";\n+        String urlParameters = \"{\\\"login\\\":\\\"\" + bridgeConfig.getLogin() + \"\\\", \\\"password\\\":\\\"\"\n+                + bridgeConfig.getPassword() + \"\\\"}\";\n+        JablotronLoginResponse response = sendJsonMessage(url, urlParameters, JablotronLoginResponse.class, false);\n+\n+        if (response == null) {\n+            return;\n+        }\n+\n+        if (response.getHttpCode() != 200) {\n+            logger.debug(\"Error during login, got http error: {}\", response.getHttpCode());\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                    \"Http error: \" + response.getHttpCode());\n+        } else {\n+            logger.debug(\"Successfully logged in\");\n+            updateStatus(ThingStatus.ONLINE);\n+        }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzM5MjQyMQ=="}, "originalCommit": {"oid": "bb824dab23246fe665151e79780dc81f6fe4928f"}, "originalPosition": 201}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzQzOTM5Mw==", "bodyText": "Still it is useful to have this information if you tail the openhab.log. Their API is very unreliable and this helps me to quickly see what happened during login", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r487439393", "createdAt": "2020-09-12T19:13:09Z", "author": {"login": "octa22"}, "path": "bundles/org.openhab.binding.jablotron/src/main/java/org/openhab/binding/jablotron/internal/handler/JablotronBridgeHandler.java", "diffHunk": "@@ -0,0 +1,370 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.jablotron.internal.handler;\n+\n+import static org.openhab.binding.jablotron.JablotronBindingConstants.*;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.eclipse.jetty.http.HttpHeader;\n+import org.eclipse.jetty.http.HttpMethod;\n+import org.eclipse.smarthome.core.thing.*;\n+import org.eclipse.smarthome.core.thing.binding.BaseBridgeHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.openhab.binding.jablotron.internal.config.JablotronBridgeConfig;\n+import org.openhab.binding.jablotron.internal.discovery.JablotronDiscoveryService;\n+import org.openhab.binding.jablotron.internal.model.*;\n+import org.openhab.binding.jablotron.internal.model.ja100f.JablotronGetPGResponse;\n+import org.openhab.binding.jablotron.internal.model.ja100f.JablotronGetSectionsResponse;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.JsonSyntaxException;\n+\n+/**\n+ * The {@link JablotronBridgeHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Ondrej Pecta - Initial contribution\n+ */\n+@NonNullByDefault\n+public class JablotronBridgeHandler extends BaseBridgeHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(JablotronBridgeHandler.class);\n+\n+    private final Gson gson = new Gson();\n+\n+    final HttpClient httpClient;\n+\n+    private @Nullable ScheduledFuture<?> future = null;\n+\n+    /**\n+     * Our configuration\n+     */\n+    public JablotronBridgeConfig bridgeConfig = new JablotronBridgeConfig();\n+\n+    public JablotronBridgeHandler(Bridge thing, HttpClient httpClient) {\n+        super(thing);\n+        this.httpClient = httpClient;\n+    }\n+\n+    @Override\n+    public Collection<Class<? extends ThingHandlerService>> getServices() {\n+        return Collections.singleton(JablotronDiscoveryService.class);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        bridgeConfig = getConfigAs(JablotronBridgeConfig.class);\n+        scheduler.execute(this::login);\n+        future = scheduler.scheduleWithFixedDelay(this::updateAlarmThings, 30, bridgeConfig.getRefresh(),\n+                TimeUnit.SECONDS);\n+    }\n+\n+    private void updateAlarmThings() {\n+        @Nullable\n+        List<JablotronDiscoveredService> services = discoverServices();\n+        if (services != null) {\n+            for (JablotronDiscoveredService service : services) {\n+                updateAlarmThing(service);\n+            }\n+        }\n+    }\n+\n+    private void updateAlarmThing(JablotronDiscoveredService service) {\n+        for (Thing th : getThing().getThings()) {\n+            JablotronAlarmHandler handler = (JablotronAlarmHandler) th.getHandler();\n+\n+            if (handler == null) {\n+                logger.debug(\"Thing handler is null\");\n+                continue;\n+            }\n+\n+            if (String.valueOf(service.getId()).equals(handler.thingConfig.getServiceId())) {\n+                if (\"ENABLED\".equals(service.getStatus())) {\n+                    if (!service.getWarning().isEmpty()) {\n+                        logger.debug(\"Alarm with service id: {} warning: {}\", service.getId(), service.getWarning());\n+                    }\n+                    handler.setStatus(ThingStatus.ONLINE, ThingStatusDetail.NONE, service.getWarning());\n+                    if (\"ALARM\".equals(service.getWarning()) || \"TAMPER\".equals(service.getWarning())) {\n+                        handler.triggerAlarm(service);\n+                    }\n+                    handler.setInService(\"SERVICE\".equals(service.getWarning()));\n+                } else {\n+                    logger.debug(\"Alarm with service id: {} is offline\", service.getId());\n+                    handler.setStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, service.getStatus());\n+                }\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        super.dispose();\n+        if (future != null) {\n+            future.cancel(true);\n+        }\n+        logout();\n+    }\n+\n+    private @Nullable <T> T sendJsonMessage(String url, String urlParameters, Class<T> classOfT) {\n+        return sendMessage(url, urlParameters, classOfT, APPLICATION_JSON, true);\n+    }\n+\n+    private @Nullable <T> T sendJsonMessage(String url, String urlParameters, Class<T> classOfT, boolean relogin) {\n+        return sendMessage(url, urlParameters, classOfT, APPLICATION_JSON, relogin);\n+    }\n+\n+    private @Nullable <T> T sendUrlEncodedMessage(String url, String urlParameters, Class<T> classOfT) {\n+        return sendMessage(url, urlParameters, classOfT, WWW_FORM_URLENCODED, true);\n+    }\n+\n+    private @Nullable <T> T sendMessage(String url, String urlParameters, Class<T> classOfT, String encoding,\n+            boolean relogin) {\n+        try {\n+            ContentResponse resp = createRequest(url).content(new StringContentProvider(urlParameters), encoding)\n+                    .send();\n+\n+            logger.trace(\"Request: {} with data: {}\", url, urlParameters);\n+            String line = resp.getContentAsString();\n+            logger.trace(\"Response: {}\", line);\n+            return gson.fromJson(line, classOfT);\n+        } catch (TimeoutException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                    \"Timeout during calling url: \" + url);\n+        } catch (InterruptedException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                    \"Interrupt during calling url: \" + url);\n+            Thread.currentThread().interrupt();\n+        } catch (JsonSyntaxException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                    \"Syntax error during calling url: \" + url);\n+        } catch (ExecutionException e) {\n+            if (relogin) {\n+                if (e.getMessage().contains(AUTHENTICATION_CHALLENGE)) {\n+                    relogin();\n+                    return null;\n+                }\n+            }\n+            logger.debug(\"Error during calling url: {}\", url, e);\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                    \"Error during calling url: \" + url);\n+        }\n+        return null;\n+    }\n+\n+    protected synchronized void login() {\n+        String url = JABLOTRON_API_URL + \"userAuthorize.json\";\n+        String urlParameters = \"{\\\"login\\\":\\\"\" + bridgeConfig.getLogin() + \"\\\", \\\"password\\\":\\\"\"\n+                + bridgeConfig.getPassword() + \"\\\"}\";\n+        JablotronLoginResponse response = sendJsonMessage(url, urlParameters, JablotronLoginResponse.class, false);\n+\n+        if (response == null) {\n+            return;\n+        }\n+\n+        if (response.getHttpCode() != 200) {\n+            logger.debug(\"Error during login, got http error: {}\", response.getHttpCode());\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                    \"Http error: \" + response.getHttpCode());\n+        } else {\n+            logger.debug(\"Successfully logged in\");\n+            updateStatus(ThingStatus.ONLINE);\n+        }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzM5MjQyMQ=="}, "originalCommit": {"oid": "bb824dab23246fe665151e79780dc81f6fe4928f"}, "originalPosition": 201}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzQ0Nzg4NQ==", "bodyText": "The state change originated by updateStatus() is logged to events.log. Including the status detail message. You could tail both files with the same tail command or adjust your logging config in userdata/etc/org.ops4j.pax.logging.cfg if this is more comfortable to you.", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r487447885", "createdAt": "2020-09-12T20:54:42Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.jablotron/src/main/java/org/openhab/binding/jablotron/internal/handler/JablotronBridgeHandler.java", "diffHunk": "@@ -0,0 +1,370 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.jablotron.internal.handler;\n+\n+import static org.openhab.binding.jablotron.JablotronBindingConstants.*;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.eclipse.jetty.http.HttpHeader;\n+import org.eclipse.jetty.http.HttpMethod;\n+import org.eclipse.smarthome.core.thing.*;\n+import org.eclipse.smarthome.core.thing.binding.BaseBridgeHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.openhab.binding.jablotron.internal.config.JablotronBridgeConfig;\n+import org.openhab.binding.jablotron.internal.discovery.JablotronDiscoveryService;\n+import org.openhab.binding.jablotron.internal.model.*;\n+import org.openhab.binding.jablotron.internal.model.ja100f.JablotronGetPGResponse;\n+import org.openhab.binding.jablotron.internal.model.ja100f.JablotronGetSectionsResponse;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.JsonSyntaxException;\n+\n+/**\n+ * The {@link JablotronBridgeHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Ondrej Pecta - Initial contribution\n+ */\n+@NonNullByDefault\n+public class JablotronBridgeHandler extends BaseBridgeHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(JablotronBridgeHandler.class);\n+\n+    private final Gson gson = new Gson();\n+\n+    final HttpClient httpClient;\n+\n+    private @Nullable ScheduledFuture<?> future = null;\n+\n+    /**\n+     * Our configuration\n+     */\n+    public JablotronBridgeConfig bridgeConfig = new JablotronBridgeConfig();\n+\n+    public JablotronBridgeHandler(Bridge thing, HttpClient httpClient) {\n+        super(thing);\n+        this.httpClient = httpClient;\n+    }\n+\n+    @Override\n+    public Collection<Class<? extends ThingHandlerService>> getServices() {\n+        return Collections.singleton(JablotronDiscoveryService.class);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        bridgeConfig = getConfigAs(JablotronBridgeConfig.class);\n+        scheduler.execute(this::login);\n+        future = scheduler.scheduleWithFixedDelay(this::updateAlarmThings, 30, bridgeConfig.getRefresh(),\n+                TimeUnit.SECONDS);\n+    }\n+\n+    private void updateAlarmThings() {\n+        @Nullable\n+        List<JablotronDiscoveredService> services = discoverServices();\n+        if (services != null) {\n+            for (JablotronDiscoveredService service : services) {\n+                updateAlarmThing(service);\n+            }\n+        }\n+    }\n+\n+    private void updateAlarmThing(JablotronDiscoveredService service) {\n+        for (Thing th : getThing().getThings()) {\n+            JablotronAlarmHandler handler = (JablotronAlarmHandler) th.getHandler();\n+\n+            if (handler == null) {\n+                logger.debug(\"Thing handler is null\");\n+                continue;\n+            }\n+\n+            if (String.valueOf(service.getId()).equals(handler.thingConfig.getServiceId())) {\n+                if (\"ENABLED\".equals(service.getStatus())) {\n+                    if (!service.getWarning().isEmpty()) {\n+                        logger.debug(\"Alarm with service id: {} warning: {}\", service.getId(), service.getWarning());\n+                    }\n+                    handler.setStatus(ThingStatus.ONLINE, ThingStatusDetail.NONE, service.getWarning());\n+                    if (\"ALARM\".equals(service.getWarning()) || \"TAMPER\".equals(service.getWarning())) {\n+                        handler.triggerAlarm(service);\n+                    }\n+                    handler.setInService(\"SERVICE\".equals(service.getWarning()));\n+                } else {\n+                    logger.debug(\"Alarm with service id: {} is offline\", service.getId());\n+                    handler.setStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, service.getStatus());\n+                }\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        super.dispose();\n+        if (future != null) {\n+            future.cancel(true);\n+        }\n+        logout();\n+    }\n+\n+    private @Nullable <T> T sendJsonMessage(String url, String urlParameters, Class<T> classOfT) {\n+        return sendMessage(url, urlParameters, classOfT, APPLICATION_JSON, true);\n+    }\n+\n+    private @Nullable <T> T sendJsonMessage(String url, String urlParameters, Class<T> classOfT, boolean relogin) {\n+        return sendMessage(url, urlParameters, classOfT, APPLICATION_JSON, relogin);\n+    }\n+\n+    private @Nullable <T> T sendUrlEncodedMessage(String url, String urlParameters, Class<T> classOfT) {\n+        return sendMessage(url, urlParameters, classOfT, WWW_FORM_URLENCODED, true);\n+    }\n+\n+    private @Nullable <T> T sendMessage(String url, String urlParameters, Class<T> classOfT, String encoding,\n+            boolean relogin) {\n+        try {\n+            ContentResponse resp = createRequest(url).content(new StringContentProvider(urlParameters), encoding)\n+                    .send();\n+\n+            logger.trace(\"Request: {} with data: {}\", url, urlParameters);\n+            String line = resp.getContentAsString();\n+            logger.trace(\"Response: {}\", line);\n+            return gson.fromJson(line, classOfT);\n+        } catch (TimeoutException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                    \"Timeout during calling url: \" + url);\n+        } catch (InterruptedException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                    \"Interrupt during calling url: \" + url);\n+            Thread.currentThread().interrupt();\n+        } catch (JsonSyntaxException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                    \"Syntax error during calling url: \" + url);\n+        } catch (ExecutionException e) {\n+            if (relogin) {\n+                if (e.getMessage().contains(AUTHENTICATION_CHALLENGE)) {\n+                    relogin();\n+                    return null;\n+                }\n+            }\n+            logger.debug(\"Error during calling url: {}\", url, e);\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                    \"Error during calling url: \" + url);\n+        }\n+        return null;\n+    }\n+\n+    protected synchronized void login() {\n+        String url = JABLOTRON_API_URL + \"userAuthorize.json\";\n+        String urlParameters = \"{\\\"login\\\":\\\"\" + bridgeConfig.getLogin() + \"\\\", \\\"password\\\":\\\"\"\n+                + bridgeConfig.getPassword() + \"\\\"}\";\n+        JablotronLoginResponse response = sendJsonMessage(url, urlParameters, JablotronLoginResponse.class, false);\n+\n+        if (response == null) {\n+            return;\n+        }\n+\n+        if (response.getHttpCode() != 200) {\n+            logger.debug(\"Error during login, got http error: {}\", response.getHttpCode());\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                    \"Http error: \" + response.getHttpCode());\n+        } else {\n+            logger.debug(\"Successfully logged in\");\n+            updateStatus(ThingStatus.ONLINE);\n+        }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzM5MjQyMQ=="}, "originalCommit": {"oid": "bb824dab23246fe665151e79780dc81f6fe4928f"}, "originalPosition": 201}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzUxNDExMQ==", "bodyText": "ok, removed", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r487514111", "createdAt": "2020-09-13T10:55:13Z", "author": {"login": "octa22"}, "path": "bundles/org.openhab.binding.jablotron/src/main/java/org/openhab/binding/jablotron/internal/handler/JablotronBridgeHandler.java", "diffHunk": "@@ -0,0 +1,370 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.jablotron.internal.handler;\n+\n+import static org.openhab.binding.jablotron.JablotronBindingConstants.*;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.eclipse.jetty.http.HttpHeader;\n+import org.eclipse.jetty.http.HttpMethod;\n+import org.eclipse.smarthome.core.thing.*;\n+import org.eclipse.smarthome.core.thing.binding.BaseBridgeHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.openhab.binding.jablotron.internal.config.JablotronBridgeConfig;\n+import org.openhab.binding.jablotron.internal.discovery.JablotronDiscoveryService;\n+import org.openhab.binding.jablotron.internal.model.*;\n+import org.openhab.binding.jablotron.internal.model.ja100f.JablotronGetPGResponse;\n+import org.openhab.binding.jablotron.internal.model.ja100f.JablotronGetSectionsResponse;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.JsonSyntaxException;\n+\n+/**\n+ * The {@link JablotronBridgeHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Ondrej Pecta - Initial contribution\n+ */\n+@NonNullByDefault\n+public class JablotronBridgeHandler extends BaseBridgeHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(JablotronBridgeHandler.class);\n+\n+    private final Gson gson = new Gson();\n+\n+    final HttpClient httpClient;\n+\n+    private @Nullable ScheduledFuture<?> future = null;\n+\n+    /**\n+     * Our configuration\n+     */\n+    public JablotronBridgeConfig bridgeConfig = new JablotronBridgeConfig();\n+\n+    public JablotronBridgeHandler(Bridge thing, HttpClient httpClient) {\n+        super(thing);\n+        this.httpClient = httpClient;\n+    }\n+\n+    @Override\n+    public Collection<Class<? extends ThingHandlerService>> getServices() {\n+        return Collections.singleton(JablotronDiscoveryService.class);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        bridgeConfig = getConfigAs(JablotronBridgeConfig.class);\n+        scheduler.execute(this::login);\n+        future = scheduler.scheduleWithFixedDelay(this::updateAlarmThings, 30, bridgeConfig.getRefresh(),\n+                TimeUnit.SECONDS);\n+    }\n+\n+    private void updateAlarmThings() {\n+        @Nullable\n+        List<JablotronDiscoveredService> services = discoverServices();\n+        if (services != null) {\n+            for (JablotronDiscoveredService service : services) {\n+                updateAlarmThing(service);\n+            }\n+        }\n+    }\n+\n+    private void updateAlarmThing(JablotronDiscoveredService service) {\n+        for (Thing th : getThing().getThings()) {\n+            JablotronAlarmHandler handler = (JablotronAlarmHandler) th.getHandler();\n+\n+            if (handler == null) {\n+                logger.debug(\"Thing handler is null\");\n+                continue;\n+            }\n+\n+            if (String.valueOf(service.getId()).equals(handler.thingConfig.getServiceId())) {\n+                if (\"ENABLED\".equals(service.getStatus())) {\n+                    if (!service.getWarning().isEmpty()) {\n+                        logger.debug(\"Alarm with service id: {} warning: {}\", service.getId(), service.getWarning());\n+                    }\n+                    handler.setStatus(ThingStatus.ONLINE, ThingStatusDetail.NONE, service.getWarning());\n+                    if (\"ALARM\".equals(service.getWarning()) || \"TAMPER\".equals(service.getWarning())) {\n+                        handler.triggerAlarm(service);\n+                    }\n+                    handler.setInService(\"SERVICE\".equals(service.getWarning()));\n+                } else {\n+                    logger.debug(\"Alarm with service id: {} is offline\", service.getId());\n+                    handler.setStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, service.getStatus());\n+                }\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        super.dispose();\n+        if (future != null) {\n+            future.cancel(true);\n+        }\n+        logout();\n+    }\n+\n+    private @Nullable <T> T sendJsonMessage(String url, String urlParameters, Class<T> classOfT) {\n+        return sendMessage(url, urlParameters, classOfT, APPLICATION_JSON, true);\n+    }\n+\n+    private @Nullable <T> T sendJsonMessage(String url, String urlParameters, Class<T> classOfT, boolean relogin) {\n+        return sendMessage(url, urlParameters, classOfT, APPLICATION_JSON, relogin);\n+    }\n+\n+    private @Nullable <T> T sendUrlEncodedMessage(String url, String urlParameters, Class<T> classOfT) {\n+        return sendMessage(url, urlParameters, classOfT, WWW_FORM_URLENCODED, true);\n+    }\n+\n+    private @Nullable <T> T sendMessage(String url, String urlParameters, Class<T> classOfT, String encoding,\n+            boolean relogin) {\n+        try {\n+            ContentResponse resp = createRequest(url).content(new StringContentProvider(urlParameters), encoding)\n+                    .send();\n+\n+            logger.trace(\"Request: {} with data: {}\", url, urlParameters);\n+            String line = resp.getContentAsString();\n+            logger.trace(\"Response: {}\", line);\n+            return gson.fromJson(line, classOfT);\n+        } catch (TimeoutException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                    \"Timeout during calling url: \" + url);\n+        } catch (InterruptedException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                    \"Interrupt during calling url: \" + url);\n+            Thread.currentThread().interrupt();\n+        } catch (JsonSyntaxException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                    \"Syntax error during calling url: \" + url);\n+        } catch (ExecutionException e) {\n+            if (relogin) {\n+                if (e.getMessage().contains(AUTHENTICATION_CHALLENGE)) {\n+                    relogin();\n+                    return null;\n+                }\n+            }\n+            logger.debug(\"Error during calling url: {}\", url, e);\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                    \"Error during calling url: \" + url);\n+        }\n+        return null;\n+    }\n+\n+    protected synchronized void login() {\n+        String url = JABLOTRON_API_URL + \"userAuthorize.json\";\n+        String urlParameters = \"{\\\"login\\\":\\\"\" + bridgeConfig.getLogin() + \"\\\", \\\"password\\\":\\\"\"\n+                + bridgeConfig.getPassword() + \"\\\"}\";\n+        JablotronLoginResponse response = sendJsonMessage(url, urlParameters, JablotronLoginResponse.class, false);\n+\n+        if (response == null) {\n+            return;\n+        }\n+\n+        if (response.getHttpCode() != 200) {\n+            logger.debug(\"Error during login, got http error: {}\", response.getHttpCode());\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                    \"Http error: \" + response.getHttpCode());\n+        } else {\n+            logger.debug(\"Successfully logged in\");\n+            updateStatus(ThingStatus.ONLINE);\n+        }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzM5MjQyMQ=="}, "originalCommit": {"oid": "bb824dab23246fe665151e79780dc81f6fe4928f"}, "originalPosition": 201}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA0ODg4OTIwOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.jablotron/src/main/java/org/openhab/binding/jablotron/internal/handler/JablotronBridgeHandler.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMlQwOTo1NTo1MFrOHQ0FNA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMlQxNTo1OToxMVrOHQ178Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzM5MjU2NA==", "bodyText": "What is throwing a SecurityException here?", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r487392564", "createdAt": "2020-09-12T09:55:50Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.jablotron/src/main/java/org/openhab/binding/jablotron/internal/handler/JablotronBridgeHandler.java", "diffHunk": "@@ -0,0 +1,370 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.jablotron.internal.handler;\n+\n+import static org.openhab.binding.jablotron.JablotronBindingConstants.*;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.eclipse.jetty.http.HttpHeader;\n+import org.eclipse.jetty.http.HttpMethod;\n+import org.eclipse.smarthome.core.thing.*;\n+import org.eclipse.smarthome.core.thing.binding.BaseBridgeHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.openhab.binding.jablotron.internal.config.JablotronBridgeConfig;\n+import org.openhab.binding.jablotron.internal.discovery.JablotronDiscoveryService;\n+import org.openhab.binding.jablotron.internal.model.*;\n+import org.openhab.binding.jablotron.internal.model.ja100f.JablotronGetPGResponse;\n+import org.openhab.binding.jablotron.internal.model.ja100f.JablotronGetSectionsResponse;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.JsonSyntaxException;\n+\n+/**\n+ * The {@link JablotronBridgeHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Ondrej Pecta - Initial contribution\n+ */\n+@NonNullByDefault\n+public class JablotronBridgeHandler extends BaseBridgeHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(JablotronBridgeHandler.class);\n+\n+    private final Gson gson = new Gson();\n+\n+    final HttpClient httpClient;\n+\n+    private @Nullable ScheduledFuture<?> future = null;\n+\n+    /**\n+     * Our configuration\n+     */\n+    public JablotronBridgeConfig bridgeConfig = new JablotronBridgeConfig();\n+\n+    public JablotronBridgeHandler(Bridge thing, HttpClient httpClient) {\n+        super(thing);\n+        this.httpClient = httpClient;\n+    }\n+\n+    @Override\n+    public Collection<Class<? extends ThingHandlerService>> getServices() {\n+        return Collections.singleton(JablotronDiscoveryService.class);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        bridgeConfig = getConfigAs(JablotronBridgeConfig.class);\n+        scheduler.execute(this::login);\n+        future = scheduler.scheduleWithFixedDelay(this::updateAlarmThings, 30, bridgeConfig.getRefresh(),\n+                TimeUnit.SECONDS);\n+    }\n+\n+    private void updateAlarmThings() {\n+        @Nullable\n+        List<JablotronDiscoveredService> services = discoverServices();\n+        if (services != null) {\n+            for (JablotronDiscoveredService service : services) {\n+                updateAlarmThing(service);\n+            }\n+        }\n+    }\n+\n+    private void updateAlarmThing(JablotronDiscoveredService service) {\n+        for (Thing th : getThing().getThings()) {\n+            JablotronAlarmHandler handler = (JablotronAlarmHandler) th.getHandler();\n+\n+            if (handler == null) {\n+                logger.debug(\"Thing handler is null\");\n+                continue;\n+            }\n+\n+            if (String.valueOf(service.getId()).equals(handler.thingConfig.getServiceId())) {\n+                if (\"ENABLED\".equals(service.getStatus())) {\n+                    if (!service.getWarning().isEmpty()) {\n+                        logger.debug(\"Alarm with service id: {} warning: {}\", service.getId(), service.getWarning());\n+                    }\n+                    handler.setStatus(ThingStatus.ONLINE, ThingStatusDetail.NONE, service.getWarning());\n+                    if (\"ALARM\".equals(service.getWarning()) || \"TAMPER\".equals(service.getWarning())) {\n+                        handler.triggerAlarm(service);\n+                    }\n+                    handler.setInService(\"SERVICE\".equals(service.getWarning()));\n+                } else {\n+                    logger.debug(\"Alarm with service id: {} is offline\", service.getId());\n+                    handler.setStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, service.getStatus());\n+                }\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        super.dispose();\n+        if (future != null) {\n+            future.cancel(true);\n+        }\n+        logout();\n+    }\n+\n+    private @Nullable <T> T sendJsonMessage(String url, String urlParameters, Class<T> classOfT) {\n+        return sendMessage(url, urlParameters, classOfT, APPLICATION_JSON, true);\n+    }\n+\n+    private @Nullable <T> T sendJsonMessage(String url, String urlParameters, Class<T> classOfT, boolean relogin) {\n+        return sendMessage(url, urlParameters, classOfT, APPLICATION_JSON, relogin);\n+    }\n+\n+    private @Nullable <T> T sendUrlEncodedMessage(String url, String urlParameters, Class<T> classOfT) {\n+        return sendMessage(url, urlParameters, classOfT, WWW_FORM_URLENCODED, true);\n+    }\n+\n+    private @Nullable <T> T sendMessage(String url, String urlParameters, Class<T> classOfT, String encoding,\n+            boolean relogin) {\n+        try {\n+            ContentResponse resp = createRequest(url).content(new StringContentProvider(urlParameters), encoding)\n+                    .send();\n+\n+            logger.trace(\"Request: {} with data: {}\", url, urlParameters);\n+            String line = resp.getContentAsString();\n+            logger.trace(\"Response: {}\", line);\n+            return gson.fromJson(line, classOfT);\n+        } catch (TimeoutException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                    \"Timeout during calling url: \" + url);\n+        } catch (InterruptedException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                    \"Interrupt during calling url: \" + url);\n+            Thread.currentThread().interrupt();\n+        } catch (JsonSyntaxException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                    \"Syntax error during calling url: \" + url);\n+        } catch (ExecutionException e) {\n+            if (relogin) {\n+                if (e.getMessage().contains(AUTHENTICATION_CHALLENGE)) {\n+                    relogin();\n+                    return null;\n+                }\n+            }\n+            logger.debug(\"Error during calling url: {}\", url, e);\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                    \"Error during calling url: \" + url);\n+        }\n+        return null;\n+    }\n+\n+    protected synchronized void login() {\n+        String url = JABLOTRON_API_URL + \"userAuthorize.json\";\n+        String urlParameters = \"{\\\"login\\\":\\\"\" + bridgeConfig.getLogin() + \"\\\", \\\"password\\\":\\\"\"\n+                + bridgeConfig.getPassword() + \"\\\"}\";\n+        JablotronLoginResponse response = sendJsonMessage(url, urlParameters, JablotronLoginResponse.class, false);\n+\n+        if (response == null) {\n+            return;\n+        }\n+\n+        if (response.getHttpCode() != 200) {\n+            logger.debug(\"Error during login, got http error: {}\", response.getHttpCode());\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                    \"Http error: \" + response.getHttpCode());\n+        } else {\n+            logger.debug(\"Successfully logged in\");\n+            updateStatus(ThingStatus.ONLINE);\n+        }\n+    }\n+\n+    protected void logout() {\n+        String url = JABLOTRON_API_URL + \"logout.json\";\n+        String urlParameters = \"system=\" + SYSTEM;\n+\n+        try {\n+            ContentResponse resp = createRequest(url)\n+                    .content(new StringContentProvider(urlParameters), WWW_FORM_URLENCODED).send();\n+\n+            if (logger.isTraceEnabled()) {\n+                String line = resp.getContentAsString();\n+                logger.trace(\"logout response: {}\", line);\n+            }\n+        } catch (ExecutionException | TimeoutException | InterruptedException e) {\n+            // Silence\n+        }\n+    }\n+\n+    public @Nullable List<JablotronDiscoveredService> discoverServices() {\n+        String url = JABLOTRON_API_URL + \"serviceListGet.json\";\n+        String urlParameters = \"{\\\"list-type\\\": \\\"EXTENDED\\\",\\\"visibility\\\": \\\"VISIBLE\\\"}\";\n+        JablotronGetServiceResponse response = sendJsonMessage(url, urlParameters, JablotronGetServiceResponse.class);\n+\n+        if (response == null) {\n+            return null;\n+        }\n+\n+        if (response.getHttpCode() != 200) {\n+            logger.debug(\"Error during service discovery, got http code: {}\", response.getHttpCode());\n+        }\n+\n+        return response.getData().getServices();\n+    }\n+\n+    protected @Nullable JablotronControlResponse sendUserCode(Thing th, String section, String key, String status,\n+            String code) throws SecurityException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bb824dab23246fe665151e79780dc81f6fe4928f"}, "originalPosition": 238}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzQyMjk2MQ==", "bodyText": "as I mentioned, old code.\nremoved the SecurityException from the header. thanks", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r487422961", "createdAt": "2020-09-12T15:59:11Z", "author": {"login": "octa22"}, "path": "bundles/org.openhab.binding.jablotron/src/main/java/org/openhab/binding/jablotron/internal/handler/JablotronBridgeHandler.java", "diffHunk": "@@ -0,0 +1,370 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.jablotron.internal.handler;\n+\n+import static org.openhab.binding.jablotron.JablotronBindingConstants.*;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.eclipse.jetty.http.HttpHeader;\n+import org.eclipse.jetty.http.HttpMethod;\n+import org.eclipse.smarthome.core.thing.*;\n+import org.eclipse.smarthome.core.thing.binding.BaseBridgeHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.openhab.binding.jablotron.internal.config.JablotronBridgeConfig;\n+import org.openhab.binding.jablotron.internal.discovery.JablotronDiscoveryService;\n+import org.openhab.binding.jablotron.internal.model.*;\n+import org.openhab.binding.jablotron.internal.model.ja100f.JablotronGetPGResponse;\n+import org.openhab.binding.jablotron.internal.model.ja100f.JablotronGetSectionsResponse;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.JsonSyntaxException;\n+\n+/**\n+ * The {@link JablotronBridgeHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Ondrej Pecta - Initial contribution\n+ */\n+@NonNullByDefault\n+public class JablotronBridgeHandler extends BaseBridgeHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(JablotronBridgeHandler.class);\n+\n+    private final Gson gson = new Gson();\n+\n+    final HttpClient httpClient;\n+\n+    private @Nullable ScheduledFuture<?> future = null;\n+\n+    /**\n+     * Our configuration\n+     */\n+    public JablotronBridgeConfig bridgeConfig = new JablotronBridgeConfig();\n+\n+    public JablotronBridgeHandler(Bridge thing, HttpClient httpClient) {\n+        super(thing);\n+        this.httpClient = httpClient;\n+    }\n+\n+    @Override\n+    public Collection<Class<? extends ThingHandlerService>> getServices() {\n+        return Collections.singleton(JablotronDiscoveryService.class);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        bridgeConfig = getConfigAs(JablotronBridgeConfig.class);\n+        scheduler.execute(this::login);\n+        future = scheduler.scheduleWithFixedDelay(this::updateAlarmThings, 30, bridgeConfig.getRefresh(),\n+                TimeUnit.SECONDS);\n+    }\n+\n+    private void updateAlarmThings() {\n+        @Nullable\n+        List<JablotronDiscoveredService> services = discoverServices();\n+        if (services != null) {\n+            for (JablotronDiscoveredService service : services) {\n+                updateAlarmThing(service);\n+            }\n+        }\n+    }\n+\n+    private void updateAlarmThing(JablotronDiscoveredService service) {\n+        for (Thing th : getThing().getThings()) {\n+            JablotronAlarmHandler handler = (JablotronAlarmHandler) th.getHandler();\n+\n+            if (handler == null) {\n+                logger.debug(\"Thing handler is null\");\n+                continue;\n+            }\n+\n+            if (String.valueOf(service.getId()).equals(handler.thingConfig.getServiceId())) {\n+                if (\"ENABLED\".equals(service.getStatus())) {\n+                    if (!service.getWarning().isEmpty()) {\n+                        logger.debug(\"Alarm with service id: {} warning: {}\", service.getId(), service.getWarning());\n+                    }\n+                    handler.setStatus(ThingStatus.ONLINE, ThingStatusDetail.NONE, service.getWarning());\n+                    if (\"ALARM\".equals(service.getWarning()) || \"TAMPER\".equals(service.getWarning())) {\n+                        handler.triggerAlarm(service);\n+                    }\n+                    handler.setInService(\"SERVICE\".equals(service.getWarning()));\n+                } else {\n+                    logger.debug(\"Alarm with service id: {} is offline\", service.getId());\n+                    handler.setStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, service.getStatus());\n+                }\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        super.dispose();\n+        if (future != null) {\n+            future.cancel(true);\n+        }\n+        logout();\n+    }\n+\n+    private @Nullable <T> T sendJsonMessage(String url, String urlParameters, Class<T> classOfT) {\n+        return sendMessage(url, urlParameters, classOfT, APPLICATION_JSON, true);\n+    }\n+\n+    private @Nullable <T> T sendJsonMessage(String url, String urlParameters, Class<T> classOfT, boolean relogin) {\n+        return sendMessage(url, urlParameters, classOfT, APPLICATION_JSON, relogin);\n+    }\n+\n+    private @Nullable <T> T sendUrlEncodedMessage(String url, String urlParameters, Class<T> classOfT) {\n+        return sendMessage(url, urlParameters, classOfT, WWW_FORM_URLENCODED, true);\n+    }\n+\n+    private @Nullable <T> T sendMessage(String url, String urlParameters, Class<T> classOfT, String encoding,\n+            boolean relogin) {\n+        try {\n+            ContentResponse resp = createRequest(url).content(new StringContentProvider(urlParameters), encoding)\n+                    .send();\n+\n+            logger.trace(\"Request: {} with data: {}\", url, urlParameters);\n+            String line = resp.getContentAsString();\n+            logger.trace(\"Response: {}\", line);\n+            return gson.fromJson(line, classOfT);\n+        } catch (TimeoutException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                    \"Timeout during calling url: \" + url);\n+        } catch (InterruptedException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                    \"Interrupt during calling url: \" + url);\n+            Thread.currentThread().interrupt();\n+        } catch (JsonSyntaxException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                    \"Syntax error during calling url: \" + url);\n+        } catch (ExecutionException e) {\n+            if (relogin) {\n+                if (e.getMessage().contains(AUTHENTICATION_CHALLENGE)) {\n+                    relogin();\n+                    return null;\n+                }\n+            }\n+            logger.debug(\"Error during calling url: {}\", url, e);\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                    \"Error during calling url: \" + url);\n+        }\n+        return null;\n+    }\n+\n+    protected synchronized void login() {\n+        String url = JABLOTRON_API_URL + \"userAuthorize.json\";\n+        String urlParameters = \"{\\\"login\\\":\\\"\" + bridgeConfig.getLogin() + \"\\\", \\\"password\\\":\\\"\"\n+                + bridgeConfig.getPassword() + \"\\\"}\";\n+        JablotronLoginResponse response = sendJsonMessage(url, urlParameters, JablotronLoginResponse.class, false);\n+\n+        if (response == null) {\n+            return;\n+        }\n+\n+        if (response.getHttpCode() != 200) {\n+            logger.debug(\"Error during login, got http error: {}\", response.getHttpCode());\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                    \"Http error: \" + response.getHttpCode());\n+        } else {\n+            logger.debug(\"Successfully logged in\");\n+            updateStatus(ThingStatus.ONLINE);\n+        }\n+    }\n+\n+    protected void logout() {\n+        String url = JABLOTRON_API_URL + \"logout.json\";\n+        String urlParameters = \"system=\" + SYSTEM;\n+\n+        try {\n+            ContentResponse resp = createRequest(url)\n+                    .content(new StringContentProvider(urlParameters), WWW_FORM_URLENCODED).send();\n+\n+            if (logger.isTraceEnabled()) {\n+                String line = resp.getContentAsString();\n+                logger.trace(\"logout response: {}\", line);\n+            }\n+        } catch (ExecutionException | TimeoutException | InterruptedException e) {\n+            // Silence\n+        }\n+    }\n+\n+    public @Nullable List<JablotronDiscoveredService> discoverServices() {\n+        String url = JABLOTRON_API_URL + \"serviceListGet.json\";\n+        String urlParameters = \"{\\\"list-type\\\": \\\"EXTENDED\\\",\\\"visibility\\\": \\\"VISIBLE\\\"}\";\n+        JablotronGetServiceResponse response = sendJsonMessage(url, urlParameters, JablotronGetServiceResponse.class);\n+\n+        if (response == null) {\n+            return null;\n+        }\n+\n+        if (response.getHttpCode() != 200) {\n+            logger.debug(\"Error during service discovery, got http code: {}\", response.getHttpCode());\n+        }\n+\n+        return response.getData().getServices();\n+    }\n+\n+    protected @Nullable JablotronControlResponse sendUserCode(Thing th, String section, String key, String status,\n+            String code) throws SecurityException {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzM5MjU2NA=="}, "originalCommit": {"oid": "bb824dab23246fe665151e79780dc81f6fe4928f"}, "originalPosition": 238}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA0ODg5NDUwOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.jablotron/src/main/resources/ESH-INF/config/config.xml", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMlQxMDowMzoyNFrOHQ0HhA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMlQxNjowMjoxNlrOHQ19Eg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzM5MzE1Ng==", "bodyText": "Can you apply the min value and the unit to the other refresh parameters, too? Is 30 sec. a reasonable min value? Maybe the API gets faster some day?", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r487393156", "createdAt": "2020-09-12T10:03:24Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.jablotron/src/main/resources/ESH-INF/config/config.xml", "diffHunk": "@@ -0,0 +1,86 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<config-description:config-descriptions\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:config-description=\"https://openhab.org/schemas/config-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/config-description/v1.0.0 https://openhab.org/schemas/config-description-1.0.0.xsd\">\n+\n+\t<config-description uri=\"thing-type:jablotron:device\">\n+\t\t<parameter name=\"refresh\" type=\"integer\" required=\"false\" min=\"30\" unit=\"s\">", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bb824dab23246fe665151e79780dc81f6fe4928f"}, "originalPosition": 8}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzQyMzI1MA==", "bodyText": "lowered to 10s and added to the missing", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r487423250", "createdAt": "2020-09-12T16:02:16Z", "author": {"login": "octa22"}, "path": "bundles/org.openhab.binding.jablotron/src/main/resources/ESH-INF/config/config.xml", "diffHunk": "@@ -0,0 +1,86 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<config-description:config-descriptions\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:config-description=\"https://openhab.org/schemas/config-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/config-description/v1.0.0 https://openhab.org/schemas/config-description-1.0.0.xsd\">\n+\n+\t<config-description uri=\"thing-type:jablotron:device\">\n+\t\t<parameter name=\"refresh\" type=\"integer\" required=\"false\" min=\"30\" unit=\"s\">", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzM5MzE1Ng=="}, "originalCommit": {"oid": "bb824dab23246fe665151e79780dc81f6fe4928f"}, "originalPosition": 8}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA1MDIyMTU4OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.jablotron/README.md", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xM1QxNzowMjoxNlrOHQ92zA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xM1QxODoyOTo1NFrOHQ-YUQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzU1MjcxNg==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            | JA-100               | thermometer_%nr% | Number    | the thermometer %nr% value                                |\n          \n          \n            \n            | JA-100               | thermostat_%nr%  | Number    | the thermostat %nr% value                                 |\n          \n          \n            \n            | JA-100               | thermometer_%nr% | Number:Temperature    | the thermometer %nr% value                                |\n          \n          \n            \n            | JA-100               | thermostat_%nr%  | Number:Temperature    | the thermostat %nr% value                                 |", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r487552716", "createdAt": "2020-09-13T17:02:16Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.jablotron/README.md", "diffHunk": "@@ -0,0 +1,125 @@\n+# Jablotron Alarm Binding\n+\n+This is the binding for Jablotron alarms.\n+https://www.jablotron.com/en/jablotron-products/alarms/\n+\n+## Supported Things\n+\n+| thing   | note                                      |\n+|---------|-------------------------------------------|\n+| bridge  | the bridge to your Jablonet cloud account |\n+| JA-80   | the OASIS alarm                           |\n+| JA-100  | with the thermometer support              |\n+| JA-100F | without the thermometer support           |\n+ \n+## Discovery\n+\n+This binding supports auto discovery. Just manually add a bridge thing and supply login & password to your Jablonet account.\n+\n+## Binding Configuration\n+\n+Binding itself doesn't require specific configuration.\n+\n+## Thing Configuration\n+\n+| thing                | config parameter name | description                                                                        | type                  |\n+|----------------------|-----------------------|------------------------------------------------------------------------------------|-----------------------|\n+| bridge               | login                 | the login to your Jablonet account                                                 | mandatory             |\n+| bridge               | password              | the password to your Jablonet account                                              | mandatory             |\n+| bridge               | refresh               | the refresh time for all alarm warnings (ALARM, TAMPER triggers and SERVICE state) | optional, default=30s |\n+| bridge               | lang                  | the language of the alarm texts                                                    | optional, default=en  |\n+| JA-80/JA-100/JA-100F | refresh               | the channels refresh period in seconds                                             | optional, default=60s |\n+| JA-80/JA-100/JA-100F | serviceId             | the service ID which identifies the alarm                                          | mandatory             |\n+| JA-100/JA-100F       | code                  | the master code for controlling sections                                           | optional              |\n+\n+## Channels\n+\n+| thing                | channel name     | item type | description                                               |\n+|----------------------|------------------|-----------|-----------------------------------------------------------|\n+| bridge               | N/A              | N/A       | the bridge does not expose any channels                   |\n+| JA-80                | statusA          | Switch    | the status of the A section                               |\n+| JA-80                | statusB          | Switch    | the status of the AB/B section                            |\n+| JA-80                | statusABC        | Switch    | the status of the ABC section                             |\n+| JA-80                | statusPGX        | Switch    | the status of PGX                                         |\n+| JA-80                | statusPGY        | Switch    | the status of PGY                                         |\n+| JA-80                | command          | String    | the channel for sending keyboard codes to the OASIS alarm |\n+| JA-80/JA-100/JA-100F | lastEvent        | String    | the description of the last event                         |\n+| JA-80/JA-100/JA-100F | lastEventClass   | String    | the class of the last event - e.g. arm, disarm, ...       |\n+| JA-80/JA-100/JA-100F | lastEventInvoker | String    | the invoker of the last event                             |\n+| JA-80/JA-100/JA-100F | lastEventTime    | DateTime  | the time of the last event                                |\n+| JA-80/JA-100/JA-100F | lastCheckTime    | DateTime  | the time of the last checking                             |\n+| JA-80/JA-100/JA-100F | alarm            | N/A       | the alarm trigger, might fire ALARM or TAMPER events      |\n+| JA-100/JA-100F       | lastEventSection | String    | the section of the last event                             |\n+| JA-100               | state_%nr%       | String    | the section %nr% status/control                           |\n+| JA-100               | pgm_%nr%         | Switch    | the PG switch %nr% status/control                        |\n+| JA-100               | thermometer_%nr% | Number    | the thermometer %nr% value                                |\n+| JA-100               | thermostat_%nr%  | Number    | the thermostat %nr% value                                 |", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a24a1fd3e9b0b42b246535a2373bab007dbe3856"}, "originalPosition": 56}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzU2MTI5Nw==", "bodyText": "ok", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r487561297", "createdAt": "2020-09-13T18:29:54Z", "author": {"login": "octa22"}, "path": "bundles/org.openhab.binding.jablotron/README.md", "diffHunk": "@@ -0,0 +1,125 @@\n+# Jablotron Alarm Binding\n+\n+This is the binding for Jablotron alarms.\n+https://www.jablotron.com/en/jablotron-products/alarms/\n+\n+## Supported Things\n+\n+| thing   | note                                      |\n+|---------|-------------------------------------------|\n+| bridge  | the bridge to your Jablonet cloud account |\n+| JA-80   | the OASIS alarm                           |\n+| JA-100  | with the thermometer support              |\n+| JA-100F | without the thermometer support           |\n+ \n+## Discovery\n+\n+This binding supports auto discovery. Just manually add a bridge thing and supply login & password to your Jablonet account.\n+\n+## Binding Configuration\n+\n+Binding itself doesn't require specific configuration.\n+\n+## Thing Configuration\n+\n+| thing                | config parameter name | description                                                                        | type                  |\n+|----------------------|-----------------------|------------------------------------------------------------------------------------|-----------------------|\n+| bridge               | login                 | the login to your Jablonet account                                                 | mandatory             |\n+| bridge               | password              | the password to your Jablonet account                                              | mandatory             |\n+| bridge               | refresh               | the refresh time for all alarm warnings (ALARM, TAMPER triggers and SERVICE state) | optional, default=30s |\n+| bridge               | lang                  | the language of the alarm texts                                                    | optional, default=en  |\n+| JA-80/JA-100/JA-100F | refresh               | the channels refresh period in seconds                                             | optional, default=60s |\n+| JA-80/JA-100/JA-100F | serviceId             | the service ID which identifies the alarm                                          | mandatory             |\n+| JA-100/JA-100F       | code                  | the master code for controlling sections                                           | optional              |\n+\n+## Channels\n+\n+| thing                | channel name     | item type | description                                               |\n+|----------------------|------------------|-----------|-----------------------------------------------------------|\n+| bridge               | N/A              | N/A       | the bridge does not expose any channels                   |\n+| JA-80                | statusA          | Switch    | the status of the A section                               |\n+| JA-80                | statusB          | Switch    | the status of the AB/B section                            |\n+| JA-80                | statusABC        | Switch    | the status of the ABC section                             |\n+| JA-80                | statusPGX        | Switch    | the status of PGX                                         |\n+| JA-80                | statusPGY        | Switch    | the status of PGY                                         |\n+| JA-80                | command          | String    | the channel for sending keyboard codes to the OASIS alarm |\n+| JA-80/JA-100/JA-100F | lastEvent        | String    | the description of the last event                         |\n+| JA-80/JA-100/JA-100F | lastEventClass   | String    | the class of the last event - e.g. arm, disarm, ...       |\n+| JA-80/JA-100/JA-100F | lastEventInvoker | String    | the invoker of the last event                             |\n+| JA-80/JA-100/JA-100F | lastEventTime    | DateTime  | the time of the last event                                |\n+| JA-80/JA-100/JA-100F | lastCheckTime    | DateTime  | the time of the last checking                             |\n+| JA-80/JA-100/JA-100F | alarm            | N/A       | the alarm trigger, might fire ALARM or TAMPER events      |\n+| JA-100/JA-100F       | lastEventSection | String    | the section of the last event                             |\n+| JA-100               | state_%nr%       | String    | the section %nr% status/control                           |\n+| JA-100               | pgm_%nr%         | Switch    | the PG switch %nr% status/control                        |\n+| JA-100               | thermometer_%nr% | Number    | the thermometer %nr% value                                |\n+| JA-100               | thermostat_%nr%  | Number    | the thermostat %nr% value                                 |", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzU1MjcxNg=="}, "originalCommit": {"oid": "a24a1fd3e9b0b42b246535a2373bab007dbe3856"}, "originalPosition": 56}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA1MDIyMjI2OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.jablotron/src/main/java/org/openhab/binding/jablotron/internal/handler/JablotronJa100Handler.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xM1QxNzowMzoyOFrOHQ93Jw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xM1QxODozMzoyMVrOHQ-Z6w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzU1MjgwNw==", "bodyText": "This needs to be of type QuantityType. Please pay attention to use import org.eclipse.smarthome.core.library.unit.SIUnits, as there is another class with the same name in a different package.\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        DecimalType newState = new DecimalType(infos.get(0).getValue());\n          \n          \n            \n                        updateState(channel.getUID(), newState);\n          \n          \n            \n                        updateState(channel.getUID(), QuantityType.valueOf(infos.get(0).getValue(), SIUnits.CELSIUS));", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r487552807", "createdAt": "2020-09-13T17:03:28Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.jablotron/src/main/java/org/openhab/binding/jablotron/internal/handler/JablotronJa100Handler.java", "diffHunk": "@@ -0,0 +1,220 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.jablotron.internal.handler;\n+\n+import static org.openhab.binding.jablotron.JablotronBindingConstants.CACHE_TIMEOUT_MS;\n+import static org.openhab.binding.jablotron.JablotronBindingConstants.CHANNEL_LAST_CHECK_TIME;\n+\n+import java.util.List;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.smarthome.core.cache.ExpiringCache;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.binding.builder.ChannelBuilder;\n+import org.eclipse.smarthome.core.thing.binding.builder.ThingBuilder;\n+import org.eclipse.smarthome.core.thing.type.ChannelTypeUID;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.jablotron.internal.model.JablotronControlResponse;\n+import org.openhab.binding.jablotron.internal.model.JablotronServiceDetailSegment;\n+import org.openhab.binding.jablotron.internal.model.JablotronServiceDetailSegmentInfo;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link JablotronJa100Handler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Ondrej Pecta - Initial contribution\n+ */\n+@NonNullByDefault\n+public class JablotronJa100Handler extends JablotronAlarmHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(JablotronJa100Handler.class);\n+\n+    public JablotronJa100Handler(Thing thing, String alarmName) {\n+        super(thing, alarmName);\n+        dataCache = new ExpiringCache<>(CACHE_TIMEOUT_MS, this::sendGetStatusRequest);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (RefreshType.REFRESH.equals(command)) {\n+            logger.debug(\"refreshing channel: {}\", channelUID.getId());\n+            updateChannel(channelUID.getId());\n+        } else {\n+            if (channelUID.getId().startsWith(\"state_\") && command instanceof StringType) {\n+                scheduler.execute(() -> {\n+                    controlSTATESection(channelUID.getId().toUpperCase(), command.toString());\n+                });\n+            }\n+\n+            if (channelUID.getId().startsWith(\"pgm_\") && command instanceof OnOffType) {\n+                scheduler.execute(() -> {\n+                    controlPGMSection(channelUID.getId().toUpperCase(), command.equals(OnOffType.ON) ? \"set\" : \"unset\");\n+                });\n+            }\n+        }\n+    }\n+\n+    private void updateChannel(String channel) {\n+        if (channel.startsWith(\"state_\") || channel.startsWith(\"pgm_\") || channel.startsWith(\"thermometer_\")\n+                || channel.startsWith(\"thermostat_\")) {\n+            updateSegmentStatus(channel, dataCache.getValue());\n+        } else if (CHANNEL_LAST_CHECK_TIME.equals(channel)) {\n+            // not updating\n+        } else {\n+            updateEventChannel(channel);\n+        }\n+    }\n+\n+    private void createChannel(JablotronServiceDetailSegment section) {\n+        if (section.getSegmentId().startsWith(\"PGM_\")) {\n+            createPGMChannel(section.getSegmentId().toLowerCase(), section.getSegmentName());\n+        } else {\n+            createStateChannel(section.getSegmentId().toLowerCase(), section.getSegmentName());\n+        }\n+    }\n+\n+    private void createTempChannel(String name, String label) {\n+        ChannelTypeUID temperature = new ChannelTypeUID(\"jablotron\", \"temperature\");\n+        ThingBuilder thingBuilder = editThing();\n+        Channel channel = ChannelBuilder.create(new ChannelUID(thing.getUID(), name), \"Number:Temperature\")\n+                .withLabel(label).withType(temperature).build();\n+        thingBuilder.withChannel(channel);\n+        updateThing(thingBuilder.build());\n+    }\n+\n+    private void createThermostatChannel(String name, String label) {\n+        ChannelTypeUID temperature = new ChannelTypeUID(\"jablotron\", \"thermostat\");\n+        ThingBuilder thingBuilder = editThing();\n+        Channel channel = ChannelBuilder.create(new ChannelUID(thing.getUID(), name), \"Number:Temperature\")\n+                .withLabel(label).withType(temperature).build();\n+        thingBuilder.withChannel(channel);\n+        updateThing(thingBuilder.build());\n+    }\n+\n+    private void createPGMChannel(String name, String label) {\n+        ThingBuilder thingBuilder = editThing();\n+        Channel channel = ChannelBuilder.create(new ChannelUID(thing.getUID(), name), \"Switch\").withLabel(label)\n+                .build();\n+        thingBuilder.withChannel(channel);\n+        updateThing(thingBuilder.build());\n+    }\n+\n+    private void createStateChannel(String name, String label) {\n+        ChannelTypeUID alarmStatus = new ChannelTypeUID(\"jablotron\", \"alarm_state\");\n+        ThingBuilder thingBuilder = editThing();\n+        Channel channel = ChannelBuilder.create(new ChannelUID(thing.getUID(), name), \"String\").withLabel(label)\n+                .withType(alarmStatus).build();\n+        thingBuilder.withChannel(channel);\n+        updateThing(thingBuilder.build());\n+    }\n+\n+    @Override\n+    protected void updateSegmentStatus(JablotronServiceDetailSegment segment) {\n+        logger.debug(\"Segment id: {} and status: {}\", segment.getSegmentId(), segment.getSegmentState());\n+        String segmentId = segment.getSegmentId();\n+\n+        if (segmentId.startsWith(\"STATE_\") || segmentId.startsWith(\"PGM_\")) {\n+            processSection(segment);\n+        } else if (segmentId.startsWith(\"THERMOMETER_\")) {\n+            processThermometer(segment);\n+        } else if (segmentId.startsWith(\"THERMOSTAT_\")) {\n+            processThermostat(segment);\n+        } else {\n+            logger.debug(\"Unknown segment received: {} with state: {}\", segment.getSegmentId(),\n+                    segment.getSegmentState());\n+        }\n+    }\n+\n+    private void processSection(JablotronServiceDetailSegment segment) {\n+        String segmentId = segment.getSegmentId().toLowerCase();\n+        Channel channel = getThing().getChannel(segmentId);\n+        if (channel == null) {\n+            logger.debug(\"Creating a new channel: {}\", segmentId);\n+            createChannel(segment);\n+        }\n+        channel = getThing().getChannel(segmentId);\n+        if (channel != null) {\n+            logger.debug(\"Updating channel: {} to value: {}\", channel.getUID(), segment.getSegmentState());\n+            State newState;\n+            if (segmentId.startsWith(\"PGM_\")) {\n+                newState = \"unset\".equals(segment.getSegmentState()) ? OnOffType.OFF : OnOffType.ON;\n+            } else {\n+                newState = new StringType(segment.getSegmentState());\n+            }\n+            updateState(channel.getUID(), newState);\n+        } else {\n+            logger.debug(\"The channel: {} still doesn't exist!\", segmentId);\n+        }\n+    }\n+\n+    private void processThermometer(JablotronServiceDetailSegment segment) {\n+        String segmentId = segment.getSegmentId().toLowerCase();\n+        Channel channel = getThing().getChannel(segmentId);\n+        if (channel == null) {\n+            logger.debug(\"Creating a new temperature channel: {}\", segmentId);\n+            createTempChannel(segmentId, segment.getSegmentName());\n+        }\n+        updateTemperatureChannel(channel, segment);\n+    }\n+\n+    private void processThermostat(JablotronServiceDetailSegment segment) {\n+        String segmentId = segment.getSegmentId().toLowerCase();\n+        Channel channel = getThing().getChannel(segmentId);\n+        if (channel == null) {\n+            logger.debug(\"Creating a new thermostat channel: {}\", segmentId);\n+            createThermostatChannel(segmentId, segment.getSegmentName());\n+        }\n+        updateTemperatureChannel(channel, segment);\n+    }\n+\n+    private void updateTemperatureChannel(Channel channel, JablotronServiceDetailSegment segment) {\n+        List<JablotronServiceDetailSegmentInfo> infos = segment.getSegmentInfos();\n+        if (infos.size() > 0) {\n+            logger.debug(\"Found value: {} and type: {}\", infos.get(0).getValue(), infos.get(0).getType());\n+            DecimalType newState = new DecimalType(infos.get(0).getValue());\n+            updateState(channel.getUID(), newState);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a24a1fd3e9b0b42b246535a2373bab007dbe3856"}, "originalPosition": 194}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzU2MTcwNw==", "bodyText": "OK", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r487561707", "createdAt": "2020-09-13T18:33:21Z", "author": {"login": "octa22"}, "path": "bundles/org.openhab.binding.jablotron/src/main/java/org/openhab/binding/jablotron/internal/handler/JablotronJa100Handler.java", "diffHunk": "@@ -0,0 +1,220 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.jablotron.internal.handler;\n+\n+import static org.openhab.binding.jablotron.JablotronBindingConstants.CACHE_TIMEOUT_MS;\n+import static org.openhab.binding.jablotron.JablotronBindingConstants.CHANNEL_LAST_CHECK_TIME;\n+\n+import java.util.List;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.smarthome.core.cache.ExpiringCache;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.binding.builder.ChannelBuilder;\n+import org.eclipse.smarthome.core.thing.binding.builder.ThingBuilder;\n+import org.eclipse.smarthome.core.thing.type.ChannelTypeUID;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.jablotron.internal.model.JablotronControlResponse;\n+import org.openhab.binding.jablotron.internal.model.JablotronServiceDetailSegment;\n+import org.openhab.binding.jablotron.internal.model.JablotronServiceDetailSegmentInfo;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link JablotronJa100Handler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Ondrej Pecta - Initial contribution\n+ */\n+@NonNullByDefault\n+public class JablotronJa100Handler extends JablotronAlarmHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(JablotronJa100Handler.class);\n+\n+    public JablotronJa100Handler(Thing thing, String alarmName) {\n+        super(thing, alarmName);\n+        dataCache = new ExpiringCache<>(CACHE_TIMEOUT_MS, this::sendGetStatusRequest);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (RefreshType.REFRESH.equals(command)) {\n+            logger.debug(\"refreshing channel: {}\", channelUID.getId());\n+            updateChannel(channelUID.getId());\n+        } else {\n+            if (channelUID.getId().startsWith(\"state_\") && command instanceof StringType) {\n+                scheduler.execute(() -> {\n+                    controlSTATESection(channelUID.getId().toUpperCase(), command.toString());\n+                });\n+            }\n+\n+            if (channelUID.getId().startsWith(\"pgm_\") && command instanceof OnOffType) {\n+                scheduler.execute(() -> {\n+                    controlPGMSection(channelUID.getId().toUpperCase(), command.equals(OnOffType.ON) ? \"set\" : \"unset\");\n+                });\n+            }\n+        }\n+    }\n+\n+    private void updateChannel(String channel) {\n+        if (channel.startsWith(\"state_\") || channel.startsWith(\"pgm_\") || channel.startsWith(\"thermometer_\")\n+                || channel.startsWith(\"thermostat_\")) {\n+            updateSegmentStatus(channel, dataCache.getValue());\n+        } else if (CHANNEL_LAST_CHECK_TIME.equals(channel)) {\n+            // not updating\n+        } else {\n+            updateEventChannel(channel);\n+        }\n+    }\n+\n+    private void createChannel(JablotronServiceDetailSegment section) {\n+        if (section.getSegmentId().startsWith(\"PGM_\")) {\n+            createPGMChannel(section.getSegmentId().toLowerCase(), section.getSegmentName());\n+        } else {\n+            createStateChannel(section.getSegmentId().toLowerCase(), section.getSegmentName());\n+        }\n+    }\n+\n+    private void createTempChannel(String name, String label) {\n+        ChannelTypeUID temperature = new ChannelTypeUID(\"jablotron\", \"temperature\");\n+        ThingBuilder thingBuilder = editThing();\n+        Channel channel = ChannelBuilder.create(new ChannelUID(thing.getUID(), name), \"Number:Temperature\")\n+                .withLabel(label).withType(temperature).build();\n+        thingBuilder.withChannel(channel);\n+        updateThing(thingBuilder.build());\n+    }\n+\n+    private void createThermostatChannel(String name, String label) {\n+        ChannelTypeUID temperature = new ChannelTypeUID(\"jablotron\", \"thermostat\");\n+        ThingBuilder thingBuilder = editThing();\n+        Channel channel = ChannelBuilder.create(new ChannelUID(thing.getUID(), name), \"Number:Temperature\")\n+                .withLabel(label).withType(temperature).build();\n+        thingBuilder.withChannel(channel);\n+        updateThing(thingBuilder.build());\n+    }\n+\n+    private void createPGMChannel(String name, String label) {\n+        ThingBuilder thingBuilder = editThing();\n+        Channel channel = ChannelBuilder.create(new ChannelUID(thing.getUID(), name), \"Switch\").withLabel(label)\n+                .build();\n+        thingBuilder.withChannel(channel);\n+        updateThing(thingBuilder.build());\n+    }\n+\n+    private void createStateChannel(String name, String label) {\n+        ChannelTypeUID alarmStatus = new ChannelTypeUID(\"jablotron\", \"alarm_state\");\n+        ThingBuilder thingBuilder = editThing();\n+        Channel channel = ChannelBuilder.create(new ChannelUID(thing.getUID(), name), \"String\").withLabel(label)\n+                .withType(alarmStatus).build();\n+        thingBuilder.withChannel(channel);\n+        updateThing(thingBuilder.build());\n+    }\n+\n+    @Override\n+    protected void updateSegmentStatus(JablotronServiceDetailSegment segment) {\n+        logger.debug(\"Segment id: {} and status: {}\", segment.getSegmentId(), segment.getSegmentState());\n+        String segmentId = segment.getSegmentId();\n+\n+        if (segmentId.startsWith(\"STATE_\") || segmentId.startsWith(\"PGM_\")) {\n+            processSection(segment);\n+        } else if (segmentId.startsWith(\"THERMOMETER_\")) {\n+            processThermometer(segment);\n+        } else if (segmentId.startsWith(\"THERMOSTAT_\")) {\n+            processThermostat(segment);\n+        } else {\n+            logger.debug(\"Unknown segment received: {} with state: {}\", segment.getSegmentId(),\n+                    segment.getSegmentState());\n+        }\n+    }\n+\n+    private void processSection(JablotronServiceDetailSegment segment) {\n+        String segmentId = segment.getSegmentId().toLowerCase();\n+        Channel channel = getThing().getChannel(segmentId);\n+        if (channel == null) {\n+            logger.debug(\"Creating a new channel: {}\", segmentId);\n+            createChannel(segment);\n+        }\n+        channel = getThing().getChannel(segmentId);\n+        if (channel != null) {\n+            logger.debug(\"Updating channel: {} to value: {}\", channel.getUID(), segment.getSegmentState());\n+            State newState;\n+            if (segmentId.startsWith(\"PGM_\")) {\n+                newState = \"unset\".equals(segment.getSegmentState()) ? OnOffType.OFF : OnOffType.ON;\n+            } else {\n+                newState = new StringType(segment.getSegmentState());\n+            }\n+            updateState(channel.getUID(), newState);\n+        } else {\n+            logger.debug(\"The channel: {} still doesn't exist!\", segmentId);\n+        }\n+    }\n+\n+    private void processThermometer(JablotronServiceDetailSegment segment) {\n+        String segmentId = segment.getSegmentId().toLowerCase();\n+        Channel channel = getThing().getChannel(segmentId);\n+        if (channel == null) {\n+            logger.debug(\"Creating a new temperature channel: {}\", segmentId);\n+            createTempChannel(segmentId, segment.getSegmentName());\n+        }\n+        updateTemperatureChannel(channel, segment);\n+    }\n+\n+    private void processThermostat(JablotronServiceDetailSegment segment) {\n+        String segmentId = segment.getSegmentId().toLowerCase();\n+        Channel channel = getThing().getChannel(segmentId);\n+        if (channel == null) {\n+            logger.debug(\"Creating a new thermostat channel: {}\", segmentId);\n+            createThermostatChannel(segmentId, segment.getSegmentName());\n+        }\n+        updateTemperatureChannel(channel, segment);\n+    }\n+\n+    private void updateTemperatureChannel(Channel channel, JablotronServiceDetailSegment segment) {\n+        List<JablotronServiceDetailSegmentInfo> infos = segment.getSegmentInfos();\n+        if (infos.size() > 0) {\n+            logger.debug(\"Found value: {} and type: {}\", infos.get(0).getValue(), infos.get(0).getType());\n+            DecimalType newState = new DecimalType(infos.get(0).getValue());\n+            updateState(channel.getUID(), newState);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzU1MjgwNw=="}, "originalCommit": {"oid": "a24a1fd3e9b0b42b246535a2373bab007dbe3856"}, "originalPosition": 194}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA1MDIzMDIzOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.jablotron/src/main/java/org/openhab/binding/jablotron/internal/discovery/JablotronDiscoveryService.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xM1QxNzoxMzo0NVrOHQ97Ag==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xM1QxODozNDo0OVrOHQ-aew==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzU1Mzc5NA==", "bodyText": "The field could theoretically be modified by another thread exactly between the null check and the access at isCancelled(). This is why the compiler generates a warning. To mitigate this, you can store the field to a local variable before checking it:\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    if (discoveryJob == null || discoveryJob.isCancelled()) {\n          \n          \n            \n                        discoveryJob = scheduler.scheduleWithFixedDelay(this::startDiscovery, 10, 3600, TimeUnit.SECONDS);\n          \n          \n            \n                    }\n          \n          \n            \n                    ScheduledFuture<?> localDiscoveryJob = discoveryJob;\n          \n          \n            \n            \n          \n          \n            \n                    if (localDiscoveryJob == null || localDiscoveryJob.isCancelled()) {\n          \n          \n            \n                        discoveryJob = scheduler.scheduleWithFixedDelay(this::startDiscovery, 10, 3600, TimeUnit.SECONDS);\n          \n          \n            \n                    }", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r487553794", "createdAt": "2020-09-13T17:13:45Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.jablotron/src/main/java/org/openhab/binding/jablotron/internal/discovery/JablotronDiscoveryService.java", "diffHunk": "@@ -0,0 +1,172 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.jablotron.internal.discovery;\n+\n+import static org.openhab.binding.jablotron.JablotronBindingConstants.*;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.config.discovery.*;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.thing.ThingUID;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.openhab.binding.jablotron.internal.handler.JablotronBridgeHandler;\n+import org.openhab.binding.jablotron.internal.model.JablotronDiscoveredService;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link JablotronDiscoveryService} is responsible for the thing discovery\n+ * process.\n+ *\n+ * @author Ondrej Pecta - Initial contribution\n+ */\n+@NonNullByDefault\n+public class JablotronDiscoveryService extends AbstractDiscoveryService\n+        implements DiscoveryService, ThingHandlerService {\n+    private final Logger logger = LoggerFactory.getLogger(JablotronDiscoveryService.class);\n+\n+    private @Nullable JablotronBridgeHandler bridgeHandler;\n+\n+    private @Nullable ScheduledFuture<?> discoveryJob = null;\n+\n+    public JablotronDiscoveryService() {\n+        super(DISCOVERY_TIMEOUT_SEC);\n+        logger.debug(\"Creating discovery service\");\n+    }\n+\n+    private void startDiscovery() {\n+        if (bridgeHandler != null && ThingStatus.ONLINE == bridgeHandler.getThing().getStatus()) {\n+            discoverServices();\n+        }\n+    }\n+\n+    @Override\n+    public void setThingHandler(@Nullable ThingHandler thingHandler) {\n+        if (thingHandler instanceof JablotronBridgeHandler) {\n+            bridgeHandler = (JablotronBridgeHandler) thingHandler;\n+        }\n+    }\n+\n+    @Override\n+    public @Nullable ThingHandler getThingHandler() {\n+        return bridgeHandler;\n+    }\n+\n+    @Override\n+    protected void stopBackgroundDiscovery() {\n+        super.stopBackgroundDiscovery();\n+        if (discoveryJob != null) {\n+            discoveryJob.cancel(true);\n+        }\n+    }\n+\n+    @Override\n+    protected void startBackgroundDiscovery() {\n+        logger.debug(\"Starting Jablotron background discovery\");\n+\n+        if (discoveryJob == null || discoveryJob.isCancelled()) {\n+            discoveryJob = scheduler.scheduleWithFixedDelay(this::startDiscovery, 10, 3600, TimeUnit.SECONDS);\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a24a1fd3e9b0b42b246535a2373bab007dbe3856"}, "originalPosition": 89}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzU2MTg1MQ==", "bodyText": "ok", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r487561851", "createdAt": "2020-09-13T18:34:49Z", "author": {"login": "octa22"}, "path": "bundles/org.openhab.binding.jablotron/src/main/java/org/openhab/binding/jablotron/internal/discovery/JablotronDiscoveryService.java", "diffHunk": "@@ -0,0 +1,172 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.jablotron.internal.discovery;\n+\n+import static org.openhab.binding.jablotron.JablotronBindingConstants.*;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.config.discovery.*;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.thing.ThingUID;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.openhab.binding.jablotron.internal.handler.JablotronBridgeHandler;\n+import org.openhab.binding.jablotron.internal.model.JablotronDiscoveredService;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link JablotronDiscoveryService} is responsible for the thing discovery\n+ * process.\n+ *\n+ * @author Ondrej Pecta - Initial contribution\n+ */\n+@NonNullByDefault\n+public class JablotronDiscoveryService extends AbstractDiscoveryService\n+        implements DiscoveryService, ThingHandlerService {\n+    private final Logger logger = LoggerFactory.getLogger(JablotronDiscoveryService.class);\n+\n+    private @Nullable JablotronBridgeHandler bridgeHandler;\n+\n+    private @Nullable ScheduledFuture<?> discoveryJob = null;\n+\n+    public JablotronDiscoveryService() {\n+        super(DISCOVERY_TIMEOUT_SEC);\n+        logger.debug(\"Creating discovery service\");\n+    }\n+\n+    private void startDiscovery() {\n+        if (bridgeHandler != null && ThingStatus.ONLINE == bridgeHandler.getThing().getStatus()) {\n+            discoverServices();\n+        }\n+    }\n+\n+    @Override\n+    public void setThingHandler(@Nullable ThingHandler thingHandler) {\n+        if (thingHandler instanceof JablotronBridgeHandler) {\n+            bridgeHandler = (JablotronBridgeHandler) thingHandler;\n+        }\n+    }\n+\n+    @Override\n+    public @Nullable ThingHandler getThingHandler() {\n+        return bridgeHandler;\n+    }\n+\n+    @Override\n+    protected void stopBackgroundDiscovery() {\n+        super.stopBackgroundDiscovery();\n+        if (discoveryJob != null) {\n+            discoveryJob.cancel(true);\n+        }\n+    }\n+\n+    @Override\n+    protected void startBackgroundDiscovery() {\n+        logger.debug(\"Starting Jablotron background discovery\");\n+\n+        if (discoveryJob == null || discoveryJob.isCancelled()) {\n+            discoveryJob = scheduler.scheduleWithFixedDelay(this::startDiscovery, 10, 3600, TimeUnit.SECONDS);\n+        }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzU1Mzc5NA=="}, "originalCommit": {"oid": "a24a1fd3e9b0b42b246535a2373bab007dbe3856"}, "originalPosition": 89}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA1MDIzMTY2OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.jablotron/src/main/java/org/openhab/binding/jablotron/internal/discovery/JablotronDiscoveryService.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xM1QxNzoxNToxN1rOHQ97oQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xM1QxODo0MDoyNVrOHQ-cvA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzU1Mzk1Mw==", "bodyText": "Here too and same for below.\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    ThingUID thingUID = new ThingUID(THING_TYPE_OASIS, bridgeHandler.getThing().getUID(), serviceId);\n          \n          \n            \n                    JablotronBridgeHandler localBridgeHandler = bridgeHandler;\n          \n          \n            \n                    if (localBridgeHandler != null) {\n          \n          \n            \n                        ThingUID thingUID = new ThingUID(THING_TYPE_OASIS, localBridgeHandler.getThing().getUID(), serviceId);", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r487553953", "createdAt": "2020-09-13T17:15:17Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.jablotron/src/main/java/org/openhab/binding/jablotron/internal/discovery/JablotronDiscoveryService.java", "diffHunk": "@@ -0,0 +1,172 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.jablotron.internal.discovery;\n+\n+import static org.openhab.binding.jablotron.JablotronBindingConstants.*;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.config.discovery.*;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.thing.ThingUID;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.openhab.binding.jablotron.internal.handler.JablotronBridgeHandler;\n+import org.openhab.binding.jablotron.internal.model.JablotronDiscoveredService;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link JablotronDiscoveryService} is responsible for the thing discovery\n+ * process.\n+ *\n+ * @author Ondrej Pecta - Initial contribution\n+ */\n+@NonNullByDefault\n+public class JablotronDiscoveryService extends AbstractDiscoveryService\n+        implements DiscoveryService, ThingHandlerService {\n+    private final Logger logger = LoggerFactory.getLogger(JablotronDiscoveryService.class);\n+\n+    private @Nullable JablotronBridgeHandler bridgeHandler;\n+\n+    private @Nullable ScheduledFuture<?> discoveryJob = null;\n+\n+    public JablotronDiscoveryService() {\n+        super(DISCOVERY_TIMEOUT_SEC);\n+        logger.debug(\"Creating discovery service\");\n+    }\n+\n+    private void startDiscovery() {\n+        if (bridgeHandler != null && ThingStatus.ONLINE == bridgeHandler.getThing().getStatus()) {\n+            discoverServices();\n+        }\n+    }\n+\n+    @Override\n+    public void setThingHandler(@Nullable ThingHandler thingHandler) {\n+        if (thingHandler instanceof JablotronBridgeHandler) {\n+            bridgeHandler = (JablotronBridgeHandler) thingHandler;\n+        }\n+    }\n+\n+    @Override\n+    public @Nullable ThingHandler getThingHandler() {\n+        return bridgeHandler;\n+    }\n+\n+    @Override\n+    protected void stopBackgroundDiscovery() {\n+        super.stopBackgroundDiscovery();\n+        if (discoveryJob != null) {\n+            discoveryJob.cancel(true);\n+        }\n+    }\n+\n+    @Override\n+    protected void startBackgroundDiscovery() {\n+        logger.debug(\"Starting Jablotron background discovery\");\n+\n+        if (discoveryJob == null || discoveryJob.isCancelled()) {\n+            discoveryJob = scheduler.scheduleWithFixedDelay(this::startDiscovery, 10, 3600, TimeUnit.SECONDS);\n+        }\n+    }\n+\n+    @Override\n+    public void activate() {\n+        super.activate(null);\n+    }\n+\n+    @Override\n+    public void deactivate() {\n+        super.deactivate();\n+    }\n+\n+    @Override\n+    public Set<ThingTypeUID> getSupportedThingTypes() {\n+        return SUPPORTED_THING_TYPES_UIDS;\n+    }\n+\n+    @Override\n+    protected void startScan() {\n+        logger.debug(\"Starting scanning for items...\");\n+        startDiscovery();\n+    }\n+\n+    public void oasisDiscovered(String label, String serviceId) {\n+        ThingUID thingUID = new ThingUID(THING_TYPE_OASIS, bridgeHandler.getThing().getUID(), serviceId);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a24a1fd3e9b0b42b246535a2373bab007dbe3856"}, "originalPosition": 114}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzU2MjQyOA==", "bodyText": "ok, done", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r487562428", "createdAt": "2020-09-13T18:40:25Z", "author": {"login": "octa22"}, "path": "bundles/org.openhab.binding.jablotron/src/main/java/org/openhab/binding/jablotron/internal/discovery/JablotronDiscoveryService.java", "diffHunk": "@@ -0,0 +1,172 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.jablotron.internal.discovery;\n+\n+import static org.openhab.binding.jablotron.JablotronBindingConstants.*;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.config.discovery.*;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.thing.ThingUID;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.openhab.binding.jablotron.internal.handler.JablotronBridgeHandler;\n+import org.openhab.binding.jablotron.internal.model.JablotronDiscoveredService;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link JablotronDiscoveryService} is responsible for the thing discovery\n+ * process.\n+ *\n+ * @author Ondrej Pecta - Initial contribution\n+ */\n+@NonNullByDefault\n+public class JablotronDiscoveryService extends AbstractDiscoveryService\n+        implements DiscoveryService, ThingHandlerService {\n+    private final Logger logger = LoggerFactory.getLogger(JablotronDiscoveryService.class);\n+\n+    private @Nullable JablotronBridgeHandler bridgeHandler;\n+\n+    private @Nullable ScheduledFuture<?> discoveryJob = null;\n+\n+    public JablotronDiscoveryService() {\n+        super(DISCOVERY_TIMEOUT_SEC);\n+        logger.debug(\"Creating discovery service\");\n+    }\n+\n+    private void startDiscovery() {\n+        if (bridgeHandler != null && ThingStatus.ONLINE == bridgeHandler.getThing().getStatus()) {\n+            discoverServices();\n+        }\n+    }\n+\n+    @Override\n+    public void setThingHandler(@Nullable ThingHandler thingHandler) {\n+        if (thingHandler instanceof JablotronBridgeHandler) {\n+            bridgeHandler = (JablotronBridgeHandler) thingHandler;\n+        }\n+    }\n+\n+    @Override\n+    public @Nullable ThingHandler getThingHandler() {\n+        return bridgeHandler;\n+    }\n+\n+    @Override\n+    protected void stopBackgroundDiscovery() {\n+        super.stopBackgroundDiscovery();\n+        if (discoveryJob != null) {\n+            discoveryJob.cancel(true);\n+        }\n+    }\n+\n+    @Override\n+    protected void startBackgroundDiscovery() {\n+        logger.debug(\"Starting Jablotron background discovery\");\n+\n+        if (discoveryJob == null || discoveryJob.isCancelled()) {\n+            discoveryJob = scheduler.scheduleWithFixedDelay(this::startDiscovery, 10, 3600, TimeUnit.SECONDS);\n+        }\n+    }\n+\n+    @Override\n+    public void activate() {\n+        super.activate(null);\n+    }\n+\n+    @Override\n+    public void deactivate() {\n+        super.deactivate();\n+    }\n+\n+    @Override\n+    public Set<ThingTypeUID> getSupportedThingTypes() {\n+        return SUPPORTED_THING_TYPES_UIDS;\n+    }\n+\n+    @Override\n+    protected void startScan() {\n+        logger.debug(\"Starting scanning for items...\");\n+        startDiscovery();\n+    }\n+\n+    public void oasisDiscovered(String label, String serviceId) {\n+        ThingUID thingUID = new ThingUID(THING_TYPE_OASIS, bridgeHandler.getThing().getUID(), serviceId);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzU1Mzk1Mw=="}, "originalCommit": {"oid": "a24a1fd3e9b0b42b246535a2373bab007dbe3856"}, "originalPosition": 114}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA1MDIzMjM3OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.jablotron/src/main/java/org/openhab/binding/jablotron/internal/handler/JablotronJa100Handler.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xM1QxNzoxNjowOFrOHQ979A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xM1QxODo1MzoxM1rOHQ-iKQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzU1NDAzNg==", "bodyText": "Here for dataCache.", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r487554036", "createdAt": "2020-09-13T17:16:08Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.jablotron/src/main/java/org/openhab/binding/jablotron/internal/handler/JablotronJa100Handler.java", "diffHunk": "@@ -0,0 +1,220 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.jablotron.internal.handler;\n+\n+import static org.openhab.binding.jablotron.JablotronBindingConstants.CACHE_TIMEOUT_MS;\n+import static org.openhab.binding.jablotron.JablotronBindingConstants.CHANNEL_LAST_CHECK_TIME;\n+\n+import java.util.List;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.smarthome.core.cache.ExpiringCache;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.binding.builder.ChannelBuilder;\n+import org.eclipse.smarthome.core.thing.binding.builder.ThingBuilder;\n+import org.eclipse.smarthome.core.thing.type.ChannelTypeUID;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.jablotron.internal.model.JablotronControlResponse;\n+import org.openhab.binding.jablotron.internal.model.JablotronServiceDetailSegment;\n+import org.openhab.binding.jablotron.internal.model.JablotronServiceDetailSegmentInfo;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link JablotronJa100Handler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Ondrej Pecta - Initial contribution\n+ */\n+@NonNullByDefault\n+public class JablotronJa100Handler extends JablotronAlarmHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(JablotronJa100Handler.class);\n+\n+    public JablotronJa100Handler(Thing thing, String alarmName) {\n+        super(thing, alarmName);\n+        dataCache = new ExpiringCache<>(CACHE_TIMEOUT_MS, this::sendGetStatusRequest);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (RefreshType.REFRESH.equals(command)) {\n+            logger.debug(\"refreshing channel: {}\", channelUID.getId());\n+            updateChannel(channelUID.getId());\n+        } else {\n+            if (channelUID.getId().startsWith(\"state_\") && command instanceof StringType) {\n+                scheduler.execute(() -> {\n+                    controlSTATESection(channelUID.getId().toUpperCase(), command.toString());\n+                });\n+            }\n+\n+            if (channelUID.getId().startsWith(\"pgm_\") && command instanceof OnOffType) {\n+                scheduler.execute(() -> {\n+                    controlPGMSection(channelUID.getId().toUpperCase(), command.equals(OnOffType.ON) ? \"set\" : \"unset\");\n+                });\n+            }\n+        }\n+    }\n+\n+    private void updateChannel(String channel) {\n+        if (channel.startsWith(\"state_\") || channel.startsWith(\"pgm_\") || channel.startsWith(\"thermometer_\")\n+                || channel.startsWith(\"thermostat_\")) {\n+            updateSegmentStatus(channel, dataCache.getValue());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a24a1fd3e9b0b42b246535a2373bab007dbe3856"}, "originalPosition": 79}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzU2MzgxNw==", "bodyText": "done", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r487563817", "createdAt": "2020-09-13T18:53:13Z", "author": {"login": "octa22"}, "path": "bundles/org.openhab.binding.jablotron/src/main/java/org/openhab/binding/jablotron/internal/handler/JablotronJa100Handler.java", "diffHunk": "@@ -0,0 +1,220 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.jablotron.internal.handler;\n+\n+import static org.openhab.binding.jablotron.JablotronBindingConstants.CACHE_TIMEOUT_MS;\n+import static org.openhab.binding.jablotron.JablotronBindingConstants.CHANNEL_LAST_CHECK_TIME;\n+\n+import java.util.List;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.smarthome.core.cache.ExpiringCache;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.binding.builder.ChannelBuilder;\n+import org.eclipse.smarthome.core.thing.binding.builder.ThingBuilder;\n+import org.eclipse.smarthome.core.thing.type.ChannelTypeUID;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.jablotron.internal.model.JablotronControlResponse;\n+import org.openhab.binding.jablotron.internal.model.JablotronServiceDetailSegment;\n+import org.openhab.binding.jablotron.internal.model.JablotronServiceDetailSegmentInfo;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link JablotronJa100Handler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Ondrej Pecta - Initial contribution\n+ */\n+@NonNullByDefault\n+public class JablotronJa100Handler extends JablotronAlarmHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(JablotronJa100Handler.class);\n+\n+    public JablotronJa100Handler(Thing thing, String alarmName) {\n+        super(thing, alarmName);\n+        dataCache = new ExpiringCache<>(CACHE_TIMEOUT_MS, this::sendGetStatusRequest);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (RefreshType.REFRESH.equals(command)) {\n+            logger.debug(\"refreshing channel: {}\", channelUID.getId());\n+            updateChannel(channelUID.getId());\n+        } else {\n+            if (channelUID.getId().startsWith(\"state_\") && command instanceof StringType) {\n+                scheduler.execute(() -> {\n+                    controlSTATESection(channelUID.getId().toUpperCase(), command.toString());\n+                });\n+            }\n+\n+            if (channelUID.getId().startsWith(\"pgm_\") && command instanceof OnOffType) {\n+                scheduler.execute(() -> {\n+                    controlPGMSection(channelUID.getId().toUpperCase(), command.equals(OnOffType.ON) ? \"set\" : \"unset\");\n+                });\n+            }\n+        }\n+    }\n+\n+    private void updateChannel(String channel) {\n+        if (channel.startsWith(\"state_\") || channel.startsWith(\"pgm_\") || channel.startsWith(\"thermometer_\")\n+                || channel.startsWith(\"thermostat_\")) {\n+            updateSegmentStatus(channel, dataCache.getValue());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzU1NDAzNg=="}, "originalCommit": {"oid": "a24a1fd3e9b0b42b246535a2373bab007dbe3856"}, "originalPosition": 79}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA1MDIzMjQ3OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.jablotron/src/main/java/org/openhab/binding/jablotron/internal/handler/JablotronOasisHandler.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xM1QxNzoxNjozOFrOHQ98Bg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xM1QxODo1MzoyNFrOHQ-iOg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzU1NDA1NA==", "bodyText": "And here.", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r487554054", "createdAt": "2020-09-13T17:16:38Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.jablotron/src/main/java/org/openhab/binding/jablotron/internal/handler/JablotronOasisHandler.java", "diffHunk": "@@ -0,0 +1,155 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.jablotron.internal.handler;\n+\n+import static org.openhab.binding.jablotron.JablotronBindingConstants.*;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.cache.ExpiringCache;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.jablotron.internal.model.JablotronControlResponse;\n+import org.openhab.binding.jablotron.internal.model.JablotronServiceDetailSegment;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link JablotronOasisHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Ondrej Pecta - Initial contribution\n+ */\n+@NonNullByDefault\n+public class JablotronOasisHandler extends JablotronAlarmHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(JablotronOasisHandler.class);\n+\n+    public JablotronOasisHandler(Thing thing, String alarmName) {\n+        super(thing, alarmName);\n+        dataCache = new ExpiringCache<>(CACHE_TIMEOUT_MS, this::sendGetStatusRequest);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (RefreshType.REFRESH.equals(command)) {\n+            logger.debug(\"refreshing channel: {}\", channelUID.getId());\n+            updateChannel(channelUID.getId());\n+        } else {\n+            switch (channelUID.getId()) {\n+                case CHANNEL_COMMAND:\n+                    if (command instanceof StringType) {\n+                        scheduler.execute(() -> {\n+                            sendCommand(command.toString());\n+                        });\n+                    }\n+                    break;\n+                case CHANNEL_STATUS_PGX:\n+                    if (command instanceof OnOffType) {\n+                        scheduler.execute(() -> {\n+                            controlSection(\"PGM_1\", command.equals(OnOffType.ON) ? \"set\" : \"unset\");\n+                        });\n+                    }\n+                    break;\n+                case CHANNEL_STATUS_PGY:\n+                    if (command instanceof OnOffType) {\n+                        scheduler.execute(() -> {\n+                            controlSection(\"PGM_2\", command.equals(OnOffType.ON) ? \"set\" : \"unset\");\n+                        });\n+                    }\n+                    break;\n+            }\n+        }\n+    }\n+\n+    private void updateChannel(String channel) {\n+        switch (channel) {\n+            case CHANNEL_STATUS_A:\n+                updateSegmentStatus(\"STATE_1\", dataCache.getValue());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a24a1fd3e9b0b42b246535a2373bab007dbe3856"}, "originalPosition": 85}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzU2MzgzNA==", "bodyText": "done", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r487563834", "createdAt": "2020-09-13T18:53:24Z", "author": {"login": "octa22"}, "path": "bundles/org.openhab.binding.jablotron/src/main/java/org/openhab/binding/jablotron/internal/handler/JablotronOasisHandler.java", "diffHunk": "@@ -0,0 +1,155 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.jablotron.internal.handler;\n+\n+import static org.openhab.binding.jablotron.JablotronBindingConstants.*;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.cache.ExpiringCache;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.jablotron.internal.model.JablotronControlResponse;\n+import org.openhab.binding.jablotron.internal.model.JablotronServiceDetailSegment;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link JablotronOasisHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Ondrej Pecta - Initial contribution\n+ */\n+@NonNullByDefault\n+public class JablotronOasisHandler extends JablotronAlarmHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(JablotronOasisHandler.class);\n+\n+    public JablotronOasisHandler(Thing thing, String alarmName) {\n+        super(thing, alarmName);\n+        dataCache = new ExpiringCache<>(CACHE_TIMEOUT_MS, this::sendGetStatusRequest);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (RefreshType.REFRESH.equals(command)) {\n+            logger.debug(\"refreshing channel: {}\", channelUID.getId());\n+            updateChannel(channelUID.getId());\n+        } else {\n+            switch (channelUID.getId()) {\n+                case CHANNEL_COMMAND:\n+                    if (command instanceof StringType) {\n+                        scheduler.execute(() -> {\n+                            sendCommand(command.toString());\n+                        });\n+                    }\n+                    break;\n+                case CHANNEL_STATUS_PGX:\n+                    if (command instanceof OnOffType) {\n+                        scheduler.execute(() -> {\n+                            controlSection(\"PGM_1\", command.equals(OnOffType.ON) ? \"set\" : \"unset\");\n+                        });\n+                    }\n+                    break;\n+                case CHANNEL_STATUS_PGY:\n+                    if (command instanceof OnOffType) {\n+                        scheduler.execute(() -> {\n+                            controlSection(\"PGM_2\", command.equals(OnOffType.ON) ? \"set\" : \"unset\");\n+                        });\n+                    }\n+                    break;\n+            }\n+        }\n+    }\n+\n+    private void updateChannel(String channel) {\n+        switch (channel) {\n+            case CHANNEL_STATUS_A:\n+                updateSegmentStatus(\"STATE_1\", dataCache.getValue());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzU1NDA1NA=="}, "originalCommit": {"oid": "a24a1fd3e9b0b42b246535a2373bab007dbe3856"}, "originalPosition": 85}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 910, "cost": 1, "resetAt": "2021-11-12T20:44:06Z"}}}