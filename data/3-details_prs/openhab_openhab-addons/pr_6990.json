{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzcyODc1ODYz", "number": 6990, "title": "[jablotron] Jablotron binding initial contribution", "bodyText": "This is the initial contribution for the Jablotron alarm binding.\nhttps://www.jablotron.com/en/jablotron-products/alarms/alarms-houses/\nThe currently supported things are JA-80 OASIS, JA-100 and JA100+/JA100F\nThe community thread exists:\nhttps://community.openhab.org/t/jablotron-alarm-binding-for-openhab-2-x/41930\nIn the beginning of 2020 the binding has been completely rewritten to work against the Jablotron v1.6 API, but still needs a bit of testing (especially the JA100 thing), so it is WIP for now.", "createdAt": "2020-02-09T21:28:02Z", "url": "https://github.com/openhab/openhab-addons/pull/6990", "merged": true, "mergeCommit": {"oid": "de1d2a35e8d331f8ebfc908347e0cd1254e0cdc6"}, "closed": true, "closedAt": "2020-09-13T20:34:46Z", "author": {"login": "octa22"}, "timelineItems": {"totalCount": 51, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcCv_uAABqjMwMjA5MTc5MTI=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdIjZhZgFqTQ4NzMzMTc5Mw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "8a3a7463ddc178103bc352b042fd099ee9933ca6", "author": {"user": {"login": "octa22", "name": "Ondrej Pecta"}}, "url": "https://github.com/openhab/openhab-addons/commit/8a3a7463ddc178103bc352b042fd099ee9933ca6", "committedDate": "2020-02-09T21:15:57Z", "message": "[jablotron] Jablotron binding initial contribution\n\nSigned-off-by: Ondrej Pecta <opecta@gmail.com>"}, "afterCommit": {"oid": "16a96c4dd5c1040b1454049737a29a23954838dc", "author": {"user": {"login": "octa22", "name": "Ondrej Pecta"}}, "url": "https://github.com/openhab/openhab-addons/commit/16a96c4dd5c1040b1454049737a29a23954838dc", "committedDate": "2020-02-09T22:08:51Z", "message": "[jablotron] Jablotron binding initial contribution\n\nSigned-off-by: Ondrej Pecta <opecta@gmail.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "16a96c4dd5c1040b1454049737a29a23954838dc", "author": {"user": {"login": "octa22", "name": "Ondrej Pecta"}}, "url": "https://github.com/openhab/openhab-addons/commit/16a96c4dd5c1040b1454049737a29a23954838dc", "committedDate": "2020-02-09T22:08:51Z", "message": "[jablotron] Jablotron binding initial contribution\n\nSigned-off-by: Ondrej Pecta <opecta@gmail.com>"}, "afterCommit": {"oid": "797d454db6a38f8da451152b7f1369ccee64a806", "author": {"user": {"login": "octa22", "name": "Ondrej Pecta"}}, "url": "https://github.com/openhab/openhab-addons/commit/797d454db6a38f8da451152b7f1369ccee64a806", "committedDate": "2020-02-09T22:26:21Z", "message": "[jablotron] Jablotron binding initial contribution\n\nSigned-off-by: Ondrej Pecta <opecta@gmail.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "797d454db6a38f8da451152b7f1369ccee64a806", "author": {"user": {"login": "octa22", "name": "Ondrej Pecta"}}, "url": "https://github.com/openhab/openhab-addons/commit/797d454db6a38f8da451152b7f1369ccee64a806", "committedDate": "2020-02-09T22:26:21Z", "message": "[jablotron] Jablotron binding initial contribution\n\nSigned-off-by: Ondrej Pecta <opecta@gmail.com>"}, "afterCommit": {"oid": "22dbdd1d616c9c97df3d6f3dff8e1e5045a1f8e2", "author": {"user": {"login": "octa22", "name": "Ondrej Pecta"}}, "url": "https://github.com/openhab/openhab-addons/commit/22dbdd1d616c9c97df3d6f3dff8e1e5045a1f8e2", "committedDate": "2020-02-09T22:34:18Z", "message": "[jablotron] Jablotron binding initial contribution\n\nSigned-off-by: Ondrej Pecta <opecta@gmail.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "1bdc3dc71938f407532a88752479a5a1a02d82a7", "author": {"user": {"login": "octa22", "name": "Ondrej Pecta"}}, "url": "https://github.com/openhab/openhab-addons/commit/1bdc3dc71938f407532a88752479a5a1a02d82a7", "committedDate": "2020-02-14T20:09:17Z", "message": "[jablotron] fix NPE\n\nSigned-off-by: Ondrej Pecta <opecta@gmail.com>"}, "afterCommit": {"oid": "321abab03798bd745baa0a2f82e432e69040d778", "author": {"user": {"login": "octa22", "name": "Ondrej Pecta"}}, "url": "https://github.com/openhab/openhab-addons/commit/321abab03798bd745baa0a2f82e432e69040d778", "committedDate": "2020-02-14T20:20:41Z", "message": "[jablotron] fix NPE\n\nSigned-off-by: Ondrej Pecta <opecta@gmail.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "321abab03798bd745baa0a2f82e432e69040d778", "author": {"user": {"login": "octa22", "name": "Ondrej Pecta"}}, "url": "https://github.com/openhab/openhab-addons/commit/321abab03798bd745baa0a2f82e432e69040d778", "committedDate": "2020-02-14T20:20:41Z", "message": "[jablotron] fix NPE\n\nSigned-off-by: Ondrej Pecta <opecta@gmail.com>"}, "afterCommit": {"oid": "d70edcd01a2dc8695cc5774f620ce727573d1494", "author": {"user": {"login": "octa22", "name": "Ondrej Pecta"}}, "url": "https://github.com/openhab/openhab-addons/commit/d70edcd01a2dc8695cc5774f620ce727573d1494", "committedDate": "2020-02-14T21:52:21Z", "message": "[jablotron] fix NPE\n\nSigned-off-by: Ondrej Pecta <opecta@gmail.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "d70edcd01a2dc8695cc5774f620ce727573d1494", "author": {"user": {"login": "octa22", "name": "Ondrej Pecta"}}, "url": "https://github.com/openhab/openhab-addons/commit/d70edcd01a2dc8695cc5774f620ce727573d1494", "committedDate": "2020-02-14T21:52:21Z", "message": "[jablotron] fix NPE\n\nSigned-off-by: Ondrej Pecta <opecta@gmail.com>"}, "afterCommit": {"oid": "fc3b2af066d901d0227b2c76baa1ebb370dd6861", "author": {"user": {"login": "octa22", "name": "Ondrej Pecta"}}, "url": "https://github.com/openhab/openhab-addons/commit/fc3b2af066d901d0227b2c76baa1ebb370dd6861", "committedDate": "2020-02-14T22:21:26Z", "message": "[jablotron] fix NPE\n\nSigned-off-by: Ondrej Pecta <opecta@gmail.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "7f894dde9db73eb619ff006c31316a5065f37440", "author": {"user": {"login": "octa22", "name": "Ondrej Pecta"}}, "url": "https://github.com/openhab/openhab-addons/commit/7f894dde9db73eb619ff006c31316a5065f37440", "committedDate": "2020-02-16T18:09:56Z", "message": "[jablotron] improved the documentation\n\nSigned-off-by: Ondrej Pecta <opecta@gmail.com>"}, "afterCommit": {"oid": "b1b15e21b9ef1c9bf457ef0e5816a382fa6403ac", "author": {"user": {"login": "octa22", "name": "Ondrej Pecta"}}, "url": "https://github.com/openhab/openhab-addons/commit/b1b15e21b9ef1c9bf457ef0e5816a382fa6403ac", "committedDate": "2020-02-16T18:14:20Z", "message": "[jablotron] improved the documentation\n\nSigned-off-by: Ondrej Pecta <opecta@gmail.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "9bbadf52aa591082f59fec249c734392a1984491", "author": {"user": {"login": "octa22", "name": "Ondrej Pecta"}}, "url": "https://github.com/openhab/openhab-addons/commit/9bbadf52aa591082f59fec249c734392a1984491", "committedDate": "2020-02-17T18:06:25Z", "message": "[jablotron] proper reaction to an authentication challenge exception\n\nSigned-off-by: Ondrej Pecta <opecta@gmail.com>"}, "afterCommit": {"oid": "68677f3868c09c3d5269440cd443fcd8e520180e", "author": {"user": {"login": "octa22", "name": "Ondrej Pecta"}}, "url": "https://github.com/openhab/openhab-addons/commit/68677f3868c09c3d5269440cd443fcd8e520180e", "committedDate": "2020-02-17T18:44:06Z", "message": "[jablotron] proper reaction to an authentication challenge exception\n\nSigned-off-by: Ondrej Pecta <opecta@gmail.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "35adc38fa9151b60a1d2eb31a2753dedead0f3e1", "author": {"user": {"login": "octa22", "name": "Ondrej Pecta"}}, "url": "https://github.com/openhab/openhab-addons/commit/35adc38fa9151b60a1d2eb31a2753dedead0f3e1", "committedDate": "2020-02-29T21:22:21Z", "message": "[jablotron] improved the binding robustness\n\nSigned-off-by: Ondrej Pecta <opecta@gmail.com>"}, "afterCommit": {"oid": "5de2ba8ad7d8be60940e23dfe64d0b97e9acc98a", "author": {"user": {"login": "octa22", "name": "Ondrej Pecta"}}, "url": "https://github.com/openhab/openhab-addons/commit/5de2ba8ad7d8be60940e23dfe64d0b97e9acc98a", "committedDate": "2020-03-01T09:18:08Z", "message": "[jablotron] improved the binding robustness\n\nSigned-off-by: Ondrej Pecta <opecta@gmail.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "5de2ba8ad7d8be60940e23dfe64d0b97e9acc98a", "author": {"user": {"login": "octa22", "name": "Ondrej Pecta"}}, "url": "https://github.com/openhab/openhab-addons/commit/5de2ba8ad7d8be60940e23dfe64d0b97e9acc98a", "committedDate": "2020-03-01T09:18:08Z", "message": "[jablotron] improved the binding robustness\n\nSigned-off-by: Ondrej Pecta <opecta@gmail.com>"}, "afterCommit": {"oid": "fc69ce4a14aea33749cfdcf3093a55876b80f924", "author": {"user": {"login": "octa22", "name": "Ondrej Pecta"}}, "url": "https://github.com/openhab/openhab-addons/commit/fc69ce4a14aea33749cfdcf3093a55876b80f924", "committedDate": "2020-03-01T09:31:23Z", "message": "[jablotron] improved the binding robustness\n\nSigned-off-by: Ondrej Pecta <opecta@gmail.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "fc69ce4a14aea33749cfdcf3093a55876b80f924", "author": {"user": {"login": "octa22", "name": "Ondrej Pecta"}}, "url": "https://github.com/openhab/openhab-addons/commit/fc69ce4a14aea33749cfdcf3093a55876b80f924", "committedDate": "2020-03-01T09:31:23Z", "message": "[jablotron] improved the binding robustness\n\nSigned-off-by: Ondrej Pecta <opecta@gmail.com>"}, "afterCommit": {"oid": "901ebbe210b8573566465f5808b21eab29b878b6", "author": {"user": {"login": "octa22", "name": "Ondrej Pecta"}}, "url": "https://github.com/openhab/openhab-addons/commit/901ebbe210b8573566465f5808b21eab29b878b6", "committedDate": "2020-03-21T13:29:18Z", "message": "[jablotron] bump to the next version\n\nSigned-off-by: Ondrej Pecta <opecta@gmail.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "901ebbe210b8573566465f5808b21eab29b878b6", "author": {"user": {"login": "octa22", "name": "Ondrej Pecta"}}, "url": "https://github.com/openhab/openhab-addons/commit/901ebbe210b8573566465f5808b21eab29b878b6", "committedDate": "2020-03-21T13:29:18Z", "message": "[jablotron] bump to the next version\n\nSigned-off-by: Ondrej Pecta <opecta@gmail.com>"}, "afterCommit": {"oid": "5d94922868aedede9f3a983875748fbb966bd2f8", "author": {"user": {"login": "octa22", "name": "Ondrej Pecta"}}, "url": "https://github.com/openhab/openhab-addons/commit/5d94922868aedede9f3a983875748fbb966bd2f8", "committedDate": "2020-04-22T18:27:58Z", "message": "[jablotron] Bump to the next version, improved detection of alarms\n\nSigned-off-by: Ondrej Pecta <opecta@gmail.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "5d94922868aedede9f3a983875748fbb966bd2f8", "author": {"user": {"login": "octa22", "name": "Ondrej Pecta"}}, "url": "https://github.com/openhab/openhab-addons/commit/5d94922868aedede9f3a983875748fbb966bd2f8", "committedDate": "2020-04-22T18:27:58Z", "message": "[jablotron] Bump to the next version, improved detection of alarms\n\nSigned-off-by: Ondrej Pecta <opecta@gmail.com>"}, "afterCommit": {"oid": "0ea482b55ffb96cf438937fd0d8db5a440bfb9ab", "author": {"user": {"login": "octa22", "name": "Ondrej Pecta"}}, "url": "https://github.com/openhab/openhab-addons/commit/0ea482b55ffb96cf438937fd0d8db5a440bfb9ab", "committedDate": "2020-08-19T16:27:20Z", "message": "[jablotron] Bump to the next version, improved detection of alarms\n\nSigned-off-by: Ondrej Pecta <opecta@gmail.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "0ea482b55ffb96cf438937fd0d8db5a440bfb9ab", "author": {"user": {"login": "octa22", "name": "Ondrej Pecta"}}, "url": "https://github.com/openhab/openhab-addons/commit/0ea482b55ffb96cf438937fd0d8db5a440bfb9ab", "committedDate": "2020-08-19T16:27:20Z", "message": "[jablotron] Bump to the next version, improved detection of alarms\n\nSigned-off-by: Ondrej Pecta <opecta@gmail.com>"}, "afterCommit": {"oid": "135b27fb724206ad55bd73cd9da2db54f9734e65", "author": {"user": {"login": "octa22", "name": "Ondrej Pecta"}}, "url": "https://github.com/openhab/openhab-addons/commit/135b27fb724206ad55bd73cd9da2db54f9734e65", "committedDate": "2020-08-19T16:27:52Z", "message": "[jablotron] Bump to the next version, improved detection of alarms\n\nSigned-off-by: Ondrej Pecta <opecta@gmail.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDgxNzg3OTc1", "url": "https://github.com/openhab/openhab-addons/pull/6990#pullrequestreview-481787975", "createdAt": "2020-09-03T12:29:09Z", "commit": {"oid": "36775963f2d1f6fd1e9689f06b070bfa8e6a859e"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 23, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wM1QxMjoyOTowOVrOHMkSug==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNFQxOToxMDoxMVrOHNY9gQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjkzOTU3OA==", "bodyText": "Use the attribute required instead of the element required. The latter is deprecated:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t<config-description uri=\"bridge-type:jablotron:bridge\">\n          \n          \n            \n            \t<config-description uri=\"bridge-type:jablotron:bridge\" required=\"true\">\n          \n      \n    \n    \n  \n\nAlso check other paramters.", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r482939578", "createdAt": "2020-09-03T12:29:09Z", "author": {"login": "Hilbrand"}, "path": "bundles/org.openhab.binding.jablotron/src/main/resources/ESH-INF/config/config.xml", "diffHunk": "@@ -0,0 +1,79 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<config-description:config-descriptions xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\t\t\t\t\t\t\t\t\t\txmlns:config-description=\"https://openhab.org/schemas/config-description/v1.0.0\"\n+\t\t\t\t\t\t\t\t\t\txsi:schemaLocation=\"https://openhab.org/schemas/config-description/v1.0.0 https://openhab.org/schemas/config-description-1.0.0.xsd\">\n+\n+\t<config-description uri=\"thing-type:jablotron:device\">\n+\t\t<parameter name=\"refresh\" type=\"integer\" required=\"false\">\n+\t\t\t<label>Refresh</label>\n+\t\t\t<description>Specifies the refresh time of thing channels in seconds</description>\n+\t\t\t<default>60</default>\n+\t\t</parameter>\n+\t</config-description>\n+\n+\t<config-description uri=\"thing-type:jablotron:ja100device\">\n+\t\t<parameter name=\"refresh\" type=\"integer\" required=\"false\">\n+\t\t\t<label>Refresh</label>\n+\t\t\t<description>Specifies the refresh time of thing channels in seconds</description>\n+\t\t\t<default>60</default>\n+\t\t</parameter>\n+\n+\t\t<parameter name=\"code\" type=\"text\">\n+\t\t\t<context>password</context>\n+\t\t\t<label>Code</label>\n+\t\t\t<description>Master code for the JA100 alarm</description>\n+\t\t\t<required>false</required>\n+\t\t</parameter>\n+\t</config-description>\n+\n+\t<config-description uri=\"bridge-type:jablotron:bridge\">", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "36775963f2d1f6fd1e9689f06b070bfa8e6a859e"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjkzOTgzNA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\t\t<label>Refresh refresh</label>\n          \n          \n            \n            \t\t\t<label>Refresh</label>", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r482939834", "createdAt": "2020-09-03T12:29:35Z", "author": {"login": "Hilbrand"}, "path": "bundles/org.openhab.binding.jablotron/src/main/resources/ESH-INF/config/config.xml", "diffHunk": "@@ -0,0 +1,79 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<config-description:config-descriptions xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\t\t\t\t\t\t\t\t\t\txmlns:config-description=\"https://openhab.org/schemas/config-description/v1.0.0\"\n+\t\t\t\t\t\t\t\t\t\txsi:schemaLocation=\"https://openhab.org/schemas/config-description/v1.0.0 https://openhab.org/schemas/config-description-1.0.0.xsd\">\n+\n+\t<config-description uri=\"thing-type:jablotron:device\">\n+\t\t<parameter name=\"refresh\" type=\"integer\" required=\"false\">\n+\t\t\t<label>Refresh</label>\n+\t\t\t<description>Specifies the refresh time of thing channels in seconds</description>\n+\t\t\t<default>60</default>\n+\t\t</parameter>\n+\t</config-description>\n+\n+\t<config-description uri=\"thing-type:jablotron:ja100device\">\n+\t\t<parameter name=\"refresh\" type=\"integer\" required=\"false\">\n+\t\t\t<label>Refresh</label>\n+\t\t\t<description>Specifies the refresh time of thing channels in seconds</description>\n+\t\t\t<default>60</default>\n+\t\t</parameter>\n+\n+\t\t<parameter name=\"code\" type=\"text\">\n+\t\t\t<context>password</context>\n+\t\t\t<label>Code</label>\n+\t\t\t<description>Master code for the JA100 alarm</description>\n+\t\t\t<required>false</required>\n+\t\t</parameter>\n+\t</config-description>\n+\n+\t<config-description uri=\"bridge-type:jablotron:bridge\">\n+\t\t<parameter name=\"login\" type=\"text\">\n+\t\t\t<label>Login</label>\n+\t\t\t<description>Login for Jablonet portal</description>\n+\t\t\t<required>true</required>\n+\t\t</parameter>\n+\n+\t\t<parameter name=\"password\" type=\"text\">\n+\t\t\t<context>password</context>\n+\t\t\t<label>Password</label>\n+\t\t\t<description>Password for Jablonet portal</description>\n+\t\t\t<required>true</required>\n+\t\t</parameter>\n+\n+\t\t<parameter name=\"lang\" type=\"text\">\n+\t\t\t<default>en</default>\n+\t\t\t<label>Language</label>\n+\t\t\t<description>Language for Jablonet portal</description>\n+\t\t\t<options>\n+\t\t\t\t<option value=\"cs\">\u010cesky</option>\n+\t\t\t\t<option value=\"da\">Dansk</option>\n+\t\t\t\t<option value=\"de\">Deutsch</option>\n+\t\t\t\t<option value=\"en\">English</option>\n+\t\t\t\t<option value=\"es\">Espa\u00f1ol</option>\n+\t\t\t\t<option value=\"fr\">Fran\u00e7ais</option>\n+\t\t\t\t<option value=\"hr\">Hrvatski</option>\n+\t\t\t\t<option value=\"it\">Italiano</option>\n+\t\t\t\t<option value=\"hu\">Magyar</option>\n+\t\t\t\t<option value=\"nl\">Nederlands</option>\n+\t\t\t\t<option value=\"vi\">Ng\u01b0\u1eddi vi\u1ec7t nam</option>\n+\t\t\t\t<option value=\"no\">Norsk</option>\n+\t\t\t\t<option value=\"pl\">Polski</option>\n+\t\t\t\t<option value=\"pt\">Portugues</option>\n+\t\t\t\t<option value=\"ro\">Rom\u00e2n\u0103</option>\n+\t\t\t\t<option value=\"sl\">Slovenski</option>\n+\t\t\t\t<option value=\"sk\">Slovensky</option>\n+\t\t\t\t<option value=\"sr\">Srpski</option>\n+\t\t\t\t<option value=\"fi\">Suomi</option>\n+\t\t\t\t<option value=\"sv\">Svenska</option>\n+\t\t\t\t<option value=\"tr\">T\u00fcrk\u00e7e</option>\n+\t\t\t</options>\n+\t\t\t<required>true</required>\n+\t\t</parameter>\n+\n+\t\t<parameter name=\"refresh\" type=\"integer\" required=\"false\">\n+\t\t\t<label>Refresh refresh</label>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "36775963f2d1f6fd1e9689f06b070bfa8e6a859e"}, "originalPosition": 74}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mjk0MDE2OQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\t<label>Jablotron Jablonet Bridge</label>\n          \n          \n            \n            \t\t<label>Jablonet Bridge</label>", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r482940169", "createdAt": "2020-09-03T12:30:06Z", "author": {"login": "Hilbrand"}, "path": "bundles/org.openhab.binding.jablotron/src/main/resources/ESH-INF/thing/bridge.xml", "diffHunk": "@@ -0,0 +1,14 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"jablotron\"\n+\t\t\t\t\t\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\t\t\t\t\t\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\t\t\t\t\t\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\t<!-- Jablonet -->\n+\t<bridge-type id=\"bridge\">\n+\t\t<label>Jablotron Jablonet Bridge</label>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "36775963f2d1f6fd1e9689f06b070bfa8e6a859e"}, "originalPosition": 8}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mjk0MDY2OA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\t<label>Alarm state</label>\n          \n          \n            \n            \t\t<label>Alarm State</label>\n          \n      \n    \n    \n  \n\nAlso check others labels. Words must be uppercase, with some exceptions: https://www.openhab.org/docs/developer/bindings/thing-xml.html#formatting-labels-and-descriptions", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r482940668", "createdAt": "2020-09-03T12:30:58Z", "author": {"login": "Hilbrand"}, "path": "bundles/org.openhab.binding.jablotron/src/main/resources/ESH-INF/thing/channels.xml", "diffHunk": "@@ -0,0 +1,164 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"jablotron\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\t\t\t\t\t\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\t\t\t\t\t\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\t<!-- Oasis -->\n+\t<!-- StatusA -->\n+\t<channel-type id=\"statusA\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Alarm Zone A Status Channel</label>\n+\t\t<description>Status of the A zone of your alarm</description>\n+\t\t<state readOnly=\"true\"/>\n+\t</channel-type>\n+\n+\t<!-- StatusB -->\n+\t<channel-type id=\"statusB\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Alarm B Status Channel</label>\n+\t\t<description>Status of the B zone of your alarm</description>\n+\t\t<state readOnly=\"true\"/>\n+\t</channel-type>\n+\n+\t<!-- StatusABC -->\n+\t<channel-type id=\"statusABC\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Alarm Zone ABC Status Channel</label>\n+\t\t<description>Status of the ABC zone of your alarm</description>\n+\t\t<state readOnly=\"true\"/>\n+\t</channel-type>\n+\n+\t<!-- StatusPGX -->\n+\t<channel-type id=\"statusPGX\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>OASIS PGX Status Channel</label>\n+\t\t<description>Status of the PGX switch of your OASIS alarm</description>\n+\t</channel-type>\n+\n+\t<!-- StatusPGY -->\n+\t<channel-type id=\"statusPGY\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>OASIS PGY Status Channel</label>\n+\t\t<description>Status of the PGY switch of your OASIS alarm</description>\n+\t</channel-type>\n+\n+\t<!-- JA100 -->\n+\t<channel-type id=\"status\">\n+\t\t<item-type>Number</item-type>\n+\t\t<label>Alarm Section Status Channel</label>\n+\t\t<description>Status of the section of your alarm</description>\n+\t</channel-type>\n+\n+\t<!-- StatusPGM -->\n+\t<channel-type id=\"statusPGM\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>JA-100 PGM Status Channel</label>\n+\t\t<description>Status of the PGM switch of your JA-100 alarm</description>\n+\t</channel-type>\n+\n+\t<!-- Alarm -->\n+\t<channel-type id=\"alarm\">\n+\t\t<kind>trigger</kind>\n+\t\t<label>Alarm Channel</label>\n+\t\t<description>Status of the alarm of your alarm</description>\n+\t\t<state readOnly=\"true\"/>\n+\t</channel-type>\n+\n+\t<!-- Command -->\n+\t<channel-type id=\"command\">\n+\t\t<item-type>String</item-type>\n+\t\t<label>Alarm Command Channel</label>\n+\t\t<description>Channel for sending commands to your alarm</description>\n+\t</channel-type>\n+\n+\t<!-- LastEvent -->\n+\t<channel-type id=\"lastEvent\">\n+\t\t<item-type>String</item-type>\n+\t\t<label>Alarm Last Event Text Description Channel</label>\n+\t\t<description>Text description of the last event of your alarm</description>\n+\t\t<state readOnly=\"true\"/>\n+\t</channel-type>\n+\n+\t<!-- LastEventClass -->\n+\t<channel-type id=\"lastEventClass\">\n+\t\t<item-type>String</item-type>\n+\t\t<label>Alarm Last Event Class Channel</label>\n+\t\t<description>Class of the last event of your alarm (arm, disarm, ...)</description>\n+\t\t<state readOnly=\"true\"/>\n+\t</channel-type>\n+\n+\t<!-- LastEventSection -->\n+\t<channel-type id=\"lastEventSection\">\n+\t\t<item-type>String</item-type>\n+\t\t<label>Alarm Last Event Section Channel</label>\n+\t\t<description>The last event section of your alarm</description>\n+\t\t<state readOnly=\"true\"/>\n+\t</channel-type>\n+\n+\t<!-- LastEventInvoker -->\n+\t<channel-type id=\"lastEventInvoker\">\n+\t\t<item-type>String</item-type>\n+\t\t<label>Alarm Last Event Invoker Channel</label>\n+\t\t<description>The last event invoker</description>\n+\t\t<state readOnly=\"true\"/>\n+\t</channel-type>\n+\n+\t<!-- LastEventTime -->\n+\t<channel-type id=\"lastEventTime\">\n+\t\t<item-type>DateTime</item-type>\n+\t\t<label>Alarm Last Event Time Channel</label>\n+\t\t<description>Date and time of the last event of your alarm</description>\n+\t\t<state readOnly=\"true\"/>\n+\t</channel-type>\n+\n+\t<!-- LastCheckTime -->\n+\t<channel-type id=\"lastCheckTime\">\n+\t\t<item-type>DateTime</item-type>\n+\t\t<label>Alarm Last Check Time Channel</label>\n+\t\t<description>Date and time of last status check of your alarm</description>\n+\t\t<state readOnly=\"true\"/>\n+\t</channel-type>\n+\n+\t<!-- alarm_state -->\n+\t<channel-type id=\"alarm_state\">\n+\t\t<item-type>String</item-type>\n+\t\t<label>Alarm state</label>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "36775963f2d1f6fd1e9689f06b070bfa8e6a859e"}, "originalPosition": 124}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mjk0Mjc0Ng==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    <version>2.5.8-SNAPSHOT</version>\n          \n          \n            \n                    <version>2.5.9-SNAPSHOT</version>", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r482942746", "createdAt": "2020-09-03T12:34:39Z", "author": {"login": "Hilbrand"}, "path": "bundles/org.openhab.binding.jablotron/pom.xml", "diffHunk": "@@ -0,0 +1,18 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<project xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns=\"http://maven.apache.org/POM/4.0.0\"\n+         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd\">\n+\n+    <modelVersion>4.0.0</modelVersion>\n+\n+    <parent>\n+        <groupId>org.openhab.addons.bundles</groupId>\n+        <artifactId>org.openhab.addons.reactor.bundles</artifactId>\n+        <version>2.5.8-SNAPSHOT</version>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "36775963f2d1f6fd1e9689f06b070bfa8e6a859e"}, "originalPosition": 10}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mjk0OTU3Mg==", "bodyText": "Can you implement registration of a bridge bound discovery as a ThingHandlerService. See this preview documentation on how that works: https://deploy-preview-1262--openhab-docs-preview.netlify.app/docs/developer/bindings/#discovery-that-is-bound-to-a-thing", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r482949572", "createdAt": "2020-09-03T12:46:05Z", "author": {"login": "Hilbrand"}, "path": "bundles/org.openhab.binding.jablotron/src/main/java/org/openhab/binding/jablotron/internal/JablotronHandlerFactory.java", "diffHunk": "@@ -0,0 +1,107 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.jablotron.internal;\n+\n+import static org.openhab.binding.jablotron.JablotronBindingConstants.*;\n+\n+import java.util.*;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.config.discovery.DiscoveryService;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.thing.ThingUID;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandlerFactory;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerFactory;\n+import org.eclipse.smarthome.io.net.http.HttpClientFactory;\n+import org.openhab.binding.jablotron.internal.discovery.JablotronDiscoveryService;\n+import org.openhab.binding.jablotron.internal.handler.JablotronBridgeHandler;\n+import org.openhab.binding.jablotron.internal.handler.JablotronJa100FHandler;\n+import org.openhab.binding.jablotron.internal.handler.JablotronJa100Handler;\n+import org.openhab.binding.jablotron.internal.handler.JablotronOasisHandler;\n+import org.osgi.framework.ServiceRegistration;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Reference;\n+\n+/**\n+ * The {@link JablotronHandlerFactory} is responsible for creating things and thing\n+ * handlers.\n+ *\n+ * @author Ondrej Pecta - Initial contribution\n+ */\n+@NonNullByDefault\n+@Component(service = ThingHandlerFactory.class, immediate = true)\n+public class JablotronHandlerFactory extends BaseThingHandlerFactory {\n+\n+    private Map<ThingUID, ServiceRegistration<?>> discoveryServiceRegs = new HashMap<>();\n+    private final HttpClientFactory httpClientFactory;\n+\n+    @Activate\n+    public JablotronHandlerFactory(@Reference HttpClientFactory httpClientFactory) {\n+        this.httpClientFactory = httpClientFactory;\n+    }\n+\n+    @Override\n+    public boolean supportsThingType(ThingTypeUID thingTypeUID) {\n+        return THING_TYPE_BRIDGE.equals(thingTypeUID) || SUPPORTED_THING_TYPES_UIDS.contains(thingTypeUID);\n+    }\n+\n+    @Override\n+    protected @Nullable ThingHandler createHandler(Thing thing) {\n+        ThingTypeUID thingTypeUID = thing.getThingTypeUID();\n+\n+        if (thingTypeUID.equals(THING_TYPE_BRIDGE)) {\n+            JablotronBridgeHandler handler = new JablotronBridgeHandler((Bridge) thing, httpClientFactory.getCommonHttpClient());\n+            registerItemDiscoveryService(handler);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "36775963f2d1f6fd1e9689f06b070bfa8e6a859e"}, "originalPosition": 69}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mjk1MDA0NQ==", "bodyText": "static final should be above other fields.", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r482950045", "createdAt": "2020-09-03T12:46:49Z", "author": {"login": "Hilbrand"}, "path": "bundles/org.openhab.binding.jablotron/src/main/java/org/openhab/binding/jablotron/internal/discovery/JablotronDiscoveryService.java", "diffHunk": "@@ -0,0 +1,175 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.jablotron.internal.discovery;\n+\n+import static org.openhab.binding.jablotron.JablotronBindingConstants.*;\n+\n+import java.util.*;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.config.discovery.AbstractDiscoveryService;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResultBuilder;\n+import org.eclipse.smarthome.config.discovery.DiscoveryServiceCallback;\n+import org.eclipse.smarthome.config.discovery.ExtendedDiscoveryService;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.thing.ThingUID;\n+import org.openhab.binding.jablotron.internal.handler.JablotronBridgeHandler;\n+import org.openhab.binding.jablotron.internal.model.JablotronDiscoveredService;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Deactivate;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link JablotronDiscoveryService} is responsible for the thing discovery\n+ * process.\n+ *\n+ * @author Ondrej Pecta - Initial contribution\n+ */\n+@NonNullByDefault\n+public class JablotronDiscoveryService extends AbstractDiscoveryService implements ExtendedDiscoveryService {\n+    private final Logger logger = LoggerFactory.getLogger(JablotronDiscoveryService.class);\n+    private JablotronBridgeHandler bridge;\n+    private @Nullable DiscoveryServiceCallback discoveryServiceCallback;\n+\n+    private @Nullable ScheduledFuture<?> discoveryJob = null;\n+\n+    private static final int DISCOVERY_TIMEOUT_SEC = 10;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "36775963f2d1f6fd1e9689f06b070bfa8e6a859e"}, "originalPosition": 51}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mjk1MDg2Mw==", "bodyText": "Can you catch the specific exception.", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r482950863", "createdAt": "2020-09-03T12:48:13Z", "author": {"login": "Hilbrand"}, "path": "bundles/org.openhab.binding.jablotron/src/main/java/org/openhab/binding/jablotron/internal/discovery/JablotronDiscoveryService.java", "diffHunk": "@@ -0,0 +1,175 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.jablotron.internal.discovery;\n+\n+import static org.openhab.binding.jablotron.JablotronBindingConstants.*;\n+\n+import java.util.*;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.config.discovery.AbstractDiscoveryService;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResultBuilder;\n+import org.eclipse.smarthome.config.discovery.DiscoveryServiceCallback;\n+import org.eclipse.smarthome.config.discovery.ExtendedDiscoveryService;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.thing.ThingUID;\n+import org.openhab.binding.jablotron.internal.handler.JablotronBridgeHandler;\n+import org.openhab.binding.jablotron.internal.model.JablotronDiscoveredService;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Deactivate;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link JablotronDiscoveryService} is responsible for the thing discovery\n+ * process.\n+ *\n+ * @author Ondrej Pecta - Initial contribution\n+ */\n+@NonNullByDefault\n+public class JablotronDiscoveryService extends AbstractDiscoveryService implements ExtendedDiscoveryService {\n+    private final Logger logger = LoggerFactory.getLogger(JablotronDiscoveryService.class);\n+    private JablotronBridgeHandler bridge;\n+    private @Nullable DiscoveryServiceCallback discoveryServiceCallback;\n+\n+    private @Nullable ScheduledFuture<?> discoveryJob = null;\n+\n+    private static final int DISCOVERY_TIMEOUT_SEC = 10;\n+\n+    public JablotronDiscoveryService(JablotronBridgeHandler bridgeHandler) {\n+        super(DISCOVERY_TIMEOUT_SEC);\n+        logger.debug(\"Creating discovery service\");\n+        this.bridge = bridgeHandler;\n+    }\n+\n+    private void startDiscovery() {\n+        if (this.bridge.getThing().getStatus() == ThingStatus.ONLINE) {\n+            discoverServices();\n+        }\n+    }\n+\n+    @Override\n+    protected void stopBackgroundDiscovery() {\n+        super.stopBackgroundDiscovery();\n+        if (discoveryJob != null) {\n+            discoveryJob.cancel(true);\n+        }\n+    }\n+\n+    @Override\n+    protected void startBackgroundDiscovery() {\n+        logger.debug(\"Starting Jablotron background discovery\");\n+\n+        if (discoveryJob == null || discoveryJob.isCancelled()) {\n+            discoveryJob = scheduler.scheduleWithFixedDelay(this::startDiscovery, 10, 3600,\n+                    TimeUnit.SECONDS);\n+        }\n+    }\n+\n+    /**\n+     * Called on component activation.\n+     */\n+    @Override\n+    @Activate\n+    public void activate(@Nullable Map<String, @Nullable Object> configProperties) {\n+        super.activate(configProperties);\n+    }\n+\n+    @Deactivate\n+    @Override\n+    public void deactivate() {\n+        super.deactivate();\n+        if (discoveryJob != null) {\n+            discoveryJob.cancel(true);\n+        }\n+    }\n+\n+    @Override\n+    public Set<ThingTypeUID> getSupportedThingTypes() {\n+        return SUPPORTED_THING_TYPES_UIDS;\n+    }\n+\n+    @Override\n+    public void setDiscoveryServiceCallback(DiscoveryServiceCallback discoveryServiceCallback) {\n+        this.discoveryServiceCallback = discoveryServiceCallback;\n+    }\n+\n+    @Override\n+    protected void startScan() {\n+        logger.debug(\"Starting scanning for items...\");\n+        startDiscovery();\n+    }\n+\n+    public void oasisDiscovered(String label, String serviceId) {\n+        ThingUID thingUID = new ThingUID(THING_TYPE_OASIS, bridge.getThing().getUID(), serviceId);\n+\n+        logger.debug(\"Detected an OASIS alarm with service id: {}\", serviceId);\n+        thingDiscovered(\n+                DiscoveryResultBuilder.create(thingUID).withThingType(THING_TYPE_OASIS)\n+                        .withLabel(label)\n+                        .withBridge(bridge.getThing().getUID()).build());\n+    }\n+\n+    public void ja100Discovered(String label, String serviceId) {\n+        ThingUID thingUID = new ThingUID(THING_TYPE_JA100, bridge.getThing().getUID(), serviceId);\n+\n+        logger.debug(\"Detected a JA100 alarm with service id: {}\", serviceId);\n+        thingDiscovered(\n+                DiscoveryResultBuilder.create(thingUID).withThingType(THING_TYPE_JA100)\n+                        .withLabel(label)\n+                        .withBridge(bridge.getThing().getUID()).build());\n+    }\n+\n+    public void ja100fDiscovered(String label, String serviceId) {\n+        ThingUID thingUID = new ThingUID(THING_TYPE_JA100F, bridge.getThing().getUID(), serviceId);\n+\n+        logger.debug(\"Detected a JA100+ alarm with service id: {}\", serviceId);\n+        thingDiscovered(\n+                DiscoveryResultBuilder.create(thingUID).withThingType(THING_TYPE_JA100F)\n+                        .withLabel(label)\n+                        .withBridge(bridge.getThing().getUID()).build());\n+    }\n+\n+    private synchronized void discoverServices() {\n+        try {\n+            List<JablotronDiscoveredService> services = bridge.discoverServices();\n+\n+            if (services == null || services.size() == 0) {\n+                logger.info(\"Cannot find any Jablotron device\");\n+                return;\n+            }\n+\n+            for (JablotronDiscoveredService service : services) {\n+                String serviceId = String.valueOf(service.getId());\n+                logger.debug(\"Found Jablotron service: {} id: {}\", service.getName(), serviceId);\n+\n+                String serviceType = service.getServiceType().toLowerCase();\n+                if (serviceType.equals(THING_TYPE_OASIS.getId())) {\n+                    oasisDiscovered(\"Jablotron OASIS Alarm : \" + service.getName(), serviceId);\n+                } else if (serviceType.equals(THING_TYPE_JA100.getId())) {\n+                    ja100Discovered(\"Jablotron JA100 Alarm : \" + service.getName(), serviceId);\n+                } else if (serviceType.equals(THING_TYPE_JA100F.getId())) {\n+                    ja100fDiscovered(\"Jablotron JA100+ Alarm : \" + service.getName(), serviceId);\n+                } else {\n+                    logger.info(\"Unsupported device type discovered: {} with serviceId: {} and type: {}\", service.getName(), serviceId, service.getServiceType());\n+                }\n+            }\n+        } catch (Exception ex) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "36775963f2d1f6fd1e9689f06b070bfa8e6a859e"}, "originalPosition": 171}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mjk1MDk4Mw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        if (services == null || services.size() == 0) {\n          \n          \n            \n                        if (services == null || services.isEmpty()) {", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r482950983", "createdAt": "2020-09-03T12:48:26Z", "author": {"login": "Hilbrand"}, "path": "bundles/org.openhab.binding.jablotron/src/main/java/org/openhab/binding/jablotron/internal/discovery/JablotronDiscoveryService.java", "diffHunk": "@@ -0,0 +1,175 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.jablotron.internal.discovery;\n+\n+import static org.openhab.binding.jablotron.JablotronBindingConstants.*;\n+\n+import java.util.*;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.config.discovery.AbstractDiscoveryService;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResultBuilder;\n+import org.eclipse.smarthome.config.discovery.DiscoveryServiceCallback;\n+import org.eclipse.smarthome.config.discovery.ExtendedDiscoveryService;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.thing.ThingUID;\n+import org.openhab.binding.jablotron.internal.handler.JablotronBridgeHandler;\n+import org.openhab.binding.jablotron.internal.model.JablotronDiscoveredService;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Deactivate;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link JablotronDiscoveryService} is responsible for the thing discovery\n+ * process.\n+ *\n+ * @author Ondrej Pecta - Initial contribution\n+ */\n+@NonNullByDefault\n+public class JablotronDiscoveryService extends AbstractDiscoveryService implements ExtendedDiscoveryService {\n+    private final Logger logger = LoggerFactory.getLogger(JablotronDiscoveryService.class);\n+    private JablotronBridgeHandler bridge;\n+    private @Nullable DiscoveryServiceCallback discoveryServiceCallback;\n+\n+    private @Nullable ScheduledFuture<?> discoveryJob = null;\n+\n+    private static final int DISCOVERY_TIMEOUT_SEC = 10;\n+\n+    public JablotronDiscoveryService(JablotronBridgeHandler bridgeHandler) {\n+        super(DISCOVERY_TIMEOUT_SEC);\n+        logger.debug(\"Creating discovery service\");\n+        this.bridge = bridgeHandler;\n+    }\n+\n+    private void startDiscovery() {\n+        if (this.bridge.getThing().getStatus() == ThingStatus.ONLINE) {\n+            discoverServices();\n+        }\n+    }\n+\n+    @Override\n+    protected void stopBackgroundDiscovery() {\n+        super.stopBackgroundDiscovery();\n+        if (discoveryJob != null) {\n+            discoveryJob.cancel(true);\n+        }\n+    }\n+\n+    @Override\n+    protected void startBackgroundDiscovery() {\n+        logger.debug(\"Starting Jablotron background discovery\");\n+\n+        if (discoveryJob == null || discoveryJob.isCancelled()) {\n+            discoveryJob = scheduler.scheduleWithFixedDelay(this::startDiscovery, 10, 3600,\n+                    TimeUnit.SECONDS);\n+        }\n+    }\n+\n+    /**\n+     * Called on component activation.\n+     */\n+    @Override\n+    @Activate\n+    public void activate(@Nullable Map<String, @Nullable Object> configProperties) {\n+        super.activate(configProperties);\n+    }\n+\n+    @Deactivate\n+    @Override\n+    public void deactivate() {\n+        super.deactivate();\n+        if (discoveryJob != null) {\n+            discoveryJob.cancel(true);\n+        }\n+    }\n+\n+    @Override\n+    public Set<ThingTypeUID> getSupportedThingTypes() {\n+        return SUPPORTED_THING_TYPES_UIDS;\n+    }\n+\n+    @Override\n+    public void setDiscoveryServiceCallback(DiscoveryServiceCallback discoveryServiceCallback) {\n+        this.discoveryServiceCallback = discoveryServiceCallback;\n+    }\n+\n+    @Override\n+    protected void startScan() {\n+        logger.debug(\"Starting scanning for items...\");\n+        startDiscovery();\n+    }\n+\n+    public void oasisDiscovered(String label, String serviceId) {\n+        ThingUID thingUID = new ThingUID(THING_TYPE_OASIS, bridge.getThing().getUID(), serviceId);\n+\n+        logger.debug(\"Detected an OASIS alarm with service id: {}\", serviceId);\n+        thingDiscovered(\n+                DiscoveryResultBuilder.create(thingUID).withThingType(THING_TYPE_OASIS)\n+                        .withLabel(label)\n+                        .withBridge(bridge.getThing().getUID()).build());\n+    }\n+\n+    public void ja100Discovered(String label, String serviceId) {\n+        ThingUID thingUID = new ThingUID(THING_TYPE_JA100, bridge.getThing().getUID(), serviceId);\n+\n+        logger.debug(\"Detected a JA100 alarm with service id: {}\", serviceId);\n+        thingDiscovered(\n+                DiscoveryResultBuilder.create(thingUID).withThingType(THING_TYPE_JA100)\n+                        .withLabel(label)\n+                        .withBridge(bridge.getThing().getUID()).build());\n+    }\n+\n+    public void ja100fDiscovered(String label, String serviceId) {\n+        ThingUID thingUID = new ThingUID(THING_TYPE_JA100F, bridge.getThing().getUID(), serviceId);\n+\n+        logger.debug(\"Detected a JA100+ alarm with service id: {}\", serviceId);\n+        thingDiscovered(\n+                DiscoveryResultBuilder.create(thingUID).withThingType(THING_TYPE_JA100F)\n+                        .withLabel(label)\n+                        .withBridge(bridge.getThing().getUID()).build());\n+    }\n+\n+    private synchronized void discoverServices() {\n+        try {\n+            List<JablotronDiscoveredService> services = bridge.discoverServices();\n+\n+            if (services == null || services.size() == 0) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "36775963f2d1f6fd1e9689f06b070bfa8e6a859e"}, "originalPosition": 151}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mjk1MzAwOQ==", "bodyText": "This table seems to contains tabs. Can you format it. You can use http://markdowntable.com/", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r482953009", "createdAt": "2020-09-03T12:51:43Z", "author": {"login": "Hilbrand"}, "path": "bundles/org.openhab.binding.jablotron/README.md", "diffHunk": "@@ -0,0 +1,119 @@\n+# Jablotron Alarm Binding\n+\n+This is the OH2.x binding for Jablotron alarms.\n+https://www.jablotron.com/en/jablotron-products/alarms/\n+\n+## Supported Things\n+\n+| thing   | note                                      |\n+|---------|-------------------------------------------|\n+| bridge  | the bridge to your Jablonet cloud account |\n+| JA-80   | the OASIS alarm                           |\n+| JA-100  | with the thermometer support              |\n+| JA-100F | without the thermometer support           |\n+ \n+## Discovery\n+\n+This binding supports auto discovery. Just manually add a bridge thing and supply login & password to your Jablonet account.\n+\n+## Binding Configuration\n+\n+Binding itself doesn't require specific configuration.\n+\n+## Thing Configuration\n+\n+| thing                | config parameter name | description                                                                        | type                  |\n+|----------------------|-----------------------|------------------------------------------------------------------------------------|-----------------------|\n+| bridge               | login                 | the login to your Jablonet account                                                 | mandatory             |\n+| bridge               | password              | the password to your Jablonet account                                              | mandatory             |\n+| bridge               | refresh               | the refresh time for all alarm warnings (ALARM, TAMPER triggers and SERVICE state) | optional, default=30s |\n+| bridge               | lang                  | the language of the alarm texts                                                    | optional, default=en  |\n+| JA-80/JA-100/JA-100F | refresh               | the channels refresh period in seconds                                             | optional, default=60s |\n+| JA-100/JA-100F       | code                  | the master code for controlling sections                                           | optional              |\n+\n+## Channels\n+\n+| thing                | channel name     | description                                               |\n+|----------------------|------------------|-----------------------------------------------------------|\n+| bridge               | N/A              | the bridge does not expose any channels                   |\n+| JA-80                | statusA          | the status of the A section                                   |\n+| JA-80                | statusB          | the status of the AB/B section                                |\n+| JA-80                | statusABC        | the status of the ABC section                                 |", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "36775963f2d1f6fd1e9689f06b070bfa8e6a859e"}, "originalPosition": 41}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mjk1NTI4MQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    scheduler.execute(() -> {\n          \n          \n            \n                        doInit();\n          \n          \n            \n                    });\n          \n          \n            \n                    scheduler.execute(this::doInit);", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r482955281", "createdAt": "2020-09-03T12:55:05Z", "author": {"login": "Hilbrand"}, "path": "bundles/org.openhab.binding.jablotron/src/main/java/org/openhab/binding/jablotron/internal/handler/JablotronAlarmHandler.java", "diffHunk": "@@ -0,0 +1,221 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.jablotron.internal.handler;\n+\n+import static org.openhab.binding.jablotron.JablotronBindingConstants.*;\n+\n+import java.time.ZoneId;\n+import java.time.ZonedDateTime;\n+import java.time.format.DateTimeFormatter;\n+import java.util.Calendar;\n+import java.util.List;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import com.google.gson.Gson;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DateTimeType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.ThingStatusInfo;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.jablotron.internal.config.JablotronDeviceConfig;\n+import org.openhab.binding.jablotron.internal.model.*;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link JablotronAlarmHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Ondrej Pecta - Initial contribution\n+ */\n+@NonNullByDefault\n+public abstract class JablotronAlarmHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(JablotronAlarmHandler.class);\n+\n+    protected Gson gson = new Gson();\n+\n+    protected JablotronDeviceConfig thingConfig = new JablotronDeviceConfig();\n+\n+    private String lastWarningTime = \"\";\n+\n+    protected String alarmName = \"\";\n+\n+    private boolean inService = false;\n+\n+    @Nullable\n+    ScheduledFuture<?> future = null;\n+\n+    public JablotronAlarmHandler(Thing thing, String alarmName) {\n+        super(thing);\n+        this.alarmName = alarmName;\n+    }\n+\n+    @Override\n+    public void bridgeStatusChanged(ThingStatusInfo bridgeStatusInfo) {\n+        super.bridgeStatusChanged(bridgeStatusInfo);\n+        if (ThingStatus.UNINITIALIZED == bridgeStatusInfo.getStatus()) {\n+            cleanup();\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        super.dispose();\n+        cleanup();\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        thingConfig = getConfigAs(JablotronDeviceConfig.class);\n+        scheduler.execute(() -> {\n+            doInit();\n+        });", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "36775963f2d1f6fd1e9689f06b070bfa8e6a859e"}, "originalPosition": 89}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mjk1NTY0MQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                @Nullable\n          \n          \n            \n                ScheduledFuture<?> future = null;\n          \n          \n            \n                @Nullable ScheduledFuture<?> future = null;\n          \n      \n    \n    \n  \n\nprotected?", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r482955641", "createdAt": "2020-09-03T12:55:39Z", "author": {"login": "Hilbrand"}, "path": "bundles/org.openhab.binding.jablotron/src/main/java/org/openhab/binding/jablotron/internal/handler/JablotronAlarmHandler.java", "diffHunk": "@@ -0,0 +1,221 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.jablotron.internal.handler;\n+\n+import static org.openhab.binding.jablotron.JablotronBindingConstants.*;\n+\n+import java.time.ZoneId;\n+import java.time.ZonedDateTime;\n+import java.time.format.DateTimeFormatter;\n+import java.util.Calendar;\n+import java.util.List;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import com.google.gson.Gson;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DateTimeType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.ThingStatusInfo;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.jablotron.internal.config.JablotronDeviceConfig;\n+import org.openhab.binding.jablotron.internal.model.*;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link JablotronAlarmHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Ondrej Pecta - Initial contribution\n+ */\n+@NonNullByDefault\n+public abstract class JablotronAlarmHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(JablotronAlarmHandler.class);\n+\n+    protected Gson gson = new Gson();\n+\n+    protected JablotronDeviceConfig thingConfig = new JablotronDeviceConfig();\n+\n+    private String lastWarningTime = \"\";\n+\n+    protected String alarmName = \"\";\n+\n+    private boolean inService = false;\n+\n+    @Nullable\n+    ScheduledFuture<?> future = null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "36775963f2d1f6fd1e9689f06b070bfa8e6a859e"}, "originalPosition": 63}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mjk1NTk3Ng==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                protected Gson gson = new Gson();\n          \n          \n            \n                protected final Gson gson = new Gson();", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r482955976", "createdAt": "2020-09-03T12:56:09Z", "author": {"login": "Hilbrand"}, "path": "bundles/org.openhab.binding.jablotron/src/main/java/org/openhab/binding/jablotron/internal/handler/JablotronAlarmHandler.java", "diffHunk": "@@ -0,0 +1,221 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.jablotron.internal.handler;\n+\n+import static org.openhab.binding.jablotron.JablotronBindingConstants.*;\n+\n+import java.time.ZoneId;\n+import java.time.ZonedDateTime;\n+import java.time.format.DateTimeFormatter;\n+import java.util.Calendar;\n+import java.util.List;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import com.google.gson.Gson;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DateTimeType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.ThingStatusInfo;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.jablotron.internal.config.JablotronDeviceConfig;\n+import org.openhab.binding.jablotron.internal.model.*;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link JablotronAlarmHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Ondrej Pecta - Initial contribution\n+ */\n+@NonNullByDefault\n+public abstract class JablotronAlarmHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(JablotronAlarmHandler.class);\n+\n+    protected Gson gson = new Gson();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "36775963f2d1f6fd1e9689f06b070bfa8e6a859e"}, "originalPosition": 52}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzQyNjc4NA==", "bodyText": "It this needed?", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r483426784", "createdAt": "2020-09-04T07:01:27Z", "author": {"login": "Hilbrand"}, "path": "bundles/org.openhab.binding.jablotron/src/main/java/org/openhab/binding/jablotron/internal/discovery/JablotronDiscoveryService.java", "diffHunk": "@@ -0,0 +1,175 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.jablotron.internal.discovery;\n+\n+import static org.openhab.binding.jablotron.JablotronBindingConstants.*;\n+\n+import java.util.*;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.config.discovery.AbstractDiscoveryService;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResultBuilder;\n+import org.eclipse.smarthome.config.discovery.DiscoveryServiceCallback;\n+import org.eclipse.smarthome.config.discovery.ExtendedDiscoveryService;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.thing.ThingUID;\n+import org.openhab.binding.jablotron.internal.handler.JablotronBridgeHandler;\n+import org.openhab.binding.jablotron.internal.model.JablotronDiscoveredService;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Deactivate;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link JablotronDiscoveryService} is responsible for the thing discovery\n+ * process.\n+ *\n+ * @author Ondrej Pecta - Initial contribution\n+ */\n+@NonNullByDefault\n+public class JablotronDiscoveryService extends AbstractDiscoveryService implements ExtendedDiscoveryService {\n+    private final Logger logger = LoggerFactory.getLogger(JablotronDiscoveryService.class);\n+    private JablotronBridgeHandler bridge;\n+    private @Nullable DiscoveryServiceCallback discoveryServiceCallback;\n+\n+    private @Nullable ScheduledFuture<?> discoveryJob = null;\n+\n+    private static final int DISCOVERY_TIMEOUT_SEC = 10;\n+\n+    public JablotronDiscoveryService(JablotronBridgeHandler bridgeHandler) {\n+        super(DISCOVERY_TIMEOUT_SEC);\n+        logger.debug(\"Creating discovery service\");\n+        this.bridge = bridgeHandler;\n+    }\n+\n+    private void startDiscovery() {\n+        if (this.bridge.getThing().getStatus() == ThingStatus.ONLINE) {\n+            discoverServices();\n+        }\n+    }\n+\n+    @Override\n+    protected void stopBackgroundDiscovery() {\n+        super.stopBackgroundDiscovery();\n+        if (discoveryJob != null) {\n+            discoveryJob.cancel(true);\n+        }\n+    }\n+\n+    @Override\n+    protected void startBackgroundDiscovery() {\n+        logger.debug(\"Starting Jablotron background discovery\");\n+\n+        if (discoveryJob == null || discoveryJob.isCancelled()) {\n+            discoveryJob = scheduler.scheduleWithFixedDelay(this::startDiscovery, 10, 3600,\n+                    TimeUnit.SECONDS);\n+        }\n+    }\n+\n+    /**\n+     * Called on component activation.\n+     */\n+    @Override\n+    @Activate\n+    public void activate(@Nullable Map<String, @Nullable Object> configProperties) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "36775963f2d1f6fd1e9689f06b070bfa8e6a859e"}, "originalPosition": 88}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzQyNjk4Mw==", "bodyText": "This is probably not needed as it is already done in stopBackgroundDiscovery.", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r483426983", "createdAt": "2020-09-04T07:01:57Z", "author": {"login": "Hilbrand"}, "path": "bundles/org.openhab.binding.jablotron/src/main/java/org/openhab/binding/jablotron/internal/discovery/JablotronDiscoveryService.java", "diffHunk": "@@ -0,0 +1,175 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.jablotron.internal.discovery;\n+\n+import static org.openhab.binding.jablotron.JablotronBindingConstants.*;\n+\n+import java.util.*;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.config.discovery.AbstractDiscoveryService;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResultBuilder;\n+import org.eclipse.smarthome.config.discovery.DiscoveryServiceCallback;\n+import org.eclipse.smarthome.config.discovery.ExtendedDiscoveryService;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.thing.ThingUID;\n+import org.openhab.binding.jablotron.internal.handler.JablotronBridgeHandler;\n+import org.openhab.binding.jablotron.internal.model.JablotronDiscoveredService;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Deactivate;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link JablotronDiscoveryService} is responsible for the thing discovery\n+ * process.\n+ *\n+ * @author Ondrej Pecta - Initial contribution\n+ */\n+@NonNullByDefault\n+public class JablotronDiscoveryService extends AbstractDiscoveryService implements ExtendedDiscoveryService {\n+    private final Logger logger = LoggerFactory.getLogger(JablotronDiscoveryService.class);\n+    private JablotronBridgeHandler bridge;\n+    private @Nullable DiscoveryServiceCallback discoveryServiceCallback;\n+\n+    private @Nullable ScheduledFuture<?> discoveryJob = null;\n+\n+    private static final int DISCOVERY_TIMEOUT_SEC = 10;\n+\n+    public JablotronDiscoveryService(JablotronBridgeHandler bridgeHandler) {\n+        super(DISCOVERY_TIMEOUT_SEC);\n+        logger.debug(\"Creating discovery service\");\n+        this.bridge = bridgeHandler;\n+    }\n+\n+    private void startDiscovery() {\n+        if (this.bridge.getThing().getStatus() == ThingStatus.ONLINE) {\n+            discoverServices();\n+        }\n+    }\n+\n+    @Override\n+    protected void stopBackgroundDiscovery() {\n+        super.stopBackgroundDiscovery();\n+        if (discoveryJob != null) {\n+            discoveryJob.cancel(true);\n+        }\n+    }\n+\n+    @Override\n+    protected void startBackgroundDiscovery() {\n+        logger.debug(\"Starting Jablotron background discovery\");\n+\n+        if (discoveryJob == null || discoveryJob.isCancelled()) {\n+            discoveryJob = scheduler.scheduleWithFixedDelay(this::startDiscovery, 10, 3600,\n+                    TimeUnit.SECONDS);\n+        }\n+    }\n+\n+    /**\n+     * Called on component activation.\n+     */\n+    @Override\n+    @Activate\n+    public void activate(@Nullable Map<String, @Nullable Object> configProperties) {\n+        super.activate(configProperties);\n+    }\n+\n+    @Deactivate\n+    @Override\n+    public void deactivate() {\n+        super.deactivate();\n+        if (discoveryJob != null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "36775963f2d1f6fd1e9689f06b070bfa8e6a859e"}, "originalPosition": 96}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzQyNzM2Mw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    future = scheduler.scheduleWithFixedDelay(() -> {\n          \n          \n            \n                        updateAlarmStatus();\n          \n          \n            \n                    }, 1, thingConfig.getRefresh(), TimeUnit.SECONDS);\n          \n          \n            \n                    future = scheduler.scheduleWithFixedDelay(this::updateAlarmStatus, 1, thingConfig.getRefresh(), TimeUnit.SECONDS);", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r483427363", "createdAt": "2020-09-04T07:02:57Z", "author": {"login": "Hilbrand"}, "path": "bundles/org.openhab.binding.jablotron/src/main/java/org/openhab/binding/jablotron/internal/handler/JablotronAlarmHandler.java", "diffHunk": "@@ -0,0 +1,221 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.jablotron.internal.handler;\n+\n+import static org.openhab.binding.jablotron.JablotronBindingConstants.*;\n+\n+import java.time.ZoneId;\n+import java.time.ZonedDateTime;\n+import java.time.format.DateTimeFormatter;\n+import java.util.Calendar;\n+import java.util.List;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import com.google.gson.Gson;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DateTimeType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.ThingStatusInfo;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.jablotron.internal.config.JablotronDeviceConfig;\n+import org.openhab.binding.jablotron.internal.model.*;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link JablotronAlarmHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Ondrej Pecta - Initial contribution\n+ */\n+@NonNullByDefault\n+public abstract class JablotronAlarmHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(JablotronAlarmHandler.class);\n+\n+    protected Gson gson = new Gson();\n+\n+    protected JablotronDeviceConfig thingConfig = new JablotronDeviceConfig();\n+\n+    private String lastWarningTime = \"\";\n+\n+    protected String alarmName = \"\";\n+\n+    private boolean inService = false;\n+\n+    @Nullable\n+    ScheduledFuture<?> future = null;\n+\n+    public JablotronAlarmHandler(Thing thing, String alarmName) {\n+        super(thing);\n+        this.alarmName = alarmName;\n+    }\n+\n+    @Override\n+    public void bridgeStatusChanged(ThingStatusInfo bridgeStatusInfo) {\n+        super.bridgeStatusChanged(bridgeStatusInfo);\n+        if (ThingStatus.UNINITIALIZED == bridgeStatusInfo.getStatus()) {\n+            cleanup();\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        super.dispose();\n+        cleanup();\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        thingConfig = getConfigAs(JablotronDeviceConfig.class);\n+        scheduler.execute(() -> {\n+            doInit();\n+        });\n+        updateStatus(ThingStatus.ONLINE);\n+    }\n+\n+    public boolean isInService() {\n+        return inService;\n+    }\n+\n+    public String getAlarmName() {\n+        return alarmName;\n+    }\n+\n+    protected void updateSegmentStatus(JablotronServiceDetailSegment segment) {\n+    }\n+\n+    private void cleanup() {\n+        logger.debug(\"doing cleanup...\");\n+        if (future != null) {\n+            future.cancel(true);\n+        }\n+    }\n+\n+    protected State getCheckTime() {\n+        ZonedDateTime zdt = ZonedDateTime.ofInstant(Calendar.getInstance().toInstant(), ZoneId.systemDefault());\n+        return new DateTimeType(zdt);\n+    }\n+\n+    protected void doInit() {\n+        future = scheduler.scheduleWithFixedDelay(() -> {\n+            updateAlarmStatus();\n+        }, 1, thingConfig.getRefresh(), TimeUnit.SECONDS);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "36775963f2d1f6fd1e9689f06b070bfa8e6a859e"}, "originalPosition": 119}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzQyODc1Ng==", "bodyText": "To make this class a lot readable better move the generic parts in these methods to a single method and call that from the other methods.", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r483428756", "createdAt": "2020-09-04T07:06:10Z", "author": {"login": "Hilbrand"}, "path": "bundles/org.openhab.binding.jablotron/src/main/java/org/openhab/binding/jablotron/internal/handler/JablotronBridgeHandler.java", "diffHunk": "@@ -0,0 +1,452 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.jablotron.internal.handler;\n+\n+import static org.openhab.binding.jablotron.JablotronBindingConstants.*;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.JsonSyntaxException;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.eclipse.jetty.http.HttpHeader;\n+import org.eclipse.jetty.http.HttpMethod;\n+import org.eclipse.smarthome.config.core.status.ConfigStatusMessage;\n+import org.eclipse.smarthome.core.thing.*;\n+import org.eclipse.smarthome.core.thing.binding.ConfigStatusBridgeHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.openhab.binding.jablotron.internal.config.JablotronBridgeConfig;\n+import org.openhab.binding.jablotron.internal.model.*;\n+import org.openhab.binding.jablotron.internal.model.ja100f.JablotronGetPGResponse;\n+import org.openhab.binding.jablotron.internal.model.ja100f.JablotronGetSectionsResponse;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link JablotronBridgeHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Ondrej Pecta - Initial contribution\n+ */\n+@NonNullByDefault\n+public class JablotronBridgeHandler extends ConfigStatusBridgeHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(JablotronBridgeHandler.class);\n+\n+    private Gson gson = new Gson();\n+\n+    final HttpClient httpClient;\n+\n+    @Nullable\n+    ScheduledFuture<?> future = null;\n+\n+    /**\n+     * Our configuration\n+     */\n+    public JablotronBridgeConfig bridgeConfig = new JablotronBridgeConfig();\n+\n+    public JablotronBridgeHandler(Bridge thing, HttpClient httpClient) {\n+        super(thing);\n+        this.httpClient = httpClient;\n+    }\n+\n+    @Override\n+    public Collection<ConfigStatusMessage> getConfigStatus() {\n+        return Collections.emptyList();\n+    }\n+\n+    @Override\n+    public void childHandlerInitialized(ThingHandler thingHandler, Thing thing) {\n+    }\n+\n+    @Override\n+    public void childHandlerDisposed(ThingHandler thingHandler, Thing thing) {\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        bridgeConfig = getConfigAs(JablotronBridgeConfig.class);\n+        scheduler.execute(this::login);\n+        future = scheduler.scheduleWithFixedDelay(() -> updateAlarmThings(), 30, bridgeConfig.getRefresh(), TimeUnit.SECONDS);\n+    }\n+\n+    private void updateAlarmThings() {\n+        List<JablotronDiscoveredService> services = discoverServices();\n+        if (services != null) {\n+            for (JablotronDiscoveredService service : services) {\n+                updateAlarmThing(service);\n+            }\n+        }\n+    }\n+\n+    private void updateAlarmThing(JablotronDiscoveredService service) {\n+        for (Thing th : getThing().getThings()) {\n+            if (String.valueOf(service.getId()).equals(th.getUID().getId())) {\n+                JablotronAlarmHandler handler = (JablotronAlarmHandler) th.getHandler();\n+                if (handler == null) {\n+                    logger.debug(\"Thing handler is null\");\n+                    continue;\n+                }\n+                if (\"ENABLED\".equals(service.getStatus())) {\n+                    if (!\"\".equals(service.getWarning())) {\n+                        logger.debug(\"Alarm with service id: {} warning: {}\", service.getId(), service.getWarning());\n+                    }\n+                    handler.setStatus(ThingStatus.ONLINE, ThingStatusDetail.NONE, service.getWarning());\n+                    if (\"ALARM\".equals(service.getWarning()) || \"TAMPER\".equals(service.getWarning())) {\n+                        handler.triggerAlarm(service);\n+                    }\n+                    handler.setInService(\"SERVICE\".equals(service.getWarning()));\n+                } else {\n+                    logger.debug(\"Alarm with service id: {} is offline\", service.getId());\n+                    handler.setStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, service.getStatus());\n+                }\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        super.dispose();\n+        if (future != null) {\n+            future.cancel(true);\n+        }\n+        logout();\n+    }\n+\n+    protected synchronized void login() {\n+        try {\n+            String url = JABLOTRON_API_URL + \"userAuthorize.json\";\n+            String urlParameters = \"{\\\"login\\\":\\\"\" + bridgeConfig.getLogin() + \"\\\", \\\"password\\\":\\\"\" + bridgeConfig.getPassword() + \"\\\"}\";\n+\n+            ContentResponse resp = createRequest(url)\n+                    .header(HttpHeader.ACCEPT, APPLICATION_JSON)\n+                    .content(new StringContentProvider(urlParameters), APPLICATION_JSON)\n+                    .send();\n+\n+            String line = resp.getContentAsString();\n+            logger.trace(\"login response: {}\", line);\n+            JablotronLoginResponse response = gson.fromJson(line, JablotronLoginResponse.class);\n+            if (response.getHttpCode() != 200) {\n+                logger.debug(\"Error during login, got http error: {}\", response.getHttpCode());\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, \"Http error: \" + String.valueOf(response.getHttpCode()));\n+            } else {\n+                logger.debug(\"Successfully logged in\");\n+                updateStatus(ThingStatus.ONLINE);\n+            }\n+        } catch (TimeoutException e) {\n+            logger.debug(\"Timeout during getting login cookie\", e);\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, \"Cannot login to Jablonet cloud\");\n+        } catch (ExecutionException | InterruptedException | JsonSyntaxException e) {\n+            logger.debug(\"Cannot get Jablotron login cookie\", e);\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, \"Cannot login to Jablonet cloud\");\n+        }\n+    }\n+\n+    protected synchronized void logout() {\n+        String url = JABLOTRON_API_URL + \"logout.json\";\n+        String urlParameters = \"system=\" + SYSTEM;\n+\n+        try {\n+            ContentResponse resp = createRequest(url)\n+                    .content(new StringContentProvider(urlParameters), \"application/x-www-form-urlencoded; charset=UTF-8\")\n+                    .send();\n+            String line = resp.getContentAsString();\n+\n+            logger.trace(\"logout response: {}\", line);\n+        } catch (ExecutionException | TimeoutException | InterruptedException e) {\n+            //Silence\n+        }\n+    }\n+\n+    public synchronized @Nullable List<JablotronDiscoveredService> discoverServices() {\n+        try {\n+            String url = JABLOTRON_API_URL + \"serviceListGet.json\";\n+            String urlParameters = \"{\\\"list-type\\\": \\\"EXTENDED\\\",\\\"visibility\\\": \\\"VISIBLE\\\"}\";\n+\n+            ContentResponse resp = createRequest(url)\n+                    .header(HttpHeader.ACCEPT, APPLICATION_JSON)\n+                    .content(new StringContentProvider(urlParameters), APPLICATION_JSON)\n+                    .send();\n+\n+            String line = resp.getContentAsString();\n+\n+            logger.trace(\"Response: {}\", line);\n+            JablotronGetServiceResponse response = gson.fromJson(line, JablotronGetServiceResponse.class);\n+\n+            if (response.getHttpCode() != 200) {\n+                logger.debug(\"Error during service discovery, got http code: {}\", response.getHttpCode());\n+            }\n+\n+            return response.getData().getServices();\n+        } catch (TimeoutException e) {\n+            logger.debug(\"Timeout during discovering services\", e);\n+        } catch (InterruptedException e) {\n+            logger.debug(\"Error during discovering services\", e);\n+        } catch (JsonSyntaxException e) {\n+            logger.debug(\"JSON syntax exception\", e);\n+        } catch (ExecutionException e) {\n+            if (e.getMessage().contains(AUTHENTICATION_CHALLENGE)) {\n+                relogin();\n+            } else {\n+                logger.debug(\"Error during discovering services\", e);\n+            }\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "36775963f2d1f6fd1e9689f06b070bfa8e6a859e"}, "originalPosition": 219}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzQyOTIxMA==", "bodyText": "Is this Exception thrown or can it be a specific exception that is being catched here?", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r483429210", "createdAt": "2020-09-04T07:07:08Z", "author": {"login": "Hilbrand"}, "path": "bundles/org.openhab.binding.jablotron/src/main/java/org/openhab/binding/jablotron/internal/handler/JablotronOasisHandler.java", "diffHunk": "@@ -0,0 +1,119 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.jablotron.internal.handler;\n+\n+import static org.openhab.binding.jablotron.JablotronBindingConstants.*;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.jablotron.internal.model.JablotronControlResponse;\n+import org.openhab.binding.jablotron.internal.model.JablotronServiceDetailSegment;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link JablotronOasisHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Ondrej Pecta - Initial contribution\n+ */\n+@NonNullByDefault\n+public class JablotronOasisHandler extends JablotronAlarmHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(JablotronOasisHandler.class);\n+\n+    public JablotronOasisHandler(Thing thing, String alarmName) {\n+        super(thing, alarmName);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (channelUID.getId().equals(CHANNEL_COMMAND) && command instanceof StringType) {\n+            scheduler.execute(() -> {\n+                sendCommand(command.toString());\n+            });\n+        }\n+\n+        if (channelUID.getId().equals(CHANNEL_STATUS_PGX) && command instanceof OnOffType) {\n+            scheduler.execute(() -> {\n+                controlSection(\"PGM_1\", command.equals(OnOffType.ON) ? \"set\" : \"unset\");\n+            });\n+        }\n+\n+        if (channelUID.getId().equals(CHANNEL_STATUS_PGY) && command instanceof OnOffType) {\n+            scheduler.execute(() -> {\n+                controlSection(\"PGM_2\", command.equals(OnOffType.ON) ? \"set\" : \"unset\");\n+            });\n+        }\n+    }\n+\n+    @Override\n+    protected void updateSegmentStatus(JablotronServiceDetailSegment segment) {\n+        logger.debug(\"Segment id: {} and status: {}\", segment.getSegmentId(), segment.getSegmentState());\n+        State newState = \"unset\".equals(segment.getSegmentState()) ? OnOffType.OFF : OnOffType.ON;\n+        switch (segment.getSegmentId()) {\n+            case \"STATE_1\":\n+                updateState(CHANNEL_STATUS_A, newState);\n+                break;\n+            case \"STATE_2\":\n+                updateState(CHANNEL_STATUS_B, newState);\n+                break;\n+            case \"STATE_3\":\n+                updateState(CHANNEL_STATUS_ABC, newState);\n+                break;\n+            case \"PGM_1\":\n+                updateState(CHANNEL_STATUS_PGX, newState);\n+                break;\n+            case \"PGM_2\":\n+                updateState(CHANNEL_STATUS_PGY, newState);\n+                break;\n+            default:\n+                logger.debug(\"Unknown segment received: {} with state: {}\", segment.getSegmentId(), segment.getSegmentState());\n+        }\n+    }\n+\n+    public synchronized void controlSection(String section, String status) {\n+        logger.debug(\"Controlling section: {} with status: {}\", section, status);\n+        JablotronControlResponse response = sendUserCode(section, section.toLowerCase(), status, \"\");\n+\n+        updateAlarmStatus();\n+        if (response == null) {\n+            logger.debug(\"null response/status received\");\n+        }\n+    }\n+\n+    public synchronized void sendCommand(String code) {\n+        try {\n+            JablotronControlResponse response = sendUserCode(code);\n+            scheduler.schedule(this::updateAlarmStatus, 1, TimeUnit.SECONDS);\n+\n+            if (response == null) {\n+                logger.debug(\"null response/status received\");\n+            }\n+        } catch (Exception e) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "36775963f2d1f6fd1e9689f06b070bfa8e6a859e"}, "originalPosition": 111}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mzc5NDYwMA==", "bodyText": "Maybe add some context to this debug message. Like what was send.", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r483794600", "createdAt": "2020-09-04T18:50:11Z", "author": {"login": "Hilbrand"}, "path": "bundles/org.openhab.binding.jablotron/src/main/java/org/openhab/binding/jablotron/internal/handler/JablotronJa100Handler.java", "diffHunk": "@@ -0,0 +1,198 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.jablotron.internal.handler;\n+\n+import java.util.List;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.binding.builder.ChannelBuilder;\n+import org.eclipse.smarthome.core.thing.binding.builder.ThingBuilder;\n+import org.eclipse.smarthome.core.thing.type.ChannelTypeUID;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.jablotron.internal.model.JablotronControlResponse;\n+import org.openhab.binding.jablotron.internal.model.JablotronServiceDetailSegment;\n+import org.openhab.binding.jablotron.internal.model.JablotronServiceDetailSegmentInfo;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link JablotronJa100Handler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Ondrej Pecta - Initial contribution\n+ */\n+@NonNullByDefault\n+public class JablotronJa100Handler extends JablotronAlarmHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(JablotronJa100Handler.class);\n+\n+    public JablotronJa100Handler(Thing thing, String alarmName) {\n+        super(thing, alarmName);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (channelUID.getId().startsWith(\"STATE_\") && command instanceof StringType) {\n+            scheduler.execute(() -> {\n+                controlSTATESection(channelUID.getId(), command.toString());\n+            });\n+        }\n+\n+        if (channelUID.getId().startsWith(\"PGM_\") && command instanceof OnOffType) {\n+            scheduler.execute(() -> {\n+                controlPGMSection(channelUID.getId(), command.equals(OnOffType.ON) ? \"set\" : \"unset\");\n+            });\n+        }\n+    }\n+\n+    private void createChannel(JablotronServiceDetailSegment section) {\n+        if (section.getSegmentId().startsWith(\"PGM_\")) {\n+            createPGMChannel(section.getSegmentId(), section.getSegmentName());\n+        } else {\n+            createStateChannel(section.getSegmentId(), section.getSegmentName());\n+        }\n+    }\n+\n+    private void createTempChannel(String name, String label) {\n+        ChannelTypeUID temperature = new ChannelTypeUID(\"jablotron\", \"temperature\");\n+        ThingBuilder thingBuilder = editThing();\n+        Channel channel = ChannelBuilder.create(new ChannelUID(thing.getUID(), name), \"Number:Temperature\").withLabel(label).withType(temperature).build();\n+        thingBuilder.withChannel(channel);\n+        updateThing(thingBuilder.build());\n+    }\n+\n+    private void createThermostatChannel(String name, String label) {\n+        ChannelTypeUID temperature = new ChannelTypeUID(\"jablotron\", \"thermostat\");\n+        ThingBuilder thingBuilder = editThing();\n+        Channel channel = ChannelBuilder.create(new ChannelUID(thing.getUID(), name), \"Number:Temperature\").withLabel(label).withType(temperature).build();\n+        thingBuilder.withChannel(channel);\n+        updateThing(thingBuilder.build());\n+    }\n+\n+    private void createPGMChannel(String name, String label) {\n+        ThingBuilder thingBuilder = editThing();\n+        Channel channel = ChannelBuilder.create(new ChannelUID(thing.getUID(), name), \"Switch\").withLabel(label).build();\n+        thingBuilder.withChannel(channel);\n+        updateThing(thingBuilder.build());\n+    }\n+\n+    private void createStateChannel(String name, String label) {\n+        ChannelTypeUID alarmStatus = new ChannelTypeUID(\"jablotron\", \"alarm_state\");\n+        ThingBuilder thingBuilder = editThing();\n+        Channel channel = ChannelBuilder.create(new ChannelUID(thing.getUID(), name), \"String\").withLabel(label).withType(alarmStatus).build();\n+        thingBuilder.withChannel(channel);\n+        updateThing(thingBuilder.build());\n+    }\n+\n+    @Override\n+    protected void updateSegmentStatus(JablotronServiceDetailSegment segment) {\n+        logger.debug(\"Segment id: {} and status: {}\", segment.getSegmentId(), segment.getSegmentState());\n+        String segmentId = segment.getSegmentId();\n+\n+        if (segmentId.startsWith(\"STATE_\") || segmentId.startsWith(\"PGM_\")) {\n+            processSection(segment);\n+        } else if (segmentId.startsWith(\"THERMOMETER_\")) {\n+            processThermometer(segment);\n+        } else if (segmentId.startsWith(\"THERMOSTAT_\")) {\n+            processThermostat(segment);\n+        }\n+        else {\n+            logger.debug(\"Unknown segment received: {} with state: {}\", segment.getSegmentId(), segment.getSegmentState());\n+        }\n+    }\n+\n+    private void processSection(JablotronServiceDetailSegment segment) {\n+        String segmentId = segment.getSegmentId();\n+        Channel channel = getThing().getChannel(segmentId);\n+        if (channel == null) {\n+            logger.debug(\"Creating a new channel: {}\", segmentId);\n+            createChannel(segment);\n+        }\n+        channel = getThing().getChannel(segmentId);\n+        if (channel != null) {\n+            logger.debug(\"Updating channel: {} to value: {}\", channel.getUID(), segment.getSegmentState());\n+            State newState;\n+            if (segmentId.startsWith(\"PGM_\")) {\n+                newState = \"unset\".equals(segment.getSegmentState()) ? OnOffType.OFF : OnOffType.ON;\n+            } else {\n+                newState = new StringType(segment.getSegmentState());\n+            }\n+            updateState(channel.getUID(), newState);\n+        } else {\n+            logger.debug(\"The channel: {} still doesn't exist!\", segmentId);\n+        }\n+    }\n+\n+    private void processThermometer(JablotronServiceDetailSegment segment) {\n+        String segmentId = segment.getSegmentId();\n+        Channel channel = getThing().getChannel(segmentId);\n+        if (channel == null) {\n+            logger.debug(\"Creating a new temperature channel: {}\", segmentId);\n+            createTempChannel(segmentId, segment.getSegmentName());\n+        }\n+        updateTemperatureChannel(channel, segment);\n+    }\n+\n+    private void processThermostat(JablotronServiceDetailSegment segment) {\n+        String segmentId = segment.getSegmentId();\n+        Channel channel = getThing().getChannel(segmentId);\n+        if (channel == null) {\n+            logger.debug(\"Creating a new thermostat channel: {}\", segmentId);\n+            createThermostatChannel(segmentId, segment.getSegmentName());\n+        }\n+        updateTemperatureChannel(channel, segment);\n+    }\n+\n+    private void updateTemperatureChannel(Channel channel, JablotronServiceDetailSegment segment) {\n+        String segmentId = segment.getSegmentId();\n+        if (channel != null) {\n+            List<JablotronServiceDetailSegmentInfo> infos = segment.getSegmentInfos();\n+            if (infos.size() > 0) {\n+                logger.debug(\"Found value: {} and type: {}\", infos.get(0).getValue(), infos.get(0).getType());\n+                DecimalType newState = new DecimalType(infos.get(0).getValue());\n+                updateState(channel.getUID(), newState);\n+            } else {\n+                logger.debug(\"No segment information received\");\n+            }\n+        } else {\n+            logger.debug(\"The channel: {} still doesn't exist!\", segmentId);\n+        }\n+    }\n+\n+    public synchronized void controlPGMSection(String section, String status) {\n+        logger.debug(\"Controlling section: {} with status: {}\", section, status);\n+        JablotronControlResponse response = sendUserCode(section, section.toLowerCase(), status, thingConfig.getCode());\n+\n+        updateAlarmStatus();\n+        if (response == null) {\n+            logger.debug(\"null response/status received\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "36775963f2d1f6fd1e9689f06b070bfa8e6a859e"}, "originalPosition": 185}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mzc5NjAxNA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                ScheduledFuture<?> future = null;\n          \n          \n            \n                @Nullable ScheduledFuture<?> future = null;", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r483796014", "createdAt": "2020-09-04T18:53:47Z", "author": {"login": "Hilbrand"}, "path": "bundles/org.openhab.binding.jablotron/src/main/java/org/openhab/binding/jablotron/internal/handler/JablotronBridgeHandler.java", "diffHunk": "@@ -0,0 +1,452 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.jablotron.internal.handler;\n+\n+import static org.openhab.binding.jablotron.JablotronBindingConstants.*;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.JsonSyntaxException;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.eclipse.jetty.http.HttpHeader;\n+import org.eclipse.jetty.http.HttpMethod;\n+import org.eclipse.smarthome.config.core.status.ConfigStatusMessage;\n+import org.eclipse.smarthome.core.thing.*;\n+import org.eclipse.smarthome.core.thing.binding.ConfigStatusBridgeHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.openhab.binding.jablotron.internal.config.JablotronBridgeConfig;\n+import org.openhab.binding.jablotron.internal.model.*;\n+import org.openhab.binding.jablotron.internal.model.ja100f.JablotronGetPGResponse;\n+import org.openhab.binding.jablotron.internal.model.ja100f.JablotronGetSectionsResponse;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link JablotronBridgeHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Ondrej Pecta - Initial contribution\n+ */\n+@NonNullByDefault\n+public class JablotronBridgeHandler extends ConfigStatusBridgeHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(JablotronBridgeHandler.class);\n+\n+    private Gson gson = new Gson();\n+\n+    final HttpClient httpClient;\n+\n+    @Nullable\n+    ScheduledFuture<?> future = null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "36775963f2d1f6fd1e9689f06b070bfa8e6a859e"}, "originalPosition": 63}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mzc5NjA2Mw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private Gson gson = new Gson();\n          \n          \n            \n                private final Gson gson = new Gson();", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r483796063", "createdAt": "2020-09-04T18:53:58Z", "author": {"login": "Hilbrand"}, "path": "bundles/org.openhab.binding.jablotron/src/main/java/org/openhab/binding/jablotron/internal/handler/JablotronBridgeHandler.java", "diffHunk": "@@ -0,0 +1,452 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.jablotron.internal.handler;\n+\n+import static org.openhab.binding.jablotron.JablotronBindingConstants.*;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.JsonSyntaxException;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.eclipse.jetty.http.HttpHeader;\n+import org.eclipse.jetty.http.HttpMethod;\n+import org.eclipse.smarthome.config.core.status.ConfigStatusMessage;\n+import org.eclipse.smarthome.core.thing.*;\n+import org.eclipse.smarthome.core.thing.binding.ConfigStatusBridgeHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.openhab.binding.jablotron.internal.config.JablotronBridgeConfig;\n+import org.openhab.binding.jablotron.internal.model.*;\n+import org.openhab.binding.jablotron.internal.model.ja100f.JablotronGetPGResponse;\n+import org.openhab.binding.jablotron.internal.model.ja100f.JablotronGetSectionsResponse;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link JablotronBridgeHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Ondrej Pecta - Initial contribution\n+ */\n+@NonNullByDefault\n+public class JablotronBridgeHandler extends ConfigStatusBridgeHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(JablotronBridgeHandler.class);\n+\n+    private Gson gson = new Gson();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "36775963f2d1f6fd1e9689f06b070bfa8e6a859e"}, "originalPosition": 58}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mzc5NjU4OA==", "bodyText": "Is this necessay to override?. Same for disposed method?", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r483796588", "createdAt": "2020-09-04T18:55:08Z", "author": {"login": "Hilbrand"}, "path": "bundles/org.openhab.binding.jablotron/src/main/java/org/openhab/binding/jablotron/internal/handler/JablotronBridgeHandler.java", "diffHunk": "@@ -0,0 +1,452 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.jablotron.internal.handler;\n+\n+import static org.openhab.binding.jablotron.JablotronBindingConstants.*;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.JsonSyntaxException;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.eclipse.jetty.http.HttpHeader;\n+import org.eclipse.jetty.http.HttpMethod;\n+import org.eclipse.smarthome.config.core.status.ConfigStatusMessage;\n+import org.eclipse.smarthome.core.thing.*;\n+import org.eclipse.smarthome.core.thing.binding.ConfigStatusBridgeHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.openhab.binding.jablotron.internal.config.JablotronBridgeConfig;\n+import org.openhab.binding.jablotron.internal.model.*;\n+import org.openhab.binding.jablotron.internal.model.ja100f.JablotronGetPGResponse;\n+import org.openhab.binding.jablotron.internal.model.ja100f.JablotronGetSectionsResponse;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link JablotronBridgeHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Ondrej Pecta - Initial contribution\n+ */\n+@NonNullByDefault\n+public class JablotronBridgeHandler extends ConfigStatusBridgeHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(JablotronBridgeHandler.class);\n+\n+    private Gson gson = new Gson();\n+\n+    final HttpClient httpClient;\n+\n+    @Nullable\n+    ScheduledFuture<?> future = null;\n+\n+    /**\n+     * Our configuration\n+     */\n+    public JablotronBridgeConfig bridgeConfig = new JablotronBridgeConfig();\n+\n+    public JablotronBridgeHandler(Bridge thing, HttpClient httpClient) {\n+        super(thing);\n+        this.httpClient = httpClient;\n+    }\n+\n+    @Override\n+    public Collection<ConfigStatusMessage> getConfigStatus() {\n+        return Collections.emptyList();\n+    }\n+\n+    @Override\n+    public void childHandlerInitialized(ThingHandler thingHandler, Thing thing) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "36775963f2d1f6fd1e9689f06b070bfa8e6a859e"}, "originalPosition": 81}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzgwMjQ5Nw==", "bodyText": "The design you have used here is that a thing id represents a identiffier. However, convention is that the id of a thing should not be used, but can freely be defined by the user. The design should be that the serviceId is a parameter of a thing.", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r483802497", "createdAt": "2020-09-04T19:10:11Z", "author": {"login": "Hilbrand"}, "path": "bundles/org.openhab.binding.jablotron/src/main/java/org/openhab/binding/jablotron/internal/handler/JablotronBridgeHandler.java", "diffHunk": "@@ -0,0 +1,452 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.jablotron.internal.handler;\n+\n+import static org.openhab.binding.jablotron.JablotronBindingConstants.*;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.JsonSyntaxException;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.eclipse.jetty.http.HttpHeader;\n+import org.eclipse.jetty.http.HttpMethod;\n+import org.eclipse.smarthome.config.core.status.ConfigStatusMessage;\n+import org.eclipse.smarthome.core.thing.*;\n+import org.eclipse.smarthome.core.thing.binding.ConfigStatusBridgeHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.openhab.binding.jablotron.internal.config.JablotronBridgeConfig;\n+import org.openhab.binding.jablotron.internal.model.*;\n+import org.openhab.binding.jablotron.internal.model.ja100f.JablotronGetPGResponse;\n+import org.openhab.binding.jablotron.internal.model.ja100f.JablotronGetSectionsResponse;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link JablotronBridgeHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Ondrej Pecta - Initial contribution\n+ */\n+@NonNullByDefault\n+public class JablotronBridgeHandler extends ConfigStatusBridgeHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(JablotronBridgeHandler.class);\n+\n+    private Gson gson = new Gson();\n+\n+    final HttpClient httpClient;\n+\n+    @Nullable\n+    ScheduledFuture<?> future = null;\n+\n+    /**\n+     * Our configuration\n+     */\n+    public JablotronBridgeConfig bridgeConfig = new JablotronBridgeConfig();\n+\n+    public JablotronBridgeHandler(Bridge thing, HttpClient httpClient) {\n+        super(thing);\n+        this.httpClient = httpClient;\n+    }\n+\n+    @Override\n+    public Collection<ConfigStatusMessage> getConfigStatus() {\n+        return Collections.emptyList();\n+    }\n+\n+    @Override\n+    public void childHandlerInitialized(ThingHandler thingHandler, Thing thing) {\n+    }\n+\n+    @Override\n+    public void childHandlerDisposed(ThingHandler thingHandler, Thing thing) {\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        bridgeConfig = getConfigAs(JablotronBridgeConfig.class);\n+        scheduler.execute(this::login);\n+        future = scheduler.scheduleWithFixedDelay(() -> updateAlarmThings(), 30, bridgeConfig.getRefresh(), TimeUnit.SECONDS);\n+    }\n+\n+    private void updateAlarmThings() {\n+        List<JablotronDiscoveredService> services = discoverServices();\n+        if (services != null) {\n+            for (JablotronDiscoveredService service : services) {\n+                updateAlarmThing(service);\n+            }\n+        }\n+    }\n+\n+    private void updateAlarmThing(JablotronDiscoveredService service) {\n+        for (Thing th : getThing().getThings()) {\n+            if (String.valueOf(service.getId()).equals(th.getUID().getId())) {\n+                JablotronAlarmHandler handler = (JablotronAlarmHandler) th.getHandler();\n+                if (handler == null) {\n+                    logger.debug(\"Thing handler is null\");\n+                    continue;\n+                }\n+                if (\"ENABLED\".equals(service.getStatus())) {\n+                    if (!\"\".equals(service.getWarning())) {\n+                        logger.debug(\"Alarm with service id: {} warning: {}\", service.getId(), service.getWarning());\n+                    }\n+                    handler.setStatus(ThingStatus.ONLINE, ThingStatusDetail.NONE, service.getWarning());\n+                    if (\"ALARM\".equals(service.getWarning()) || \"TAMPER\".equals(service.getWarning())) {\n+                        handler.triggerAlarm(service);\n+                    }\n+                    handler.setInService(\"SERVICE\".equals(service.getWarning()));\n+                } else {\n+                    logger.debug(\"Alarm with service id: {} is offline\", service.getId());\n+                    handler.setStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, service.getStatus());\n+                }\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        super.dispose();\n+        if (future != null) {\n+            future.cancel(true);\n+        }\n+        logout();\n+    }\n+\n+    protected synchronized void login() {\n+        try {\n+            String url = JABLOTRON_API_URL + \"userAuthorize.json\";\n+            String urlParameters = \"{\\\"login\\\":\\\"\" + bridgeConfig.getLogin() + \"\\\", \\\"password\\\":\\\"\" + bridgeConfig.getPassword() + \"\\\"}\";\n+\n+            ContentResponse resp = createRequest(url)\n+                    .header(HttpHeader.ACCEPT, APPLICATION_JSON)\n+                    .content(new StringContentProvider(urlParameters), APPLICATION_JSON)\n+                    .send();\n+\n+            String line = resp.getContentAsString();\n+            logger.trace(\"login response: {}\", line);\n+            JablotronLoginResponse response = gson.fromJson(line, JablotronLoginResponse.class);\n+            if (response.getHttpCode() != 200) {\n+                logger.debug(\"Error during login, got http error: {}\", response.getHttpCode());\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, \"Http error: \" + String.valueOf(response.getHttpCode()));\n+            } else {\n+                logger.debug(\"Successfully logged in\");\n+                updateStatus(ThingStatus.ONLINE);\n+            }\n+        } catch (TimeoutException e) {\n+            logger.debug(\"Timeout during getting login cookie\", e);\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, \"Cannot login to Jablonet cloud\");\n+        } catch (ExecutionException | InterruptedException | JsonSyntaxException e) {\n+            logger.debug(\"Cannot get Jablotron login cookie\", e);\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, \"Cannot login to Jablonet cloud\");\n+        }\n+    }\n+\n+    protected synchronized void logout() {\n+        String url = JABLOTRON_API_URL + \"logout.json\";\n+        String urlParameters = \"system=\" + SYSTEM;\n+\n+        try {\n+            ContentResponse resp = createRequest(url)\n+                    .content(new StringContentProvider(urlParameters), \"application/x-www-form-urlencoded; charset=UTF-8\")\n+                    .send();\n+            String line = resp.getContentAsString();\n+\n+            logger.trace(\"logout response: {}\", line);\n+        } catch (ExecutionException | TimeoutException | InterruptedException e) {\n+            //Silence\n+        }\n+    }\n+\n+    public synchronized @Nullable List<JablotronDiscoveredService> discoverServices() {\n+        try {\n+            String url = JABLOTRON_API_URL + \"serviceListGet.json\";\n+            String urlParameters = \"{\\\"list-type\\\": \\\"EXTENDED\\\",\\\"visibility\\\": \\\"VISIBLE\\\"}\";\n+\n+            ContentResponse resp = createRequest(url)\n+                    .header(HttpHeader.ACCEPT, APPLICATION_JSON)\n+                    .content(new StringContentProvider(urlParameters), APPLICATION_JSON)\n+                    .send();\n+\n+            String line = resp.getContentAsString();\n+\n+            logger.trace(\"Response: {}\", line);\n+            JablotronGetServiceResponse response = gson.fromJson(line, JablotronGetServiceResponse.class);\n+\n+            if (response.getHttpCode() != 200) {\n+                logger.debug(\"Error during service discovery, got http code: {}\", response.getHttpCode());\n+            }\n+\n+            return response.getData().getServices();\n+        } catch (TimeoutException e) {\n+            logger.debug(\"Timeout during discovering services\", e);\n+        } catch (InterruptedException e) {\n+            logger.debug(\"Error during discovering services\", e);\n+        } catch (JsonSyntaxException e) {\n+            logger.debug(\"JSON syntax exception\", e);\n+        } catch (ExecutionException e) {\n+            if (e.getMessage().contains(AUTHENTICATION_CHALLENGE)) {\n+                relogin();\n+            } else {\n+                logger.debug(\"Error during discovering services\", e);\n+            }\n+        }\n+        return null;\n+    }\n+\n+    protected synchronized @Nullable JablotronControlResponse sendUserCode(Thing th, String section, String key, String status, String code) throws SecurityException {\n+        String url;\n+        JablotronAlarmHandler handler = (JablotronAlarmHandler) th.getHandler();\n+\n+        if (handler == null) {\n+            logger.debug(\"Thing handler is null\");\n+            return null;\n+        }\n+\n+        if (handler.isInService()) {\n+            logger.debug(\"Cannot send command because the alarm is in the service mode\");\n+            return null;\n+        }\n+\n+        try {\n+            url = JABLOTRON_API_URL + \"controlSegment.json\";\n+            String urlParameters = \"service=\" + th.getThingTypeUID().getId() + \"&serviceId=\" + th.getUID().getId() + \"&segmentId=\" + section + \"&segmentKey=\" + key + \"&expected_status=\" + status + \"&control_time=0&control_code=\" + code + \"&system=\" + SYSTEM;\n+            logger.debug(\"Sending POST to url address: {} to control section: {}\", url, section);\n+            logger.trace(\"Url parameters: {}\", urlParameters);\n+\n+            ContentResponse resp = createRequest(url)\n+                    .content(new StringContentProvider(urlParameters), \"application/x-www-form-urlencoded; charset=UTF-8\")\n+                    .send();\n+\n+            String line = resp.getContentAsString();\n+\n+            logger.trace(\"Control response: {}\", line);\n+            JablotronControlResponse response = gson.fromJson(line, JablotronControlResponse.class);\n+            if (!response.isStatus()) {\n+                logger.debug(\"Error during sending user code: {}\", response.getErrorMessage());\n+            }\n+            return response;\n+        } catch (TimeoutException e) {\n+            logger.debug(\"sendUserCode timeout exception\", e);\n+        } catch (InterruptedException e) {\n+            logger.debug(\"sendUserCode exception\", e);\n+        } catch (JsonSyntaxException e) {\n+            logger.debug(\"JSON syntax exception\", e);\n+        } catch (ExecutionException e) {\n+            if (e.getMessage().contains(AUTHENTICATION_CHALLENGE)) {\n+                relogin();\n+                throw new SecurityException(AUTHENTICATION_CHALLENGE);\n+            } else {\n+                logger.debug(\"sendUserCode exception\", e);\n+            }\n+        }\n+        return null;\n+    }\n+\n+    protected synchronized @Nullable List<JablotronHistoryDataEvent> sendGetEventHistory(Thing th, String alarm) {\n+        String url = JABLOTRON_API_URL + alarm + \"/eventHistoryGet.json\";\n+        String urlParameters = \"{\\\"limit\\\":1, \\\"service-id\\\":\" + th.getUID().getId() + \"}\";\n+\n+        try {\n+            ContentResponse resp = createRequest(url)\n+                    .header(HttpHeader.ACCEPT, APPLICATION_JSON)\n+                    .content(new StringContentProvider(urlParameters), APPLICATION_JSON)\n+                    .send();\n+\n+            String line = resp.getContentAsString();\n+            logger.trace(\"get event history: {}\", line);\n+            JablotronGetEventHistoryResponse response = gson.fromJson(line, JablotronGetEventHistoryResponse.class);\n+            if (200 != response.getHttpCode()) {\n+                logger.debug(\"Got error while getting history with http code: {}\", response.getHttpCode());\n+            }\n+            return response.getData().getEvents();\n+        } catch (TimeoutException e) {\n+            logger.debug(\"Timeout during getting alarm history!\", e);\n+        } catch (InterruptedException e) {\n+            logger.debug(\"sendGetEventHistory exception\", e);\n+        } catch (JsonSyntaxException e) {\n+            logger.debug(\"JSON syntax exception\", e);\n+        } catch (ExecutionException e) {\n+            if (e.getMessage().contains(AUTHENTICATION_CHALLENGE)) {\n+                relogin();\n+            } else {\n+                logger.debug(\"sendGetEventHistory exception\", e);\n+            }\n+        }\n+        return null;\n+    }\n+\n+    protected synchronized @Nullable JablotronDataUpdateResponse sendGetStatusRequest(Thing th) {\n+        String url = JABLOTRON_API_URL + \"dataUpdate.json\";\n+        String urlParameters = \"data=[{ \\\"filter_data\\\":[{\\\"data_type\\\":\\\"section\\\"},{\\\"data_type\\\":\\\"pgm\\\"},{\\\"data_type\\\":\\\"thermometer\\\"},{\\\"data_type\\\":\\\"thermostat\\\"}],\\\"service_type\\\":\\\"\" + th.getThingTypeUID().getId() + \"\\\",\\\"service_id\\\":\" + th.getUID().getId() + \",\\\"data_group\\\":\\\"serviceData\\\"}]&system=\" + SYSTEM;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "36775963f2d1f6fd1e9689f06b070bfa8e6a859e"}, "originalPosition": 307}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fd5e10d20825e53071c28421cbe41e948b0b3d2d", "author": {"user": {"login": "octa22", "name": "Ondrej Pecta"}}, "url": "https://github.com/openhab/openhab-addons/commit/fd5e10d20825e53071c28421cbe41e948b0b3d2d", "committedDate": "2020-09-06T19:45:30Z", "message": "[jablotron] Jablotron binding initial contribution\n\nSigned-off-by: Ondrej Pecta <opecta@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a1c5f2bb0924e0f6d02b68e1651304f4425f7266", "author": {"user": {"login": "octa22", "name": "Ondrej Pecta"}}, "url": "https://github.com/openhab/openhab-addons/commit/a1c5f2bb0924e0f6d02b68e1651304f4425f7266", "committedDate": "2020-09-06T19:45:30Z", "message": "[jablotron] added support for JA100 thermometers\n\nSigned-off-by: Ondrej Pecta <opecta@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b951b508ec412dd3ef99e3fa0af4033c53228ed6", "author": {"user": {"login": "octa22", "name": "Ondrej Pecta"}}, "url": "https://github.com/openhab/openhab-addons/commit/b951b508ec412dd3ef99e3fa0af4033c53228ed6", "committedDate": "2020-09-06T19:45:30Z", "message": "[jablotron] fix NPE\n\nSigned-off-by: Ondrej Pecta <opecta@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "415bbfeb705363edb54324518a06b1c277b08af9", "author": {"user": {"login": "octa22", "name": "Ondrej Pecta"}}, "url": "https://github.com/openhab/openhab-addons/commit/415bbfeb705363edb54324518a06b1c277b08af9", "committedDate": "2020-09-06T19:45:30Z", "message": "[jablotron] improved the documentation\n\nSigned-off-by: Ondrej Pecta <opecta@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a40fe3db2a2fb9f73e24ea13d1e45ad13c9be432", "author": {"user": {"login": "octa22", "name": "Ondrej Pecta"}}, "url": "https://github.com/openhab/openhab-addons/commit/a40fe3db2a2fb9f73e24ea13d1e45ad13c9be432", "committedDate": "2020-09-06T19:45:30Z", "message": "[jablotron] proper reaction to an authentication challenge exception\n\nSigned-off-by: Ondrej Pecta <opecta@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2090ab03e884f6c944d8dfb3908294c368376e42", "author": {"user": {"login": "octa22", "name": "Ondrej Pecta"}}, "url": "https://github.com/openhab/openhab-addons/commit/2090ab03e884f6c944d8dfb3908294c368376e42", "committedDate": "2020-09-06T19:45:30Z", "message": "[jablotron] improved the binding robustness\n\nSigned-off-by: Ondrej Pecta <opecta@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8c904e3ff7298b8d84760d013617bd8eb7a36ab4", "author": {"user": {"login": "octa22", "name": "Ondrej Pecta"}}, "url": "https://github.com/openhab/openhab-addons/commit/8c904e3ff7298b8d84760d013617bd8eb7a36ab4", "committedDate": "2020-09-06T19:45:30Z", "message": "[jablotron] bump to the next version\n\nSigned-off-by: Ondrej Pecta <opecta@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "211a0ba826f477603b801ef9c5bfc1c90f2478e2", "author": {"user": {"login": "octa22", "name": "Ondrej Pecta"}}, "url": "https://github.com/openhab/openhab-addons/commit/211a0ba826f477603b801ef9c5bfc1c90f2478e2", "committedDate": "2020-09-06T19:45:31Z", "message": "[jablotron] Bump to the next version, improved detection of alarms\n\nSigned-off-by: Ondrej Pecta <opecta@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8998bd20454a7789d89eabb807f3da7e2af8ec33", "author": {"user": {"login": "octa22", "name": "Ondrej Pecta"}}, "url": "https://github.com/openhab/openhab-addons/commit/8998bd20454a7789d89eabb807f3da7e2af8ec33", "committedDate": "2020-09-06T19:45:31Z", "message": "[jablotron] Bump to the next version\n\nSigned-off-by: Ondrej Pecta <opecta@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8c508ac966c84921920e6b660b54dafc37c76736", "author": {"user": {"login": "octa22", "name": "Ondrej Pecta"}}, "url": "https://github.com/openhab/openhab-addons/commit/8c508ac966c84921920e6b660b54dafc37c76736", "committedDate": "2020-09-06T19:45:31Z", "message": "[jablotron] added support for the thermostat temperature\n\nSigned-off-by: Ondrej Pecta <opecta@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a029f424e56b4a3bc39b73147d3336ecbd4b4456", "author": {"user": {"login": "octa22", "name": "Ondrej Pecta"}}, "url": "https://github.com/openhab/openhab-addons/commit/a029f424e56b4a3bc39b73147d3336ecbd4b4456", "committedDate": "2020-09-06T19:45:31Z", "message": "[jablotron] applied mvn:spotless\n\nSigned-off-by: Ondrej Pecta <opecta@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7fdea73f32b1dbad02b9f990cafa0f2b777871ec", "author": {"user": {"login": "octa22", "name": "Ondrej Pecta"}}, "url": "https://github.com/openhab/openhab-addons/commit/7fdea73f32b1dbad02b9f990cafa0f2b777871ec", "committedDate": "2020-09-06T19:45:31Z", "message": "[jablotron] Fixes based on the code review\n\nSigned-off-by: Ondrej Pecta <opecta@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "51cf2d1d427168f58488e404374fb842d8f26172", "author": {"user": {"login": "octa22", "name": "Ondrej Pecta"}}, "url": "https://github.com/openhab/openhab-addons/commit/51cf2d1d427168f58488e404374fb842d8f26172", "committedDate": "2020-09-06T19:46:52Z", "message": "[jablotron] bump to the next version\n\nSigned-off-by: Ondrej Pecta <opecta@gmail.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "ed1b44f1d62493afc6c9490e9f4a9775e988c6ca", "author": {"user": {"login": "octa22", "name": "Ondrej Pecta"}}, "url": "https://github.com/openhab/openhab-addons/commit/ed1b44f1d62493afc6c9490e9f4a9775e988c6ca", "committedDate": "2020-09-06T19:44:26Z", "message": "[jablotron] Fixes based on the code review\n\nSigned-off-by: Ondrej Pecta <opecta@gmail.com>"}, "afterCommit": {"oid": "51cf2d1d427168f58488e404374fb842d8f26172", "author": {"user": {"login": "octa22", "name": "Ondrej Pecta"}}, "url": "https://github.com/openhab/openhab-addons/commit/51cf2d1d427168f58488e404374fb842d8f26172", "committedDate": "2020-09-06T19:46:52Z", "message": "[jablotron] bump to the next version\n\nSigned-off-by: Ondrej Pecta <opecta@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "60de8c7ff2ab05cfd2d545ab87074d210268d604", "author": {"user": {"login": "octa22", "name": "Ondrej Pecta"}}, "url": "https://github.com/openhab/openhab-addons/commit/60de8c7ff2ab05cfd2d545ab87074d210268d604", "committedDate": "2020-09-06T20:19:38Z", "message": "[jablotron] serviceId is mandatory config parameter now\n\nSigned-off-by: Ondrej Pecta <opecta@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5db49e4d398e1ddeb9ac1b46ce361b0178a4c7f7", "author": {"user": {"login": "octa22", "name": "Ondrej Pecta"}}, "url": "https://github.com/openhab/openhab-addons/commit/5db49e4d398e1ddeb9ac1b46ce361b0178a4c7f7", "committedDate": "2020-09-06T23:13:51Z", "message": "[jablotron] next bucket of improvements based on the code review\n\nSigned-off-by: Ondrej Pecta <opecta@gmail.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "7e4bffde5c7ab03fe2e2d99f0b62f3da7c0c6870", "author": {"user": {"login": "octa22", "name": "Ondrej Pecta"}}, "url": "https://github.com/openhab/openhab-addons/commit/7e4bffde5c7ab03fe2e2d99f0b62f3da7c0c6870", "committedDate": "2020-09-06T22:59:24Z", "message": "[jablotron] next bucket of improvements based on the code review\n\nSigned-off-by: Ondrej Pecta <opecta@gmail.com>"}, "afterCommit": {"oid": "5db49e4d398e1ddeb9ac1b46ce361b0178a4c7f7", "author": {"user": {"login": "octa22", "name": "Ondrej Pecta"}}, "url": "https://github.com/openhab/openhab-addons/commit/5db49e4d398e1ddeb9ac1b46ce361b0178a4c7f7", "committedDate": "2020-09-06T23:13:51Z", "message": "[jablotron] next bucket of improvements based on the code review\n\nSigned-off-by: Ondrej Pecta <opecta@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c1ffbb591d92a8b648e7420168c9b836c0bf9b10", "author": {"user": {"login": "octa22", "name": "Ondrej Pecta"}}, "url": "https://github.com/openhab/openhab-addons/commit/c1ffbb591d92a8b648e7420168c9b836c0bf9b10", "committedDate": "2020-09-07T21:02:52Z", "message": "[jablotron] code cleanup\n\nSigned-off-by: Ondrej Pecta <opecta@gmail.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "bee9afd8f48a63723d7f8bea1c2660f3cf799053", "author": {"user": {"login": "octa22", "name": "Ondrej Pecta"}}, "url": "https://github.com/openhab/openhab-addons/commit/bee9afd8f48a63723d7f8bea1c2660f3cf799053", "committedDate": "2020-09-07T20:25:41Z", "message": "[jablotron] code cleanup\n\nSigned-off-by: Ondrej Pecta <opecta@gmail.com>"}, "afterCommit": {"oid": "c1ffbb591d92a8b648e7420168c9b836c0bf9b10", "author": {"user": {"login": "octa22", "name": "Ondrej Pecta"}}, "url": "https://github.com/openhab/openhab-addons/commit/c1ffbb591d92a8b648e7420168c9b836c0bf9b10", "committedDate": "2020-09-07T21:02:52Z", "message": "[jablotron] code cleanup\n\nSigned-off-by: Ondrej Pecta <opecta@gmail.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg0NDE5NzQ5", "url": "https://github.com/openhab/openhab-addons/pull/6990#pullrequestreview-484419749", "createdAt": "2020-09-08T19:09:18Z", "commit": {"oid": "c1ffbb591d92a8b648e7420168c9b836c0bf9b10"}, "state": "COMMENTED", "comments": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOFQxOTowOToxOFrOHOqcqQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOFQyMDo0OTowNFrOHOthAg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTEzNzU3Nw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            @Component(service = ThingHandlerFactory.class, immediate = true)\n          \n          \n            \n            @Component(service = ThingHandlerFactory.class)", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r485137577", "createdAt": "2020-09-08T19:09:18Z", "author": {"login": "Hilbrand"}, "path": "bundles/org.openhab.binding.jablotron/src/main/java/org/openhab/binding/jablotron/internal/JablotronHandlerFactory.java", "diffHunk": "@@ -0,0 +1,77 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.jablotron.internal;\n+\n+import static org.openhab.binding.jablotron.JablotronBindingConstants.*;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.thing.ThingUID;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandlerFactory;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerFactory;\n+import org.eclipse.smarthome.io.net.http.HttpClientFactory;\n+import org.openhab.binding.jablotron.internal.handler.JablotronBridgeHandler;\n+import org.openhab.binding.jablotron.internal.handler.JablotronJa100FHandler;\n+import org.openhab.binding.jablotron.internal.handler.JablotronJa100Handler;\n+import org.openhab.binding.jablotron.internal.handler.JablotronOasisHandler;\n+import org.osgi.framework.ServiceRegistration;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Reference;\n+\n+/**\n+ * The {@link JablotronHandlerFactory} is responsible for creating things and thing\n+ * handlers.\n+ *\n+ * @author Ondrej Pecta - Initial contribution\n+ */\n+@NonNullByDefault\n+@Component(service = ThingHandlerFactory.class, immediate = true)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c1ffbb591d92a8b648e7420168c9b836c0bf9b10"}, "originalPosition": 46}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTEzNzc3OA==", "bodyText": "This field can be removed.", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r485137778", "createdAt": "2020-09-08T19:09:43Z", "author": {"login": "Hilbrand"}, "path": "bundles/org.openhab.binding.jablotron/src/main/java/org/openhab/binding/jablotron/internal/JablotronHandlerFactory.java", "diffHunk": "@@ -0,0 +1,77 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.jablotron.internal;\n+\n+import static org.openhab.binding.jablotron.JablotronBindingConstants.*;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.thing.ThingUID;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandlerFactory;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerFactory;\n+import org.eclipse.smarthome.io.net.http.HttpClientFactory;\n+import org.openhab.binding.jablotron.internal.handler.JablotronBridgeHandler;\n+import org.openhab.binding.jablotron.internal.handler.JablotronJa100FHandler;\n+import org.openhab.binding.jablotron.internal.handler.JablotronJa100Handler;\n+import org.openhab.binding.jablotron.internal.handler.JablotronOasisHandler;\n+import org.osgi.framework.ServiceRegistration;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Reference;\n+\n+/**\n+ * The {@link JablotronHandlerFactory} is responsible for creating things and thing\n+ * handlers.\n+ *\n+ * @author Ondrej Pecta - Initial contribution\n+ */\n+@NonNullByDefault\n+@Component(service = ThingHandlerFactory.class, immediate = true)\n+public class JablotronHandlerFactory extends BaseThingHandlerFactory {\n+\n+    private Map<ThingUID, ServiceRegistration<?>> discoveryServiceRegs = new HashMap<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c1ffbb591d92a8b648e7420168c9b836c0bf9b10"}, "originalPosition": 49}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTEzOTYzMg==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public static final int TIMEOUT = 10;\n          \n          \n            \n                public static final int TIMEOUT_SEC = 10;", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r485139632", "createdAt": "2020-09-08T19:13:24Z", "author": {"login": "Hilbrand"}, "path": "bundles/org.openhab.binding.jablotron/src/main/java/org/openhab/binding/jablotron/JablotronBindingConstants.java", "diffHunk": "@@ -0,0 +1,71 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.jablotron;\n+\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+\n+/**\n+ * The {@link JablotronBindingConstants} class defines common constants, which are\n+ * used across the whole binding.\n+ *\n+ * @author Ondrej Pecta - Initial contribution\n+ */\n+@NonNullByDefault\n+public class JablotronBindingConstants {\n+\n+    private static final String BINDING_ID = \"jablotron\";\n+\n+    // List of all Thing Type UIDs\n+    public static final ThingTypeUID THING_TYPE_BRIDGE = new ThingTypeUID(BINDING_ID, \"bridge\");\n+    public static final ThingTypeUID THING_TYPE_OASIS = new ThingTypeUID(BINDING_ID, \"oasis\");\n+    public static final ThingTypeUID THING_TYPE_JA100 = new ThingTypeUID(BINDING_ID, \"ja100\");\n+    public static final ThingTypeUID THING_TYPE_JA100F = new ThingTypeUID(BINDING_ID, \"ja100f\");\n+\n+    // Common alarm channels\n+    public static final String CHANNEL_ALARM = \"alarm\";\n+    public static final String CHANNEL_LAST_CHECK_TIME = \"lastCheckTime\";\n+    public static final String CHANNEL_LAST_EVENT = \"lastEvent\";\n+    public static final String CHANNEL_LAST_EVENT_CLASS = \"lastEventClass\";\n+    public static final String CHANNEL_LAST_EVENT_TIME = \"lastEventTime\";\n+    public static final String CHANNEL_LAST_EVENT_INVOKER = \"lastEventInvoker\";\n+    public static final String CHANNEL_LAST_EVENT_SECTION = \"lastEventSection\";\n+\n+    // List of all OASIS Channel ids\n+    public static final String CHANNEL_COMMAND = \"command\";\n+    public static final String CHANNEL_STATUS_A = \"statusA\";\n+    public static final String CHANNEL_STATUS_B = \"statusB\";\n+    public static final String CHANNEL_STATUS_ABC = \"statusABC\";\n+    public static final String CHANNEL_STATUS_PGX = \"statusPGX\";\n+    public static final String CHANNEL_STATUS_PGY = \"statusPGY\";\n+\n+    // Constants\n+    public static final String JABLOTRON_API_URL = \"https://api.jablonet.net/api/1.6/\";\n+    public static final String AGENT = \"Swagger-Codegen/1.0.0/android\";\n+    public static final int TIMEOUT = 10;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c1ffbb591d92a8b648e7420168c9b836c0bf9b10"}, "originalPosition": 59}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTEzOTkyNQ==", "bodyText": "This won't age well \ud83d\ude09\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            This is the OH2.x binding for Jablotron alarms.\n          \n          \n            \n            This is the binding for Jablotron alarms.", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r485139925", "createdAt": "2020-09-08T19:13:58Z", "author": {"login": "Hilbrand"}, "path": "bundles/org.openhab.binding.jablotron/README.md", "diffHunk": "@@ -0,0 +1,120 @@\n+# Jablotron Alarm Binding\n+\n+This is the OH2.x binding for Jablotron alarms.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c1ffbb591d92a8b648e7420168c9b836c0bf9b10"}, "originalPosition": 3}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE0MTE3Mw==", "bodyText": "As this is an abstract class maybe use getClass() to know which specific subclass logs:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private final Logger logger = LoggerFactory.getLogger(JablotronAlarmHandler.class);\n          \n          \n            \n                private final Logger logger = LoggerFactory.getLogger(getClass());", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r485141173", "createdAt": "2020-09-08T19:16:22Z", "author": {"login": "Hilbrand"}, "path": "bundles/org.openhab.binding.jablotron/src/main/java/org/openhab/binding/jablotron/internal/handler/JablotronAlarmHandler.java", "diffHunk": "@@ -0,0 +1,219 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.jablotron.internal.handler;\n+\n+import static org.openhab.binding.jablotron.JablotronBindingConstants.*;\n+\n+import java.time.ZoneId;\n+import java.time.ZonedDateTime;\n+import java.time.format.DateTimeFormatter;\n+import java.util.Calendar;\n+import java.util.List;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DateTimeType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.ThingStatusInfo;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.jablotron.internal.config.JablotronDeviceConfig;\n+import org.openhab.binding.jablotron.internal.model.*;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+\n+/**\n+ * The {@link JablotronAlarmHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Ondrej Pecta - Initial contribution\n+ */\n+@NonNullByDefault\n+public abstract class JablotronAlarmHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(JablotronAlarmHandler.class);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c1ffbb591d92a8b648e7420168c9b836c0bf9b10"}, "originalPosition": 51}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE0NDk4OQ==", "bodyText": "This one is still having a lower case word", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r485144989", "createdAt": "2020-09-08T19:23:41Z", "author": {"login": "Hilbrand"}, "path": "bundles/org.openhab.binding.jablotron/src/main/resources/ESH-INF/thing/channels.xml", "diffHunk": "@@ -0,0 +1,164 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"jablotron\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\t\t\t\t\t\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\t\t\t\t\t\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\t<!-- Oasis -->\n+\t<!-- StatusA -->\n+\t<channel-type id=\"statusA\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Alarm Zone A Status Channel</label>\n+\t\t<description>Status of the A zone of your alarm</description>\n+\t\t<state readOnly=\"true\"/>\n+\t</channel-type>\n+\n+\t<!-- StatusB -->\n+\t<channel-type id=\"statusB\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Alarm B Status Channel</label>\n+\t\t<description>Status of the B zone of your alarm</description>\n+\t\t<state readOnly=\"true\"/>\n+\t</channel-type>\n+\n+\t<!-- StatusABC -->\n+\t<channel-type id=\"statusABC\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Alarm Zone ABC Status Channel</label>\n+\t\t<description>Status of the ABC zone of your alarm</description>\n+\t\t<state readOnly=\"true\"/>\n+\t</channel-type>\n+\n+\t<!-- StatusPGX -->\n+\t<channel-type id=\"statusPGX\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>OASIS PGX Status Channel</label>\n+\t\t<description>Status of the PGX switch of your OASIS alarm</description>\n+\t</channel-type>\n+\n+\t<!-- StatusPGY -->\n+\t<channel-type id=\"statusPGY\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>OASIS PGY Status Channel</label>\n+\t\t<description>Status of the PGY switch of your OASIS alarm</description>\n+\t</channel-type>\n+\n+\t<!-- JA100 -->\n+\t<channel-type id=\"status\">\n+\t\t<item-type>Number</item-type>\n+\t\t<label>Alarm Section Status Channel</label>\n+\t\t<description>Status of the section of your alarm</description>\n+\t</channel-type>\n+\n+\t<!-- StatusPGM -->\n+\t<channel-type id=\"statusPGM\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>JA-100 PGM Status Channel</label>\n+\t\t<description>Status of the PGM switch of your JA-100 alarm</description>\n+\t</channel-type>\n+\n+\t<!-- Alarm -->\n+\t<channel-type id=\"alarm\">\n+\t\t<kind>trigger</kind>\n+\t\t<label>Alarm Channel</label>\n+\t\t<description>Status of the alarm of your alarm</description>\n+\t\t<state readOnly=\"true\"/>\n+\t</channel-type>\n+\n+\t<!-- Command -->\n+\t<channel-type id=\"command\">\n+\t\t<item-type>String</item-type>\n+\t\t<label>Alarm Command Channel</label>\n+\t\t<description>Channel for sending commands to your alarm</description>\n+\t</channel-type>\n+\n+\t<!-- LastEvent -->\n+\t<channel-type id=\"lastEvent\">\n+\t\t<item-type>String</item-type>\n+\t\t<label>Alarm Last Event Text Description Channel</label>\n+\t\t<description>Text description of the last event of your alarm</description>\n+\t\t<state readOnly=\"true\"/>\n+\t</channel-type>\n+\n+\t<!-- LastEventClass -->\n+\t<channel-type id=\"lastEventClass\">\n+\t\t<item-type>String</item-type>\n+\t\t<label>Alarm Last Event Class Channel</label>\n+\t\t<description>Class of the last event of your alarm (arm, disarm, ...)</description>\n+\t\t<state readOnly=\"true\"/>\n+\t</channel-type>\n+\n+\t<!-- LastEventSection -->\n+\t<channel-type id=\"lastEventSection\">\n+\t\t<item-type>String</item-type>\n+\t\t<label>Alarm Last Event Section Channel</label>\n+\t\t<description>The last event section of your alarm</description>\n+\t\t<state readOnly=\"true\"/>\n+\t</channel-type>\n+\n+\t<!-- LastEventInvoker -->\n+\t<channel-type id=\"lastEventInvoker\">\n+\t\t<item-type>String</item-type>\n+\t\t<label>Alarm Last Event Invoker Channel</label>\n+\t\t<description>The last event invoker</description>\n+\t\t<state readOnly=\"true\"/>\n+\t</channel-type>\n+\n+\t<!-- LastEventTime -->\n+\t<channel-type id=\"lastEventTime\">\n+\t\t<item-type>DateTime</item-type>\n+\t\t<label>Alarm Last Event Time Channel</label>\n+\t\t<description>Date and time of the last event of your alarm</description>\n+\t\t<state readOnly=\"true\"/>\n+\t</channel-type>\n+\n+\t<!-- LastCheckTime -->\n+\t<channel-type id=\"lastCheckTime\">\n+\t\t<item-type>DateTime</item-type>\n+\t\t<label>Alarm Last Check Time Channel</label>\n+\t\t<description>Date and time of last status check of your alarm</description>\n+\t\t<state readOnly=\"true\"/>\n+\t</channel-type>\n+\n+\t<!-- alarm_state -->\n+\t<channel-type id=\"alarm_state\">\n+\t\t<item-type>String</item-type>\n+\t\t<label>Alarm state</label>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mjk0MDY2OA=="}, "originalCommit": {"oid": "36775963f2d1f6fd1e9689f06b070bfa8e6a859e"}, "originalPosition": 124}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE4Nzg0Mg==", "bodyText": "You can drop the word  Channel from all labels. It's redundanti information and only makes the labels unnecessary longer.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\t<label>Alarm Zone A Status Channel</label>\n          \n          \n            \n            \t\t<label>Alarm Zone A Status</label>", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r485187842", "createdAt": "2020-09-08T20:49:04Z", "author": {"login": "Hilbrand"}, "path": "bundles/org.openhab.binding.jablotron/src/main/resources/ESH-INF/thing/channels.xml", "diffHunk": "@@ -0,0 +1,165 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"jablotron\"\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\t<!-- Oasis -->\n+\t<!-- StatusA -->\n+\t<channel-type id=\"statusA\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Alarm Zone A Status Channel</label>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c1ffbb591d92a8b648e7420168c9b836c0bf9b10"}, "originalPosition": 10}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a590e81e68f4bb50a74b76dce0635a7906ca04ab", "author": {"user": {"login": "octa22", "name": "Ondrej Pecta"}}, "url": "https://github.com/openhab/openhab-addons/commit/a590e81e68f4bb50a74b76dce0635a7906ca04ab", "committedDate": "2020-09-08T21:26:32Z", "message": "[jablotron] next bunch of improvements based on the code review\n\nSigned-off-by: Ondrej Pecta <opecta@gmail.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg0NTA3OTcw", "url": "https://github.com/openhab/openhab-addons/pull/6990#pullrequestreview-484507970", "createdAt": "2020-09-08T21:33:43Z", "commit": {"oid": "a590e81e68f4bb50a74b76dce0635a7906ca04ab"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg2MjQ2MjQ4", "url": "https://github.com/openhab/openhab-addons/pull/6990#pullrequestreview-486246248", "createdAt": "2020-09-10T19:28:04Z", "commit": {"oid": "a590e81e68f4bb50a74b76dce0635a7906ca04ab"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 25, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMFQxOToyODowNFrOHQCubg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMFQyMDozNzoyMFrOHQE2-Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjU4MzkxOA==", "bodyText": "Same for below\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            #items file for JA80\n          \n          \n            \n            # items file for JA80", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r486583918", "createdAt": "2020-09-10T19:28:04Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.jablotron/README.md", "diffHunk": "@@ -0,0 +1,120 @@\n+# Jablotron Alarm Binding\n+\n+This is the binding for Jablotron alarms.\n+https://www.jablotron.com/en/jablotron-products/alarms/\n+\n+## Supported Things\n+\n+| thing   | note                                      |\n+|---------|-------------------------------------------|\n+| bridge  | the bridge to your Jablonet cloud account |\n+| JA-80   | the OASIS alarm                           |\n+| JA-100  | with the thermometer support              |\n+| JA-100F | without the thermometer support           |\n+ \n+## Discovery\n+\n+This binding supports auto discovery. Just manually add a bridge thing and supply login & password to your Jablonet account.\n+\n+## Binding Configuration\n+\n+Binding itself doesn't require specific configuration.\n+\n+## Thing Configuration\n+\n+| thing                | config parameter name | description                                                                        | type                  |\n+|----------------------|-----------------------|------------------------------------------------------------------------------------|-----------------------|\n+| bridge               | login                 | the login to your Jablonet account                                                 | mandatory             |\n+| bridge               | password              | the password to your Jablonet account                                              | mandatory             |\n+| bridge               | refresh               | the refresh time for all alarm warnings (ALARM, TAMPER triggers and SERVICE state) | optional, default=30s |\n+| bridge               | lang                  | the language of the alarm texts                                                    | optional, default=en  |\n+| JA-80/JA-100/JA-100F | refresh               | the channels refresh period in seconds                                             | optional, default=60s |\n+| JA-80/JA-100/JA-100F | serviceId             | the service ID which identifies the alarm                                          | mandatory             |\n+| JA-100/JA-100F       | code                  | the master code for controlling sections                                           | optional              |\n+\n+## Channels\n+\n+| thing                | channel name     | description                                               |\n+|----------------------|------------------|-----------------------------------------------------------|\n+| bridge               | N/A              | the bridge does not expose any channels                   |\n+| JA-80                | statusA          | the status of the A section                               |\n+| JA-80                | statusB          | the status of the AB/B section                            |\n+| JA-80                | statusABC        | the status of the ABC section                             |\n+| JA-80                | statusPGX        | the status of PGX                                         |\n+| JA-80                | statusPGY        | the status of PGY                                         |\n+| JA-80                | command          | the channel for sending keyboard codes to the OASIS alarm |\n+| JA-80/JA-100/JA-100F | lastEvent        | the text description of the last event                    |\n+| JA-80/JA-100/JA-100F | lastEventClass   | the class of the last event - e.g. arm, disarm, ...       |\n+| JA-80/JA-100/JA-100F | lastEventInvoker | the invoker of the last event                             |\n+| JA-80/JA-100/JA-100F | lastEventTime    | the time of the last event                                |\n+| JA-80/JA-100/JA-100F | lastCheckTime    | the time of the last checking                             |\n+| JA-80/JA-100/JA-100F | alarm            | the alarm trigger, might fire ALARM or TAMPER events      |\n+| JA-100/JA-100F       | lastEventSection | the section of the last event                             |\n+\n+all other channels for the JA-100/JA-100F alarms (sections, PGs and thermometers for JA-100) are dynamically created according to your configuration\n+\n+* The sections are represented by String channels (with possible values \"set\", \"unset\", \"partialSet\" for JA-100 and \n+possible values \"ARM\", \"PARTIAL_ARM\" and \"DISARM\" for JA100-F)\n+* The PGs (programmable gates) are represented by Switch channels \n+\n+## Full Example\n+\n+#items file for JA80", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a590e81e68f4bb50a74b76dce0635a7906ca04ab"}, "originalPosition": 62}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjU4NDI3Mw==", "bodyText": "Is there a reason why you didn't document them here?", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r486584273", "createdAt": "2020-09-10T19:28:51Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.jablotron/README.md", "diffHunk": "@@ -0,0 +1,120 @@\n+# Jablotron Alarm Binding\n+\n+This is the binding for Jablotron alarms.\n+https://www.jablotron.com/en/jablotron-products/alarms/\n+\n+## Supported Things\n+\n+| thing   | note                                      |\n+|---------|-------------------------------------------|\n+| bridge  | the bridge to your Jablonet cloud account |\n+| JA-80   | the OASIS alarm                           |\n+| JA-100  | with the thermometer support              |\n+| JA-100F | without the thermometer support           |\n+ \n+## Discovery\n+\n+This binding supports auto discovery. Just manually add a bridge thing and supply login & password to your Jablonet account.\n+\n+## Binding Configuration\n+\n+Binding itself doesn't require specific configuration.\n+\n+## Thing Configuration\n+\n+| thing                | config parameter name | description                                                                        | type                  |\n+|----------------------|-----------------------|------------------------------------------------------------------------------------|-----------------------|\n+| bridge               | login                 | the login to your Jablonet account                                                 | mandatory             |\n+| bridge               | password              | the password to your Jablonet account                                              | mandatory             |\n+| bridge               | refresh               | the refresh time for all alarm warnings (ALARM, TAMPER triggers and SERVICE state) | optional, default=30s |\n+| bridge               | lang                  | the language of the alarm texts                                                    | optional, default=en  |\n+| JA-80/JA-100/JA-100F | refresh               | the channels refresh period in seconds                                             | optional, default=60s |\n+| JA-80/JA-100/JA-100F | serviceId             | the service ID which identifies the alarm                                          | mandatory             |\n+| JA-100/JA-100F       | code                  | the master code for controlling sections                                           | optional              |\n+\n+## Channels\n+\n+| thing                | channel name     | description                                               |\n+|----------------------|------------------|-----------------------------------------------------------|\n+| bridge               | N/A              | the bridge does not expose any channels                   |\n+| JA-80                | statusA          | the status of the A section                               |\n+| JA-80                | statusB          | the status of the AB/B section                            |\n+| JA-80                | statusABC        | the status of the ABC section                             |\n+| JA-80                | statusPGX        | the status of PGX                                         |\n+| JA-80                | statusPGY        | the status of PGY                                         |\n+| JA-80                | command          | the channel for sending keyboard codes to the OASIS alarm |\n+| JA-80/JA-100/JA-100F | lastEvent        | the text description of the last event                    |\n+| JA-80/JA-100/JA-100F | lastEventClass   | the class of the last event - e.g. arm, disarm, ...       |\n+| JA-80/JA-100/JA-100F | lastEventInvoker | the invoker of the last event                             |\n+| JA-80/JA-100/JA-100F | lastEventTime    | the time of the last event                                |\n+| JA-80/JA-100/JA-100F | lastCheckTime    | the time of the last checking                             |\n+| JA-80/JA-100/JA-100F | alarm            | the alarm trigger, might fire ALARM or TAMPER events      |\n+| JA-100/JA-100F       | lastEventSection | the section of the last event                             |\n+\n+all other channels for the JA-100/JA-100F alarms (sections, PGs and thermometers for JA-100) are dynamically created according to your configuration", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a590e81e68f4bb50a74b76dce0635a7906ca04ab"}, "originalPosition": 54}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjU4NTg5NA==", "bodyText": "Logging to info should be used rarely. This could be debug. Same for below.", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r486585894", "createdAt": "2020-09-10T19:31:44Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.jablotron/src/main/java/org/openhab/binding/jablotron/internal/discovery/JablotronDiscoveryService.java", "diffHunk": "@@ -0,0 +1,171 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.jablotron.internal.discovery;\n+\n+import static org.openhab.binding.jablotron.JablotronBindingConstants.*;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.config.discovery.*;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.thing.ThingUID;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.openhab.binding.jablotron.internal.handler.JablotronBridgeHandler;\n+import org.openhab.binding.jablotron.internal.model.JablotronDiscoveredService;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link JablotronDiscoveryService} is responsible for the thing discovery\n+ * process.\n+ *\n+ * @author Ondrej Pecta - Initial contribution\n+ */\n+@NonNullByDefault\n+public class JablotronDiscoveryService extends AbstractDiscoveryService\n+        implements DiscoveryService, ThingHandlerService {\n+    private final Logger logger = LoggerFactory.getLogger(JablotronDiscoveryService.class);\n+\n+    private @Nullable JablotronBridgeHandler bridgeHandler;\n+\n+    private @Nullable ScheduledFuture<?> discoveryJob = null;\n+\n+    public JablotronDiscoveryService() {\n+        super(DISCOVERY_TIMEOUT_SEC);\n+        logger.debug(\"Creating discovery service\");\n+    }\n+\n+    private void startDiscovery() {\n+        if (this.bridgeHandler.getThing().getStatus() == ThingStatus.ONLINE) {\n+            discoverServices();\n+        }\n+    }\n+\n+    @Override\n+    public void setThingHandler(@Nullable ThingHandler thingHandler) {\n+        if (thingHandler instanceof JablotronBridgeHandler) {\n+            bridgeHandler = (JablotronBridgeHandler) thingHandler;\n+        }\n+    }\n+\n+    @Override\n+    public @Nullable ThingHandler getThingHandler() {\n+        return bridgeHandler;\n+    }\n+\n+    @Override\n+    protected void stopBackgroundDiscovery() {\n+        super.stopBackgroundDiscovery();\n+        if (discoveryJob != null) {\n+            discoveryJob.cancel(true);\n+        }\n+    }\n+\n+    @Override\n+    protected void startBackgroundDiscovery() {\n+        logger.debug(\"Starting Jablotron background discovery\");\n+\n+        if (discoveryJob == null || discoveryJob.isCancelled()) {\n+            discoveryJob = scheduler.scheduleWithFixedDelay(this::startDiscovery, 10, 3600, TimeUnit.SECONDS);\n+        }\n+    }\n+\n+    @Override\n+    public void activate() {\n+        super.activate(null);\n+    }\n+\n+    @Override\n+    public void deactivate() {\n+        super.deactivate();\n+    }\n+\n+    @Override\n+    public Set<ThingTypeUID> getSupportedThingTypes() {\n+        return SUPPORTED_THING_TYPES_UIDS;\n+    }\n+\n+    @Override\n+    protected void startScan() {\n+        logger.debug(\"Starting scanning for items...\");\n+        startDiscovery();\n+    }\n+\n+    public void oasisDiscovered(String label, String serviceId) {\n+        ThingUID thingUID = new ThingUID(THING_TYPE_OASIS, bridgeHandler.getThing().getUID(), serviceId);\n+        Map<String, Object> properties = new HashMap<>();\n+        properties.put(PROPERTY_SERVICE_ID, serviceId);\n+\n+        logger.debug(\"Detected an OASIS alarm with service id: {}\", serviceId);\n+        thingDiscovered(DiscoveryResultBuilder.create(thingUID).withThingType(THING_TYPE_OASIS).withLabel(label)\n+                .withProperties(properties).withRepresentationProperty(PROPERTY_SERVICE_ID)\n+                .withBridge(bridgeHandler.getThing().getUID()).build());\n+    }\n+\n+    public void ja100Discovered(String label, String serviceId) {\n+        ThingUID thingUID = new ThingUID(THING_TYPE_JA100, bridgeHandler.getThing().getUID(), serviceId);\n+        Map<String, Object> properties = new HashMap<>();\n+        properties.put(PROPERTY_SERVICE_ID, serviceId);\n+\n+        logger.debug(\"Detected a JA100 alarm with service id: {}\", serviceId);\n+        thingDiscovered(DiscoveryResultBuilder.create(thingUID).withThingType(THING_TYPE_JA100).withLabel(label)\n+                .withProperties(properties).withRepresentationProperty(PROPERTY_SERVICE_ID)\n+                .withBridge(bridgeHandler.getThing().getUID()).build());\n+    }\n+\n+    public void ja100fDiscovered(String label, String serviceId) {\n+        ThingUID thingUID = new ThingUID(THING_TYPE_JA100F, bridgeHandler.getThing().getUID(), serviceId);\n+        Map<String, Object> properties = new HashMap<>();\n+        properties.put(PROPERTY_SERVICE_ID, serviceId);\n+\n+        logger.debug(\"Detected a JA100+ alarm with service id: {}\", serviceId);\n+        thingDiscovered(DiscoveryResultBuilder.create(thingUID).withThingType(THING_TYPE_JA100F).withLabel(label)\n+                .withProperties(properties).withRepresentationProperty(PROPERTY_SERVICE_ID)\n+                .withBridge(bridgeHandler.getThing().getUID()).build());\n+    }\n+\n+    private synchronized void discoverServices() {\n+        List<JablotronDiscoveredService> services = bridgeHandler.discoverServices();\n+\n+        if (services == null || services.isEmpty()) {\n+            logger.info(\"Cannot find any Jablotron device\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a590e81e68f4bb50a74b76dce0635a7906ca04ab"}, "originalPosition": 150}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjU4NzcxMQ==", "bodyText": "What's the purpose of this method?", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r486587711", "createdAt": "2020-09-10T19:35:26Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.jablotron/src/main/java/org/openhab/binding/jablotron/internal/handler/JablotronAlarmHandler.java", "diffHunk": "@@ -0,0 +1,219 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.jablotron.internal.handler;\n+\n+import static org.openhab.binding.jablotron.JablotronBindingConstants.*;\n+\n+import java.time.ZoneId;\n+import java.time.ZonedDateTime;\n+import java.time.format.DateTimeFormatter;\n+import java.util.Calendar;\n+import java.util.List;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DateTimeType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.ThingStatusInfo;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.jablotron.internal.config.JablotronDeviceConfig;\n+import org.openhab.binding.jablotron.internal.model.*;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+\n+/**\n+ * The {@link JablotronAlarmHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Ondrej Pecta - Initial contribution\n+ */\n+@NonNullByDefault\n+public abstract class JablotronAlarmHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(getClass());\n+\n+    protected final Gson gson = new Gson();\n+\n+    protected JablotronDeviceConfig thingConfig = new JablotronDeviceConfig();\n+\n+    private String lastWarningTime = \"\";\n+\n+    protected String alarmName = \"\";\n+\n+    private boolean inService = false;\n+\n+    protected @Nullable ScheduledFuture<?> future = null;\n+\n+    public JablotronAlarmHandler(Thing thing, String alarmName) {\n+        super(thing);\n+        this.alarmName = alarmName;\n+    }\n+\n+    @Override\n+    public void bridgeStatusChanged(ThingStatusInfo bridgeStatusInfo) {\n+        super.bridgeStatusChanged(bridgeStatusInfo);\n+        if (ThingStatus.UNINITIALIZED == bridgeStatusInfo.getStatus()) {\n+            cleanup();\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        super.dispose();\n+        cleanup();\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        thingConfig = getConfigAs(JablotronDeviceConfig.class);\n+        scheduler.execute(this::doInit);\n+        updateStatus(ThingStatus.ONLINE);\n+    }\n+\n+    public boolean isInService() {\n+        return inService;\n+    }\n+\n+    public String getAlarmName() {\n+        return alarmName;\n+    }\n+\n+    protected void updateSegmentStatus(JablotronServiceDetailSegment segment) {\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a590e81e68f4bb50a74b76dce0635a7906ca04ab"}, "originalPosition": 100}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjU4ODQ5NQ==", "bodyText": "Calendar is old fashioned. You could do this:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    ZonedDateTime zdt = ZonedDateTime.ofInstant(Calendar.getInstance().toInstant(), ZoneId.systemDefault());\n          \n          \n            \n                    ZonedDateTime zdt = ZonedDateTime.ofInstant(Instant.now(), ZoneId.systemDefault());", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r486588495", "createdAt": "2020-09-10T19:36:56Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.jablotron/src/main/java/org/openhab/binding/jablotron/internal/handler/JablotronAlarmHandler.java", "diffHunk": "@@ -0,0 +1,219 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.jablotron.internal.handler;\n+\n+import static org.openhab.binding.jablotron.JablotronBindingConstants.*;\n+\n+import java.time.ZoneId;\n+import java.time.ZonedDateTime;\n+import java.time.format.DateTimeFormatter;\n+import java.util.Calendar;\n+import java.util.List;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DateTimeType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.ThingStatusInfo;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.jablotron.internal.config.JablotronDeviceConfig;\n+import org.openhab.binding.jablotron.internal.model.*;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+\n+/**\n+ * The {@link JablotronAlarmHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Ondrej Pecta - Initial contribution\n+ */\n+@NonNullByDefault\n+public abstract class JablotronAlarmHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(getClass());\n+\n+    protected final Gson gson = new Gson();\n+\n+    protected JablotronDeviceConfig thingConfig = new JablotronDeviceConfig();\n+\n+    private String lastWarningTime = \"\";\n+\n+    protected String alarmName = \"\";\n+\n+    private boolean inService = false;\n+\n+    protected @Nullable ScheduledFuture<?> future = null;\n+\n+    public JablotronAlarmHandler(Thing thing, String alarmName) {\n+        super(thing);\n+        this.alarmName = alarmName;\n+    }\n+\n+    @Override\n+    public void bridgeStatusChanged(ThingStatusInfo bridgeStatusInfo) {\n+        super.bridgeStatusChanged(bridgeStatusInfo);\n+        if (ThingStatus.UNINITIALIZED == bridgeStatusInfo.getStatus()) {\n+            cleanup();\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        super.dispose();\n+        cleanup();\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        thingConfig = getConfigAs(JablotronDeviceConfig.class);\n+        scheduler.execute(this::doInit);\n+        updateStatus(ThingStatus.ONLINE);\n+    }\n+\n+    public boolean isInService() {\n+        return inService;\n+    }\n+\n+    public String getAlarmName() {\n+        return alarmName;\n+    }\n+\n+    protected void updateSegmentStatus(JablotronServiceDetailSegment segment) {\n+    }\n+\n+    private void cleanup() {\n+        logger.debug(\"doing cleanup...\");\n+        if (future != null) {\n+            future.cancel(true);\n+        }\n+    }\n+\n+    protected State getCheckTime() {\n+        ZonedDateTime zdt = ZonedDateTime.ofInstant(Calendar.getInstance().toInstant(), ZoneId.systemDefault());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a590e81e68f4bb50a74b76dce0635a7906ca04ab"}, "originalPosition": 110}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjU4OTA0Nw==", "bodyText": "Is this necessary to be executed asynchronously? You could schedule the updateAlarmStatus() task directly here.", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r486589047", "createdAt": "2020-09-10T19:38:04Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.jablotron/src/main/java/org/openhab/binding/jablotron/internal/handler/JablotronAlarmHandler.java", "diffHunk": "@@ -0,0 +1,219 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.jablotron.internal.handler;\n+\n+import static org.openhab.binding.jablotron.JablotronBindingConstants.*;\n+\n+import java.time.ZoneId;\n+import java.time.ZonedDateTime;\n+import java.time.format.DateTimeFormatter;\n+import java.util.Calendar;\n+import java.util.List;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DateTimeType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.ThingStatusInfo;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.jablotron.internal.config.JablotronDeviceConfig;\n+import org.openhab.binding.jablotron.internal.model.*;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+\n+/**\n+ * The {@link JablotronAlarmHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Ondrej Pecta - Initial contribution\n+ */\n+@NonNullByDefault\n+public abstract class JablotronAlarmHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(getClass());\n+\n+    protected final Gson gson = new Gson();\n+\n+    protected JablotronDeviceConfig thingConfig = new JablotronDeviceConfig();\n+\n+    private String lastWarningTime = \"\";\n+\n+    protected String alarmName = \"\";\n+\n+    private boolean inService = false;\n+\n+    protected @Nullable ScheduledFuture<?> future = null;\n+\n+    public JablotronAlarmHandler(Thing thing, String alarmName) {\n+        super(thing);\n+        this.alarmName = alarmName;\n+    }\n+\n+    @Override\n+    public void bridgeStatusChanged(ThingStatusInfo bridgeStatusInfo) {\n+        super.bridgeStatusChanged(bridgeStatusInfo);\n+        if (ThingStatus.UNINITIALIZED == bridgeStatusInfo.getStatus()) {\n+            cleanup();\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        super.dispose();\n+        cleanup();\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        thingConfig = getConfigAs(JablotronDeviceConfig.class);\n+        scheduler.execute(this::doInit);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a590e81e68f4bb50a74b76dce0635a7906ca04ab"}, "originalPosition": 87}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjU5MjY2Mw==", "bodyText": "You could fix the compiler warning by storing the result of getBridge() into a local variable and work with that.", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r486592663", "createdAt": "2020-09-10T19:45:20Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.jablotron/src/main/java/org/openhab/binding/jablotron/internal/handler/JablotronAlarmHandler.java", "diffHunk": "@@ -0,0 +1,219 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.jablotron.internal.handler;\n+\n+import static org.openhab.binding.jablotron.JablotronBindingConstants.*;\n+\n+import java.time.ZoneId;\n+import java.time.ZonedDateTime;\n+import java.time.format.DateTimeFormatter;\n+import java.util.Calendar;\n+import java.util.List;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DateTimeType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.ThingStatusInfo;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.jablotron.internal.config.JablotronDeviceConfig;\n+import org.openhab.binding.jablotron.internal.model.*;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+\n+/**\n+ * The {@link JablotronAlarmHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Ondrej Pecta - Initial contribution\n+ */\n+@NonNullByDefault\n+public abstract class JablotronAlarmHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(getClass());\n+\n+    protected final Gson gson = new Gson();\n+\n+    protected JablotronDeviceConfig thingConfig = new JablotronDeviceConfig();\n+\n+    private String lastWarningTime = \"\";\n+\n+    protected String alarmName = \"\";\n+\n+    private boolean inService = false;\n+\n+    protected @Nullable ScheduledFuture<?> future = null;\n+\n+    public JablotronAlarmHandler(Thing thing, String alarmName) {\n+        super(thing);\n+        this.alarmName = alarmName;\n+    }\n+\n+    @Override\n+    public void bridgeStatusChanged(ThingStatusInfo bridgeStatusInfo) {\n+        super.bridgeStatusChanged(bridgeStatusInfo);\n+        if (ThingStatus.UNINITIALIZED == bridgeStatusInfo.getStatus()) {\n+            cleanup();\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        super.dispose();\n+        cleanup();\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        thingConfig = getConfigAs(JablotronDeviceConfig.class);\n+        scheduler.execute(this::doInit);\n+        updateStatus(ThingStatus.ONLINE);\n+    }\n+\n+    public boolean isInService() {\n+        return inService;\n+    }\n+\n+    public String getAlarmName() {\n+        return alarmName;\n+    }\n+\n+    protected void updateSegmentStatus(JablotronServiceDetailSegment segment) {\n+    }\n+\n+    private void cleanup() {\n+        logger.debug(\"doing cleanup...\");\n+        if (future != null) {\n+            future.cancel(true);\n+        }\n+    }\n+\n+    protected State getCheckTime() {\n+        ZonedDateTime zdt = ZonedDateTime.ofInstant(Calendar.getInstance().toInstant(), ZoneId.systemDefault());\n+        return new DateTimeType(zdt);\n+    }\n+\n+    protected void doInit() {\n+        future = scheduler.scheduleWithFixedDelay(this::updateAlarmStatus, 1, thingConfig.getRefresh(),\n+                TimeUnit.SECONDS);\n+    }\n+\n+    protected synchronized @Nullable JablotronDataUpdateResponse sendGetStatusRequest() {\n+        JablotronBridgeHandler handler = getBridgeHandler();\n+        if (handler != null) {\n+            return handler.sendGetStatusRequest(getThing());\n+        }\n+        return null;\n+    }\n+\n+    protected synchronized boolean updateAlarmStatus() {\n+        JablotronDataUpdateResponse dataUpdate = sendGetStatusRequest();\n+        if (dataUpdate == null) {\n+            return false;\n+        }\n+\n+        if (dataUpdate.isStatus()) {\n+            updateState(CHANNEL_LAST_CHECK_TIME, getCheckTime());\n+            List<JablotronServiceData> serviceData = dataUpdate.getData().getServiceData();\n+            for (JablotronServiceData data : serviceData) {\n+                List<JablotronService> services = data.getData();\n+                for (JablotronService service : services) {\n+                    JablotronServiceDetail detail = service.getData();\n+                    for (JablotronServiceDetailSegment segment : detail.getSegments()) {\n+                        updateSegmentStatus(segment);\n+                    }\n+                }\n+\n+            }\n+        } else {\n+            logger.debug(\"Error during alarm status update: {}\", dataUpdate.getErrorMessage());\n+        }\n+\n+        List<JablotronHistoryDataEvent> events = sendGetEventHistory(alarmName);\n+        if (events != null && events.size() > 0) {\n+            JablotronHistoryDataEvent event = events.get(0);\n+            updateLastEvent(event);\n+        }\n+\n+        return true;\n+    }\n+\n+    protected @Nullable List<JablotronHistoryDataEvent> sendGetEventHistory(String alarm) {\n+        JablotronBridgeHandler handler = getBridgeHandler();\n+        if (handler != null) {\n+            return handler.sendGetEventHistory(getThing(), alarm);\n+        }\n+        return null;\n+    }\n+\n+    protected void updateLastEvent(JablotronHistoryDataEvent event) {\n+        updateState(CHANNEL_LAST_EVENT_TIME, new DateTimeType(getZonedDateTime(event.getDate())));\n+        updateState(CHANNEL_LAST_EVENT, new StringType(event.getEventText()));\n+        updateState(CHANNEL_LAST_EVENT_CLASS, new StringType(event.getIconType()));\n+        updateState(CHANNEL_LAST_EVENT_INVOKER, new StringType(event.getInvokerName()));\n+\n+        // oasis does not have sections\n+        if (getThing().getChannel(CHANNEL_LAST_EVENT_SECTION) != null) {\n+            updateState(CHANNEL_LAST_EVENT_SECTION, new StringType(event.getSectionName()));\n+        }\n+    }\n+\n+    public ZonedDateTime getZonedDateTime(String date) {\n+        return ZonedDateTime.parse(date.substring(0, 22) + \":\" + date.substring(22, 24),\n+                DateTimeFormatter.ISO_DATE_TIME);\n+    }\n+\n+    protected @Nullable JablotronControlResponse sendUserCode(String section, String key, String status, String code) {\n+        JablotronControlResponse response = null;\n+        JablotronBridgeHandler handler = getBridgeHandler();\n+        if (handler != null) {\n+            try {\n+                response = handler.sendUserCode(getThing(), section, key, status, code);\n+            } catch (SecurityException se) {\n+                response = handler.sendUserCode(getThing(), section, key, status, code);\n+            }\n+        }\n+        return response;\n+    }\n+\n+    protected @Nullable JablotronBridgeHandler getBridgeHandler() {\n+        if (getBridge() != null && getBridge().getHandler() != null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a590e81e68f4bb50a74b76dce0635a7906ca04ab"}, "originalPosition": 198}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjU5MzE0Nw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                @Nullable\n          \n          \n            \n                ScheduledFuture<?> future = null;\n          \n          \n            \n                private @Nullable ScheduledFuture<?> future = null;", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r486593147", "createdAt": "2020-09-10T19:46:24Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.jablotron/src/main/java/org/openhab/binding/jablotron/internal/handler/JablotronBridgeHandler.java", "diffHunk": "@@ -0,0 +1,385 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.jablotron.internal.handler;\n+\n+import static org.openhab.binding.jablotron.JablotronBindingConstants.*;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.eclipse.jetty.http.HttpHeader;\n+import org.eclipse.jetty.http.HttpMethod;\n+import org.eclipse.smarthome.core.thing.*;\n+import org.eclipse.smarthome.core.thing.binding.BaseBridgeHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.openhab.binding.jablotron.internal.config.JablotronBridgeConfig;\n+import org.openhab.binding.jablotron.internal.discovery.JablotronDiscoveryService;\n+import org.openhab.binding.jablotron.internal.model.*;\n+import org.openhab.binding.jablotron.internal.model.ja100f.JablotronGetPGResponse;\n+import org.openhab.binding.jablotron.internal.model.ja100f.JablotronGetSectionsResponse;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.JsonSyntaxException;\n+\n+/**\n+ * The {@link JablotronBridgeHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Ondrej Pecta - Initial contribution\n+ */\n+@NonNullByDefault\n+public class JablotronBridgeHandler extends BaseBridgeHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(JablotronBridgeHandler.class);\n+\n+    private final Gson gson = new Gson();\n+\n+    final HttpClient httpClient;\n+\n+    @Nullable\n+    ScheduledFuture<?> future = null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a590e81e68f4bb50a74b76dce0635a7906ca04ab"}, "originalPosition": 64}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjU5Mzg1Ng==", "bodyText": "The annotation could be removed, as the compiler is more intelligent on local variables to see, that you're doing a null check.", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r486593856", "createdAt": "2020-09-10T19:47:51Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.jablotron/src/main/java/org/openhab/binding/jablotron/internal/handler/JablotronBridgeHandler.java", "diffHunk": "@@ -0,0 +1,385 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.jablotron.internal.handler;\n+\n+import static org.openhab.binding.jablotron.JablotronBindingConstants.*;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.eclipse.jetty.http.HttpHeader;\n+import org.eclipse.jetty.http.HttpMethod;\n+import org.eclipse.smarthome.core.thing.*;\n+import org.eclipse.smarthome.core.thing.binding.BaseBridgeHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.openhab.binding.jablotron.internal.config.JablotronBridgeConfig;\n+import org.openhab.binding.jablotron.internal.discovery.JablotronDiscoveryService;\n+import org.openhab.binding.jablotron.internal.model.*;\n+import org.openhab.binding.jablotron.internal.model.ja100f.JablotronGetPGResponse;\n+import org.openhab.binding.jablotron.internal.model.ja100f.JablotronGetSectionsResponse;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.JsonSyntaxException;\n+\n+/**\n+ * The {@link JablotronBridgeHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Ondrej Pecta - Initial contribution\n+ */\n+@NonNullByDefault\n+public class JablotronBridgeHandler extends BaseBridgeHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(JablotronBridgeHandler.class);\n+\n+    private final Gson gson = new Gson();\n+\n+    final HttpClient httpClient;\n+\n+    @Nullable\n+    ScheduledFuture<?> future = null;\n+\n+    /**\n+     * Our configuration\n+     */\n+    public JablotronBridgeConfig bridgeConfig = new JablotronBridgeConfig();\n+\n+    public JablotronBridgeHandler(Bridge thing, HttpClient httpClient) {\n+        super(thing);\n+        this.httpClient = httpClient;\n+    }\n+\n+    @Override\n+    public Collection<Class<? extends ThingHandlerService>> getServices() {\n+        return Collections.singleton(JablotronDiscoveryService.class);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        bridgeConfig = getConfigAs(JablotronBridgeConfig.class);\n+        scheduler.execute(this::login);\n+        future = scheduler.scheduleWithFixedDelay(this::updateAlarmThings, 30, bridgeConfig.getRefresh(),\n+                TimeUnit.SECONDS);\n+    }\n+\n+    private void updateAlarmThings() {\n+        @Nullable\n+        List<JablotronDiscoveredService> services = discoverServices();\n+        if (services != null) {\n+            for (JablotronDiscoveredService service : services) {\n+                updateAlarmThing(service);\n+            }\n+        }\n+    }\n+\n+    private void updateAlarmThing(JablotronDiscoveredService service) {\n+        for (Thing th : getThing().getThings()) {\n+            @Nullable\n+            JablotronAlarmHandler handler = (JablotronAlarmHandler) th.getHandler();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a590e81e68f4bb50a74b76dce0635a7906ca04ab"}, "originalPosition": 106}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjU5NDUzNg==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                if (!\"\".equals(service.getWarning())) {\n          \n          \n            \n                                if (!service.getWarning().isEmpty()) {", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r486594536", "createdAt": "2020-09-10T19:49:21Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.jablotron/src/main/java/org/openhab/binding/jablotron/internal/handler/JablotronBridgeHandler.java", "diffHunk": "@@ -0,0 +1,385 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.jablotron.internal.handler;\n+\n+import static org.openhab.binding.jablotron.JablotronBindingConstants.*;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.eclipse.jetty.http.HttpHeader;\n+import org.eclipse.jetty.http.HttpMethod;\n+import org.eclipse.smarthome.core.thing.*;\n+import org.eclipse.smarthome.core.thing.binding.BaseBridgeHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.openhab.binding.jablotron.internal.config.JablotronBridgeConfig;\n+import org.openhab.binding.jablotron.internal.discovery.JablotronDiscoveryService;\n+import org.openhab.binding.jablotron.internal.model.*;\n+import org.openhab.binding.jablotron.internal.model.ja100f.JablotronGetPGResponse;\n+import org.openhab.binding.jablotron.internal.model.ja100f.JablotronGetSectionsResponse;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.JsonSyntaxException;\n+\n+/**\n+ * The {@link JablotronBridgeHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Ondrej Pecta - Initial contribution\n+ */\n+@NonNullByDefault\n+public class JablotronBridgeHandler extends BaseBridgeHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(JablotronBridgeHandler.class);\n+\n+    private final Gson gson = new Gson();\n+\n+    final HttpClient httpClient;\n+\n+    @Nullable\n+    ScheduledFuture<?> future = null;\n+\n+    /**\n+     * Our configuration\n+     */\n+    public JablotronBridgeConfig bridgeConfig = new JablotronBridgeConfig();\n+\n+    public JablotronBridgeHandler(Bridge thing, HttpClient httpClient) {\n+        super(thing);\n+        this.httpClient = httpClient;\n+    }\n+\n+    @Override\n+    public Collection<Class<? extends ThingHandlerService>> getServices() {\n+        return Collections.singleton(JablotronDiscoveryService.class);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        bridgeConfig = getConfigAs(JablotronBridgeConfig.class);\n+        scheduler.execute(this::login);\n+        future = scheduler.scheduleWithFixedDelay(this::updateAlarmThings, 30, bridgeConfig.getRefresh(),\n+                TimeUnit.SECONDS);\n+    }\n+\n+    private void updateAlarmThings() {\n+        @Nullable\n+        List<JablotronDiscoveredService> services = discoverServices();\n+        if (services != null) {\n+            for (JablotronDiscoveredService service : services) {\n+                updateAlarmThing(service);\n+            }\n+        }\n+    }\n+\n+    private void updateAlarmThing(JablotronDiscoveredService service) {\n+        for (Thing th : getThing().getThings()) {\n+            @Nullable\n+            JablotronAlarmHandler handler = (JablotronAlarmHandler) th.getHandler();\n+\n+            if (handler == null) {\n+                logger.debug(\"Thing handler is null\");\n+                continue;\n+            }\n+\n+            if (String.valueOf(service.getId()).equals(handler.thingConfig.getServiceId())) {\n+                if (\"ENABLED\".equals(service.getStatus())) {\n+                    if (!\"\".equals(service.getWarning())) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a590e81e68f4bb50a74b76dce0635a7906ca04ab"}, "originalPosition": 115}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjU5NDk0Mg==", "bodyText": "The log message could be removed, as the status update is already logged by the framework.", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r486594942", "createdAt": "2020-09-10T19:50:10Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.jablotron/src/main/java/org/openhab/binding/jablotron/internal/handler/JablotronBridgeHandler.java", "diffHunk": "@@ -0,0 +1,385 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.jablotron.internal.handler;\n+\n+import static org.openhab.binding.jablotron.JablotronBindingConstants.*;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.eclipse.jetty.http.HttpHeader;\n+import org.eclipse.jetty.http.HttpMethod;\n+import org.eclipse.smarthome.core.thing.*;\n+import org.eclipse.smarthome.core.thing.binding.BaseBridgeHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.openhab.binding.jablotron.internal.config.JablotronBridgeConfig;\n+import org.openhab.binding.jablotron.internal.discovery.JablotronDiscoveryService;\n+import org.openhab.binding.jablotron.internal.model.*;\n+import org.openhab.binding.jablotron.internal.model.ja100f.JablotronGetPGResponse;\n+import org.openhab.binding.jablotron.internal.model.ja100f.JablotronGetSectionsResponse;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.JsonSyntaxException;\n+\n+/**\n+ * The {@link JablotronBridgeHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Ondrej Pecta - Initial contribution\n+ */\n+@NonNullByDefault\n+public class JablotronBridgeHandler extends BaseBridgeHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(JablotronBridgeHandler.class);\n+\n+    private final Gson gson = new Gson();\n+\n+    final HttpClient httpClient;\n+\n+    @Nullable\n+    ScheduledFuture<?> future = null;\n+\n+    /**\n+     * Our configuration\n+     */\n+    public JablotronBridgeConfig bridgeConfig = new JablotronBridgeConfig();\n+\n+    public JablotronBridgeHandler(Bridge thing, HttpClient httpClient) {\n+        super(thing);\n+        this.httpClient = httpClient;\n+    }\n+\n+    @Override\n+    public Collection<Class<? extends ThingHandlerService>> getServices() {\n+        return Collections.singleton(JablotronDiscoveryService.class);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        bridgeConfig = getConfigAs(JablotronBridgeConfig.class);\n+        scheduler.execute(this::login);\n+        future = scheduler.scheduleWithFixedDelay(this::updateAlarmThings, 30, bridgeConfig.getRefresh(),\n+                TimeUnit.SECONDS);\n+    }\n+\n+    private void updateAlarmThings() {\n+        @Nullable\n+        List<JablotronDiscoveredService> services = discoverServices();\n+        if (services != null) {\n+            for (JablotronDiscoveredService service : services) {\n+                updateAlarmThing(service);\n+            }\n+        }\n+    }\n+\n+    private void updateAlarmThing(JablotronDiscoveredService service) {\n+        for (Thing th : getThing().getThings()) {\n+            @Nullable\n+            JablotronAlarmHandler handler = (JablotronAlarmHandler) th.getHandler();\n+\n+            if (handler == null) {\n+                logger.debug(\"Thing handler is null\");\n+                continue;\n+            }\n+\n+            if (String.valueOf(service.getId()).equals(handler.thingConfig.getServiceId())) {\n+                if (\"ENABLED\".equals(service.getStatus())) {\n+                    if (!\"\".equals(service.getWarning())) {\n+                        logger.debug(\"Alarm with service id: {} warning: {}\", service.getId(), service.getWarning());\n+                    }\n+                    handler.setStatus(ThingStatus.ONLINE, ThingStatusDetail.NONE, service.getWarning());\n+                    if (\"ALARM\".equals(service.getWarning()) || \"TAMPER\".equals(service.getWarning())) {\n+                        handler.triggerAlarm(service);\n+                    }\n+                    handler.setInService(\"SERVICE\".equals(service.getWarning()));\n+                } else {\n+                    logger.debug(\"Alarm with service id: {} is offline\", service.getId());\n+                    handler.setStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, service.getStatus());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a590e81e68f4bb50a74b76dce0635a7906ca04ab"}, "originalPosition": 125}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjU5NjA5Mg==", "bodyText": "The log message could be removed, as the status update is already logged by the framework. Same for below.", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r486596092", "createdAt": "2020-09-10T19:52:25Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.jablotron/src/main/java/org/openhab/binding/jablotron/internal/handler/JablotronBridgeHandler.java", "diffHunk": "@@ -0,0 +1,385 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.jablotron.internal.handler;\n+\n+import static org.openhab.binding.jablotron.JablotronBindingConstants.*;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.eclipse.jetty.http.HttpHeader;\n+import org.eclipse.jetty.http.HttpMethod;\n+import org.eclipse.smarthome.core.thing.*;\n+import org.eclipse.smarthome.core.thing.binding.BaseBridgeHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.openhab.binding.jablotron.internal.config.JablotronBridgeConfig;\n+import org.openhab.binding.jablotron.internal.discovery.JablotronDiscoveryService;\n+import org.openhab.binding.jablotron.internal.model.*;\n+import org.openhab.binding.jablotron.internal.model.ja100f.JablotronGetPGResponse;\n+import org.openhab.binding.jablotron.internal.model.ja100f.JablotronGetSectionsResponse;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.JsonSyntaxException;\n+\n+/**\n+ * The {@link JablotronBridgeHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Ondrej Pecta - Initial contribution\n+ */\n+@NonNullByDefault\n+public class JablotronBridgeHandler extends BaseBridgeHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(JablotronBridgeHandler.class);\n+\n+    private final Gson gson = new Gson();\n+\n+    final HttpClient httpClient;\n+\n+    @Nullable\n+    ScheduledFuture<?> future = null;\n+\n+    /**\n+     * Our configuration\n+     */\n+    public JablotronBridgeConfig bridgeConfig = new JablotronBridgeConfig();\n+\n+    public JablotronBridgeHandler(Bridge thing, HttpClient httpClient) {\n+        super(thing);\n+        this.httpClient = httpClient;\n+    }\n+\n+    @Override\n+    public Collection<Class<? extends ThingHandlerService>> getServices() {\n+        return Collections.singleton(JablotronDiscoveryService.class);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        bridgeConfig = getConfigAs(JablotronBridgeConfig.class);\n+        scheduler.execute(this::login);\n+        future = scheduler.scheduleWithFixedDelay(this::updateAlarmThings, 30, bridgeConfig.getRefresh(),\n+                TimeUnit.SECONDS);\n+    }\n+\n+    private void updateAlarmThings() {\n+        @Nullable\n+        List<JablotronDiscoveredService> services = discoverServices();\n+        if (services != null) {\n+            for (JablotronDiscoveredService service : services) {\n+                updateAlarmThing(service);\n+            }\n+        }\n+    }\n+\n+    private void updateAlarmThing(JablotronDiscoveredService service) {\n+        for (Thing th : getThing().getThings()) {\n+            @Nullable\n+            JablotronAlarmHandler handler = (JablotronAlarmHandler) th.getHandler();\n+\n+            if (handler == null) {\n+                logger.debug(\"Thing handler is null\");\n+                continue;\n+            }\n+\n+            if (String.valueOf(service.getId()).equals(handler.thingConfig.getServiceId())) {\n+                if (\"ENABLED\".equals(service.getStatus())) {\n+                    if (!\"\".equals(service.getWarning())) {\n+                        logger.debug(\"Alarm with service id: {} warning: {}\", service.getId(), service.getWarning());\n+                    }\n+                    handler.setStatus(ThingStatus.ONLINE, ThingStatusDetail.NONE, service.getWarning());\n+                    if (\"ALARM\".equals(service.getWarning()) || \"TAMPER\".equals(service.getWarning())) {\n+                        handler.triggerAlarm(service);\n+                    }\n+                    handler.setInService(\"SERVICE\".equals(service.getWarning()));\n+                } else {\n+                    logger.debug(\"Alarm with service id: {} is offline\", service.getId());\n+                    handler.setStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, service.getStatus());\n+                }\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        super.dispose();\n+        if (future != null) {\n+            future.cancel(true);\n+        }\n+        logout();\n+    }\n+\n+    private @Nullable <T> T sendJsonMessage(String url, String urlParameters, Class<T> classOfT) {\n+        return sendMessage(url, urlParameters, classOfT, APPLICATION_JSON, true);\n+    }\n+\n+    private @Nullable <T> T sendJsonMessage(String url, String urlParameters, Class<T> classOfT, boolean relogin) {\n+        return sendMessage(url, urlParameters, classOfT, APPLICATION_JSON, relogin);\n+    }\n+\n+    private @Nullable <T> T sendUrlEncodedMessage(String url, String urlParameters, Class<T> classOfT) {\n+        return sendMessage(url, urlParameters, classOfT, WWW_FORM_URLENCODED, true);\n+    }\n+\n+    private @Nullable <T> T sendMessage(String url, String urlParameters, Class<T> classOfT, String encoding,\n+            boolean relogin) {\n+        try {\n+            ContentResponse resp = createRequest(url).content(new StringContentProvider(urlParameters), encoding)\n+                    .send();\n+\n+            logger.trace(\"Request: {} with data: {}\", url, urlParameters);\n+            String line = resp.getContentAsString();\n+            logger.trace(\"Response: {}\", line);\n+            return gson.fromJson(line, classOfT);\n+        } catch (TimeoutException e) {\n+            logger.debug(\"Timeout during calling url: {}\", url, e);\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                    \"Timeout during calling url: \" + url);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a590e81e68f4bb50a74b76dce0635a7906ca04ab"}, "originalPosition": 165}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjU5NjQ3OA==", "bodyText": "Same for below.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    @Nullable", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r486596478", "createdAt": "2020-09-10T19:53:12Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.jablotron/src/main/java/org/openhab/binding/jablotron/internal/handler/JablotronBridgeHandler.java", "diffHunk": "@@ -0,0 +1,385 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.jablotron.internal.handler;\n+\n+import static org.openhab.binding.jablotron.JablotronBindingConstants.*;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.eclipse.jetty.http.HttpHeader;\n+import org.eclipse.jetty.http.HttpMethod;\n+import org.eclipse.smarthome.core.thing.*;\n+import org.eclipse.smarthome.core.thing.binding.BaseBridgeHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.openhab.binding.jablotron.internal.config.JablotronBridgeConfig;\n+import org.openhab.binding.jablotron.internal.discovery.JablotronDiscoveryService;\n+import org.openhab.binding.jablotron.internal.model.*;\n+import org.openhab.binding.jablotron.internal.model.ja100f.JablotronGetPGResponse;\n+import org.openhab.binding.jablotron.internal.model.ja100f.JablotronGetSectionsResponse;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.JsonSyntaxException;\n+\n+/**\n+ * The {@link JablotronBridgeHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Ondrej Pecta - Initial contribution\n+ */\n+@NonNullByDefault\n+public class JablotronBridgeHandler extends BaseBridgeHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(JablotronBridgeHandler.class);\n+\n+    private final Gson gson = new Gson();\n+\n+    final HttpClient httpClient;\n+\n+    @Nullable\n+    ScheduledFuture<?> future = null;\n+\n+    /**\n+     * Our configuration\n+     */\n+    public JablotronBridgeConfig bridgeConfig = new JablotronBridgeConfig();\n+\n+    public JablotronBridgeHandler(Bridge thing, HttpClient httpClient) {\n+        super(thing);\n+        this.httpClient = httpClient;\n+    }\n+\n+    @Override\n+    public Collection<Class<? extends ThingHandlerService>> getServices() {\n+        return Collections.singleton(JablotronDiscoveryService.class);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        bridgeConfig = getConfigAs(JablotronBridgeConfig.class);\n+        scheduler.execute(this::login);\n+        future = scheduler.scheduleWithFixedDelay(this::updateAlarmThings, 30, bridgeConfig.getRefresh(),\n+                TimeUnit.SECONDS);\n+    }\n+\n+    private void updateAlarmThings() {\n+        @Nullable\n+        List<JablotronDiscoveredService> services = discoverServices();\n+        if (services != null) {\n+            for (JablotronDiscoveredService service : services) {\n+                updateAlarmThing(service);\n+            }\n+        }\n+    }\n+\n+    private void updateAlarmThing(JablotronDiscoveredService service) {\n+        for (Thing th : getThing().getThings()) {\n+            @Nullable\n+            JablotronAlarmHandler handler = (JablotronAlarmHandler) th.getHandler();\n+\n+            if (handler == null) {\n+                logger.debug(\"Thing handler is null\");\n+                continue;\n+            }\n+\n+            if (String.valueOf(service.getId()).equals(handler.thingConfig.getServiceId())) {\n+                if (\"ENABLED\".equals(service.getStatus())) {\n+                    if (!\"\".equals(service.getWarning())) {\n+                        logger.debug(\"Alarm with service id: {} warning: {}\", service.getId(), service.getWarning());\n+                    }\n+                    handler.setStatus(ThingStatus.ONLINE, ThingStatusDetail.NONE, service.getWarning());\n+                    if (\"ALARM\".equals(service.getWarning()) || \"TAMPER\".equals(service.getWarning())) {\n+                        handler.triggerAlarm(service);\n+                    }\n+                    handler.setInService(\"SERVICE\".equals(service.getWarning()));\n+                } else {\n+                    logger.debug(\"Alarm with service id: {} is offline\", service.getId());\n+                    handler.setStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, service.getStatus());\n+                }\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        super.dispose();\n+        if (future != null) {\n+            future.cancel(true);\n+        }\n+        logout();\n+    }\n+\n+    private @Nullable <T> T sendJsonMessage(String url, String urlParameters, Class<T> classOfT) {\n+        return sendMessage(url, urlParameters, classOfT, APPLICATION_JSON, true);\n+    }\n+\n+    private @Nullable <T> T sendJsonMessage(String url, String urlParameters, Class<T> classOfT, boolean relogin) {\n+        return sendMessage(url, urlParameters, classOfT, APPLICATION_JSON, relogin);\n+    }\n+\n+    private @Nullable <T> T sendUrlEncodedMessage(String url, String urlParameters, Class<T> classOfT) {\n+        return sendMessage(url, urlParameters, classOfT, WWW_FORM_URLENCODED, true);\n+    }\n+\n+    private @Nullable <T> T sendMessage(String url, String urlParameters, Class<T> classOfT, String encoding,\n+            boolean relogin) {\n+        try {\n+            ContentResponse resp = createRequest(url).content(new StringContentProvider(urlParameters), encoding)\n+                    .send();\n+\n+            logger.trace(\"Request: {} with data: {}\", url, urlParameters);\n+            String line = resp.getContentAsString();\n+            logger.trace(\"Response: {}\", line);\n+            return gson.fromJson(line, classOfT);\n+        } catch (TimeoutException e) {\n+            logger.debug(\"Timeout during calling url: {}\", url, e);\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                    \"Timeout during calling url: \" + url);\n+        } catch (InterruptedException e) {\n+            logger.debug(\"Interrupt during calling url: {}\", url, e);\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                    \"Interrupt during calling url: \" + url);\n+            Thread.currentThread().interrupt();\n+        } catch (JsonSyntaxException e) {\n+            logger.debug(\"Syntax error during calling url: {}\", url, e);\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                    \"Syntax error during calling url: \" + url);\n+        } catch (ExecutionException e) {\n+            if (relogin) {\n+                if (e.getMessage().contains(AUTHENTICATION_CHALLENGE)) {\n+                    relogin();\n+                    return null;\n+                }\n+            }\n+            logger.debug(\"Error during calling url: {}\", url, e);\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                    \"Error during calling url: \" + url);\n+        }\n+        return null;\n+    }\n+\n+    protected synchronized void login() {\n+        String url = JABLOTRON_API_URL + \"userAuthorize.json\";\n+        String urlParameters = \"{\\\"login\\\":\\\"\" + bridgeConfig.getLogin() + \"\\\", \\\"password\\\":\\\"\"\n+                + bridgeConfig.getPassword() + \"\\\"}\";\n+        @Nullable", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a590e81e68f4bb50a74b76dce0635a7906ca04ab"}, "originalPosition": 193}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjU5NzcyMA==", "bodyText": "Can you handle the RefreshType command?", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r486597720", "createdAt": "2020-09-10T19:55:39Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.jablotron/src/main/java/org/openhab/binding/jablotron/internal/handler/JablotronJa100FHandler.java", "diffHunk": "@@ -0,0 +1,182 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.jablotron.internal.handler;\n+\n+import static org.openhab.binding.jablotron.JablotronBindingConstants.CHANNEL_LAST_CHECK_TIME;\n+\n+import java.util.List;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.binding.builder.ChannelBuilder;\n+import org.eclipse.smarthome.core.thing.binding.builder.ThingBuilder;\n+import org.eclipse.smarthome.core.thing.type.ChannelTypeUID;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.jablotron.internal.model.JablotronHistoryDataEvent;\n+import org.openhab.binding.jablotron.internal.model.ja100f.JablotronGetPGResponse;\n+import org.openhab.binding.jablotron.internal.model.ja100f.JablotronGetSectionsResponse;\n+import org.openhab.binding.jablotron.internal.model.ja100f.JablotronSection;\n+import org.openhab.binding.jablotron.internal.model.ja100f.JablotronState;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link JablotronJa100FHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Ondrej Pecta - Initial contribution\n+ */\n+@NonNullByDefault\n+public class JablotronJa100FHandler extends JablotronAlarmHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(JablotronJa100FHandler.class);\n+\n+    public JablotronJa100FHandler(Thing thing, String alarmName) {\n+        super(thing, alarmName);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (channelUID.getId().startsWith(\"SEC-\") && command instanceof StringType) {\n+            if (\"PARTIAL_ARM\".equals(command.toString())) {\n+                controlComponent(channelUID.getId(), \"CONTROL-SECTION\", \"DISARM\");\n+            }\n+            scheduler.execute(() -> controlComponent(channelUID.getId(), \"CONTROL-SECTION\", command.toString()));\n+        }\n+\n+        if (channelUID.getId().startsWith(\"PG-\") && command instanceof OnOffType) {\n+            scheduler.execute(() -> controlComponent(channelUID.getId(), \"CONTROL-PG\", command.toString()));\n+        }\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a590e81e68f4bb50a74b76dce0635a7906ca04ab"}, "originalPosition": 65}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjYwMDQ2NQ==", "bodyText": "See above. Handle refresh.", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r486600465", "createdAt": "2020-09-10T20:01:10Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.jablotron/src/main/java/org/openhab/binding/jablotron/internal/handler/JablotronJa100Handler.java", "diffHunk": "@@ -0,0 +1,203 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.jablotron.internal.handler;\n+\n+import java.util.List;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.binding.builder.ChannelBuilder;\n+import org.eclipse.smarthome.core.thing.binding.builder.ThingBuilder;\n+import org.eclipse.smarthome.core.thing.type.ChannelTypeUID;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.jablotron.internal.model.JablotronControlResponse;\n+import org.openhab.binding.jablotron.internal.model.JablotronServiceDetailSegment;\n+import org.openhab.binding.jablotron.internal.model.JablotronServiceDetailSegmentInfo;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link JablotronJa100Handler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Ondrej Pecta - Initial contribution\n+ */\n+@NonNullByDefault\n+public class JablotronJa100Handler extends JablotronAlarmHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(JablotronJa100Handler.class);\n+\n+    public JablotronJa100Handler(Thing thing, String alarmName) {\n+        super(thing, alarmName);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (channelUID.getId().startsWith(\"STATE_\") && command instanceof StringType) {\n+            scheduler.execute(() -> {\n+                controlSTATESection(channelUID.getId(), command.toString());\n+            });\n+        }\n+\n+        if (channelUID.getId().startsWith(\"PGM_\") && command instanceof OnOffType) {\n+            scheduler.execute(() -> {\n+                controlPGMSection(channelUID.getId(), command.equals(OnOffType.ON) ? \"set\" : \"unset\");\n+            });\n+        }\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a590e81e68f4bb50a74b76dce0635a7906ca04ab"}, "originalPosition": 63}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjYwMjg3MQ==", "bodyText": "Is there a reason why you create the temperature Channel dynamically? Is the temperature sensor not always present at JA-100 devices?", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r486602871", "createdAt": "2020-09-10T20:06:00Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.jablotron/src/main/java/org/openhab/binding/jablotron/internal/handler/JablotronJa100Handler.java", "diffHunk": "@@ -0,0 +1,203 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.jablotron.internal.handler;\n+\n+import java.util.List;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.binding.builder.ChannelBuilder;\n+import org.eclipse.smarthome.core.thing.binding.builder.ThingBuilder;\n+import org.eclipse.smarthome.core.thing.type.ChannelTypeUID;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.jablotron.internal.model.JablotronControlResponse;\n+import org.openhab.binding.jablotron.internal.model.JablotronServiceDetailSegment;\n+import org.openhab.binding.jablotron.internal.model.JablotronServiceDetailSegmentInfo;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link JablotronJa100Handler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Ondrej Pecta - Initial contribution\n+ */\n+@NonNullByDefault\n+public class JablotronJa100Handler extends JablotronAlarmHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(JablotronJa100Handler.class);\n+\n+    public JablotronJa100Handler(Thing thing, String alarmName) {\n+        super(thing, alarmName);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (channelUID.getId().startsWith(\"STATE_\") && command instanceof StringType) {\n+            scheduler.execute(() -> {\n+                controlSTATESection(channelUID.getId(), command.toString());\n+            });\n+        }\n+\n+        if (channelUID.getId().startsWith(\"PGM_\") && command instanceof OnOffType) {\n+            scheduler.execute(() -> {\n+                controlPGMSection(channelUID.getId(), command.equals(OnOffType.ON) ? \"set\" : \"unset\");\n+            });\n+        }\n+    }\n+\n+    private void createChannel(JablotronServiceDetailSegment section) {\n+        if (section.getSegmentId().startsWith(\"PGM_\")) {\n+            createPGMChannel(section.getSegmentId(), section.getSegmentName());\n+        } else {\n+            createStateChannel(section.getSegmentId(), section.getSegmentName());\n+        }\n+    }\n+\n+    private void createTempChannel(String name, String label) {\n+        ChannelTypeUID temperature = new ChannelTypeUID(\"jablotron\", \"temperature\");\n+        ThingBuilder thingBuilder = editThing();\n+        Channel channel = ChannelBuilder.create(new ChannelUID(thing.getUID(), name), \"Number:Temperature\")\n+                .withLabel(label).withType(temperature).build();\n+        thingBuilder.withChannel(channel);\n+        updateThing(thingBuilder.build());\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a590e81e68f4bb50a74b76dce0635a7906ca04ab"}, "originalPosition": 80}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjYwNDMwNg==", "bodyText": "Did you test this? Are there Channels starting with STATE_?", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r486604306", "createdAt": "2020-09-10T20:09:00Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.jablotron/src/main/java/org/openhab/binding/jablotron/internal/handler/JablotronJa100Handler.java", "diffHunk": "@@ -0,0 +1,203 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.jablotron.internal.handler;\n+\n+import java.util.List;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.binding.builder.ChannelBuilder;\n+import org.eclipse.smarthome.core.thing.binding.builder.ThingBuilder;\n+import org.eclipse.smarthome.core.thing.type.ChannelTypeUID;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.jablotron.internal.model.JablotronControlResponse;\n+import org.openhab.binding.jablotron.internal.model.JablotronServiceDetailSegment;\n+import org.openhab.binding.jablotron.internal.model.JablotronServiceDetailSegmentInfo;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link JablotronJa100Handler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Ondrej Pecta - Initial contribution\n+ */\n+@NonNullByDefault\n+public class JablotronJa100Handler extends JablotronAlarmHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(JablotronJa100Handler.class);\n+\n+    public JablotronJa100Handler(Thing thing, String alarmName) {\n+        super(thing, alarmName);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (channelUID.getId().startsWith(\"STATE_\") && command instanceof StringType) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a590e81e68f4bb50a74b76dce0635a7906ca04ab"}, "originalPosition": 52}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjYwNjIxNQ==", "bodyText": "See above. refresh", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r486606215", "createdAt": "2020-09-10T20:12:57Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.jablotron/src/main/java/org/openhab/binding/jablotron/internal/handler/JablotronOasisHandler.java", "diffHunk": "@@ -0,0 +1,116 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.jablotron.internal.handler;\n+\n+import static org.openhab.binding.jablotron.JablotronBindingConstants.*;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.jablotron.internal.model.JablotronControlResponse;\n+import org.openhab.binding.jablotron.internal.model.JablotronServiceDetailSegment;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link JablotronOasisHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Ondrej Pecta - Initial contribution\n+ */\n+@NonNullByDefault\n+public class JablotronOasisHandler extends JablotronAlarmHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(JablotronOasisHandler.class);\n+\n+    public JablotronOasisHandler(Thing thing, String alarmName) {\n+        super(thing, alarmName);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (channelUID.getId().equals(CHANNEL_COMMAND) && command instanceof StringType) {\n+            scheduler.execute(() -> {\n+                sendCommand(command.toString());\n+            });\n+        }\n+\n+        if (channelUID.getId().equals(CHANNEL_STATUS_PGX) && command instanceof OnOffType) {\n+            scheduler.execute(() -> {\n+                controlSection(\"PGM_1\", command.equals(OnOffType.ON) ? \"set\" : \"unset\");\n+            });\n+        }\n+\n+        if (channelUID.getId().equals(CHANNEL_STATUS_PGY) && command instanceof OnOffType) {\n+            scheduler.execute(() -> {\n+                controlSection(\"PGM_2\", command.equals(OnOffType.ON) ? \"set\" : \"unset\");\n+            });\n+        }\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a590e81e68f4bb50a74b76dce0635a7906ca04ab"}, "originalPosition": 66}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjYwODQwOQ==", "bodyText": "You don't need to poll the state, as the Channel has already the new value, the user set before.\nOr does setting one Channel affect the state of another Channel?", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r486608409", "createdAt": "2020-09-10T20:17:12Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.jablotron/src/main/java/org/openhab/binding/jablotron/internal/handler/JablotronOasisHandler.java", "diffHunk": "@@ -0,0 +1,116 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.jablotron.internal.handler;\n+\n+import static org.openhab.binding.jablotron.JablotronBindingConstants.*;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.jablotron.internal.model.JablotronControlResponse;\n+import org.openhab.binding.jablotron.internal.model.JablotronServiceDetailSegment;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link JablotronOasisHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Ondrej Pecta - Initial contribution\n+ */\n+@NonNullByDefault\n+public class JablotronOasisHandler extends JablotronAlarmHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(JablotronOasisHandler.class);\n+\n+    public JablotronOasisHandler(Thing thing, String alarmName) {\n+        super(thing, alarmName);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (channelUID.getId().equals(CHANNEL_COMMAND) && command instanceof StringType) {\n+            scheduler.execute(() -> {\n+                sendCommand(command.toString());\n+            });\n+        }\n+\n+        if (channelUID.getId().equals(CHANNEL_STATUS_PGX) && command instanceof OnOffType) {\n+            scheduler.execute(() -> {\n+                controlSection(\"PGM_1\", command.equals(OnOffType.ON) ? \"set\" : \"unset\");\n+            });\n+        }\n+\n+        if (channelUID.getId().equals(CHANNEL_STATUS_PGY) && command instanceof OnOffType) {\n+            scheduler.execute(() -> {\n+                controlSection(\"PGM_2\", command.equals(OnOffType.ON) ? \"set\" : \"unset\");\n+            });\n+        }\n+    }\n+\n+    @Override\n+    protected void updateSegmentStatus(JablotronServiceDetailSegment segment) {\n+        logger.debug(\"Segment id: {} and status: {}\", segment.getSegmentId(), segment.getSegmentState());\n+        State newState = \"unset\".equals(segment.getSegmentState()) ? OnOffType.OFF : OnOffType.ON;\n+        switch (segment.getSegmentId()) {\n+            case \"STATE_1\":\n+                updateState(CHANNEL_STATUS_A, newState);\n+                break;\n+            case \"STATE_2\":\n+                updateState(CHANNEL_STATUS_B, newState);\n+                break;\n+            case \"STATE_3\":\n+                updateState(CHANNEL_STATUS_ABC, newState);\n+                break;\n+            case \"PGM_1\":\n+                updateState(CHANNEL_STATUS_PGX, newState);\n+                break;\n+            case \"PGM_2\":\n+                updateState(CHANNEL_STATUS_PGY, newState);\n+                break;\n+            default:\n+                logger.debug(\"Unknown segment received: {} with state: {}\", segment.getSegmentId(),\n+                        segment.getSegmentState());\n+        }\n+    }\n+\n+    public synchronized void controlSection(String section, String status) {\n+        logger.debug(\"Controlling section: {} with status: {}\", section, status);\n+        JablotronControlResponse response = sendUserCode(section, section.toLowerCase(), status, \"\");\n+\n+        updateAlarmStatus();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a590e81e68f4bb50a74b76dce0635a7906ca04ab"}, "originalPosition": 98}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjYwODUwNw==", "bodyText": "See above", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r486608507", "createdAt": "2020-09-10T20:17:25Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.jablotron/src/main/java/org/openhab/binding/jablotron/internal/handler/JablotronOasisHandler.java", "diffHunk": "@@ -0,0 +1,116 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.jablotron.internal.handler;\n+\n+import static org.openhab.binding.jablotron.JablotronBindingConstants.*;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.jablotron.internal.model.JablotronControlResponse;\n+import org.openhab.binding.jablotron.internal.model.JablotronServiceDetailSegment;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link JablotronOasisHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Ondrej Pecta - Initial contribution\n+ */\n+@NonNullByDefault\n+public class JablotronOasisHandler extends JablotronAlarmHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(JablotronOasisHandler.class);\n+\n+    public JablotronOasisHandler(Thing thing, String alarmName) {\n+        super(thing, alarmName);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (channelUID.getId().equals(CHANNEL_COMMAND) && command instanceof StringType) {\n+            scheduler.execute(() -> {\n+                sendCommand(command.toString());\n+            });\n+        }\n+\n+        if (channelUID.getId().equals(CHANNEL_STATUS_PGX) && command instanceof OnOffType) {\n+            scheduler.execute(() -> {\n+                controlSection(\"PGM_1\", command.equals(OnOffType.ON) ? \"set\" : \"unset\");\n+            });\n+        }\n+\n+        if (channelUID.getId().equals(CHANNEL_STATUS_PGY) && command instanceof OnOffType) {\n+            scheduler.execute(() -> {\n+                controlSection(\"PGM_2\", command.equals(OnOffType.ON) ? \"set\" : \"unset\");\n+            });\n+        }\n+    }\n+\n+    @Override\n+    protected void updateSegmentStatus(JablotronServiceDetailSegment segment) {\n+        logger.debug(\"Segment id: {} and status: {}\", segment.getSegmentId(), segment.getSegmentState());\n+        State newState = \"unset\".equals(segment.getSegmentState()) ? OnOffType.OFF : OnOffType.ON;\n+        switch (segment.getSegmentId()) {\n+            case \"STATE_1\":\n+                updateState(CHANNEL_STATUS_A, newState);\n+                break;\n+            case \"STATE_2\":\n+                updateState(CHANNEL_STATUS_B, newState);\n+                break;\n+            case \"STATE_3\":\n+                updateState(CHANNEL_STATUS_ABC, newState);\n+                break;\n+            case \"PGM_1\":\n+                updateState(CHANNEL_STATUS_PGX, newState);\n+                break;\n+            case \"PGM_2\":\n+                updateState(CHANNEL_STATUS_PGY, newState);\n+                break;\n+            default:\n+                logger.debug(\"Unknown segment received: {} with state: {}\", segment.getSegmentId(),\n+                        segment.getSegmentState());\n+        }\n+    }\n+\n+    public synchronized void controlSection(String section, String status) {\n+        logger.debug(\"Controlling section: {} with status: {}\", section, status);\n+        JablotronControlResponse response = sendUserCode(section, section.toLowerCase(), status, \"\");\n+\n+        updateAlarmStatus();\n+        if (response == null) {\n+            logger.debug(\"null response/status received during the control of section: {}\", section);\n+        }\n+    }\n+\n+    public synchronized void sendCommand(String code) {\n+        JablotronControlResponse response = sendUserCode(code);\n+        scheduler.schedule(this::updateAlarmStatus, 1, TimeUnit.SECONDS);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a590e81e68f4bb50a74b76dce0635a7906ca04ab"}, "originalPosition": 106}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjYwOTQyMA==", "bodyText": "This sound rather an Action than a Channel.", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r486609420", "createdAt": "2020-09-10T20:19:13Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.jablotron/README.md", "diffHunk": "@@ -0,0 +1,120 @@\n+# Jablotron Alarm Binding\n+\n+This is the binding for Jablotron alarms.\n+https://www.jablotron.com/en/jablotron-products/alarms/\n+\n+## Supported Things\n+\n+| thing   | note                                      |\n+|---------|-------------------------------------------|\n+| bridge  | the bridge to your Jablonet cloud account |\n+| JA-80   | the OASIS alarm                           |\n+| JA-100  | with the thermometer support              |\n+| JA-100F | without the thermometer support           |\n+ \n+## Discovery\n+\n+This binding supports auto discovery. Just manually add a bridge thing and supply login & password to your Jablonet account.\n+\n+## Binding Configuration\n+\n+Binding itself doesn't require specific configuration.\n+\n+## Thing Configuration\n+\n+| thing                | config parameter name | description                                                                        | type                  |\n+|----------------------|-----------------------|------------------------------------------------------------------------------------|-----------------------|\n+| bridge               | login                 | the login to your Jablonet account                                                 | mandatory             |\n+| bridge               | password              | the password to your Jablonet account                                              | mandatory             |\n+| bridge               | refresh               | the refresh time for all alarm warnings (ALARM, TAMPER triggers and SERVICE state) | optional, default=30s |\n+| bridge               | lang                  | the language of the alarm texts                                                    | optional, default=en  |\n+| JA-80/JA-100/JA-100F | refresh               | the channels refresh period in seconds                                             | optional, default=60s |\n+| JA-80/JA-100/JA-100F | serviceId             | the service ID which identifies the alarm                                          | mandatory             |\n+| JA-100/JA-100F       | code                  | the master code for controlling sections                                           | optional              |\n+\n+## Channels\n+\n+| thing                | channel name     | description                                               |\n+|----------------------|------------------|-----------------------------------------------------------|\n+| bridge               | N/A              | the bridge does not expose any channels                   |\n+| JA-80                | statusA          | the status of the A section                               |\n+| JA-80                | statusB          | the status of the AB/B section                            |\n+| JA-80                | statusABC        | the status of the ABC section                             |\n+| JA-80                | statusPGX        | the status of PGX                                         |\n+| JA-80                | statusPGY        | the status of PGY                                         |\n+| JA-80                | command          | the channel for sending keyboard codes to the OASIS alarm |", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a590e81e68f4bb50a74b76dce0635a7906ca04ab"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjYxMDY3Mg==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t<description>This is the binding for Jablotron.</description>\n          \n          \n            \n            \t<description>This is the binding for Jablotron Alarm Systems.</description>", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r486610672", "createdAt": "2020-09-10T20:21:32Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.jablotron/src/main/resources/ESH-INF/binding/binding.xml", "diffHunk": "@@ -0,0 +1,10 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<binding:binding id=\"jablotron\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:binding=\"https://openhab.org/schemas/binding/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/binding/v1.0.0 https://openhab.org/schemas/binding-1.0.0.xsd\">\n+\n+\t<name>Jablotron Binding</name>\n+\t<description>This is the binding for Jablotron.</description>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a590e81e68f4bb50a74b76dce0635a7906ca04ab"}, "originalPosition": 7}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjYxMDgwMg==", "bodyText": "Better specify a reasonable min value (e.g. 1) to prevent entering 0 or a negative number, which would crash your binding. Same for below.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\t<parameter name=\"refresh\" type=\"integer\" required=\"false\">\n          \n          \n            \n            \t\t<parameter name=\"refresh\" type=\"integer\" required=\"false\" unit=\"s\">", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r486610802", "createdAt": "2020-09-10T20:21:47Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.jablotron/src/main/resources/ESH-INF/config/config.xml", "diffHunk": "@@ -0,0 +1,86 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<config-description:config-descriptions\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:config-description=\"https://openhab.org/schemas/config-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/config-description/v1.0.0 https://openhab.org/schemas/config-description-1.0.0.xsd\">\n+\n+\t<config-description uri=\"thing-type:jablotron:device\">\n+\t\t<parameter name=\"refresh\" type=\"integer\" required=\"false\">", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a590e81e68f4bb50a74b76dce0635a7906ca04ab"}, "originalPosition": 8}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjYxMzM3MA==", "bodyText": "As this trigger Channel has payload, the <event /> tag shall be specified. See https://www.openhab.org/docs/developer/bindings/thing-xml.html#trigger-channel-types", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r486613370", "createdAt": "2020-09-10T20:26:40Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.jablotron/src/main/resources/ESH-INF/thing/channels.xml", "diffHunk": "@@ -0,0 +1,165 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"jablotron\"\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\t<!-- Oasis -->\n+\t<!-- StatusA -->\n+\t<channel-type id=\"statusA\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Alarm Zone A Status</label>\n+\t\t<description>Status of the A zone of your alarm</description>\n+\t\t<state readOnly=\"true\"/>\n+\t</channel-type>\n+\n+\t<!-- StatusB -->\n+\t<channel-type id=\"statusB\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Alarm B Status</label>\n+\t\t<description>Status of the B zone of your alarm</description>\n+\t\t<state readOnly=\"true\"/>\n+\t</channel-type>\n+\n+\t<!-- StatusABC -->\n+\t<channel-type id=\"statusABC\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Alarm Zone ABC Status</label>\n+\t\t<description>Status of the ABC zone of your alarm</description>\n+\t\t<state readOnly=\"true\"/>\n+\t</channel-type>\n+\n+\t<!-- StatusPGX -->\n+\t<channel-type id=\"statusPGX\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>OASIS PGX Status</label>\n+\t\t<description>Status of the PGX switch of your OASIS alarm</description>\n+\t</channel-type>\n+\n+\t<!-- StatusPGY -->\n+\t<channel-type id=\"statusPGY\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>OASIS PGY Status</label>\n+\t\t<description>Status of the PGY switch of your OASIS alarm</description>\n+\t</channel-type>\n+\n+\t<!-- JA100 -->\n+\t<channel-type id=\"status\">\n+\t\t<item-type>Number</item-type>\n+\t\t<label>Alarm Section Status</label>\n+\t\t<description>Status of the section of your alarm</description>\n+\t</channel-type>\n+\n+\t<!-- StatusPGM -->\n+\t<channel-type id=\"statusPGM\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>JA-100 PGM Status</label>\n+\t\t<description>Status of the PGM switch of your JA-100 alarm</description>\n+\t</channel-type>\n+\n+\t<!-- Alarm -->\n+\t<channel-type id=\"alarm\">\n+\t\t<kind>trigger</kind>\n+\t\t<label>Alarm</label>\n+\t\t<description>Status of the alarm of your alarm</description>\n+\t\t<state readOnly=\"true\"/>\n+\t</channel-type>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a590e81e68f4bb50a74b76dce0635a7906ca04ab"}, "originalPosition": 65}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjYxODg3Mw==", "bodyText": "As bridgeHandler is Nullable, you have to do a null check before accessing it. You can store it to a local variable and do the null check on that. Same for the others in this file.", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r486618873", "createdAt": "2020-09-10T20:37:20Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.jablotron/src/main/java/org/openhab/binding/jablotron/internal/discovery/JablotronDiscoveryService.java", "diffHunk": "@@ -0,0 +1,171 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.jablotron.internal.discovery;\n+\n+import static org.openhab.binding.jablotron.JablotronBindingConstants.*;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.config.discovery.*;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.thing.ThingUID;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.openhab.binding.jablotron.internal.handler.JablotronBridgeHandler;\n+import org.openhab.binding.jablotron.internal.model.JablotronDiscoveredService;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link JablotronDiscoveryService} is responsible for the thing discovery\n+ * process.\n+ *\n+ * @author Ondrej Pecta - Initial contribution\n+ */\n+@NonNullByDefault\n+public class JablotronDiscoveryService extends AbstractDiscoveryService\n+        implements DiscoveryService, ThingHandlerService {\n+    private final Logger logger = LoggerFactory.getLogger(JablotronDiscoveryService.class);\n+\n+    private @Nullable JablotronBridgeHandler bridgeHandler;\n+\n+    private @Nullable ScheduledFuture<?> discoveryJob = null;\n+\n+    public JablotronDiscoveryService() {\n+        super(DISCOVERY_TIMEOUT_SEC);\n+        logger.debug(\"Creating discovery service\");\n+    }\n+\n+    private void startDiscovery() {\n+        if (this.bridgeHandler.getThing().getStatus() == ThingStatus.ONLINE) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a590e81e68f4bb50a74b76dce0635a7906ca04ab"}, "originalPosition": 58}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d4b5ba212823258ad7b10e18f3c2f3a63030b810", "author": {"user": {"login": "octa22", "name": "Ondrej Pecta"}}, "url": "https://github.com/openhab/openhab-addons/commit/d4b5ba212823258ad7b10e18f3c2f3a63030b810", "committedDate": "2020-09-11T16:53:14Z", "message": "[jablotron] another bunch of improvements based on code revires\n\nSigned-off-by: Ondrej Pecta <opecta@gmail.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "763fc82a35d72142f670cae58214a6aa1d80ed06", "author": {"user": {"login": "octa22", "name": "Ondrej Pecta"}}, "url": "https://github.com/openhab/openhab-addons/commit/763fc82a35d72142f670cae58214a6aa1d80ed06", "committedDate": "2020-09-11T23:06:34Z", "message": "[jablotron] implemented the refreshing of channels\n\nSigned-off-by: Ondrej Pecta <opecta@gmail.com>"}, "afterCommit": {"oid": "516302a479c102f6f7f8e8cbd8904bf67e5c3c89", "author": {"user": {"login": "octa22", "name": "Ondrej Pecta"}}, "url": "https://github.com/openhab/openhab-addons/commit/516302a479c102f6f7f8e8cbd8904bf67e5c3c89", "committedDate": "2020-09-12T06:41:41Z", "message": "[jablotron] implemented the refreshing of channels\n\nSigned-off-by: Ondrej Pecta <opecta@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "bb824dab23246fe665151e79780dc81f6fe4928f", "author": {"user": {"login": "octa22", "name": "Ondrej Pecta"}}, "url": "https://github.com/openhab/openhab-addons/commit/bb824dab23246fe665151e79780dc81f6fe4928f", "committedDate": "2020-09-12T06:57:07Z", "message": "[jablotron] implemented the refreshing of channels\n\nSigned-off-by: Ondrej Pecta <opecta@gmail.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "516302a479c102f6f7f8e8cbd8904bf67e5c3c89", "author": {"user": {"login": "octa22", "name": "Ondrej Pecta"}}, "url": "https://github.com/openhab/openhab-addons/commit/516302a479c102f6f7f8e8cbd8904bf67e5c3c89", "committedDate": "2020-09-12T06:41:41Z", "message": "[jablotron] implemented the refreshing of channels\n\nSigned-off-by: Ondrej Pecta <opecta@gmail.com>"}, "afterCommit": {"oid": "bb824dab23246fe665151e79780dc81f6fe4928f", "author": {"user": {"login": "octa22", "name": "Ondrej Pecta"}}, "url": "https://github.com/openhab/openhab-addons/commit/bb824dab23246fe665151e79780dc81f6fe4928f", "committedDate": "2020-09-12T06:57:07Z", "message": "[jablotron] implemented the refreshing of channels\n\nSigned-off-by: Ondrej Pecta <opecta@gmail.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg3MjE3NTM1", "url": "https://github.com/openhab/openhab-addons/pull/6990#pullrequestreview-487217535", "createdAt": "2020-09-12T09:20:09Z", "commit": {"oid": "bb824dab23246fe665151e79780dc81f6fe4928f"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 13, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMlQwOToyMDowOVrOHQz5UQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMlQxMDowMzoyNFrOHQ0HhA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzM4OTUyMQ==", "bodyText": "These don't need to be nullable, as they are initialized in the constructor.", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r487389521", "createdAt": "2020-09-12T09:20:09Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.jablotron/src/main/java/org/openhab/binding/jablotron/internal/handler/JablotronJa100FHandler.java", "diffHunk": "@@ -0,0 +1,251 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.jablotron.internal.handler;\n+\n+import static org.openhab.binding.jablotron.JablotronBindingConstants.CACHE_TIMEOUT_MS;\n+import static org.openhab.binding.jablotron.JablotronBindingConstants.CHANNEL_LAST_CHECK_TIME;\n+\n+import java.util.List;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.cache.ExpiringCache;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.binding.builder.ChannelBuilder;\n+import org.eclipse.smarthome.core.thing.binding.builder.ThingBuilder;\n+import org.eclipse.smarthome.core.thing.type.ChannelTypeUID;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.jablotron.internal.model.JablotronHistoryDataEvent;\n+import org.openhab.binding.jablotron.internal.model.JablotronServiceDetailSegment;\n+import org.openhab.binding.jablotron.internal.model.ja100f.JablotronGetPGResponse;\n+import org.openhab.binding.jablotron.internal.model.ja100f.JablotronGetSectionsResponse;\n+import org.openhab.binding.jablotron.internal.model.ja100f.JablotronSection;\n+import org.openhab.binding.jablotron.internal.model.ja100f.JablotronState;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link JablotronJa100FHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Ondrej Pecta - Initial contribution\n+ */\n+@NonNullByDefault\n+public class JablotronJa100FHandler extends JablotronAlarmHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(JablotronJa100FHandler.class);\n+\n+    private @Nullable ExpiringCache<JablotronGetSectionsResponse> sectionCache;\n+    private @Nullable ExpiringCache<JablotronGetPGResponse> pgCache;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bb824dab23246fe665151e79780dc81f6fe4928f"}, "originalPosition": 55}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzM4OTYyMQ==", "bodyText": "To eliminate the compiler warnings, you could move this initialization to the JablotronAlarmHandler constructor.", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r487389621", "createdAt": "2020-09-12T09:21:24Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.jablotron/src/main/java/org/openhab/binding/jablotron/internal/handler/JablotronJa100FHandler.java", "diffHunk": "@@ -0,0 +1,251 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.jablotron.internal.handler;\n+\n+import static org.openhab.binding.jablotron.JablotronBindingConstants.CACHE_TIMEOUT_MS;\n+import static org.openhab.binding.jablotron.JablotronBindingConstants.CHANNEL_LAST_CHECK_TIME;\n+\n+import java.util.List;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.cache.ExpiringCache;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.binding.builder.ChannelBuilder;\n+import org.eclipse.smarthome.core.thing.binding.builder.ThingBuilder;\n+import org.eclipse.smarthome.core.thing.type.ChannelTypeUID;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.jablotron.internal.model.JablotronHistoryDataEvent;\n+import org.openhab.binding.jablotron.internal.model.JablotronServiceDetailSegment;\n+import org.openhab.binding.jablotron.internal.model.ja100f.JablotronGetPGResponse;\n+import org.openhab.binding.jablotron.internal.model.ja100f.JablotronGetSectionsResponse;\n+import org.openhab.binding.jablotron.internal.model.ja100f.JablotronSection;\n+import org.openhab.binding.jablotron.internal.model.ja100f.JablotronState;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link JablotronJa100FHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Ondrej Pecta - Initial contribution\n+ */\n+@NonNullByDefault\n+public class JablotronJa100FHandler extends JablotronAlarmHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(JablotronJa100FHandler.class);\n+\n+    private @Nullable ExpiringCache<JablotronGetSectionsResponse> sectionCache;\n+    private @Nullable ExpiringCache<JablotronGetPGResponse> pgCache;\n+\n+    public JablotronJa100FHandler(Thing thing, String alarmName) {\n+        super(thing, alarmName);\n+        eventCache = new ExpiringCache<>(CACHE_TIMEOUT_MS, this::sendGetEventHistory);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bb824dab23246fe665151e79780dc81f6fe4928f"}, "originalPosition": 59}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzM5MDIxOQ==", "bodyText": "If I see correctly, eventCache is always non-null in your implementation.", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r487390219", "createdAt": "2020-09-12T09:28:47Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.jablotron/src/main/java/org/openhab/binding/jablotron/internal/handler/JablotronAlarmHandler.java", "diffHunk": "@@ -0,0 +1,268 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.jablotron.internal.handler;\n+\n+import static org.openhab.binding.jablotron.JablotronBindingConstants.*;\n+\n+import java.time.Instant;\n+import java.time.ZoneId;\n+import java.time.ZonedDateTime;\n+import java.time.format.DateTimeFormatter;\n+import java.util.List;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.cache.ExpiringCache;\n+import org.eclipse.smarthome.core.library.types.DateTimeType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.*;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.jablotron.internal.config.JablotronDeviceConfig;\n+import org.openhab.binding.jablotron.internal.model.*;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+\n+/**\n+ * The {@link JablotronAlarmHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Ondrej Pecta - Initial contribution\n+ */\n+@NonNullByDefault\n+public abstract class JablotronAlarmHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(getClass());\n+\n+    protected final Gson gson = new Gson();\n+\n+    protected JablotronDeviceConfig thingConfig = new JablotronDeviceConfig();\n+\n+    private String lastWarningTime = \"\";\n+\n+    protected String alarmName = \"\";\n+\n+    private boolean inService = false;\n+\n+    protected @Nullable ScheduledFuture<?> future = null;\n+\n+    protected @Nullable ExpiringCache<JablotronDataUpdateResponse> dataCache;\n+    protected @Nullable ExpiringCache<List<JablotronHistoryDataEvent>> eventCache;\n+\n+    public JablotronAlarmHandler(Thing thing, String alarmName) {\n+        super(thing);\n+        this.alarmName = alarmName;\n+    }\n+\n+    @Override\n+    public void bridgeStatusChanged(ThingStatusInfo bridgeStatusInfo) {\n+        super.bridgeStatusChanged(bridgeStatusInfo);\n+        if (ThingStatus.UNINITIALIZED == bridgeStatusInfo.getStatus()) {\n+            cleanup();\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        super.dispose();\n+        cleanup();\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        thingConfig = getConfigAs(JablotronDeviceConfig.class);\n+        future = scheduler.scheduleWithFixedDelay(this::updateAlarmStatus, 1, thingConfig.getRefresh(),\n+                TimeUnit.SECONDS);\n+        updateStatus(ThingStatus.ONLINE);\n+    }\n+\n+    public boolean isInService() {\n+        return inService;\n+    }\n+\n+    public String getAlarmName() {\n+        return alarmName;\n+    }\n+\n+    protected abstract void updateSegmentStatus(JablotronServiceDetailSegment segment);\n+\n+    protected void updateSegmentStatus(String segmentName, @Nullable JablotronDataUpdateResponse dataUpdate) {\n+        if (dataUpdate == null || !dataUpdate.isStatus()) {\n+            return;\n+        }\n+        List<JablotronServiceData> serviceData = dataUpdate.getData().getServiceData();\n+        for (JablotronServiceData data : serviceData) {\n+            if (!thingConfig.getServiceId().equals(data.getServiceId())) {\n+                continue;\n+            }\n+            List<JablotronService> services = data.getData();\n+            for (JablotronService service : services) {\n+                JablotronServiceDetail detail = service.getData();\n+                for (JablotronServiceDetailSegment segment : detail.getSegments()) {\n+                    if (segmentName.equals(segment.getSegmentId())) {\n+                        updateSegmentStatus(segment);\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    private void cleanup() {\n+        logger.debug(\"doing cleanup...\");\n+        if (future != null) {\n+            future.cancel(true);\n+        }\n+    }\n+\n+    protected State getCheckTime() {\n+        ZonedDateTime zdt = ZonedDateTime.ofInstant(Instant.now(), ZoneId.systemDefault());\n+        return new DateTimeType(zdt);\n+    }\n+\n+    protected synchronized @Nullable JablotronDataUpdateResponse sendGetStatusRequest() {\n+        JablotronBridgeHandler handler = getBridgeHandler();\n+        if (handler != null) {\n+            return handler.sendGetStatusRequest(getThing());\n+        }\n+        return null;\n+    }\n+\n+    protected synchronized boolean updateAlarmStatus() {\n+        JablotronDataUpdateResponse dataUpdate = sendGetStatusRequest();\n+        if (dataUpdate == null) {\n+            return false;\n+        }\n+\n+        if (dataUpdate.isStatus()) {\n+            updateState(CHANNEL_LAST_CHECK_TIME, getCheckTime());\n+            List<JablotronServiceData> serviceData = dataUpdate.getData().getServiceData();\n+            for (JablotronServiceData data : serviceData) {\n+                if (!thingConfig.getServiceId().equals(data.getServiceId())) {\n+                    continue;\n+                }\n+                List<JablotronService> services = data.getData();\n+                for (JablotronService service : services) {\n+                    JablotronServiceDetail detail = service.getData();\n+                    for (JablotronServiceDetailSegment segment : detail.getSegments()) {\n+                        updateSegmentStatus(segment);\n+                    }\n+                }\n+\n+            }\n+        } else {\n+            logger.debug(\"Error during alarm status update: {}\", dataUpdate.getErrorMessage());\n+        }\n+\n+        List<JablotronHistoryDataEvent> events = sendGetEventHistory();\n+        if (events != null && events.size() > 0) {\n+            JablotronHistoryDataEvent event = events.get(0);\n+            updateLastEvent(event);\n+        }\n+\n+        return true;\n+    }\n+\n+    protected @Nullable List<JablotronHistoryDataEvent> sendGetEventHistory() {\n+        return sendGetEventHistory(alarmName);\n+    }\n+\n+    private @Nullable List<JablotronHistoryDataEvent> sendGetEventHistory(String alarm) {\n+        JablotronBridgeHandler handler = getBridgeHandler();\n+        if (handler != null) {\n+            return handler.sendGetEventHistory(getThing(), alarm);\n+        }\n+        return null;\n+    }\n+\n+    protected void updateLastEvent(JablotronHistoryDataEvent event) {\n+        updateState(CHANNEL_LAST_EVENT_TIME, new DateTimeType(getZonedDateTime(event.getDate())));\n+        updateState(CHANNEL_LAST_EVENT, new StringType(event.getEventText()));\n+        updateState(CHANNEL_LAST_EVENT_CLASS, new StringType(event.getIconType()));\n+        updateState(CHANNEL_LAST_EVENT_INVOKER, new StringType(event.getInvokerName()));\n+\n+        // oasis does not have sections\n+        if (getThing().getChannel(CHANNEL_LAST_EVENT_SECTION) != null) {\n+            updateState(CHANNEL_LAST_EVENT_SECTION, new StringType(event.getSectionName()));\n+        }\n+    }\n+\n+    protected void updateEventChannel(String channel) {\n+        List<JablotronHistoryDataEvent> events = eventCache != null ? eventCache.getValue() : null;\n+        if (events != null && events.size() > 0) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bb824dab23246fe665151e79780dc81f6fe4928f"}, "originalPosition": 205}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzM5MDQ2Ng==", "bodyText": "channel cannot be null at this point.", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r487390466", "createdAt": "2020-09-12T09:30:52Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.jablotron/src/main/java/org/openhab/binding/jablotron/internal/handler/JablotronJa100Handler.java", "diffHunk": "@@ -0,0 +1,226 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.jablotron.internal.handler;\n+\n+import static org.openhab.binding.jablotron.JablotronBindingConstants.CACHE_TIMEOUT_MS;\n+import static org.openhab.binding.jablotron.JablotronBindingConstants.CHANNEL_LAST_CHECK_TIME;\n+\n+import java.util.List;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.smarthome.core.cache.ExpiringCache;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.binding.builder.ChannelBuilder;\n+import org.eclipse.smarthome.core.thing.binding.builder.ThingBuilder;\n+import org.eclipse.smarthome.core.thing.type.ChannelTypeUID;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.jablotron.internal.model.JablotronControlResponse;\n+import org.openhab.binding.jablotron.internal.model.JablotronServiceDetailSegment;\n+import org.openhab.binding.jablotron.internal.model.JablotronServiceDetailSegmentInfo;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link JablotronJa100Handler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Ondrej Pecta - Initial contribution\n+ */\n+@NonNullByDefault\n+public class JablotronJa100Handler extends JablotronAlarmHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(JablotronJa100Handler.class);\n+\n+    public JablotronJa100Handler(Thing thing, String alarmName) {\n+        super(thing, alarmName);\n+        dataCache = new ExpiringCache<>(CACHE_TIMEOUT_MS, this::sendGetStatusRequest);\n+        eventCache = new ExpiringCache<>(CACHE_TIMEOUT_MS, this::sendGetEventHistory);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (RefreshType.REFRESH.equals(command)) {\n+            logger.debug(\"refreshing channel: {}\", channelUID.getId());\n+            updateChannel(channelUID.getId());\n+        } else {\n+            if (channelUID.getId().startsWith(\"STATE_\") && command instanceof StringType) {\n+                scheduler.execute(() -> {\n+                    controlSTATESection(channelUID.getId(), command.toString());\n+                });\n+            }\n+\n+            if (channelUID.getId().startsWith(\"PGM_\") && command instanceof OnOffType) {\n+                scheduler.execute(() -> {\n+                    controlPGMSection(channelUID.getId(), command.equals(OnOffType.ON) ? \"set\" : \"unset\");\n+                });\n+            }\n+        }\n+    }\n+\n+    private void updateChannel(String channel) {\n+        if (channel.startsWith(\"STATE_\") || channel.startsWith(\"PGM_\") || channel.startsWith(\"THERMOMETER_\")\n+                || channel.startsWith(\"THERMOSTAT_\")) {\n+            updateSegmentStatus(channel, dataCache.getValue());\n+        } else if (CHANNEL_LAST_CHECK_TIME.equals(channel)) {\n+            // not updating\n+        } else {\n+            updateEventChannel(channel);\n+        }\n+    }\n+\n+    private void createChannel(JablotronServiceDetailSegment section) {\n+        if (section.getSegmentId().startsWith(\"PGM_\")) {\n+            createPGMChannel(section.getSegmentId(), section.getSegmentName());\n+        } else {\n+            createStateChannel(section.getSegmentId(), section.getSegmentName());\n+        }\n+    }\n+\n+    private void createTempChannel(String name, String label) {\n+        ChannelTypeUID temperature = new ChannelTypeUID(\"jablotron\", \"temperature\");\n+        ThingBuilder thingBuilder = editThing();\n+        Channel channel = ChannelBuilder.create(new ChannelUID(thing.getUID(), name), \"Number:Temperature\")\n+                .withLabel(label).withType(temperature).build();\n+        thingBuilder.withChannel(channel);\n+        updateThing(thingBuilder.build());\n+    }\n+\n+    private void createThermostatChannel(String name, String label) {\n+        ChannelTypeUID temperature = new ChannelTypeUID(\"jablotron\", \"thermostat\");\n+        ThingBuilder thingBuilder = editThing();\n+        Channel channel = ChannelBuilder.create(new ChannelUID(thing.getUID(), name), \"Number:Temperature\")\n+                .withLabel(label).withType(temperature).build();\n+        thingBuilder.withChannel(channel);\n+        updateThing(thingBuilder.build());\n+    }\n+\n+    private void createPGMChannel(String name, String label) {\n+        ThingBuilder thingBuilder = editThing();\n+        Channel channel = ChannelBuilder.create(new ChannelUID(thing.getUID(), name), \"Switch\").withLabel(label)\n+                .build();\n+        thingBuilder.withChannel(channel);\n+        updateThing(thingBuilder.build());\n+    }\n+\n+    private void createStateChannel(String name, String label) {\n+        ChannelTypeUID alarmStatus = new ChannelTypeUID(\"jablotron\", \"alarm_state\");\n+        ThingBuilder thingBuilder = editThing();\n+        Channel channel = ChannelBuilder.create(new ChannelUID(thing.getUID(), name), \"String\").withLabel(label)\n+                .withType(alarmStatus).build();\n+        thingBuilder.withChannel(channel);\n+        updateThing(thingBuilder.build());\n+    }\n+\n+    @Override\n+    protected void updateSegmentStatus(JablotronServiceDetailSegment segment) {\n+        logger.debug(\"Segment id: {} and status: {}\", segment.getSegmentId(), segment.getSegmentState());\n+        String segmentId = segment.getSegmentId();\n+\n+        if (segmentId.startsWith(\"STATE_\") || segmentId.startsWith(\"PGM_\")) {\n+            processSection(segment);\n+        } else if (segmentId.startsWith(\"THERMOMETER_\")) {\n+            processThermometer(segment);\n+        } else if (segmentId.startsWith(\"THERMOSTAT_\")) {\n+            processThermostat(segment);\n+        } else {\n+            logger.debug(\"Unknown segment received: {} with state: {}\", segment.getSegmentId(),\n+                    segment.getSegmentState());\n+        }\n+    }\n+\n+    private void processSection(JablotronServiceDetailSegment segment) {\n+        String segmentId = segment.getSegmentId();\n+        Channel channel = getThing().getChannel(segmentId);\n+        if (channel == null) {\n+            logger.debug(\"Creating a new channel: {}\", segmentId);\n+            createChannel(segment);\n+        }\n+        channel = getThing().getChannel(segmentId);\n+        if (channel != null) {\n+            logger.debug(\"Updating channel: {} to value: {}\", channel.getUID(), segment.getSegmentState());\n+            State newState;\n+            if (segmentId.startsWith(\"PGM_\")) {\n+                newState = \"unset\".equals(segment.getSegmentState()) ? OnOffType.OFF : OnOffType.ON;\n+            } else {\n+                newState = new StringType(segment.getSegmentState());\n+            }\n+            updateState(channel.getUID(), newState);\n+        } else {\n+            logger.debug(\"The channel: {} still doesn't exist!\", segmentId);\n+        }\n+    }\n+\n+    private void processThermometer(JablotronServiceDetailSegment segment) {\n+        String segmentId = segment.getSegmentId();\n+        Channel channel = getThing().getChannel(segmentId);\n+        if (channel == null) {\n+            logger.debug(\"Creating a new temperature channel: {}\", segmentId);\n+            createTempChannel(segmentId, segment.getSegmentName());\n+        }\n+        updateTemperatureChannel(channel, segment);\n+    }\n+\n+    private void processThermostat(JablotronServiceDetailSegment segment) {\n+        String segmentId = segment.getSegmentId();\n+        Channel channel = getThing().getChannel(segmentId);\n+        if (channel == null) {\n+            logger.debug(\"Creating a new thermostat channel: {}\", segmentId);\n+            createThermostatChannel(segmentId, segment.getSegmentName());\n+        }\n+        updateTemperatureChannel(channel, segment);\n+    }\n+\n+    private void updateTemperatureChannel(Channel channel, JablotronServiceDetailSegment segment) {\n+        String segmentId = segment.getSegmentId();\n+        if (channel != null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bb824dab23246fe665151e79780dc81f6fe4928f"}, "originalPosition": 192}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzM5MDU2MQ==", "bodyText": "Ok", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r487390561", "createdAt": "2020-09-12T09:32:05Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.jablotron/README.md", "diffHunk": "@@ -0,0 +1,120 @@\n+# Jablotron Alarm Binding\n+\n+This is the binding for Jablotron alarms.\n+https://www.jablotron.com/en/jablotron-products/alarms/\n+\n+## Supported Things\n+\n+| thing   | note                                      |\n+|---------|-------------------------------------------|\n+| bridge  | the bridge to your Jablonet cloud account |\n+| JA-80   | the OASIS alarm                           |\n+| JA-100  | with the thermometer support              |\n+| JA-100F | without the thermometer support           |\n+ \n+## Discovery\n+\n+This binding supports auto discovery. Just manually add a bridge thing and supply login & password to your Jablonet account.\n+\n+## Binding Configuration\n+\n+Binding itself doesn't require specific configuration.\n+\n+## Thing Configuration\n+\n+| thing                | config parameter name | description                                                                        | type                  |\n+|----------------------|-----------------------|------------------------------------------------------------------------------------|-----------------------|\n+| bridge               | login                 | the login to your Jablonet account                                                 | mandatory             |\n+| bridge               | password              | the password to your Jablonet account                                              | mandatory             |\n+| bridge               | refresh               | the refresh time for all alarm warnings (ALARM, TAMPER triggers and SERVICE state) | optional, default=30s |\n+| bridge               | lang                  | the language of the alarm texts                                                    | optional, default=en  |\n+| JA-80/JA-100/JA-100F | refresh               | the channels refresh period in seconds                                             | optional, default=60s |\n+| JA-80/JA-100/JA-100F | serviceId             | the service ID which identifies the alarm                                          | mandatory             |\n+| JA-100/JA-100F       | code                  | the master code for controlling sections                                           | optional              |\n+\n+## Channels\n+\n+| thing                | channel name     | description                                               |\n+|----------------------|------------------|-----------------------------------------------------------|\n+| bridge               | N/A              | the bridge does not expose any channels                   |\n+| JA-80                | statusA          | the status of the A section                               |\n+| JA-80                | statusB          | the status of the AB/B section                            |\n+| JA-80                | statusABC        | the status of the ABC section                             |\n+| JA-80                | statusPGX        | the status of PGX                                         |\n+| JA-80                | statusPGY        | the status of PGY                                         |\n+| JA-80                | command          | the channel for sending keyboard codes to the OASIS alarm |", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjYwOTQyMA=="}, "originalCommit": {"oid": "a590e81e68f4bb50a74b76dce0635a7906ca04ab"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzM5MDc1NQ==", "bodyText": "Sorry, I overlooked, that the Item Type column is missing. That could replace the footnote partially.", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r487390755", "createdAt": "2020-09-12T09:34:36Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.jablotron/README.md", "diffHunk": "@@ -0,0 +1,126 @@\n+# Jablotron Alarm Binding\n+\n+This is the binding for Jablotron alarms.\n+https://www.jablotron.com/en/jablotron-products/alarms/\n+\n+## Supported Things\n+\n+| thing   | note                                      |\n+|---------|-------------------------------------------|\n+| bridge  | the bridge to your Jablonet cloud account |\n+| JA-80   | the OASIS alarm                           |\n+| JA-100  | with the thermometer support              |\n+| JA-100F | without the thermometer support           |\n+ \n+## Discovery\n+\n+This binding supports auto discovery. Just manually add a bridge thing and supply login & password to your Jablonet account.\n+\n+## Binding Configuration\n+\n+Binding itself doesn't require specific configuration.\n+\n+## Thing Configuration\n+\n+| thing                | config parameter name | description                                                                        | type                  |\n+|----------------------|-----------------------|------------------------------------------------------------------------------------|-----------------------|\n+| bridge               | login                 | the login to your Jablonet account                                                 | mandatory             |\n+| bridge               | password              | the password to your Jablonet account                                              | mandatory             |\n+| bridge               | refresh               | the refresh time for all alarm warnings (ALARM, TAMPER triggers and SERVICE state) | optional, default=30s |\n+| bridge               | lang                  | the language of the alarm texts                                                    | optional, default=en  |\n+| JA-80/JA-100/JA-100F | refresh               | the channels refresh period in seconds                                             | optional, default=60s |\n+| JA-80/JA-100/JA-100F | serviceId             | the service ID which identifies the alarm                                          | mandatory             |\n+| JA-100/JA-100F       | code                  | the master code for controlling sections                                           | optional              |\n+\n+## Channels\n+\n+| thing                | channel name     | description                                               |", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bb824dab23246fe665151e79780dc81f6fe4928f"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzM5MDg2Nw==", "bodyText": "Although these are special, as they are dynamically created, they should be camelCase, too.", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r487390867", "createdAt": "2020-09-12T09:35:48Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.jablotron/README.md", "diffHunk": "@@ -0,0 +1,126 @@\n+# Jablotron Alarm Binding\n+\n+This is the binding for Jablotron alarms.\n+https://www.jablotron.com/en/jablotron-products/alarms/\n+\n+## Supported Things\n+\n+| thing   | note                                      |\n+|---------|-------------------------------------------|\n+| bridge  | the bridge to your Jablonet cloud account |\n+| JA-80   | the OASIS alarm                           |\n+| JA-100  | with the thermometer support              |\n+| JA-100F | without the thermometer support           |\n+ \n+## Discovery\n+\n+This binding supports auto discovery. Just manually add a bridge thing and supply login & password to your Jablonet account.\n+\n+## Binding Configuration\n+\n+Binding itself doesn't require specific configuration.\n+\n+## Thing Configuration\n+\n+| thing                | config parameter name | description                                                                        | type                  |\n+|----------------------|-----------------------|------------------------------------------------------------------------------------|-----------------------|\n+| bridge               | login                 | the login to your Jablonet account                                                 | mandatory             |\n+| bridge               | password              | the password to your Jablonet account                                              | mandatory             |\n+| bridge               | refresh               | the refresh time for all alarm warnings (ALARM, TAMPER triggers and SERVICE state) | optional, default=30s |\n+| bridge               | lang                  | the language of the alarm texts                                                    | optional, default=en  |\n+| JA-80/JA-100/JA-100F | refresh               | the channels refresh period in seconds                                             | optional, default=60s |\n+| JA-80/JA-100/JA-100F | serviceId             | the service ID which identifies the alarm                                          | mandatory             |\n+| JA-100/JA-100F       | code                  | the master code for controlling sections                                           | optional              |\n+\n+## Channels\n+\n+| thing                | channel name     | description                                               |\n+|----------------------|------------------|-----------------------------------------------------------|\n+| bridge               | N/A              | the bridge does not expose any channels                   |\n+| JA-80                | statusA          | the status of the A section                               |\n+| JA-80                | statusB          | the status of the AB/B section                            |\n+| JA-80                | statusABC        | the status of the ABC section                             |\n+| JA-80                | statusPGX        | the status of PGX                                         |\n+| JA-80                | statusPGY        | the status of PGY                                         |\n+| JA-80                | command          | the channel for sending keyboard codes to the OASIS alarm |\n+| JA-80/JA-100/JA-100F | lastEvent        | the text description of the last event                    |\n+| JA-80/JA-100/JA-100F | lastEventClass   | the class of the last event - e.g. arm, disarm, ...       |\n+| JA-80/JA-100/JA-100F | lastEventInvoker | the invoker of the last event                             |\n+| JA-80/JA-100/JA-100F | lastEventTime    | the time of the last event                                |\n+| JA-80/JA-100/JA-100F | lastCheckTime    | the time of the last checking                             |\n+| JA-80/JA-100/JA-100F | alarm            | the alarm trigger, might fire ALARM or TAMPER events      |\n+| JA-100/JA-100F       | lastEventSection | the section of the last event                             |\n+| JA-100               | STATE_%nr%       | the section %nr% status/control                           |\n+| JA-100               | PGM_%nr%         | the PG section %nr% status/control                        |\n+| JA-100               | THERMOMETER_%nr% | the thermometer %nr% value                                |\n+| JA-100               | THERMOSTAT_%nr%  | the thermostat %nr% value                                 |\n+| JA-100F              | SEC-%nr%         | the section %nr% status/control                           |\n+| JA-100F              | PG-%nr%          | the PG section %nr% status/control                        |", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bb824dab23246fe665151e79780dc81f6fe4928f"}, "originalPosition": 58}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzM5MTcxMg==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            @Component(service = ThingHandlerFactory.class)\n          \n          \n            \n            @Component(configurationPid = \"binding.jablotron\", service = ThingHandlerFactory.class)", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r487391712", "createdAt": "2020-09-12T09:45:52Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.jablotron/src/main/java/org/openhab/binding/jablotron/internal/JablotronHandlerFactory.java", "diffHunk": "@@ -0,0 +1,71 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.jablotron.internal;\n+\n+import static org.openhab.binding.jablotron.JablotronBindingConstants.*;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandlerFactory;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerFactory;\n+import org.eclipse.smarthome.io.net.http.HttpClientFactory;\n+import org.openhab.binding.jablotron.internal.handler.JablotronBridgeHandler;\n+import org.openhab.binding.jablotron.internal.handler.JablotronJa100FHandler;\n+import org.openhab.binding.jablotron.internal.handler.JablotronJa100Handler;\n+import org.openhab.binding.jablotron.internal.handler.JablotronOasisHandler;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Reference;\n+\n+/**\n+ * The {@link JablotronHandlerFactory} is responsible for creating things and thing\n+ * handlers.\n+ *\n+ * @author Ondrej Pecta - Initial contribution\n+ */\n+@NonNullByDefault\n+@Component(service = ThingHandlerFactory.class)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bb824dab23246fe665151e79780dc81f6fe4928f"}, "originalPosition": 41}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzM5MjI3NA==", "bodyText": "Is is a retry code?", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r487392274", "createdAt": "2020-09-12T09:52:44Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.jablotron/src/main/java/org/openhab/binding/jablotron/internal/handler/JablotronAlarmHandler.java", "diffHunk": "@@ -0,0 +1,268 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.jablotron.internal.handler;\n+\n+import static org.openhab.binding.jablotron.JablotronBindingConstants.*;\n+\n+import java.time.Instant;\n+import java.time.ZoneId;\n+import java.time.ZonedDateTime;\n+import java.time.format.DateTimeFormatter;\n+import java.util.List;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.cache.ExpiringCache;\n+import org.eclipse.smarthome.core.library.types.DateTimeType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.*;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.jablotron.internal.config.JablotronDeviceConfig;\n+import org.openhab.binding.jablotron.internal.model.*;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+\n+/**\n+ * The {@link JablotronAlarmHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Ondrej Pecta - Initial contribution\n+ */\n+@NonNullByDefault\n+public abstract class JablotronAlarmHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(getClass());\n+\n+    protected final Gson gson = new Gson();\n+\n+    protected JablotronDeviceConfig thingConfig = new JablotronDeviceConfig();\n+\n+    private String lastWarningTime = \"\";\n+\n+    protected String alarmName = \"\";\n+\n+    private boolean inService = false;\n+\n+    protected @Nullable ScheduledFuture<?> future = null;\n+\n+    protected @Nullable ExpiringCache<JablotronDataUpdateResponse> dataCache;\n+    protected @Nullable ExpiringCache<List<JablotronHistoryDataEvent>> eventCache;\n+\n+    public JablotronAlarmHandler(Thing thing, String alarmName) {\n+        super(thing);\n+        this.alarmName = alarmName;\n+    }\n+\n+    @Override\n+    public void bridgeStatusChanged(ThingStatusInfo bridgeStatusInfo) {\n+        super.bridgeStatusChanged(bridgeStatusInfo);\n+        if (ThingStatus.UNINITIALIZED == bridgeStatusInfo.getStatus()) {\n+            cleanup();\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        super.dispose();\n+        cleanup();\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        thingConfig = getConfigAs(JablotronDeviceConfig.class);\n+        future = scheduler.scheduleWithFixedDelay(this::updateAlarmStatus, 1, thingConfig.getRefresh(),\n+                TimeUnit.SECONDS);\n+        updateStatus(ThingStatus.ONLINE);\n+    }\n+\n+    public boolean isInService() {\n+        return inService;\n+    }\n+\n+    public String getAlarmName() {\n+        return alarmName;\n+    }\n+\n+    protected abstract void updateSegmentStatus(JablotronServiceDetailSegment segment);\n+\n+    protected void updateSegmentStatus(String segmentName, @Nullable JablotronDataUpdateResponse dataUpdate) {\n+        if (dataUpdate == null || !dataUpdate.isStatus()) {\n+            return;\n+        }\n+        List<JablotronServiceData> serviceData = dataUpdate.getData().getServiceData();\n+        for (JablotronServiceData data : serviceData) {\n+            if (!thingConfig.getServiceId().equals(data.getServiceId())) {\n+                continue;\n+            }\n+            List<JablotronService> services = data.getData();\n+            for (JablotronService service : services) {\n+                JablotronServiceDetail detail = service.getData();\n+                for (JablotronServiceDetailSegment segment : detail.getSegments()) {\n+                    if (segmentName.equals(segment.getSegmentId())) {\n+                        updateSegmentStatus(segment);\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    private void cleanup() {\n+        logger.debug(\"doing cleanup...\");\n+        if (future != null) {\n+            future.cancel(true);\n+        }\n+    }\n+\n+    protected State getCheckTime() {\n+        ZonedDateTime zdt = ZonedDateTime.ofInstant(Instant.now(), ZoneId.systemDefault());\n+        return new DateTimeType(zdt);\n+    }\n+\n+    protected synchronized @Nullable JablotronDataUpdateResponse sendGetStatusRequest() {\n+        JablotronBridgeHandler handler = getBridgeHandler();\n+        if (handler != null) {\n+            return handler.sendGetStatusRequest(getThing());\n+        }\n+        return null;\n+    }\n+\n+    protected synchronized boolean updateAlarmStatus() {\n+        JablotronDataUpdateResponse dataUpdate = sendGetStatusRequest();\n+        if (dataUpdate == null) {\n+            return false;\n+        }\n+\n+        if (dataUpdate.isStatus()) {\n+            updateState(CHANNEL_LAST_CHECK_TIME, getCheckTime());\n+            List<JablotronServiceData> serviceData = dataUpdate.getData().getServiceData();\n+            for (JablotronServiceData data : serviceData) {\n+                if (!thingConfig.getServiceId().equals(data.getServiceId())) {\n+                    continue;\n+                }\n+                List<JablotronService> services = data.getData();\n+                for (JablotronService service : services) {\n+                    JablotronServiceDetail detail = service.getData();\n+                    for (JablotronServiceDetailSegment segment : detail.getSegments()) {\n+                        updateSegmentStatus(segment);\n+                    }\n+                }\n+\n+            }\n+        } else {\n+            logger.debug(\"Error during alarm status update: {}\", dataUpdate.getErrorMessage());\n+        }\n+\n+        List<JablotronHistoryDataEvent> events = sendGetEventHistory();\n+        if (events != null && events.size() > 0) {\n+            JablotronHistoryDataEvent event = events.get(0);\n+            updateLastEvent(event);\n+        }\n+\n+        return true;\n+    }\n+\n+    protected @Nullable List<JablotronHistoryDataEvent> sendGetEventHistory() {\n+        return sendGetEventHistory(alarmName);\n+    }\n+\n+    private @Nullable List<JablotronHistoryDataEvent> sendGetEventHistory(String alarm) {\n+        JablotronBridgeHandler handler = getBridgeHandler();\n+        if (handler != null) {\n+            return handler.sendGetEventHistory(getThing(), alarm);\n+        }\n+        return null;\n+    }\n+\n+    protected void updateLastEvent(JablotronHistoryDataEvent event) {\n+        updateState(CHANNEL_LAST_EVENT_TIME, new DateTimeType(getZonedDateTime(event.getDate())));\n+        updateState(CHANNEL_LAST_EVENT, new StringType(event.getEventText()));\n+        updateState(CHANNEL_LAST_EVENT_CLASS, new StringType(event.getIconType()));\n+        updateState(CHANNEL_LAST_EVENT_INVOKER, new StringType(event.getInvokerName()));\n+\n+        // oasis does not have sections\n+        if (getThing().getChannel(CHANNEL_LAST_EVENT_SECTION) != null) {\n+            updateState(CHANNEL_LAST_EVENT_SECTION, new StringType(event.getSectionName()));\n+        }\n+    }\n+\n+    protected void updateEventChannel(String channel) {\n+        List<JablotronHistoryDataEvent> events = eventCache != null ? eventCache.getValue() : null;\n+        if (events != null && events.size() > 0) {\n+            JablotronHistoryDataEvent event = events.get(0);\n+            switch (channel) {\n+                case CHANNEL_LAST_EVENT_TIME:\n+                    updateState(CHANNEL_LAST_EVENT_TIME, new DateTimeType(getZonedDateTime(event.getDate())));\n+                    break;\n+                case CHANNEL_LAST_EVENT:\n+                    updateState(CHANNEL_LAST_EVENT, new StringType(event.getEventText()));\n+                    break;\n+                case CHANNEL_LAST_EVENT_CLASS:\n+                    updateState(CHANNEL_LAST_EVENT_CLASS, new StringType(event.getIconType()));\n+                    break;\n+                case CHANNEL_LAST_EVENT_INVOKER:\n+                    updateState(CHANNEL_LAST_EVENT_INVOKER, new StringType(event.getInvokerName()));\n+                    break;\n+                case CHANNEL_LAST_EVENT_SECTION:\n+                    updateState(CHANNEL_LAST_EVENT_SECTION, new StringType(event.getSectionName()));\n+                    break;\n+            }\n+        }\n+    }\n+\n+    public ZonedDateTime getZonedDateTime(String date) {\n+        return ZonedDateTime.parse(date.substring(0, 22) + \":\" + date.substring(22, 24),\n+                DateTimeFormatter.ISO_DATE_TIME);\n+    }\n+\n+    protected @Nullable JablotronControlResponse sendUserCode(String section, String key, String status, String code) {\n+        JablotronControlResponse response = null;\n+        JablotronBridgeHandler handler = getBridgeHandler();\n+        if (handler != null) {\n+            try {\n+                response = handler.sendUserCode(getThing(), section, key, status, code);\n+            } catch (SecurityException se) {\n+                response = handler.sendUserCode(getThing(), section, key, status, code);\n+            }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bb824dab23246fe665151e79780dc81f6fe4928f"}, "originalPosition": 240}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzM5MjMzOA==", "bodyText": "You're right, sorry.", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r487392338", "createdAt": "2020-09-12T09:53:38Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.jablotron/src/main/java/org/openhab/binding/jablotron/internal/handler/JablotronBridgeHandler.java", "diffHunk": "@@ -0,0 +1,385 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.jablotron.internal.handler;\n+\n+import static org.openhab.binding.jablotron.JablotronBindingConstants.*;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.eclipse.jetty.http.HttpHeader;\n+import org.eclipse.jetty.http.HttpMethod;\n+import org.eclipse.smarthome.core.thing.*;\n+import org.eclipse.smarthome.core.thing.binding.BaseBridgeHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.openhab.binding.jablotron.internal.config.JablotronBridgeConfig;\n+import org.openhab.binding.jablotron.internal.discovery.JablotronDiscoveryService;\n+import org.openhab.binding.jablotron.internal.model.*;\n+import org.openhab.binding.jablotron.internal.model.ja100f.JablotronGetPGResponse;\n+import org.openhab.binding.jablotron.internal.model.ja100f.JablotronGetSectionsResponse;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.JsonSyntaxException;\n+\n+/**\n+ * The {@link JablotronBridgeHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Ondrej Pecta - Initial contribution\n+ */\n+@NonNullByDefault\n+public class JablotronBridgeHandler extends BaseBridgeHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(JablotronBridgeHandler.class);\n+\n+    private final Gson gson = new Gson();\n+\n+    final HttpClient httpClient;\n+\n+    @Nullable\n+    ScheduledFuture<?> future = null;\n+\n+    /**\n+     * Our configuration\n+     */\n+    public JablotronBridgeConfig bridgeConfig = new JablotronBridgeConfig();\n+\n+    public JablotronBridgeHandler(Bridge thing, HttpClient httpClient) {\n+        super(thing);\n+        this.httpClient = httpClient;\n+    }\n+\n+    @Override\n+    public Collection<Class<? extends ThingHandlerService>> getServices() {\n+        return Collections.singleton(JablotronDiscoveryService.class);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        bridgeConfig = getConfigAs(JablotronBridgeConfig.class);\n+        scheduler.execute(this::login);\n+        future = scheduler.scheduleWithFixedDelay(this::updateAlarmThings, 30, bridgeConfig.getRefresh(),\n+                TimeUnit.SECONDS);\n+    }\n+\n+    private void updateAlarmThings() {\n+        @Nullable\n+        List<JablotronDiscoveredService> services = discoverServices();\n+        if (services != null) {\n+            for (JablotronDiscoveredService service : services) {\n+                updateAlarmThing(service);\n+            }\n+        }\n+    }\n+\n+    private void updateAlarmThing(JablotronDiscoveredService service) {\n+        for (Thing th : getThing().getThings()) {\n+            @Nullable\n+            JablotronAlarmHandler handler = (JablotronAlarmHandler) th.getHandler();\n+\n+            if (handler == null) {\n+                logger.debug(\"Thing handler is null\");\n+                continue;\n+            }\n+\n+            if (String.valueOf(service.getId()).equals(handler.thingConfig.getServiceId())) {\n+                if (\"ENABLED\".equals(service.getStatus())) {\n+                    if (!\"\".equals(service.getWarning())) {\n+                        logger.debug(\"Alarm with service id: {} warning: {}\", service.getId(), service.getWarning());\n+                    }\n+                    handler.setStatus(ThingStatus.ONLINE, ThingStatusDetail.NONE, service.getWarning());\n+                    if (\"ALARM\".equals(service.getWarning()) || \"TAMPER\".equals(service.getWarning())) {\n+                        handler.triggerAlarm(service);\n+                    }\n+                    handler.setInService(\"SERVICE\".equals(service.getWarning()));\n+                } else {\n+                    logger.debug(\"Alarm with service id: {} is offline\", service.getId());\n+                    handler.setStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, service.getStatus());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjU5NDk0Mg=="}, "originalCommit": {"oid": "a590e81e68f4bb50a74b76dce0635a7906ca04ab"}, "originalPosition": 125}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzM5MjQyMQ==", "bodyText": "But these are redundant.", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r487392421", "createdAt": "2020-09-12T09:54:37Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.jablotron/src/main/java/org/openhab/binding/jablotron/internal/handler/JablotronBridgeHandler.java", "diffHunk": "@@ -0,0 +1,370 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.jablotron.internal.handler;\n+\n+import static org.openhab.binding.jablotron.JablotronBindingConstants.*;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.eclipse.jetty.http.HttpHeader;\n+import org.eclipse.jetty.http.HttpMethod;\n+import org.eclipse.smarthome.core.thing.*;\n+import org.eclipse.smarthome.core.thing.binding.BaseBridgeHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.openhab.binding.jablotron.internal.config.JablotronBridgeConfig;\n+import org.openhab.binding.jablotron.internal.discovery.JablotronDiscoveryService;\n+import org.openhab.binding.jablotron.internal.model.*;\n+import org.openhab.binding.jablotron.internal.model.ja100f.JablotronGetPGResponse;\n+import org.openhab.binding.jablotron.internal.model.ja100f.JablotronGetSectionsResponse;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.JsonSyntaxException;\n+\n+/**\n+ * The {@link JablotronBridgeHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Ondrej Pecta - Initial contribution\n+ */\n+@NonNullByDefault\n+public class JablotronBridgeHandler extends BaseBridgeHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(JablotronBridgeHandler.class);\n+\n+    private final Gson gson = new Gson();\n+\n+    final HttpClient httpClient;\n+\n+    private @Nullable ScheduledFuture<?> future = null;\n+\n+    /**\n+     * Our configuration\n+     */\n+    public JablotronBridgeConfig bridgeConfig = new JablotronBridgeConfig();\n+\n+    public JablotronBridgeHandler(Bridge thing, HttpClient httpClient) {\n+        super(thing);\n+        this.httpClient = httpClient;\n+    }\n+\n+    @Override\n+    public Collection<Class<? extends ThingHandlerService>> getServices() {\n+        return Collections.singleton(JablotronDiscoveryService.class);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        bridgeConfig = getConfigAs(JablotronBridgeConfig.class);\n+        scheduler.execute(this::login);\n+        future = scheduler.scheduleWithFixedDelay(this::updateAlarmThings, 30, bridgeConfig.getRefresh(),\n+                TimeUnit.SECONDS);\n+    }\n+\n+    private void updateAlarmThings() {\n+        @Nullable\n+        List<JablotronDiscoveredService> services = discoverServices();\n+        if (services != null) {\n+            for (JablotronDiscoveredService service : services) {\n+                updateAlarmThing(service);\n+            }\n+        }\n+    }\n+\n+    private void updateAlarmThing(JablotronDiscoveredService service) {\n+        for (Thing th : getThing().getThings()) {\n+            JablotronAlarmHandler handler = (JablotronAlarmHandler) th.getHandler();\n+\n+            if (handler == null) {\n+                logger.debug(\"Thing handler is null\");\n+                continue;\n+            }\n+\n+            if (String.valueOf(service.getId()).equals(handler.thingConfig.getServiceId())) {\n+                if (\"ENABLED\".equals(service.getStatus())) {\n+                    if (!service.getWarning().isEmpty()) {\n+                        logger.debug(\"Alarm with service id: {} warning: {}\", service.getId(), service.getWarning());\n+                    }\n+                    handler.setStatus(ThingStatus.ONLINE, ThingStatusDetail.NONE, service.getWarning());\n+                    if (\"ALARM\".equals(service.getWarning()) || \"TAMPER\".equals(service.getWarning())) {\n+                        handler.triggerAlarm(service);\n+                    }\n+                    handler.setInService(\"SERVICE\".equals(service.getWarning()));\n+                } else {\n+                    logger.debug(\"Alarm with service id: {} is offline\", service.getId());\n+                    handler.setStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, service.getStatus());\n+                }\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        super.dispose();\n+        if (future != null) {\n+            future.cancel(true);\n+        }\n+        logout();\n+    }\n+\n+    private @Nullable <T> T sendJsonMessage(String url, String urlParameters, Class<T> classOfT) {\n+        return sendMessage(url, urlParameters, classOfT, APPLICATION_JSON, true);\n+    }\n+\n+    private @Nullable <T> T sendJsonMessage(String url, String urlParameters, Class<T> classOfT, boolean relogin) {\n+        return sendMessage(url, urlParameters, classOfT, APPLICATION_JSON, relogin);\n+    }\n+\n+    private @Nullable <T> T sendUrlEncodedMessage(String url, String urlParameters, Class<T> classOfT) {\n+        return sendMessage(url, urlParameters, classOfT, WWW_FORM_URLENCODED, true);\n+    }\n+\n+    private @Nullable <T> T sendMessage(String url, String urlParameters, Class<T> classOfT, String encoding,\n+            boolean relogin) {\n+        try {\n+            ContentResponse resp = createRequest(url).content(new StringContentProvider(urlParameters), encoding)\n+                    .send();\n+\n+            logger.trace(\"Request: {} with data: {}\", url, urlParameters);\n+            String line = resp.getContentAsString();\n+            logger.trace(\"Response: {}\", line);\n+            return gson.fromJson(line, classOfT);\n+        } catch (TimeoutException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                    \"Timeout during calling url: \" + url);\n+        } catch (InterruptedException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                    \"Interrupt during calling url: \" + url);\n+            Thread.currentThread().interrupt();\n+        } catch (JsonSyntaxException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                    \"Syntax error during calling url: \" + url);\n+        } catch (ExecutionException e) {\n+            if (relogin) {\n+                if (e.getMessage().contains(AUTHENTICATION_CHALLENGE)) {\n+                    relogin();\n+                    return null;\n+                }\n+            }\n+            logger.debug(\"Error during calling url: {}\", url, e);\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                    \"Error during calling url: \" + url);\n+        }\n+        return null;\n+    }\n+\n+    protected synchronized void login() {\n+        String url = JABLOTRON_API_URL + \"userAuthorize.json\";\n+        String urlParameters = \"{\\\"login\\\":\\\"\" + bridgeConfig.getLogin() + \"\\\", \\\"password\\\":\\\"\"\n+                + bridgeConfig.getPassword() + \"\\\"}\";\n+        JablotronLoginResponse response = sendJsonMessage(url, urlParameters, JablotronLoginResponse.class, false);\n+\n+        if (response == null) {\n+            return;\n+        }\n+\n+        if (response.getHttpCode() != 200) {\n+            logger.debug(\"Error during login, got http error: {}\", response.getHttpCode());\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                    \"Http error: \" + response.getHttpCode());\n+        } else {\n+            logger.debug(\"Successfully logged in\");\n+            updateStatus(ThingStatus.ONLINE);\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bb824dab23246fe665151e79780dc81f6fe4928f"}, "originalPosition": 201}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzM5MjU2NA==", "bodyText": "What is throwing a SecurityException here?", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r487392564", "createdAt": "2020-09-12T09:55:50Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.jablotron/src/main/java/org/openhab/binding/jablotron/internal/handler/JablotronBridgeHandler.java", "diffHunk": "@@ -0,0 +1,370 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.jablotron.internal.handler;\n+\n+import static org.openhab.binding.jablotron.JablotronBindingConstants.*;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.eclipse.jetty.http.HttpHeader;\n+import org.eclipse.jetty.http.HttpMethod;\n+import org.eclipse.smarthome.core.thing.*;\n+import org.eclipse.smarthome.core.thing.binding.BaseBridgeHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.openhab.binding.jablotron.internal.config.JablotronBridgeConfig;\n+import org.openhab.binding.jablotron.internal.discovery.JablotronDiscoveryService;\n+import org.openhab.binding.jablotron.internal.model.*;\n+import org.openhab.binding.jablotron.internal.model.ja100f.JablotronGetPGResponse;\n+import org.openhab.binding.jablotron.internal.model.ja100f.JablotronGetSectionsResponse;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.JsonSyntaxException;\n+\n+/**\n+ * The {@link JablotronBridgeHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Ondrej Pecta - Initial contribution\n+ */\n+@NonNullByDefault\n+public class JablotronBridgeHandler extends BaseBridgeHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(JablotronBridgeHandler.class);\n+\n+    private final Gson gson = new Gson();\n+\n+    final HttpClient httpClient;\n+\n+    private @Nullable ScheduledFuture<?> future = null;\n+\n+    /**\n+     * Our configuration\n+     */\n+    public JablotronBridgeConfig bridgeConfig = new JablotronBridgeConfig();\n+\n+    public JablotronBridgeHandler(Bridge thing, HttpClient httpClient) {\n+        super(thing);\n+        this.httpClient = httpClient;\n+    }\n+\n+    @Override\n+    public Collection<Class<? extends ThingHandlerService>> getServices() {\n+        return Collections.singleton(JablotronDiscoveryService.class);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        bridgeConfig = getConfigAs(JablotronBridgeConfig.class);\n+        scheduler.execute(this::login);\n+        future = scheduler.scheduleWithFixedDelay(this::updateAlarmThings, 30, bridgeConfig.getRefresh(),\n+                TimeUnit.SECONDS);\n+    }\n+\n+    private void updateAlarmThings() {\n+        @Nullable\n+        List<JablotronDiscoveredService> services = discoverServices();\n+        if (services != null) {\n+            for (JablotronDiscoveredService service : services) {\n+                updateAlarmThing(service);\n+            }\n+        }\n+    }\n+\n+    private void updateAlarmThing(JablotronDiscoveredService service) {\n+        for (Thing th : getThing().getThings()) {\n+            JablotronAlarmHandler handler = (JablotronAlarmHandler) th.getHandler();\n+\n+            if (handler == null) {\n+                logger.debug(\"Thing handler is null\");\n+                continue;\n+            }\n+\n+            if (String.valueOf(service.getId()).equals(handler.thingConfig.getServiceId())) {\n+                if (\"ENABLED\".equals(service.getStatus())) {\n+                    if (!service.getWarning().isEmpty()) {\n+                        logger.debug(\"Alarm with service id: {} warning: {}\", service.getId(), service.getWarning());\n+                    }\n+                    handler.setStatus(ThingStatus.ONLINE, ThingStatusDetail.NONE, service.getWarning());\n+                    if (\"ALARM\".equals(service.getWarning()) || \"TAMPER\".equals(service.getWarning())) {\n+                        handler.triggerAlarm(service);\n+                    }\n+                    handler.setInService(\"SERVICE\".equals(service.getWarning()));\n+                } else {\n+                    logger.debug(\"Alarm with service id: {} is offline\", service.getId());\n+                    handler.setStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, service.getStatus());\n+                }\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        super.dispose();\n+        if (future != null) {\n+            future.cancel(true);\n+        }\n+        logout();\n+    }\n+\n+    private @Nullable <T> T sendJsonMessage(String url, String urlParameters, Class<T> classOfT) {\n+        return sendMessage(url, urlParameters, classOfT, APPLICATION_JSON, true);\n+    }\n+\n+    private @Nullable <T> T sendJsonMessage(String url, String urlParameters, Class<T> classOfT, boolean relogin) {\n+        return sendMessage(url, urlParameters, classOfT, APPLICATION_JSON, relogin);\n+    }\n+\n+    private @Nullable <T> T sendUrlEncodedMessage(String url, String urlParameters, Class<T> classOfT) {\n+        return sendMessage(url, urlParameters, classOfT, WWW_FORM_URLENCODED, true);\n+    }\n+\n+    private @Nullable <T> T sendMessage(String url, String urlParameters, Class<T> classOfT, String encoding,\n+            boolean relogin) {\n+        try {\n+            ContentResponse resp = createRequest(url).content(new StringContentProvider(urlParameters), encoding)\n+                    .send();\n+\n+            logger.trace(\"Request: {} with data: {}\", url, urlParameters);\n+            String line = resp.getContentAsString();\n+            logger.trace(\"Response: {}\", line);\n+            return gson.fromJson(line, classOfT);\n+        } catch (TimeoutException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                    \"Timeout during calling url: \" + url);\n+        } catch (InterruptedException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                    \"Interrupt during calling url: \" + url);\n+            Thread.currentThread().interrupt();\n+        } catch (JsonSyntaxException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                    \"Syntax error during calling url: \" + url);\n+        } catch (ExecutionException e) {\n+            if (relogin) {\n+                if (e.getMessage().contains(AUTHENTICATION_CHALLENGE)) {\n+                    relogin();\n+                    return null;\n+                }\n+            }\n+            logger.debug(\"Error during calling url: {}\", url, e);\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                    \"Error during calling url: \" + url);\n+        }\n+        return null;\n+    }\n+\n+    protected synchronized void login() {\n+        String url = JABLOTRON_API_URL + \"userAuthorize.json\";\n+        String urlParameters = \"{\\\"login\\\":\\\"\" + bridgeConfig.getLogin() + \"\\\", \\\"password\\\":\\\"\"\n+                + bridgeConfig.getPassword() + \"\\\"}\";\n+        JablotronLoginResponse response = sendJsonMessage(url, urlParameters, JablotronLoginResponse.class, false);\n+\n+        if (response == null) {\n+            return;\n+        }\n+\n+        if (response.getHttpCode() != 200) {\n+            logger.debug(\"Error during login, got http error: {}\", response.getHttpCode());\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                    \"Http error: \" + response.getHttpCode());\n+        } else {\n+            logger.debug(\"Successfully logged in\");\n+            updateStatus(ThingStatus.ONLINE);\n+        }\n+    }\n+\n+    protected void logout() {\n+        String url = JABLOTRON_API_URL + \"logout.json\";\n+        String urlParameters = \"system=\" + SYSTEM;\n+\n+        try {\n+            ContentResponse resp = createRequest(url)\n+                    .content(new StringContentProvider(urlParameters), WWW_FORM_URLENCODED).send();\n+\n+            if (logger.isTraceEnabled()) {\n+                String line = resp.getContentAsString();\n+                logger.trace(\"logout response: {}\", line);\n+            }\n+        } catch (ExecutionException | TimeoutException | InterruptedException e) {\n+            // Silence\n+        }\n+    }\n+\n+    public @Nullable List<JablotronDiscoveredService> discoverServices() {\n+        String url = JABLOTRON_API_URL + \"serviceListGet.json\";\n+        String urlParameters = \"{\\\"list-type\\\": \\\"EXTENDED\\\",\\\"visibility\\\": \\\"VISIBLE\\\"}\";\n+        JablotronGetServiceResponse response = sendJsonMessage(url, urlParameters, JablotronGetServiceResponse.class);\n+\n+        if (response == null) {\n+            return null;\n+        }\n+\n+        if (response.getHttpCode() != 200) {\n+            logger.debug(\"Error during service discovery, got http code: {}\", response.getHttpCode());\n+        }\n+\n+        return response.getData().getServices();\n+    }\n+\n+    protected @Nullable JablotronControlResponse sendUserCode(Thing th, String section, String key, String status,\n+            String code) throws SecurityException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bb824dab23246fe665151e79780dc81f6fe4928f"}, "originalPosition": 238}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzM5MzE1Ng==", "bodyText": "Can you apply the min value and the unit to the other refresh parameters, too? Is 30 sec. a reasonable min value? Maybe the API gets faster some day?", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r487393156", "createdAt": "2020-09-12T10:03:24Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.jablotron/src/main/resources/ESH-INF/config/config.xml", "diffHunk": "@@ -0,0 +1,86 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<config-description:config-descriptions\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:config-description=\"https://openhab.org/schemas/config-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/config-description/v1.0.0 https://openhab.org/schemas/config-description-1.0.0.xsd\">\n+\n+\t<config-description uri=\"thing-type:jablotron:device\">\n+\t\t<parameter name=\"refresh\" type=\"integer\" required=\"false\" min=\"30\" unit=\"s\">", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bb824dab23246fe665151e79780dc81f6fe4928f"}, "originalPosition": 8}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a55fc34028923eec2bd5850ca43374dbc7816a1b", "author": {"user": {"login": "octa22", "name": "Ondrej Pecta"}}, "url": "https://github.com/openhab/openhab-addons/commit/a55fc34028923eec2bd5850ca43374dbc7816a1b", "committedDate": "2020-09-12T16:45:47Z", "message": "[jablotron] next bunch of improvements related to the code review\n\nSigned-off-by: Ondrej Pecta <opecta@gmail.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "eca0372bb87588985159d44723b68f90a7f0757e", "author": {"user": {"login": "octa22", "name": "Ondrej Pecta"}}, "url": "https://github.com/openhab/openhab-addons/commit/eca0372bb87588985159d44723b68f90a7f0757e", "committedDate": "2020-09-12T16:30:21Z", "message": "[jablotron] next bunch of improvements related to the code review\n\nSigned-off-by: Ondrej Pecta <opecta@gmail.com>"}, "afterCommit": {"oid": "a55fc34028923eec2bd5850ca43374dbc7816a1b", "author": {"user": {"login": "octa22", "name": "Ondrej Pecta"}}, "url": "https://github.com/openhab/openhab-addons/commit/a55fc34028923eec2bd5850ca43374dbc7816a1b", "committedDate": "2020-09-12T16:45:47Z", "message": "[jablotron] next bunch of improvements related to the code review\n\nSigned-off-by: Ondrej Pecta <opecta@gmail.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "90128a1b5cf768e406c9967cc47f5a4673ea81b1", "author": {"user": {"login": "octa22", "name": "Ondrej Pecta"}}, "url": "https://github.com/openhab/openhab-addons/commit/90128a1b5cf768e406c9967cc47f5a4673ea81b1", "committedDate": "2020-09-12T19:39:43Z", "message": "[jablotron] dynamic channel's names are now lowercase\n\nSigned-off-by: Ondrej Pecta <opecta@gmail.com>"}, "afterCommit": {"oid": "ef8689324beb15b05eb31b4c76011cdff64751f8", "author": {"user": {"login": "octa22", "name": "Ondrej Pecta"}}, "url": "https://github.com/openhab/openhab-addons/commit/ef8689324beb15b05eb31b4c76011cdff64751f8", "committedDate": "2020-09-12T20:07:45Z", "message": "[jablotron] dynamic channel's names are now lowercase\n\nSigned-off-by: Ondrej Pecta <opecta@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a24a1fd3e9b0b42b246535a2373bab007dbe3856", "author": {"user": {"login": "octa22", "name": "Ondrej Pecta"}}, "url": "https://github.com/openhab/openhab-addons/commit/a24a1fd3e9b0b42b246535a2373bab007dbe3856", "committedDate": "2020-09-13T10:54:42Z", "message": "[jablotron] dynamic channel's names are now lowercase\n\nSigned-off-by: Ondrej Pecta <opecta@gmail.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "ef8689324beb15b05eb31b4c76011cdff64751f8", "author": {"user": {"login": "octa22", "name": "Ondrej Pecta"}}, "url": "https://github.com/openhab/openhab-addons/commit/ef8689324beb15b05eb31b4c76011cdff64751f8", "committedDate": "2020-09-12T20:07:45Z", "message": "[jablotron] dynamic channel's names are now lowercase\n\nSigned-off-by: Ondrej Pecta <opecta@gmail.com>"}, "afterCommit": {"oid": "a24a1fd3e9b0b42b246535a2373bab007dbe3856", "author": {"user": {"login": "octa22", "name": "Ondrej Pecta"}}, "url": "https://github.com/openhab/openhab-addons/commit/a24a1fd3e9b0b42b246535a2373bab007dbe3856", "committedDate": "2020-09-13T10:54:42Z", "message": "[jablotron] dynamic channel's names are now lowercase\n\nSigned-off-by: Ondrej Pecta <opecta@gmail.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg3MzIzNzMz", "url": "https://github.com/openhab/openhab-addons/pull/6990#pullrequestreview-487323733", "createdAt": "2020-09-13T17:02:15Z", "commit": {"oid": "a24a1fd3e9b0b42b246535a2373bab007dbe3856"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xM1QxNzowMjoxNlrOHQ92zA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xM1QxNzoxNjozOFrOHQ98Bg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzU1MjcxNg==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            | JA-100               | thermometer_%nr% | Number    | the thermometer %nr% value                                |\n          \n          \n            \n            | JA-100               | thermostat_%nr%  | Number    | the thermostat %nr% value                                 |\n          \n          \n            \n            | JA-100               | thermometer_%nr% | Number:Temperature    | the thermometer %nr% value                                |\n          \n          \n            \n            | JA-100               | thermostat_%nr%  | Number:Temperature    | the thermostat %nr% value                                 |", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r487552716", "createdAt": "2020-09-13T17:02:16Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.jablotron/README.md", "diffHunk": "@@ -0,0 +1,125 @@\n+# Jablotron Alarm Binding\n+\n+This is the binding for Jablotron alarms.\n+https://www.jablotron.com/en/jablotron-products/alarms/\n+\n+## Supported Things\n+\n+| thing   | note                                      |\n+|---------|-------------------------------------------|\n+| bridge  | the bridge to your Jablonet cloud account |\n+| JA-80   | the OASIS alarm                           |\n+| JA-100  | with the thermometer support              |\n+| JA-100F | without the thermometer support           |\n+ \n+## Discovery\n+\n+This binding supports auto discovery. Just manually add a bridge thing and supply login & password to your Jablonet account.\n+\n+## Binding Configuration\n+\n+Binding itself doesn't require specific configuration.\n+\n+## Thing Configuration\n+\n+| thing                | config parameter name | description                                                                        | type                  |\n+|----------------------|-----------------------|------------------------------------------------------------------------------------|-----------------------|\n+| bridge               | login                 | the login to your Jablonet account                                                 | mandatory             |\n+| bridge               | password              | the password to your Jablonet account                                              | mandatory             |\n+| bridge               | refresh               | the refresh time for all alarm warnings (ALARM, TAMPER triggers and SERVICE state) | optional, default=30s |\n+| bridge               | lang                  | the language of the alarm texts                                                    | optional, default=en  |\n+| JA-80/JA-100/JA-100F | refresh               | the channels refresh period in seconds                                             | optional, default=60s |\n+| JA-80/JA-100/JA-100F | serviceId             | the service ID which identifies the alarm                                          | mandatory             |\n+| JA-100/JA-100F       | code                  | the master code for controlling sections                                           | optional              |\n+\n+## Channels\n+\n+| thing                | channel name     | item type | description                                               |\n+|----------------------|------------------|-----------|-----------------------------------------------------------|\n+| bridge               | N/A              | N/A       | the bridge does not expose any channels                   |\n+| JA-80                | statusA          | Switch    | the status of the A section                               |\n+| JA-80                | statusB          | Switch    | the status of the AB/B section                            |\n+| JA-80                | statusABC        | Switch    | the status of the ABC section                             |\n+| JA-80                | statusPGX        | Switch    | the status of PGX                                         |\n+| JA-80                | statusPGY        | Switch    | the status of PGY                                         |\n+| JA-80                | command          | String    | the channel for sending keyboard codes to the OASIS alarm |\n+| JA-80/JA-100/JA-100F | lastEvent        | String    | the description of the last event                         |\n+| JA-80/JA-100/JA-100F | lastEventClass   | String    | the class of the last event - e.g. arm, disarm, ...       |\n+| JA-80/JA-100/JA-100F | lastEventInvoker | String    | the invoker of the last event                             |\n+| JA-80/JA-100/JA-100F | lastEventTime    | DateTime  | the time of the last event                                |\n+| JA-80/JA-100/JA-100F | lastCheckTime    | DateTime  | the time of the last checking                             |\n+| JA-80/JA-100/JA-100F | alarm            | N/A       | the alarm trigger, might fire ALARM or TAMPER events      |\n+| JA-100/JA-100F       | lastEventSection | String    | the section of the last event                             |\n+| JA-100               | state_%nr%       | String    | the section %nr% status/control                           |\n+| JA-100               | pgm_%nr%         | Switch    | the PG switch %nr% status/control                        |\n+| JA-100               | thermometer_%nr% | Number    | the thermometer %nr% value                                |\n+| JA-100               | thermostat_%nr%  | Number    | the thermostat %nr% value                                 |", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a24a1fd3e9b0b42b246535a2373bab007dbe3856"}, "originalPosition": 56}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzU1MjgwNw==", "bodyText": "This needs to be of type QuantityType. Please pay attention to use import org.eclipse.smarthome.core.library.unit.SIUnits, as there is another class with the same name in a different package.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        DecimalType newState = new DecimalType(infos.get(0).getValue());\n          \n          \n            \n                        updateState(channel.getUID(), newState);\n          \n          \n            \n                        updateState(channel.getUID(), QuantityType.valueOf(infos.get(0).getValue(), SIUnits.CELSIUS));", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r487552807", "createdAt": "2020-09-13T17:03:28Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.jablotron/src/main/java/org/openhab/binding/jablotron/internal/handler/JablotronJa100Handler.java", "diffHunk": "@@ -0,0 +1,220 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.jablotron.internal.handler;\n+\n+import static org.openhab.binding.jablotron.JablotronBindingConstants.CACHE_TIMEOUT_MS;\n+import static org.openhab.binding.jablotron.JablotronBindingConstants.CHANNEL_LAST_CHECK_TIME;\n+\n+import java.util.List;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.smarthome.core.cache.ExpiringCache;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.binding.builder.ChannelBuilder;\n+import org.eclipse.smarthome.core.thing.binding.builder.ThingBuilder;\n+import org.eclipse.smarthome.core.thing.type.ChannelTypeUID;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.jablotron.internal.model.JablotronControlResponse;\n+import org.openhab.binding.jablotron.internal.model.JablotronServiceDetailSegment;\n+import org.openhab.binding.jablotron.internal.model.JablotronServiceDetailSegmentInfo;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link JablotronJa100Handler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Ondrej Pecta - Initial contribution\n+ */\n+@NonNullByDefault\n+public class JablotronJa100Handler extends JablotronAlarmHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(JablotronJa100Handler.class);\n+\n+    public JablotronJa100Handler(Thing thing, String alarmName) {\n+        super(thing, alarmName);\n+        dataCache = new ExpiringCache<>(CACHE_TIMEOUT_MS, this::sendGetStatusRequest);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (RefreshType.REFRESH.equals(command)) {\n+            logger.debug(\"refreshing channel: {}\", channelUID.getId());\n+            updateChannel(channelUID.getId());\n+        } else {\n+            if (channelUID.getId().startsWith(\"state_\") && command instanceof StringType) {\n+                scheduler.execute(() -> {\n+                    controlSTATESection(channelUID.getId().toUpperCase(), command.toString());\n+                });\n+            }\n+\n+            if (channelUID.getId().startsWith(\"pgm_\") && command instanceof OnOffType) {\n+                scheduler.execute(() -> {\n+                    controlPGMSection(channelUID.getId().toUpperCase(), command.equals(OnOffType.ON) ? \"set\" : \"unset\");\n+                });\n+            }\n+        }\n+    }\n+\n+    private void updateChannel(String channel) {\n+        if (channel.startsWith(\"state_\") || channel.startsWith(\"pgm_\") || channel.startsWith(\"thermometer_\")\n+                || channel.startsWith(\"thermostat_\")) {\n+            updateSegmentStatus(channel, dataCache.getValue());\n+        } else if (CHANNEL_LAST_CHECK_TIME.equals(channel)) {\n+            // not updating\n+        } else {\n+            updateEventChannel(channel);\n+        }\n+    }\n+\n+    private void createChannel(JablotronServiceDetailSegment section) {\n+        if (section.getSegmentId().startsWith(\"PGM_\")) {\n+            createPGMChannel(section.getSegmentId().toLowerCase(), section.getSegmentName());\n+        } else {\n+            createStateChannel(section.getSegmentId().toLowerCase(), section.getSegmentName());\n+        }\n+    }\n+\n+    private void createTempChannel(String name, String label) {\n+        ChannelTypeUID temperature = new ChannelTypeUID(\"jablotron\", \"temperature\");\n+        ThingBuilder thingBuilder = editThing();\n+        Channel channel = ChannelBuilder.create(new ChannelUID(thing.getUID(), name), \"Number:Temperature\")\n+                .withLabel(label).withType(temperature).build();\n+        thingBuilder.withChannel(channel);\n+        updateThing(thingBuilder.build());\n+    }\n+\n+    private void createThermostatChannel(String name, String label) {\n+        ChannelTypeUID temperature = new ChannelTypeUID(\"jablotron\", \"thermostat\");\n+        ThingBuilder thingBuilder = editThing();\n+        Channel channel = ChannelBuilder.create(new ChannelUID(thing.getUID(), name), \"Number:Temperature\")\n+                .withLabel(label).withType(temperature).build();\n+        thingBuilder.withChannel(channel);\n+        updateThing(thingBuilder.build());\n+    }\n+\n+    private void createPGMChannel(String name, String label) {\n+        ThingBuilder thingBuilder = editThing();\n+        Channel channel = ChannelBuilder.create(new ChannelUID(thing.getUID(), name), \"Switch\").withLabel(label)\n+                .build();\n+        thingBuilder.withChannel(channel);\n+        updateThing(thingBuilder.build());\n+    }\n+\n+    private void createStateChannel(String name, String label) {\n+        ChannelTypeUID alarmStatus = new ChannelTypeUID(\"jablotron\", \"alarm_state\");\n+        ThingBuilder thingBuilder = editThing();\n+        Channel channel = ChannelBuilder.create(new ChannelUID(thing.getUID(), name), \"String\").withLabel(label)\n+                .withType(alarmStatus).build();\n+        thingBuilder.withChannel(channel);\n+        updateThing(thingBuilder.build());\n+    }\n+\n+    @Override\n+    protected void updateSegmentStatus(JablotronServiceDetailSegment segment) {\n+        logger.debug(\"Segment id: {} and status: {}\", segment.getSegmentId(), segment.getSegmentState());\n+        String segmentId = segment.getSegmentId();\n+\n+        if (segmentId.startsWith(\"STATE_\") || segmentId.startsWith(\"PGM_\")) {\n+            processSection(segment);\n+        } else if (segmentId.startsWith(\"THERMOMETER_\")) {\n+            processThermometer(segment);\n+        } else if (segmentId.startsWith(\"THERMOSTAT_\")) {\n+            processThermostat(segment);\n+        } else {\n+            logger.debug(\"Unknown segment received: {} with state: {}\", segment.getSegmentId(),\n+                    segment.getSegmentState());\n+        }\n+    }\n+\n+    private void processSection(JablotronServiceDetailSegment segment) {\n+        String segmentId = segment.getSegmentId().toLowerCase();\n+        Channel channel = getThing().getChannel(segmentId);\n+        if (channel == null) {\n+            logger.debug(\"Creating a new channel: {}\", segmentId);\n+            createChannel(segment);\n+        }\n+        channel = getThing().getChannel(segmentId);\n+        if (channel != null) {\n+            logger.debug(\"Updating channel: {} to value: {}\", channel.getUID(), segment.getSegmentState());\n+            State newState;\n+            if (segmentId.startsWith(\"PGM_\")) {\n+                newState = \"unset\".equals(segment.getSegmentState()) ? OnOffType.OFF : OnOffType.ON;\n+            } else {\n+                newState = new StringType(segment.getSegmentState());\n+            }\n+            updateState(channel.getUID(), newState);\n+        } else {\n+            logger.debug(\"The channel: {} still doesn't exist!\", segmentId);\n+        }\n+    }\n+\n+    private void processThermometer(JablotronServiceDetailSegment segment) {\n+        String segmentId = segment.getSegmentId().toLowerCase();\n+        Channel channel = getThing().getChannel(segmentId);\n+        if (channel == null) {\n+            logger.debug(\"Creating a new temperature channel: {}\", segmentId);\n+            createTempChannel(segmentId, segment.getSegmentName());\n+        }\n+        updateTemperatureChannel(channel, segment);\n+    }\n+\n+    private void processThermostat(JablotronServiceDetailSegment segment) {\n+        String segmentId = segment.getSegmentId().toLowerCase();\n+        Channel channel = getThing().getChannel(segmentId);\n+        if (channel == null) {\n+            logger.debug(\"Creating a new thermostat channel: {}\", segmentId);\n+            createThermostatChannel(segmentId, segment.getSegmentName());\n+        }\n+        updateTemperatureChannel(channel, segment);\n+    }\n+\n+    private void updateTemperatureChannel(Channel channel, JablotronServiceDetailSegment segment) {\n+        List<JablotronServiceDetailSegmentInfo> infos = segment.getSegmentInfos();\n+        if (infos.size() > 0) {\n+            logger.debug(\"Found value: {} and type: {}\", infos.get(0).getValue(), infos.get(0).getType());\n+            DecimalType newState = new DecimalType(infos.get(0).getValue());\n+            updateState(channel.getUID(), newState);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a24a1fd3e9b0b42b246535a2373bab007dbe3856"}, "originalPosition": 194}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzU1Mzc5NA==", "bodyText": "The field could theoretically be modified by another thread exactly between the null check and the access at isCancelled(). This is why the compiler generates a warning. To mitigate this, you can store the field to a local variable before checking it:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    if (discoveryJob == null || discoveryJob.isCancelled()) {\n          \n          \n            \n                        discoveryJob = scheduler.scheduleWithFixedDelay(this::startDiscovery, 10, 3600, TimeUnit.SECONDS);\n          \n          \n            \n                    }\n          \n          \n            \n                    ScheduledFuture<?> localDiscoveryJob = discoveryJob;\n          \n          \n            \n            \n          \n          \n            \n                    if (localDiscoveryJob == null || localDiscoveryJob.isCancelled()) {\n          \n          \n            \n                        discoveryJob = scheduler.scheduleWithFixedDelay(this::startDiscovery, 10, 3600, TimeUnit.SECONDS);\n          \n          \n            \n                    }", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r487553794", "createdAt": "2020-09-13T17:13:45Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.jablotron/src/main/java/org/openhab/binding/jablotron/internal/discovery/JablotronDiscoveryService.java", "diffHunk": "@@ -0,0 +1,172 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.jablotron.internal.discovery;\n+\n+import static org.openhab.binding.jablotron.JablotronBindingConstants.*;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.config.discovery.*;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.thing.ThingUID;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.openhab.binding.jablotron.internal.handler.JablotronBridgeHandler;\n+import org.openhab.binding.jablotron.internal.model.JablotronDiscoveredService;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link JablotronDiscoveryService} is responsible for the thing discovery\n+ * process.\n+ *\n+ * @author Ondrej Pecta - Initial contribution\n+ */\n+@NonNullByDefault\n+public class JablotronDiscoveryService extends AbstractDiscoveryService\n+        implements DiscoveryService, ThingHandlerService {\n+    private final Logger logger = LoggerFactory.getLogger(JablotronDiscoveryService.class);\n+\n+    private @Nullable JablotronBridgeHandler bridgeHandler;\n+\n+    private @Nullable ScheduledFuture<?> discoveryJob = null;\n+\n+    public JablotronDiscoveryService() {\n+        super(DISCOVERY_TIMEOUT_SEC);\n+        logger.debug(\"Creating discovery service\");\n+    }\n+\n+    private void startDiscovery() {\n+        if (bridgeHandler != null && ThingStatus.ONLINE == bridgeHandler.getThing().getStatus()) {\n+            discoverServices();\n+        }\n+    }\n+\n+    @Override\n+    public void setThingHandler(@Nullable ThingHandler thingHandler) {\n+        if (thingHandler instanceof JablotronBridgeHandler) {\n+            bridgeHandler = (JablotronBridgeHandler) thingHandler;\n+        }\n+    }\n+\n+    @Override\n+    public @Nullable ThingHandler getThingHandler() {\n+        return bridgeHandler;\n+    }\n+\n+    @Override\n+    protected void stopBackgroundDiscovery() {\n+        super.stopBackgroundDiscovery();\n+        if (discoveryJob != null) {\n+            discoveryJob.cancel(true);\n+        }\n+    }\n+\n+    @Override\n+    protected void startBackgroundDiscovery() {\n+        logger.debug(\"Starting Jablotron background discovery\");\n+\n+        if (discoveryJob == null || discoveryJob.isCancelled()) {\n+            discoveryJob = scheduler.scheduleWithFixedDelay(this::startDiscovery, 10, 3600, TimeUnit.SECONDS);\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a24a1fd3e9b0b42b246535a2373bab007dbe3856"}, "originalPosition": 89}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzU1Mzk1Mw==", "bodyText": "Here too and same for below.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    ThingUID thingUID = new ThingUID(THING_TYPE_OASIS, bridgeHandler.getThing().getUID(), serviceId);\n          \n          \n            \n                    JablotronBridgeHandler localBridgeHandler = bridgeHandler;\n          \n          \n            \n                    if (localBridgeHandler != null) {\n          \n          \n            \n                        ThingUID thingUID = new ThingUID(THING_TYPE_OASIS, localBridgeHandler.getThing().getUID(), serviceId);", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r487553953", "createdAt": "2020-09-13T17:15:17Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.jablotron/src/main/java/org/openhab/binding/jablotron/internal/discovery/JablotronDiscoveryService.java", "diffHunk": "@@ -0,0 +1,172 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.jablotron.internal.discovery;\n+\n+import static org.openhab.binding.jablotron.JablotronBindingConstants.*;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.config.discovery.*;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.thing.ThingUID;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.openhab.binding.jablotron.internal.handler.JablotronBridgeHandler;\n+import org.openhab.binding.jablotron.internal.model.JablotronDiscoveredService;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link JablotronDiscoveryService} is responsible for the thing discovery\n+ * process.\n+ *\n+ * @author Ondrej Pecta - Initial contribution\n+ */\n+@NonNullByDefault\n+public class JablotronDiscoveryService extends AbstractDiscoveryService\n+        implements DiscoveryService, ThingHandlerService {\n+    private final Logger logger = LoggerFactory.getLogger(JablotronDiscoveryService.class);\n+\n+    private @Nullable JablotronBridgeHandler bridgeHandler;\n+\n+    private @Nullable ScheduledFuture<?> discoveryJob = null;\n+\n+    public JablotronDiscoveryService() {\n+        super(DISCOVERY_TIMEOUT_SEC);\n+        logger.debug(\"Creating discovery service\");\n+    }\n+\n+    private void startDiscovery() {\n+        if (bridgeHandler != null && ThingStatus.ONLINE == bridgeHandler.getThing().getStatus()) {\n+            discoverServices();\n+        }\n+    }\n+\n+    @Override\n+    public void setThingHandler(@Nullable ThingHandler thingHandler) {\n+        if (thingHandler instanceof JablotronBridgeHandler) {\n+            bridgeHandler = (JablotronBridgeHandler) thingHandler;\n+        }\n+    }\n+\n+    @Override\n+    public @Nullable ThingHandler getThingHandler() {\n+        return bridgeHandler;\n+    }\n+\n+    @Override\n+    protected void stopBackgroundDiscovery() {\n+        super.stopBackgroundDiscovery();\n+        if (discoveryJob != null) {\n+            discoveryJob.cancel(true);\n+        }\n+    }\n+\n+    @Override\n+    protected void startBackgroundDiscovery() {\n+        logger.debug(\"Starting Jablotron background discovery\");\n+\n+        if (discoveryJob == null || discoveryJob.isCancelled()) {\n+            discoveryJob = scheduler.scheduleWithFixedDelay(this::startDiscovery, 10, 3600, TimeUnit.SECONDS);\n+        }\n+    }\n+\n+    @Override\n+    public void activate() {\n+        super.activate(null);\n+    }\n+\n+    @Override\n+    public void deactivate() {\n+        super.deactivate();\n+    }\n+\n+    @Override\n+    public Set<ThingTypeUID> getSupportedThingTypes() {\n+        return SUPPORTED_THING_TYPES_UIDS;\n+    }\n+\n+    @Override\n+    protected void startScan() {\n+        logger.debug(\"Starting scanning for items...\");\n+        startDiscovery();\n+    }\n+\n+    public void oasisDiscovered(String label, String serviceId) {\n+        ThingUID thingUID = new ThingUID(THING_TYPE_OASIS, bridgeHandler.getThing().getUID(), serviceId);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a24a1fd3e9b0b42b246535a2373bab007dbe3856"}, "originalPosition": 114}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzU1NDAzNg==", "bodyText": "Here for dataCache.", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r487554036", "createdAt": "2020-09-13T17:16:08Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.jablotron/src/main/java/org/openhab/binding/jablotron/internal/handler/JablotronJa100Handler.java", "diffHunk": "@@ -0,0 +1,220 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.jablotron.internal.handler;\n+\n+import static org.openhab.binding.jablotron.JablotronBindingConstants.CACHE_TIMEOUT_MS;\n+import static org.openhab.binding.jablotron.JablotronBindingConstants.CHANNEL_LAST_CHECK_TIME;\n+\n+import java.util.List;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.smarthome.core.cache.ExpiringCache;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.binding.builder.ChannelBuilder;\n+import org.eclipse.smarthome.core.thing.binding.builder.ThingBuilder;\n+import org.eclipse.smarthome.core.thing.type.ChannelTypeUID;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.jablotron.internal.model.JablotronControlResponse;\n+import org.openhab.binding.jablotron.internal.model.JablotronServiceDetailSegment;\n+import org.openhab.binding.jablotron.internal.model.JablotronServiceDetailSegmentInfo;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link JablotronJa100Handler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Ondrej Pecta - Initial contribution\n+ */\n+@NonNullByDefault\n+public class JablotronJa100Handler extends JablotronAlarmHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(JablotronJa100Handler.class);\n+\n+    public JablotronJa100Handler(Thing thing, String alarmName) {\n+        super(thing, alarmName);\n+        dataCache = new ExpiringCache<>(CACHE_TIMEOUT_MS, this::sendGetStatusRequest);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (RefreshType.REFRESH.equals(command)) {\n+            logger.debug(\"refreshing channel: {}\", channelUID.getId());\n+            updateChannel(channelUID.getId());\n+        } else {\n+            if (channelUID.getId().startsWith(\"state_\") && command instanceof StringType) {\n+                scheduler.execute(() -> {\n+                    controlSTATESection(channelUID.getId().toUpperCase(), command.toString());\n+                });\n+            }\n+\n+            if (channelUID.getId().startsWith(\"pgm_\") && command instanceof OnOffType) {\n+                scheduler.execute(() -> {\n+                    controlPGMSection(channelUID.getId().toUpperCase(), command.equals(OnOffType.ON) ? \"set\" : \"unset\");\n+                });\n+            }\n+        }\n+    }\n+\n+    private void updateChannel(String channel) {\n+        if (channel.startsWith(\"state_\") || channel.startsWith(\"pgm_\") || channel.startsWith(\"thermometer_\")\n+                || channel.startsWith(\"thermostat_\")) {\n+            updateSegmentStatus(channel, dataCache.getValue());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a24a1fd3e9b0b42b246535a2373bab007dbe3856"}, "originalPosition": 79}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzU1NDA1NA==", "bodyText": "And here.", "url": "https://github.com/openhab/openhab-addons/pull/6990#discussion_r487554054", "createdAt": "2020-09-13T17:16:38Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.jablotron/src/main/java/org/openhab/binding/jablotron/internal/handler/JablotronOasisHandler.java", "diffHunk": "@@ -0,0 +1,155 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.jablotron.internal.handler;\n+\n+import static org.openhab.binding.jablotron.JablotronBindingConstants.*;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.cache.ExpiringCache;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.jablotron.internal.model.JablotronControlResponse;\n+import org.openhab.binding.jablotron.internal.model.JablotronServiceDetailSegment;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link JablotronOasisHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Ondrej Pecta - Initial contribution\n+ */\n+@NonNullByDefault\n+public class JablotronOasisHandler extends JablotronAlarmHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(JablotronOasisHandler.class);\n+\n+    public JablotronOasisHandler(Thing thing, String alarmName) {\n+        super(thing, alarmName);\n+        dataCache = new ExpiringCache<>(CACHE_TIMEOUT_MS, this::sendGetStatusRequest);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (RefreshType.REFRESH.equals(command)) {\n+            logger.debug(\"refreshing channel: {}\", channelUID.getId());\n+            updateChannel(channelUID.getId());\n+        } else {\n+            switch (channelUID.getId()) {\n+                case CHANNEL_COMMAND:\n+                    if (command instanceof StringType) {\n+                        scheduler.execute(() -> {\n+                            sendCommand(command.toString());\n+                        });\n+                    }\n+                    break;\n+                case CHANNEL_STATUS_PGX:\n+                    if (command instanceof OnOffType) {\n+                        scheduler.execute(() -> {\n+                            controlSection(\"PGM_1\", command.equals(OnOffType.ON) ? \"set\" : \"unset\");\n+                        });\n+                    }\n+                    break;\n+                case CHANNEL_STATUS_PGY:\n+                    if (command instanceof OnOffType) {\n+                        scheduler.execute(() -> {\n+                            controlSection(\"PGM_2\", command.equals(OnOffType.ON) ? \"set\" : \"unset\");\n+                        });\n+                    }\n+                    break;\n+            }\n+        }\n+    }\n+\n+    private void updateChannel(String channel) {\n+        switch (channel) {\n+            case CHANNEL_STATUS_A:\n+                updateSegmentStatus(\"STATE_1\", dataCache.getValue());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a24a1fd3e9b0b42b246535a2373bab007dbe3856"}, "originalPosition": 85}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c7cd72baa91c882e3e482b05ceabe69518a30697", "author": {"user": {"login": "octa22", "name": "Ondrej Pecta"}}, "url": "https://github.com/openhab/openhab-addons/commit/c7cd72baa91c882e3e482b05ceabe69518a30697", "committedDate": "2020-09-13T18:58:33Z", "message": "[jablotron] improvements based on code review\n\nSigned-off-by: Ondrej Pecta <opecta@gmail.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg3MzMxNzkz", "url": "https://github.com/openhab/openhab-addons/pull/6990#pullrequestreview-487331793", "createdAt": "2020-09-13T19:03:11Z", "commit": {"oid": "c7cd72baa91c882e3e482b05ceabe69518a30697"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1426, "cost": 1, "resetAt": "2021-10-28T19:08:13Z"}}}