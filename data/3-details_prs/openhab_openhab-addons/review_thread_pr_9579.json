{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTQ2NDg2MTk3", "number": 9579, "reviewThreads": {"totalCount": 54, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0zMVQxMDoxMDowOFrOFKQqEw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xN1QyMTo0MTowN1rOFPzGsw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ2MzAyOTk1OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/api/esp32/WlanThermoEsp32CommandHandler.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0zMVQxMDoxMDowOFrOIM8rZw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0zMVQxMDoxMDowOFrOIM8rZw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDQ0Nzk3NQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            import java.awt.*;\n          \n          \n            \n            import java.awt.Color;", "url": "https://github.com/openhab/openhab-addons/pull/9579#discussion_r550447975", "createdAt": "2020-12-31T10:10:08Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/api/esp32/WlanThermoEsp32CommandHandler.java", "diffHunk": "@@ -0,0 +1,272 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.wlanthermo.internal.api.esp32;\n+\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.*;\n+\n+import java.awt.*;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1d8198157422913730de85f90ef717e523e063bd"}, "originalPosition": 17}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ2MzA0MjEwOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/api/esp32/WlanThermoEsp32CommandHandler.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0zMVQxMDoxODozOVrOIM8x4w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wMVQxMzowNzoyNFrOINQKAg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDQ0OTYzNQ==", "bodyText": "You can avoid the compiler warning by specifying the wildcard. Please check all.\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                        channel.get(channelId).setMin(((QuantityType) command).doubleValue());\n          \n          \n            \n                                        channel.get(channelId).setMin(((QuantityType<?>) command).doubleValue());", "url": "https://github.com/openhab/openhab-addons/pull/9579#discussion_r550449635", "createdAt": "2020-12-31T10:18:39Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/api/esp32/WlanThermoEsp32CommandHandler.java", "diffHunk": "@@ -0,0 +1,272 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.wlanthermo.internal.api.esp32;\n+\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.*;\n+\n+import java.awt.*;\n+import java.math.BigInteger;\n+import java.util.List;\n+\n+import org.openhab.binding.wlanthermo.internal.api.esp32.data.Channel;\n+import org.openhab.binding.wlanthermo.internal.api.esp32.data.Data;\n+import org.openhab.binding.wlanthermo.internal.api.esp32.data.Pm;\n+import org.openhab.binding.wlanthermo.internal.api.esp32.data.System;\n+import org.openhab.binding.wlanthermo.internal.api.esp32.settings.Settings;\n+import org.openhab.core.library.types.*;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.UnDefType;\n+\n+/**\n+ * The {@link WlanThermoEsp32CommandHandler} is responsible for mapping the Commands to the respective data fields\n+ * of the API.\n+ *\n+ * @author Christian Schlipp - Initial contribution\n+ */\n+public class WlanThermoEsp32CommandHandler {\n+\n+    public State getState(ChannelUID channelUID, Data data, Settings settings) {\n+        State state = null;\n+        if (data == null || settings == null) {\n+            return null;\n+        }\n+        System system = data.getSystem();\n+        List<Channel> channel = data.getChannel();\n+        if (\"system\".equals(channelUID.getGroupId()) && system != null) {\n+            switch (channelUID.getIdWithoutGroup()) {\n+                case SYSTEM_SOC:\n+                    if (system.getSoc() != null) {\n+                        state = new DecimalType(system.getSoc());\n+                    } else {\n+                        state = UnDefType.UNDEF;\n+                    }\n+                    break;\n+                case SYSTEM_CHARGE:\n+                    if (system.getCharge() != null) {\n+                        state = OnOffType.from(system.getCharge());\n+                    } else {\n+                        state = UnDefType.UNDEF;\n+                    }\n+                    break;\n+                case SYSTEM_RSSI_SIGNALSTRENGTH:\n+                    int dbm = system.getRssi();\n+                    if (dbm >= -80) {\n+                        state = new DecimalType(4);\n+                    } else if (dbm >= -95) {\n+                        state = new DecimalType(3);\n+                    } else if (dbm >= -105) {\n+                        state = new DecimalType(2);\n+                    } else {\n+                        state = new DecimalType(1);\n+                    }\n+                    break;\n+                case SYSTEM_RSSI:\n+                    state = new DecimalType(system.getRssi());\n+                    break;\n+            }\n+        } else if (channelUID.getId().startsWith(\"channel\")) {\n+            int channelId = Integer.parseInt(channelUID.getGroupId().substring(\"channel\".length())) - 1;\n+            if (channel != null && channel.size() > 0 && channelId < channel.size()) {\n+                switch (channelUID.getIdWithoutGroup()) {\n+                    case CHANNEL_NAME:\n+                        state = new StringType(channel.get(channelId).getName());\n+                        break;\n+                    case CHANNEL_TYP:\n+                        state = new StringType(settings.getSensors().get(channel.get(channelId).getTyp()).getName());\n+                        break;\n+                    case CHANNEL_TEMP:\n+                        if (channel.get(channelId).getTemp() == 999.0) {\n+                            state = UnDefType.UNDEF;\n+                        } else {\n+                            state = new DecimalType(channel.get(channelId).getTemp());\n+                        }\n+                        break;\n+                    case CHANNEL_MIN:\n+                        state = new DecimalType(channel.get(channelId).getMin());\n+                        break;\n+                    case CHANNEL_MAX:\n+                        state = new DecimalType(channel.get(channelId).getMax());\n+                        break;\n+                    case CHANNEL_ALARM_DEVICE:\n+                        state = OnOffType.from(BigInteger.valueOf(channel.get(channelId).getAlarm()).testBit(1));\n+                        break;\n+                    case CHANNEL_ALARM_PUSH:\n+                        state = OnOffType.from(BigInteger.valueOf(channel.get(channelId).getAlarm()).testBit(0));\n+                        break;\n+                    case CHANNEL_ALARM_OPENHAB_HIGH:\n+                        if (channel.get(channelId).getTemp() != 999\n+                                && channel.get(channelId).getTemp() > channel.get(channelId).getMax()) {\n+                            state = OnOffType.ON;\n+                        } else {\n+                            state = OnOffType.OFF;\n+                        }\n+                        break;\n+                    case CHANNEL_ALARM_OPENHAB_LOW:\n+                        if (channel.get(channelId).getTemp() != 999\n+                                && channel.get(channelId).getTemp() < channel.get(channelId).getMin()) {\n+                            state = OnOffType.ON;\n+                        } else {\n+                            state = OnOffType.OFF;\n+                        }\n+                        break;\n+                    case CHANNEL_COLOR:\n+                        String color = channel.get(channelId).getColor();\n+                        if (color != null && !color.isEmpty()) {\n+                            Color c = Color.decode(color);\n+                            state = HSBType.fromRGB(c.getRed(), c.getGreen(), c.getBlue());\n+                        }\n+                        break;\n+                    case CHANNEL_COLOR_NAME:\n+                        String colorHex = channel.get(channelId).getColor();\n+                        if (colorHex != null && !colorHex.isEmpty()) {\n+                            state = new StringType(UtilEsp32.toColorName(colorHex));\n+                        }\n+                        break;\n+                }\n+            }\n+        } else if (channelUID.getId().startsWith(\"pit1\")) {\n+            if (data.getPitmaster() != null && data.getPitmaster().getPm() != null\n+                    && data.getPitmaster().getPm().size() > 0) {\n+                Pm pm = data.getPitmaster().getPm().get(0);\n+                switch (channelUID.getIdWithoutGroup()) {\n+                    case CHANNEL_PITMASTER_CHANNEL_ID:\n+                        state = new DecimalType(pm.getChannel());\n+                        break;\n+                    case CHANNEL_PITMASTER_PIDPROFILE:\n+                        state = new DecimalType(pm.getPid());\n+                        break;\n+                    case CHANNEL_PITMASTER_DUTY_CYCLE:\n+                        state = new DecimalType(pm.getValue());\n+                        break;\n+                    case CHANNEL_PITMASTER_SETPOINT:\n+                        state = new DecimalType(pm.getSet());\n+                        break;\n+                    case CHANNEL_PITMASTER_STATE:\n+                        state = new StringType(pm.getTyp());\n+                }\n+            } else {\n+                return UnDefType.UNDEF;\n+            }\n+        }\n+        return state;\n+    }\n+\n+    public boolean setState(ChannelUID channelUID, Command command, Data data) {\n+        boolean success = false;\n+        List<Channel> channel = data.getChannel();\n+        if (channelUID.getId().startsWith(\"channel\")) {\n+            int channelId = Integer.parseInt(channelUID.getGroupId().substring(\"channel\".length())) - 1;\n+            if (channel.size() > 0 && channelId < channel.size()) {\n+                switch (channelUID.getIdWithoutGroup()) {\n+                    case CHANNEL_NAME:\n+                        if (command instanceof StringType) {\n+                            channel.get(channelId).setName(command.toFullString());\n+                            success = true;\n+                        }\n+                        break;\n+                    case CHANNEL_MIN:\n+                        if (command instanceof QuantityType) {\n+                            channel.get(channelId).setMin(((QuantityType) command).doubleValue());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1d8198157422913730de85f90ef717e523e063bd"}, "originalPosition": 181}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDc2NzEwNg==", "bodyText": "Changed to wildcard", "url": "https://github.com/openhab/openhab-addons/pull/9579#discussion_r550767106", "createdAt": "2021-01-01T13:07:24Z", "author": {"login": "CSchlipp"}, "path": "bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/api/esp32/WlanThermoEsp32CommandHandler.java", "diffHunk": "@@ -0,0 +1,272 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.wlanthermo.internal.api.esp32;\n+\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.*;\n+\n+import java.awt.*;\n+import java.math.BigInteger;\n+import java.util.List;\n+\n+import org.openhab.binding.wlanthermo.internal.api.esp32.data.Channel;\n+import org.openhab.binding.wlanthermo.internal.api.esp32.data.Data;\n+import org.openhab.binding.wlanthermo.internal.api.esp32.data.Pm;\n+import org.openhab.binding.wlanthermo.internal.api.esp32.data.System;\n+import org.openhab.binding.wlanthermo.internal.api.esp32.settings.Settings;\n+import org.openhab.core.library.types.*;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.UnDefType;\n+\n+/**\n+ * The {@link WlanThermoEsp32CommandHandler} is responsible for mapping the Commands to the respective data fields\n+ * of the API.\n+ *\n+ * @author Christian Schlipp - Initial contribution\n+ */\n+public class WlanThermoEsp32CommandHandler {\n+\n+    public State getState(ChannelUID channelUID, Data data, Settings settings) {\n+        State state = null;\n+        if (data == null || settings == null) {\n+            return null;\n+        }\n+        System system = data.getSystem();\n+        List<Channel> channel = data.getChannel();\n+        if (\"system\".equals(channelUID.getGroupId()) && system != null) {\n+            switch (channelUID.getIdWithoutGroup()) {\n+                case SYSTEM_SOC:\n+                    if (system.getSoc() != null) {\n+                        state = new DecimalType(system.getSoc());\n+                    } else {\n+                        state = UnDefType.UNDEF;\n+                    }\n+                    break;\n+                case SYSTEM_CHARGE:\n+                    if (system.getCharge() != null) {\n+                        state = OnOffType.from(system.getCharge());\n+                    } else {\n+                        state = UnDefType.UNDEF;\n+                    }\n+                    break;\n+                case SYSTEM_RSSI_SIGNALSTRENGTH:\n+                    int dbm = system.getRssi();\n+                    if (dbm >= -80) {\n+                        state = new DecimalType(4);\n+                    } else if (dbm >= -95) {\n+                        state = new DecimalType(3);\n+                    } else if (dbm >= -105) {\n+                        state = new DecimalType(2);\n+                    } else {\n+                        state = new DecimalType(1);\n+                    }\n+                    break;\n+                case SYSTEM_RSSI:\n+                    state = new DecimalType(system.getRssi());\n+                    break;\n+            }\n+        } else if (channelUID.getId().startsWith(\"channel\")) {\n+            int channelId = Integer.parseInt(channelUID.getGroupId().substring(\"channel\".length())) - 1;\n+            if (channel != null && channel.size() > 0 && channelId < channel.size()) {\n+                switch (channelUID.getIdWithoutGroup()) {\n+                    case CHANNEL_NAME:\n+                        state = new StringType(channel.get(channelId).getName());\n+                        break;\n+                    case CHANNEL_TYP:\n+                        state = new StringType(settings.getSensors().get(channel.get(channelId).getTyp()).getName());\n+                        break;\n+                    case CHANNEL_TEMP:\n+                        if (channel.get(channelId).getTemp() == 999.0) {\n+                            state = UnDefType.UNDEF;\n+                        } else {\n+                            state = new DecimalType(channel.get(channelId).getTemp());\n+                        }\n+                        break;\n+                    case CHANNEL_MIN:\n+                        state = new DecimalType(channel.get(channelId).getMin());\n+                        break;\n+                    case CHANNEL_MAX:\n+                        state = new DecimalType(channel.get(channelId).getMax());\n+                        break;\n+                    case CHANNEL_ALARM_DEVICE:\n+                        state = OnOffType.from(BigInteger.valueOf(channel.get(channelId).getAlarm()).testBit(1));\n+                        break;\n+                    case CHANNEL_ALARM_PUSH:\n+                        state = OnOffType.from(BigInteger.valueOf(channel.get(channelId).getAlarm()).testBit(0));\n+                        break;\n+                    case CHANNEL_ALARM_OPENHAB_HIGH:\n+                        if (channel.get(channelId).getTemp() != 999\n+                                && channel.get(channelId).getTemp() > channel.get(channelId).getMax()) {\n+                            state = OnOffType.ON;\n+                        } else {\n+                            state = OnOffType.OFF;\n+                        }\n+                        break;\n+                    case CHANNEL_ALARM_OPENHAB_LOW:\n+                        if (channel.get(channelId).getTemp() != 999\n+                                && channel.get(channelId).getTemp() < channel.get(channelId).getMin()) {\n+                            state = OnOffType.ON;\n+                        } else {\n+                            state = OnOffType.OFF;\n+                        }\n+                        break;\n+                    case CHANNEL_COLOR:\n+                        String color = channel.get(channelId).getColor();\n+                        if (color != null && !color.isEmpty()) {\n+                            Color c = Color.decode(color);\n+                            state = HSBType.fromRGB(c.getRed(), c.getGreen(), c.getBlue());\n+                        }\n+                        break;\n+                    case CHANNEL_COLOR_NAME:\n+                        String colorHex = channel.get(channelId).getColor();\n+                        if (colorHex != null && !colorHex.isEmpty()) {\n+                            state = new StringType(UtilEsp32.toColorName(colorHex));\n+                        }\n+                        break;\n+                }\n+            }\n+        } else if (channelUID.getId().startsWith(\"pit1\")) {\n+            if (data.getPitmaster() != null && data.getPitmaster().getPm() != null\n+                    && data.getPitmaster().getPm().size() > 0) {\n+                Pm pm = data.getPitmaster().getPm().get(0);\n+                switch (channelUID.getIdWithoutGroup()) {\n+                    case CHANNEL_PITMASTER_CHANNEL_ID:\n+                        state = new DecimalType(pm.getChannel());\n+                        break;\n+                    case CHANNEL_PITMASTER_PIDPROFILE:\n+                        state = new DecimalType(pm.getPid());\n+                        break;\n+                    case CHANNEL_PITMASTER_DUTY_CYCLE:\n+                        state = new DecimalType(pm.getValue());\n+                        break;\n+                    case CHANNEL_PITMASTER_SETPOINT:\n+                        state = new DecimalType(pm.getSet());\n+                        break;\n+                    case CHANNEL_PITMASTER_STATE:\n+                        state = new StringType(pm.getTyp());\n+                }\n+            } else {\n+                return UnDefType.UNDEF;\n+            }\n+        }\n+        return state;\n+    }\n+\n+    public boolean setState(ChannelUID channelUID, Command command, Data data) {\n+        boolean success = false;\n+        List<Channel> channel = data.getChannel();\n+        if (channelUID.getId().startsWith(\"channel\")) {\n+            int channelId = Integer.parseInt(channelUID.getGroupId().substring(\"channel\".length())) - 1;\n+            if (channel.size() > 0 && channelId < channel.size()) {\n+                switch (channelUID.getIdWithoutGroup()) {\n+                    case CHANNEL_NAME:\n+                        if (command instanceof StringType) {\n+                            channel.get(channelId).setName(command.toFullString());\n+                            success = true;\n+                        }\n+                        break;\n+                    case CHANNEL_MIN:\n+                        if (command instanceof QuantityType) {\n+                            channel.get(channelId).setMin(((QuantityType) command).doubleValue());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDQ0OTYzNQ=="}, "originalCommit": {"oid": "1d8198157422913730de85f90ef717e523e063bd"}, "originalPosition": 181}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ2MzA2NjM5OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/api/esp32/WlanThermoEsp32Handler.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0zMVQxMDozNDo0MVrOIM8-1A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0zMVQxMDozNDo0MVrOIM8-1A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDQ1Mjk0OA==", "bodyText": "Can this message be replaced by using the debugger or by increasing the framework's log level? See point 4 https://www.openhab.org/docs/developer/guidelines.html#f-logging", "url": "https://github.com/openhab/openhab-addons/pull/9579#discussion_r550452948", "createdAt": "2020-12-31T10:34:41Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/api/esp32/WlanThermoEsp32Handler.java", "diffHunk": "@@ -0,0 +1,222 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.wlanthermo.internal.api.esp32;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.Map;\n+import java.util.concurrent.*;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.Authentication;\n+import org.eclipse.jetty.client.api.AuthenticationStore;\n+import org.eclipse.jetty.client.util.DigestAuthentication;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants;\n+import org.openhab.binding.wlanthermo.internal.WlanThermoExtendedConfiguration;\n+import org.openhab.binding.wlanthermo.internal.api.esp32.data.Data;\n+import org.openhab.binding.wlanthermo.internal.api.esp32.settings.Settings;\n+import org.openhab.core.common.ThreadPoolManager;\n+import org.openhab.core.thing.*;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+\n+/**\n+ * The {@link WlanThermoEsp32Handler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Christian Schlipp - Initial contribution\n+ */\n+@NonNullByDefault\n+public class WlanThermoEsp32Handler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(WlanThermoEsp32Handler.class);\n+\n+    private WlanThermoExtendedConfiguration config = new WlanThermoExtendedConfiguration();\n+    private WlanThermoEsp32CommandHandler wlanThermoEsp32CommandHandler = new WlanThermoEsp32CommandHandler();\n+    private final HttpClient httpClient;\n+    private @Nullable ScheduledFuture<?> pollingScheduler;\n+    private final ScheduledExecutorService scheduler = ThreadPoolManager\n+            .getScheduledPool(WlanThermoBindingConstants.WLANTHERMO_THREAD_POOL);\n+    private final Gson gson = new Gson();\n+    private @Nullable Data data = new Data();\n+    private @Nullable Settings settings = new Settings();\n+\n+    public WlanThermoEsp32Handler(Thing thing, HttpClient httpClient) {\n+        super(thing);\n+        this.httpClient = httpClient;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Start initializing WlanThermo Nano!\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1d8198157422913730de85f90ef717e523e063bd"}, "originalPosition": 71}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ2MzA2NzMxOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/api/esp32/WlanThermoEsp32Handler.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0zMVQxMDozNToxOFrOIM8_RA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0zMVQxMDozNToxOFrOIM8_RA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDQ1MzA2MA==", "bodyText": "The log message could be removed, as the status update is already logged by the framework. The state change originated by updateStatus() is logged to events.log. Including the status detail message. Please check all.\nYou could mention, that the URL is incorrect in the message.", "url": "https://github.com/openhab/openhab-addons/pull/9579#discussion_r550453060", "createdAt": "2020-12-31T10:35:18Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/api/esp32/WlanThermoEsp32Handler.java", "diffHunk": "@@ -0,0 +1,222 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.wlanthermo.internal.api.esp32;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.Map;\n+import java.util.concurrent.*;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.Authentication;\n+import org.eclipse.jetty.client.api.AuthenticationStore;\n+import org.eclipse.jetty.client.util.DigestAuthentication;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants;\n+import org.openhab.binding.wlanthermo.internal.WlanThermoExtendedConfiguration;\n+import org.openhab.binding.wlanthermo.internal.api.esp32.data.Data;\n+import org.openhab.binding.wlanthermo.internal.api.esp32.settings.Settings;\n+import org.openhab.core.common.ThreadPoolManager;\n+import org.openhab.core.thing.*;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+\n+/**\n+ * The {@link WlanThermoEsp32Handler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Christian Schlipp - Initial contribution\n+ */\n+@NonNullByDefault\n+public class WlanThermoEsp32Handler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(WlanThermoEsp32Handler.class);\n+\n+    private WlanThermoExtendedConfiguration config = new WlanThermoExtendedConfiguration();\n+    private WlanThermoEsp32CommandHandler wlanThermoEsp32CommandHandler = new WlanThermoEsp32CommandHandler();\n+    private final HttpClient httpClient;\n+    private @Nullable ScheduledFuture<?> pollingScheduler;\n+    private final ScheduledExecutorService scheduler = ThreadPoolManager\n+            .getScheduledPool(WlanThermoBindingConstants.WLANTHERMO_THREAD_POOL);\n+    private final Gson gson = new Gson();\n+    private @Nullable Data data = new Data();\n+    private @Nullable Settings settings = new Settings();\n+\n+    public WlanThermoEsp32Handler(Thing thing, HttpClient httpClient) {\n+        super(thing);\n+        this.httpClient = httpClient;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Start initializing WlanThermo Nano!\");\n+        config = getConfigAs(WlanThermoExtendedConfiguration.class);\n+\n+        updateStatus(ThingStatus.UNKNOWN);\n+        try {\n+            if (config.getUsername() != null && !config.getUsername().isEmpty() && config.getPassword() != null\n+                    && !config.getPassword().isEmpty()) {\n+                AuthenticationStore authStore = httpClient.getAuthenticationStore();\n+                authStore.addAuthentication(new DigestAuthentication(config.getUri(), Authentication.ANY_REALM,\n+                        config.getUsername(), config.getPassword()));\n+            }\n+            scheduler.schedule(this::checkConnection, config.getPollingInterval(), TimeUnit.SECONDS);\n+\n+            logger.debug(\"Finished initializing WlanThermo Nano!\");\n+        } catch (URISyntaxException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"Failed to initialize WlanThermo Nano!\");\n+            logger.debug(\"Failed to initialize WlanThermo Nano!\", e);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1d8198157422913730de85f90ef717e523e063bd"}, "originalPosition": 88}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ2MzA3MDU2OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/api/esp32/WlanThermoEsp32Handler.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0zMVQxMDozNzoxNFrOIM9Azg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0zMVQxMDozNzoxNFrOIM9Azg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDQ1MzQ1NA==", "bodyText": "You could append the exception's message. Please check all.\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n          \n          \n            \n                                \"Could not connect to WlanThermo at \" + config.getIpAddress());\n          \n          \n            \n                        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n          \n          \n            \n                                \"Could not connect to WlanThermo at \" + config.getIpAddress() + \": \" + e.getMessage());", "url": "https://github.com/openhab/openhab-addons/pull/9579#discussion_r550453454", "createdAt": "2020-12-31T10:37:14Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/api/esp32/WlanThermoEsp32Handler.java", "diffHunk": "@@ -0,0 +1,222 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.wlanthermo.internal.api.esp32;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.Map;\n+import java.util.concurrent.*;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.Authentication;\n+import org.eclipse.jetty.client.api.AuthenticationStore;\n+import org.eclipse.jetty.client.util.DigestAuthentication;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants;\n+import org.openhab.binding.wlanthermo.internal.WlanThermoExtendedConfiguration;\n+import org.openhab.binding.wlanthermo.internal.api.esp32.data.Data;\n+import org.openhab.binding.wlanthermo.internal.api.esp32.settings.Settings;\n+import org.openhab.core.common.ThreadPoolManager;\n+import org.openhab.core.thing.*;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+\n+/**\n+ * The {@link WlanThermoEsp32Handler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Christian Schlipp - Initial contribution\n+ */\n+@NonNullByDefault\n+public class WlanThermoEsp32Handler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(WlanThermoEsp32Handler.class);\n+\n+    private WlanThermoExtendedConfiguration config = new WlanThermoExtendedConfiguration();\n+    private WlanThermoEsp32CommandHandler wlanThermoEsp32CommandHandler = new WlanThermoEsp32CommandHandler();\n+    private final HttpClient httpClient;\n+    private @Nullable ScheduledFuture<?> pollingScheduler;\n+    private final ScheduledExecutorService scheduler = ThreadPoolManager\n+            .getScheduledPool(WlanThermoBindingConstants.WLANTHERMO_THREAD_POOL);\n+    private final Gson gson = new Gson();\n+    private @Nullable Data data = new Data();\n+    private @Nullable Settings settings = new Settings();\n+\n+    public WlanThermoEsp32Handler(Thing thing, HttpClient httpClient) {\n+        super(thing);\n+        this.httpClient = httpClient;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Start initializing WlanThermo Nano!\");\n+        config = getConfigAs(WlanThermoExtendedConfiguration.class);\n+\n+        updateStatus(ThingStatus.UNKNOWN);\n+        try {\n+            if (config.getUsername() != null && !config.getUsername().isEmpty() && config.getPassword() != null\n+                    && !config.getPassword().isEmpty()) {\n+                AuthenticationStore authStore = httpClient.getAuthenticationStore();\n+                authStore.addAuthentication(new DigestAuthentication(config.getUri(), Authentication.ANY_REALM,\n+                        config.getUsername(), config.getPassword()));\n+            }\n+            scheduler.schedule(this::checkConnection, config.getPollingInterval(), TimeUnit.SECONDS);\n+\n+            logger.debug(\"Finished initializing WlanThermo Nano!\");\n+        } catch (URISyntaxException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"Failed to initialize WlanThermo Nano!\");\n+            logger.debug(\"Failed to initialize WlanThermo Nano!\", e);\n+        }\n+    }\n+\n+    private void checkConnection() {\n+        try {\n+            if (httpClient.GET(config.getUri()).getStatus() == 200) {\n+                updateStatus(ThingStatus.ONLINE);\n+                ScheduledFuture<?> oldScheduler = pollingScheduler;\n+                if (oldScheduler != null) {\n+                    oldScheduler.cancel(false);\n+                }\n+                pollingScheduler = scheduler.scheduleWithFixedDelay(this::update, 0, config.getPollingInterval(),\n+                        TimeUnit.SECONDS);\n+            } else {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                        \"WlanThermo not found under given address.\");\n+            }\n+        } catch (URISyntaxException | InterruptedException | ExecutionException | TimeoutException e) {\n+            logger.debug(\"Failed to connect.\", e);\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                    \"Could not connect to WlanThermo at \" + config.getIpAddress());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1d8198157422913730de85f90ef717e523e063bd"}, "originalPosition": 109}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ2MzA3NTcyOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/api/esp32/WlanThermoEsp32Handler.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0zMVQxMDo0MDo0OFrOIM9Dbg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0zMVQxMDo0MDo0OFrOIM9Dbg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDQ1NDEyNg==", "bodyText": "You could initialize the config parameters in the config class to be able to remove the Nullable declaration. Or store config.getUsername() to a local variable here and do the null check on that.", "url": "https://github.com/openhab/openhab-addons/pull/9579#discussion_r550454126", "createdAt": "2020-12-31T10:40:48Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/api/esp32/WlanThermoEsp32Handler.java", "diffHunk": "@@ -0,0 +1,222 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.wlanthermo.internal.api.esp32;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.Map;\n+import java.util.concurrent.*;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.Authentication;\n+import org.eclipse.jetty.client.api.AuthenticationStore;\n+import org.eclipse.jetty.client.util.DigestAuthentication;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants;\n+import org.openhab.binding.wlanthermo.internal.WlanThermoExtendedConfiguration;\n+import org.openhab.binding.wlanthermo.internal.api.esp32.data.Data;\n+import org.openhab.binding.wlanthermo.internal.api.esp32.settings.Settings;\n+import org.openhab.core.common.ThreadPoolManager;\n+import org.openhab.core.thing.*;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+\n+/**\n+ * The {@link WlanThermoEsp32Handler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Christian Schlipp - Initial contribution\n+ */\n+@NonNullByDefault\n+public class WlanThermoEsp32Handler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(WlanThermoEsp32Handler.class);\n+\n+    private WlanThermoExtendedConfiguration config = new WlanThermoExtendedConfiguration();\n+    private WlanThermoEsp32CommandHandler wlanThermoEsp32CommandHandler = new WlanThermoEsp32CommandHandler();\n+    private final HttpClient httpClient;\n+    private @Nullable ScheduledFuture<?> pollingScheduler;\n+    private final ScheduledExecutorService scheduler = ThreadPoolManager\n+            .getScheduledPool(WlanThermoBindingConstants.WLANTHERMO_THREAD_POOL);\n+    private final Gson gson = new Gson();\n+    private @Nullable Data data = new Data();\n+    private @Nullable Settings settings = new Settings();\n+\n+    public WlanThermoEsp32Handler(Thing thing, HttpClient httpClient) {\n+        super(thing);\n+        this.httpClient = httpClient;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Start initializing WlanThermo Nano!\");\n+        config = getConfigAs(WlanThermoExtendedConfiguration.class);\n+\n+        updateStatus(ThingStatus.UNKNOWN);\n+        try {\n+            if (config.getUsername() != null && !config.getUsername().isEmpty() && config.getPassword() != null\n+                    && !config.getPassword().isEmpty()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1d8198157422913730de85f90ef717e523e063bd"}, "originalPosition": 77}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ2MzA3NjI3OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/api/esp32/WlanThermoEsp32Handler.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0zMVQxMDo0MToxMlrOIM9Drw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0zMVQxMDo0MToxMlrOIM9Drw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDQ1NDE5MQ==", "bodyText": "Please add curly brackets.", "url": "https://github.com/openhab/openhab-addons/pull/9579#discussion_r550454191", "createdAt": "2020-12-31T10:41:12Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/api/esp32/WlanThermoEsp32Handler.java", "diffHunk": "@@ -0,0 +1,222 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.wlanthermo.internal.api.esp32;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.Map;\n+import java.util.concurrent.*;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.Authentication;\n+import org.eclipse.jetty.client.api.AuthenticationStore;\n+import org.eclipse.jetty.client.util.DigestAuthentication;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants;\n+import org.openhab.binding.wlanthermo.internal.WlanThermoExtendedConfiguration;\n+import org.openhab.binding.wlanthermo.internal.api.esp32.data.Data;\n+import org.openhab.binding.wlanthermo.internal.api.esp32.settings.Settings;\n+import org.openhab.core.common.ThreadPoolManager;\n+import org.openhab.core.thing.*;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+\n+/**\n+ * The {@link WlanThermoEsp32Handler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Christian Schlipp - Initial contribution\n+ */\n+@NonNullByDefault\n+public class WlanThermoEsp32Handler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(WlanThermoEsp32Handler.class);\n+\n+    private WlanThermoExtendedConfiguration config = new WlanThermoExtendedConfiguration();\n+    private WlanThermoEsp32CommandHandler wlanThermoEsp32CommandHandler = new WlanThermoEsp32CommandHandler();\n+    private final HttpClient httpClient;\n+    private @Nullable ScheduledFuture<?> pollingScheduler;\n+    private final ScheduledExecutorService scheduler = ThreadPoolManager\n+            .getScheduledPool(WlanThermoBindingConstants.WLANTHERMO_THREAD_POOL);\n+    private final Gson gson = new Gson();\n+    private @Nullable Data data = new Data();\n+    private @Nullable Settings settings = new Settings();\n+\n+    public WlanThermoEsp32Handler(Thing thing, HttpClient httpClient) {\n+        super(thing);\n+        this.httpClient = httpClient;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Start initializing WlanThermo Nano!\");\n+        config = getConfigAs(WlanThermoExtendedConfiguration.class);\n+\n+        updateStatus(ThingStatus.UNKNOWN);\n+        try {\n+            if (config.getUsername() != null && !config.getUsername().isEmpty() && config.getPassword() != null\n+                    && !config.getPassword().isEmpty()) {\n+                AuthenticationStore authStore = httpClient.getAuthenticationStore();\n+                authStore.addAuthentication(new DigestAuthentication(config.getUri(), Authentication.ANY_REALM,\n+                        config.getUsername(), config.getPassword()));\n+            }\n+            scheduler.schedule(this::checkConnection, config.getPollingInterval(), TimeUnit.SECONDS);\n+\n+            logger.debug(\"Finished initializing WlanThermo Nano!\");\n+        } catch (URISyntaxException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"Failed to initialize WlanThermo Nano!\");\n+            logger.debug(\"Failed to initialize WlanThermo Nano!\", e);\n+        }\n+    }\n+\n+    private void checkConnection() {\n+        try {\n+            if (httpClient.GET(config.getUri()).getStatus() == 200) {\n+                updateStatus(ThingStatus.ONLINE);\n+                ScheduledFuture<?> oldScheduler = pollingScheduler;\n+                if (oldScheduler != null) {\n+                    oldScheduler.cancel(false);\n+                }\n+                pollingScheduler = scheduler.scheduleWithFixedDelay(this::update, 0, config.getPollingInterval(),\n+                        TimeUnit.SECONDS);\n+            } else {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                        \"WlanThermo not found under given address.\");\n+            }\n+        } catch (URISyntaxException | InterruptedException | ExecutionException | TimeoutException e) {\n+            logger.debug(\"Failed to connect.\", e);\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                    \"Could not connect to WlanThermo at \" + config.getIpAddress());\n+            ScheduledFuture<?> oldScheduler = pollingScheduler;\n+            if (oldScheduler != null) {\n+                oldScheduler.cancel(false);\n+            }\n+            pollingScheduler = scheduler.schedule(this::checkConnection, config.getPollingInterval(), TimeUnit.SECONDS);\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            State s = wlanThermoEsp32CommandHandler.getState(channelUID, data, settings);\n+            if (s != null)\n+                updateState(channelUID, s);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1d8198157422913730de85f90ef717e523e063bd"}, "originalPosition": 123}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ2MzA3NzkyOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/api/esp32/WlanThermoEsp32Handler.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0zMVQxMDo0MjoyMlrOIM9Ejg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wMVQxMzowNzowNFrOINQJ-g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDQ1NDQxNA==", "bodyText": "Is there a reason why these are Nullable?", "url": "https://github.com/openhab/openhab-addons/pull/9579#discussion_r550454414", "createdAt": "2020-12-31T10:42:22Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/api/esp32/WlanThermoEsp32Handler.java", "diffHunk": "@@ -0,0 +1,222 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.wlanthermo.internal.api.esp32;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.Map;\n+import java.util.concurrent.*;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.Authentication;\n+import org.eclipse.jetty.client.api.AuthenticationStore;\n+import org.eclipse.jetty.client.util.DigestAuthentication;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants;\n+import org.openhab.binding.wlanthermo.internal.WlanThermoExtendedConfiguration;\n+import org.openhab.binding.wlanthermo.internal.api.esp32.data.Data;\n+import org.openhab.binding.wlanthermo.internal.api.esp32.settings.Settings;\n+import org.openhab.core.common.ThreadPoolManager;\n+import org.openhab.core.thing.*;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+\n+/**\n+ * The {@link WlanThermoEsp32Handler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Christian Schlipp - Initial contribution\n+ */\n+@NonNullByDefault\n+public class WlanThermoEsp32Handler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(WlanThermoEsp32Handler.class);\n+\n+    private WlanThermoExtendedConfiguration config = new WlanThermoExtendedConfiguration();\n+    private WlanThermoEsp32CommandHandler wlanThermoEsp32CommandHandler = new WlanThermoEsp32CommandHandler();\n+    private final HttpClient httpClient;\n+    private @Nullable ScheduledFuture<?> pollingScheduler;\n+    private final ScheduledExecutorService scheduler = ThreadPoolManager\n+            .getScheduledPool(WlanThermoBindingConstants.WLANTHERMO_THREAD_POOL);\n+    private final Gson gson = new Gson();\n+    private @Nullable Data data = new Data();\n+    private @Nullable Settings settings = new Settings();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1d8198157422913730de85f90ef717e523e063bd"}, "originalPosition": 62}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDQ2MTU5OQ==", "bodyText": "TBH I don't know why this came up as an error in the V3 branch when compiling locally...\nPrevious versions did not require the annotation, even the current auto-migrated binding is obviously compiling fine when run on Jenkins?", "url": "https://github.com/openhab/openhab-addons/pull/9579#discussion_r550461599", "createdAt": "2020-12-31T11:19:35Z", "author": {"login": "CSchlipp"}, "path": "bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/api/esp32/WlanThermoEsp32Handler.java", "diffHunk": "@@ -0,0 +1,222 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.wlanthermo.internal.api.esp32;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.Map;\n+import java.util.concurrent.*;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.Authentication;\n+import org.eclipse.jetty.client.api.AuthenticationStore;\n+import org.eclipse.jetty.client.util.DigestAuthentication;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants;\n+import org.openhab.binding.wlanthermo.internal.WlanThermoExtendedConfiguration;\n+import org.openhab.binding.wlanthermo.internal.api.esp32.data.Data;\n+import org.openhab.binding.wlanthermo.internal.api.esp32.settings.Settings;\n+import org.openhab.core.common.ThreadPoolManager;\n+import org.openhab.core.thing.*;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+\n+/**\n+ * The {@link WlanThermoEsp32Handler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Christian Schlipp - Initial contribution\n+ */\n+@NonNullByDefault\n+public class WlanThermoEsp32Handler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(WlanThermoEsp32Handler.class);\n+\n+    private WlanThermoExtendedConfiguration config = new WlanThermoExtendedConfiguration();\n+    private WlanThermoEsp32CommandHandler wlanThermoEsp32CommandHandler = new WlanThermoEsp32CommandHandler();\n+    private final HttpClient httpClient;\n+    private @Nullable ScheduledFuture<?> pollingScheduler;\n+    private final ScheduledExecutorService scheduler = ThreadPoolManager\n+            .getScheduledPool(WlanThermoBindingConstants.WLANTHERMO_THREAD_POOL);\n+    private final Gson gson = new Gson();\n+    private @Nullable Data data = new Data();\n+    private @Nullable Settings settings = new Settings();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDQ1NDQxNA=="}, "originalCommit": {"oid": "1d8198157422913730de85f90ef717e523e063bd"}, "originalPosition": 62}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDQ2MzQ3MA==", "bodyText": "I see, Gson requires it. Then, you need to handle the null case, i.e. fix the compiler warnings about nulls.", "url": "https://github.com/openhab/openhab-addons/pull/9579#discussion_r550463470", "createdAt": "2020-12-31T11:30:55Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/api/esp32/WlanThermoEsp32Handler.java", "diffHunk": "@@ -0,0 +1,222 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.wlanthermo.internal.api.esp32;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.Map;\n+import java.util.concurrent.*;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.Authentication;\n+import org.eclipse.jetty.client.api.AuthenticationStore;\n+import org.eclipse.jetty.client.util.DigestAuthentication;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants;\n+import org.openhab.binding.wlanthermo.internal.WlanThermoExtendedConfiguration;\n+import org.openhab.binding.wlanthermo.internal.api.esp32.data.Data;\n+import org.openhab.binding.wlanthermo.internal.api.esp32.settings.Settings;\n+import org.openhab.core.common.ThreadPoolManager;\n+import org.openhab.core.thing.*;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+\n+/**\n+ * The {@link WlanThermoEsp32Handler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Christian Schlipp - Initial contribution\n+ */\n+@NonNullByDefault\n+public class WlanThermoEsp32Handler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(WlanThermoEsp32Handler.class);\n+\n+    private WlanThermoExtendedConfiguration config = new WlanThermoExtendedConfiguration();\n+    private WlanThermoEsp32CommandHandler wlanThermoEsp32CommandHandler = new WlanThermoEsp32CommandHandler();\n+    private final HttpClient httpClient;\n+    private @Nullable ScheduledFuture<?> pollingScheduler;\n+    private final ScheduledExecutorService scheduler = ThreadPoolManager\n+            .getScheduledPool(WlanThermoBindingConstants.WLANTHERMO_THREAD_POOL);\n+    private final Gson gson = new Gson();\n+    private @Nullable Data data = new Data();\n+    private @Nullable Settings settings = new Settings();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDQ1NDQxNA=="}, "originalCommit": {"oid": "1d8198157422913730de85f90ef717e523e063bd"}, "originalPosition": 62}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDc2NzA5OA==", "bodyText": "Done, remaining warnings are false positives", "url": "https://github.com/openhab/openhab-addons/pull/9579#discussion_r550767098", "createdAt": "2021-01-01T13:07:04Z", "author": {"login": "CSchlipp"}, "path": "bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/api/esp32/WlanThermoEsp32Handler.java", "diffHunk": "@@ -0,0 +1,222 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.wlanthermo.internal.api.esp32;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.Map;\n+import java.util.concurrent.*;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.Authentication;\n+import org.eclipse.jetty.client.api.AuthenticationStore;\n+import org.eclipse.jetty.client.util.DigestAuthentication;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants;\n+import org.openhab.binding.wlanthermo.internal.WlanThermoExtendedConfiguration;\n+import org.openhab.binding.wlanthermo.internal.api.esp32.data.Data;\n+import org.openhab.binding.wlanthermo.internal.api.esp32.settings.Settings;\n+import org.openhab.core.common.ThreadPoolManager;\n+import org.openhab.core.thing.*;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+\n+/**\n+ * The {@link WlanThermoEsp32Handler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Christian Schlipp - Initial contribution\n+ */\n+@NonNullByDefault\n+public class WlanThermoEsp32Handler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(WlanThermoEsp32Handler.class);\n+\n+    private WlanThermoExtendedConfiguration config = new WlanThermoExtendedConfiguration();\n+    private WlanThermoEsp32CommandHandler wlanThermoEsp32CommandHandler = new WlanThermoEsp32CommandHandler();\n+    private final HttpClient httpClient;\n+    private @Nullable ScheduledFuture<?> pollingScheduler;\n+    private final ScheduledExecutorService scheduler = ThreadPoolManager\n+            .getScheduledPool(WlanThermoBindingConstants.WLANTHERMO_THREAD_POOL);\n+    private final Gson gson = new Gson();\n+    private @Nullable Data data = new Data();\n+    private @Nullable Settings settings = new Settings();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDQ1NDQxNA=="}, "originalCommit": {"oid": "1d8198157422913730de85f90ef717e523e063bd"}, "originalPosition": 62}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ2MzA4MDMyOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/api/esp32/WlanThermoEsp32Handler.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0zMVQxMDo0NDowN1rOIM9FxQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wMVQxMDoxMTozMFrOINPU-w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDQ1NDcyNQ==", "bodyText": "Can this message be replaced by using the debugger or by increasing the framework's log level? See point 4 https://www.openhab.org/docs/developer/guidelines.html#f-logging", "url": "https://github.com/openhab/openhab-addons/pull/9579#discussion_r550454725", "createdAt": "2020-12-31T10:44:07Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/api/esp32/WlanThermoEsp32Handler.java", "diffHunk": "@@ -0,0 +1,222 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.wlanthermo.internal.api.esp32;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.Map;\n+import java.util.concurrent.*;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.Authentication;\n+import org.eclipse.jetty.client.api.AuthenticationStore;\n+import org.eclipse.jetty.client.util.DigestAuthentication;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants;\n+import org.openhab.binding.wlanthermo.internal.WlanThermoExtendedConfiguration;\n+import org.openhab.binding.wlanthermo.internal.api.esp32.data.Data;\n+import org.openhab.binding.wlanthermo.internal.api.esp32.settings.Settings;\n+import org.openhab.core.common.ThreadPoolManager;\n+import org.openhab.core.thing.*;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+\n+/**\n+ * The {@link WlanThermoEsp32Handler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Christian Schlipp - Initial contribution\n+ */\n+@NonNullByDefault\n+public class WlanThermoEsp32Handler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(WlanThermoEsp32Handler.class);\n+\n+    private WlanThermoExtendedConfiguration config = new WlanThermoExtendedConfiguration();\n+    private WlanThermoEsp32CommandHandler wlanThermoEsp32CommandHandler = new WlanThermoEsp32CommandHandler();\n+    private final HttpClient httpClient;\n+    private @Nullable ScheduledFuture<?> pollingScheduler;\n+    private final ScheduledExecutorService scheduler = ThreadPoolManager\n+            .getScheduledPool(WlanThermoBindingConstants.WLANTHERMO_THREAD_POOL);\n+    private final Gson gson = new Gson();\n+    private @Nullable Data data = new Data();\n+    private @Nullable Settings settings = new Settings();\n+\n+    public WlanThermoEsp32Handler(Thing thing, HttpClient httpClient) {\n+        super(thing);\n+        this.httpClient = httpClient;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Start initializing WlanThermo Nano!\");\n+        config = getConfigAs(WlanThermoExtendedConfiguration.class);\n+\n+        updateStatus(ThingStatus.UNKNOWN);\n+        try {\n+            if (config.getUsername() != null && !config.getUsername().isEmpty() && config.getPassword() != null\n+                    && !config.getPassword().isEmpty()) {\n+                AuthenticationStore authStore = httpClient.getAuthenticationStore();\n+                authStore.addAuthentication(new DigestAuthentication(config.getUri(), Authentication.ANY_REALM,\n+                        config.getUsername(), config.getPassword()));\n+            }\n+            scheduler.schedule(this::checkConnection, config.getPollingInterval(), TimeUnit.SECONDS);\n+\n+            logger.debug(\"Finished initializing WlanThermo Nano!\");\n+        } catch (URISyntaxException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"Failed to initialize WlanThermo Nano!\");\n+            logger.debug(\"Failed to initialize WlanThermo Nano!\", e);\n+        }\n+    }\n+\n+    private void checkConnection() {\n+        try {\n+            if (httpClient.GET(config.getUri()).getStatus() == 200) {\n+                updateStatus(ThingStatus.ONLINE);\n+                ScheduledFuture<?> oldScheduler = pollingScheduler;\n+                if (oldScheduler != null) {\n+                    oldScheduler.cancel(false);\n+                }\n+                pollingScheduler = scheduler.scheduleWithFixedDelay(this::update, 0, config.getPollingInterval(),\n+                        TimeUnit.SECONDS);\n+            } else {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                        \"WlanThermo not found under given address.\");\n+            }\n+        } catch (URISyntaxException | InterruptedException | ExecutionException | TimeoutException e) {\n+            logger.debug(\"Failed to connect.\", e);\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                    \"Could not connect to WlanThermo at \" + config.getIpAddress());\n+            ScheduledFuture<?> oldScheduler = pollingScheduler;\n+            if (oldScheduler != null) {\n+                oldScheduler.cancel(false);\n+            }\n+            pollingScheduler = scheduler.schedule(this::checkConnection, config.getPollingInterval(), TimeUnit.SECONDS);\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            State s = wlanThermoEsp32CommandHandler.getState(channelUID, data, settings);\n+            if (s != null)\n+                updateState(channelUID, s);\n+        } else {\n+            if (wlanThermoEsp32CommandHandler.setState(channelUID, command, data)) {\n+                logger.debug(\"Data updated, pushing changes\");\n+                push();\n+            } else {\n+                logger.debug(\"Could not handle command of type {} for channel {}!\",\n+                        command.getClass().toGenericString(), channelUID.getId());\n+            }\n+        }\n+    }\n+\n+    private void update() {\n+        try {\n+            // Update objects with data from device\n+            String json = httpClient.GET(config.getUri(\"/data\")).getContentAsString();\n+            data = gson.fromJson(json, Data.class);\n+            logger.debug(\"Received at /data: {}\", json);\n+            json = httpClient.GET(config.getUri(\"/settings\")).getContentAsString();\n+            settings = gson.fromJson(json, Settings.class);\n+            logger.debug(\"Received at /settings: {}\", json);\n+\n+            // Update Channels if required\n+            Map<String, String> properties = editProperties();\n+            Boolean pmEnabled = settings.getFeatures().getBluetooth();\n+            int pmChannels = pmEnabled ? data.getPitmaster().getPm().size() : 0;\n+            int tempChannels = data.getChannel().size();\n+\n+            // Update properties\n+            properties.put(WlanThermoBindingConstants.PROPERTY_MODEL, settings.getDevice().getDevice());\n+            properties.put(WlanThermoBindingConstants.PROPERTY_SERIAL, settings.getDevice().getSerial());\n+            properties.put(WlanThermoBindingConstants.PROPERTY_ESP32_BT_ENABLED,\n+                    settings.getFeatures().getBluetooth().toString());\n+            properties.put(WlanThermoBindingConstants.PROPERTY_ESP32_PM_ENABLED, pmEnabled.toString());\n+            properties.put(WlanThermoBindingConstants.PROPERTY_ESP32_TEMP_CHANNELS, String.valueOf(tempChannels));\n+            properties.put(WlanThermoBindingConstants.PROPERTY_ESP32_PM_CHANNELS, String.valueOf(pmChannels));\n+            updateProperties(properties);\n+\n+            // Update channel state\n+            for (Channel channel : thing.getChannels()) {\n+                State state = wlanThermoEsp32CommandHandler.getState(channel.getUID(), data, settings);\n+                if (state != null) {\n+                    updateState(channel.getUID(), state);\n+                } else {\n+                    // if we could not obtain a state, try trigger instead\n+                    String trigger = wlanThermoEsp32CommandHandler.getTrigger(channel.getUID(), data);\n+                    if (trigger != null) {\n+                        triggerChannel(channel.getUID(), trigger);\n+                    }\n+                }\n+            }\n+        } catch (URISyntaxException | InterruptedException | ExecutionException | TimeoutException e) {\n+            logger.debug(\"Update failed, checking connection\", e);\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, \"Update failed, reconnecting...\");\n+            ScheduledFuture<?> oldScheduler = pollingScheduler;\n+            if (oldScheduler != null) {\n+                oldScheduler.cancel(false);\n+            }\n+            for (Channel channel : thing.getChannels()) {\n+                updateState(channel.getUID(), UnDefType.UNDEF);\n+            }\n+            checkConnection();\n+        }\n+    }\n+\n+    private void push() {\n+        data.getChannel().forEach(c -> {\n+            try {\n+                String json = gson.toJson(c);\n+                logger.debug(\"Pushing: {}\", json);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1d8198157422913730de85f90ef717e523e063bd"}, "originalPosition": 192}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDUwNzU3NQ==", "bodyText": "This is usually the most crucial part in case sth goes wrong.\nI'd prefer to leave it with a dedicated debug log so that users can easily include it in in bug reports.", "url": "https://github.com/openhab/openhab-addons/pull/9579#discussion_r550507575", "createdAt": "2020-12-31T15:42:39Z", "author": {"login": "CSchlipp"}, "path": "bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/api/esp32/WlanThermoEsp32Handler.java", "diffHunk": "@@ -0,0 +1,222 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.wlanthermo.internal.api.esp32;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.Map;\n+import java.util.concurrent.*;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.Authentication;\n+import org.eclipse.jetty.client.api.AuthenticationStore;\n+import org.eclipse.jetty.client.util.DigestAuthentication;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants;\n+import org.openhab.binding.wlanthermo.internal.WlanThermoExtendedConfiguration;\n+import org.openhab.binding.wlanthermo.internal.api.esp32.data.Data;\n+import org.openhab.binding.wlanthermo.internal.api.esp32.settings.Settings;\n+import org.openhab.core.common.ThreadPoolManager;\n+import org.openhab.core.thing.*;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+\n+/**\n+ * The {@link WlanThermoEsp32Handler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Christian Schlipp - Initial contribution\n+ */\n+@NonNullByDefault\n+public class WlanThermoEsp32Handler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(WlanThermoEsp32Handler.class);\n+\n+    private WlanThermoExtendedConfiguration config = new WlanThermoExtendedConfiguration();\n+    private WlanThermoEsp32CommandHandler wlanThermoEsp32CommandHandler = new WlanThermoEsp32CommandHandler();\n+    private final HttpClient httpClient;\n+    private @Nullable ScheduledFuture<?> pollingScheduler;\n+    private final ScheduledExecutorService scheduler = ThreadPoolManager\n+            .getScheduledPool(WlanThermoBindingConstants.WLANTHERMO_THREAD_POOL);\n+    private final Gson gson = new Gson();\n+    private @Nullable Data data = new Data();\n+    private @Nullable Settings settings = new Settings();\n+\n+    public WlanThermoEsp32Handler(Thing thing, HttpClient httpClient) {\n+        super(thing);\n+        this.httpClient = httpClient;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Start initializing WlanThermo Nano!\");\n+        config = getConfigAs(WlanThermoExtendedConfiguration.class);\n+\n+        updateStatus(ThingStatus.UNKNOWN);\n+        try {\n+            if (config.getUsername() != null && !config.getUsername().isEmpty() && config.getPassword() != null\n+                    && !config.getPassword().isEmpty()) {\n+                AuthenticationStore authStore = httpClient.getAuthenticationStore();\n+                authStore.addAuthentication(new DigestAuthentication(config.getUri(), Authentication.ANY_REALM,\n+                        config.getUsername(), config.getPassword()));\n+            }\n+            scheduler.schedule(this::checkConnection, config.getPollingInterval(), TimeUnit.SECONDS);\n+\n+            logger.debug(\"Finished initializing WlanThermo Nano!\");\n+        } catch (URISyntaxException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"Failed to initialize WlanThermo Nano!\");\n+            logger.debug(\"Failed to initialize WlanThermo Nano!\", e);\n+        }\n+    }\n+\n+    private void checkConnection() {\n+        try {\n+            if (httpClient.GET(config.getUri()).getStatus() == 200) {\n+                updateStatus(ThingStatus.ONLINE);\n+                ScheduledFuture<?> oldScheduler = pollingScheduler;\n+                if (oldScheduler != null) {\n+                    oldScheduler.cancel(false);\n+                }\n+                pollingScheduler = scheduler.scheduleWithFixedDelay(this::update, 0, config.getPollingInterval(),\n+                        TimeUnit.SECONDS);\n+            } else {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                        \"WlanThermo not found under given address.\");\n+            }\n+        } catch (URISyntaxException | InterruptedException | ExecutionException | TimeoutException e) {\n+            logger.debug(\"Failed to connect.\", e);\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                    \"Could not connect to WlanThermo at \" + config.getIpAddress());\n+            ScheduledFuture<?> oldScheduler = pollingScheduler;\n+            if (oldScheduler != null) {\n+                oldScheduler.cancel(false);\n+            }\n+            pollingScheduler = scheduler.schedule(this::checkConnection, config.getPollingInterval(), TimeUnit.SECONDS);\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            State s = wlanThermoEsp32CommandHandler.getState(channelUID, data, settings);\n+            if (s != null)\n+                updateState(channelUID, s);\n+        } else {\n+            if (wlanThermoEsp32CommandHandler.setState(channelUID, command, data)) {\n+                logger.debug(\"Data updated, pushing changes\");\n+                push();\n+            } else {\n+                logger.debug(\"Could not handle command of type {} for channel {}!\",\n+                        command.getClass().toGenericString(), channelUID.getId());\n+            }\n+        }\n+    }\n+\n+    private void update() {\n+        try {\n+            // Update objects with data from device\n+            String json = httpClient.GET(config.getUri(\"/data\")).getContentAsString();\n+            data = gson.fromJson(json, Data.class);\n+            logger.debug(\"Received at /data: {}\", json);\n+            json = httpClient.GET(config.getUri(\"/settings\")).getContentAsString();\n+            settings = gson.fromJson(json, Settings.class);\n+            logger.debug(\"Received at /settings: {}\", json);\n+\n+            // Update Channels if required\n+            Map<String, String> properties = editProperties();\n+            Boolean pmEnabled = settings.getFeatures().getBluetooth();\n+            int pmChannels = pmEnabled ? data.getPitmaster().getPm().size() : 0;\n+            int tempChannels = data.getChannel().size();\n+\n+            // Update properties\n+            properties.put(WlanThermoBindingConstants.PROPERTY_MODEL, settings.getDevice().getDevice());\n+            properties.put(WlanThermoBindingConstants.PROPERTY_SERIAL, settings.getDevice().getSerial());\n+            properties.put(WlanThermoBindingConstants.PROPERTY_ESP32_BT_ENABLED,\n+                    settings.getFeatures().getBluetooth().toString());\n+            properties.put(WlanThermoBindingConstants.PROPERTY_ESP32_PM_ENABLED, pmEnabled.toString());\n+            properties.put(WlanThermoBindingConstants.PROPERTY_ESP32_TEMP_CHANNELS, String.valueOf(tempChannels));\n+            properties.put(WlanThermoBindingConstants.PROPERTY_ESP32_PM_CHANNELS, String.valueOf(pmChannels));\n+            updateProperties(properties);\n+\n+            // Update channel state\n+            for (Channel channel : thing.getChannels()) {\n+                State state = wlanThermoEsp32CommandHandler.getState(channel.getUID(), data, settings);\n+                if (state != null) {\n+                    updateState(channel.getUID(), state);\n+                } else {\n+                    // if we could not obtain a state, try trigger instead\n+                    String trigger = wlanThermoEsp32CommandHandler.getTrigger(channel.getUID(), data);\n+                    if (trigger != null) {\n+                        triggerChannel(channel.getUID(), trigger);\n+                    }\n+                }\n+            }\n+        } catch (URISyntaxException | InterruptedException | ExecutionException | TimeoutException e) {\n+            logger.debug(\"Update failed, checking connection\", e);\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, \"Update failed, reconnecting...\");\n+            ScheduledFuture<?> oldScheduler = pollingScheduler;\n+            if (oldScheduler != null) {\n+                oldScheduler.cancel(false);\n+            }\n+            for (Channel channel : thing.getChannels()) {\n+                updateState(channel.getUID(), UnDefType.UNDEF);\n+            }\n+            checkConnection();\n+        }\n+    }\n+\n+    private void push() {\n+        data.getChannel().forEach(c -> {\n+            try {\n+                String json = gson.toJson(c);\n+                logger.debug(\"Pushing: {}\", json);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDQ1NDcyNQ=="}, "originalCommit": {"oid": "1d8198157422913730de85f90ef717e523e063bd"}, "originalPosition": 192}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDUxMjgxMg==", "bodyText": "Is there any chance to log this only if something goes wrong?", "url": "https://github.com/openhab/openhab-addons/pull/9579#discussion_r550512812", "createdAt": "2020-12-31T16:00:31Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/api/esp32/WlanThermoEsp32Handler.java", "diffHunk": "@@ -0,0 +1,222 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.wlanthermo.internal.api.esp32;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.Map;\n+import java.util.concurrent.*;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.Authentication;\n+import org.eclipse.jetty.client.api.AuthenticationStore;\n+import org.eclipse.jetty.client.util.DigestAuthentication;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants;\n+import org.openhab.binding.wlanthermo.internal.WlanThermoExtendedConfiguration;\n+import org.openhab.binding.wlanthermo.internal.api.esp32.data.Data;\n+import org.openhab.binding.wlanthermo.internal.api.esp32.settings.Settings;\n+import org.openhab.core.common.ThreadPoolManager;\n+import org.openhab.core.thing.*;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+\n+/**\n+ * The {@link WlanThermoEsp32Handler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Christian Schlipp - Initial contribution\n+ */\n+@NonNullByDefault\n+public class WlanThermoEsp32Handler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(WlanThermoEsp32Handler.class);\n+\n+    private WlanThermoExtendedConfiguration config = new WlanThermoExtendedConfiguration();\n+    private WlanThermoEsp32CommandHandler wlanThermoEsp32CommandHandler = new WlanThermoEsp32CommandHandler();\n+    private final HttpClient httpClient;\n+    private @Nullable ScheduledFuture<?> pollingScheduler;\n+    private final ScheduledExecutorService scheduler = ThreadPoolManager\n+            .getScheduledPool(WlanThermoBindingConstants.WLANTHERMO_THREAD_POOL);\n+    private final Gson gson = new Gson();\n+    private @Nullable Data data = new Data();\n+    private @Nullable Settings settings = new Settings();\n+\n+    public WlanThermoEsp32Handler(Thing thing, HttpClient httpClient) {\n+        super(thing);\n+        this.httpClient = httpClient;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Start initializing WlanThermo Nano!\");\n+        config = getConfigAs(WlanThermoExtendedConfiguration.class);\n+\n+        updateStatus(ThingStatus.UNKNOWN);\n+        try {\n+            if (config.getUsername() != null && !config.getUsername().isEmpty() && config.getPassword() != null\n+                    && !config.getPassword().isEmpty()) {\n+                AuthenticationStore authStore = httpClient.getAuthenticationStore();\n+                authStore.addAuthentication(new DigestAuthentication(config.getUri(), Authentication.ANY_REALM,\n+                        config.getUsername(), config.getPassword()));\n+            }\n+            scheduler.schedule(this::checkConnection, config.getPollingInterval(), TimeUnit.SECONDS);\n+\n+            logger.debug(\"Finished initializing WlanThermo Nano!\");\n+        } catch (URISyntaxException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"Failed to initialize WlanThermo Nano!\");\n+            logger.debug(\"Failed to initialize WlanThermo Nano!\", e);\n+        }\n+    }\n+\n+    private void checkConnection() {\n+        try {\n+            if (httpClient.GET(config.getUri()).getStatus() == 200) {\n+                updateStatus(ThingStatus.ONLINE);\n+                ScheduledFuture<?> oldScheduler = pollingScheduler;\n+                if (oldScheduler != null) {\n+                    oldScheduler.cancel(false);\n+                }\n+                pollingScheduler = scheduler.scheduleWithFixedDelay(this::update, 0, config.getPollingInterval(),\n+                        TimeUnit.SECONDS);\n+            } else {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                        \"WlanThermo not found under given address.\");\n+            }\n+        } catch (URISyntaxException | InterruptedException | ExecutionException | TimeoutException e) {\n+            logger.debug(\"Failed to connect.\", e);\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                    \"Could not connect to WlanThermo at \" + config.getIpAddress());\n+            ScheduledFuture<?> oldScheduler = pollingScheduler;\n+            if (oldScheduler != null) {\n+                oldScheduler.cancel(false);\n+            }\n+            pollingScheduler = scheduler.schedule(this::checkConnection, config.getPollingInterval(), TimeUnit.SECONDS);\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            State s = wlanThermoEsp32CommandHandler.getState(channelUID, data, settings);\n+            if (s != null)\n+                updateState(channelUID, s);\n+        } else {\n+            if (wlanThermoEsp32CommandHandler.setState(channelUID, command, data)) {\n+                logger.debug(\"Data updated, pushing changes\");\n+                push();\n+            } else {\n+                logger.debug(\"Could not handle command of type {} for channel {}!\",\n+                        command.getClass().toGenericString(), channelUID.getId());\n+            }\n+        }\n+    }\n+\n+    private void update() {\n+        try {\n+            // Update objects with data from device\n+            String json = httpClient.GET(config.getUri(\"/data\")).getContentAsString();\n+            data = gson.fromJson(json, Data.class);\n+            logger.debug(\"Received at /data: {}\", json);\n+            json = httpClient.GET(config.getUri(\"/settings\")).getContentAsString();\n+            settings = gson.fromJson(json, Settings.class);\n+            logger.debug(\"Received at /settings: {}\", json);\n+\n+            // Update Channels if required\n+            Map<String, String> properties = editProperties();\n+            Boolean pmEnabled = settings.getFeatures().getBluetooth();\n+            int pmChannels = pmEnabled ? data.getPitmaster().getPm().size() : 0;\n+            int tempChannels = data.getChannel().size();\n+\n+            // Update properties\n+            properties.put(WlanThermoBindingConstants.PROPERTY_MODEL, settings.getDevice().getDevice());\n+            properties.put(WlanThermoBindingConstants.PROPERTY_SERIAL, settings.getDevice().getSerial());\n+            properties.put(WlanThermoBindingConstants.PROPERTY_ESP32_BT_ENABLED,\n+                    settings.getFeatures().getBluetooth().toString());\n+            properties.put(WlanThermoBindingConstants.PROPERTY_ESP32_PM_ENABLED, pmEnabled.toString());\n+            properties.put(WlanThermoBindingConstants.PROPERTY_ESP32_TEMP_CHANNELS, String.valueOf(tempChannels));\n+            properties.put(WlanThermoBindingConstants.PROPERTY_ESP32_PM_CHANNELS, String.valueOf(pmChannels));\n+            updateProperties(properties);\n+\n+            // Update channel state\n+            for (Channel channel : thing.getChannels()) {\n+                State state = wlanThermoEsp32CommandHandler.getState(channel.getUID(), data, settings);\n+                if (state != null) {\n+                    updateState(channel.getUID(), state);\n+                } else {\n+                    // if we could not obtain a state, try trigger instead\n+                    String trigger = wlanThermoEsp32CommandHandler.getTrigger(channel.getUID(), data);\n+                    if (trigger != null) {\n+                        triggerChannel(channel.getUID(), trigger);\n+                    }\n+                }\n+            }\n+        } catch (URISyntaxException | InterruptedException | ExecutionException | TimeoutException e) {\n+            logger.debug(\"Update failed, checking connection\", e);\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, \"Update failed, reconnecting...\");\n+            ScheduledFuture<?> oldScheduler = pollingScheduler;\n+            if (oldScheduler != null) {\n+                oldScheduler.cancel(false);\n+            }\n+            for (Channel channel : thing.getChannels()) {\n+                updateState(channel.getUID(), UnDefType.UNDEF);\n+            }\n+            checkConnection();\n+        }\n+    }\n+\n+    private void push() {\n+        data.getChannel().forEach(c -> {\n+            try {\n+                String json = gson.toJson(c);\n+                logger.debug(\"Pushing: {}\", json);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDQ1NDcyNQ=="}, "originalCommit": {"oid": "1d8198157422913730de85f90ef717e523e063bd"}, "originalPosition": 192}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDc1MzUzMQ==", "bodyText": "Payload is now only logged if response code != 200", "url": "https://github.com/openhab/openhab-addons/pull/9579#discussion_r550753531", "createdAt": "2021-01-01T10:11:30Z", "author": {"login": "CSchlipp"}, "path": "bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/api/esp32/WlanThermoEsp32Handler.java", "diffHunk": "@@ -0,0 +1,222 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.wlanthermo.internal.api.esp32;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.Map;\n+import java.util.concurrent.*;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.Authentication;\n+import org.eclipse.jetty.client.api.AuthenticationStore;\n+import org.eclipse.jetty.client.util.DigestAuthentication;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants;\n+import org.openhab.binding.wlanthermo.internal.WlanThermoExtendedConfiguration;\n+import org.openhab.binding.wlanthermo.internal.api.esp32.data.Data;\n+import org.openhab.binding.wlanthermo.internal.api.esp32.settings.Settings;\n+import org.openhab.core.common.ThreadPoolManager;\n+import org.openhab.core.thing.*;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+\n+/**\n+ * The {@link WlanThermoEsp32Handler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Christian Schlipp - Initial contribution\n+ */\n+@NonNullByDefault\n+public class WlanThermoEsp32Handler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(WlanThermoEsp32Handler.class);\n+\n+    private WlanThermoExtendedConfiguration config = new WlanThermoExtendedConfiguration();\n+    private WlanThermoEsp32CommandHandler wlanThermoEsp32CommandHandler = new WlanThermoEsp32CommandHandler();\n+    private final HttpClient httpClient;\n+    private @Nullable ScheduledFuture<?> pollingScheduler;\n+    private final ScheduledExecutorService scheduler = ThreadPoolManager\n+            .getScheduledPool(WlanThermoBindingConstants.WLANTHERMO_THREAD_POOL);\n+    private final Gson gson = new Gson();\n+    private @Nullable Data data = new Data();\n+    private @Nullable Settings settings = new Settings();\n+\n+    public WlanThermoEsp32Handler(Thing thing, HttpClient httpClient) {\n+        super(thing);\n+        this.httpClient = httpClient;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Start initializing WlanThermo Nano!\");\n+        config = getConfigAs(WlanThermoExtendedConfiguration.class);\n+\n+        updateStatus(ThingStatus.UNKNOWN);\n+        try {\n+            if (config.getUsername() != null && !config.getUsername().isEmpty() && config.getPassword() != null\n+                    && !config.getPassword().isEmpty()) {\n+                AuthenticationStore authStore = httpClient.getAuthenticationStore();\n+                authStore.addAuthentication(new DigestAuthentication(config.getUri(), Authentication.ANY_REALM,\n+                        config.getUsername(), config.getPassword()));\n+            }\n+            scheduler.schedule(this::checkConnection, config.getPollingInterval(), TimeUnit.SECONDS);\n+\n+            logger.debug(\"Finished initializing WlanThermo Nano!\");\n+        } catch (URISyntaxException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"Failed to initialize WlanThermo Nano!\");\n+            logger.debug(\"Failed to initialize WlanThermo Nano!\", e);\n+        }\n+    }\n+\n+    private void checkConnection() {\n+        try {\n+            if (httpClient.GET(config.getUri()).getStatus() == 200) {\n+                updateStatus(ThingStatus.ONLINE);\n+                ScheduledFuture<?> oldScheduler = pollingScheduler;\n+                if (oldScheduler != null) {\n+                    oldScheduler.cancel(false);\n+                }\n+                pollingScheduler = scheduler.scheduleWithFixedDelay(this::update, 0, config.getPollingInterval(),\n+                        TimeUnit.SECONDS);\n+            } else {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                        \"WlanThermo not found under given address.\");\n+            }\n+        } catch (URISyntaxException | InterruptedException | ExecutionException | TimeoutException e) {\n+            logger.debug(\"Failed to connect.\", e);\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                    \"Could not connect to WlanThermo at \" + config.getIpAddress());\n+            ScheduledFuture<?> oldScheduler = pollingScheduler;\n+            if (oldScheduler != null) {\n+                oldScheduler.cancel(false);\n+            }\n+            pollingScheduler = scheduler.schedule(this::checkConnection, config.getPollingInterval(), TimeUnit.SECONDS);\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            State s = wlanThermoEsp32CommandHandler.getState(channelUID, data, settings);\n+            if (s != null)\n+                updateState(channelUID, s);\n+        } else {\n+            if (wlanThermoEsp32CommandHandler.setState(channelUID, command, data)) {\n+                logger.debug(\"Data updated, pushing changes\");\n+                push();\n+            } else {\n+                logger.debug(\"Could not handle command of type {} for channel {}!\",\n+                        command.getClass().toGenericString(), channelUID.getId());\n+            }\n+        }\n+    }\n+\n+    private void update() {\n+        try {\n+            // Update objects with data from device\n+            String json = httpClient.GET(config.getUri(\"/data\")).getContentAsString();\n+            data = gson.fromJson(json, Data.class);\n+            logger.debug(\"Received at /data: {}\", json);\n+            json = httpClient.GET(config.getUri(\"/settings\")).getContentAsString();\n+            settings = gson.fromJson(json, Settings.class);\n+            logger.debug(\"Received at /settings: {}\", json);\n+\n+            // Update Channels if required\n+            Map<String, String> properties = editProperties();\n+            Boolean pmEnabled = settings.getFeatures().getBluetooth();\n+            int pmChannels = pmEnabled ? data.getPitmaster().getPm().size() : 0;\n+            int tempChannels = data.getChannel().size();\n+\n+            // Update properties\n+            properties.put(WlanThermoBindingConstants.PROPERTY_MODEL, settings.getDevice().getDevice());\n+            properties.put(WlanThermoBindingConstants.PROPERTY_SERIAL, settings.getDevice().getSerial());\n+            properties.put(WlanThermoBindingConstants.PROPERTY_ESP32_BT_ENABLED,\n+                    settings.getFeatures().getBluetooth().toString());\n+            properties.put(WlanThermoBindingConstants.PROPERTY_ESP32_PM_ENABLED, pmEnabled.toString());\n+            properties.put(WlanThermoBindingConstants.PROPERTY_ESP32_TEMP_CHANNELS, String.valueOf(tempChannels));\n+            properties.put(WlanThermoBindingConstants.PROPERTY_ESP32_PM_CHANNELS, String.valueOf(pmChannels));\n+            updateProperties(properties);\n+\n+            // Update channel state\n+            for (Channel channel : thing.getChannels()) {\n+                State state = wlanThermoEsp32CommandHandler.getState(channel.getUID(), data, settings);\n+                if (state != null) {\n+                    updateState(channel.getUID(), state);\n+                } else {\n+                    // if we could not obtain a state, try trigger instead\n+                    String trigger = wlanThermoEsp32CommandHandler.getTrigger(channel.getUID(), data);\n+                    if (trigger != null) {\n+                        triggerChannel(channel.getUID(), trigger);\n+                    }\n+                }\n+            }\n+        } catch (URISyntaxException | InterruptedException | ExecutionException | TimeoutException e) {\n+            logger.debug(\"Update failed, checking connection\", e);\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, \"Update failed, reconnecting...\");\n+            ScheduledFuture<?> oldScheduler = pollingScheduler;\n+            if (oldScheduler != null) {\n+                oldScheduler.cancel(false);\n+            }\n+            for (Channel channel : thing.getChannels()) {\n+                updateState(channel.getUID(), UnDefType.UNDEF);\n+            }\n+            checkConnection();\n+        }\n+    }\n+\n+    private void push() {\n+        data.getChannel().forEach(c -> {\n+            try {\n+                String json = gson.toJson(c);\n+                logger.debug(\"Pushing: {}\", json);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDQ1NDcyNQ=="}, "originalCommit": {"oid": "1d8198157422913730de85f90ef717e523e063bd"}, "originalPosition": 192}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ2MzA4NDYwOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/api/esp32/WlanThermoEsp32Handler.java", "isResolved": true, "comments": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0zMVQxMDo0Njo0NlrOIM9H-Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wM1QxNTo0ODoxNVrOINftjg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDQ1NTI4OQ==", "bodyText": "BaseThingHandler provides a scheduler. Is there any reason not using that?", "url": "https://github.com/openhab/openhab-addons/pull/9579#discussion_r550455289", "createdAt": "2020-12-31T10:46:46Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/api/esp32/WlanThermoEsp32Handler.java", "diffHunk": "@@ -0,0 +1,222 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.wlanthermo.internal.api.esp32;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.Map;\n+import java.util.concurrent.*;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.Authentication;\n+import org.eclipse.jetty.client.api.AuthenticationStore;\n+import org.eclipse.jetty.client.util.DigestAuthentication;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants;\n+import org.openhab.binding.wlanthermo.internal.WlanThermoExtendedConfiguration;\n+import org.openhab.binding.wlanthermo.internal.api.esp32.data.Data;\n+import org.openhab.binding.wlanthermo.internal.api.esp32.settings.Settings;\n+import org.openhab.core.common.ThreadPoolManager;\n+import org.openhab.core.thing.*;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+\n+/**\n+ * The {@link WlanThermoEsp32Handler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Christian Schlipp - Initial contribution\n+ */\n+@NonNullByDefault\n+public class WlanThermoEsp32Handler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(WlanThermoEsp32Handler.class);\n+\n+    private WlanThermoExtendedConfiguration config = new WlanThermoExtendedConfiguration();\n+    private WlanThermoEsp32CommandHandler wlanThermoEsp32CommandHandler = new WlanThermoEsp32CommandHandler();\n+    private final HttpClient httpClient;\n+    private @Nullable ScheduledFuture<?> pollingScheduler;\n+    private final ScheduledExecutorService scheduler = ThreadPoolManager\n+            .getScheduledPool(WlanThermoBindingConstants.WLANTHERMO_THREAD_POOL);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1d8198157422913730de85f90ef717e523e063bd"}, "originalPosition": 59}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDQ2MjI5Nw==", "bodyText": "Ref. discussion in initial PR #8209, the scheduler from the BaseThingHandler constantly errored with RejectedExecutionExceptions. Wasn't able to track this down until now and went the same way as suggested for the Homematic binding in PR #1078", "url": "https://github.com/openhab/openhab-addons/pull/9579#discussion_r550462297", "createdAt": "2020-12-31T11:24:11Z", "author": {"login": "CSchlipp"}, "path": "bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/api/esp32/WlanThermoEsp32Handler.java", "diffHunk": "@@ -0,0 +1,222 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.wlanthermo.internal.api.esp32;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.Map;\n+import java.util.concurrent.*;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.Authentication;\n+import org.eclipse.jetty.client.api.AuthenticationStore;\n+import org.eclipse.jetty.client.util.DigestAuthentication;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants;\n+import org.openhab.binding.wlanthermo.internal.WlanThermoExtendedConfiguration;\n+import org.openhab.binding.wlanthermo.internal.api.esp32.data.Data;\n+import org.openhab.binding.wlanthermo.internal.api.esp32.settings.Settings;\n+import org.openhab.core.common.ThreadPoolManager;\n+import org.openhab.core.thing.*;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+\n+/**\n+ * The {@link WlanThermoEsp32Handler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Christian Schlipp - Initial contribution\n+ */\n+@NonNullByDefault\n+public class WlanThermoEsp32Handler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(WlanThermoEsp32Handler.class);\n+\n+    private WlanThermoExtendedConfiguration config = new WlanThermoExtendedConfiguration();\n+    private WlanThermoEsp32CommandHandler wlanThermoEsp32CommandHandler = new WlanThermoEsp32CommandHandler();\n+    private final HttpClient httpClient;\n+    private @Nullable ScheduledFuture<?> pollingScheduler;\n+    private final ScheduledExecutorService scheduler = ThreadPoolManager\n+            .getScheduledPool(WlanThermoBindingConstants.WLANTHERMO_THREAD_POOL);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDQ1NTI4OQ=="}, "originalCommit": {"oid": "1d8198157422913730de85f90ef717e523e063bd"}, "originalPosition": 59}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDQ2MzcyMg==", "bodyText": "AFAIK, these happen if the scheduler is shut-down. This should only happen if OH is shut-down. Can you provide a stack trace?", "url": "https://github.com/openhab/openhab-addons/pull/9579#discussion_r550463722", "createdAt": "2020-12-31T11:32:47Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/api/esp32/WlanThermoEsp32Handler.java", "diffHunk": "@@ -0,0 +1,222 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.wlanthermo.internal.api.esp32;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.Map;\n+import java.util.concurrent.*;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.Authentication;\n+import org.eclipse.jetty.client.api.AuthenticationStore;\n+import org.eclipse.jetty.client.util.DigestAuthentication;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants;\n+import org.openhab.binding.wlanthermo.internal.WlanThermoExtendedConfiguration;\n+import org.openhab.binding.wlanthermo.internal.api.esp32.data.Data;\n+import org.openhab.binding.wlanthermo.internal.api.esp32.settings.Settings;\n+import org.openhab.core.common.ThreadPoolManager;\n+import org.openhab.core.thing.*;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+\n+/**\n+ * The {@link WlanThermoEsp32Handler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Christian Schlipp - Initial contribution\n+ */\n+@NonNullByDefault\n+public class WlanThermoEsp32Handler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(WlanThermoEsp32Handler.class);\n+\n+    private WlanThermoExtendedConfiguration config = new WlanThermoExtendedConfiguration();\n+    private WlanThermoEsp32CommandHandler wlanThermoEsp32CommandHandler = new WlanThermoEsp32CommandHandler();\n+    private final HttpClient httpClient;\n+    private @Nullable ScheduledFuture<?> pollingScheduler;\n+    private final ScheduledExecutorService scheduler = ThreadPoolManager\n+            .getScheduledPool(WlanThermoBindingConstants.WLANTHERMO_THREAD_POOL);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDQ1NTI4OQ=="}, "originalCommit": {"oid": "1d8198157422913730de85f90ef717e523e063bd"}, "originalPosition": 59}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDc3MjEwNQ==", "bodyText": "I don't have any stack traces for the scheduler issue anymore, but will try to reproduce this issue again during my local testing.\nIs this a blocker for merging or can it be tackled later on?", "url": "https://github.com/openhab/openhab-addons/pull/9579#discussion_r550772105", "createdAt": "2021-01-01T14:09:17Z", "author": {"login": "CSchlipp"}, "path": "bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/api/esp32/WlanThermoEsp32Handler.java", "diffHunk": "@@ -0,0 +1,222 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.wlanthermo.internal.api.esp32;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.Map;\n+import java.util.concurrent.*;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.Authentication;\n+import org.eclipse.jetty.client.api.AuthenticationStore;\n+import org.eclipse.jetty.client.util.DigestAuthentication;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants;\n+import org.openhab.binding.wlanthermo.internal.WlanThermoExtendedConfiguration;\n+import org.openhab.binding.wlanthermo.internal.api.esp32.data.Data;\n+import org.openhab.binding.wlanthermo.internal.api.esp32.settings.Settings;\n+import org.openhab.core.common.ThreadPoolManager;\n+import org.openhab.core.thing.*;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+\n+/**\n+ * The {@link WlanThermoEsp32Handler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Christian Schlipp - Initial contribution\n+ */\n+@NonNullByDefault\n+public class WlanThermoEsp32Handler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(WlanThermoEsp32Handler.class);\n+\n+    private WlanThermoExtendedConfiguration config = new WlanThermoExtendedConfiguration();\n+    private WlanThermoEsp32CommandHandler wlanThermoEsp32CommandHandler = new WlanThermoEsp32CommandHandler();\n+    private final HttpClient httpClient;\n+    private @Nullable ScheduledFuture<?> pollingScheduler;\n+    private final ScheduledExecutorService scheduler = ThreadPoolManager\n+            .getScheduledPool(WlanThermoBindingConstants.WLANTHERMO_THREAD_POOL);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDQ1NTI4OQ=="}, "originalCommit": {"oid": "1d8198157422913730de85f90ef717e523e063bd"}, "originalPosition": 59}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDk4NDU2Nw==", "bodyText": "The RejectedExecution exception is only a symptom of a larger issue. We should at least identify the root cause before merging it.", "url": "https://github.com/openhab/openhab-addons/pull/9579#discussion_r550984567", "createdAt": "2021-01-03T10:06:29Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/api/esp32/WlanThermoEsp32Handler.java", "diffHunk": "@@ -0,0 +1,222 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.wlanthermo.internal.api.esp32;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.Map;\n+import java.util.concurrent.*;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.Authentication;\n+import org.eclipse.jetty.client.api.AuthenticationStore;\n+import org.eclipse.jetty.client.util.DigestAuthentication;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants;\n+import org.openhab.binding.wlanthermo.internal.WlanThermoExtendedConfiguration;\n+import org.openhab.binding.wlanthermo.internal.api.esp32.data.Data;\n+import org.openhab.binding.wlanthermo.internal.api.esp32.settings.Settings;\n+import org.openhab.core.common.ThreadPoolManager;\n+import org.openhab.core.thing.*;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+\n+/**\n+ * The {@link WlanThermoEsp32Handler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Christian Schlipp - Initial contribution\n+ */\n+@NonNullByDefault\n+public class WlanThermoEsp32Handler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(WlanThermoEsp32Handler.class);\n+\n+    private WlanThermoExtendedConfiguration config = new WlanThermoExtendedConfiguration();\n+    private WlanThermoEsp32CommandHandler wlanThermoEsp32CommandHandler = new WlanThermoEsp32CommandHandler();\n+    private final HttpClient httpClient;\n+    private @Nullable ScheduledFuture<?> pollingScheduler;\n+    private final ScheduledExecutorService scheduler = ThreadPoolManager\n+            .getScheduledPool(WlanThermoBindingConstants.WLANTHERMO_THREAD_POOL);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDQ1NTI4OQ=="}, "originalCommit": {"oid": "1d8198157422913730de85f90ef717e523e063bd"}, "originalPosition": 59}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTAxNzA3Ng==", "bodyText": "Okay, I'll do some local tests to check if I can still reproduce this error in OH V3.x.", "url": "https://github.com/openhab/openhab-addons/pull/9579#discussion_r551017076", "createdAt": "2021-01-03T15:04:43Z", "author": {"login": "CSchlipp"}, "path": "bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/api/esp32/WlanThermoEsp32Handler.java", "diffHunk": "@@ -0,0 +1,222 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.wlanthermo.internal.api.esp32;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.Map;\n+import java.util.concurrent.*;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.Authentication;\n+import org.eclipse.jetty.client.api.AuthenticationStore;\n+import org.eclipse.jetty.client.util.DigestAuthentication;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants;\n+import org.openhab.binding.wlanthermo.internal.WlanThermoExtendedConfiguration;\n+import org.openhab.binding.wlanthermo.internal.api.esp32.data.Data;\n+import org.openhab.binding.wlanthermo.internal.api.esp32.settings.Settings;\n+import org.openhab.core.common.ThreadPoolManager;\n+import org.openhab.core.thing.*;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+\n+/**\n+ * The {@link WlanThermoEsp32Handler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Christian Schlipp - Initial contribution\n+ */\n+@NonNullByDefault\n+public class WlanThermoEsp32Handler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(WlanThermoEsp32Handler.class);\n+\n+    private WlanThermoExtendedConfiguration config = new WlanThermoExtendedConfiguration();\n+    private WlanThermoEsp32CommandHandler wlanThermoEsp32CommandHandler = new WlanThermoEsp32CommandHandler();\n+    private final HttpClient httpClient;\n+    private @Nullable ScheduledFuture<?> pollingScheduler;\n+    private final ScheduledExecutorService scheduler = ThreadPoolManager\n+            .getScheduledPool(WlanThermoBindingConstants.WLANTHERMO_THREAD_POOL);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDQ1NTI4OQ=="}, "originalCommit": {"oid": "1d8198157422913730de85f90ef717e523e063bd"}, "originalPosition": 59}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTAyMTUzNA==", "bodyText": "Stupid me - I think the error was a combination of the default scheduler shutting down and me not correctly cancelling all scheduled futures when disposing the things.\nI was missing an assignment during the initialization and therefore has some orphaned tasks still running. This is fixed now, it's either the checkConnection or the update task running, but never more than one at the same time.\nI couldn't reproduce the error anymore, nor is the thing handler anymore complaining about updated to the thing after it got disposed. Pretty confident that this solved the issue!", "url": "https://github.com/openhab/openhab-addons/pull/9579#discussion_r551021534", "createdAt": "2021-01-03T15:44:56Z", "author": {"login": "CSchlipp"}, "path": "bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/api/esp32/WlanThermoEsp32Handler.java", "diffHunk": "@@ -0,0 +1,222 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.wlanthermo.internal.api.esp32;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.Map;\n+import java.util.concurrent.*;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.Authentication;\n+import org.eclipse.jetty.client.api.AuthenticationStore;\n+import org.eclipse.jetty.client.util.DigestAuthentication;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants;\n+import org.openhab.binding.wlanthermo.internal.WlanThermoExtendedConfiguration;\n+import org.openhab.binding.wlanthermo.internal.api.esp32.data.Data;\n+import org.openhab.binding.wlanthermo.internal.api.esp32.settings.Settings;\n+import org.openhab.core.common.ThreadPoolManager;\n+import org.openhab.core.thing.*;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+\n+/**\n+ * The {@link WlanThermoEsp32Handler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Christian Schlipp - Initial contribution\n+ */\n+@NonNullByDefault\n+public class WlanThermoEsp32Handler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(WlanThermoEsp32Handler.class);\n+\n+    private WlanThermoExtendedConfiguration config = new WlanThermoExtendedConfiguration();\n+    private WlanThermoEsp32CommandHandler wlanThermoEsp32CommandHandler = new WlanThermoEsp32CommandHandler();\n+    private final HttpClient httpClient;\n+    private @Nullable ScheduledFuture<?> pollingScheduler;\n+    private final ScheduledExecutorService scheduler = ThreadPoolManager\n+            .getScheduledPool(WlanThermoBindingConstants.WLANTHERMO_THREAD_POOL);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDQ1NTI4OQ=="}, "originalCommit": {"oid": "1d8198157422913730de85f90ef717e523e063bd"}, "originalPosition": 59}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTAyMTk2Ng==", "bodyText": "Sounds good!", "url": "https://github.com/openhab/openhab-addons/pull/9579#discussion_r551021966", "createdAt": "2021-01-03T15:48:15Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/api/esp32/WlanThermoEsp32Handler.java", "diffHunk": "@@ -0,0 +1,222 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.wlanthermo.internal.api.esp32;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.Map;\n+import java.util.concurrent.*;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.Authentication;\n+import org.eclipse.jetty.client.api.AuthenticationStore;\n+import org.eclipse.jetty.client.util.DigestAuthentication;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants;\n+import org.openhab.binding.wlanthermo.internal.WlanThermoExtendedConfiguration;\n+import org.openhab.binding.wlanthermo.internal.api.esp32.data.Data;\n+import org.openhab.binding.wlanthermo.internal.api.esp32.settings.Settings;\n+import org.openhab.core.common.ThreadPoolManager;\n+import org.openhab.core.thing.*;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+\n+/**\n+ * The {@link WlanThermoEsp32Handler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Christian Schlipp - Initial contribution\n+ */\n+@NonNullByDefault\n+public class WlanThermoEsp32Handler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(WlanThermoEsp32Handler.class);\n+\n+    private WlanThermoExtendedConfiguration config = new WlanThermoExtendedConfiguration();\n+    private WlanThermoEsp32CommandHandler wlanThermoEsp32CommandHandler = new WlanThermoEsp32CommandHandler();\n+    private final HttpClient httpClient;\n+    private @Nullable ScheduledFuture<?> pollingScheduler;\n+    private final ScheduledExecutorService scheduler = ThreadPoolManager\n+            .getScheduledPool(WlanThermoBindingConstants.WLANTHERMO_THREAD_POOL);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDQ1NTI4OQ=="}, "originalCommit": {"oid": "1d8198157422913730de85f90ef717e523e063bd"}, "originalPosition": 59}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ2MzA4NTQzOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/api/esp32/data/Channel.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0zMVQxMDo0NzoxNlrOIM9IZA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0zMVQxMzo1ODoyOVrOIM_Kmg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDQ1NTM5Ng==", "bodyText": "You could move this into a package called dto or append DTO to the class name to get rid of the checkstyle warning about missing NonNullByDefault annotation.", "url": "https://github.com/openhab/openhab-addons/pull/9579#discussion_r550455396", "createdAt": "2020-12-31T10:47:16Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/api/esp32/data/Channel.java", "diffHunk": "@@ -0,0 +1,125 @@\n+\n+package org.openhab.binding.wlanthermo.internal.api.esp32.data;\n+\n+import com.google.gson.annotations.Expose;\n+import com.google.gson.annotations.SerializedName;\n+\n+/**\n+ * This DTO is used to parse the JSON\n+ * Class is auto-generated from JSON using http://www.jsonschema2pojo.org/\n+ *\n+ * @author Christian Schlipp - Initial contribution\n+ */\n+public class Channel {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1d8198157422913730de85f90ef717e523e063bd"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDQ4ODczMA==", "bodyText": "Good to know, done!", "url": "https://github.com/openhab/openhab-addons/pull/9579#discussion_r550488730", "createdAt": "2020-12-31T13:58:29Z", "author": {"login": "CSchlipp"}, "path": "bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/api/esp32/data/Channel.java", "diffHunk": "@@ -0,0 +1,125 @@\n+\n+package org.openhab.binding.wlanthermo.internal.api.esp32.data;\n+\n+import com.google.gson.annotations.Expose;\n+import com.google.gson.annotations.SerializedName;\n+\n+/**\n+ * This DTO is used to parse the JSON\n+ * Class is auto-generated from JSON using http://www.jsonschema2pojo.org/\n+ *\n+ * @author Christian Schlipp - Initial contribution\n+ */\n+public class Channel {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDQ1NTM5Ng=="}, "originalCommit": {"oid": "1d8198157422913730de85f90ef717e523e063bd"}, "originalPosition": 13}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ2MzA4ODY5OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.wlanthermo/src/main/resources/OH-INF/thing/channel-types.xml", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0zMVQxMDo0OTo0M1rOIM9KNA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0zMVQxMDo0OTo0M1rOIM9KNA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDQ1NTg2MA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\t<label>Openhab Alarm Trigger</label>\n          \n          \n            \n            \t\t<label>OpenHAB Alarm Trigger</label>", "url": "https://github.com/openhab/openhab-addons/pull/9579#discussion_r550455860", "createdAt": "2020-12-31T10:49:43Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.wlanthermo/src/main/resources/OH-INF/thing/channel-types.xml", "diffHunk": "@@ -0,0 +1,261 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"wlanthermo\"\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\t<channel-type id=\"cpu_load\" advanced=\"true\">\n+\t\t<item-type>Number</item-type>\n+\t\t<label>CPU Load</label>\n+\t\t<state readOnly=\"true\"/>\n+\t</channel-type>\n+\n+\t<channel-type id=\"name\" advanced=\"false\">\n+\t\t<item-type>String</item-type>\n+\t\t<label>Probe Name</label>\n+\t\t<category>Text</category>\n+\t</channel-type>\n+\n+\t<channel-type id=\"name_ro\" advanced=\"false\">\n+\t\t<item-type>String</item-type>\n+\t\t<label>Probe Name</label>\n+\t\t<category>Text</category>\n+\t\t<state readOnly=\"true\"/>\n+\t</channel-type>\n+\n+\t<channel-type id=\"typ\" advanced=\"true\">\n+\t\t<item-type>String</item-type>\n+\t\t<label>Probe Type</label>\n+\t\t<category>Text</category>\n+\t\t<state readOnly=\"true\"/>\n+\t</channel-type>\n+\n+\t<channel-type id=\"temperature\" advanced=\"false\">\n+\t\t<item-type>Number:Temperature</item-type>\n+\t\t<label>Current Temperature</label>\n+\t\t<category>Temperature</category>\n+\t\t<state min=\"0\" pattern=\"%.1f %unit%\" readOnly=\"true\"/>\n+\t</channel-type>\n+\n+\t<channel-type id=\"temperature_min\" advanced=\"true\">\n+\t\t<item-type>Number:Temperature</item-type>\n+\t\t<label>Low Temperature Alarm</label>\n+\t\t<category>Temperature</category>\n+\t\t<state min=\"0\" step=\"0.1\" pattern=\"%.1f %unit%\" readOnly=\"false\"/>\n+\t</channel-type>\n+\n+\t<channel-type id=\"temperature_max\" advanced=\"true\">\n+\t\t<item-type>Number:Temperature</item-type>\n+\t\t<label>High Temperature Alarm</label>\n+\t\t<category>Temperature</category>\n+\t\t<state min=\"0\" step=\"0.1\" pattern=\"%.1f %unit%\" readOnly=\"false\"/>\n+\t</channel-type>\n+\n+\t<channel-type id=\"temperature_min_ro\" advanced=\"true\">\n+\t\t<item-type>Number:Temperature</item-type>\n+\t\t<label>Low Temperature Alarm</label>\n+\t\t<category>Temperature</category>\n+\t\t<state min=\"0\" step=\"0.1\" pattern=\"%.1f %unit%\" readOnly=\"true\"/>\n+\t</channel-type>\n+\n+\t<channel-type id=\"temperature_max_ro\" advanced=\"true\">\n+\t\t<item-type>Number:Temperature</item-type>\n+\t\t<label>High Temperature Alarm</label>\n+\t\t<category>Temperature</category>\n+\t\t<state min=\"0\" step=\"0.1\" pattern=\"%.1f %unit%\" readOnly=\"true\"/>\n+\t</channel-type>\n+\n+\t<channel-type id=\"alarm_device\" advanced=\"true\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Alarm Buzzer</label>\n+\t\t<category>Switch</category>\n+\t</channel-type>\n+\n+\t<channel-type id=\"alarm_device_ro\" advanced=\"true\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Alarm Buzzer</label>\n+\t\t<category>Switch</category>\n+\t\t<state readOnly=\"true\"/>\n+\t</channel-type>\n+\n+\t<channel-type id=\"alarm_push\" advanced=\"true\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Push-Alarm</label>\n+\t\t<category>Switch</category>\n+\t</channel-type>\n+\n+\t<channel-type id=\"alarm_openhab\" advanced=\"true\">\n+\t\t<kind>trigger</kind>\n+\t\t<label>Openhab Alarm Trigger</label>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1d8198157422913730de85f90ef717e523e063bd"}, "originalPosition": 88}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ2MzA4OTY0OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.wlanthermo/src/main/resources/OH-INF/thing/channel-types.xml", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0zMVQxMDo1MDoyMVrOIM9Kug==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0zMVQxMToyNToyMVrOIM9kLA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDQ1NTk5NA==", "bodyText": "Do you mean pink?", "url": "https://github.com/openhab/openhab-addons/pull/9579#discussion_r550455994", "createdAt": "2020-12-31T10:50:21Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.wlanthermo/src/main/resources/OH-INF/thing/channel-types.xml", "diffHunk": "@@ -0,0 +1,261 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"wlanthermo\"\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\t<channel-type id=\"cpu_load\" advanced=\"true\">\n+\t\t<item-type>Number</item-type>\n+\t\t<label>CPU Load</label>\n+\t\t<state readOnly=\"true\"/>\n+\t</channel-type>\n+\n+\t<channel-type id=\"name\" advanced=\"false\">\n+\t\t<item-type>String</item-type>\n+\t\t<label>Probe Name</label>\n+\t\t<category>Text</category>\n+\t</channel-type>\n+\n+\t<channel-type id=\"name_ro\" advanced=\"false\">\n+\t\t<item-type>String</item-type>\n+\t\t<label>Probe Name</label>\n+\t\t<category>Text</category>\n+\t\t<state readOnly=\"true\"/>\n+\t</channel-type>\n+\n+\t<channel-type id=\"typ\" advanced=\"true\">\n+\t\t<item-type>String</item-type>\n+\t\t<label>Probe Type</label>\n+\t\t<category>Text</category>\n+\t\t<state readOnly=\"true\"/>\n+\t</channel-type>\n+\n+\t<channel-type id=\"temperature\" advanced=\"false\">\n+\t\t<item-type>Number:Temperature</item-type>\n+\t\t<label>Current Temperature</label>\n+\t\t<category>Temperature</category>\n+\t\t<state min=\"0\" pattern=\"%.1f %unit%\" readOnly=\"true\"/>\n+\t</channel-type>\n+\n+\t<channel-type id=\"temperature_min\" advanced=\"true\">\n+\t\t<item-type>Number:Temperature</item-type>\n+\t\t<label>Low Temperature Alarm</label>\n+\t\t<category>Temperature</category>\n+\t\t<state min=\"0\" step=\"0.1\" pattern=\"%.1f %unit%\" readOnly=\"false\"/>\n+\t</channel-type>\n+\n+\t<channel-type id=\"temperature_max\" advanced=\"true\">\n+\t\t<item-type>Number:Temperature</item-type>\n+\t\t<label>High Temperature Alarm</label>\n+\t\t<category>Temperature</category>\n+\t\t<state min=\"0\" step=\"0.1\" pattern=\"%.1f %unit%\" readOnly=\"false\"/>\n+\t</channel-type>\n+\n+\t<channel-type id=\"temperature_min_ro\" advanced=\"true\">\n+\t\t<item-type>Number:Temperature</item-type>\n+\t\t<label>Low Temperature Alarm</label>\n+\t\t<category>Temperature</category>\n+\t\t<state min=\"0\" step=\"0.1\" pattern=\"%.1f %unit%\" readOnly=\"true\"/>\n+\t</channel-type>\n+\n+\t<channel-type id=\"temperature_max_ro\" advanced=\"true\">\n+\t\t<item-type>Number:Temperature</item-type>\n+\t\t<label>High Temperature Alarm</label>\n+\t\t<category>Temperature</category>\n+\t\t<state min=\"0\" step=\"0.1\" pattern=\"%.1f %unit%\" readOnly=\"true\"/>\n+\t</channel-type>\n+\n+\t<channel-type id=\"alarm_device\" advanced=\"true\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Alarm Buzzer</label>\n+\t\t<category>Switch</category>\n+\t</channel-type>\n+\n+\t<channel-type id=\"alarm_device_ro\" advanced=\"true\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Alarm Buzzer</label>\n+\t\t<category>Switch</category>\n+\t\t<state readOnly=\"true\"/>\n+\t</channel-type>\n+\n+\t<channel-type id=\"alarm_push\" advanced=\"true\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Push-Alarm</label>\n+\t\t<category>Switch</category>\n+\t</channel-type>\n+\n+\t<channel-type id=\"alarm_openhab\" advanced=\"true\">\n+\t\t<kind>trigger</kind>\n+\t\t<label>Openhab Alarm Trigger</label>\n+\t\t<event>\n+\t\t\t<options>\n+\t\t\t\t<option value=\"MIN\">Low Temperature Alarm</option>\n+\t\t\t\t<option value=\"MAX\">High Temperature Alarm</option>\n+\t\t\t</options>\n+\t\t</event>\n+\t</channel-type>\n+\n+\t<channel-type id=\"alarm_openhab_low\" advanced=\"false\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Low Temperature Alarm</label>\n+\t\t<state readOnly=\"true\"/>\n+\t</channel-type>\n+\n+\t<channel-type id=\"alarm_openhab_high\" advanced=\"false\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>High Temperature Alarm</label>\n+\t\t<state readOnly=\"true\"/>\n+\t</channel-type>\n+\n+\t<channel-type id=\"color\" advanced=\"true\">\n+\t\t<item-type>Color</item-type>\n+\t\t<label>Color</label>\n+\t\t<category>Colorpicker</category>\n+\t\t<state readOnly=\"true\"/>\n+\t</channel-type>\n+\n+\t<channel-type id=\"color_name_nano\" advanced=\"true\">\n+\t\t<item-type>String</item-type>\n+\t\t<label>Probe Color</label>\n+\t\t<category>Colorpicker</category>\n+\t\t<state>\n+\t\t\t<options>\n+\t\t\t\t<option value=\"niagara\">Niagara</option>\n+\t\t\t\t<option value=\"rosa\">Rosa</option>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1d8198157422913730de85f90ef717e523e063bd"}, "originalPosition": 123}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDQ2MjUwOA==", "bodyText": "Color names are given by WlanThermo implementation", "url": "https://github.com/openhab/openhab-addons/pull/9579#discussion_r550462508", "createdAt": "2020-12-31T11:25:21Z", "author": {"login": "CSchlipp"}, "path": "bundles/org.openhab.binding.wlanthermo/src/main/resources/OH-INF/thing/channel-types.xml", "diffHunk": "@@ -0,0 +1,261 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"wlanthermo\"\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\t<channel-type id=\"cpu_load\" advanced=\"true\">\n+\t\t<item-type>Number</item-type>\n+\t\t<label>CPU Load</label>\n+\t\t<state readOnly=\"true\"/>\n+\t</channel-type>\n+\n+\t<channel-type id=\"name\" advanced=\"false\">\n+\t\t<item-type>String</item-type>\n+\t\t<label>Probe Name</label>\n+\t\t<category>Text</category>\n+\t</channel-type>\n+\n+\t<channel-type id=\"name_ro\" advanced=\"false\">\n+\t\t<item-type>String</item-type>\n+\t\t<label>Probe Name</label>\n+\t\t<category>Text</category>\n+\t\t<state readOnly=\"true\"/>\n+\t</channel-type>\n+\n+\t<channel-type id=\"typ\" advanced=\"true\">\n+\t\t<item-type>String</item-type>\n+\t\t<label>Probe Type</label>\n+\t\t<category>Text</category>\n+\t\t<state readOnly=\"true\"/>\n+\t</channel-type>\n+\n+\t<channel-type id=\"temperature\" advanced=\"false\">\n+\t\t<item-type>Number:Temperature</item-type>\n+\t\t<label>Current Temperature</label>\n+\t\t<category>Temperature</category>\n+\t\t<state min=\"0\" pattern=\"%.1f %unit%\" readOnly=\"true\"/>\n+\t</channel-type>\n+\n+\t<channel-type id=\"temperature_min\" advanced=\"true\">\n+\t\t<item-type>Number:Temperature</item-type>\n+\t\t<label>Low Temperature Alarm</label>\n+\t\t<category>Temperature</category>\n+\t\t<state min=\"0\" step=\"0.1\" pattern=\"%.1f %unit%\" readOnly=\"false\"/>\n+\t</channel-type>\n+\n+\t<channel-type id=\"temperature_max\" advanced=\"true\">\n+\t\t<item-type>Number:Temperature</item-type>\n+\t\t<label>High Temperature Alarm</label>\n+\t\t<category>Temperature</category>\n+\t\t<state min=\"0\" step=\"0.1\" pattern=\"%.1f %unit%\" readOnly=\"false\"/>\n+\t</channel-type>\n+\n+\t<channel-type id=\"temperature_min_ro\" advanced=\"true\">\n+\t\t<item-type>Number:Temperature</item-type>\n+\t\t<label>Low Temperature Alarm</label>\n+\t\t<category>Temperature</category>\n+\t\t<state min=\"0\" step=\"0.1\" pattern=\"%.1f %unit%\" readOnly=\"true\"/>\n+\t</channel-type>\n+\n+\t<channel-type id=\"temperature_max_ro\" advanced=\"true\">\n+\t\t<item-type>Number:Temperature</item-type>\n+\t\t<label>High Temperature Alarm</label>\n+\t\t<category>Temperature</category>\n+\t\t<state min=\"0\" step=\"0.1\" pattern=\"%.1f %unit%\" readOnly=\"true\"/>\n+\t</channel-type>\n+\n+\t<channel-type id=\"alarm_device\" advanced=\"true\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Alarm Buzzer</label>\n+\t\t<category>Switch</category>\n+\t</channel-type>\n+\n+\t<channel-type id=\"alarm_device_ro\" advanced=\"true\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Alarm Buzzer</label>\n+\t\t<category>Switch</category>\n+\t\t<state readOnly=\"true\"/>\n+\t</channel-type>\n+\n+\t<channel-type id=\"alarm_push\" advanced=\"true\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Push-Alarm</label>\n+\t\t<category>Switch</category>\n+\t</channel-type>\n+\n+\t<channel-type id=\"alarm_openhab\" advanced=\"true\">\n+\t\t<kind>trigger</kind>\n+\t\t<label>Openhab Alarm Trigger</label>\n+\t\t<event>\n+\t\t\t<options>\n+\t\t\t\t<option value=\"MIN\">Low Temperature Alarm</option>\n+\t\t\t\t<option value=\"MAX\">High Temperature Alarm</option>\n+\t\t\t</options>\n+\t\t</event>\n+\t</channel-type>\n+\n+\t<channel-type id=\"alarm_openhab_low\" advanced=\"false\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Low Temperature Alarm</label>\n+\t\t<state readOnly=\"true\"/>\n+\t</channel-type>\n+\n+\t<channel-type id=\"alarm_openhab_high\" advanced=\"false\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>High Temperature Alarm</label>\n+\t\t<state readOnly=\"true\"/>\n+\t</channel-type>\n+\n+\t<channel-type id=\"color\" advanced=\"true\">\n+\t\t<item-type>Color</item-type>\n+\t\t<label>Color</label>\n+\t\t<category>Colorpicker</category>\n+\t\t<state readOnly=\"true\"/>\n+\t</channel-type>\n+\n+\t<channel-type id=\"color_name_nano\" advanced=\"true\">\n+\t\t<item-type>String</item-type>\n+\t\t<label>Probe Color</label>\n+\t\t<category>Colorpicker</category>\n+\t\t<state>\n+\t\t\t<options>\n+\t\t\t\t<option value=\"niagara\">Niagara</option>\n+\t\t\t\t<option value=\"rosa\">Rosa</option>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDQ1NTk5NA=="}, "originalCommit": {"oid": "1d8198157422913730de85f90ef717e523e063bd"}, "originalPosition": 123}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ2MzA5MDIyOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.wlanthermo/src/main/resources/OH-INF/thing/channel-types.xml", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0zMVQxMDo1MDo1MVrOIM9LEA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0zMVQxMDo1MDo1MVrOIM9LEA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDQ1NjA4MA==", "bodyText": "Labels are expected to be as short as possible. Guideline is 2-3 words with max 20-25 chars. See https://www.openhab.org/docs/developer/bindings/thing-xml.html#formatting-labels-and-descriptions\nPlease check all.", "url": "https://github.com/openhab/openhab-addons/pull/9579#discussion_r550456080", "createdAt": "2020-12-31T10:50:51Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.wlanthermo/src/main/resources/OH-INF/thing/channel-types.xml", "diffHunk": "@@ -0,0 +1,261 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"wlanthermo\"\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\t<channel-type id=\"cpu_load\" advanced=\"true\">\n+\t\t<item-type>Number</item-type>\n+\t\t<label>CPU Load</label>\n+\t\t<state readOnly=\"true\"/>\n+\t</channel-type>\n+\n+\t<channel-type id=\"name\" advanced=\"false\">\n+\t\t<item-type>String</item-type>\n+\t\t<label>Probe Name</label>\n+\t\t<category>Text</category>\n+\t</channel-type>\n+\n+\t<channel-type id=\"name_ro\" advanced=\"false\">\n+\t\t<item-type>String</item-type>\n+\t\t<label>Probe Name</label>\n+\t\t<category>Text</category>\n+\t\t<state readOnly=\"true\"/>\n+\t</channel-type>\n+\n+\t<channel-type id=\"typ\" advanced=\"true\">\n+\t\t<item-type>String</item-type>\n+\t\t<label>Probe Type</label>\n+\t\t<category>Text</category>\n+\t\t<state readOnly=\"true\"/>\n+\t</channel-type>\n+\n+\t<channel-type id=\"temperature\" advanced=\"false\">\n+\t\t<item-type>Number:Temperature</item-type>\n+\t\t<label>Current Temperature</label>\n+\t\t<category>Temperature</category>\n+\t\t<state min=\"0\" pattern=\"%.1f %unit%\" readOnly=\"true\"/>\n+\t</channel-type>\n+\n+\t<channel-type id=\"temperature_min\" advanced=\"true\">\n+\t\t<item-type>Number:Temperature</item-type>\n+\t\t<label>Low Temperature Alarm</label>\n+\t\t<category>Temperature</category>\n+\t\t<state min=\"0\" step=\"0.1\" pattern=\"%.1f %unit%\" readOnly=\"false\"/>\n+\t</channel-type>\n+\n+\t<channel-type id=\"temperature_max\" advanced=\"true\">\n+\t\t<item-type>Number:Temperature</item-type>\n+\t\t<label>High Temperature Alarm</label>\n+\t\t<category>Temperature</category>\n+\t\t<state min=\"0\" step=\"0.1\" pattern=\"%.1f %unit%\" readOnly=\"false\"/>\n+\t</channel-type>\n+\n+\t<channel-type id=\"temperature_min_ro\" advanced=\"true\">\n+\t\t<item-type>Number:Temperature</item-type>\n+\t\t<label>Low Temperature Alarm</label>\n+\t\t<category>Temperature</category>\n+\t\t<state min=\"0\" step=\"0.1\" pattern=\"%.1f %unit%\" readOnly=\"true\"/>\n+\t</channel-type>\n+\n+\t<channel-type id=\"temperature_max_ro\" advanced=\"true\">\n+\t\t<item-type>Number:Temperature</item-type>\n+\t\t<label>High Temperature Alarm</label>\n+\t\t<category>Temperature</category>\n+\t\t<state min=\"0\" step=\"0.1\" pattern=\"%.1f %unit%\" readOnly=\"true\"/>\n+\t</channel-type>\n+\n+\t<channel-type id=\"alarm_device\" advanced=\"true\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Alarm Buzzer</label>\n+\t\t<category>Switch</category>\n+\t</channel-type>\n+\n+\t<channel-type id=\"alarm_device_ro\" advanced=\"true\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Alarm Buzzer</label>\n+\t\t<category>Switch</category>\n+\t\t<state readOnly=\"true\"/>\n+\t</channel-type>\n+\n+\t<channel-type id=\"alarm_push\" advanced=\"true\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Push-Alarm</label>\n+\t\t<category>Switch</category>\n+\t</channel-type>\n+\n+\t<channel-type id=\"alarm_openhab\" advanced=\"true\">\n+\t\t<kind>trigger</kind>\n+\t\t<label>Openhab Alarm Trigger</label>\n+\t\t<event>\n+\t\t\t<options>\n+\t\t\t\t<option value=\"MIN\">Low Temperature Alarm</option>\n+\t\t\t\t<option value=\"MAX\">High Temperature Alarm</option>\n+\t\t\t</options>\n+\t\t</event>\n+\t</channel-type>\n+\n+\t<channel-type id=\"alarm_openhab_low\" advanced=\"false\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Low Temperature Alarm</label>\n+\t\t<state readOnly=\"true\"/>\n+\t</channel-type>\n+\n+\t<channel-type id=\"alarm_openhab_high\" advanced=\"false\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>High Temperature Alarm</label>\n+\t\t<state readOnly=\"true\"/>\n+\t</channel-type>\n+\n+\t<channel-type id=\"color\" advanced=\"true\">\n+\t\t<item-type>Color</item-type>\n+\t\t<label>Color</label>\n+\t\t<category>Colorpicker</category>\n+\t\t<state readOnly=\"true\"/>\n+\t</channel-type>\n+\n+\t<channel-type id=\"color_name_nano\" advanced=\"true\">\n+\t\t<item-type>String</item-type>\n+\t\t<label>Probe Color</label>\n+\t\t<category>Colorpicker</category>\n+\t\t<state>\n+\t\t\t<options>\n+\t\t\t\t<option value=\"niagara\">Niagara</option>\n+\t\t\t\t<option value=\"rosa\">Rosa</option>\n+\t\t\t\t<option value=\"lapis blue\">Lapis Blue</option>\n+\t\t\t\t<option value=\"orange\">Orange</option>\n+\t\t\t\t<option value=\"lila\">Lila</option>\n+\t\t\t\t<option value=\"red\">Red</option>\n+\t\t\t\t<option value=\"green\">Green</option>\n+\t\t\t\t<option value=\"gold\">Gold</option>\n+\t\t\t\t<option value=\"kale\">Kale</option>\n+\t\t\t\t<option value=\"brown\">Brown</option>\n+\t\t\t</options>\n+\t\t</state>\n+\t</channel-type>\n+\n+\t<channel-type id=\"color_name_esp32\" advanced=\"true\">\n+\t\t<item-type>String</item-type>\n+\t\t<label>Probe Color</label>\n+\t\t<category>Colorpicker</category>\n+\t\t<state>\n+\t\t\t<options>\n+\t\t\t\t<option value=\"#FFFF00\">yellow</option>\n+\t\t\t\t<option value=\"#FFC002\">dark yellow</option>\n+\t\t\t\t<option value=\"#00FF00\">green</option>\n+\t\t\t\t<option value=\"#FFFFFF\">white</option>\n+\t\t\t\t<option value=\"#FF1DC4\">pink</option>\n+\t\t\t\t<option value=\"#E46C0A\">orange</option>\n+\t\t\t\t<option value=\"#C3D69B\">olive</option>\n+\t\t\t\t<option value=\"#0FE6F1\">light blue</option>\n+\t\t\t\t<option value=\"#0000FF\">blue</option>\n+\t\t\t\t<option value=\"#03A923\">dark green</option>\n+\t\t\t\t<option value=\"#C84B32\">brown</option>\n+\t\t\t\t<option value=\"#FF9B69\">light brown</option>\n+\t\t\t\t<option value=\"#5082BE\">dark blue</option>\n+\t\t\t\t<option value=\"#FFB1D0\">light pink</option>\n+\t\t\t\t<option value=\"#A6EF03\">light green</option>\n+\t\t\t\t<option value=\"#D42A6B\">dark pink</option>\n+\t\t\t\t<option value=\"#FFDA8F\">beige</option>\n+\t\t\t\t<option value=\"#00B0F0\">azure</option>\n+\t\t\t\t<option value=\"#948A54\">dark olive</option>\n+\t\t\t</options>\n+\t\t</state>\n+\t</channel-type>\n+\n+\t<channel-type id=\"color_ro\" advanced=\"true\">\n+\t\t<item-type>Color</item-type>\n+\t\t<label>Probe Color</label>\n+\t\t<category>Colorpicker</category>\n+\t\t<state readOnly=\"true\"/>\n+\t</channel-type>\n+\n+\t<channel-type id=\"color_name_mini_ro\" advanced=\"true\">\n+\t\t<item-type>String</item-type>\n+\t\t<label>Probe Color Name</label>\n+\t\t<category>Text</category>\n+\t\t<state readOnly=\"true\"/>\n+\t</channel-type>\n+\n+\t<channel-type id=\"enabled\" advanced=\"false\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Pitmaster Enabled</label>\n+\t\t<state readOnly=\"true\"/>\n+\t</channel-type>\n+\n+\t<channel-type id=\"temperature_setpoint_ro\" advanced=\"false\">\n+\t\t<item-type>Number:Temperature</item-type>\n+\t\t<label>Pitmaster Setpoint Temperature</label>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1d8198157422913730de85f90ef717e523e063bd"}, "originalPosition": 187}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ2MzA5MTI5OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.wlanthermo/src/main/resources/OH-INF/thing/channel-types.xml", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0zMVQxMDo1MTozMFrOIM9Lpw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0zMVQxMDo1MTozMFrOIM9Lpw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDQ1NjIzMQ==", "bodyText": "Can this be either removed or checked if it's supported?", "url": "https://github.com/openhab/openhab-addons/pull/9579#discussion_r550456231", "createdAt": "2020-12-31T10:51:30Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.wlanthermo/src/main/resources/OH-INF/thing/channel-types.xml", "diffHunk": "@@ -0,0 +1,261 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"wlanthermo\"\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\t<channel-type id=\"cpu_load\" advanced=\"true\">\n+\t\t<item-type>Number</item-type>\n+\t\t<label>CPU Load</label>\n+\t\t<state readOnly=\"true\"/>\n+\t</channel-type>\n+\n+\t<channel-type id=\"name\" advanced=\"false\">\n+\t\t<item-type>String</item-type>\n+\t\t<label>Probe Name</label>\n+\t\t<category>Text</category>\n+\t</channel-type>\n+\n+\t<channel-type id=\"name_ro\" advanced=\"false\">\n+\t\t<item-type>String</item-type>\n+\t\t<label>Probe Name</label>\n+\t\t<category>Text</category>\n+\t\t<state readOnly=\"true\"/>\n+\t</channel-type>\n+\n+\t<channel-type id=\"typ\" advanced=\"true\">\n+\t\t<item-type>String</item-type>\n+\t\t<label>Probe Type</label>\n+\t\t<category>Text</category>\n+\t\t<state readOnly=\"true\"/>\n+\t</channel-type>\n+\n+\t<channel-type id=\"temperature\" advanced=\"false\">\n+\t\t<item-type>Number:Temperature</item-type>\n+\t\t<label>Current Temperature</label>\n+\t\t<category>Temperature</category>\n+\t\t<state min=\"0\" pattern=\"%.1f %unit%\" readOnly=\"true\"/>\n+\t</channel-type>\n+\n+\t<channel-type id=\"temperature_min\" advanced=\"true\">\n+\t\t<item-type>Number:Temperature</item-type>\n+\t\t<label>Low Temperature Alarm</label>\n+\t\t<category>Temperature</category>\n+\t\t<state min=\"0\" step=\"0.1\" pattern=\"%.1f %unit%\" readOnly=\"false\"/>\n+\t</channel-type>\n+\n+\t<channel-type id=\"temperature_max\" advanced=\"true\">\n+\t\t<item-type>Number:Temperature</item-type>\n+\t\t<label>High Temperature Alarm</label>\n+\t\t<category>Temperature</category>\n+\t\t<state min=\"0\" step=\"0.1\" pattern=\"%.1f %unit%\" readOnly=\"false\"/>\n+\t</channel-type>\n+\n+\t<channel-type id=\"temperature_min_ro\" advanced=\"true\">\n+\t\t<item-type>Number:Temperature</item-type>\n+\t\t<label>Low Temperature Alarm</label>\n+\t\t<category>Temperature</category>\n+\t\t<state min=\"0\" step=\"0.1\" pattern=\"%.1f %unit%\" readOnly=\"true\"/>\n+\t</channel-type>\n+\n+\t<channel-type id=\"temperature_max_ro\" advanced=\"true\">\n+\t\t<item-type>Number:Temperature</item-type>\n+\t\t<label>High Temperature Alarm</label>\n+\t\t<category>Temperature</category>\n+\t\t<state min=\"0\" step=\"0.1\" pattern=\"%.1f %unit%\" readOnly=\"true\"/>\n+\t</channel-type>\n+\n+\t<channel-type id=\"alarm_device\" advanced=\"true\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Alarm Buzzer</label>\n+\t\t<category>Switch</category>\n+\t</channel-type>\n+\n+\t<channel-type id=\"alarm_device_ro\" advanced=\"true\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Alarm Buzzer</label>\n+\t\t<category>Switch</category>\n+\t\t<state readOnly=\"true\"/>\n+\t</channel-type>\n+\n+\t<channel-type id=\"alarm_push\" advanced=\"true\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Push-Alarm</label>\n+\t\t<category>Switch</category>\n+\t</channel-type>\n+\n+\t<channel-type id=\"alarm_openhab\" advanced=\"true\">\n+\t\t<kind>trigger</kind>\n+\t\t<label>Openhab Alarm Trigger</label>\n+\t\t<event>\n+\t\t\t<options>\n+\t\t\t\t<option value=\"MIN\">Low Temperature Alarm</option>\n+\t\t\t\t<option value=\"MAX\">High Temperature Alarm</option>\n+\t\t\t</options>\n+\t\t</event>\n+\t</channel-type>\n+\n+\t<channel-type id=\"alarm_openhab_low\" advanced=\"false\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Low Temperature Alarm</label>\n+\t\t<state readOnly=\"true\"/>\n+\t</channel-type>\n+\n+\t<channel-type id=\"alarm_openhab_high\" advanced=\"false\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>High Temperature Alarm</label>\n+\t\t<state readOnly=\"true\"/>\n+\t</channel-type>\n+\n+\t<channel-type id=\"color\" advanced=\"true\">\n+\t\t<item-type>Color</item-type>\n+\t\t<label>Color</label>\n+\t\t<category>Colorpicker</category>\n+\t\t<state readOnly=\"true\"/>\n+\t</channel-type>\n+\n+\t<channel-type id=\"color_name_nano\" advanced=\"true\">\n+\t\t<item-type>String</item-type>\n+\t\t<label>Probe Color</label>\n+\t\t<category>Colorpicker</category>\n+\t\t<state>\n+\t\t\t<options>\n+\t\t\t\t<option value=\"niagara\">Niagara</option>\n+\t\t\t\t<option value=\"rosa\">Rosa</option>\n+\t\t\t\t<option value=\"lapis blue\">Lapis Blue</option>\n+\t\t\t\t<option value=\"orange\">Orange</option>\n+\t\t\t\t<option value=\"lila\">Lila</option>\n+\t\t\t\t<option value=\"red\">Red</option>\n+\t\t\t\t<option value=\"green\">Green</option>\n+\t\t\t\t<option value=\"gold\">Gold</option>\n+\t\t\t\t<option value=\"kale\">Kale</option>\n+\t\t\t\t<option value=\"brown\">Brown</option>\n+\t\t\t</options>\n+\t\t</state>\n+\t</channel-type>\n+\n+\t<channel-type id=\"color_name_esp32\" advanced=\"true\">\n+\t\t<item-type>String</item-type>\n+\t\t<label>Probe Color</label>\n+\t\t<category>Colorpicker</category>\n+\t\t<state>\n+\t\t\t<options>\n+\t\t\t\t<option value=\"#FFFF00\">yellow</option>\n+\t\t\t\t<option value=\"#FFC002\">dark yellow</option>\n+\t\t\t\t<option value=\"#00FF00\">green</option>\n+\t\t\t\t<option value=\"#FFFFFF\">white</option>\n+\t\t\t\t<option value=\"#FF1DC4\">pink</option>\n+\t\t\t\t<option value=\"#E46C0A\">orange</option>\n+\t\t\t\t<option value=\"#C3D69B\">olive</option>\n+\t\t\t\t<option value=\"#0FE6F1\">light blue</option>\n+\t\t\t\t<option value=\"#0000FF\">blue</option>\n+\t\t\t\t<option value=\"#03A923\">dark green</option>\n+\t\t\t\t<option value=\"#C84B32\">brown</option>\n+\t\t\t\t<option value=\"#FF9B69\">light brown</option>\n+\t\t\t\t<option value=\"#5082BE\">dark blue</option>\n+\t\t\t\t<option value=\"#FFB1D0\">light pink</option>\n+\t\t\t\t<option value=\"#A6EF03\">light green</option>\n+\t\t\t\t<option value=\"#D42A6B\">dark pink</option>\n+\t\t\t\t<option value=\"#FFDA8F\">beige</option>\n+\t\t\t\t<option value=\"#00B0F0\">azure</option>\n+\t\t\t\t<option value=\"#948A54\">dark olive</option>\n+\t\t\t</options>\n+\t\t</state>\n+\t</channel-type>\n+\n+\t<channel-type id=\"color_ro\" advanced=\"true\">\n+\t\t<item-type>Color</item-type>\n+\t\t<label>Probe Color</label>\n+\t\t<category>Colorpicker</category>\n+\t\t<state readOnly=\"true\"/>\n+\t</channel-type>\n+\n+\t<channel-type id=\"color_name_mini_ro\" advanced=\"true\">\n+\t\t<item-type>String</item-type>\n+\t\t<label>Probe Color Name</label>\n+\t\t<category>Text</category>\n+\t\t<state readOnly=\"true\"/>\n+\t</channel-type>\n+\n+\t<channel-type id=\"enabled\" advanced=\"false\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Pitmaster Enabled</label>\n+\t\t<state readOnly=\"true\"/>\n+\t</channel-type>\n+\n+\t<channel-type id=\"temperature_setpoint_ro\" advanced=\"false\">\n+\t\t<item-type>Number:Temperature</item-type>\n+\t\t<label>Pitmaster Setpoint Temperature</label>\n+\t\t<category>Temperature</category>\n+\t\t<state min=\"0\" pattern=\"%.1f %unit%\" readOnly=\"true\"/>\n+\t</channel-type>\n+\n+\t<channel-type id=\"duty_cycle_ro\" advanced=\"false\">\n+\t\t<item-type>Number</item-type>\n+\t\t<label>Pitmaster Duty Cycle / Control Out</label>\n+\t\t<state min=\"0\" max=\"100\" pattern=\"%d\" readOnly=\"true\"/>\n+\t</channel-type>\n+\n+\t<channel-type id=\"lid_open\" advanced=\"false\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Pitmaster Lid Open</label>\n+\t\t<state readOnly=\"true\"/>\n+\t</channel-type>\n+\n+\t<channel-type id=\"channel_id_ro\" advanced=\"false\">\n+\t\t<item-type>Number</item-type>\n+\t\t<label>Pitmaster Channel ID</label>\n+\t\t<state min=\"0\" max=\"9\" pattern=\"%d\" readOnly=\"true\"/>\n+\t</channel-type>\n+\n+\t<channel-type id=\"pitmaster_type\" advanced=\"false\">\n+\t\t<item-type>String</item-type>\n+\t\t<label>Pitmaster State</label>\n+\t\t<state>\n+\t\t\t<options>\n+\t\t\t\t<option value=\"off\">Off</option>\n+\t\t\t\t<option value=\"manual\">Manual</option>\n+\t\t\t\t<option value=\"auto\">Auto</option>\n+\t\t\t\t<!--<option value=\"autotune\">Autotune</option> Not clear if still supported -->", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1d8198157422913730de85f90ef717e523e063bd"}, "originalPosition": 218}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ2MzA5NTU0OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.wlanthermo/src/main/resources/OH-INF/thing/channel-types.xml", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0zMVQxMDo1NDo0M1rOIM9OBg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0zMVQxMDo1NDo0M1rOIM9OBg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDQ1NjgzOA==", "bodyText": "You could make this Number:Power and use Units.DECIBEL_MILLIWATTS.", "url": "https://github.com/openhab/openhab-addons/pull/9579#discussion_r550456838", "createdAt": "2020-12-31T10:54:43Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.wlanthermo/src/main/resources/OH-INF/thing/channel-types.xml", "diffHunk": "@@ -0,0 +1,261 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"wlanthermo\"\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\t<channel-type id=\"cpu_load\" advanced=\"true\">\n+\t\t<item-type>Number</item-type>\n+\t\t<label>CPU Load</label>\n+\t\t<state readOnly=\"true\"/>\n+\t</channel-type>\n+\n+\t<channel-type id=\"name\" advanced=\"false\">\n+\t\t<item-type>String</item-type>\n+\t\t<label>Probe Name</label>\n+\t\t<category>Text</category>\n+\t</channel-type>\n+\n+\t<channel-type id=\"name_ro\" advanced=\"false\">\n+\t\t<item-type>String</item-type>\n+\t\t<label>Probe Name</label>\n+\t\t<category>Text</category>\n+\t\t<state readOnly=\"true\"/>\n+\t</channel-type>\n+\n+\t<channel-type id=\"typ\" advanced=\"true\">\n+\t\t<item-type>String</item-type>\n+\t\t<label>Probe Type</label>\n+\t\t<category>Text</category>\n+\t\t<state readOnly=\"true\"/>\n+\t</channel-type>\n+\n+\t<channel-type id=\"temperature\" advanced=\"false\">\n+\t\t<item-type>Number:Temperature</item-type>\n+\t\t<label>Current Temperature</label>\n+\t\t<category>Temperature</category>\n+\t\t<state min=\"0\" pattern=\"%.1f %unit%\" readOnly=\"true\"/>\n+\t</channel-type>\n+\n+\t<channel-type id=\"temperature_min\" advanced=\"true\">\n+\t\t<item-type>Number:Temperature</item-type>\n+\t\t<label>Low Temperature Alarm</label>\n+\t\t<category>Temperature</category>\n+\t\t<state min=\"0\" step=\"0.1\" pattern=\"%.1f %unit%\" readOnly=\"false\"/>\n+\t</channel-type>\n+\n+\t<channel-type id=\"temperature_max\" advanced=\"true\">\n+\t\t<item-type>Number:Temperature</item-type>\n+\t\t<label>High Temperature Alarm</label>\n+\t\t<category>Temperature</category>\n+\t\t<state min=\"0\" step=\"0.1\" pattern=\"%.1f %unit%\" readOnly=\"false\"/>\n+\t</channel-type>\n+\n+\t<channel-type id=\"temperature_min_ro\" advanced=\"true\">\n+\t\t<item-type>Number:Temperature</item-type>\n+\t\t<label>Low Temperature Alarm</label>\n+\t\t<category>Temperature</category>\n+\t\t<state min=\"0\" step=\"0.1\" pattern=\"%.1f %unit%\" readOnly=\"true\"/>\n+\t</channel-type>\n+\n+\t<channel-type id=\"temperature_max_ro\" advanced=\"true\">\n+\t\t<item-type>Number:Temperature</item-type>\n+\t\t<label>High Temperature Alarm</label>\n+\t\t<category>Temperature</category>\n+\t\t<state min=\"0\" step=\"0.1\" pattern=\"%.1f %unit%\" readOnly=\"true\"/>\n+\t</channel-type>\n+\n+\t<channel-type id=\"alarm_device\" advanced=\"true\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Alarm Buzzer</label>\n+\t\t<category>Switch</category>\n+\t</channel-type>\n+\n+\t<channel-type id=\"alarm_device_ro\" advanced=\"true\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Alarm Buzzer</label>\n+\t\t<category>Switch</category>\n+\t\t<state readOnly=\"true\"/>\n+\t</channel-type>\n+\n+\t<channel-type id=\"alarm_push\" advanced=\"true\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Push-Alarm</label>\n+\t\t<category>Switch</category>\n+\t</channel-type>\n+\n+\t<channel-type id=\"alarm_openhab\" advanced=\"true\">\n+\t\t<kind>trigger</kind>\n+\t\t<label>Openhab Alarm Trigger</label>\n+\t\t<event>\n+\t\t\t<options>\n+\t\t\t\t<option value=\"MIN\">Low Temperature Alarm</option>\n+\t\t\t\t<option value=\"MAX\">High Temperature Alarm</option>\n+\t\t\t</options>\n+\t\t</event>\n+\t</channel-type>\n+\n+\t<channel-type id=\"alarm_openhab_low\" advanced=\"false\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Low Temperature Alarm</label>\n+\t\t<state readOnly=\"true\"/>\n+\t</channel-type>\n+\n+\t<channel-type id=\"alarm_openhab_high\" advanced=\"false\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>High Temperature Alarm</label>\n+\t\t<state readOnly=\"true\"/>\n+\t</channel-type>\n+\n+\t<channel-type id=\"color\" advanced=\"true\">\n+\t\t<item-type>Color</item-type>\n+\t\t<label>Color</label>\n+\t\t<category>Colorpicker</category>\n+\t\t<state readOnly=\"true\"/>\n+\t</channel-type>\n+\n+\t<channel-type id=\"color_name_nano\" advanced=\"true\">\n+\t\t<item-type>String</item-type>\n+\t\t<label>Probe Color</label>\n+\t\t<category>Colorpicker</category>\n+\t\t<state>\n+\t\t\t<options>\n+\t\t\t\t<option value=\"niagara\">Niagara</option>\n+\t\t\t\t<option value=\"rosa\">Rosa</option>\n+\t\t\t\t<option value=\"lapis blue\">Lapis Blue</option>\n+\t\t\t\t<option value=\"orange\">Orange</option>\n+\t\t\t\t<option value=\"lila\">Lila</option>\n+\t\t\t\t<option value=\"red\">Red</option>\n+\t\t\t\t<option value=\"green\">Green</option>\n+\t\t\t\t<option value=\"gold\">Gold</option>\n+\t\t\t\t<option value=\"kale\">Kale</option>\n+\t\t\t\t<option value=\"brown\">Brown</option>\n+\t\t\t</options>\n+\t\t</state>\n+\t</channel-type>\n+\n+\t<channel-type id=\"color_name_esp32\" advanced=\"true\">\n+\t\t<item-type>String</item-type>\n+\t\t<label>Probe Color</label>\n+\t\t<category>Colorpicker</category>\n+\t\t<state>\n+\t\t\t<options>\n+\t\t\t\t<option value=\"#FFFF00\">yellow</option>\n+\t\t\t\t<option value=\"#FFC002\">dark yellow</option>\n+\t\t\t\t<option value=\"#00FF00\">green</option>\n+\t\t\t\t<option value=\"#FFFFFF\">white</option>\n+\t\t\t\t<option value=\"#FF1DC4\">pink</option>\n+\t\t\t\t<option value=\"#E46C0A\">orange</option>\n+\t\t\t\t<option value=\"#C3D69B\">olive</option>\n+\t\t\t\t<option value=\"#0FE6F1\">light blue</option>\n+\t\t\t\t<option value=\"#0000FF\">blue</option>\n+\t\t\t\t<option value=\"#03A923\">dark green</option>\n+\t\t\t\t<option value=\"#C84B32\">brown</option>\n+\t\t\t\t<option value=\"#FF9B69\">light brown</option>\n+\t\t\t\t<option value=\"#5082BE\">dark blue</option>\n+\t\t\t\t<option value=\"#FFB1D0\">light pink</option>\n+\t\t\t\t<option value=\"#A6EF03\">light green</option>\n+\t\t\t\t<option value=\"#D42A6B\">dark pink</option>\n+\t\t\t\t<option value=\"#FFDA8F\">beige</option>\n+\t\t\t\t<option value=\"#00B0F0\">azure</option>\n+\t\t\t\t<option value=\"#948A54\">dark olive</option>\n+\t\t\t</options>\n+\t\t</state>\n+\t</channel-type>\n+\n+\t<channel-type id=\"color_ro\" advanced=\"true\">\n+\t\t<item-type>Color</item-type>\n+\t\t<label>Probe Color</label>\n+\t\t<category>Colorpicker</category>\n+\t\t<state readOnly=\"true\"/>\n+\t</channel-type>\n+\n+\t<channel-type id=\"color_name_mini_ro\" advanced=\"true\">\n+\t\t<item-type>String</item-type>\n+\t\t<label>Probe Color Name</label>\n+\t\t<category>Text</category>\n+\t\t<state readOnly=\"true\"/>\n+\t</channel-type>\n+\n+\t<channel-type id=\"enabled\" advanced=\"false\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Pitmaster Enabled</label>\n+\t\t<state readOnly=\"true\"/>\n+\t</channel-type>\n+\n+\t<channel-type id=\"temperature_setpoint_ro\" advanced=\"false\">\n+\t\t<item-type>Number:Temperature</item-type>\n+\t\t<label>Pitmaster Setpoint Temperature</label>\n+\t\t<category>Temperature</category>\n+\t\t<state min=\"0\" pattern=\"%.1f %unit%\" readOnly=\"true\"/>\n+\t</channel-type>\n+\n+\t<channel-type id=\"duty_cycle_ro\" advanced=\"false\">\n+\t\t<item-type>Number</item-type>\n+\t\t<label>Pitmaster Duty Cycle / Control Out</label>\n+\t\t<state min=\"0\" max=\"100\" pattern=\"%d\" readOnly=\"true\"/>\n+\t</channel-type>\n+\n+\t<channel-type id=\"lid_open\" advanced=\"false\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Pitmaster Lid Open</label>\n+\t\t<state readOnly=\"true\"/>\n+\t</channel-type>\n+\n+\t<channel-type id=\"channel_id_ro\" advanced=\"false\">\n+\t\t<item-type>Number</item-type>\n+\t\t<label>Pitmaster Channel ID</label>\n+\t\t<state min=\"0\" max=\"9\" pattern=\"%d\" readOnly=\"true\"/>\n+\t</channel-type>\n+\n+\t<channel-type id=\"pitmaster_type\" advanced=\"false\">\n+\t\t<item-type>String</item-type>\n+\t\t<label>Pitmaster State</label>\n+\t\t<state>\n+\t\t\t<options>\n+\t\t\t\t<option value=\"off\">Off</option>\n+\t\t\t\t<option value=\"manual\">Manual</option>\n+\t\t\t\t<option value=\"auto\">Auto</option>\n+\t\t\t\t<!--<option value=\"autotune\">Autotune</option> Not clear if still supported -->\n+\t\t\t</options>\n+\t\t</state>\n+\t</channel-type>\n+\n+\t<channel-type id=\"duty_cycle\" advanced=\"false\">\n+\t\t<item-type>Number</item-type>\n+\t\t<label>Pitmaster Duty Cycle / Control Out</label>\n+\t\t<state min=\"0\" max=\"100\" pattern=\"%d\"/>\n+\t</channel-type>\n+\n+\t<channel-type id=\"pid_id\" advanced=\"false\">\n+\t\t<item-type>Number</item-type>\n+\t\t<label>PID Profile ID</label>\n+\t\t<state pattern=\"%d\"/>\n+\t</channel-type>\n+\n+\t<channel-type id=\"temperature_setpoint\" advanced=\"false\">\n+\t\t<item-type>Number:Temperature</item-type>\n+\t\t<label>Pitmaster Setpoint Temperature</label>\n+\t\t<category>Temperature</category>\n+\t\t<state min=\"0\" pattern=\"%.1f %unit%\"/>\n+\t</channel-type>\n+\n+\t<channel-type id=\"channel_id\" advanced=\"false\">\n+\t\t<item-type>Number</item-type>\n+\t\t<label>Pitmaster Channel ID</label>\n+\t\t<state min=\"1\" max=\"8\" pattern=\"%d\"/>\n+\t</channel-type>\n+\n+\t<channel-type id=\"charging\" advanced=\"true\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Charging</label>\n+\t\t<category>Energy</category>\n+\t\t<state readOnly=\"true\"/>\n+\t</channel-type>\n+\n+\t<channel-type id=\"rssi\" advanced=\"true\">\n+\t\t<item-type>Number</item-type>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1d8198157422913730de85f90ef717e523e063bd"}, "originalPosition": 256}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ2MzA5NzY5OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.wlanthermo/src/main/resources/OH-INF/thing/thing-types-mini.xml", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0zMVQxMDo1NjoxMFrOIM9PKw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0zMVQxMDo1NjoxMFrOIM9PKw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDQ1NzEzMQ==", "bodyText": "Labels are expected to be as short as possible. Guideline is 2-3 words with max 20-25 chars. See https://www.openhab.org/docs/developer/bindings/thing-xml.html#formatting-labels-and-descriptions", "url": "https://github.com/openhab/openhab-addons/pull/9579#discussion_r550457131", "createdAt": "2020-12-31T10:56:10Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.wlanthermo/src/main/resources/OH-INF/thing/thing-types-mini.xml", "diffHunk": "@@ -0,0 +1,79 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"wlanthermo\"\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\n+\n+\t<thing-type id=\"mini\">\n+\t\t<label>WlanThermo Mini V1/V2 (Raspberry Pi)</label>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1d8198157422913730de85f90ef717e523e063bd"}, "originalPosition": 9}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ4MDAxMTEzOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/api/esp32/UtilEsp32.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNlQxOTo0NDo1NVrOIPT9yw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNlQxOTo0NDo1NVrOIPT9yw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjkyNjY2Nw==", "bodyText": "Please add @NonNullByDefault", "url": "https://github.com/openhab/openhab-addons/pull/9579#discussion_r552926667", "createdAt": "2021-01-06T19:44:55Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/api/esp32/UtilEsp32.java", "diffHunk": "@@ -0,0 +1,82 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.wlanthermo.internal.api.esp32;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+/**\n+ * The {@link UtilEsp32} class provides conversion functions for the WlanThermo Nano V3\n+ *\n+ * @author Christian Schlipp - Initial contribution\n+ */\n+public class UtilEsp32 {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aff5cb5d1d4586abbf71161d45993b63d09ab438"}, "originalPosition": 23}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ4MDAxNDM1OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/api/esp32/WlanThermoEsp32CommandHandler.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNlQxOTo0NTo1N1rOIPT_wQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNlQxOTo0NTo1N1rOIPT_wQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjkyNzE2OQ==", "bodyText": "Please add @NonNullByDefault", "url": "https://github.com/openhab/openhab-addons/pull/9579#discussion_r552927169", "createdAt": "2021-01-06T19:45:57Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/api/esp32/WlanThermoEsp32CommandHandler.java", "diffHunk": "@@ -0,0 +1,298 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.wlanthermo.internal.api.esp32;\n+\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.*;\n+\n+import java.awt.Color;\n+import java.math.BigInteger;\n+import java.util.List;\n+\n+import javax.measure.Unit;\n+import javax.measure.quantity.Temperature;\n+\n+import org.openhab.binding.wlanthermo.internal.api.esp32.dto.data.Channel;\n+import org.openhab.binding.wlanthermo.internal.api.esp32.dto.data.Data;\n+import org.openhab.binding.wlanthermo.internal.api.esp32.dto.data.Pm;\n+import org.openhab.binding.wlanthermo.internal.api.esp32.dto.data.System;\n+import org.openhab.binding.wlanthermo.internal.api.esp32.dto.settings.Settings;\n+import org.openhab.core.library.types.*;\n+import org.openhab.core.library.unit.ImperialUnits;\n+import org.openhab.core.library.unit.SIUnits;\n+import org.openhab.core.library.unit.Units;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.UnDefType;\n+\n+/**\n+ * The {@link WlanThermoEsp32CommandHandler} is responsible for mapping the Commands to the respective data fields\n+ * of the API.\n+ *\n+ * @author Christian Schlipp - Initial contribution\n+ */\n+public class WlanThermoEsp32CommandHandler {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aff5cb5d1d4586abbf71161d45993b63d09ab438"}, "originalPosition": 44}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ4MDAxNjMxOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/api/esp32/WlanThermoEsp32CommandHandler.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNlQxOTo0NjoyMlrOIPUA7A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNlQxOTo0NjoyMlrOIPUA7A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjkyNzQ2OA==", "bodyText": "You should make this DecimalType instances static final fields so you can reuse them.", "url": "https://github.com/openhab/openhab-addons/pull/9579#discussion_r552927468", "createdAt": "2021-01-06T19:46:22Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/api/esp32/WlanThermoEsp32CommandHandler.java", "diffHunk": "@@ -0,0 +1,298 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.wlanthermo.internal.api.esp32;\n+\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.*;\n+\n+import java.awt.Color;\n+import java.math.BigInteger;\n+import java.util.List;\n+\n+import javax.measure.Unit;\n+import javax.measure.quantity.Temperature;\n+\n+import org.openhab.binding.wlanthermo.internal.api.esp32.dto.data.Channel;\n+import org.openhab.binding.wlanthermo.internal.api.esp32.dto.data.Data;\n+import org.openhab.binding.wlanthermo.internal.api.esp32.dto.data.Pm;\n+import org.openhab.binding.wlanthermo.internal.api.esp32.dto.data.System;\n+import org.openhab.binding.wlanthermo.internal.api.esp32.dto.settings.Settings;\n+import org.openhab.core.library.types.*;\n+import org.openhab.core.library.unit.ImperialUnits;\n+import org.openhab.core.library.unit.SIUnits;\n+import org.openhab.core.library.unit.Units;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.UnDefType;\n+\n+/**\n+ * The {@link WlanThermoEsp32CommandHandler} is responsible for mapping the Commands to the respective data fields\n+ * of the API.\n+ *\n+ * @author Christian Schlipp - Initial contribution\n+ */\n+public class WlanThermoEsp32CommandHandler {\n+\n+    public State getState(ChannelUID channelUID, Data data, Settings settings) {\n+        State state = null;\n+\n+        String groupId = channelUID.getGroupId();\n+        if (groupId == null || data == null || settings == null) {\n+            return null;\n+        }\n+\n+        System system = data.getSystem();\n+\n+        Unit<Temperature> unit;\n+        if (system.getUnit().equals(\"F\")) {\n+            unit = ImperialUnits.FAHRENHEIT;\n+        } else {\n+            // Default to Celsius\n+            unit = SIUnits.CELSIUS;\n+        }\n+\n+        List<Channel> channel = data.getChannel();\n+        if (\"system\".equals(groupId)) {\n+            switch (channelUID.getIdWithoutGroup()) {\n+                case SYSTEM_SOC:\n+                    if (system.getSoc() != null) {\n+                        state = new DecimalType(system.getSoc());\n+                    } else {\n+                        state = UnDefType.UNDEF;\n+                    }\n+                    break;\n+                case SYSTEM_CHARGE:\n+                    if (system.getCharge() != null) {\n+                        state = OnOffType.from(system.getCharge());\n+                    } else {\n+                        state = UnDefType.UNDEF;\n+                    }\n+                    break;\n+                case SYSTEM_RSSI_SIGNALSTRENGTH:\n+                    int dbm = system.getRssi();\n+                    if (dbm >= -80) {\n+                        state = new DecimalType(4);\n+                    } else if (dbm >= -95) {\n+                        state = new DecimalType(3);\n+                    } else if (dbm >= -105) {\n+                        state = new DecimalType(2);\n+                    } else {\n+                        state = new DecimalType(1);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aff5cb5d1d4586abbf71161d45993b63d09ab438"}, "originalPosition": 90}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ4MDAyMzc3OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/api/esp32/WlanThermoEsp32CommandHandler.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNlQxOTo0OToxMlrOIPUFgQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNlQxOTo0OToxMlrOIPUFgQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjkyODY0MQ==", "bodyText": "Please cache channel.get(channelId) to a local variable.", "url": "https://github.com/openhab/openhab-addons/pull/9579#discussion_r552928641", "createdAt": "2021-01-06T19:49:12Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/api/esp32/WlanThermoEsp32CommandHandler.java", "diffHunk": "@@ -0,0 +1,298 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.wlanthermo.internal.api.esp32;\n+\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.*;\n+\n+import java.awt.Color;\n+import java.math.BigInteger;\n+import java.util.List;\n+\n+import javax.measure.Unit;\n+import javax.measure.quantity.Temperature;\n+\n+import org.openhab.binding.wlanthermo.internal.api.esp32.dto.data.Channel;\n+import org.openhab.binding.wlanthermo.internal.api.esp32.dto.data.Data;\n+import org.openhab.binding.wlanthermo.internal.api.esp32.dto.data.Pm;\n+import org.openhab.binding.wlanthermo.internal.api.esp32.dto.data.System;\n+import org.openhab.binding.wlanthermo.internal.api.esp32.dto.settings.Settings;\n+import org.openhab.core.library.types.*;\n+import org.openhab.core.library.unit.ImperialUnits;\n+import org.openhab.core.library.unit.SIUnits;\n+import org.openhab.core.library.unit.Units;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.UnDefType;\n+\n+/**\n+ * The {@link WlanThermoEsp32CommandHandler} is responsible for mapping the Commands to the respective data fields\n+ * of the API.\n+ *\n+ * @author Christian Schlipp - Initial contribution\n+ */\n+public class WlanThermoEsp32CommandHandler {\n+\n+    public State getState(ChannelUID channelUID, Data data, Settings settings) {\n+        State state = null;\n+\n+        String groupId = channelUID.getGroupId();\n+        if (groupId == null || data == null || settings == null) {\n+            return null;\n+        }\n+\n+        System system = data.getSystem();\n+\n+        Unit<Temperature> unit;\n+        if (system.getUnit().equals(\"F\")) {\n+            unit = ImperialUnits.FAHRENHEIT;\n+        } else {\n+            // Default to Celsius\n+            unit = SIUnits.CELSIUS;\n+        }\n+\n+        List<Channel> channel = data.getChannel();\n+        if (\"system\".equals(groupId)) {\n+            switch (channelUID.getIdWithoutGroup()) {\n+                case SYSTEM_SOC:\n+                    if (system.getSoc() != null) {\n+                        state = new DecimalType(system.getSoc());\n+                    } else {\n+                        state = UnDefType.UNDEF;\n+                    }\n+                    break;\n+                case SYSTEM_CHARGE:\n+                    if (system.getCharge() != null) {\n+                        state = OnOffType.from(system.getCharge());\n+                    } else {\n+                        state = UnDefType.UNDEF;\n+                    }\n+                    break;\n+                case SYSTEM_RSSI_SIGNALSTRENGTH:\n+                    int dbm = system.getRssi();\n+                    if (dbm >= -80) {\n+                        state = new DecimalType(4);\n+                    } else if (dbm >= -95) {\n+                        state = new DecimalType(3);\n+                    } else if (dbm >= -105) {\n+                        state = new DecimalType(2);\n+                    } else {\n+                        state = new DecimalType(1);\n+                    }\n+                    break;\n+                case SYSTEM_RSSI:\n+                    state = new QuantityType<>(system.getRssi(), Units.DECIBEL_MILLIWATTS);\n+                    break;\n+            }\n+        } else if (channelUID.getId().startsWith(\"channel\")) {\n+            int channelId = Integer.parseInt(groupId.substring(\"channel\".length())) - 1;\n+            if (channel != null && channel.size() > 0 && channelId < channel.size()) {\n+                switch (channelUID.getIdWithoutGroup()) {\n+                    case CHANNEL_NAME:\n+                        state = new StringType(channel.get(channelId).getName());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aff5cb5d1d4586abbf71161d45993b63d09ab438"}, "originalPosition": 102}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ4MDAyNTQ0OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/api/esp32/WlanThermoEsp32CommandHandler.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNlQxOTo0OTo1NFrOIPUGjA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wOVQxMToxMjoyNVrOIQsn4w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjkyODkwOA==", "bodyText": "Typo?\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                    state = new StringType(settings.getSensors().get(channel.get(channelId).getTyp()).getName());\n          \n          \n            \n                                    state = new StringType(settings.getSensors().get(channel.get(channelId).getType()).getName());", "url": "https://github.com/openhab/openhab-addons/pull/9579#discussion_r552928908", "createdAt": "2021-01-06T19:49:54Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/api/esp32/WlanThermoEsp32CommandHandler.java", "diffHunk": "@@ -0,0 +1,298 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.wlanthermo.internal.api.esp32;\n+\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.*;\n+\n+import java.awt.Color;\n+import java.math.BigInteger;\n+import java.util.List;\n+\n+import javax.measure.Unit;\n+import javax.measure.quantity.Temperature;\n+\n+import org.openhab.binding.wlanthermo.internal.api.esp32.dto.data.Channel;\n+import org.openhab.binding.wlanthermo.internal.api.esp32.dto.data.Data;\n+import org.openhab.binding.wlanthermo.internal.api.esp32.dto.data.Pm;\n+import org.openhab.binding.wlanthermo.internal.api.esp32.dto.data.System;\n+import org.openhab.binding.wlanthermo.internal.api.esp32.dto.settings.Settings;\n+import org.openhab.core.library.types.*;\n+import org.openhab.core.library.unit.ImperialUnits;\n+import org.openhab.core.library.unit.SIUnits;\n+import org.openhab.core.library.unit.Units;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.UnDefType;\n+\n+/**\n+ * The {@link WlanThermoEsp32CommandHandler} is responsible for mapping the Commands to the respective data fields\n+ * of the API.\n+ *\n+ * @author Christian Schlipp - Initial contribution\n+ */\n+public class WlanThermoEsp32CommandHandler {\n+\n+    public State getState(ChannelUID channelUID, Data data, Settings settings) {\n+        State state = null;\n+\n+        String groupId = channelUID.getGroupId();\n+        if (groupId == null || data == null || settings == null) {\n+            return null;\n+        }\n+\n+        System system = data.getSystem();\n+\n+        Unit<Temperature> unit;\n+        if (system.getUnit().equals(\"F\")) {\n+            unit = ImperialUnits.FAHRENHEIT;\n+        } else {\n+            // Default to Celsius\n+            unit = SIUnits.CELSIUS;\n+        }\n+\n+        List<Channel> channel = data.getChannel();\n+        if (\"system\".equals(groupId)) {\n+            switch (channelUID.getIdWithoutGroup()) {\n+                case SYSTEM_SOC:\n+                    if (system.getSoc() != null) {\n+                        state = new DecimalType(system.getSoc());\n+                    } else {\n+                        state = UnDefType.UNDEF;\n+                    }\n+                    break;\n+                case SYSTEM_CHARGE:\n+                    if (system.getCharge() != null) {\n+                        state = OnOffType.from(system.getCharge());\n+                    } else {\n+                        state = UnDefType.UNDEF;\n+                    }\n+                    break;\n+                case SYSTEM_RSSI_SIGNALSTRENGTH:\n+                    int dbm = system.getRssi();\n+                    if (dbm >= -80) {\n+                        state = new DecimalType(4);\n+                    } else if (dbm >= -95) {\n+                        state = new DecimalType(3);\n+                    } else if (dbm >= -105) {\n+                        state = new DecimalType(2);\n+                    } else {\n+                        state = new DecimalType(1);\n+                    }\n+                    break;\n+                case SYSTEM_RSSI:\n+                    state = new QuantityType<>(system.getRssi(), Units.DECIBEL_MILLIWATTS);\n+                    break;\n+            }\n+        } else if (channelUID.getId().startsWith(\"channel\")) {\n+            int channelId = Integer.parseInt(groupId.substring(\"channel\".length())) - 1;\n+            if (channel != null && channel.size() > 0 && channelId < channel.size()) {\n+                switch (channelUID.getIdWithoutGroup()) {\n+                    case CHANNEL_NAME:\n+                        state = new StringType(channel.get(channelId).getName());\n+                        break;\n+                    case CHANNEL_TYP:\n+                        state = new StringType(settings.getSensors().get(channel.get(channelId).getTyp()).getName());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aff5cb5d1d4586abbf71161d45993b63d09ab438"}, "originalPosition": 105}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDM3OTIzNQ==", "bodyText": "No, this is referring to the \"typ\" field of the class \"Channel\", not to the \"type\" field of class \"Sensor\".\nThe naming is a bit unfortunate, but generated from the API of the device.", "url": "https://github.com/openhab/openhab-addons/pull/9579#discussion_r554379235", "createdAt": "2021-01-09T11:12:25Z", "author": {"login": "CSchlipp"}, "path": "bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/api/esp32/WlanThermoEsp32CommandHandler.java", "diffHunk": "@@ -0,0 +1,298 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.wlanthermo.internal.api.esp32;\n+\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.*;\n+\n+import java.awt.Color;\n+import java.math.BigInteger;\n+import java.util.List;\n+\n+import javax.measure.Unit;\n+import javax.measure.quantity.Temperature;\n+\n+import org.openhab.binding.wlanthermo.internal.api.esp32.dto.data.Channel;\n+import org.openhab.binding.wlanthermo.internal.api.esp32.dto.data.Data;\n+import org.openhab.binding.wlanthermo.internal.api.esp32.dto.data.Pm;\n+import org.openhab.binding.wlanthermo.internal.api.esp32.dto.data.System;\n+import org.openhab.binding.wlanthermo.internal.api.esp32.dto.settings.Settings;\n+import org.openhab.core.library.types.*;\n+import org.openhab.core.library.unit.ImperialUnits;\n+import org.openhab.core.library.unit.SIUnits;\n+import org.openhab.core.library.unit.Units;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.UnDefType;\n+\n+/**\n+ * The {@link WlanThermoEsp32CommandHandler} is responsible for mapping the Commands to the respective data fields\n+ * of the API.\n+ *\n+ * @author Christian Schlipp - Initial contribution\n+ */\n+public class WlanThermoEsp32CommandHandler {\n+\n+    public State getState(ChannelUID channelUID, Data data, Settings settings) {\n+        State state = null;\n+\n+        String groupId = channelUID.getGroupId();\n+        if (groupId == null || data == null || settings == null) {\n+            return null;\n+        }\n+\n+        System system = data.getSystem();\n+\n+        Unit<Temperature> unit;\n+        if (system.getUnit().equals(\"F\")) {\n+            unit = ImperialUnits.FAHRENHEIT;\n+        } else {\n+            // Default to Celsius\n+            unit = SIUnits.CELSIUS;\n+        }\n+\n+        List<Channel> channel = data.getChannel();\n+        if (\"system\".equals(groupId)) {\n+            switch (channelUID.getIdWithoutGroup()) {\n+                case SYSTEM_SOC:\n+                    if (system.getSoc() != null) {\n+                        state = new DecimalType(system.getSoc());\n+                    } else {\n+                        state = UnDefType.UNDEF;\n+                    }\n+                    break;\n+                case SYSTEM_CHARGE:\n+                    if (system.getCharge() != null) {\n+                        state = OnOffType.from(system.getCharge());\n+                    } else {\n+                        state = UnDefType.UNDEF;\n+                    }\n+                    break;\n+                case SYSTEM_RSSI_SIGNALSTRENGTH:\n+                    int dbm = system.getRssi();\n+                    if (dbm >= -80) {\n+                        state = new DecimalType(4);\n+                    } else if (dbm >= -95) {\n+                        state = new DecimalType(3);\n+                    } else if (dbm >= -105) {\n+                        state = new DecimalType(2);\n+                    } else {\n+                        state = new DecimalType(1);\n+                    }\n+                    break;\n+                case SYSTEM_RSSI:\n+                    state = new QuantityType<>(system.getRssi(), Units.DECIBEL_MILLIWATTS);\n+                    break;\n+            }\n+        } else if (channelUID.getId().startsWith(\"channel\")) {\n+            int channelId = Integer.parseInt(groupId.substring(\"channel\".length())) - 1;\n+            if (channel != null && channel.size() > 0 && channelId < channel.size()) {\n+                switch (channelUID.getIdWithoutGroup()) {\n+                    case CHANNEL_NAME:\n+                        state = new StringType(channel.get(channelId).getName());\n+                        break;\n+                    case CHANNEL_TYP:\n+                        state = new StringType(settings.getSensors().get(channel.get(channelId).getTyp()).getName());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjkyODkwOA=="}, "originalCommit": {"oid": "aff5cb5d1d4586abbf71161d45993b63d09ab438"}, "originalPosition": 105}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ4MDAzMDcxOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/api/esp32/WlanThermoEsp32CommandHandler.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNlQxOTo1MTo1MVrOIPUJ4A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNlQxOTo1MTo1MVrOIPUJ4A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjkyOTc2MA==", "bodyText": "Instead of assigning the return variable and then breaking, it would simplify the code in this method to just return the state immediately where possible.\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                    if (channel.get(channelId).getTemp() == 999.0) {\n          \n          \n            \n                                        state = UnDefType.UNDEF;\n          \n          \n            \n                                    } else {\n          \n          \n            \n                                        state = new QuantityType<>(channel.get(channelId).getTemp(), unit);\n          \n          \n            \n                                    }\n          \n          \n            \n                                    break;\n          \n          \n            \n                                    if (channel.get(channelId).getTemp() == 999.0) {\n          \n          \n            \n                                        return UnDefType.UNDEF;\n          \n          \n            \n                                    }\n          \n          \n            \n                                    return new QuantityType<>(channel.get(channelId).getTemp(), unit);", "url": "https://github.com/openhab/openhab-addons/pull/9579#discussion_r552929760", "createdAt": "2021-01-06T19:51:51Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/api/esp32/WlanThermoEsp32CommandHandler.java", "diffHunk": "@@ -0,0 +1,298 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.wlanthermo.internal.api.esp32;\n+\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.*;\n+\n+import java.awt.Color;\n+import java.math.BigInteger;\n+import java.util.List;\n+\n+import javax.measure.Unit;\n+import javax.measure.quantity.Temperature;\n+\n+import org.openhab.binding.wlanthermo.internal.api.esp32.dto.data.Channel;\n+import org.openhab.binding.wlanthermo.internal.api.esp32.dto.data.Data;\n+import org.openhab.binding.wlanthermo.internal.api.esp32.dto.data.Pm;\n+import org.openhab.binding.wlanthermo.internal.api.esp32.dto.data.System;\n+import org.openhab.binding.wlanthermo.internal.api.esp32.dto.settings.Settings;\n+import org.openhab.core.library.types.*;\n+import org.openhab.core.library.unit.ImperialUnits;\n+import org.openhab.core.library.unit.SIUnits;\n+import org.openhab.core.library.unit.Units;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.UnDefType;\n+\n+/**\n+ * The {@link WlanThermoEsp32CommandHandler} is responsible for mapping the Commands to the respective data fields\n+ * of the API.\n+ *\n+ * @author Christian Schlipp - Initial contribution\n+ */\n+public class WlanThermoEsp32CommandHandler {\n+\n+    public State getState(ChannelUID channelUID, Data data, Settings settings) {\n+        State state = null;\n+\n+        String groupId = channelUID.getGroupId();\n+        if (groupId == null || data == null || settings == null) {\n+            return null;\n+        }\n+\n+        System system = data.getSystem();\n+\n+        Unit<Temperature> unit;\n+        if (system.getUnit().equals(\"F\")) {\n+            unit = ImperialUnits.FAHRENHEIT;\n+        } else {\n+            // Default to Celsius\n+            unit = SIUnits.CELSIUS;\n+        }\n+\n+        List<Channel> channel = data.getChannel();\n+        if (\"system\".equals(groupId)) {\n+            switch (channelUID.getIdWithoutGroup()) {\n+                case SYSTEM_SOC:\n+                    if (system.getSoc() != null) {\n+                        state = new DecimalType(system.getSoc());\n+                    } else {\n+                        state = UnDefType.UNDEF;\n+                    }\n+                    break;\n+                case SYSTEM_CHARGE:\n+                    if (system.getCharge() != null) {\n+                        state = OnOffType.from(system.getCharge());\n+                    } else {\n+                        state = UnDefType.UNDEF;\n+                    }\n+                    break;\n+                case SYSTEM_RSSI_SIGNALSTRENGTH:\n+                    int dbm = system.getRssi();\n+                    if (dbm >= -80) {\n+                        state = new DecimalType(4);\n+                    } else if (dbm >= -95) {\n+                        state = new DecimalType(3);\n+                    } else if (dbm >= -105) {\n+                        state = new DecimalType(2);\n+                    } else {\n+                        state = new DecimalType(1);\n+                    }\n+                    break;\n+                case SYSTEM_RSSI:\n+                    state = new QuantityType<>(system.getRssi(), Units.DECIBEL_MILLIWATTS);\n+                    break;\n+            }\n+        } else if (channelUID.getId().startsWith(\"channel\")) {\n+            int channelId = Integer.parseInt(groupId.substring(\"channel\".length())) - 1;\n+            if (channel != null && channel.size() > 0 && channelId < channel.size()) {\n+                switch (channelUID.getIdWithoutGroup()) {\n+                    case CHANNEL_NAME:\n+                        state = new StringType(channel.get(channelId).getName());\n+                        break;\n+                    case CHANNEL_TYP:\n+                        state = new StringType(settings.getSensors().get(channel.get(channelId).getTyp()).getName());\n+                        break;\n+                    case CHANNEL_TEMP:\n+                        if (channel.get(channelId).getTemp() == 999.0) {\n+                            state = UnDefType.UNDEF;\n+                        } else {\n+                            state = new QuantityType<>(channel.get(channelId).getTemp(), unit);\n+                        }\n+                        break;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aff5cb5d1d4586abbf71161d45993b63d09ab438"}, "originalPosition": 113}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ4MDA0NzE0OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/api/esp32/WlanThermoEsp32CommandHandler.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNlQxOTo1NjowM1rOIPUUfQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNlQxOTo1NjowM1rOIPUUfQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjkzMjQ3Nw==", "bodyText": "Always try to call .equals on the constant so you can avoid accidental NPEs.\nAlso this seems like a good place to use the ternary operator as well.\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    Unit<Temperature> unit;\n          \n          \n            \n                    if (system.getUnit().equals(\"F\")) {\n          \n          \n            \n                        unit = ImperialUnits.FAHRENHEIT;\n          \n          \n            \n                    } else {\n          \n          \n            \n                        // Default to Celsius\n          \n          \n            \n                        unit = SIUnits.CELSIUS;\n          \n          \n            \n                    }\n          \n          \n            \n                    Unit<Temperature> unit = \"F\".equals(system.getUnit()) ? ImperialUnits.FAHRENHEIT : SIUnits.CELSIUS;", "url": "https://github.com/openhab/openhab-addons/pull/9579#discussion_r552932477", "createdAt": "2021-01-06T19:56:03Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/api/esp32/WlanThermoEsp32CommandHandler.java", "diffHunk": "@@ -0,0 +1,298 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.wlanthermo.internal.api.esp32;\n+\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.*;\n+\n+import java.awt.Color;\n+import java.math.BigInteger;\n+import java.util.List;\n+\n+import javax.measure.Unit;\n+import javax.measure.quantity.Temperature;\n+\n+import org.openhab.binding.wlanthermo.internal.api.esp32.dto.data.Channel;\n+import org.openhab.binding.wlanthermo.internal.api.esp32.dto.data.Data;\n+import org.openhab.binding.wlanthermo.internal.api.esp32.dto.data.Pm;\n+import org.openhab.binding.wlanthermo.internal.api.esp32.dto.data.System;\n+import org.openhab.binding.wlanthermo.internal.api.esp32.dto.settings.Settings;\n+import org.openhab.core.library.types.*;\n+import org.openhab.core.library.unit.ImperialUnits;\n+import org.openhab.core.library.unit.SIUnits;\n+import org.openhab.core.library.unit.Units;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.UnDefType;\n+\n+/**\n+ * The {@link WlanThermoEsp32CommandHandler} is responsible for mapping the Commands to the respective data fields\n+ * of the API.\n+ *\n+ * @author Christian Schlipp - Initial contribution\n+ */\n+public class WlanThermoEsp32CommandHandler {\n+\n+    public State getState(ChannelUID channelUID, Data data, Settings settings) {\n+        State state = null;\n+\n+        String groupId = channelUID.getGroupId();\n+        if (groupId == null || data == null || settings == null) {\n+            return null;\n+        }\n+\n+        System system = data.getSystem();\n+\n+        Unit<Temperature> unit;\n+        if (system.getUnit().equals(\"F\")) {\n+            unit = ImperialUnits.FAHRENHEIT;\n+        } else {\n+            // Default to Celsius\n+            unit = SIUnits.CELSIUS;\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aff5cb5d1d4586abbf71161d45993b63d09ab438"}, "originalPosition": 62}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ4MDA1ODk1OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/api/esp32/WlanThermoEsp32CommandHandler.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNlQxOTo1OTo1NVrOIPUbnw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNlQxOTo1OTo1NVrOIPUbnw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjkzNDMwMw==", "bodyText": "You should make sure that the unit of the incoming quantity type is what you expect. Use QuantityType.toUnit to get a QuantityType instance with your expected unit.", "url": "https://github.com/openhab/openhab-addons/pull/9579#discussion_r552934303", "createdAt": "2021-01-06T19:59:55Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/api/esp32/WlanThermoEsp32CommandHandler.java", "diffHunk": "@@ -0,0 +1,298 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.wlanthermo.internal.api.esp32;\n+\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.*;\n+\n+import java.awt.Color;\n+import java.math.BigInteger;\n+import java.util.List;\n+\n+import javax.measure.Unit;\n+import javax.measure.quantity.Temperature;\n+\n+import org.openhab.binding.wlanthermo.internal.api.esp32.dto.data.Channel;\n+import org.openhab.binding.wlanthermo.internal.api.esp32.dto.data.Data;\n+import org.openhab.binding.wlanthermo.internal.api.esp32.dto.data.Pm;\n+import org.openhab.binding.wlanthermo.internal.api.esp32.dto.data.System;\n+import org.openhab.binding.wlanthermo.internal.api.esp32.dto.settings.Settings;\n+import org.openhab.core.library.types.*;\n+import org.openhab.core.library.unit.ImperialUnits;\n+import org.openhab.core.library.unit.SIUnits;\n+import org.openhab.core.library.unit.Units;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.UnDefType;\n+\n+/**\n+ * The {@link WlanThermoEsp32CommandHandler} is responsible for mapping the Commands to the respective data fields\n+ * of the API.\n+ *\n+ * @author Christian Schlipp - Initial contribution\n+ */\n+public class WlanThermoEsp32CommandHandler {\n+\n+    public State getState(ChannelUID channelUID, Data data, Settings settings) {\n+        State state = null;\n+\n+        String groupId = channelUID.getGroupId();\n+        if (groupId == null || data == null || settings == null) {\n+            return null;\n+        }\n+\n+        System system = data.getSystem();\n+\n+        Unit<Temperature> unit;\n+        if (system.getUnit().equals(\"F\")) {\n+            unit = ImperialUnits.FAHRENHEIT;\n+        } else {\n+            // Default to Celsius\n+            unit = SIUnits.CELSIUS;\n+        }\n+\n+        List<Channel> channel = data.getChannel();\n+        if (\"system\".equals(groupId)) {\n+            switch (channelUID.getIdWithoutGroup()) {\n+                case SYSTEM_SOC:\n+                    if (system.getSoc() != null) {\n+                        state = new DecimalType(system.getSoc());\n+                    } else {\n+                        state = UnDefType.UNDEF;\n+                    }\n+                    break;\n+                case SYSTEM_CHARGE:\n+                    if (system.getCharge() != null) {\n+                        state = OnOffType.from(system.getCharge());\n+                    } else {\n+                        state = UnDefType.UNDEF;\n+                    }\n+                    break;\n+                case SYSTEM_RSSI_SIGNALSTRENGTH:\n+                    int dbm = system.getRssi();\n+                    if (dbm >= -80) {\n+                        state = new DecimalType(4);\n+                    } else if (dbm >= -95) {\n+                        state = new DecimalType(3);\n+                    } else if (dbm >= -105) {\n+                        state = new DecimalType(2);\n+                    } else {\n+                        state = new DecimalType(1);\n+                    }\n+                    break;\n+                case SYSTEM_RSSI:\n+                    state = new QuantityType<>(system.getRssi(), Units.DECIBEL_MILLIWATTS);\n+                    break;\n+            }\n+        } else if (channelUID.getId().startsWith(\"channel\")) {\n+            int channelId = Integer.parseInt(groupId.substring(\"channel\".length())) - 1;\n+            if (channel != null && channel.size() > 0 && channelId < channel.size()) {\n+                switch (channelUID.getIdWithoutGroup()) {\n+                    case CHANNEL_NAME:\n+                        state = new StringType(channel.get(channelId).getName());\n+                        break;\n+                    case CHANNEL_TYP:\n+                        state = new StringType(settings.getSensors().get(channel.get(channelId).getTyp()).getName());\n+                        break;\n+                    case CHANNEL_TEMP:\n+                        if (channel.get(channelId).getTemp() == 999.0) {\n+                            state = UnDefType.UNDEF;\n+                        } else {\n+                            state = new QuantityType<>(channel.get(channelId).getTemp(), unit);\n+                        }\n+                        break;\n+                    case CHANNEL_MIN:\n+                        state = new QuantityType<>(channel.get(channelId).getMin(), unit);\n+                        break;\n+                    case CHANNEL_MAX:\n+                        state = new QuantityType<>(channel.get(channelId).getMax(), unit);\n+                        break;\n+                    case CHANNEL_ALARM_DEVICE:\n+                        state = OnOffType.from(BigInteger.valueOf(channel.get(channelId).getAlarm()).testBit(1));\n+                        break;\n+                    case CHANNEL_ALARM_PUSH:\n+                        state = OnOffType.from(BigInteger.valueOf(channel.get(channelId).getAlarm()).testBit(0));\n+                        break;\n+                    case CHANNEL_ALARM_OPENHAB_HIGH:\n+                        if (channel.get(channelId).getTemp() != 999\n+                                && channel.get(channelId).getTemp() > channel.get(channelId).getMax()) {\n+                            state = OnOffType.ON;\n+                        } else {\n+                            state = OnOffType.OFF;\n+                        }\n+                        break;\n+                    case CHANNEL_ALARM_OPENHAB_LOW:\n+                        if (channel.get(channelId).getTemp() != 999\n+                                && channel.get(channelId).getTemp() < channel.get(channelId).getMin()) {\n+                            state = OnOffType.ON;\n+                        } else {\n+                            state = OnOffType.OFF;\n+                        }\n+                        break;\n+                    case CHANNEL_COLOR:\n+                        String color = channel.get(channelId).getColor();\n+                        if (color != null && !color.isEmpty()) {\n+                            Color c = Color.decode(color);\n+                            state = HSBType.fromRGB(c.getRed(), c.getGreen(), c.getBlue());\n+                        }\n+                        break;\n+                    case CHANNEL_COLOR_NAME:\n+                        String colorHex = channel.get(channelId).getColor();\n+                        if (colorHex != null && !colorHex.isEmpty()) {\n+                            state = new StringType(UtilEsp32.toColorName(colorHex));\n+                        }\n+                        break;\n+                }\n+            }\n+        } else if (channelUID.getId().startsWith(\"pit1\")) {\n+            if (data.getPitmaster() != null && data.getPitmaster().getPm() != null\n+                    && data.getPitmaster().getPm().size() > 0) {\n+                Pm pm = data.getPitmaster().getPm().get(0);\n+                switch (channelUID.getIdWithoutGroup()) {\n+                    case CHANNEL_PITMASTER_CHANNEL_ID:\n+                        state = new DecimalType(pm.getChannel());\n+                        break;\n+                    case CHANNEL_PITMASTER_PIDPROFILE:\n+                        state = new DecimalType(pm.getPid());\n+                        break;\n+                    case CHANNEL_PITMASTER_DUTY_CYCLE:\n+                        state = new DecimalType(pm.getValue());\n+                        break;\n+                    case CHANNEL_PITMASTER_SETPOINT:\n+                        state = new QuantityType<>(pm.getSet(), unit);\n+                        break;\n+                    case CHANNEL_PITMASTER_STATE:\n+                        state = new StringType(pm.getTyp());\n+                }\n+            } else {\n+                return UnDefType.UNDEF;\n+            }\n+        }\n+        return state;\n+    }\n+\n+    public boolean setState(ChannelUID channelUID, Command command, Data data) {\n+        boolean success = false;\n+        String groupId = channelUID.getGroupId();\n+        if (groupId == null || data == null) {\n+            return false;\n+        }\n+        List<Channel> channel = data.getChannel();\n+        if (channelUID.getId().startsWith(\"channel\")) {\n+            int channelId = Integer.parseInt(groupId.substring(\"channel\".length())) - 1;\n+            if (channel.size() > 0 && channelId < channel.size()) {\n+                switch (channelUID.getIdWithoutGroup()) {\n+                    case CHANNEL_NAME:\n+                        if (command instanceof StringType) {\n+                            channel.get(channelId).setName(command.toFullString());\n+                            success = true;\n+                        }\n+                        break;\n+                    case CHANNEL_MIN:\n+                        if (command instanceof QuantityType) {\n+                            channel.get(channelId).setMin(((QuantityType<?>) command).doubleValue());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aff5cb5d1d4586abbf71161d45993b63d09ab438"}, "originalPosition": 203}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ4MDA2MjM4OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/api/esp32/WlanThermoEsp32CommandHandler.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNlQyMDowMToxMVrOIPUdwA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xM1QyMjowMTozNFrOITFWoA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjkzNDg0OA==", "bodyText": "Using the && operator would reduce the amount of nested indentation going on here.", "url": "https://github.com/openhab/openhab-addons/pull/9579#discussion_r552934848", "createdAt": "2021-01-06T20:01:11Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/api/esp32/WlanThermoEsp32CommandHandler.java", "diffHunk": "@@ -0,0 +1,298 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.wlanthermo.internal.api.esp32;\n+\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.*;\n+\n+import java.awt.Color;\n+import java.math.BigInteger;\n+import java.util.List;\n+\n+import javax.measure.Unit;\n+import javax.measure.quantity.Temperature;\n+\n+import org.openhab.binding.wlanthermo.internal.api.esp32.dto.data.Channel;\n+import org.openhab.binding.wlanthermo.internal.api.esp32.dto.data.Data;\n+import org.openhab.binding.wlanthermo.internal.api.esp32.dto.data.Pm;\n+import org.openhab.binding.wlanthermo.internal.api.esp32.dto.data.System;\n+import org.openhab.binding.wlanthermo.internal.api.esp32.dto.settings.Settings;\n+import org.openhab.core.library.types.*;\n+import org.openhab.core.library.unit.ImperialUnits;\n+import org.openhab.core.library.unit.SIUnits;\n+import org.openhab.core.library.unit.Units;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.UnDefType;\n+\n+/**\n+ * The {@link WlanThermoEsp32CommandHandler} is responsible for mapping the Commands to the respective data fields\n+ * of the API.\n+ *\n+ * @author Christian Schlipp - Initial contribution\n+ */\n+public class WlanThermoEsp32CommandHandler {\n+\n+    public State getState(ChannelUID channelUID, Data data, Settings settings) {\n+        State state = null;\n+\n+        String groupId = channelUID.getGroupId();\n+        if (groupId == null || data == null || settings == null) {\n+            return null;\n+        }\n+\n+        System system = data.getSystem();\n+\n+        Unit<Temperature> unit;\n+        if (system.getUnit().equals(\"F\")) {\n+            unit = ImperialUnits.FAHRENHEIT;\n+        } else {\n+            // Default to Celsius\n+            unit = SIUnits.CELSIUS;\n+        }\n+\n+        List<Channel> channel = data.getChannel();\n+        if (\"system\".equals(groupId)) {\n+            switch (channelUID.getIdWithoutGroup()) {\n+                case SYSTEM_SOC:\n+                    if (system.getSoc() != null) {\n+                        state = new DecimalType(system.getSoc());\n+                    } else {\n+                        state = UnDefType.UNDEF;\n+                    }\n+                    break;\n+                case SYSTEM_CHARGE:\n+                    if (system.getCharge() != null) {\n+                        state = OnOffType.from(system.getCharge());\n+                    } else {\n+                        state = UnDefType.UNDEF;\n+                    }\n+                    break;\n+                case SYSTEM_RSSI_SIGNALSTRENGTH:\n+                    int dbm = system.getRssi();\n+                    if (dbm >= -80) {\n+                        state = new DecimalType(4);\n+                    } else if (dbm >= -95) {\n+                        state = new DecimalType(3);\n+                    } else if (dbm >= -105) {\n+                        state = new DecimalType(2);\n+                    } else {\n+                        state = new DecimalType(1);\n+                    }\n+                    break;\n+                case SYSTEM_RSSI:\n+                    state = new QuantityType<>(system.getRssi(), Units.DECIBEL_MILLIWATTS);\n+                    break;\n+            }\n+        } else if (channelUID.getId().startsWith(\"channel\")) {\n+            int channelId = Integer.parseInt(groupId.substring(\"channel\".length())) - 1;\n+            if (channel != null && channel.size() > 0 && channelId < channel.size()) {\n+                switch (channelUID.getIdWithoutGroup()) {\n+                    case CHANNEL_NAME:\n+                        state = new StringType(channel.get(channelId).getName());\n+                        break;\n+                    case CHANNEL_TYP:\n+                        state = new StringType(settings.getSensors().get(channel.get(channelId).getTyp()).getName());\n+                        break;\n+                    case CHANNEL_TEMP:\n+                        if (channel.get(channelId).getTemp() == 999.0) {\n+                            state = UnDefType.UNDEF;\n+                        } else {\n+                            state = new QuantityType<>(channel.get(channelId).getTemp(), unit);\n+                        }\n+                        break;\n+                    case CHANNEL_MIN:\n+                        state = new QuantityType<>(channel.get(channelId).getMin(), unit);\n+                        break;\n+                    case CHANNEL_MAX:\n+                        state = new QuantityType<>(channel.get(channelId).getMax(), unit);\n+                        break;\n+                    case CHANNEL_ALARM_DEVICE:\n+                        state = OnOffType.from(BigInteger.valueOf(channel.get(channelId).getAlarm()).testBit(1));\n+                        break;\n+                    case CHANNEL_ALARM_PUSH:\n+                        state = OnOffType.from(BigInteger.valueOf(channel.get(channelId).getAlarm()).testBit(0));\n+                        break;\n+                    case CHANNEL_ALARM_OPENHAB_HIGH:\n+                        if (channel.get(channelId).getTemp() != 999\n+                                && channel.get(channelId).getTemp() > channel.get(channelId).getMax()) {\n+                            state = OnOffType.ON;\n+                        } else {\n+                            state = OnOffType.OFF;\n+                        }\n+                        break;\n+                    case CHANNEL_ALARM_OPENHAB_LOW:\n+                        if (channel.get(channelId).getTemp() != 999\n+                                && channel.get(channelId).getTemp() < channel.get(channelId).getMin()) {\n+                            state = OnOffType.ON;\n+                        } else {\n+                            state = OnOffType.OFF;\n+                        }\n+                        break;\n+                    case CHANNEL_COLOR:\n+                        String color = channel.get(channelId).getColor();\n+                        if (color != null && !color.isEmpty()) {\n+                            Color c = Color.decode(color);\n+                            state = HSBType.fromRGB(c.getRed(), c.getGreen(), c.getBlue());\n+                        }\n+                        break;\n+                    case CHANNEL_COLOR_NAME:\n+                        String colorHex = channel.get(channelId).getColor();\n+                        if (colorHex != null && !colorHex.isEmpty()) {\n+                            state = new StringType(UtilEsp32.toColorName(colorHex));\n+                        }\n+                        break;\n+                }\n+            }\n+        } else if (channelUID.getId().startsWith(\"pit1\")) {\n+            if (data.getPitmaster() != null && data.getPitmaster().getPm() != null\n+                    && data.getPitmaster().getPm().size() > 0) {\n+                Pm pm = data.getPitmaster().getPm().get(0);\n+                switch (channelUID.getIdWithoutGroup()) {\n+                    case CHANNEL_PITMASTER_CHANNEL_ID:\n+                        state = new DecimalType(pm.getChannel());\n+                        break;\n+                    case CHANNEL_PITMASTER_PIDPROFILE:\n+                        state = new DecimalType(pm.getPid());\n+                        break;\n+                    case CHANNEL_PITMASTER_DUTY_CYCLE:\n+                        state = new DecimalType(pm.getValue());\n+                        break;\n+                    case CHANNEL_PITMASTER_SETPOINT:\n+                        state = new QuantityType<>(pm.getSet(), unit);\n+                        break;\n+                    case CHANNEL_PITMASTER_STATE:\n+                        state = new StringType(pm.getTyp());\n+                }\n+            } else {\n+                return UnDefType.UNDEF;\n+            }\n+        }\n+        return state;\n+    }\n+\n+    public boolean setState(ChannelUID channelUID, Command command, Data data) {\n+        boolean success = false;\n+        String groupId = channelUID.getGroupId();\n+        if (groupId == null || data == null) {\n+            return false;\n+        }\n+        List<Channel> channel = data.getChannel();\n+        if (channelUID.getId().startsWith(\"channel\")) {\n+            int channelId = Integer.parseInt(groupId.substring(\"channel\".length())) - 1;\n+            if (channel.size() > 0 && channelId < channel.size()) {\n+                switch (channelUID.getIdWithoutGroup()) {\n+                    case CHANNEL_NAME:\n+                        if (command instanceof StringType) {\n+                            channel.get(channelId).setName(command.toFullString());\n+                            success = true;\n+                        }\n+                        break;\n+                    case CHANNEL_MIN:\n+                        if (command instanceof QuantityType) {\n+                            channel.get(channelId).setMin(((QuantityType<?>) command).doubleValue());\n+                            success = true;\n+                        }\n+                        break;\n+                    case CHANNEL_MAX:\n+                        if (command instanceof QuantityType) {\n+                            channel.get(channelId).setMax(((QuantityType<?>) command).doubleValue());\n+                            success = true;\n+                        }\n+                        break;\n+                    case CHANNEL_ALARM_DEVICE:\n+                        if (command instanceof OnOffType) {\n+                            BigInteger value;\n+                            if (command == OnOffType.ON) {\n+                                value = BigInteger.valueOf(channel.get(channelId).getAlarm()).setBit(1);\n+                            } else {\n+                                value = BigInteger.valueOf(channel.get(channelId).getAlarm()).clearBit(1);\n+                            }\n+                            channel.get(channelId).setAlarm(value.intValue());\n+                            success = true;\n+                        }\n+                        break;\n+                    case CHANNEL_ALARM_PUSH:\n+                        if (command instanceof OnOffType) {\n+                            BigInteger value;\n+                            if (command == OnOffType.ON) {\n+                                value = BigInteger.valueOf(channel.get(channelId).getAlarm()).setBit(0);\n+                            } else {\n+                                value = BigInteger.valueOf(channel.get(channelId).getAlarm()).clearBit(0);\n+                            }\n+                            channel.get(channelId).setAlarm(value.intValue());\n+                            success = true;\n+                        }\n+                        break;\n+                    case CHANNEL_COLOR_NAME:\n+                        if (command instanceof StringType) {\n+                            channel.get(channelId).setColor(UtilEsp32.toHex(((StringType) command).toString()));\n+                            success = true;\n+                        }\n+                        break;\n+                }\n+            }\n+        } else if (channelUID.getId().equals(\"pit1\")) {\n+            if (data.getPitmaster() != null && data.getPitmaster().getPm() != null\n+                    && data.getPitmaster().getPm().size() > 0) {\n+                Pm pm = data.getPitmaster().getPm().get(0);\n+                switch (channelUID.getIdWithoutGroup()) {\n+                    case CHANNEL_PITMASTER_CHANNEL_ID:\n+                        pm.setChannel(((QuantityType<?>) command).intValue());\n+                        success = true;\n+                        break;\n+                    case CHANNEL_PITMASTER_PIDPROFILE:\n+                        pm.setPid(((QuantityType<?>) command).intValue());\n+                        success = true;\n+                        break;\n+                    case CHANNEL_PITMASTER_SETPOINT:\n+                        pm.setSet(((QuantityType<?>) command).doubleValue());\n+                        success = true;\n+                        break;\n+                    case CHANNEL_PITMASTER_STATE:\n+                        String state = ((StringType) command).toString();\n+                        if (state.equalsIgnoreCase(\"off\") || state.equalsIgnoreCase(\"manual\")\n+                                || state.equalsIgnoreCase(\"auto\")) {\n+                            pm.setTyp(state);\n+                            success = true;\n+                        }\n+                }\n+            }\n+        }\n+        return success;\n+    }\n+\n+    public String getTrigger(ChannelUID channelUID, Data data) {\n+        String trigger = null;\n+        String groupId = channelUID.getGroupId();\n+        if (groupId == null || data == null) {\n+            return null;\n+        }\n+        List<Channel> channel = data.getChannel();\n+        if (channelUID.getId().startsWith(\"channel\")) {\n+            int channelId = Integer.parseInt(groupId.substring(\"channel\".length())) - 1;\n+            if (channel.size() > 0 && channelId < channel.size()) {\n+                if (CHANNEL_ALARM_OPENHAB.equals(channelUID.getIdWithoutGroup())) {\n+                    if (channel.get(channelId).getTemp() != 999) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aff5cb5d1d4586abbf71161d45993b63d09ab438"}, "originalPosition": 286}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDQ1MTM3NQ==", "bodyText": "Agree, but it wouldn't make the code clearer or better to understand. I tried to structure the different functions in the command handler all in the same way, so one can easily figure out where e.g. new Triggers have to be added.\nIn the end, the compiler is optimizing it anyways, so I'd plead for leaving it more readable.", "url": "https://github.com/openhab/openhab-addons/pull/9579#discussion_r554451375", "createdAt": "2021-01-09T17:31:30Z", "author": {"login": "CSchlipp"}, "path": "bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/api/esp32/WlanThermoEsp32CommandHandler.java", "diffHunk": "@@ -0,0 +1,298 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.wlanthermo.internal.api.esp32;\n+\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.*;\n+\n+import java.awt.Color;\n+import java.math.BigInteger;\n+import java.util.List;\n+\n+import javax.measure.Unit;\n+import javax.measure.quantity.Temperature;\n+\n+import org.openhab.binding.wlanthermo.internal.api.esp32.dto.data.Channel;\n+import org.openhab.binding.wlanthermo.internal.api.esp32.dto.data.Data;\n+import org.openhab.binding.wlanthermo.internal.api.esp32.dto.data.Pm;\n+import org.openhab.binding.wlanthermo.internal.api.esp32.dto.data.System;\n+import org.openhab.binding.wlanthermo.internal.api.esp32.dto.settings.Settings;\n+import org.openhab.core.library.types.*;\n+import org.openhab.core.library.unit.ImperialUnits;\n+import org.openhab.core.library.unit.SIUnits;\n+import org.openhab.core.library.unit.Units;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.UnDefType;\n+\n+/**\n+ * The {@link WlanThermoEsp32CommandHandler} is responsible for mapping the Commands to the respective data fields\n+ * of the API.\n+ *\n+ * @author Christian Schlipp - Initial contribution\n+ */\n+public class WlanThermoEsp32CommandHandler {\n+\n+    public State getState(ChannelUID channelUID, Data data, Settings settings) {\n+        State state = null;\n+\n+        String groupId = channelUID.getGroupId();\n+        if (groupId == null || data == null || settings == null) {\n+            return null;\n+        }\n+\n+        System system = data.getSystem();\n+\n+        Unit<Temperature> unit;\n+        if (system.getUnit().equals(\"F\")) {\n+            unit = ImperialUnits.FAHRENHEIT;\n+        } else {\n+            // Default to Celsius\n+            unit = SIUnits.CELSIUS;\n+        }\n+\n+        List<Channel> channel = data.getChannel();\n+        if (\"system\".equals(groupId)) {\n+            switch (channelUID.getIdWithoutGroup()) {\n+                case SYSTEM_SOC:\n+                    if (system.getSoc() != null) {\n+                        state = new DecimalType(system.getSoc());\n+                    } else {\n+                        state = UnDefType.UNDEF;\n+                    }\n+                    break;\n+                case SYSTEM_CHARGE:\n+                    if (system.getCharge() != null) {\n+                        state = OnOffType.from(system.getCharge());\n+                    } else {\n+                        state = UnDefType.UNDEF;\n+                    }\n+                    break;\n+                case SYSTEM_RSSI_SIGNALSTRENGTH:\n+                    int dbm = system.getRssi();\n+                    if (dbm >= -80) {\n+                        state = new DecimalType(4);\n+                    } else if (dbm >= -95) {\n+                        state = new DecimalType(3);\n+                    } else if (dbm >= -105) {\n+                        state = new DecimalType(2);\n+                    } else {\n+                        state = new DecimalType(1);\n+                    }\n+                    break;\n+                case SYSTEM_RSSI:\n+                    state = new QuantityType<>(system.getRssi(), Units.DECIBEL_MILLIWATTS);\n+                    break;\n+            }\n+        } else if (channelUID.getId().startsWith(\"channel\")) {\n+            int channelId = Integer.parseInt(groupId.substring(\"channel\".length())) - 1;\n+            if (channel != null && channel.size() > 0 && channelId < channel.size()) {\n+                switch (channelUID.getIdWithoutGroup()) {\n+                    case CHANNEL_NAME:\n+                        state = new StringType(channel.get(channelId).getName());\n+                        break;\n+                    case CHANNEL_TYP:\n+                        state = new StringType(settings.getSensors().get(channel.get(channelId).getTyp()).getName());\n+                        break;\n+                    case CHANNEL_TEMP:\n+                        if (channel.get(channelId).getTemp() == 999.0) {\n+                            state = UnDefType.UNDEF;\n+                        } else {\n+                            state = new QuantityType<>(channel.get(channelId).getTemp(), unit);\n+                        }\n+                        break;\n+                    case CHANNEL_MIN:\n+                        state = new QuantityType<>(channel.get(channelId).getMin(), unit);\n+                        break;\n+                    case CHANNEL_MAX:\n+                        state = new QuantityType<>(channel.get(channelId).getMax(), unit);\n+                        break;\n+                    case CHANNEL_ALARM_DEVICE:\n+                        state = OnOffType.from(BigInteger.valueOf(channel.get(channelId).getAlarm()).testBit(1));\n+                        break;\n+                    case CHANNEL_ALARM_PUSH:\n+                        state = OnOffType.from(BigInteger.valueOf(channel.get(channelId).getAlarm()).testBit(0));\n+                        break;\n+                    case CHANNEL_ALARM_OPENHAB_HIGH:\n+                        if (channel.get(channelId).getTemp() != 999\n+                                && channel.get(channelId).getTemp() > channel.get(channelId).getMax()) {\n+                            state = OnOffType.ON;\n+                        } else {\n+                            state = OnOffType.OFF;\n+                        }\n+                        break;\n+                    case CHANNEL_ALARM_OPENHAB_LOW:\n+                        if (channel.get(channelId).getTemp() != 999\n+                                && channel.get(channelId).getTemp() < channel.get(channelId).getMin()) {\n+                            state = OnOffType.ON;\n+                        } else {\n+                            state = OnOffType.OFF;\n+                        }\n+                        break;\n+                    case CHANNEL_COLOR:\n+                        String color = channel.get(channelId).getColor();\n+                        if (color != null && !color.isEmpty()) {\n+                            Color c = Color.decode(color);\n+                            state = HSBType.fromRGB(c.getRed(), c.getGreen(), c.getBlue());\n+                        }\n+                        break;\n+                    case CHANNEL_COLOR_NAME:\n+                        String colorHex = channel.get(channelId).getColor();\n+                        if (colorHex != null && !colorHex.isEmpty()) {\n+                            state = new StringType(UtilEsp32.toColorName(colorHex));\n+                        }\n+                        break;\n+                }\n+            }\n+        } else if (channelUID.getId().startsWith(\"pit1\")) {\n+            if (data.getPitmaster() != null && data.getPitmaster().getPm() != null\n+                    && data.getPitmaster().getPm().size() > 0) {\n+                Pm pm = data.getPitmaster().getPm().get(0);\n+                switch (channelUID.getIdWithoutGroup()) {\n+                    case CHANNEL_PITMASTER_CHANNEL_ID:\n+                        state = new DecimalType(pm.getChannel());\n+                        break;\n+                    case CHANNEL_PITMASTER_PIDPROFILE:\n+                        state = new DecimalType(pm.getPid());\n+                        break;\n+                    case CHANNEL_PITMASTER_DUTY_CYCLE:\n+                        state = new DecimalType(pm.getValue());\n+                        break;\n+                    case CHANNEL_PITMASTER_SETPOINT:\n+                        state = new QuantityType<>(pm.getSet(), unit);\n+                        break;\n+                    case CHANNEL_PITMASTER_STATE:\n+                        state = new StringType(pm.getTyp());\n+                }\n+            } else {\n+                return UnDefType.UNDEF;\n+            }\n+        }\n+        return state;\n+    }\n+\n+    public boolean setState(ChannelUID channelUID, Command command, Data data) {\n+        boolean success = false;\n+        String groupId = channelUID.getGroupId();\n+        if (groupId == null || data == null) {\n+            return false;\n+        }\n+        List<Channel> channel = data.getChannel();\n+        if (channelUID.getId().startsWith(\"channel\")) {\n+            int channelId = Integer.parseInt(groupId.substring(\"channel\".length())) - 1;\n+            if (channel.size() > 0 && channelId < channel.size()) {\n+                switch (channelUID.getIdWithoutGroup()) {\n+                    case CHANNEL_NAME:\n+                        if (command instanceof StringType) {\n+                            channel.get(channelId).setName(command.toFullString());\n+                            success = true;\n+                        }\n+                        break;\n+                    case CHANNEL_MIN:\n+                        if (command instanceof QuantityType) {\n+                            channel.get(channelId).setMin(((QuantityType<?>) command).doubleValue());\n+                            success = true;\n+                        }\n+                        break;\n+                    case CHANNEL_MAX:\n+                        if (command instanceof QuantityType) {\n+                            channel.get(channelId).setMax(((QuantityType<?>) command).doubleValue());\n+                            success = true;\n+                        }\n+                        break;\n+                    case CHANNEL_ALARM_DEVICE:\n+                        if (command instanceof OnOffType) {\n+                            BigInteger value;\n+                            if (command == OnOffType.ON) {\n+                                value = BigInteger.valueOf(channel.get(channelId).getAlarm()).setBit(1);\n+                            } else {\n+                                value = BigInteger.valueOf(channel.get(channelId).getAlarm()).clearBit(1);\n+                            }\n+                            channel.get(channelId).setAlarm(value.intValue());\n+                            success = true;\n+                        }\n+                        break;\n+                    case CHANNEL_ALARM_PUSH:\n+                        if (command instanceof OnOffType) {\n+                            BigInteger value;\n+                            if (command == OnOffType.ON) {\n+                                value = BigInteger.valueOf(channel.get(channelId).getAlarm()).setBit(0);\n+                            } else {\n+                                value = BigInteger.valueOf(channel.get(channelId).getAlarm()).clearBit(0);\n+                            }\n+                            channel.get(channelId).setAlarm(value.intValue());\n+                            success = true;\n+                        }\n+                        break;\n+                    case CHANNEL_COLOR_NAME:\n+                        if (command instanceof StringType) {\n+                            channel.get(channelId).setColor(UtilEsp32.toHex(((StringType) command).toString()));\n+                            success = true;\n+                        }\n+                        break;\n+                }\n+            }\n+        } else if (channelUID.getId().equals(\"pit1\")) {\n+            if (data.getPitmaster() != null && data.getPitmaster().getPm() != null\n+                    && data.getPitmaster().getPm().size() > 0) {\n+                Pm pm = data.getPitmaster().getPm().get(0);\n+                switch (channelUID.getIdWithoutGroup()) {\n+                    case CHANNEL_PITMASTER_CHANNEL_ID:\n+                        pm.setChannel(((QuantityType<?>) command).intValue());\n+                        success = true;\n+                        break;\n+                    case CHANNEL_PITMASTER_PIDPROFILE:\n+                        pm.setPid(((QuantityType<?>) command).intValue());\n+                        success = true;\n+                        break;\n+                    case CHANNEL_PITMASTER_SETPOINT:\n+                        pm.setSet(((QuantityType<?>) command).doubleValue());\n+                        success = true;\n+                        break;\n+                    case CHANNEL_PITMASTER_STATE:\n+                        String state = ((StringType) command).toString();\n+                        if (state.equalsIgnoreCase(\"off\") || state.equalsIgnoreCase(\"manual\")\n+                                || state.equalsIgnoreCase(\"auto\")) {\n+                            pm.setTyp(state);\n+                            success = true;\n+                        }\n+                }\n+            }\n+        }\n+        return success;\n+    }\n+\n+    public String getTrigger(ChannelUID channelUID, Data data) {\n+        String trigger = null;\n+        String groupId = channelUID.getGroupId();\n+        if (groupId == null || data == null) {\n+            return null;\n+        }\n+        List<Channel> channel = data.getChannel();\n+        if (channelUID.getId().startsWith(\"channel\")) {\n+            int channelId = Integer.parseInt(groupId.substring(\"channel\".length())) - 1;\n+            if (channel.size() > 0 && channelId < channel.size()) {\n+                if (CHANNEL_ALARM_OPENHAB.equals(channelUID.getIdWithoutGroup())) {\n+                    if (channel.get(channelId).getTemp() != 999) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjkzNDg0OA=="}, "originalCommit": {"oid": "aff5cb5d1d4586abbf71161d45993b63d09ab438"}, "originalPosition": 286}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Njg4MTU2OA==", "bodyText": "Fair enough.", "url": "https://github.com/openhab/openhab-addons/pull/9579#discussion_r556881568", "createdAt": "2021-01-13T22:01:34Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/api/esp32/WlanThermoEsp32CommandHandler.java", "diffHunk": "@@ -0,0 +1,298 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.wlanthermo.internal.api.esp32;\n+\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.*;\n+\n+import java.awt.Color;\n+import java.math.BigInteger;\n+import java.util.List;\n+\n+import javax.measure.Unit;\n+import javax.measure.quantity.Temperature;\n+\n+import org.openhab.binding.wlanthermo.internal.api.esp32.dto.data.Channel;\n+import org.openhab.binding.wlanthermo.internal.api.esp32.dto.data.Data;\n+import org.openhab.binding.wlanthermo.internal.api.esp32.dto.data.Pm;\n+import org.openhab.binding.wlanthermo.internal.api.esp32.dto.data.System;\n+import org.openhab.binding.wlanthermo.internal.api.esp32.dto.settings.Settings;\n+import org.openhab.core.library.types.*;\n+import org.openhab.core.library.unit.ImperialUnits;\n+import org.openhab.core.library.unit.SIUnits;\n+import org.openhab.core.library.unit.Units;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.UnDefType;\n+\n+/**\n+ * The {@link WlanThermoEsp32CommandHandler} is responsible for mapping the Commands to the respective data fields\n+ * of the API.\n+ *\n+ * @author Christian Schlipp - Initial contribution\n+ */\n+public class WlanThermoEsp32CommandHandler {\n+\n+    public State getState(ChannelUID channelUID, Data data, Settings settings) {\n+        State state = null;\n+\n+        String groupId = channelUID.getGroupId();\n+        if (groupId == null || data == null || settings == null) {\n+            return null;\n+        }\n+\n+        System system = data.getSystem();\n+\n+        Unit<Temperature> unit;\n+        if (system.getUnit().equals(\"F\")) {\n+            unit = ImperialUnits.FAHRENHEIT;\n+        } else {\n+            // Default to Celsius\n+            unit = SIUnits.CELSIUS;\n+        }\n+\n+        List<Channel> channel = data.getChannel();\n+        if (\"system\".equals(groupId)) {\n+            switch (channelUID.getIdWithoutGroup()) {\n+                case SYSTEM_SOC:\n+                    if (system.getSoc() != null) {\n+                        state = new DecimalType(system.getSoc());\n+                    } else {\n+                        state = UnDefType.UNDEF;\n+                    }\n+                    break;\n+                case SYSTEM_CHARGE:\n+                    if (system.getCharge() != null) {\n+                        state = OnOffType.from(system.getCharge());\n+                    } else {\n+                        state = UnDefType.UNDEF;\n+                    }\n+                    break;\n+                case SYSTEM_RSSI_SIGNALSTRENGTH:\n+                    int dbm = system.getRssi();\n+                    if (dbm >= -80) {\n+                        state = new DecimalType(4);\n+                    } else if (dbm >= -95) {\n+                        state = new DecimalType(3);\n+                    } else if (dbm >= -105) {\n+                        state = new DecimalType(2);\n+                    } else {\n+                        state = new DecimalType(1);\n+                    }\n+                    break;\n+                case SYSTEM_RSSI:\n+                    state = new QuantityType<>(system.getRssi(), Units.DECIBEL_MILLIWATTS);\n+                    break;\n+            }\n+        } else if (channelUID.getId().startsWith(\"channel\")) {\n+            int channelId = Integer.parseInt(groupId.substring(\"channel\".length())) - 1;\n+            if (channel != null && channel.size() > 0 && channelId < channel.size()) {\n+                switch (channelUID.getIdWithoutGroup()) {\n+                    case CHANNEL_NAME:\n+                        state = new StringType(channel.get(channelId).getName());\n+                        break;\n+                    case CHANNEL_TYP:\n+                        state = new StringType(settings.getSensors().get(channel.get(channelId).getTyp()).getName());\n+                        break;\n+                    case CHANNEL_TEMP:\n+                        if (channel.get(channelId).getTemp() == 999.0) {\n+                            state = UnDefType.UNDEF;\n+                        } else {\n+                            state = new QuantityType<>(channel.get(channelId).getTemp(), unit);\n+                        }\n+                        break;\n+                    case CHANNEL_MIN:\n+                        state = new QuantityType<>(channel.get(channelId).getMin(), unit);\n+                        break;\n+                    case CHANNEL_MAX:\n+                        state = new QuantityType<>(channel.get(channelId).getMax(), unit);\n+                        break;\n+                    case CHANNEL_ALARM_DEVICE:\n+                        state = OnOffType.from(BigInteger.valueOf(channel.get(channelId).getAlarm()).testBit(1));\n+                        break;\n+                    case CHANNEL_ALARM_PUSH:\n+                        state = OnOffType.from(BigInteger.valueOf(channel.get(channelId).getAlarm()).testBit(0));\n+                        break;\n+                    case CHANNEL_ALARM_OPENHAB_HIGH:\n+                        if (channel.get(channelId).getTemp() != 999\n+                                && channel.get(channelId).getTemp() > channel.get(channelId).getMax()) {\n+                            state = OnOffType.ON;\n+                        } else {\n+                            state = OnOffType.OFF;\n+                        }\n+                        break;\n+                    case CHANNEL_ALARM_OPENHAB_LOW:\n+                        if (channel.get(channelId).getTemp() != 999\n+                                && channel.get(channelId).getTemp() < channel.get(channelId).getMin()) {\n+                            state = OnOffType.ON;\n+                        } else {\n+                            state = OnOffType.OFF;\n+                        }\n+                        break;\n+                    case CHANNEL_COLOR:\n+                        String color = channel.get(channelId).getColor();\n+                        if (color != null && !color.isEmpty()) {\n+                            Color c = Color.decode(color);\n+                            state = HSBType.fromRGB(c.getRed(), c.getGreen(), c.getBlue());\n+                        }\n+                        break;\n+                    case CHANNEL_COLOR_NAME:\n+                        String colorHex = channel.get(channelId).getColor();\n+                        if (colorHex != null && !colorHex.isEmpty()) {\n+                            state = new StringType(UtilEsp32.toColorName(colorHex));\n+                        }\n+                        break;\n+                }\n+            }\n+        } else if (channelUID.getId().startsWith(\"pit1\")) {\n+            if (data.getPitmaster() != null && data.getPitmaster().getPm() != null\n+                    && data.getPitmaster().getPm().size() > 0) {\n+                Pm pm = data.getPitmaster().getPm().get(0);\n+                switch (channelUID.getIdWithoutGroup()) {\n+                    case CHANNEL_PITMASTER_CHANNEL_ID:\n+                        state = new DecimalType(pm.getChannel());\n+                        break;\n+                    case CHANNEL_PITMASTER_PIDPROFILE:\n+                        state = new DecimalType(pm.getPid());\n+                        break;\n+                    case CHANNEL_PITMASTER_DUTY_CYCLE:\n+                        state = new DecimalType(pm.getValue());\n+                        break;\n+                    case CHANNEL_PITMASTER_SETPOINT:\n+                        state = new QuantityType<>(pm.getSet(), unit);\n+                        break;\n+                    case CHANNEL_PITMASTER_STATE:\n+                        state = new StringType(pm.getTyp());\n+                }\n+            } else {\n+                return UnDefType.UNDEF;\n+            }\n+        }\n+        return state;\n+    }\n+\n+    public boolean setState(ChannelUID channelUID, Command command, Data data) {\n+        boolean success = false;\n+        String groupId = channelUID.getGroupId();\n+        if (groupId == null || data == null) {\n+            return false;\n+        }\n+        List<Channel> channel = data.getChannel();\n+        if (channelUID.getId().startsWith(\"channel\")) {\n+            int channelId = Integer.parseInt(groupId.substring(\"channel\".length())) - 1;\n+            if (channel.size() > 0 && channelId < channel.size()) {\n+                switch (channelUID.getIdWithoutGroup()) {\n+                    case CHANNEL_NAME:\n+                        if (command instanceof StringType) {\n+                            channel.get(channelId).setName(command.toFullString());\n+                            success = true;\n+                        }\n+                        break;\n+                    case CHANNEL_MIN:\n+                        if (command instanceof QuantityType) {\n+                            channel.get(channelId).setMin(((QuantityType<?>) command).doubleValue());\n+                            success = true;\n+                        }\n+                        break;\n+                    case CHANNEL_MAX:\n+                        if (command instanceof QuantityType) {\n+                            channel.get(channelId).setMax(((QuantityType<?>) command).doubleValue());\n+                            success = true;\n+                        }\n+                        break;\n+                    case CHANNEL_ALARM_DEVICE:\n+                        if (command instanceof OnOffType) {\n+                            BigInteger value;\n+                            if (command == OnOffType.ON) {\n+                                value = BigInteger.valueOf(channel.get(channelId).getAlarm()).setBit(1);\n+                            } else {\n+                                value = BigInteger.valueOf(channel.get(channelId).getAlarm()).clearBit(1);\n+                            }\n+                            channel.get(channelId).setAlarm(value.intValue());\n+                            success = true;\n+                        }\n+                        break;\n+                    case CHANNEL_ALARM_PUSH:\n+                        if (command instanceof OnOffType) {\n+                            BigInteger value;\n+                            if (command == OnOffType.ON) {\n+                                value = BigInteger.valueOf(channel.get(channelId).getAlarm()).setBit(0);\n+                            } else {\n+                                value = BigInteger.valueOf(channel.get(channelId).getAlarm()).clearBit(0);\n+                            }\n+                            channel.get(channelId).setAlarm(value.intValue());\n+                            success = true;\n+                        }\n+                        break;\n+                    case CHANNEL_COLOR_NAME:\n+                        if (command instanceof StringType) {\n+                            channel.get(channelId).setColor(UtilEsp32.toHex(((StringType) command).toString()));\n+                            success = true;\n+                        }\n+                        break;\n+                }\n+            }\n+        } else if (channelUID.getId().equals(\"pit1\")) {\n+            if (data.getPitmaster() != null && data.getPitmaster().getPm() != null\n+                    && data.getPitmaster().getPm().size() > 0) {\n+                Pm pm = data.getPitmaster().getPm().get(0);\n+                switch (channelUID.getIdWithoutGroup()) {\n+                    case CHANNEL_PITMASTER_CHANNEL_ID:\n+                        pm.setChannel(((QuantityType<?>) command).intValue());\n+                        success = true;\n+                        break;\n+                    case CHANNEL_PITMASTER_PIDPROFILE:\n+                        pm.setPid(((QuantityType<?>) command).intValue());\n+                        success = true;\n+                        break;\n+                    case CHANNEL_PITMASTER_SETPOINT:\n+                        pm.setSet(((QuantityType<?>) command).doubleValue());\n+                        success = true;\n+                        break;\n+                    case CHANNEL_PITMASTER_STATE:\n+                        String state = ((StringType) command).toString();\n+                        if (state.equalsIgnoreCase(\"off\") || state.equalsIgnoreCase(\"manual\")\n+                                || state.equalsIgnoreCase(\"auto\")) {\n+                            pm.setTyp(state);\n+                            success = true;\n+                        }\n+                }\n+            }\n+        }\n+        return success;\n+    }\n+\n+    public String getTrigger(ChannelUID channelUID, Data data) {\n+        String trigger = null;\n+        String groupId = channelUID.getGroupId();\n+        if (groupId == null || data == null) {\n+            return null;\n+        }\n+        List<Channel> channel = data.getChannel();\n+        if (channelUID.getId().startsWith(\"channel\")) {\n+            int channelId = Integer.parseInt(groupId.substring(\"channel\".length())) - 1;\n+            if (channel.size() > 0 && channelId < channel.size()) {\n+                if (CHANNEL_ALARM_OPENHAB.equals(channelUID.getIdWithoutGroup())) {\n+                    if (channel.get(channelId).getTemp() != 999) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjkzNDg0OA=="}, "originalCommit": {"oid": "aff5cb5d1d4586abbf71161d45993b63d09ab438"}, "originalPosition": 286}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ4MDA2NDQ0OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/api/esp32/WlanThermoEsp32CommandHandler.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNlQyMDowMjowMFrOIPUfGA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNlQyMDowMjowMFrOIPUfGA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjkzNTE5Mg==", "bodyText": "These channel ids should be constants specified in your WlanThermoBindingConstants file.", "url": "https://github.com/openhab/openhab-addons/pull/9579#discussion_r552935192", "createdAt": "2021-01-06T20:02:00Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/api/esp32/WlanThermoEsp32CommandHandler.java", "diffHunk": "@@ -0,0 +1,298 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.wlanthermo.internal.api.esp32;\n+\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.*;\n+\n+import java.awt.Color;\n+import java.math.BigInteger;\n+import java.util.List;\n+\n+import javax.measure.Unit;\n+import javax.measure.quantity.Temperature;\n+\n+import org.openhab.binding.wlanthermo.internal.api.esp32.dto.data.Channel;\n+import org.openhab.binding.wlanthermo.internal.api.esp32.dto.data.Data;\n+import org.openhab.binding.wlanthermo.internal.api.esp32.dto.data.Pm;\n+import org.openhab.binding.wlanthermo.internal.api.esp32.dto.data.System;\n+import org.openhab.binding.wlanthermo.internal.api.esp32.dto.settings.Settings;\n+import org.openhab.core.library.types.*;\n+import org.openhab.core.library.unit.ImperialUnits;\n+import org.openhab.core.library.unit.SIUnits;\n+import org.openhab.core.library.unit.Units;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.UnDefType;\n+\n+/**\n+ * The {@link WlanThermoEsp32CommandHandler} is responsible for mapping the Commands to the respective data fields\n+ * of the API.\n+ *\n+ * @author Christian Schlipp - Initial contribution\n+ */\n+public class WlanThermoEsp32CommandHandler {\n+\n+    public State getState(ChannelUID channelUID, Data data, Settings settings) {\n+        State state = null;\n+\n+        String groupId = channelUID.getGroupId();\n+        if (groupId == null || data == null || settings == null) {\n+            return null;\n+        }\n+\n+        System system = data.getSystem();\n+\n+        Unit<Temperature> unit;\n+        if (system.getUnit().equals(\"F\")) {\n+            unit = ImperialUnits.FAHRENHEIT;\n+        } else {\n+            // Default to Celsius\n+            unit = SIUnits.CELSIUS;\n+        }\n+\n+        List<Channel> channel = data.getChannel();\n+        if (\"system\".equals(groupId)) {\n+            switch (channelUID.getIdWithoutGroup()) {\n+                case SYSTEM_SOC:\n+                    if (system.getSoc() != null) {\n+                        state = new DecimalType(system.getSoc());\n+                    } else {\n+                        state = UnDefType.UNDEF;\n+                    }\n+                    break;\n+                case SYSTEM_CHARGE:\n+                    if (system.getCharge() != null) {\n+                        state = OnOffType.from(system.getCharge());\n+                    } else {\n+                        state = UnDefType.UNDEF;\n+                    }\n+                    break;\n+                case SYSTEM_RSSI_SIGNALSTRENGTH:\n+                    int dbm = system.getRssi();\n+                    if (dbm >= -80) {\n+                        state = new DecimalType(4);\n+                    } else if (dbm >= -95) {\n+                        state = new DecimalType(3);\n+                    } else if (dbm >= -105) {\n+                        state = new DecimalType(2);\n+                    } else {\n+                        state = new DecimalType(1);\n+                    }\n+                    break;\n+                case SYSTEM_RSSI:\n+                    state = new QuantityType<>(system.getRssi(), Units.DECIBEL_MILLIWATTS);\n+                    break;\n+            }\n+        } else if (channelUID.getId().startsWith(\"channel\")) {\n+            int channelId = Integer.parseInt(groupId.substring(\"channel\".length())) - 1;\n+            if (channel != null && channel.size() > 0 && channelId < channel.size()) {\n+                switch (channelUID.getIdWithoutGroup()) {\n+                    case CHANNEL_NAME:\n+                        state = new StringType(channel.get(channelId).getName());\n+                        break;\n+                    case CHANNEL_TYP:\n+                        state = new StringType(settings.getSensors().get(channel.get(channelId).getTyp()).getName());\n+                        break;\n+                    case CHANNEL_TEMP:\n+                        if (channel.get(channelId).getTemp() == 999.0) {\n+                            state = UnDefType.UNDEF;\n+                        } else {\n+                            state = new QuantityType<>(channel.get(channelId).getTemp(), unit);\n+                        }\n+                        break;\n+                    case CHANNEL_MIN:\n+                        state = new QuantityType<>(channel.get(channelId).getMin(), unit);\n+                        break;\n+                    case CHANNEL_MAX:\n+                        state = new QuantityType<>(channel.get(channelId).getMax(), unit);\n+                        break;\n+                    case CHANNEL_ALARM_DEVICE:\n+                        state = OnOffType.from(BigInteger.valueOf(channel.get(channelId).getAlarm()).testBit(1));\n+                        break;\n+                    case CHANNEL_ALARM_PUSH:\n+                        state = OnOffType.from(BigInteger.valueOf(channel.get(channelId).getAlarm()).testBit(0));\n+                        break;\n+                    case CHANNEL_ALARM_OPENHAB_HIGH:\n+                        if (channel.get(channelId).getTemp() != 999\n+                                && channel.get(channelId).getTemp() > channel.get(channelId).getMax()) {\n+                            state = OnOffType.ON;\n+                        } else {\n+                            state = OnOffType.OFF;\n+                        }\n+                        break;\n+                    case CHANNEL_ALARM_OPENHAB_LOW:\n+                        if (channel.get(channelId).getTemp() != 999\n+                                && channel.get(channelId).getTemp() < channel.get(channelId).getMin()) {\n+                            state = OnOffType.ON;\n+                        } else {\n+                            state = OnOffType.OFF;\n+                        }\n+                        break;\n+                    case CHANNEL_COLOR:\n+                        String color = channel.get(channelId).getColor();\n+                        if (color != null && !color.isEmpty()) {\n+                            Color c = Color.decode(color);\n+                            state = HSBType.fromRGB(c.getRed(), c.getGreen(), c.getBlue());\n+                        }\n+                        break;\n+                    case CHANNEL_COLOR_NAME:\n+                        String colorHex = channel.get(channelId).getColor();\n+                        if (colorHex != null && !colorHex.isEmpty()) {\n+                            state = new StringType(UtilEsp32.toColorName(colorHex));\n+                        }\n+                        break;\n+                }\n+            }\n+        } else if (channelUID.getId().startsWith(\"pit1\")) {\n+            if (data.getPitmaster() != null && data.getPitmaster().getPm() != null\n+                    && data.getPitmaster().getPm().size() > 0) {\n+                Pm pm = data.getPitmaster().getPm().get(0);\n+                switch (channelUID.getIdWithoutGroup()) {\n+                    case CHANNEL_PITMASTER_CHANNEL_ID:\n+                        state = new DecimalType(pm.getChannel());\n+                        break;\n+                    case CHANNEL_PITMASTER_PIDPROFILE:\n+                        state = new DecimalType(pm.getPid());\n+                        break;\n+                    case CHANNEL_PITMASTER_DUTY_CYCLE:\n+                        state = new DecimalType(pm.getValue());\n+                        break;\n+                    case CHANNEL_PITMASTER_SETPOINT:\n+                        state = new QuantityType<>(pm.getSet(), unit);\n+                        break;\n+                    case CHANNEL_PITMASTER_STATE:\n+                        state = new StringType(pm.getTyp());\n+                }\n+            } else {\n+                return UnDefType.UNDEF;\n+            }\n+        }\n+        return state;\n+    }\n+\n+    public boolean setState(ChannelUID channelUID, Command command, Data data) {\n+        boolean success = false;\n+        String groupId = channelUID.getGroupId();\n+        if (groupId == null || data == null) {\n+            return false;\n+        }\n+        List<Channel> channel = data.getChannel();\n+        if (channelUID.getId().startsWith(\"channel\")) {\n+            int channelId = Integer.parseInt(groupId.substring(\"channel\".length())) - 1;\n+            if (channel.size() > 0 && channelId < channel.size()) {\n+                switch (channelUID.getIdWithoutGroup()) {\n+                    case CHANNEL_NAME:\n+                        if (command instanceof StringType) {\n+                            channel.get(channelId).setName(command.toFullString());\n+                            success = true;\n+                        }\n+                        break;\n+                    case CHANNEL_MIN:\n+                        if (command instanceof QuantityType) {\n+                            channel.get(channelId).setMin(((QuantityType<?>) command).doubleValue());\n+                            success = true;\n+                        }\n+                        break;\n+                    case CHANNEL_MAX:\n+                        if (command instanceof QuantityType) {\n+                            channel.get(channelId).setMax(((QuantityType<?>) command).doubleValue());\n+                            success = true;\n+                        }\n+                        break;\n+                    case CHANNEL_ALARM_DEVICE:\n+                        if (command instanceof OnOffType) {\n+                            BigInteger value;\n+                            if (command == OnOffType.ON) {\n+                                value = BigInteger.valueOf(channel.get(channelId).getAlarm()).setBit(1);\n+                            } else {\n+                                value = BigInteger.valueOf(channel.get(channelId).getAlarm()).clearBit(1);\n+                            }\n+                            channel.get(channelId).setAlarm(value.intValue());\n+                            success = true;\n+                        }\n+                        break;\n+                    case CHANNEL_ALARM_PUSH:\n+                        if (command instanceof OnOffType) {\n+                            BigInteger value;\n+                            if (command == OnOffType.ON) {\n+                                value = BigInteger.valueOf(channel.get(channelId).getAlarm()).setBit(0);\n+                            } else {\n+                                value = BigInteger.valueOf(channel.get(channelId).getAlarm()).clearBit(0);\n+                            }\n+                            channel.get(channelId).setAlarm(value.intValue());\n+                            success = true;\n+                        }\n+                        break;\n+                    case CHANNEL_COLOR_NAME:\n+                        if (command instanceof StringType) {\n+                            channel.get(channelId).setColor(UtilEsp32.toHex(((StringType) command).toString()));\n+                            success = true;\n+                        }\n+                        break;\n+                }\n+            }\n+        } else if (channelUID.getId().equals(\"pit1\")) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aff5cb5d1d4586abbf71161d45993b63d09ab438"}, "originalPosition": 245}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ4MDA2Nzg2OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/api/esp32/WlanThermoEsp32Handler.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNlQyMDowMzoyNVrOIPUhMQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNlQyMDowMzoyNVrOIPUhMQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjkzNTcyOQ==", "bodyText": "Any reason this couldn't be static final?", "url": "https://github.com/openhab/openhab-addons/pull/9579#discussion_r552935729", "createdAt": "2021-01-06T20:03:25Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/api/esp32/WlanThermoEsp32Handler.java", "diffHunk": "@@ -0,0 +1,222 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.wlanthermo.internal.api.esp32;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.Map;\n+import java.util.concurrent.*;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.Authentication;\n+import org.eclipse.jetty.client.api.AuthenticationStore;\n+import org.eclipse.jetty.client.util.DigestAuthentication;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants;\n+import org.openhab.binding.wlanthermo.internal.WlanThermoExtendedConfiguration;\n+import org.openhab.binding.wlanthermo.internal.api.esp32.dto.data.Data;\n+import org.openhab.binding.wlanthermo.internal.api.esp32.dto.settings.Settings;\n+import org.openhab.core.thing.*;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+\n+/**\n+ * The {@link WlanThermoEsp32Handler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Christian Schlipp - Initial contribution\n+ */\n+@NonNullByDefault\n+public class WlanThermoEsp32Handler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(WlanThermoEsp32Handler.class);\n+\n+    private WlanThermoExtendedConfiguration config = new WlanThermoExtendedConfiguration();\n+    private WlanThermoEsp32CommandHandler wlanThermoEsp32CommandHandler = new WlanThermoEsp32CommandHandler();\n+    private final HttpClient httpClient;\n+    private @Nullable ScheduledFuture<?> pollingScheduler;\n+    private final Gson gson = new Gson();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aff5cb5d1d4586abbf71161d45993b63d09ab438"}, "originalPosition": 57}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ4MDA3MTEyOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/api/esp32/WlanThermoEsp32CommandHandler.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNlQyMDowNDozNFrOIPUjKg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNlQyMDowNDozNFrOIPUjKg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjkzNjIzNA==", "bodyText": "This class is stateless, so I see no reason you couldn't make all of it's method static.\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public State getState(ChannelUID channelUID, Data data, Settings settings) {\n          \n          \n            \n                public static State getState(ChannelUID channelUID, Data data, Settings settings) {", "url": "https://github.com/openhab/openhab-addons/pull/9579#discussion_r552936234", "createdAt": "2021-01-06T20:04:34Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/api/esp32/WlanThermoEsp32CommandHandler.java", "diffHunk": "@@ -0,0 +1,298 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.wlanthermo.internal.api.esp32;\n+\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.*;\n+\n+import java.awt.Color;\n+import java.math.BigInteger;\n+import java.util.List;\n+\n+import javax.measure.Unit;\n+import javax.measure.quantity.Temperature;\n+\n+import org.openhab.binding.wlanthermo.internal.api.esp32.dto.data.Channel;\n+import org.openhab.binding.wlanthermo.internal.api.esp32.dto.data.Data;\n+import org.openhab.binding.wlanthermo.internal.api.esp32.dto.data.Pm;\n+import org.openhab.binding.wlanthermo.internal.api.esp32.dto.data.System;\n+import org.openhab.binding.wlanthermo.internal.api.esp32.dto.settings.Settings;\n+import org.openhab.core.library.types.*;\n+import org.openhab.core.library.unit.ImperialUnits;\n+import org.openhab.core.library.unit.SIUnits;\n+import org.openhab.core.library.unit.Units;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.UnDefType;\n+\n+/**\n+ * The {@link WlanThermoEsp32CommandHandler} is responsible for mapping the Commands to the respective data fields\n+ * of the API.\n+ *\n+ * @author Christian Schlipp - Initial contribution\n+ */\n+public class WlanThermoEsp32CommandHandler {\n+\n+    public State getState(ChannelUID channelUID, Data data, Settings settings) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aff5cb5d1d4586abbf71161d45993b63d09ab438"}, "originalPosition": 46}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ4MDA3MjM2OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/api/esp32/WlanThermoEsp32Handler.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNlQyMDowNTowN1rOIPUj8g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNlQyMDowNTowN1rOIPUj8g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjkzNjQzNA==", "bodyText": "This declaration can go away once you make all the methods static.", "url": "https://github.com/openhab/openhab-addons/pull/9579#discussion_r552936434", "createdAt": "2021-01-06T20:05:07Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/api/esp32/WlanThermoEsp32Handler.java", "diffHunk": "@@ -0,0 +1,222 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.wlanthermo.internal.api.esp32;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.Map;\n+import java.util.concurrent.*;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.Authentication;\n+import org.eclipse.jetty.client.api.AuthenticationStore;\n+import org.eclipse.jetty.client.util.DigestAuthentication;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants;\n+import org.openhab.binding.wlanthermo.internal.WlanThermoExtendedConfiguration;\n+import org.openhab.binding.wlanthermo.internal.api.esp32.dto.data.Data;\n+import org.openhab.binding.wlanthermo.internal.api.esp32.dto.settings.Settings;\n+import org.openhab.core.thing.*;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+\n+/**\n+ * The {@link WlanThermoEsp32Handler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Christian Schlipp - Initial contribution\n+ */\n+@NonNullByDefault\n+public class WlanThermoEsp32Handler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(WlanThermoEsp32Handler.class);\n+\n+    private WlanThermoExtendedConfiguration config = new WlanThermoExtendedConfiguration();\n+    private WlanThermoEsp32CommandHandler wlanThermoEsp32CommandHandler = new WlanThermoEsp32CommandHandler();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aff5cb5d1d4586abbf71161d45993b63d09ab438"}, "originalPosition": 54}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ4MDA5MTE4OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/api/esp32/WlanThermoEsp32Handler.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNlQyMDoxMjowN1rOIPUvRg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNlQyMDoxMjowN1rOIPUvRg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjkzOTMzNA==", "bodyText": "Can you merge the checkConnection and update methods into a single method so that you only require a single period task to be set during initialize? Things can go wrong if you are assigning the pollingScheduler field in other threads outside of the initialize and dispose methods.", "url": "https://github.com/openhab/openhab-addons/pull/9579#discussion_r552939334", "createdAt": "2021-01-06T20:12:07Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/api/esp32/WlanThermoEsp32Handler.java", "diffHunk": "@@ -0,0 +1,222 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.wlanthermo.internal.api.esp32;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.Map;\n+import java.util.concurrent.*;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.Authentication;\n+import org.eclipse.jetty.client.api.AuthenticationStore;\n+import org.eclipse.jetty.client.util.DigestAuthentication;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants;\n+import org.openhab.binding.wlanthermo.internal.WlanThermoExtendedConfiguration;\n+import org.openhab.binding.wlanthermo.internal.api.esp32.dto.data.Data;\n+import org.openhab.binding.wlanthermo.internal.api.esp32.dto.settings.Settings;\n+import org.openhab.core.thing.*;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+\n+/**\n+ * The {@link WlanThermoEsp32Handler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Christian Schlipp - Initial contribution\n+ */\n+@NonNullByDefault\n+public class WlanThermoEsp32Handler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(WlanThermoEsp32Handler.class);\n+\n+    private WlanThermoExtendedConfiguration config = new WlanThermoExtendedConfiguration();\n+    private WlanThermoEsp32CommandHandler wlanThermoEsp32CommandHandler = new WlanThermoEsp32CommandHandler();\n+    private final HttpClient httpClient;\n+    private @Nullable ScheduledFuture<?> pollingScheduler;\n+    private final Gson gson = new Gson();\n+    private @Nullable Data data = new Data();\n+    private @Nullable Settings settings = new Settings();\n+\n+    public WlanThermoEsp32Handler(Thing thing, HttpClient httpClient) {\n+        super(thing);\n+        this.httpClient = httpClient;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        config = getConfigAs(WlanThermoExtendedConfiguration.class);\n+\n+        updateStatus(ThingStatus.UNKNOWN);\n+        try {\n+            if (!config.getUsername().isEmpty() && !config.getPassword().isEmpty()) {\n+                AuthenticationStore authStore = httpClient.getAuthenticationStore();\n+                authStore.addAuthentication(new DigestAuthentication(config.getUri(), Authentication.ANY_REALM,\n+                        config.getUsername(), config.getPassword()));\n+            }\n+            pollingScheduler = scheduler.schedule(this::checkConnection, config.getPollingInterval(), TimeUnit.SECONDS);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aff5cb5d1d4586abbf71161d45993b63d09ab438"}, "originalPosition": 77}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ4MDA5NzM3OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/api/esp32/WlanThermoEsp32Handler.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNlQyMDoxNDozNlrOIPUzGw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNlQyMDoxNDozNlrOIPUzGw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mjk0MDMxNQ==", "bodyText": "A communication error should be an offline status.\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                updateStatus(ThingStatus.ONLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n          \n          \n            \n                                        \"No or wrong login credentials provided. Please configure username/password for write access to WlanThermo!\");\n          \n          \n            \n                                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n          \n          \n            \n                                        \"No or wrong login credentials provided. Please configure username/password for write access to WlanThermo!\");\n          \n      \n    \n    \n  \n\nAlso if there is a credential problem here, why would you continue to send post requests for the other channels? That would just spam the logs with a bunch of failed auth attempts.", "url": "https://github.com/openhab/openhab-addons/pull/9579#discussion_r552940315", "createdAt": "2021-01-06T20:14:36Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/api/esp32/WlanThermoEsp32Handler.java", "diffHunk": "@@ -0,0 +1,222 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.wlanthermo.internal.api.esp32;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.Map;\n+import java.util.concurrent.*;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.Authentication;\n+import org.eclipse.jetty.client.api.AuthenticationStore;\n+import org.eclipse.jetty.client.util.DigestAuthentication;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants;\n+import org.openhab.binding.wlanthermo.internal.WlanThermoExtendedConfiguration;\n+import org.openhab.binding.wlanthermo.internal.api.esp32.dto.data.Data;\n+import org.openhab.binding.wlanthermo.internal.api.esp32.dto.settings.Settings;\n+import org.openhab.core.thing.*;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+\n+/**\n+ * The {@link WlanThermoEsp32Handler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Christian Schlipp - Initial contribution\n+ */\n+@NonNullByDefault\n+public class WlanThermoEsp32Handler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(WlanThermoEsp32Handler.class);\n+\n+    private WlanThermoExtendedConfiguration config = new WlanThermoExtendedConfiguration();\n+    private WlanThermoEsp32CommandHandler wlanThermoEsp32CommandHandler = new WlanThermoEsp32CommandHandler();\n+    private final HttpClient httpClient;\n+    private @Nullable ScheduledFuture<?> pollingScheduler;\n+    private final Gson gson = new Gson();\n+    private @Nullable Data data = new Data();\n+    private @Nullable Settings settings = new Settings();\n+\n+    public WlanThermoEsp32Handler(Thing thing, HttpClient httpClient) {\n+        super(thing);\n+        this.httpClient = httpClient;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        config = getConfigAs(WlanThermoExtendedConfiguration.class);\n+\n+        updateStatus(ThingStatus.UNKNOWN);\n+        try {\n+            if (!config.getUsername().isEmpty() && !config.getPassword().isEmpty()) {\n+                AuthenticationStore authStore = httpClient.getAuthenticationStore();\n+                authStore.addAuthentication(new DigestAuthentication(config.getUri(), Authentication.ANY_REALM,\n+                        config.getUsername(), config.getPassword()));\n+            }\n+            pollingScheduler = scheduler.schedule(this::checkConnection, config.getPollingInterval(), TimeUnit.SECONDS);\n+        } catch (URISyntaxException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"Failed to initialize WlanThermo Nano: \" + e.getMessage());\n+        }\n+    }\n+\n+    private void checkConnection() {\n+        try {\n+            if (httpClient.GET(config.getUri()).getStatus() == 200) {\n+                updateStatus(ThingStatus.ONLINE);\n+                ScheduledFuture<?> oldScheduler = pollingScheduler;\n+                if (oldScheduler != null) {\n+                    oldScheduler.cancel(false);\n+                }\n+                pollingScheduler = scheduler.scheduleWithFixedDelay(this::update, 0, config.getPollingInterval(),\n+                        TimeUnit.SECONDS);\n+            } else {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                        \"WlanThermo not found under given address.\");\n+            }\n+        } catch (URISyntaxException | InterruptedException | ExecutionException | TimeoutException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                    \"Could not connect to WlanThermo at \" + config.getIpAddress() + \": \" + e.getMessage());\n+            ScheduledFuture<?> oldScheduler = pollingScheduler;\n+            if (oldScheduler != null) {\n+                oldScheduler.cancel(false);\n+            }\n+            pollingScheduler = scheduler.schedule(this::checkConnection, config.getPollingInterval(), TimeUnit.SECONDS);\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            State s = wlanThermoEsp32CommandHandler.getState(channelUID, data, settings);\n+            if (s != null) {\n+                updateState(channelUID, s);\n+            }\n+        } else {\n+            if (wlanThermoEsp32CommandHandler.setState(channelUID, command, data)) {\n+                logger.debug(\"Data updated, pushing changes\");\n+                push();\n+            } else {\n+                logger.debug(\"Could not handle command of type {} for channel {}!\",\n+                        command.getClass().toGenericString(), channelUID.getId());\n+            }\n+        }\n+    }\n+\n+    private void update() {\n+        try {\n+            // Update objects with data from device\n+            String json = httpClient.GET(config.getUri(\"/data\")).getContentAsString();\n+            data = gson.fromJson(json, Data.class);\n+            logger.debug(\"Received at /data: {}\", json);\n+            json = httpClient.GET(config.getUri(\"/settings\")).getContentAsString();\n+            settings = gson.fromJson(json, Settings.class);\n+            logger.debug(\"Received at /settings: {}\", json);\n+\n+            if (data == null || settings == null) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        \"Failed to parse Data and/or Settings values!\");\n+                return;\n+            }\n+\n+            // Update Channels if required\n+            Map<String, String> properties = editProperties();\n+            Boolean pmEnabled = settings.getFeatures().getBluetooth();\n+            int pmChannels = pmEnabled ? data.getPitmaster().getPm().size() : 0;\n+            int tempChannels = data.getChannel().size();\n+\n+            // Update properties\n+            properties.put(WlanThermoBindingConstants.PROPERTY_MODEL, settings.getDevice().getDevice());\n+            properties.put(WlanThermoBindingConstants.PROPERTY_SERIAL, settings.getDevice().getSerial());\n+            properties.put(WlanThermoBindingConstants.PROPERTY_ESP32_BT_ENABLED,\n+                    settings.getFeatures().getBluetooth().toString());\n+            properties.put(WlanThermoBindingConstants.PROPERTY_ESP32_PM_ENABLED, pmEnabled.toString());\n+            properties.put(WlanThermoBindingConstants.PROPERTY_ESP32_TEMP_CHANNELS, String.valueOf(tempChannels));\n+            properties.put(WlanThermoBindingConstants.PROPERTY_ESP32_PM_CHANNELS, String.valueOf(pmChannels));\n+            updateProperties(properties);\n+\n+            // Update channel state\n+            for (Channel channel : thing.getChannels()) {\n+                State state = wlanThermoEsp32CommandHandler.getState(channel.getUID(), data, settings);\n+                if (state != null) {\n+                    updateState(channel.getUID(), state);\n+                } else {\n+                    // if we could not obtain a state, try trigger instead\n+                    String trigger = wlanThermoEsp32CommandHandler.getTrigger(channel.getUID(), data);\n+                    if (trigger != null) {\n+                        triggerChannel(channel.getUID(), trigger);\n+                    }\n+                }\n+            }\n+        } catch (URISyntaxException | InterruptedException | ExecutionException | TimeoutException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                    \"Update failed: \" + e.getMessage());\n+            ScheduledFuture<?> oldScheduler = pollingScheduler;\n+            if (oldScheduler != null) {\n+                oldScheduler.cancel(false);\n+            }\n+            for (Channel channel : thing.getChannels()) {\n+                updateState(channel.getUID(), UnDefType.UNDEF);\n+            }\n+            checkConnection();\n+        }\n+    }\n+\n+    private void push() {\n+        if (data == null) {\n+            return;\n+        }\n+        data.getChannel().forEach(c -> {\n+            try {\n+                String json = gson.toJson(c);\n+                URI uri = config.getUri(\"/setchannels\");\n+                int status = httpClient.POST(uri).content(new StringContentProvider(json), \"application/json\")\n+                        .timeout(5, TimeUnit.SECONDS).send().getStatus();\n+                if (status == 401) {\n+                    updateStatus(ThingStatus.ONLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                            \"No or wrong login credentials provided. Please configure username/password for write access to WlanThermo!\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aff5cb5d1d4586abbf71161d45993b63d09ab438"}, "originalPosition": 198}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ4MDA5ODY3OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/api/esp32/WlanThermoEsp32Handler.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNlQyMDoxNTowNVrOIPUz4Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNlQyMDoxNTowNVrOIPUz4Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mjk0MDUxMw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                updateStatus(ThingStatus.ONLINE, ThingStatusDetail.COMMUNICATION_ERROR, \"Failed to update channel \"\n          \n          \n            \n                                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, \"Failed to update channel \"", "url": "https://github.com/openhab/openhab-addons/pull/9579#discussion_r552940513", "createdAt": "2021-01-06T20:15:05Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/api/esp32/WlanThermoEsp32Handler.java", "diffHunk": "@@ -0,0 +1,222 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.wlanthermo.internal.api.esp32;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.Map;\n+import java.util.concurrent.*;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.Authentication;\n+import org.eclipse.jetty.client.api.AuthenticationStore;\n+import org.eclipse.jetty.client.util.DigestAuthentication;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants;\n+import org.openhab.binding.wlanthermo.internal.WlanThermoExtendedConfiguration;\n+import org.openhab.binding.wlanthermo.internal.api.esp32.dto.data.Data;\n+import org.openhab.binding.wlanthermo.internal.api.esp32.dto.settings.Settings;\n+import org.openhab.core.thing.*;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+\n+/**\n+ * The {@link WlanThermoEsp32Handler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Christian Schlipp - Initial contribution\n+ */\n+@NonNullByDefault\n+public class WlanThermoEsp32Handler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(WlanThermoEsp32Handler.class);\n+\n+    private WlanThermoExtendedConfiguration config = new WlanThermoExtendedConfiguration();\n+    private WlanThermoEsp32CommandHandler wlanThermoEsp32CommandHandler = new WlanThermoEsp32CommandHandler();\n+    private final HttpClient httpClient;\n+    private @Nullable ScheduledFuture<?> pollingScheduler;\n+    private final Gson gson = new Gson();\n+    private @Nullable Data data = new Data();\n+    private @Nullable Settings settings = new Settings();\n+\n+    public WlanThermoEsp32Handler(Thing thing, HttpClient httpClient) {\n+        super(thing);\n+        this.httpClient = httpClient;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        config = getConfigAs(WlanThermoExtendedConfiguration.class);\n+\n+        updateStatus(ThingStatus.UNKNOWN);\n+        try {\n+            if (!config.getUsername().isEmpty() && !config.getPassword().isEmpty()) {\n+                AuthenticationStore authStore = httpClient.getAuthenticationStore();\n+                authStore.addAuthentication(new DigestAuthentication(config.getUri(), Authentication.ANY_REALM,\n+                        config.getUsername(), config.getPassword()));\n+            }\n+            pollingScheduler = scheduler.schedule(this::checkConnection, config.getPollingInterval(), TimeUnit.SECONDS);\n+        } catch (URISyntaxException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"Failed to initialize WlanThermo Nano: \" + e.getMessage());\n+        }\n+    }\n+\n+    private void checkConnection() {\n+        try {\n+            if (httpClient.GET(config.getUri()).getStatus() == 200) {\n+                updateStatus(ThingStatus.ONLINE);\n+                ScheduledFuture<?> oldScheduler = pollingScheduler;\n+                if (oldScheduler != null) {\n+                    oldScheduler.cancel(false);\n+                }\n+                pollingScheduler = scheduler.scheduleWithFixedDelay(this::update, 0, config.getPollingInterval(),\n+                        TimeUnit.SECONDS);\n+            } else {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                        \"WlanThermo not found under given address.\");\n+            }\n+        } catch (URISyntaxException | InterruptedException | ExecutionException | TimeoutException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                    \"Could not connect to WlanThermo at \" + config.getIpAddress() + \": \" + e.getMessage());\n+            ScheduledFuture<?> oldScheduler = pollingScheduler;\n+            if (oldScheduler != null) {\n+                oldScheduler.cancel(false);\n+            }\n+            pollingScheduler = scheduler.schedule(this::checkConnection, config.getPollingInterval(), TimeUnit.SECONDS);\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            State s = wlanThermoEsp32CommandHandler.getState(channelUID, data, settings);\n+            if (s != null) {\n+                updateState(channelUID, s);\n+            }\n+        } else {\n+            if (wlanThermoEsp32CommandHandler.setState(channelUID, command, data)) {\n+                logger.debug(\"Data updated, pushing changes\");\n+                push();\n+            } else {\n+                logger.debug(\"Could not handle command of type {} for channel {}!\",\n+                        command.getClass().toGenericString(), channelUID.getId());\n+            }\n+        }\n+    }\n+\n+    private void update() {\n+        try {\n+            // Update objects with data from device\n+            String json = httpClient.GET(config.getUri(\"/data\")).getContentAsString();\n+            data = gson.fromJson(json, Data.class);\n+            logger.debug(\"Received at /data: {}\", json);\n+            json = httpClient.GET(config.getUri(\"/settings\")).getContentAsString();\n+            settings = gson.fromJson(json, Settings.class);\n+            logger.debug(\"Received at /settings: {}\", json);\n+\n+            if (data == null || settings == null) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        \"Failed to parse Data and/or Settings values!\");\n+                return;\n+            }\n+\n+            // Update Channels if required\n+            Map<String, String> properties = editProperties();\n+            Boolean pmEnabled = settings.getFeatures().getBluetooth();\n+            int pmChannels = pmEnabled ? data.getPitmaster().getPm().size() : 0;\n+            int tempChannels = data.getChannel().size();\n+\n+            // Update properties\n+            properties.put(WlanThermoBindingConstants.PROPERTY_MODEL, settings.getDevice().getDevice());\n+            properties.put(WlanThermoBindingConstants.PROPERTY_SERIAL, settings.getDevice().getSerial());\n+            properties.put(WlanThermoBindingConstants.PROPERTY_ESP32_BT_ENABLED,\n+                    settings.getFeatures().getBluetooth().toString());\n+            properties.put(WlanThermoBindingConstants.PROPERTY_ESP32_PM_ENABLED, pmEnabled.toString());\n+            properties.put(WlanThermoBindingConstants.PROPERTY_ESP32_TEMP_CHANNELS, String.valueOf(tempChannels));\n+            properties.put(WlanThermoBindingConstants.PROPERTY_ESP32_PM_CHANNELS, String.valueOf(pmChannels));\n+            updateProperties(properties);\n+\n+            // Update channel state\n+            for (Channel channel : thing.getChannels()) {\n+                State state = wlanThermoEsp32CommandHandler.getState(channel.getUID(), data, settings);\n+                if (state != null) {\n+                    updateState(channel.getUID(), state);\n+                } else {\n+                    // if we could not obtain a state, try trigger instead\n+                    String trigger = wlanThermoEsp32CommandHandler.getTrigger(channel.getUID(), data);\n+                    if (trigger != null) {\n+                        triggerChannel(channel.getUID(), trigger);\n+                    }\n+                }\n+            }\n+        } catch (URISyntaxException | InterruptedException | ExecutionException | TimeoutException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                    \"Update failed: \" + e.getMessage());\n+            ScheduledFuture<?> oldScheduler = pollingScheduler;\n+            if (oldScheduler != null) {\n+                oldScheduler.cancel(false);\n+            }\n+            for (Channel channel : thing.getChannels()) {\n+                updateState(channel.getUID(), UnDefType.UNDEF);\n+            }\n+            checkConnection();\n+        }\n+    }\n+\n+    private void push() {\n+        if (data == null) {\n+            return;\n+        }\n+        data.getChannel().forEach(c -> {\n+            try {\n+                String json = gson.toJson(c);\n+                URI uri = config.getUri(\"/setchannels\");\n+                int status = httpClient.POST(uri).content(new StringContentProvider(json), \"application/json\")\n+                        .timeout(5, TimeUnit.SECONDS).send().getStatus();\n+                if (status == 401) {\n+                    updateStatus(ThingStatus.ONLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                            \"No or wrong login credentials provided. Please configure username/password for write access to WlanThermo!\");\n+                } else if (status != 200) {\n+                    updateStatus(ThingStatus.ONLINE, ThingStatusDetail.COMMUNICATION_ERROR, \"Failed to update channel \"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aff5cb5d1d4586abbf71161d45993b63d09ab438"}, "originalPosition": 200}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ4MDA5OTIyOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/api/esp32/WlanThermoEsp32Handler.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNlQyMDoxNToxNVrOIPU0Lw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNlQyMDoxNToxNVrOIPU0Lw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mjk0MDU5MQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            updateStatus(ThingStatus.ONLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n          \n          \n            \n                            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,", "url": "https://github.com/openhab/openhab-addons/pull/9579#discussion_r552940591", "createdAt": "2021-01-06T20:15:15Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/api/esp32/WlanThermoEsp32Handler.java", "diffHunk": "@@ -0,0 +1,222 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.wlanthermo.internal.api.esp32;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.Map;\n+import java.util.concurrent.*;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.Authentication;\n+import org.eclipse.jetty.client.api.AuthenticationStore;\n+import org.eclipse.jetty.client.util.DigestAuthentication;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants;\n+import org.openhab.binding.wlanthermo.internal.WlanThermoExtendedConfiguration;\n+import org.openhab.binding.wlanthermo.internal.api.esp32.dto.data.Data;\n+import org.openhab.binding.wlanthermo.internal.api.esp32.dto.settings.Settings;\n+import org.openhab.core.thing.*;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+\n+/**\n+ * The {@link WlanThermoEsp32Handler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Christian Schlipp - Initial contribution\n+ */\n+@NonNullByDefault\n+public class WlanThermoEsp32Handler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(WlanThermoEsp32Handler.class);\n+\n+    private WlanThermoExtendedConfiguration config = new WlanThermoExtendedConfiguration();\n+    private WlanThermoEsp32CommandHandler wlanThermoEsp32CommandHandler = new WlanThermoEsp32CommandHandler();\n+    private final HttpClient httpClient;\n+    private @Nullable ScheduledFuture<?> pollingScheduler;\n+    private final Gson gson = new Gson();\n+    private @Nullable Data data = new Data();\n+    private @Nullable Settings settings = new Settings();\n+\n+    public WlanThermoEsp32Handler(Thing thing, HttpClient httpClient) {\n+        super(thing);\n+        this.httpClient = httpClient;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        config = getConfigAs(WlanThermoExtendedConfiguration.class);\n+\n+        updateStatus(ThingStatus.UNKNOWN);\n+        try {\n+            if (!config.getUsername().isEmpty() && !config.getPassword().isEmpty()) {\n+                AuthenticationStore authStore = httpClient.getAuthenticationStore();\n+                authStore.addAuthentication(new DigestAuthentication(config.getUri(), Authentication.ANY_REALM,\n+                        config.getUsername(), config.getPassword()));\n+            }\n+            pollingScheduler = scheduler.schedule(this::checkConnection, config.getPollingInterval(), TimeUnit.SECONDS);\n+        } catch (URISyntaxException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"Failed to initialize WlanThermo Nano: \" + e.getMessage());\n+        }\n+    }\n+\n+    private void checkConnection() {\n+        try {\n+            if (httpClient.GET(config.getUri()).getStatus() == 200) {\n+                updateStatus(ThingStatus.ONLINE);\n+                ScheduledFuture<?> oldScheduler = pollingScheduler;\n+                if (oldScheduler != null) {\n+                    oldScheduler.cancel(false);\n+                }\n+                pollingScheduler = scheduler.scheduleWithFixedDelay(this::update, 0, config.getPollingInterval(),\n+                        TimeUnit.SECONDS);\n+            } else {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                        \"WlanThermo not found under given address.\");\n+            }\n+        } catch (URISyntaxException | InterruptedException | ExecutionException | TimeoutException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                    \"Could not connect to WlanThermo at \" + config.getIpAddress() + \": \" + e.getMessage());\n+            ScheduledFuture<?> oldScheduler = pollingScheduler;\n+            if (oldScheduler != null) {\n+                oldScheduler.cancel(false);\n+            }\n+            pollingScheduler = scheduler.schedule(this::checkConnection, config.getPollingInterval(), TimeUnit.SECONDS);\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            State s = wlanThermoEsp32CommandHandler.getState(channelUID, data, settings);\n+            if (s != null) {\n+                updateState(channelUID, s);\n+            }\n+        } else {\n+            if (wlanThermoEsp32CommandHandler.setState(channelUID, command, data)) {\n+                logger.debug(\"Data updated, pushing changes\");\n+                push();\n+            } else {\n+                logger.debug(\"Could not handle command of type {} for channel {}!\",\n+                        command.getClass().toGenericString(), channelUID.getId());\n+            }\n+        }\n+    }\n+\n+    private void update() {\n+        try {\n+            // Update objects with data from device\n+            String json = httpClient.GET(config.getUri(\"/data\")).getContentAsString();\n+            data = gson.fromJson(json, Data.class);\n+            logger.debug(\"Received at /data: {}\", json);\n+            json = httpClient.GET(config.getUri(\"/settings\")).getContentAsString();\n+            settings = gson.fromJson(json, Settings.class);\n+            logger.debug(\"Received at /settings: {}\", json);\n+\n+            if (data == null || settings == null) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        \"Failed to parse Data and/or Settings values!\");\n+                return;\n+            }\n+\n+            // Update Channels if required\n+            Map<String, String> properties = editProperties();\n+            Boolean pmEnabled = settings.getFeatures().getBluetooth();\n+            int pmChannels = pmEnabled ? data.getPitmaster().getPm().size() : 0;\n+            int tempChannels = data.getChannel().size();\n+\n+            // Update properties\n+            properties.put(WlanThermoBindingConstants.PROPERTY_MODEL, settings.getDevice().getDevice());\n+            properties.put(WlanThermoBindingConstants.PROPERTY_SERIAL, settings.getDevice().getSerial());\n+            properties.put(WlanThermoBindingConstants.PROPERTY_ESP32_BT_ENABLED,\n+                    settings.getFeatures().getBluetooth().toString());\n+            properties.put(WlanThermoBindingConstants.PROPERTY_ESP32_PM_ENABLED, pmEnabled.toString());\n+            properties.put(WlanThermoBindingConstants.PROPERTY_ESP32_TEMP_CHANNELS, String.valueOf(tempChannels));\n+            properties.put(WlanThermoBindingConstants.PROPERTY_ESP32_PM_CHANNELS, String.valueOf(pmChannels));\n+            updateProperties(properties);\n+\n+            // Update channel state\n+            for (Channel channel : thing.getChannels()) {\n+                State state = wlanThermoEsp32CommandHandler.getState(channel.getUID(), data, settings);\n+                if (state != null) {\n+                    updateState(channel.getUID(), state);\n+                } else {\n+                    // if we could not obtain a state, try trigger instead\n+                    String trigger = wlanThermoEsp32CommandHandler.getTrigger(channel.getUID(), data);\n+                    if (trigger != null) {\n+                        triggerChannel(channel.getUID(), trigger);\n+                    }\n+                }\n+            }\n+        } catch (URISyntaxException | InterruptedException | ExecutionException | TimeoutException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                    \"Update failed: \" + e.getMessage());\n+            ScheduledFuture<?> oldScheduler = pollingScheduler;\n+            if (oldScheduler != null) {\n+                oldScheduler.cancel(false);\n+            }\n+            for (Channel channel : thing.getChannels()) {\n+                updateState(channel.getUID(), UnDefType.UNDEF);\n+            }\n+            checkConnection();\n+        }\n+    }\n+\n+    private void push() {\n+        if (data == null) {\n+            return;\n+        }\n+        data.getChannel().forEach(c -> {\n+            try {\n+                String json = gson.toJson(c);\n+                URI uri = config.getUri(\"/setchannels\");\n+                int status = httpClient.POST(uri).content(new StringContentProvider(json), \"application/json\")\n+                        .timeout(5, TimeUnit.SECONDS).send().getStatus();\n+                if (status == 401) {\n+                    updateStatus(ThingStatus.ONLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                            \"No or wrong login credentials provided. Please configure username/password for write access to WlanThermo!\");\n+                } else if (status != 200) {\n+                    updateStatus(ThingStatus.ONLINE, ThingStatusDetail.COMMUNICATION_ERROR, \"Failed to update channel \"\n+                            + c.getName() + \" on device, Statuscode \" + status + \" on URI \" + uri.toString());\n+                    logger.debug(\"Payload sent: {}\", json);\n+                } else {\n+                    updateStatus(ThingStatus.ONLINE);\n+                }\n+            } catch (InterruptedException | TimeoutException | ExecutionException | URISyntaxException e) {\n+                updateStatus(ThingStatus.ONLINE, ThingStatusDetail.COMMUNICATION_ERROR,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aff5cb5d1d4586abbf71161d45993b63d09ab438"}, "originalPosition": 207}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ4MDEwOTAzOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/api/mini/WlanThermoMiniCommandHandler.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNlQyMDoxODo1NVrOIPU59g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wOVQxMToyNDowOVrOIQs6YQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mjk0MjA3MA==", "bodyText": "So the mini uses \"fahrenheit\" instead of \"F\"?", "url": "https://github.com/openhab/openhab-addons/pull/9579#discussion_r552942070", "createdAt": "2021-01-06T20:18:55Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/api/mini/WlanThermoMiniCommandHandler.java", "diffHunk": "@@ -33,7 +36,21 @@\n \n     public State getState(ChannelUID channelUID, App app) {\n         State state = null;\n-        if (\"system\".equals(channelUID.getGroupId())) {\n+\n+        String groupId = channelUID.getGroupId();\n+        if (groupId == null || app == null) {\n+            return null;\n+        }\n+\n+        Unit<Temperature> unit;\n+        if (app.getTempUnit().equals(\"fahrenheit\")) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aff5cb5d1d4586abbf71161d45993b63d09ab438"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDM4Mzk2OQ==", "bodyText": "yes, the API implementations unfortunately differ between the devices.", "url": "https://github.com/openhab/openhab-addons/pull/9579#discussion_r554383969", "createdAt": "2021-01-09T11:24:09Z", "author": {"login": "CSchlipp"}, "path": "bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/api/mini/WlanThermoMiniCommandHandler.java", "diffHunk": "@@ -33,7 +36,21 @@\n \n     public State getState(ChannelUID channelUID, App app) {\n         State state = null;\n-        if (\"system\".equals(channelUID.getGroupId())) {\n+\n+        String groupId = channelUID.getGroupId();\n+        if (groupId == null || app == null) {\n+            return null;\n+        }\n+\n+        Unit<Temperature> unit;\n+        if (app.getTempUnit().equals(\"fahrenheit\")) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mjk0MjA3MA=="}, "originalCommit": {"oid": "aff5cb5d1d4586abbf71161d45993b63d09ab438"}, "originalPosition": 36}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ4MDExOTcwOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.wlanthermo/src/main/resources/OH-INF/thing/channel-types.xml", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNlQyMDoyMzowOVrOIPVAeg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNlQyMDoyMzowOVrOIPVAeg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mjk0MzczOA==", "bodyText": "Why is this category Text?", "url": "https://github.com/openhab/openhab-addons/pull/9579#discussion_r552943738", "createdAt": "2021-01-06T20:23:09Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.wlanthermo/src/main/resources/OH-INF/thing/channel-types.xml", "diffHunk": "@@ -0,0 +1,260 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"wlanthermo\"\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\t<channel-type id=\"cpu_load\" advanced=\"true\">\n+\t\t<item-type>Number</item-type>\n+\t\t<label>CPU Load</label>\n+\t\t<state readOnly=\"true\"/>\n+\t</channel-type>\n+\n+\t<channel-type id=\"name\" advanced=\"false\">\n+\t\t<item-type>String</item-type>\n+\t\t<label>Name</label>\n+\t\t<category>Text</category>\n+\t</channel-type>\n+\n+\t<channel-type id=\"name_ro\" advanced=\"false\">\n+\t\t<item-type>String</item-type>\n+\t\t<label>Name</label>\n+\t\t<category>Text</category>\n+\t\t<state readOnly=\"true\"/>\n+\t</channel-type>\n+\n+\t<channel-type id=\"typ\" advanced=\"true\">\n+\t\t<item-type>String</item-type>\n+\t\t<label>Type</label>\n+\t\t<category>Text</category>\n+\t\t<state readOnly=\"true\"/>\n+\t</channel-type>\n+\n+\t<channel-type id=\"temperature\" advanced=\"false\">\n+\t\t<item-type>Number:Temperature</item-type>\n+\t\t<label>Current Temperature</label>\n+\t\t<category>Temperature</category>\n+\t\t<state min=\"0\" pattern=\"%.1f %unit%\" readOnly=\"true\"/>\n+\t</channel-type>\n+\n+\t<channel-type id=\"temperature_min\" advanced=\"true\">\n+\t\t<item-type>Number:Temperature</item-type>\n+\t\t<label>Low Temperature Alarm</label>\n+\t\t<category>Temperature</category>\n+\t\t<state min=\"0\" step=\"0.1\" pattern=\"%.1f %unit%\" readOnly=\"false\"/>\n+\t</channel-type>\n+\n+\t<channel-type id=\"temperature_max\" advanced=\"true\">\n+\t\t<item-type>Number:Temperature</item-type>\n+\t\t<label>High Temperature Alarm</label>\n+\t\t<category>Temperature</category>\n+\t\t<state min=\"0\" step=\"0.1\" pattern=\"%.1f %unit%\" readOnly=\"false\"/>\n+\t</channel-type>\n+\n+\t<channel-type id=\"temperature_min_ro\" advanced=\"true\">\n+\t\t<item-type>Number:Temperature</item-type>\n+\t\t<label>Low Temperature Alarm</label>\n+\t\t<category>Temperature</category>\n+\t\t<state min=\"0\" step=\"0.1\" pattern=\"%.1f %unit%\" readOnly=\"true\"/>\n+\t</channel-type>\n+\n+\t<channel-type id=\"temperature_max_ro\" advanced=\"true\">\n+\t\t<item-type>Number:Temperature</item-type>\n+\t\t<label>High Temperature Alarm</label>\n+\t\t<category>Temperature</category>\n+\t\t<state min=\"0\" step=\"0.1\" pattern=\"%.1f %unit%\" readOnly=\"true\"/>\n+\t</channel-type>\n+\n+\t<channel-type id=\"alarm_device\" advanced=\"true\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Alarm Buzzer</label>\n+\t\t<category>Switch</category>\n+\t</channel-type>\n+\n+\t<channel-type id=\"alarm_device_ro\" advanced=\"true\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Alarm Buzzer</label>\n+\t\t<category>Switch</category>\n+\t\t<state readOnly=\"true\"/>\n+\t</channel-type>\n+\n+\t<channel-type id=\"alarm_push\" advanced=\"true\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Push-Alarm</label>\n+\t\t<category>Switch</category>\n+\t</channel-type>\n+\n+\t<channel-type id=\"alarm_openhab\" advanced=\"true\">\n+\t\t<kind>trigger</kind>\n+\t\t<label>OpenHAB Alarm Trigger</label>\n+\t\t<event>\n+\t\t\t<options>\n+\t\t\t\t<option value=\"MIN\">Low Temperature Alarm</option>\n+\t\t\t\t<option value=\"MAX\">High Temperature Alarm</option>\n+\t\t\t</options>\n+\t\t</event>\n+\t</channel-type>\n+\n+\t<channel-type id=\"alarm_openhab_low\" advanced=\"false\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Low Temperature Alarm</label>\n+\t\t<state readOnly=\"true\"/>\n+\t</channel-type>\n+\n+\t<channel-type id=\"alarm_openhab_high\" advanced=\"false\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>High Temperature Alarm</label>\n+\t\t<state readOnly=\"true\"/>\n+\t</channel-type>\n+\n+\t<channel-type id=\"color\" advanced=\"true\">\n+\t\t<item-type>Color</item-type>\n+\t\t<label>Color</label>\n+\t\t<category>Colorpicker</category>\n+\t\t<state readOnly=\"true\"/>\n+\t</channel-type>\n+\n+\t<channel-type id=\"color_name_nano\" advanced=\"true\">\n+\t\t<item-type>String</item-type>\n+\t\t<label>Color</label>\n+\t\t<category>Colorpicker</category>\n+\t\t<state>\n+\t\t\t<options>\n+\t\t\t\t<option value=\"niagara\">Niagara</option>\n+\t\t\t\t<option value=\"rosa\">Rosa</option>\n+\t\t\t\t<option value=\"lapis blue\">Lapis Blue</option>\n+\t\t\t\t<option value=\"orange\">Orange</option>\n+\t\t\t\t<option value=\"lila\">Lila</option>\n+\t\t\t\t<option value=\"red\">Red</option>\n+\t\t\t\t<option value=\"green\">Green</option>\n+\t\t\t\t<option value=\"gold\">Gold</option>\n+\t\t\t\t<option value=\"kale\">Kale</option>\n+\t\t\t\t<option value=\"brown\">Brown</option>\n+\t\t\t</options>\n+\t\t</state>\n+\t</channel-type>\n+\n+\t<channel-type id=\"color_name_esp32\" advanced=\"true\">\n+\t\t<item-type>String</item-type>\n+\t\t<label>Color</label>\n+\t\t<category>Colorpicker</category>\n+\t\t<state>\n+\t\t\t<options>\n+\t\t\t\t<option value=\"#FFFF00\">yellow</option>\n+\t\t\t\t<option value=\"#FFC002\">dark yellow</option>\n+\t\t\t\t<option value=\"#00FF00\">green</option>\n+\t\t\t\t<option value=\"#FFFFFF\">white</option>\n+\t\t\t\t<option value=\"#FF1DC4\">pink</option>\n+\t\t\t\t<option value=\"#E46C0A\">orange</option>\n+\t\t\t\t<option value=\"#C3D69B\">olive</option>\n+\t\t\t\t<option value=\"#0FE6F1\">light blue</option>\n+\t\t\t\t<option value=\"#0000FF\">blue</option>\n+\t\t\t\t<option value=\"#03A923\">dark green</option>\n+\t\t\t\t<option value=\"#C84B32\">brown</option>\n+\t\t\t\t<option value=\"#FF9B69\">light brown</option>\n+\t\t\t\t<option value=\"#5082BE\">dark blue</option>\n+\t\t\t\t<option value=\"#FFB1D0\">light pink</option>\n+\t\t\t\t<option value=\"#A6EF03\">light green</option>\n+\t\t\t\t<option value=\"#D42A6B\">dark pink</option>\n+\t\t\t\t<option value=\"#FFDA8F\">beige</option>\n+\t\t\t\t<option value=\"#00B0F0\">azure</option>\n+\t\t\t\t<option value=\"#948A54\">dark olive</option>\n+\t\t\t</options>\n+\t\t</state>\n+\t</channel-type>\n+\n+\t<channel-type id=\"color_ro\" advanced=\"true\">\n+\t\t<item-type>Color</item-type>\n+\t\t<label>Color</label>\n+\t\t<category>Colorpicker</category>\n+\t\t<state readOnly=\"true\"/>\n+\t</channel-type>\n+\n+\t<channel-type id=\"color_name_mini_ro\" advanced=\"true\">\n+\t\t<item-type>String</item-type>\n+\t\t<label>Color Name</label>\n+\t\t<category>Text</category>\n+\t\t<state readOnly=\"true\"/>\n+\t</channel-type>\n+\n+\t<channel-type id=\"enabled\" advanced=\"false\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Enabled</label>\n+\t\t<state readOnly=\"true\"/>\n+\t</channel-type>\n+\n+\t<channel-type id=\"temperature_setpoint_ro\" advanced=\"false\">\n+\t\t<item-type>Number:Temperature</item-type>\n+\t\t<label>Setpoint Temperature</label>\n+\t\t<category>Temperature</category>\n+\t\t<state min=\"0\" pattern=\"%.1f %unit%\" readOnly=\"true\"/>\n+\t</channel-type>\n+\n+\t<channel-type id=\"duty_cycle_ro\" advanced=\"false\">\n+\t\t<item-type>Number</item-type>\n+\t\t<label>Duty Cycle / Control Out</label>\n+\t\t<state min=\"0\" max=\"100\" pattern=\"%d\" readOnly=\"true\"/>\n+\t</channel-type>\n+\n+\t<channel-type id=\"lid_open\" advanced=\"false\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Lid Open</label>\n+\t\t<state readOnly=\"true\"/>\n+\t</channel-type>\n+\n+\t<channel-type id=\"channel_id_ro\" advanced=\"false\">\n+\t\t<item-type>Number</item-type>\n+\t\t<label>Channel ID</label>\n+\t\t<state min=\"0\" max=\"9\" pattern=\"%d\" readOnly=\"true\"/>\n+\t</channel-type>\n+\n+\t<channel-type id=\"pitmaster_type\" advanced=\"false\">\n+\t\t<item-type>String</item-type>\n+\t\t<label>State</label>\n+\t\t<state>\n+\t\t\t<options>\n+\t\t\t\t<option value=\"off\">Off</option>\n+\t\t\t\t<option value=\"manual\">Manual</option>\n+\t\t\t\t<option value=\"auto\">Auto</option>\n+\t\t\t</options>\n+\t\t</state>\n+\t</channel-type>\n+\n+\t<channel-type id=\"duty_cycle\" advanced=\"false\">\n+\t\t<item-type>Number</item-type>\n+\t\t<label>Duty Cycle / Control Out</label>\n+\t\t<state min=\"0\" max=\"100\" pattern=\"%d\"/>\n+\t</channel-type>\n+\n+\t<channel-type id=\"pid_id\" advanced=\"false\">\n+\t\t<item-type>Number</item-type>\n+\t\t<label>PID Profile ID</label>\n+\t\t<state pattern=\"%d\"/>\n+\t</channel-type>\n+\n+\t<channel-type id=\"temperature_setpoint\" advanced=\"false\">\n+\t\t<item-type>Number:Temperature</item-type>\n+\t\t<label>Setpoint Temperature</label>\n+\t\t<category>Temperature</category>\n+\t\t<state min=\"0\" pattern=\"%.1f %unit%\"/>\n+\t</channel-type>\n+\n+\t<channel-type id=\"channel_id\" advanced=\"false\">\n+\t\t<item-type>Number</item-type>\n+\t\t<label>Temperature Channel ID</label>\n+\t\t<state min=\"1\" pattern=\"%d\"/>\n+\t</channel-type>\n+\n+\t<channel-type id=\"charging\" advanced=\"true\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Charging</label>\n+\t\t<category>Energy</category>\n+\t\t<state readOnly=\"true\"/>\n+\t</channel-type>\n+\n+\t<channel-type id=\"rssi\" advanced=\"true\">\n+\t\t<item-type>Number:Power</item-type>\n+\t\t<label>RSSI in dBm</label>\n+\t\t<category>Text</category>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aff5cb5d1d4586abbf71161d45993b63d09ab438"}, "originalPosition": 257}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ4MDE1NzIxOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.wlanthermo/src/main/resources/OH-INF/thing/channel-group-types-esp32.xml", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNlQyMDozNjozN1rOIPVWeQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xM1QyMjowMTowNFrOITFUcg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mjk0OTM2OQ==", "bodyText": "Since the group types are each meant for a specific thing type, why not define the group types in the thing type files instead?", "url": "https://github.com/openhab/openhab-addons/pull/9579#discussion_r552949369", "createdAt": "2021-01-06T20:36:37Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.wlanthermo/src/main/resources/OH-INF/thing/channel-group-types-esp32.xml", "diffHunk": "@@ -0,0 +1,51 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"wlanthermo\"\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\t<!-- System Group ESP32 -->\n+\t<channel-group-type id=\"cg_system_esp32\">", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aff5cb5d1d4586abbf71161d45993b63d09ab438"}, "originalPosition": 7}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDM5MTU2Ng==", "bodyText": "I've split this up to have a better overview on the different things, channel-groups and channels of the hardware versions.\nDoes it have any benefit of putting it in the same file?", "url": "https://github.com/openhab/openhab-addons/pull/9579#discussion_r554391566", "createdAt": "2021-01-09T11:38:12Z", "author": {"login": "CSchlipp"}, "path": "bundles/org.openhab.binding.wlanthermo/src/main/resources/OH-INF/thing/channel-group-types-esp32.xml", "diffHunk": "@@ -0,0 +1,51 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"wlanthermo\"\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\t<!-- System Group ESP32 -->\n+\t<channel-group-type id=\"cg_system_esp32\">", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mjk0OTM2OQ=="}, "originalCommit": {"oid": "aff5cb5d1d4586abbf71161d45993b63d09ab438"}, "originalPosition": 7}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Njg4MTAxMA==", "bodyText": "The only benefit is it is slightly better organized and thus requires less jumping around files to fully understand the thing xml configurations. But changing it is entirely up to you. Feel free to keep it as it is.", "url": "https://github.com/openhab/openhab-addons/pull/9579#discussion_r556881010", "createdAt": "2021-01-13T22:01:04Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.wlanthermo/src/main/resources/OH-INF/thing/channel-group-types-esp32.xml", "diffHunk": "@@ -0,0 +1,51 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"wlanthermo\"\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\t<!-- System Group ESP32 -->\n+\t<channel-group-type id=\"cg_system_esp32\">", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mjk0OTM2OQ=="}, "originalCommit": {"oid": "aff5cb5d1d4586abbf71161d45993b63d09ab438"}, "originalPosition": 7}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ4MDE2ODAwOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/api/esp32/WlanThermoEsp32Handler.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNlQyMDo0MDo0NlrOIPVc3A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNlQyMDo0MDo0NlrOIPVc3A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mjk1MTAwNA==", "bodyText": "Since handleCommand is called from UI threads you shouldn't make them execute potentially long running tasks like http requests. I suggest calling push asynchronously to prevent the UI from becoming unresponsive.", "url": "https://github.com/openhab/openhab-addons/pull/9579#discussion_r552951004", "createdAt": "2021-01-06T20:40:46Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/api/esp32/WlanThermoEsp32Handler.java", "diffHunk": "@@ -0,0 +1,222 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.wlanthermo.internal.api.esp32;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.Map;\n+import java.util.concurrent.*;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.Authentication;\n+import org.eclipse.jetty.client.api.AuthenticationStore;\n+import org.eclipse.jetty.client.util.DigestAuthentication;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants;\n+import org.openhab.binding.wlanthermo.internal.WlanThermoExtendedConfiguration;\n+import org.openhab.binding.wlanthermo.internal.api.esp32.dto.data.Data;\n+import org.openhab.binding.wlanthermo.internal.api.esp32.dto.settings.Settings;\n+import org.openhab.core.thing.*;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+\n+/**\n+ * The {@link WlanThermoEsp32Handler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Christian Schlipp - Initial contribution\n+ */\n+@NonNullByDefault\n+public class WlanThermoEsp32Handler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(WlanThermoEsp32Handler.class);\n+\n+    private WlanThermoExtendedConfiguration config = new WlanThermoExtendedConfiguration();\n+    private WlanThermoEsp32CommandHandler wlanThermoEsp32CommandHandler = new WlanThermoEsp32CommandHandler();\n+    private final HttpClient httpClient;\n+    private @Nullable ScheduledFuture<?> pollingScheduler;\n+    private final Gson gson = new Gson();\n+    private @Nullable Data data = new Data();\n+    private @Nullable Settings settings = new Settings();\n+\n+    public WlanThermoEsp32Handler(Thing thing, HttpClient httpClient) {\n+        super(thing);\n+        this.httpClient = httpClient;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        config = getConfigAs(WlanThermoExtendedConfiguration.class);\n+\n+        updateStatus(ThingStatus.UNKNOWN);\n+        try {\n+            if (!config.getUsername().isEmpty() && !config.getPassword().isEmpty()) {\n+                AuthenticationStore authStore = httpClient.getAuthenticationStore();\n+                authStore.addAuthentication(new DigestAuthentication(config.getUri(), Authentication.ANY_REALM,\n+                        config.getUsername(), config.getPassword()));\n+            }\n+            pollingScheduler = scheduler.schedule(this::checkConnection, config.getPollingInterval(), TimeUnit.SECONDS);\n+        } catch (URISyntaxException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"Failed to initialize WlanThermo Nano: \" + e.getMessage());\n+        }\n+    }\n+\n+    private void checkConnection() {\n+        try {\n+            if (httpClient.GET(config.getUri()).getStatus() == 200) {\n+                updateStatus(ThingStatus.ONLINE);\n+                ScheduledFuture<?> oldScheduler = pollingScheduler;\n+                if (oldScheduler != null) {\n+                    oldScheduler.cancel(false);\n+                }\n+                pollingScheduler = scheduler.scheduleWithFixedDelay(this::update, 0, config.getPollingInterval(),\n+                        TimeUnit.SECONDS);\n+            } else {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                        \"WlanThermo not found under given address.\");\n+            }\n+        } catch (URISyntaxException | InterruptedException | ExecutionException | TimeoutException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                    \"Could not connect to WlanThermo at \" + config.getIpAddress() + \": \" + e.getMessage());\n+            ScheduledFuture<?> oldScheduler = pollingScheduler;\n+            if (oldScheduler != null) {\n+                oldScheduler.cancel(false);\n+            }\n+            pollingScheduler = scheduler.schedule(this::checkConnection, config.getPollingInterval(), TimeUnit.SECONDS);\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            State s = wlanThermoEsp32CommandHandler.getState(channelUID, data, settings);\n+            if (s != null) {\n+                updateState(channelUID, s);\n+            }\n+        } else {\n+            if (wlanThermoEsp32CommandHandler.setState(channelUID, command, data)) {\n+                logger.debug(\"Data updated, pushing changes\");\n+                push();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aff5cb5d1d4586abbf71161d45993b63d09ab438"}, "originalPosition": 119}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ4MDE3NDQ1OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/api/esp32/WlanThermoEsp32Handler.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNlQyMDo0MzozNlrOIPVg9w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNlQyMDo0MzozNlrOIPVg9w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mjk1MjA1NQ==", "bodyText": "An you exit the push method as soon as possible if you catch an InterruptedException since that means that openhab is trying to shutdown. You should not delay shutdown if at all possible.", "url": "https://github.com/openhab/openhab-addons/pull/9579#discussion_r552952055", "createdAt": "2021-01-06T20:43:36Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/api/esp32/WlanThermoEsp32Handler.java", "diffHunk": "@@ -0,0 +1,222 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.wlanthermo.internal.api.esp32;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.Map;\n+import java.util.concurrent.*;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.Authentication;\n+import org.eclipse.jetty.client.api.AuthenticationStore;\n+import org.eclipse.jetty.client.util.DigestAuthentication;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants;\n+import org.openhab.binding.wlanthermo.internal.WlanThermoExtendedConfiguration;\n+import org.openhab.binding.wlanthermo.internal.api.esp32.dto.data.Data;\n+import org.openhab.binding.wlanthermo.internal.api.esp32.dto.settings.Settings;\n+import org.openhab.core.thing.*;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+\n+/**\n+ * The {@link WlanThermoEsp32Handler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Christian Schlipp - Initial contribution\n+ */\n+@NonNullByDefault\n+public class WlanThermoEsp32Handler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(WlanThermoEsp32Handler.class);\n+\n+    private WlanThermoExtendedConfiguration config = new WlanThermoExtendedConfiguration();\n+    private WlanThermoEsp32CommandHandler wlanThermoEsp32CommandHandler = new WlanThermoEsp32CommandHandler();\n+    private final HttpClient httpClient;\n+    private @Nullable ScheduledFuture<?> pollingScheduler;\n+    private final Gson gson = new Gson();\n+    private @Nullable Data data = new Data();\n+    private @Nullable Settings settings = new Settings();\n+\n+    public WlanThermoEsp32Handler(Thing thing, HttpClient httpClient) {\n+        super(thing);\n+        this.httpClient = httpClient;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        config = getConfigAs(WlanThermoExtendedConfiguration.class);\n+\n+        updateStatus(ThingStatus.UNKNOWN);\n+        try {\n+            if (!config.getUsername().isEmpty() && !config.getPassword().isEmpty()) {\n+                AuthenticationStore authStore = httpClient.getAuthenticationStore();\n+                authStore.addAuthentication(new DigestAuthentication(config.getUri(), Authentication.ANY_REALM,\n+                        config.getUsername(), config.getPassword()));\n+            }\n+            pollingScheduler = scheduler.schedule(this::checkConnection, config.getPollingInterval(), TimeUnit.SECONDS);\n+        } catch (URISyntaxException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"Failed to initialize WlanThermo Nano: \" + e.getMessage());\n+        }\n+    }\n+\n+    private void checkConnection() {\n+        try {\n+            if (httpClient.GET(config.getUri()).getStatus() == 200) {\n+                updateStatus(ThingStatus.ONLINE);\n+                ScheduledFuture<?> oldScheduler = pollingScheduler;\n+                if (oldScheduler != null) {\n+                    oldScheduler.cancel(false);\n+                }\n+                pollingScheduler = scheduler.scheduleWithFixedDelay(this::update, 0, config.getPollingInterval(),\n+                        TimeUnit.SECONDS);\n+            } else {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                        \"WlanThermo not found under given address.\");\n+            }\n+        } catch (URISyntaxException | InterruptedException | ExecutionException | TimeoutException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                    \"Could not connect to WlanThermo at \" + config.getIpAddress() + \": \" + e.getMessage());\n+            ScheduledFuture<?> oldScheduler = pollingScheduler;\n+            if (oldScheduler != null) {\n+                oldScheduler.cancel(false);\n+            }\n+            pollingScheduler = scheduler.schedule(this::checkConnection, config.getPollingInterval(), TimeUnit.SECONDS);\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            State s = wlanThermoEsp32CommandHandler.getState(channelUID, data, settings);\n+            if (s != null) {\n+                updateState(channelUID, s);\n+            }\n+        } else {\n+            if (wlanThermoEsp32CommandHandler.setState(channelUID, command, data)) {\n+                logger.debug(\"Data updated, pushing changes\");\n+                push();\n+            } else {\n+                logger.debug(\"Could not handle command of type {} for channel {}!\",\n+                        command.getClass().toGenericString(), channelUID.getId());\n+            }\n+        }\n+    }\n+\n+    private void update() {\n+        try {\n+            // Update objects with data from device\n+            String json = httpClient.GET(config.getUri(\"/data\")).getContentAsString();\n+            data = gson.fromJson(json, Data.class);\n+            logger.debug(\"Received at /data: {}\", json);\n+            json = httpClient.GET(config.getUri(\"/settings\")).getContentAsString();\n+            settings = gson.fromJson(json, Settings.class);\n+            logger.debug(\"Received at /settings: {}\", json);\n+\n+            if (data == null || settings == null) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        \"Failed to parse Data and/or Settings values!\");\n+                return;\n+            }\n+\n+            // Update Channels if required\n+            Map<String, String> properties = editProperties();\n+            Boolean pmEnabled = settings.getFeatures().getBluetooth();\n+            int pmChannels = pmEnabled ? data.getPitmaster().getPm().size() : 0;\n+            int tempChannels = data.getChannel().size();\n+\n+            // Update properties\n+            properties.put(WlanThermoBindingConstants.PROPERTY_MODEL, settings.getDevice().getDevice());\n+            properties.put(WlanThermoBindingConstants.PROPERTY_SERIAL, settings.getDevice().getSerial());\n+            properties.put(WlanThermoBindingConstants.PROPERTY_ESP32_BT_ENABLED,\n+                    settings.getFeatures().getBluetooth().toString());\n+            properties.put(WlanThermoBindingConstants.PROPERTY_ESP32_PM_ENABLED, pmEnabled.toString());\n+            properties.put(WlanThermoBindingConstants.PROPERTY_ESP32_TEMP_CHANNELS, String.valueOf(tempChannels));\n+            properties.put(WlanThermoBindingConstants.PROPERTY_ESP32_PM_CHANNELS, String.valueOf(pmChannels));\n+            updateProperties(properties);\n+\n+            // Update channel state\n+            for (Channel channel : thing.getChannels()) {\n+                State state = wlanThermoEsp32CommandHandler.getState(channel.getUID(), data, settings);\n+                if (state != null) {\n+                    updateState(channel.getUID(), state);\n+                } else {\n+                    // if we could not obtain a state, try trigger instead\n+                    String trigger = wlanThermoEsp32CommandHandler.getTrigger(channel.getUID(), data);\n+                    if (trigger != null) {\n+                        triggerChannel(channel.getUID(), trigger);\n+                    }\n+                }\n+            }\n+        } catch (URISyntaxException | InterruptedException | ExecutionException | TimeoutException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                    \"Update failed: \" + e.getMessage());\n+            ScheduledFuture<?> oldScheduler = pollingScheduler;\n+            if (oldScheduler != null) {\n+                oldScheduler.cancel(false);\n+            }\n+            for (Channel channel : thing.getChannels()) {\n+                updateState(channel.getUID(), UnDefType.UNDEF);\n+            }\n+            checkConnection();\n+        }\n+    }\n+\n+    private void push() {\n+        if (data == null) {\n+            return;\n+        }\n+        data.getChannel().forEach(c -> {\n+            try {\n+                String json = gson.toJson(c);\n+                URI uri = config.getUri(\"/setchannels\");\n+                int status = httpClient.POST(uri).content(new StringContentProvider(json), \"application/json\")\n+                        .timeout(5, TimeUnit.SECONDS).send().getStatus();\n+                if (status == 401) {\n+                    updateStatus(ThingStatus.ONLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                            \"No or wrong login credentials provided. Please configure username/password for write access to WlanThermo!\");\n+                } else if (status != 200) {\n+                    updateStatus(ThingStatus.ONLINE, ThingStatusDetail.COMMUNICATION_ERROR, \"Failed to update channel \"\n+                            + c.getName() + \" on device, Statuscode \" + status + \" on URI \" + uri.toString());\n+                    logger.debug(\"Payload sent: {}\", json);\n+                } else {\n+                    updateStatus(ThingStatus.ONLINE);\n+                }\n+            } catch (InterruptedException | TimeoutException | ExecutionException | URISyntaxException e) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aff5cb5d1d4586abbf71161d45993b63d09ab438"}, "originalPosition": 206}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ4MDE3NzA0OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/api/esp32/WlanThermoEsp32Handler.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNlQyMDo0NDozNFrOIPVigQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNlQyMDo0NDozNFrOIPVigQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mjk1MjQ0OQ==", "bodyText": "To exit early you will need to change this to regular for-each loop.", "url": "https://github.com/openhab/openhab-addons/pull/9579#discussion_r552952449", "createdAt": "2021-01-06T20:44:34Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/api/esp32/WlanThermoEsp32Handler.java", "diffHunk": "@@ -0,0 +1,222 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.wlanthermo.internal.api.esp32;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.Map;\n+import java.util.concurrent.*;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.Authentication;\n+import org.eclipse.jetty.client.api.AuthenticationStore;\n+import org.eclipse.jetty.client.util.DigestAuthentication;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants;\n+import org.openhab.binding.wlanthermo.internal.WlanThermoExtendedConfiguration;\n+import org.openhab.binding.wlanthermo.internal.api.esp32.dto.data.Data;\n+import org.openhab.binding.wlanthermo.internal.api.esp32.dto.settings.Settings;\n+import org.openhab.core.thing.*;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+\n+/**\n+ * The {@link WlanThermoEsp32Handler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Christian Schlipp - Initial contribution\n+ */\n+@NonNullByDefault\n+public class WlanThermoEsp32Handler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(WlanThermoEsp32Handler.class);\n+\n+    private WlanThermoExtendedConfiguration config = new WlanThermoExtendedConfiguration();\n+    private WlanThermoEsp32CommandHandler wlanThermoEsp32CommandHandler = new WlanThermoEsp32CommandHandler();\n+    private final HttpClient httpClient;\n+    private @Nullable ScheduledFuture<?> pollingScheduler;\n+    private final Gson gson = new Gson();\n+    private @Nullable Data data = new Data();\n+    private @Nullable Settings settings = new Settings();\n+\n+    public WlanThermoEsp32Handler(Thing thing, HttpClient httpClient) {\n+        super(thing);\n+        this.httpClient = httpClient;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        config = getConfigAs(WlanThermoExtendedConfiguration.class);\n+\n+        updateStatus(ThingStatus.UNKNOWN);\n+        try {\n+            if (!config.getUsername().isEmpty() && !config.getPassword().isEmpty()) {\n+                AuthenticationStore authStore = httpClient.getAuthenticationStore();\n+                authStore.addAuthentication(new DigestAuthentication(config.getUri(), Authentication.ANY_REALM,\n+                        config.getUsername(), config.getPassword()));\n+            }\n+            pollingScheduler = scheduler.schedule(this::checkConnection, config.getPollingInterval(), TimeUnit.SECONDS);\n+        } catch (URISyntaxException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"Failed to initialize WlanThermo Nano: \" + e.getMessage());\n+        }\n+    }\n+\n+    private void checkConnection() {\n+        try {\n+            if (httpClient.GET(config.getUri()).getStatus() == 200) {\n+                updateStatus(ThingStatus.ONLINE);\n+                ScheduledFuture<?> oldScheduler = pollingScheduler;\n+                if (oldScheduler != null) {\n+                    oldScheduler.cancel(false);\n+                }\n+                pollingScheduler = scheduler.scheduleWithFixedDelay(this::update, 0, config.getPollingInterval(),\n+                        TimeUnit.SECONDS);\n+            } else {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                        \"WlanThermo not found under given address.\");\n+            }\n+        } catch (URISyntaxException | InterruptedException | ExecutionException | TimeoutException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                    \"Could not connect to WlanThermo at \" + config.getIpAddress() + \": \" + e.getMessage());\n+            ScheduledFuture<?> oldScheduler = pollingScheduler;\n+            if (oldScheduler != null) {\n+                oldScheduler.cancel(false);\n+            }\n+            pollingScheduler = scheduler.schedule(this::checkConnection, config.getPollingInterval(), TimeUnit.SECONDS);\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            State s = wlanThermoEsp32CommandHandler.getState(channelUID, data, settings);\n+            if (s != null) {\n+                updateState(channelUID, s);\n+            }\n+        } else {\n+            if (wlanThermoEsp32CommandHandler.setState(channelUID, command, data)) {\n+                logger.debug(\"Data updated, pushing changes\");\n+                push();\n+            } else {\n+                logger.debug(\"Could not handle command of type {} for channel {}!\",\n+                        command.getClass().toGenericString(), channelUID.getId());\n+            }\n+        }\n+    }\n+\n+    private void update() {\n+        try {\n+            // Update objects with data from device\n+            String json = httpClient.GET(config.getUri(\"/data\")).getContentAsString();\n+            data = gson.fromJson(json, Data.class);\n+            logger.debug(\"Received at /data: {}\", json);\n+            json = httpClient.GET(config.getUri(\"/settings\")).getContentAsString();\n+            settings = gson.fromJson(json, Settings.class);\n+            logger.debug(\"Received at /settings: {}\", json);\n+\n+            if (data == null || settings == null) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        \"Failed to parse Data and/or Settings values!\");\n+                return;\n+            }\n+\n+            // Update Channels if required\n+            Map<String, String> properties = editProperties();\n+            Boolean pmEnabled = settings.getFeatures().getBluetooth();\n+            int pmChannels = pmEnabled ? data.getPitmaster().getPm().size() : 0;\n+            int tempChannels = data.getChannel().size();\n+\n+            // Update properties\n+            properties.put(WlanThermoBindingConstants.PROPERTY_MODEL, settings.getDevice().getDevice());\n+            properties.put(WlanThermoBindingConstants.PROPERTY_SERIAL, settings.getDevice().getSerial());\n+            properties.put(WlanThermoBindingConstants.PROPERTY_ESP32_BT_ENABLED,\n+                    settings.getFeatures().getBluetooth().toString());\n+            properties.put(WlanThermoBindingConstants.PROPERTY_ESP32_PM_ENABLED, pmEnabled.toString());\n+            properties.put(WlanThermoBindingConstants.PROPERTY_ESP32_TEMP_CHANNELS, String.valueOf(tempChannels));\n+            properties.put(WlanThermoBindingConstants.PROPERTY_ESP32_PM_CHANNELS, String.valueOf(pmChannels));\n+            updateProperties(properties);\n+\n+            // Update channel state\n+            for (Channel channel : thing.getChannels()) {\n+                State state = wlanThermoEsp32CommandHandler.getState(channel.getUID(), data, settings);\n+                if (state != null) {\n+                    updateState(channel.getUID(), state);\n+                } else {\n+                    // if we could not obtain a state, try trigger instead\n+                    String trigger = wlanThermoEsp32CommandHandler.getTrigger(channel.getUID(), data);\n+                    if (trigger != null) {\n+                        triggerChannel(channel.getUID(), trigger);\n+                    }\n+                }\n+            }\n+        } catch (URISyntaxException | InterruptedException | ExecutionException | TimeoutException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                    \"Update failed: \" + e.getMessage());\n+            ScheduledFuture<?> oldScheduler = pollingScheduler;\n+            if (oldScheduler != null) {\n+                oldScheduler.cancel(false);\n+            }\n+            for (Channel channel : thing.getChannels()) {\n+                updateState(channel.getUID(), UnDefType.UNDEF);\n+            }\n+            checkConnection();\n+        }\n+    }\n+\n+    private void push() {\n+        if (data == null) {\n+            return;\n+        }\n+        data.getChannel().forEach(c -> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aff5cb5d1d4586abbf71161d45993b63d09ab438"}, "originalPosition": 190}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzUwNTg5NjA1OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/api/esp32/WlanThermoEsp32CommandHandler.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xM1QyMTozNzozMFrOITDtgQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xM1QyMTozNzozMFrOITDtgQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Njg1NDY1Nw==", "bodyText": "I'd think that you would return something here just to avoid throwing a WlanThermoUnknownChannelException since it is clear at this point in the code that the channel is actually known.", "url": "https://github.com/openhab/openhab-addons/pull/9579#discussion_r556854657", "createdAt": "2021-01-13T21:37:30Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/api/esp32/WlanThermoEsp32CommandHandler.java", "diffHunk": "@@ -0,0 +1,280 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.wlanthermo.internal.api.esp32;\n+\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.*;\n+\n+import java.awt.Color;\n+import java.math.BigInteger;\n+import java.util.List;\n+\n+import javax.measure.Unit;\n+import javax.measure.quantity.Temperature;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.wlanthermo.internal.WlanThermoInputException;\n+import org.openhab.binding.wlanthermo.internal.WlanThermoUnknownChannelException;\n+import org.openhab.binding.wlanthermo.internal.api.esp32.dto.data.Channel;\n+import org.openhab.binding.wlanthermo.internal.api.esp32.dto.data.Data;\n+import org.openhab.binding.wlanthermo.internal.api.esp32.dto.data.Pm;\n+import org.openhab.binding.wlanthermo.internal.api.esp32.dto.data.System;\n+import org.openhab.binding.wlanthermo.internal.api.esp32.dto.settings.Settings;\n+import org.openhab.core.library.types.*;\n+import org.openhab.core.library.unit.ImperialUnits;\n+import org.openhab.core.library.unit.SIUnits;\n+import org.openhab.core.library.unit.Units;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.UnDefType;\n+\n+/**\n+ * The {@link WlanThermoEsp32CommandHandler} is responsible for mapping the Commands to the respective data fields\n+ * of the API.\n+ *\n+ * @author Christian Schlipp - Initial contribution\n+ */\n+@NonNullByDefault\n+public class WlanThermoEsp32CommandHandler {\n+\n+    public static State getState(ChannelUID channelUID, @Nullable Data data, @Nullable Settings settings)\n+            throws WlanThermoUnknownChannelException, WlanThermoInputException {\n+        if (channelUID.getGroupId() == null || data == null || settings == null) {\n+            throw new WlanThermoInputException();\n+        }\n+\n+        String groupId = channelUID.getGroupId();\n+        System system = data.getSystem();\n+        Unit<Temperature> unit = \"F\".equals(system.getUnit()) ? ImperialUnits.FAHRENHEIT : SIUnits.CELSIUS;\n+\n+        List<Channel> channelList = data.getChannel();\n+        if (SYSTEM.equals(groupId)) {\n+            switch (channelUID.getIdWithoutGroup()) {\n+                case SYSTEM_SOC:\n+                    if (system.getSoc() != null) {\n+                        return new DecimalType(system.getSoc());\n+                    } else {\n+                        return UnDefType.UNDEF;\n+                    }\n+                case SYSTEM_CHARGE:\n+                    if (system.getCharge() != null) {\n+                        return OnOffType.from(system.getCharge());\n+                    } else {\n+                        return UnDefType.UNDEF;\n+                    }\n+                case SYSTEM_RSSI_SIGNALSTRENGTH:\n+                    int dbm = system.getRssi();\n+                    if (dbm >= -80) {\n+                        return SIGNAL_STRENGTH_4;\n+                    } else if (dbm >= -95) {\n+                        return SIGNAL_STRENGTH_3;\n+                    } else if (dbm >= -105) {\n+                        return SIGNAL_STRENGTH_2;\n+                    } else {\n+                        return SIGNAL_STRENGTH_1;\n+                    }\n+                case SYSTEM_RSSI:\n+                    return new QuantityType<>(system.getRssi(), Units.DECIBEL_MILLIWATTS);\n+            }\n+        } else if (channelUID.getId().startsWith(CHANNEL_PREFIX)) {\n+            int channelId = Integer.parseInt(groupId.substring(CHANNEL_PREFIX.length())) - 1;\n+            if (channelList != null && channelList.size() > 0 && channelId < channelList.size()) {\n+                Channel channel = channelList.get(channelId);\n+                switch (channelUID.getIdWithoutGroup()) {\n+                    case CHANNEL_NAME:\n+                        return new StringType(channel.getName());\n+                    case CHANNEL_TYP:\n+                        return new StringType(settings.getSensors().get(channel.getTyp()).getName());\n+                    case CHANNEL_TEMP:\n+                        return channel.getTemp() == 999.0 ? UnDefType.UNDEF\n+                                : new QuantityType<>(channel.getTemp(), unit);\n+                    case CHANNEL_MIN:\n+                        return new QuantityType<>(channel.getMin(), unit);\n+                    case CHANNEL_MAX:\n+                        return new QuantityType<>(channel.getMax(), unit);\n+                    case CHANNEL_ALARM_DEVICE:\n+                        return OnOffType.from(BigInteger.valueOf(channel.getAlarm()).testBit(1));\n+                    case CHANNEL_ALARM_PUSH:\n+                        return OnOffType.from(BigInteger.valueOf(channel.getAlarm()).testBit(0));\n+                    case CHANNEL_ALARM_OPENHAB_HIGH:\n+                        if (channel.getTemp() != 999 && channel.getTemp() > channel.getMax()) {\n+                            return OnOffType.ON;\n+                        } else {\n+                            return OnOffType.OFF;\n+                        }\n+                    case CHANNEL_ALARM_OPENHAB_LOW:\n+                        if (channel.getTemp() != 999 && channel.getTemp() < channel.getMin()) {\n+                            return OnOffType.ON;\n+                        } else {\n+                            return OnOffType.OFF;\n+                        }\n+                    case CHANNEL_COLOR:\n+                        String color = channel.getColor();\n+                        if (color != null && !color.isEmpty()) {\n+                            Color c = Color.decode(color);\n+                            return HSBType.fromRGB(c.getRed(), c.getGreen(), c.getBlue());\n+                        } else {\n+                            return UnDefType.UNDEF;\n+                        }\n+                    case CHANNEL_COLOR_NAME:\n+                        String colorHex = channel.getColor();\n+                        if (colorHex != null && !colorHex.isEmpty()) {\n+                            return new StringType(UtilEsp32.toColorName(colorHex));\n+                        } else {\n+                            return UnDefType.UNDEF;\n+                        }\n+                }\n+            }\n+        } else if (channelUID.getId().startsWith(CHANNEL_PITMASTER_1)) {\n+            if (data.getPitmaster() != null && data.getPitmaster().getPm() != null\n+                    && data.getPitmaster().getPm().size() > 0) {\n+                Pm pm = data.getPitmaster().getPm().get(0);\n+                switch (channelUID.getIdWithoutGroup()) {\n+                    case CHANNEL_PITMASTER_CHANNEL_ID:\n+                        return new DecimalType(pm.getChannel());\n+                    case CHANNEL_PITMASTER_PIDPROFILE:\n+                        return new DecimalType(pm.getPid());\n+                    case CHANNEL_PITMASTER_DUTY_CYCLE:\n+                        return new DecimalType(pm.getValue());\n+                    case CHANNEL_PITMASTER_SETPOINT:\n+                        return new QuantityType<>(pm.getSet(), unit);\n+                    case CHANNEL_PITMASTER_STATE:\n+                        return new StringType(pm.getTyp());\n+                }\n+            } else {\n+                return UnDefType.UNDEF;\n+            }\n+        }\n+        throw new WlanThermoUnknownChannelException(channelUID);\n+    }\n+\n+    public static boolean setState(ChannelUID channelUID, Command command, @Nullable Data data) {\n+        if (channelUID.getGroupId() == null || data == null || data.getSystem() == null) {\n+            return false;\n+        }\n+\n+        String groupId = channelUID.getGroupId();\n+        List<Channel> channelList = data.getChannel();\n+        System system = data.getSystem();\n+        Unit<Temperature> unit = \"F\".equals(system.getUnit()) ? ImperialUnits.FAHRENHEIT : SIUnits.CELSIUS;\n+\n+        if (channelUID.getId().startsWith(CHANNEL_PREFIX)) {\n+            int channelId = Integer.parseInt(groupId.substring(CHANNEL_PREFIX.length())) - 1;\n+            if (channelList.size() > 0 && channelId < channelList.size()) {\n+                Channel channel = channelList.get(channelId);\n+                switch (channelUID.getIdWithoutGroup()) {\n+                    case CHANNEL_NAME:\n+                        if (command instanceof StringType) {\n+                            channel.setName(command.toFullString());\n+                            return true;\n+                        }\n+                    case CHANNEL_MIN:\n+                        if (command instanceof QuantityType) {\n+                            channel.setMin(((QuantityType<?>) command).toUnit(unit).doubleValue());\n+                            return true;\n+                        }\n+                    case CHANNEL_MAX:\n+                        if (command instanceof QuantityType) {\n+                            channel.setMax(((QuantityType<?>) command).toUnit(unit).doubleValue());\n+                            return true;\n+                        }\n+                    case CHANNEL_ALARM_DEVICE:\n+                        if (command instanceof OnOffType) {\n+                            BigInteger value;\n+                            if (command == OnOffType.ON) {\n+                                value = BigInteger.valueOf(channel.getAlarm()).setBit(1);\n+                            } else {\n+                                value = BigInteger.valueOf(channel.getAlarm()).clearBit(1);\n+                            }\n+                            channel.setAlarm(value.intValue());\n+                            return true;\n+                        }\n+                    case CHANNEL_ALARM_PUSH:\n+                        if (command instanceof OnOffType) {\n+                            BigInteger value;\n+                            if (command == OnOffType.ON) {\n+                                value = BigInteger.valueOf(channel.getAlarm()).setBit(0);\n+                            } else {\n+                                value = BigInteger.valueOf(channel.getAlarm()).clearBit(0);\n+                            }\n+                            channel.setAlarm(value.intValue());\n+                            return true;\n+                        }\n+                    case CHANNEL_COLOR_NAME:\n+                        if (command instanceof StringType) {\n+                            channel.setColor(UtilEsp32.toHex(((StringType) command).toString()));\n+                            return true;\n+                        }\n+                    case CHANNEL_COLOR:\n+                        if (command instanceof HSBType) {\n+                            channel.setColor(UtilEsp32.toHex((HSBType) command));\n+                            return true;\n+                        }\n+                }\n+            }\n+        } else if (channelUID.getId().startsWith(CHANNEL_PITMASTER_PREFIX)) {\n+            int channelId = Integer.parseInt(groupId.substring(CHANNEL_PITMASTER_PREFIX.length())) - 1;\n+            if (data.getPitmaster() != null && data.getPitmaster().getPm() != null\n+                    && data.getPitmaster().getPm().size() > channelId) {\n+                Pm pm = data.getPitmaster().getPm().get(channelId);\n+                switch (channelUID.getIdWithoutGroup()) {\n+                    case CHANNEL_PITMASTER_CHANNEL_ID:\n+                        pm.setChannel(((QuantityType<?>) command).intValue());\n+                        return true;\n+                    case CHANNEL_PITMASTER_PIDPROFILE:\n+                        pm.setPid(((QuantityType<?>) command).intValue());\n+                        return true;\n+                    case CHANNEL_PITMASTER_SETPOINT:\n+                        pm.setSet(((QuantityType<?>) command).toUnit(unit).doubleValue());\n+                        return true;\n+                    case CHANNEL_PITMASTER_STATE:\n+                        String state = ((StringType) command).toString();\n+                        if (state.equalsIgnoreCase(\"off\") || state.equalsIgnoreCase(\"manual\")\n+                                || state.equalsIgnoreCase(\"auto\")) {\n+                            pm.setTyp(state);\n+                            return true;\n+                        }\n+                }\n+            }\n+        }\n+        return false;\n+    }\n+\n+    public static String getTrigger(ChannelUID channelUID, @Nullable Data data)\n+            throws WlanThermoUnknownChannelException, WlanThermoInputException {\n+        if (channelUID.getGroupId() == null || data == null) {\n+            throw new WlanThermoInputException();\n+        }\n+\n+        String groupId = channelUID.getGroupId();\n+        List<Channel> channelList = data.getChannel();\n+\n+        if (channelUID.getId().startsWith(CHANNEL_PREFIX)) {\n+            int channelId = Integer.parseInt(groupId.substring(CHANNEL_PREFIX.length())) - 1;\n+            if (channelList.size() > 0 && channelId < channelList.size()) {\n+                Channel channel = channelList.get(channelId);\n+                if (CHANNEL_ALARM_OPENHAB.equals(channelUID.getIdWithoutGroup())) {\n+                    if (channel.getTemp() != 999) {\n+                        if (channel.getTemp() > channel.getMax()) {\n+                            return TRIGGER_ALARM_MAX;\n+                        } else if (channel.getTemp() < channel.getMin()) {\n+                            return TRIGGER_ALARM_MIN;\n+                        }\n+                    }\n+                }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c1c9ac7f28764809641c2454e814ea14e9f54724"}, "originalPosition": 275}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzUwNTkwMzcyOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/api/esp32/WlanThermoEsp32Handler.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xM1QyMTozODo0MFrOITDykQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xM1QyMTozODo0MFrOITDykQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Njg1NTk1Mw==", "bodyText": "You should return at this point to that you don't continue to query the other channels.\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            logger.debug(\"Push interrupted. {}\", e.getMessage());\n          \n          \n            \n                        }\n          \n          \n            \n                            logger.debug(\"Push interrupted. {}\", e.getMessage());\n          \n          \n            \n                            return;\n          \n          \n            \n                        }", "url": "https://github.com/openhab/openhab-addons/pull/9579#discussion_r556855953", "createdAt": "2021-01-13T21:38:40Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/api/esp32/WlanThermoEsp32Handler.java", "diffHunk": "@@ -0,0 +1,248 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.wlanthermo.internal.api.esp32;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.Map;\n+import java.util.concurrent.*;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.Authentication;\n+import org.eclipse.jetty.client.api.AuthenticationStore;\n+import org.eclipse.jetty.client.util.DigestAuthentication;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants;\n+import org.openhab.binding.wlanthermo.internal.WlanThermoException;\n+import org.openhab.binding.wlanthermo.internal.WlanThermoExtendedConfiguration;\n+import org.openhab.binding.wlanthermo.internal.WlanThermoUnknownChannelException;\n+import org.openhab.binding.wlanthermo.internal.api.esp32.dto.data.Data;\n+import org.openhab.binding.wlanthermo.internal.api.esp32.dto.settings.Settings;\n+import org.openhab.core.thing.*;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+\n+/**\n+ * The {@link WlanThermoEsp32Handler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Christian Schlipp - Initial contribution\n+ */\n+@NonNullByDefault\n+public class WlanThermoEsp32Handler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(WlanThermoEsp32Handler.class);\n+\n+    private WlanThermoExtendedConfiguration config = new WlanThermoExtendedConfiguration();\n+    private final HttpClient httpClient;\n+    private @Nullable ScheduledFuture<?> pollingScheduler;\n+    private final Gson gson = new Gson();\n+    private @Nullable Data data = new Data();\n+    private @Nullable Settings settings = new Settings();\n+\n+    public WlanThermoEsp32Handler(Thing thing, HttpClient httpClient) {\n+        super(thing);\n+        this.httpClient = httpClient;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        config = getConfigAs(WlanThermoExtendedConfiguration.class);\n+\n+        updateStatus(ThingStatus.UNKNOWN);\n+        try {\n+            if (!config.getUsername().isEmpty() && !config.getPassword().isEmpty()) {\n+                AuthenticationStore authStore = httpClient.getAuthenticationStore();\n+                authStore.addAuthentication(new DigestAuthentication(config.getUri(), Authentication.ANY_REALM,\n+                        config.getUsername(), config.getPassword()));\n+            }\n+            pollingScheduler = scheduler.scheduleWithFixedDelay(this::checkConnectionAndUpdate, 0,\n+                    config.getPollingInterval(), TimeUnit.SECONDS);\n+        } catch (URISyntaxException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"Failed to initialize WlanThermo Nano: \" + e.getMessage());\n+        }\n+    }\n+\n+    private void checkConnectionAndUpdate() {\n+        if (this.thing.getStatus() != ThingStatus.ONLINE) {\n+            try {\n+                if (httpClient.GET(config.getUri()).getStatus() == 200) {\n+                    updateStatus(ThingStatus.ONLINE);\n+                    // rerun immediately to update state\n+                    checkConnectionAndUpdate();\n+                } else {\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                            \"WlanThermo not found under given address.\");\n+                }\n+            } catch (URISyntaxException | ExecutionException | TimeoutException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        \"Could not connect to WlanThermo at \" + config.getIpAddress() + \": \" + e.getMessage());\n+            } catch (InterruptedException e) {\n+                logger.debug(\"Connection check interrupted. {}\", e.getMessage());\n+            }\n+        } else {\n+            try {\n+                // Update objects with data from device\n+                String json = httpClient.GET(config.getUri(\"/data\")).getContentAsString();\n+                data = gson.fromJson(json, Data.class);\n+                logger.debug(\"Received at /data: {}\", json);\n+                json = httpClient.GET(config.getUri(\"/settings\")).getContentAsString();\n+                settings = gson.fromJson(json, Settings.class);\n+                logger.debug(\"Received at /settings: {}\", json);\n+\n+                if (data == null || settings == null) {\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                            \"Failed to parse Data and/or Settings values!\");\n+                    return;\n+                }\n+\n+                // Update Channels if required\n+                Map<String, String> properties = editProperties();\n+                Boolean pmEnabled = settings.getFeatures().getBluetooth();\n+                int pmChannels = pmEnabled ? data.getPitmaster().getPm().size() : 0;\n+                int tempChannels = data.getChannel().size();\n+\n+                // Update properties\n+                properties.put(WlanThermoBindingConstants.PROPERTY_MODEL, settings.getDevice().getDevice());\n+                properties.put(WlanThermoBindingConstants.PROPERTY_SERIAL, settings.getDevice().getSerial());\n+                properties.put(WlanThermoBindingConstants.PROPERTY_ESP32_BT_ENABLED,\n+                        settings.getFeatures().getBluetooth().toString());\n+                properties.put(WlanThermoBindingConstants.PROPERTY_ESP32_PM_ENABLED, pmEnabled.toString());\n+                properties.put(WlanThermoBindingConstants.PROPERTY_ESP32_TEMP_CHANNELS, String.valueOf(tempChannels));\n+                properties.put(WlanThermoBindingConstants.PROPERTY_ESP32_PM_CHANNELS, String.valueOf(pmChannels));\n+                updateProperties(properties);\n+\n+                // Update channel state\n+                for (Channel channel : thing.getChannels()) {\n+                    try {\n+                        State state = WlanThermoEsp32CommandHandler.getState(channel.getUID(), data, settings);\n+                        updateState(channel.getUID(), state);\n+                    } catch (WlanThermoUnknownChannelException e) {\n+                        // if we could not obtain a state, try trigger instead\n+                        try {\n+                            String trigger = WlanThermoEsp32CommandHandler.getTrigger(channel.getUID(), data);\n+                            triggerChannel(channel.getUID(), trigger);\n+                        } catch (WlanThermoUnknownChannelException e1) {\n+                            logger.debug(\"{}\", e.getMessage());\n+                        }\n+                    }\n+                }\n+            } catch (URISyntaxException | ExecutionException | TimeoutException | WlanThermoException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        \"Update failed: \" + e.getMessage());\n+                for (Channel channel : thing.getChannels()) {\n+                    updateState(channel.getUID(), UnDefType.UNDEF);\n+                }\n+            } catch (InterruptedException e) {\n+                logger.debug(\"Update interrupted. {}\", e.getMessage());\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            try {\n+                State s = WlanThermoEsp32CommandHandler.getState(channelUID, data, settings);\n+                updateState(channelUID, s);\n+            } catch (WlanThermoException e) {\n+                logger.debug(\"Could not handle command of type {} for channel {}!\",\n+                        command.getClass().toGenericString(), channelUID.getId());\n+            }\n+        } else {\n+            if (WlanThermoEsp32CommandHandler.setState(channelUID, command, data)) {\n+                logger.debug(\"Data updated, pushing changes\");\n+                scheduler.execute(this::push);\n+            } else {\n+                logger.debug(\"Could not handle command of type {} for channel {}!\",\n+                        command.getClass().toGenericString(), channelUID.getId());\n+            }\n+        }\n+    }\n+\n+    private void push() {\n+        if (data == null || this.thing.getStatus() != ThingStatus.ONLINE) {\n+            return;\n+        }\n+\n+        // Push update for sensor channels\n+        for (org.openhab.binding.wlanthermo.internal.api.esp32.dto.data.Channel c : data.getChannel()) {\n+            try {\n+                String json = gson.toJson(c);\n+                URI uri = config.getUri(\"/setchannels\");\n+                int status = httpClient.POST(uri).content(new StringContentProvider(json), \"application/json\")\n+                        .timeout(5, TimeUnit.SECONDS).send().getStatus();\n+                if (status == 401) {\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                            \"No or wrong login credentials provided. Please configure username/password for write access to WlanThermo!\");\n+                    break;\n+                } else if (status != 200) {\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, \"Failed to update channel \"\n+                            + c.getName() + \" on device, Statuscode \" + status + \" on URI \" + uri.toString());\n+                    logger.debug(\"Payload sent: {}\", json);\n+                } else {\n+                    updateStatus(ThingStatus.ONLINE);\n+                }\n+            } catch (TimeoutException | ExecutionException | URISyntaxException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        \"Failed to update channel \" + c.getName() + \" on device: \" + e.getMessage());\n+            } catch (InterruptedException e) {\n+                logger.debug(\"Push interrupted. {}\", e.getMessage());\n+            }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c1c9ac7f28764809641c2454e814ea14e9f54724"}, "originalPosition": 211}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzUwNTkxOTkxOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/api/mini/WlanThermoMiniCommandHandler.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xM1QyMTo0MToxNVrOITD9eA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xM1QyMTo0MToxNVrOITD9eA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Njg1ODc0NA==", "bodyText": "see earlier comment.", "url": "https://github.com/openhab/openhab-addons/pull/9579#discussion_r556858744", "createdAt": "2021-01-13T21:41:15Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/api/mini/WlanThermoMiniCommandHandler.java", "diffHunk": "@@ -0,0 +1,171 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.wlanthermo.internal.api.mini;\n+\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.*;\n+\n+import java.awt.*;\n+\n+import javax.measure.Unit;\n+import javax.measure.quantity.Temperature;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants;\n+import org.openhab.binding.wlanthermo.internal.WlanThermoInputException;\n+import org.openhab.binding.wlanthermo.internal.WlanThermoUnknownChannelException;\n+import org.openhab.binding.wlanthermo.internal.api.mini.dto.builtin.*;\n+import org.openhab.core.library.types.*;\n+import org.openhab.core.library.unit.ImperialUnits;\n+import org.openhab.core.library.unit.SIUnits;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.UnDefType;\n+\n+/**\n+ * The {@link WlanThermoMiniCommandHandler} is responsible for mapping the Commands to the respective data fields\n+ * of the API.\n+ *\n+ * @author Christian Schlipp - Initial contribution\n+ */\n+@NonNullByDefault\n+public class WlanThermoMiniCommandHandler {\n+\n+    public static final String ERROR = \"er\";\n+\n+    public static State getState(ChannelUID channelUID, @Nullable App app)\n+            throws WlanThermoUnknownChannelException, WlanThermoInputException {\n+        if (channelUID.getGroupId() == null || app == null) {\n+            throw new WlanThermoInputException();\n+        }\n+\n+        String groupId = channelUID.getGroupId();\n+        Unit<Temperature> unit = \"fahrenheit\".equals(app.getTempUnit()) ? ImperialUnits.FAHRENHEIT : SIUnits.CELSIUS;\n+\n+        if (SYSTEM.equals(groupId)) {\n+            switch (channelUID.getIdWithoutGroup()) {\n+                case WlanThermoBindingConstants.SYSTEM_CPU_TEMP:\n+                    if (app.getCpuTemp() == null) {\n+                        return UnDefType.UNDEF;\n+                    } else {\n+                        return new DecimalType(app.getCpuTemp());\n+                    }\n+                case WlanThermoBindingConstants.SYSTEM_CPU_LOAD:\n+                    if (app.getCpuLoad() == null) {\n+                        return UnDefType.UNDEF;\n+                    } else {\n+                        return new DecimalType(app.getCpuLoad());\n+                    }\n+            }\n+        } else if (channelUID.getId().startsWith(CHANNEL_PREFIX)) {\n+            int channelId = Integer.parseInt(groupId.substring(CHANNEL_PREFIX.length()));\n+            if (channelId >= 0 && channelId <= 9) {\n+                Channel channel = app.getChannel();\n+                if (channel == null) {\n+                    return UnDefType.UNDEF;\n+                }\n+                Data data = channel.getData(channelId);\n+                switch (channelUID.getIdWithoutGroup()) {\n+                    case WlanThermoBindingConstants.CHANNEL_NAME:\n+                        return new StringType(data.getName());\n+                    case WlanThermoBindingConstants.CHANNEL_TEMP:\n+                        if (data.getState().equals(ERROR)) {\n+                            return UnDefType.UNDEF;\n+                        } else {\n+                            return new QuantityType<>(data.getTemp(), unit);\n+                        }\n+                    case WlanThermoBindingConstants.CHANNEL_MIN:\n+                        return new QuantityType<>(data.getTempMin(), unit);\n+                    case WlanThermoBindingConstants.CHANNEL_MAX:\n+                        return new QuantityType<>(data.getTempMax(), unit);\n+                    case WlanThermoBindingConstants.CHANNEL_ALARM_DEVICE:\n+                        return OnOffType.from(data.getAlert());\n+                    case WlanThermoBindingConstants.CHANNEL_ALARM_OPENHAB_HIGH:\n+                        if (!data.getState().equals(ERROR) && data.getTemp() > data.getTempMax()) {\n+                            return OnOffType.ON;\n+                        } else {\n+                            return OnOffType.OFF;\n+                        }\n+                    case WlanThermoBindingConstants.CHANNEL_ALARM_OPENHAB_LOW:\n+                        if (!data.getState().equals(ERROR) && data.getTemp() < data.getTempMin()) {\n+                            return OnOffType.ON;\n+                        } else {\n+                            return OnOffType.OFF;\n+                        }\n+                    case WlanThermoBindingConstants.CHANNEL_COLOR:\n+                        Color c = Color.decode(UtilMini.toHex(data.getColor()));\n+                        return HSBType.fromRGB(c.getRed(), c.getGreen(), c.getBlue());\n+                    case WlanThermoBindingConstants.CHANNEL_COLOR_NAME:\n+                        return new StringType(data.getColor());\n+                }\n+            }\n+        } else if (channelUID.getId().startsWith(CHANNEL_PITMASTER_PREFIX)) {\n+            Pit pit;\n+            if (groupId.equals(CHANNEL_PITMASTER_1)) {\n+                pit = app.getPit();\n+            } else if (groupId.equals(CHANNEL_PITMASTER_2)) {\n+                pit = app.getPit2();\n+            } else {\n+                return UnDefType.UNDEF;\n+            }\n+            if (pit == null || !pit.getEnabled()) {\n+                return UnDefType.UNDEF;\n+            }\n+            switch (channelUID.getIdWithoutGroup()) {\n+                case WlanThermoBindingConstants.CHANNEL_PITMASTER_ENABLED:\n+                    return OnOffType.from(pit.getEnabled());\n+                case WlanThermoBindingConstants.CHANNEL_PITMASTER_CURRENT:\n+                    return new DecimalType(pit.getCurrent());\n+                case WlanThermoBindingConstants.CHANNEL_PITMASTER_SETPOINT:\n+                    return new QuantityType<>(pit.getSetpoint(), unit);\n+                case WlanThermoBindingConstants.CHANNEL_PITMASTER_DUTY_CYCLE:\n+                    return new DecimalType(pit.getControlOut());\n+                case WlanThermoBindingConstants.CHANNEL_PITMASTER_LID_OPEN:\n+                    return OnOffType.from(pit.getOpenLid().equals(\"True\"));\n+                case WlanThermoBindingConstants.CHANNEL_PITMASTER_CHANNEL_ID:\n+                    return new DecimalType(pit.getCh());\n+            }\n+        }\n+        throw new WlanThermoUnknownChannelException(channelUID);\n+    }\n+\n+    public static String getTrigger(ChannelUID channelUID, @Nullable App app)\n+            throws WlanThermoUnknownChannelException, WlanThermoInputException {\n+        if (channelUID.getGroupId() == null || app == null) {\n+            throw new WlanThermoInputException();\n+        }\n+\n+        String groupId = channelUID.getGroupId();\n+\n+        if (channelUID.getId().startsWith(CHANNEL_PREFIX)) {\n+            int channelId = Integer.parseInt(groupId.substring(CHANNEL_PREFIX.length())) - 1;\n+            if (channelId >= 0 && channelId <= 9) {\n+                Channel channel = app.getChannel();\n+                if (channel == null) {\n+                    throw new WlanThermoInputException();\n+                }\n+                Data data = channel.getData(channelId);\n+                if (CHANNEL_ALARM_OPENHAB.equals(channelUID.getIdWithoutGroup())) {\n+                    if (!data.getState().equals(ERROR)) {\n+                        if (data.getTemp() > data.getTempMax()) {\n+                            return TRIGGER_ALARM_MAX;\n+                        } else if (data.getTemp() < data.getTempMin()) {\n+                            return TRIGGER_ALARM_MIN;\n+                        }\n+                    }\n+                }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c1c9ac7f28764809641c2454e814ea14e9f54724"}, "originalPosition": 166}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzUwNTk1NDI4OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/api/nano/WlanThermoNanoV1Handler.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xM1QyMTo0Njo1OFrOITEVZQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xM1QyMTo0Njo1OFrOITEVZQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Njg2NDg2OQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            logger.debug(\"Push interrupted. {}\", e.getMessage());\n          \n          \n            \n                        }\n          \n          \n            \n                            logger.debug(\"Push interrupted. {}\", e.getMessage());\n          \n          \n            \n                            return;\n          \n          \n            \n                        }", "url": "https://github.com/openhab/openhab-addons/pull/9579#discussion_r556864869", "createdAt": "2021-01-13T21:46:58Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/api/nano/WlanThermoNanoV1Handler.java", "diffHunk": "@@ -0,0 +1,224 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.wlanthermo.internal.api.nano;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.concurrent.*;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.Authentication;\n+import org.eclipse.jetty.client.api.AuthenticationStore;\n+import org.eclipse.jetty.client.util.DigestAuthentication;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.openhab.binding.wlanthermo.internal.WlanThermoException;\n+import org.openhab.binding.wlanthermo.internal.WlanThermoExtendedConfiguration;\n+import org.openhab.binding.wlanthermo.internal.WlanThermoUnknownChannelException;\n+import org.openhab.binding.wlanthermo.internal.api.nano.dto.data.Data;\n+import org.openhab.binding.wlanthermo.internal.api.nano.dto.settings.Settings;\n+import org.openhab.core.thing.*;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+\n+/**\n+ * The {@link WlanThermoNanoV1Handler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Christian Schlipp - Initial contribution\n+ */\n+@NonNullByDefault\n+public class WlanThermoNanoV1Handler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(WlanThermoNanoV1Handler.class);\n+\n+    private WlanThermoExtendedConfiguration config = new WlanThermoExtendedConfiguration();\n+    private final HttpClient httpClient;\n+    private @Nullable ScheduledFuture<?> pollingScheduler;\n+    private final Gson gson = new Gson();\n+    private @Nullable Data data = new Data();\n+    private @Nullable Settings settings = new Settings();\n+\n+    public WlanThermoNanoV1Handler(Thing thing, HttpClient httpClient) {\n+        super(thing);\n+        this.httpClient = httpClient;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        config = getConfigAs(WlanThermoExtendedConfiguration.class);\n+\n+        updateStatus(ThingStatus.UNKNOWN);\n+        try {\n+            if (!config.getUsername().isEmpty() && !config.getPassword().isEmpty()) {\n+                AuthenticationStore authStore = httpClient.getAuthenticationStore();\n+                authStore.addAuthentication(new DigestAuthentication(config.getUri(), Authentication.ANY_REALM,\n+                        config.getUsername(), config.getPassword()));\n+            }\n+            pollingScheduler = scheduler.scheduleWithFixedDelay(this::checkConnectionAndUpdate, 0,\n+                    config.getPollingInterval(), TimeUnit.SECONDS);\n+        } catch (URISyntaxException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"Failed to initialize WlanThermo Nano: \" + e.getMessage());\n+        }\n+    }\n+\n+    private void checkConnectionAndUpdate() {\n+        if (this.thing.getStatus() != ThingStatus.ONLINE) {\n+            try {\n+                if (httpClient.GET(config.getUri()).getStatus() == 200) {\n+                    updateStatus(ThingStatus.ONLINE);\n+                    // rerun immediately to update state\n+                    checkConnectionAndUpdate();\n+                } else {\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                            \"WlanThermo not found under given address.\");\n+                }\n+            } catch (URISyntaxException | ExecutionException | TimeoutException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        \"Could not connect to WlanThermo at \" + config.getIpAddress() + \": \" + e.getMessage());\n+            } catch (InterruptedException e) {\n+                logger.debug(\"Connection check interrupted. {}\", e.getMessage());\n+            }\n+        } else {\n+            try {\n+                // Update objects with data from device\n+                String json = httpClient.GET(config.getUri(\"/data\")).getContentAsString();\n+                data = gson.fromJson(json, Data.class);\n+                logger.debug(\"Received at /data: {}\", json);\n+                json = httpClient.GET(config.getUri(\"/settings\")).getContentAsString();\n+                settings = gson.fromJson(json, Settings.class);\n+                logger.debug(\"Received at /settings: {}\", json);\n+\n+                // Update channels\n+                for (Channel channel : thing.getChannels()) {\n+                    try {\n+                        State state = WlanThermoNanoV1CommandHandler.getState(channel.getUID(), data, settings);\n+                        updateState(channel.getUID(), state);\n+                    } catch (WlanThermoUnknownChannelException e) {\n+                        // if we could not obtain a state, try trigger instead\n+                        try {\n+                            String trigger = WlanThermoNanoV1CommandHandler.getTrigger(channel.getUID(), data);\n+                            triggerChannel(channel.getUID(), trigger);\n+                        } catch (WlanThermoUnknownChannelException e1) {\n+                            logger.debug(\"{}\", e.getMessage());\n+                        }\n+                    }\n+                }\n+            } catch (URISyntaxException | ExecutionException | TimeoutException | WlanThermoException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        \"Update failed: \" + e.getMessage());\n+                for (Channel channel : thing.getChannels()) {\n+                    updateState(channel.getUID(), UnDefType.UNDEF);\n+                }\n+            } catch (InterruptedException e) {\n+                logger.debug(\"Update interrupted. {}\", e.getMessage());\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            try {\n+                State s = WlanThermoNanoV1CommandHandler.getState(channelUID, data, settings);\n+                updateState(channelUID, s);\n+            } catch (WlanThermoException e) {\n+                logger.debug(\"Could not handle command of type {} for channel {}!\",\n+                        command.getClass().toGenericString(), channelUID.getId());\n+            }\n+        } else {\n+            if (WlanThermoNanoV1CommandHandler.setState(channelUID, command, data)) {\n+                logger.debug(\"Data updated, pushing changes\");\n+                scheduler.execute(this::push);\n+            } else {\n+                logger.debug(\"Could not handle command of type {} for channel {}!\",\n+                        command.getClass().toGenericString(), channelUID.getId());\n+            }\n+        }\n+    }\n+\n+    private void push() {\n+        if (data == null || this.thing.getStatus() != ThingStatus.ONLINE) {\n+            return;\n+        }\n+\n+        // push update for sensor channels\n+        for (org.openhab.binding.wlanthermo.internal.api.nano.dto.data.Channel c : data.getChannel()) {\n+            try {\n+                String json = gson.toJson(c);\n+                URI uri = config.getUri(\"/setchannels\");\n+                int status = httpClient.POST(uri).content(new StringContentProvider(json), \"application/json\")\n+                        .timeout(5, TimeUnit.SECONDS).send().getStatus();\n+                if (status == 401) {\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                            \"No or wrong login credentials provided. Please configure username/password for write access to WlanThermo!\");\n+                    break;\n+                } else if (status != 200) {\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, \"Failed to update channel \"\n+                            + c.getName() + \" on device, Statuscode \" + status + \" on URI \" + uri.toString());\n+                    logger.debug(\"Payload sent: {}\", json);\n+                } else {\n+                    updateStatus(ThingStatus.ONLINE);\n+                }\n+            } catch (TimeoutException | ExecutionException | URISyntaxException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        \"Failed to update channel \" + c.getName() + \" on device: \" + e.getMessage());\n+            } catch (InterruptedException e) {\n+                logger.debug(\"Push interrupted. {}\", e.getMessage());\n+            }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c1c9ac7f28764809641c2454e814ea14e9f54724"}, "originalPosition": 187}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzUwNTk4NjM0OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/api/nano/WlanThermoNanoV1CommandHandler.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xM1QyMTo1MTo1MFrOITErfg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xNFQyMToxMzo1MFrOIT3dzg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Njg3MDUyNg==", "bodyText": "Where did you get these numbers from? To my knowledge a dbm of -95 is pretty much the noise floor for most wireless applications.", "url": "https://github.com/openhab/openhab-addons/pull/9579#discussion_r556870526", "createdAt": "2021-01-13T21:51:50Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/api/nano/WlanThermoNanoV1CommandHandler.java", "diffHunk": "@@ -0,0 +1,266 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.wlanthermo.internal.api.nano;\n+\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.*;\n+\n+import java.awt.*;\n+import java.math.BigInteger;\n+import java.util.List;\n+\n+import javax.measure.Unit;\n+import javax.measure.quantity.Temperature;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.wlanthermo.internal.WlanThermoInputException;\n+import org.openhab.binding.wlanthermo.internal.WlanThermoUnknownChannelException;\n+import org.openhab.binding.wlanthermo.internal.api.nano.dto.data.Channel;\n+import org.openhab.binding.wlanthermo.internal.api.nano.dto.data.Data;\n+import org.openhab.binding.wlanthermo.internal.api.nano.dto.data.Pm;\n+import org.openhab.binding.wlanthermo.internal.api.nano.dto.data.System;\n+import org.openhab.binding.wlanthermo.internal.api.nano.dto.settings.Settings;\n+import org.openhab.core.library.types.*;\n+import org.openhab.core.library.unit.ImperialUnits;\n+import org.openhab.core.library.unit.SIUnits;\n+import org.openhab.core.library.unit.Units;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.UnDefType;\n+\n+/**\n+ * The {@link WlanThermoNanoV1CommandHandler} is responsible for mapping the Commands to the respective data fields\n+ * of the API.\n+ *\n+ * @author Christian Schlipp - Initial contribution\n+ */\n+@NonNullByDefault\n+public class WlanThermoNanoV1CommandHandler {\n+\n+    public static State getState(ChannelUID channelUID, @Nullable Data data, @Nullable Settings settings)\n+            throws WlanThermoUnknownChannelException, WlanThermoInputException {\n+        if (channelUID.getGroupId() == null || data == null || settings == null) {\n+            throw new WlanThermoInputException();\n+        }\n+\n+        String groupId = channelUID.getGroupId();\n+        System system = data.getSystem();\n+        Unit<Temperature> unit = \"F\".equals(system.getUnit()) ? ImperialUnits.FAHRENHEIT : SIUnits.CELSIUS;\n+        List<Channel> channelList = data.getChannel();\n+\n+        if (SYSTEM.equals(groupId)) {\n+            switch (channelUID.getIdWithoutGroup()) {\n+                case SYSTEM_SOC:\n+                    return new DecimalType(system.getSoc());\n+                case SYSTEM_CHARGE:\n+                    return OnOffType.from(system.getCharge());\n+                case SYSTEM_RSSI_SIGNALSTRENGTH:\n+                    int dbm = system.getRssi();\n+                    if (dbm >= -80) {\n+                        return SIGNAL_STRENGTH_4;\n+                    } else if (dbm >= -95) {\n+                        return SIGNAL_STRENGTH_3;\n+                    } else if (dbm >= -105) {\n+                        return SIGNAL_STRENGTH_2;\n+                    } else {\n+                        return SIGNAL_STRENGTH_1;\n+                    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c1c9ac7f28764809641c2454e814ea14e9f54724"}, "originalPosition": 78}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzA2OTM4OQ==", "bodyText": "As I couldn't find any generic conversion function, I've checked the source code of the WlanThermo device and took the same numbers.\nBenefit: The signal indicator now gives the same number of bars as shown on the display of the device.", "url": "https://github.com/openhab/openhab-addons/pull/9579#discussion_r557069389", "createdAt": "2021-01-14T06:29:20Z", "author": {"login": "CSchlipp"}, "path": "bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/api/nano/WlanThermoNanoV1CommandHandler.java", "diffHunk": "@@ -0,0 +1,266 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.wlanthermo.internal.api.nano;\n+\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.*;\n+\n+import java.awt.*;\n+import java.math.BigInteger;\n+import java.util.List;\n+\n+import javax.measure.Unit;\n+import javax.measure.quantity.Temperature;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.wlanthermo.internal.WlanThermoInputException;\n+import org.openhab.binding.wlanthermo.internal.WlanThermoUnknownChannelException;\n+import org.openhab.binding.wlanthermo.internal.api.nano.dto.data.Channel;\n+import org.openhab.binding.wlanthermo.internal.api.nano.dto.data.Data;\n+import org.openhab.binding.wlanthermo.internal.api.nano.dto.data.Pm;\n+import org.openhab.binding.wlanthermo.internal.api.nano.dto.data.System;\n+import org.openhab.binding.wlanthermo.internal.api.nano.dto.settings.Settings;\n+import org.openhab.core.library.types.*;\n+import org.openhab.core.library.unit.ImperialUnits;\n+import org.openhab.core.library.unit.SIUnits;\n+import org.openhab.core.library.unit.Units;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.UnDefType;\n+\n+/**\n+ * The {@link WlanThermoNanoV1CommandHandler} is responsible for mapping the Commands to the respective data fields\n+ * of the API.\n+ *\n+ * @author Christian Schlipp - Initial contribution\n+ */\n+@NonNullByDefault\n+public class WlanThermoNanoV1CommandHandler {\n+\n+    public static State getState(ChannelUID channelUID, @Nullable Data data, @Nullable Settings settings)\n+            throws WlanThermoUnknownChannelException, WlanThermoInputException {\n+        if (channelUID.getGroupId() == null || data == null || settings == null) {\n+            throw new WlanThermoInputException();\n+        }\n+\n+        String groupId = channelUID.getGroupId();\n+        System system = data.getSystem();\n+        Unit<Temperature> unit = \"F\".equals(system.getUnit()) ? ImperialUnits.FAHRENHEIT : SIUnits.CELSIUS;\n+        List<Channel> channelList = data.getChannel();\n+\n+        if (SYSTEM.equals(groupId)) {\n+            switch (channelUID.getIdWithoutGroup()) {\n+                case SYSTEM_SOC:\n+                    return new DecimalType(system.getSoc());\n+                case SYSTEM_CHARGE:\n+                    return OnOffType.from(system.getCharge());\n+                case SYSTEM_RSSI_SIGNALSTRENGTH:\n+                    int dbm = system.getRssi();\n+                    if (dbm >= -80) {\n+                        return SIGNAL_STRENGTH_4;\n+                    } else if (dbm >= -95) {\n+                        return SIGNAL_STRENGTH_3;\n+                    } else if (dbm >= -105) {\n+                        return SIGNAL_STRENGTH_2;\n+                    } else {\n+                        return SIGNAL_STRENGTH_1;\n+                    }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Njg3MDUyNg=="}, "originalCommit": {"oid": "c1c9ac7f28764809641c2454e814ea14e9f54724"}, "originalPosition": 78}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzcwMjYwNg==", "bodyText": "Well if it matches what is shown on the device then I guess that is the correct implementation. Keep it as is then.", "url": "https://github.com/openhab/openhab-addons/pull/9579#discussion_r557702606", "createdAt": "2021-01-14T21:13:50Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/api/nano/WlanThermoNanoV1CommandHandler.java", "diffHunk": "@@ -0,0 +1,266 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.wlanthermo.internal.api.nano;\n+\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.*;\n+\n+import java.awt.*;\n+import java.math.BigInteger;\n+import java.util.List;\n+\n+import javax.measure.Unit;\n+import javax.measure.quantity.Temperature;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.wlanthermo.internal.WlanThermoInputException;\n+import org.openhab.binding.wlanthermo.internal.WlanThermoUnknownChannelException;\n+import org.openhab.binding.wlanthermo.internal.api.nano.dto.data.Channel;\n+import org.openhab.binding.wlanthermo.internal.api.nano.dto.data.Data;\n+import org.openhab.binding.wlanthermo.internal.api.nano.dto.data.Pm;\n+import org.openhab.binding.wlanthermo.internal.api.nano.dto.data.System;\n+import org.openhab.binding.wlanthermo.internal.api.nano.dto.settings.Settings;\n+import org.openhab.core.library.types.*;\n+import org.openhab.core.library.unit.ImperialUnits;\n+import org.openhab.core.library.unit.SIUnits;\n+import org.openhab.core.library.unit.Units;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.UnDefType;\n+\n+/**\n+ * The {@link WlanThermoNanoV1CommandHandler} is responsible for mapping the Commands to the respective data fields\n+ * of the API.\n+ *\n+ * @author Christian Schlipp - Initial contribution\n+ */\n+@NonNullByDefault\n+public class WlanThermoNanoV1CommandHandler {\n+\n+    public static State getState(ChannelUID channelUID, @Nullable Data data, @Nullable Settings settings)\n+            throws WlanThermoUnknownChannelException, WlanThermoInputException {\n+        if (channelUID.getGroupId() == null || data == null || settings == null) {\n+            throw new WlanThermoInputException();\n+        }\n+\n+        String groupId = channelUID.getGroupId();\n+        System system = data.getSystem();\n+        Unit<Temperature> unit = \"F\".equals(system.getUnit()) ? ImperialUnits.FAHRENHEIT : SIUnits.CELSIUS;\n+        List<Channel> channelList = data.getChannel();\n+\n+        if (SYSTEM.equals(groupId)) {\n+            switch (channelUID.getIdWithoutGroup()) {\n+                case SYSTEM_SOC:\n+                    return new DecimalType(system.getSoc());\n+                case SYSTEM_CHARGE:\n+                    return OnOffType.from(system.getCharge());\n+                case SYSTEM_RSSI_SIGNALSTRENGTH:\n+                    int dbm = system.getRssi();\n+                    if (dbm >= -80) {\n+                        return SIGNAL_STRENGTH_4;\n+                    } else if (dbm >= -95) {\n+                        return SIGNAL_STRENGTH_3;\n+                    } else if (dbm >= -105) {\n+                        return SIGNAL_STRENGTH_2;\n+                    } else {\n+                        return SIGNAL_STRENGTH_1;\n+                    }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Njg3MDUyNg=="}, "originalCommit": {"oid": "c1c9ac7f28764809641c2454e814ea14e9f54724"}, "originalPosition": 78}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzUwNTk5Mzk4OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/api/nano/WlanThermoNanoV1CommandHandler.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xM1QyMTo1MzowNVrOITEwog==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xNFQyMTo0Mzo0NFrOIT4Ymg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Njg3MTg0Mg==", "bodyText": "You should make sure that the units are converted to what you expect them to be. Use QuantityType.toUnit to handle the conversion.", "url": "https://github.com/openhab/openhab-addons/pull/9579#discussion_r556871842", "createdAt": "2021-01-13T21:53:05Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/api/nano/WlanThermoNanoV1CommandHandler.java", "diffHunk": "@@ -0,0 +1,266 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.wlanthermo.internal.api.nano;\n+\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.*;\n+\n+import java.awt.*;\n+import java.math.BigInteger;\n+import java.util.List;\n+\n+import javax.measure.Unit;\n+import javax.measure.quantity.Temperature;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.wlanthermo.internal.WlanThermoInputException;\n+import org.openhab.binding.wlanthermo.internal.WlanThermoUnknownChannelException;\n+import org.openhab.binding.wlanthermo.internal.api.nano.dto.data.Channel;\n+import org.openhab.binding.wlanthermo.internal.api.nano.dto.data.Data;\n+import org.openhab.binding.wlanthermo.internal.api.nano.dto.data.Pm;\n+import org.openhab.binding.wlanthermo.internal.api.nano.dto.data.System;\n+import org.openhab.binding.wlanthermo.internal.api.nano.dto.settings.Settings;\n+import org.openhab.core.library.types.*;\n+import org.openhab.core.library.unit.ImperialUnits;\n+import org.openhab.core.library.unit.SIUnits;\n+import org.openhab.core.library.unit.Units;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.UnDefType;\n+\n+/**\n+ * The {@link WlanThermoNanoV1CommandHandler} is responsible for mapping the Commands to the respective data fields\n+ * of the API.\n+ *\n+ * @author Christian Schlipp - Initial contribution\n+ */\n+@NonNullByDefault\n+public class WlanThermoNanoV1CommandHandler {\n+\n+    public static State getState(ChannelUID channelUID, @Nullable Data data, @Nullable Settings settings)\n+            throws WlanThermoUnknownChannelException, WlanThermoInputException {\n+        if (channelUID.getGroupId() == null || data == null || settings == null) {\n+            throw new WlanThermoInputException();\n+        }\n+\n+        String groupId = channelUID.getGroupId();\n+        System system = data.getSystem();\n+        Unit<Temperature> unit = \"F\".equals(system.getUnit()) ? ImperialUnits.FAHRENHEIT : SIUnits.CELSIUS;\n+        List<Channel> channelList = data.getChannel();\n+\n+        if (SYSTEM.equals(groupId)) {\n+            switch (channelUID.getIdWithoutGroup()) {\n+                case SYSTEM_SOC:\n+                    return new DecimalType(system.getSoc());\n+                case SYSTEM_CHARGE:\n+                    return OnOffType.from(system.getCharge());\n+                case SYSTEM_RSSI_SIGNALSTRENGTH:\n+                    int dbm = system.getRssi();\n+                    if (dbm >= -80) {\n+                        return SIGNAL_STRENGTH_4;\n+                    } else if (dbm >= -95) {\n+                        return SIGNAL_STRENGTH_3;\n+                    } else if (dbm >= -105) {\n+                        return SIGNAL_STRENGTH_2;\n+                    } else {\n+                        return SIGNAL_STRENGTH_1;\n+                    }\n+                case SYSTEM_RSSI:\n+                    return new QuantityType<>(system.getRssi(), Units.DECIBEL_MILLIWATTS);\n+            }\n+        } else if (channelUID.getId().startsWith(CHANNEL_PREFIX)) {\n+            int channelId = Integer.parseInt(groupId.substring(CHANNEL_PREFIX.length())) - 1;\n+            if (channelList.size() > 0 && channelId <= channelList.size()) {\n+                Channel channel = channelList.get(channelId);\n+                switch (channelUID.getIdWithoutGroup()) {\n+                    case CHANNEL_NAME:\n+                        return new StringType(channel.getName());\n+                    case CHANNEL_TYP:\n+                        return new StringType(settings.sensors.get(channel.getTyp()));\n+                    case CHANNEL_TEMP:\n+                        return channel.getTemp() == 999.0 ? UnDefType.UNDEF\n+                                : new QuantityType<>(channel.getTemp(), unit);\n+                    case CHANNEL_MIN:\n+                        return new QuantityType<>(channel.getMin(), unit);\n+                    case CHANNEL_MAX:\n+                        return new QuantityType<>(channel.getMax(), unit);\n+                    case CHANNEL_ALARM_DEVICE:\n+                        return OnOffType.from(BigInteger.valueOf(channel.getAlarm()).testBit(1));\n+                    case CHANNEL_ALARM_PUSH:\n+                        return OnOffType.from(BigInteger.valueOf(channel.getAlarm()).testBit(0));\n+                    case CHANNEL_ALARM_OPENHAB_HIGH:\n+                        if (channel.getTemp() != 999 && channel.getTemp() > channel.getMax()) {\n+                            return OnOffType.ON;\n+                        } else {\n+                            return OnOffType.OFF;\n+                        }\n+                    case CHANNEL_ALARM_OPENHAB_LOW:\n+                        if (channel.getTemp() != 999 && channel.getTemp() < channel.getMin()) {\n+                            return OnOffType.ON;\n+                        } else {\n+                            return OnOffType.OFF;\n+                        }\n+                    case CHANNEL_COLOR:\n+                        String color = channel.getColor();\n+                        if (color != null && !color.isEmpty()) {\n+                            Color c = Color.decode(color);\n+                            return HSBType.fromRGB(c.getRed(), c.getGreen(), c.getBlue());\n+                        } else {\n+                            return UnDefType.UNDEF;\n+                        }\n+                    case CHANNEL_COLOR_NAME:\n+                        String colorHex = channel.getColor();\n+                        if (colorHex != null && !colorHex.isEmpty()) {\n+                            return new StringType(UtilNano.toColorName(colorHex));\n+                        } else {\n+                            return UnDefType.UNDEF;\n+                        }\n+                }\n+            }\n+        } else if (channelUID.getId().startsWith(CHANNEL_PITMASTER_1)) {\n+            if (data.getPitmaster() != null && data.getPitmaster().getPm() != null\n+                    && data.getPitmaster().getPm().size() > 0) {\n+                Pm pm = data.getPitmaster().getPm().get(0);\n+                switch (channelUID.getIdWithoutGroup()) {\n+                    case CHANNEL_PITMASTER_CHANNEL_ID:\n+                        return new DecimalType(pm.getChannel());\n+                    case CHANNEL_PITMASTER_PIDPROFILE:\n+                        return new DecimalType(pm.getPid());\n+                    case CHANNEL_PITMASTER_DUTY_CYCLE:\n+                        return new DecimalType(pm.getValue());\n+                    case CHANNEL_PITMASTER_SETPOINT:\n+                        return new QuantityType<>(pm.getSet(), unit);\n+                    case CHANNEL_PITMASTER_STATE:\n+                        return new StringType(pm.getTyp());\n+                }\n+            } else {\n+                return UnDefType.UNDEF;\n+            }\n+        }\n+        throw new WlanThermoUnknownChannelException(channelUID);\n+    }\n+\n+    public static boolean setState(ChannelUID channelUID, Command command, @Nullable Data data) {\n+        if (channelUID.getGroupId() == null || data == null || data.getSystem() == null) {\n+            return false;\n+        }\n+\n+        String groupId = channelUID.getGroupId();\n+        List<Channel> channelList = data.getChannel();\n+        System system = data.getSystem();\n+        Unit<Temperature> unit = \"F\".equals(system.getUnit()) ? ImperialUnits.FAHRENHEIT : SIUnits.CELSIUS;\n+\n+        if (channelUID.getId().startsWith(CHANNEL_PREFIX)) {\n+            int channelId = Integer.parseInt(groupId.substring(CHANNEL_PREFIX.length())) - 1;\n+            if (channelList.size() > 0 && channelId <= channelList.size()) {\n+                Channel channel = channelList.get(channelId);\n+                switch (channelUID.getIdWithoutGroup()) {\n+                    case CHANNEL_NAME:\n+                        if (command instanceof StringType) {\n+                            channel.setName(command.toFullString());\n+                            return true;\n+                        }\n+                    case CHANNEL_MIN:\n+                        if (command instanceof QuantityType) {\n+                            channel.setMin(((QuantityType<?>) command).toUnit(unit).doubleValue());\n+                            return true;\n+                        }\n+                    case CHANNEL_MAX:\n+                        if (command instanceof QuantityType) {\n+                            channel.setMax(((QuantityType<?>) command).toUnit(unit).doubleValue());\n+                            return true;\n+                        }\n+                    case CHANNEL_ALARM_DEVICE:\n+                        if (command instanceof OnOffType) {\n+                            BigInteger value;\n+                            if (command == OnOffType.ON) {\n+                                value = BigInteger.valueOf(channel.getAlarm()).setBit(1);\n+                            } else {\n+                                value = BigInteger.valueOf(channel.getAlarm()).clearBit(1);\n+                            }\n+                            channel.setAlarm(value.intValue());\n+                            return true;\n+                        }\n+                    case CHANNEL_ALARM_PUSH:\n+                        if (command instanceof OnOffType) {\n+                            BigInteger value;\n+                            if (command == OnOffType.ON) {\n+                                value = BigInteger.valueOf(channel.getAlarm()).setBit(0);\n+                            } else {\n+                                value = BigInteger.valueOf(channel.getAlarm()).clearBit(0);\n+                            }\n+                            channel.setAlarm(value.intValue());\n+                            return true;\n+                        }\n+                    case CHANNEL_COLOR_NAME:\n+                        if (command instanceof StringType) {\n+                            channel.setColor(UtilNano.toHex(((StringType) command).toString()));\n+                            return true;\n+                        }\n+                }\n+            }\n+        } else if (channelUID.getId().equals(CHANNEL_PITMASTER_1)) {\n+            if (data.getPitmaster() != null && data.getPitmaster().getPm() != null\n+                    && data.getPitmaster().getPm().size() > 0) {\n+                Pm pm = data.getPitmaster().getPm().get(0);\n+                switch (channelUID.getIdWithoutGroup()) {\n+                    case CHANNEL_PITMASTER_CHANNEL_ID:\n+                        pm.setChannel(((QuantityType<?>) command).intValue());\n+                        return true;\n+                    case CHANNEL_PITMASTER_PIDPROFILE:\n+                        pm.setPid(((QuantityType<?>) command).intValue());\n+                        return true;\n+                    case CHANNEL_PITMASTER_SETPOINT:\n+                        pm.setSet(((QuantityType<?>) command).toUnit(unit).doubleValue());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c1c9ac7f28764809641c2454e814ea14e9f54724"}, "originalPosition": 225}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzA2OTg1MQ==", "bodyText": "That already included in all channels, where unit conversion might be required.\nThe PITMASTER_PIDPROFILE channel however only contains an integer reference to a profile, so no conversion needed.", "url": "https://github.com/openhab/openhab-addons/pull/9579#discussion_r557069851", "createdAt": "2021-01-14T06:30:43Z", "author": {"login": "CSchlipp"}, "path": "bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/api/nano/WlanThermoNanoV1CommandHandler.java", "diffHunk": "@@ -0,0 +1,266 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.wlanthermo.internal.api.nano;\n+\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.*;\n+\n+import java.awt.*;\n+import java.math.BigInteger;\n+import java.util.List;\n+\n+import javax.measure.Unit;\n+import javax.measure.quantity.Temperature;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.wlanthermo.internal.WlanThermoInputException;\n+import org.openhab.binding.wlanthermo.internal.WlanThermoUnknownChannelException;\n+import org.openhab.binding.wlanthermo.internal.api.nano.dto.data.Channel;\n+import org.openhab.binding.wlanthermo.internal.api.nano.dto.data.Data;\n+import org.openhab.binding.wlanthermo.internal.api.nano.dto.data.Pm;\n+import org.openhab.binding.wlanthermo.internal.api.nano.dto.data.System;\n+import org.openhab.binding.wlanthermo.internal.api.nano.dto.settings.Settings;\n+import org.openhab.core.library.types.*;\n+import org.openhab.core.library.unit.ImperialUnits;\n+import org.openhab.core.library.unit.SIUnits;\n+import org.openhab.core.library.unit.Units;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.UnDefType;\n+\n+/**\n+ * The {@link WlanThermoNanoV1CommandHandler} is responsible for mapping the Commands to the respective data fields\n+ * of the API.\n+ *\n+ * @author Christian Schlipp - Initial contribution\n+ */\n+@NonNullByDefault\n+public class WlanThermoNanoV1CommandHandler {\n+\n+    public static State getState(ChannelUID channelUID, @Nullable Data data, @Nullable Settings settings)\n+            throws WlanThermoUnknownChannelException, WlanThermoInputException {\n+        if (channelUID.getGroupId() == null || data == null || settings == null) {\n+            throw new WlanThermoInputException();\n+        }\n+\n+        String groupId = channelUID.getGroupId();\n+        System system = data.getSystem();\n+        Unit<Temperature> unit = \"F\".equals(system.getUnit()) ? ImperialUnits.FAHRENHEIT : SIUnits.CELSIUS;\n+        List<Channel> channelList = data.getChannel();\n+\n+        if (SYSTEM.equals(groupId)) {\n+            switch (channelUID.getIdWithoutGroup()) {\n+                case SYSTEM_SOC:\n+                    return new DecimalType(system.getSoc());\n+                case SYSTEM_CHARGE:\n+                    return OnOffType.from(system.getCharge());\n+                case SYSTEM_RSSI_SIGNALSTRENGTH:\n+                    int dbm = system.getRssi();\n+                    if (dbm >= -80) {\n+                        return SIGNAL_STRENGTH_4;\n+                    } else if (dbm >= -95) {\n+                        return SIGNAL_STRENGTH_3;\n+                    } else if (dbm >= -105) {\n+                        return SIGNAL_STRENGTH_2;\n+                    } else {\n+                        return SIGNAL_STRENGTH_1;\n+                    }\n+                case SYSTEM_RSSI:\n+                    return new QuantityType<>(system.getRssi(), Units.DECIBEL_MILLIWATTS);\n+            }\n+        } else if (channelUID.getId().startsWith(CHANNEL_PREFIX)) {\n+            int channelId = Integer.parseInt(groupId.substring(CHANNEL_PREFIX.length())) - 1;\n+            if (channelList.size() > 0 && channelId <= channelList.size()) {\n+                Channel channel = channelList.get(channelId);\n+                switch (channelUID.getIdWithoutGroup()) {\n+                    case CHANNEL_NAME:\n+                        return new StringType(channel.getName());\n+                    case CHANNEL_TYP:\n+                        return new StringType(settings.sensors.get(channel.getTyp()));\n+                    case CHANNEL_TEMP:\n+                        return channel.getTemp() == 999.0 ? UnDefType.UNDEF\n+                                : new QuantityType<>(channel.getTemp(), unit);\n+                    case CHANNEL_MIN:\n+                        return new QuantityType<>(channel.getMin(), unit);\n+                    case CHANNEL_MAX:\n+                        return new QuantityType<>(channel.getMax(), unit);\n+                    case CHANNEL_ALARM_DEVICE:\n+                        return OnOffType.from(BigInteger.valueOf(channel.getAlarm()).testBit(1));\n+                    case CHANNEL_ALARM_PUSH:\n+                        return OnOffType.from(BigInteger.valueOf(channel.getAlarm()).testBit(0));\n+                    case CHANNEL_ALARM_OPENHAB_HIGH:\n+                        if (channel.getTemp() != 999 && channel.getTemp() > channel.getMax()) {\n+                            return OnOffType.ON;\n+                        } else {\n+                            return OnOffType.OFF;\n+                        }\n+                    case CHANNEL_ALARM_OPENHAB_LOW:\n+                        if (channel.getTemp() != 999 && channel.getTemp() < channel.getMin()) {\n+                            return OnOffType.ON;\n+                        } else {\n+                            return OnOffType.OFF;\n+                        }\n+                    case CHANNEL_COLOR:\n+                        String color = channel.getColor();\n+                        if (color != null && !color.isEmpty()) {\n+                            Color c = Color.decode(color);\n+                            return HSBType.fromRGB(c.getRed(), c.getGreen(), c.getBlue());\n+                        } else {\n+                            return UnDefType.UNDEF;\n+                        }\n+                    case CHANNEL_COLOR_NAME:\n+                        String colorHex = channel.getColor();\n+                        if (colorHex != null && !colorHex.isEmpty()) {\n+                            return new StringType(UtilNano.toColorName(colorHex));\n+                        } else {\n+                            return UnDefType.UNDEF;\n+                        }\n+                }\n+            }\n+        } else if (channelUID.getId().startsWith(CHANNEL_PITMASTER_1)) {\n+            if (data.getPitmaster() != null && data.getPitmaster().getPm() != null\n+                    && data.getPitmaster().getPm().size() > 0) {\n+                Pm pm = data.getPitmaster().getPm().get(0);\n+                switch (channelUID.getIdWithoutGroup()) {\n+                    case CHANNEL_PITMASTER_CHANNEL_ID:\n+                        return new DecimalType(pm.getChannel());\n+                    case CHANNEL_PITMASTER_PIDPROFILE:\n+                        return new DecimalType(pm.getPid());\n+                    case CHANNEL_PITMASTER_DUTY_CYCLE:\n+                        return new DecimalType(pm.getValue());\n+                    case CHANNEL_PITMASTER_SETPOINT:\n+                        return new QuantityType<>(pm.getSet(), unit);\n+                    case CHANNEL_PITMASTER_STATE:\n+                        return new StringType(pm.getTyp());\n+                }\n+            } else {\n+                return UnDefType.UNDEF;\n+            }\n+        }\n+        throw new WlanThermoUnknownChannelException(channelUID);\n+    }\n+\n+    public static boolean setState(ChannelUID channelUID, Command command, @Nullable Data data) {\n+        if (channelUID.getGroupId() == null || data == null || data.getSystem() == null) {\n+            return false;\n+        }\n+\n+        String groupId = channelUID.getGroupId();\n+        List<Channel> channelList = data.getChannel();\n+        System system = data.getSystem();\n+        Unit<Temperature> unit = \"F\".equals(system.getUnit()) ? ImperialUnits.FAHRENHEIT : SIUnits.CELSIUS;\n+\n+        if (channelUID.getId().startsWith(CHANNEL_PREFIX)) {\n+            int channelId = Integer.parseInt(groupId.substring(CHANNEL_PREFIX.length())) - 1;\n+            if (channelList.size() > 0 && channelId <= channelList.size()) {\n+                Channel channel = channelList.get(channelId);\n+                switch (channelUID.getIdWithoutGroup()) {\n+                    case CHANNEL_NAME:\n+                        if (command instanceof StringType) {\n+                            channel.setName(command.toFullString());\n+                            return true;\n+                        }\n+                    case CHANNEL_MIN:\n+                        if (command instanceof QuantityType) {\n+                            channel.setMin(((QuantityType<?>) command).toUnit(unit).doubleValue());\n+                            return true;\n+                        }\n+                    case CHANNEL_MAX:\n+                        if (command instanceof QuantityType) {\n+                            channel.setMax(((QuantityType<?>) command).toUnit(unit).doubleValue());\n+                            return true;\n+                        }\n+                    case CHANNEL_ALARM_DEVICE:\n+                        if (command instanceof OnOffType) {\n+                            BigInteger value;\n+                            if (command == OnOffType.ON) {\n+                                value = BigInteger.valueOf(channel.getAlarm()).setBit(1);\n+                            } else {\n+                                value = BigInteger.valueOf(channel.getAlarm()).clearBit(1);\n+                            }\n+                            channel.setAlarm(value.intValue());\n+                            return true;\n+                        }\n+                    case CHANNEL_ALARM_PUSH:\n+                        if (command instanceof OnOffType) {\n+                            BigInteger value;\n+                            if (command == OnOffType.ON) {\n+                                value = BigInteger.valueOf(channel.getAlarm()).setBit(0);\n+                            } else {\n+                                value = BigInteger.valueOf(channel.getAlarm()).clearBit(0);\n+                            }\n+                            channel.setAlarm(value.intValue());\n+                            return true;\n+                        }\n+                    case CHANNEL_COLOR_NAME:\n+                        if (command instanceof StringType) {\n+                            channel.setColor(UtilNano.toHex(((StringType) command).toString()));\n+                            return true;\n+                        }\n+                }\n+            }\n+        } else if (channelUID.getId().equals(CHANNEL_PITMASTER_1)) {\n+            if (data.getPitmaster() != null && data.getPitmaster().getPm() != null\n+                    && data.getPitmaster().getPm().size() > 0) {\n+                Pm pm = data.getPitmaster().getPm().get(0);\n+                switch (channelUID.getIdWithoutGroup()) {\n+                    case CHANNEL_PITMASTER_CHANNEL_ID:\n+                        pm.setChannel(((QuantityType<?>) command).intValue());\n+                        return true;\n+                    case CHANNEL_PITMASTER_PIDPROFILE:\n+                        pm.setPid(((QuantityType<?>) command).intValue());\n+                        return true;\n+                    case CHANNEL_PITMASTER_SETPOINT:\n+                        pm.setSet(((QuantityType<?>) command).toUnit(unit).doubleValue());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Njg3MTg0Mg=="}, "originalCommit": {"oid": "c1c9ac7f28764809641c2454e814ea14e9f54724"}, "originalPosition": 225}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzcxMzgxOA==", "bodyText": "If PITMASTER_PIDPROFILE is just a integer reference then why does it need to be a QuantityType?\nSame question for CHANNEL_PITMASTER_CHANNEL_ID.", "url": "https://github.com/openhab/openhab-addons/pull/9579#discussion_r557713818", "createdAt": "2021-01-14T21:36:04Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/api/nano/WlanThermoNanoV1CommandHandler.java", "diffHunk": "@@ -0,0 +1,266 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.wlanthermo.internal.api.nano;\n+\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.*;\n+\n+import java.awt.*;\n+import java.math.BigInteger;\n+import java.util.List;\n+\n+import javax.measure.Unit;\n+import javax.measure.quantity.Temperature;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.wlanthermo.internal.WlanThermoInputException;\n+import org.openhab.binding.wlanthermo.internal.WlanThermoUnknownChannelException;\n+import org.openhab.binding.wlanthermo.internal.api.nano.dto.data.Channel;\n+import org.openhab.binding.wlanthermo.internal.api.nano.dto.data.Data;\n+import org.openhab.binding.wlanthermo.internal.api.nano.dto.data.Pm;\n+import org.openhab.binding.wlanthermo.internal.api.nano.dto.data.System;\n+import org.openhab.binding.wlanthermo.internal.api.nano.dto.settings.Settings;\n+import org.openhab.core.library.types.*;\n+import org.openhab.core.library.unit.ImperialUnits;\n+import org.openhab.core.library.unit.SIUnits;\n+import org.openhab.core.library.unit.Units;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.UnDefType;\n+\n+/**\n+ * The {@link WlanThermoNanoV1CommandHandler} is responsible for mapping the Commands to the respective data fields\n+ * of the API.\n+ *\n+ * @author Christian Schlipp - Initial contribution\n+ */\n+@NonNullByDefault\n+public class WlanThermoNanoV1CommandHandler {\n+\n+    public static State getState(ChannelUID channelUID, @Nullable Data data, @Nullable Settings settings)\n+            throws WlanThermoUnknownChannelException, WlanThermoInputException {\n+        if (channelUID.getGroupId() == null || data == null || settings == null) {\n+            throw new WlanThermoInputException();\n+        }\n+\n+        String groupId = channelUID.getGroupId();\n+        System system = data.getSystem();\n+        Unit<Temperature> unit = \"F\".equals(system.getUnit()) ? ImperialUnits.FAHRENHEIT : SIUnits.CELSIUS;\n+        List<Channel> channelList = data.getChannel();\n+\n+        if (SYSTEM.equals(groupId)) {\n+            switch (channelUID.getIdWithoutGroup()) {\n+                case SYSTEM_SOC:\n+                    return new DecimalType(system.getSoc());\n+                case SYSTEM_CHARGE:\n+                    return OnOffType.from(system.getCharge());\n+                case SYSTEM_RSSI_SIGNALSTRENGTH:\n+                    int dbm = system.getRssi();\n+                    if (dbm >= -80) {\n+                        return SIGNAL_STRENGTH_4;\n+                    } else if (dbm >= -95) {\n+                        return SIGNAL_STRENGTH_3;\n+                    } else if (dbm >= -105) {\n+                        return SIGNAL_STRENGTH_2;\n+                    } else {\n+                        return SIGNAL_STRENGTH_1;\n+                    }\n+                case SYSTEM_RSSI:\n+                    return new QuantityType<>(system.getRssi(), Units.DECIBEL_MILLIWATTS);\n+            }\n+        } else if (channelUID.getId().startsWith(CHANNEL_PREFIX)) {\n+            int channelId = Integer.parseInt(groupId.substring(CHANNEL_PREFIX.length())) - 1;\n+            if (channelList.size() > 0 && channelId <= channelList.size()) {\n+                Channel channel = channelList.get(channelId);\n+                switch (channelUID.getIdWithoutGroup()) {\n+                    case CHANNEL_NAME:\n+                        return new StringType(channel.getName());\n+                    case CHANNEL_TYP:\n+                        return new StringType(settings.sensors.get(channel.getTyp()));\n+                    case CHANNEL_TEMP:\n+                        return channel.getTemp() == 999.0 ? UnDefType.UNDEF\n+                                : new QuantityType<>(channel.getTemp(), unit);\n+                    case CHANNEL_MIN:\n+                        return new QuantityType<>(channel.getMin(), unit);\n+                    case CHANNEL_MAX:\n+                        return new QuantityType<>(channel.getMax(), unit);\n+                    case CHANNEL_ALARM_DEVICE:\n+                        return OnOffType.from(BigInteger.valueOf(channel.getAlarm()).testBit(1));\n+                    case CHANNEL_ALARM_PUSH:\n+                        return OnOffType.from(BigInteger.valueOf(channel.getAlarm()).testBit(0));\n+                    case CHANNEL_ALARM_OPENHAB_HIGH:\n+                        if (channel.getTemp() != 999 && channel.getTemp() > channel.getMax()) {\n+                            return OnOffType.ON;\n+                        } else {\n+                            return OnOffType.OFF;\n+                        }\n+                    case CHANNEL_ALARM_OPENHAB_LOW:\n+                        if (channel.getTemp() != 999 && channel.getTemp() < channel.getMin()) {\n+                            return OnOffType.ON;\n+                        } else {\n+                            return OnOffType.OFF;\n+                        }\n+                    case CHANNEL_COLOR:\n+                        String color = channel.getColor();\n+                        if (color != null && !color.isEmpty()) {\n+                            Color c = Color.decode(color);\n+                            return HSBType.fromRGB(c.getRed(), c.getGreen(), c.getBlue());\n+                        } else {\n+                            return UnDefType.UNDEF;\n+                        }\n+                    case CHANNEL_COLOR_NAME:\n+                        String colorHex = channel.getColor();\n+                        if (colorHex != null && !colorHex.isEmpty()) {\n+                            return new StringType(UtilNano.toColorName(colorHex));\n+                        } else {\n+                            return UnDefType.UNDEF;\n+                        }\n+                }\n+            }\n+        } else if (channelUID.getId().startsWith(CHANNEL_PITMASTER_1)) {\n+            if (data.getPitmaster() != null && data.getPitmaster().getPm() != null\n+                    && data.getPitmaster().getPm().size() > 0) {\n+                Pm pm = data.getPitmaster().getPm().get(0);\n+                switch (channelUID.getIdWithoutGroup()) {\n+                    case CHANNEL_PITMASTER_CHANNEL_ID:\n+                        return new DecimalType(pm.getChannel());\n+                    case CHANNEL_PITMASTER_PIDPROFILE:\n+                        return new DecimalType(pm.getPid());\n+                    case CHANNEL_PITMASTER_DUTY_CYCLE:\n+                        return new DecimalType(pm.getValue());\n+                    case CHANNEL_PITMASTER_SETPOINT:\n+                        return new QuantityType<>(pm.getSet(), unit);\n+                    case CHANNEL_PITMASTER_STATE:\n+                        return new StringType(pm.getTyp());\n+                }\n+            } else {\n+                return UnDefType.UNDEF;\n+            }\n+        }\n+        throw new WlanThermoUnknownChannelException(channelUID);\n+    }\n+\n+    public static boolean setState(ChannelUID channelUID, Command command, @Nullable Data data) {\n+        if (channelUID.getGroupId() == null || data == null || data.getSystem() == null) {\n+            return false;\n+        }\n+\n+        String groupId = channelUID.getGroupId();\n+        List<Channel> channelList = data.getChannel();\n+        System system = data.getSystem();\n+        Unit<Temperature> unit = \"F\".equals(system.getUnit()) ? ImperialUnits.FAHRENHEIT : SIUnits.CELSIUS;\n+\n+        if (channelUID.getId().startsWith(CHANNEL_PREFIX)) {\n+            int channelId = Integer.parseInt(groupId.substring(CHANNEL_PREFIX.length())) - 1;\n+            if (channelList.size() > 0 && channelId <= channelList.size()) {\n+                Channel channel = channelList.get(channelId);\n+                switch (channelUID.getIdWithoutGroup()) {\n+                    case CHANNEL_NAME:\n+                        if (command instanceof StringType) {\n+                            channel.setName(command.toFullString());\n+                            return true;\n+                        }\n+                    case CHANNEL_MIN:\n+                        if (command instanceof QuantityType) {\n+                            channel.setMin(((QuantityType<?>) command).toUnit(unit).doubleValue());\n+                            return true;\n+                        }\n+                    case CHANNEL_MAX:\n+                        if (command instanceof QuantityType) {\n+                            channel.setMax(((QuantityType<?>) command).toUnit(unit).doubleValue());\n+                            return true;\n+                        }\n+                    case CHANNEL_ALARM_DEVICE:\n+                        if (command instanceof OnOffType) {\n+                            BigInteger value;\n+                            if (command == OnOffType.ON) {\n+                                value = BigInteger.valueOf(channel.getAlarm()).setBit(1);\n+                            } else {\n+                                value = BigInteger.valueOf(channel.getAlarm()).clearBit(1);\n+                            }\n+                            channel.setAlarm(value.intValue());\n+                            return true;\n+                        }\n+                    case CHANNEL_ALARM_PUSH:\n+                        if (command instanceof OnOffType) {\n+                            BigInteger value;\n+                            if (command == OnOffType.ON) {\n+                                value = BigInteger.valueOf(channel.getAlarm()).setBit(0);\n+                            } else {\n+                                value = BigInteger.valueOf(channel.getAlarm()).clearBit(0);\n+                            }\n+                            channel.setAlarm(value.intValue());\n+                            return true;\n+                        }\n+                    case CHANNEL_COLOR_NAME:\n+                        if (command instanceof StringType) {\n+                            channel.setColor(UtilNano.toHex(((StringType) command).toString()));\n+                            return true;\n+                        }\n+                }\n+            }\n+        } else if (channelUID.getId().equals(CHANNEL_PITMASTER_1)) {\n+            if (data.getPitmaster() != null && data.getPitmaster().getPm() != null\n+                    && data.getPitmaster().getPm().size() > 0) {\n+                Pm pm = data.getPitmaster().getPm().get(0);\n+                switch (channelUID.getIdWithoutGroup()) {\n+                    case CHANNEL_PITMASTER_CHANNEL_ID:\n+                        pm.setChannel(((QuantityType<?>) command).intValue());\n+                        return true;\n+                    case CHANNEL_PITMASTER_PIDPROFILE:\n+                        pm.setPid(((QuantityType<?>) command).intValue());\n+                        return true;\n+                    case CHANNEL_PITMASTER_SETPOINT:\n+                        pm.setSet(((QuantityType<?>) command).toUnit(unit).doubleValue());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Njg3MTg0Mg=="}, "originalCommit": {"oid": "c1c9ac7f28764809641c2454e814ea14e9f54724"}, "originalPosition": 225}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzcxNzY1OA==", "bodyText": "Ah, now I understood what you meant.\nReverted to DecimalType.", "url": "https://github.com/openhab/openhab-addons/pull/9579#discussion_r557717658", "createdAt": "2021-01-14T21:43:44Z", "author": {"login": "CSchlipp"}, "path": "bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/api/nano/WlanThermoNanoV1CommandHandler.java", "diffHunk": "@@ -0,0 +1,266 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.wlanthermo.internal.api.nano;\n+\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.*;\n+\n+import java.awt.*;\n+import java.math.BigInteger;\n+import java.util.List;\n+\n+import javax.measure.Unit;\n+import javax.measure.quantity.Temperature;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.wlanthermo.internal.WlanThermoInputException;\n+import org.openhab.binding.wlanthermo.internal.WlanThermoUnknownChannelException;\n+import org.openhab.binding.wlanthermo.internal.api.nano.dto.data.Channel;\n+import org.openhab.binding.wlanthermo.internal.api.nano.dto.data.Data;\n+import org.openhab.binding.wlanthermo.internal.api.nano.dto.data.Pm;\n+import org.openhab.binding.wlanthermo.internal.api.nano.dto.data.System;\n+import org.openhab.binding.wlanthermo.internal.api.nano.dto.settings.Settings;\n+import org.openhab.core.library.types.*;\n+import org.openhab.core.library.unit.ImperialUnits;\n+import org.openhab.core.library.unit.SIUnits;\n+import org.openhab.core.library.unit.Units;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.UnDefType;\n+\n+/**\n+ * The {@link WlanThermoNanoV1CommandHandler} is responsible for mapping the Commands to the respective data fields\n+ * of the API.\n+ *\n+ * @author Christian Schlipp - Initial contribution\n+ */\n+@NonNullByDefault\n+public class WlanThermoNanoV1CommandHandler {\n+\n+    public static State getState(ChannelUID channelUID, @Nullable Data data, @Nullable Settings settings)\n+            throws WlanThermoUnknownChannelException, WlanThermoInputException {\n+        if (channelUID.getGroupId() == null || data == null || settings == null) {\n+            throw new WlanThermoInputException();\n+        }\n+\n+        String groupId = channelUID.getGroupId();\n+        System system = data.getSystem();\n+        Unit<Temperature> unit = \"F\".equals(system.getUnit()) ? ImperialUnits.FAHRENHEIT : SIUnits.CELSIUS;\n+        List<Channel> channelList = data.getChannel();\n+\n+        if (SYSTEM.equals(groupId)) {\n+            switch (channelUID.getIdWithoutGroup()) {\n+                case SYSTEM_SOC:\n+                    return new DecimalType(system.getSoc());\n+                case SYSTEM_CHARGE:\n+                    return OnOffType.from(system.getCharge());\n+                case SYSTEM_RSSI_SIGNALSTRENGTH:\n+                    int dbm = system.getRssi();\n+                    if (dbm >= -80) {\n+                        return SIGNAL_STRENGTH_4;\n+                    } else if (dbm >= -95) {\n+                        return SIGNAL_STRENGTH_3;\n+                    } else if (dbm >= -105) {\n+                        return SIGNAL_STRENGTH_2;\n+                    } else {\n+                        return SIGNAL_STRENGTH_1;\n+                    }\n+                case SYSTEM_RSSI:\n+                    return new QuantityType<>(system.getRssi(), Units.DECIBEL_MILLIWATTS);\n+            }\n+        } else if (channelUID.getId().startsWith(CHANNEL_PREFIX)) {\n+            int channelId = Integer.parseInt(groupId.substring(CHANNEL_PREFIX.length())) - 1;\n+            if (channelList.size() > 0 && channelId <= channelList.size()) {\n+                Channel channel = channelList.get(channelId);\n+                switch (channelUID.getIdWithoutGroup()) {\n+                    case CHANNEL_NAME:\n+                        return new StringType(channel.getName());\n+                    case CHANNEL_TYP:\n+                        return new StringType(settings.sensors.get(channel.getTyp()));\n+                    case CHANNEL_TEMP:\n+                        return channel.getTemp() == 999.0 ? UnDefType.UNDEF\n+                                : new QuantityType<>(channel.getTemp(), unit);\n+                    case CHANNEL_MIN:\n+                        return new QuantityType<>(channel.getMin(), unit);\n+                    case CHANNEL_MAX:\n+                        return new QuantityType<>(channel.getMax(), unit);\n+                    case CHANNEL_ALARM_DEVICE:\n+                        return OnOffType.from(BigInteger.valueOf(channel.getAlarm()).testBit(1));\n+                    case CHANNEL_ALARM_PUSH:\n+                        return OnOffType.from(BigInteger.valueOf(channel.getAlarm()).testBit(0));\n+                    case CHANNEL_ALARM_OPENHAB_HIGH:\n+                        if (channel.getTemp() != 999 && channel.getTemp() > channel.getMax()) {\n+                            return OnOffType.ON;\n+                        } else {\n+                            return OnOffType.OFF;\n+                        }\n+                    case CHANNEL_ALARM_OPENHAB_LOW:\n+                        if (channel.getTemp() != 999 && channel.getTemp() < channel.getMin()) {\n+                            return OnOffType.ON;\n+                        } else {\n+                            return OnOffType.OFF;\n+                        }\n+                    case CHANNEL_COLOR:\n+                        String color = channel.getColor();\n+                        if (color != null && !color.isEmpty()) {\n+                            Color c = Color.decode(color);\n+                            return HSBType.fromRGB(c.getRed(), c.getGreen(), c.getBlue());\n+                        } else {\n+                            return UnDefType.UNDEF;\n+                        }\n+                    case CHANNEL_COLOR_NAME:\n+                        String colorHex = channel.getColor();\n+                        if (colorHex != null && !colorHex.isEmpty()) {\n+                            return new StringType(UtilNano.toColorName(colorHex));\n+                        } else {\n+                            return UnDefType.UNDEF;\n+                        }\n+                }\n+            }\n+        } else if (channelUID.getId().startsWith(CHANNEL_PITMASTER_1)) {\n+            if (data.getPitmaster() != null && data.getPitmaster().getPm() != null\n+                    && data.getPitmaster().getPm().size() > 0) {\n+                Pm pm = data.getPitmaster().getPm().get(0);\n+                switch (channelUID.getIdWithoutGroup()) {\n+                    case CHANNEL_PITMASTER_CHANNEL_ID:\n+                        return new DecimalType(pm.getChannel());\n+                    case CHANNEL_PITMASTER_PIDPROFILE:\n+                        return new DecimalType(pm.getPid());\n+                    case CHANNEL_PITMASTER_DUTY_CYCLE:\n+                        return new DecimalType(pm.getValue());\n+                    case CHANNEL_PITMASTER_SETPOINT:\n+                        return new QuantityType<>(pm.getSet(), unit);\n+                    case CHANNEL_PITMASTER_STATE:\n+                        return new StringType(pm.getTyp());\n+                }\n+            } else {\n+                return UnDefType.UNDEF;\n+            }\n+        }\n+        throw new WlanThermoUnknownChannelException(channelUID);\n+    }\n+\n+    public static boolean setState(ChannelUID channelUID, Command command, @Nullable Data data) {\n+        if (channelUID.getGroupId() == null || data == null || data.getSystem() == null) {\n+            return false;\n+        }\n+\n+        String groupId = channelUID.getGroupId();\n+        List<Channel> channelList = data.getChannel();\n+        System system = data.getSystem();\n+        Unit<Temperature> unit = \"F\".equals(system.getUnit()) ? ImperialUnits.FAHRENHEIT : SIUnits.CELSIUS;\n+\n+        if (channelUID.getId().startsWith(CHANNEL_PREFIX)) {\n+            int channelId = Integer.parseInt(groupId.substring(CHANNEL_PREFIX.length())) - 1;\n+            if (channelList.size() > 0 && channelId <= channelList.size()) {\n+                Channel channel = channelList.get(channelId);\n+                switch (channelUID.getIdWithoutGroup()) {\n+                    case CHANNEL_NAME:\n+                        if (command instanceof StringType) {\n+                            channel.setName(command.toFullString());\n+                            return true;\n+                        }\n+                    case CHANNEL_MIN:\n+                        if (command instanceof QuantityType) {\n+                            channel.setMin(((QuantityType<?>) command).toUnit(unit).doubleValue());\n+                            return true;\n+                        }\n+                    case CHANNEL_MAX:\n+                        if (command instanceof QuantityType) {\n+                            channel.setMax(((QuantityType<?>) command).toUnit(unit).doubleValue());\n+                            return true;\n+                        }\n+                    case CHANNEL_ALARM_DEVICE:\n+                        if (command instanceof OnOffType) {\n+                            BigInteger value;\n+                            if (command == OnOffType.ON) {\n+                                value = BigInteger.valueOf(channel.getAlarm()).setBit(1);\n+                            } else {\n+                                value = BigInteger.valueOf(channel.getAlarm()).clearBit(1);\n+                            }\n+                            channel.setAlarm(value.intValue());\n+                            return true;\n+                        }\n+                    case CHANNEL_ALARM_PUSH:\n+                        if (command instanceof OnOffType) {\n+                            BigInteger value;\n+                            if (command == OnOffType.ON) {\n+                                value = BigInteger.valueOf(channel.getAlarm()).setBit(0);\n+                            } else {\n+                                value = BigInteger.valueOf(channel.getAlarm()).clearBit(0);\n+                            }\n+                            channel.setAlarm(value.intValue());\n+                            return true;\n+                        }\n+                    case CHANNEL_COLOR_NAME:\n+                        if (command instanceof StringType) {\n+                            channel.setColor(UtilNano.toHex(((StringType) command).toString()));\n+                            return true;\n+                        }\n+                }\n+            }\n+        } else if (channelUID.getId().equals(CHANNEL_PITMASTER_1)) {\n+            if (data.getPitmaster() != null && data.getPitmaster().getPm() != null\n+                    && data.getPitmaster().getPm().size() > 0) {\n+                Pm pm = data.getPitmaster().getPm().get(0);\n+                switch (channelUID.getIdWithoutGroup()) {\n+                    case CHANNEL_PITMASTER_CHANNEL_ID:\n+                        pm.setChannel(((QuantityType<?>) command).intValue());\n+                        return true;\n+                    case CHANNEL_PITMASTER_PIDPROFILE:\n+                        pm.setPid(((QuantityType<?>) command).intValue());\n+                        return true;\n+                    case CHANNEL_PITMASTER_SETPOINT:\n+                        pm.setSet(((QuantityType<?>) command).toUnit(unit).doubleValue());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Njg3MTg0Mg=="}, "originalCommit": {"oid": "c1c9ac7f28764809641c2454e814ea14e9f54724"}, "originalPosition": 225}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzUwNjAwMzU5OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/api/nano/WlanThermoNanoV1CommandHandler.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xM1QyMTo1NDozM1rOITE3EA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xNFQyMTo0MDowMVrOIT4RYw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Njg3MzQ4OA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    } else if (channelUID.getId().equals(CHANNEL_PITMASTER_1)) {\n          \n          \n            \n                    } else if (channelUID.getId().startsWith(CHANNEL_PITMASTER_1)) {", "url": "https://github.com/openhab/openhab-addons/pull/9579#discussion_r556873488", "createdAt": "2021-01-13T21:54:33Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/api/nano/WlanThermoNanoV1CommandHandler.java", "diffHunk": "@@ -0,0 +1,266 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.wlanthermo.internal.api.nano;\n+\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.*;\n+\n+import java.awt.*;\n+import java.math.BigInteger;\n+import java.util.List;\n+\n+import javax.measure.Unit;\n+import javax.measure.quantity.Temperature;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.wlanthermo.internal.WlanThermoInputException;\n+import org.openhab.binding.wlanthermo.internal.WlanThermoUnknownChannelException;\n+import org.openhab.binding.wlanthermo.internal.api.nano.dto.data.Channel;\n+import org.openhab.binding.wlanthermo.internal.api.nano.dto.data.Data;\n+import org.openhab.binding.wlanthermo.internal.api.nano.dto.data.Pm;\n+import org.openhab.binding.wlanthermo.internal.api.nano.dto.data.System;\n+import org.openhab.binding.wlanthermo.internal.api.nano.dto.settings.Settings;\n+import org.openhab.core.library.types.*;\n+import org.openhab.core.library.unit.ImperialUnits;\n+import org.openhab.core.library.unit.SIUnits;\n+import org.openhab.core.library.unit.Units;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.UnDefType;\n+\n+/**\n+ * The {@link WlanThermoNanoV1CommandHandler} is responsible for mapping the Commands to the respective data fields\n+ * of the API.\n+ *\n+ * @author Christian Schlipp - Initial contribution\n+ */\n+@NonNullByDefault\n+public class WlanThermoNanoV1CommandHandler {\n+\n+    public static State getState(ChannelUID channelUID, @Nullable Data data, @Nullable Settings settings)\n+            throws WlanThermoUnknownChannelException, WlanThermoInputException {\n+        if (channelUID.getGroupId() == null || data == null || settings == null) {\n+            throw new WlanThermoInputException();\n+        }\n+\n+        String groupId = channelUID.getGroupId();\n+        System system = data.getSystem();\n+        Unit<Temperature> unit = \"F\".equals(system.getUnit()) ? ImperialUnits.FAHRENHEIT : SIUnits.CELSIUS;\n+        List<Channel> channelList = data.getChannel();\n+\n+        if (SYSTEM.equals(groupId)) {\n+            switch (channelUID.getIdWithoutGroup()) {\n+                case SYSTEM_SOC:\n+                    return new DecimalType(system.getSoc());\n+                case SYSTEM_CHARGE:\n+                    return OnOffType.from(system.getCharge());\n+                case SYSTEM_RSSI_SIGNALSTRENGTH:\n+                    int dbm = system.getRssi();\n+                    if (dbm >= -80) {\n+                        return SIGNAL_STRENGTH_4;\n+                    } else if (dbm >= -95) {\n+                        return SIGNAL_STRENGTH_3;\n+                    } else if (dbm >= -105) {\n+                        return SIGNAL_STRENGTH_2;\n+                    } else {\n+                        return SIGNAL_STRENGTH_1;\n+                    }\n+                case SYSTEM_RSSI:\n+                    return new QuantityType<>(system.getRssi(), Units.DECIBEL_MILLIWATTS);\n+            }\n+        } else if (channelUID.getId().startsWith(CHANNEL_PREFIX)) {\n+            int channelId = Integer.parseInt(groupId.substring(CHANNEL_PREFIX.length())) - 1;\n+            if (channelList.size() > 0 && channelId <= channelList.size()) {\n+                Channel channel = channelList.get(channelId);\n+                switch (channelUID.getIdWithoutGroup()) {\n+                    case CHANNEL_NAME:\n+                        return new StringType(channel.getName());\n+                    case CHANNEL_TYP:\n+                        return new StringType(settings.sensors.get(channel.getTyp()));\n+                    case CHANNEL_TEMP:\n+                        return channel.getTemp() == 999.0 ? UnDefType.UNDEF\n+                                : new QuantityType<>(channel.getTemp(), unit);\n+                    case CHANNEL_MIN:\n+                        return new QuantityType<>(channel.getMin(), unit);\n+                    case CHANNEL_MAX:\n+                        return new QuantityType<>(channel.getMax(), unit);\n+                    case CHANNEL_ALARM_DEVICE:\n+                        return OnOffType.from(BigInteger.valueOf(channel.getAlarm()).testBit(1));\n+                    case CHANNEL_ALARM_PUSH:\n+                        return OnOffType.from(BigInteger.valueOf(channel.getAlarm()).testBit(0));\n+                    case CHANNEL_ALARM_OPENHAB_HIGH:\n+                        if (channel.getTemp() != 999 && channel.getTemp() > channel.getMax()) {\n+                            return OnOffType.ON;\n+                        } else {\n+                            return OnOffType.OFF;\n+                        }\n+                    case CHANNEL_ALARM_OPENHAB_LOW:\n+                        if (channel.getTemp() != 999 && channel.getTemp() < channel.getMin()) {\n+                            return OnOffType.ON;\n+                        } else {\n+                            return OnOffType.OFF;\n+                        }\n+                    case CHANNEL_COLOR:\n+                        String color = channel.getColor();\n+                        if (color != null && !color.isEmpty()) {\n+                            Color c = Color.decode(color);\n+                            return HSBType.fromRGB(c.getRed(), c.getGreen(), c.getBlue());\n+                        } else {\n+                            return UnDefType.UNDEF;\n+                        }\n+                    case CHANNEL_COLOR_NAME:\n+                        String colorHex = channel.getColor();\n+                        if (colorHex != null && !colorHex.isEmpty()) {\n+                            return new StringType(UtilNano.toColorName(colorHex));\n+                        } else {\n+                            return UnDefType.UNDEF;\n+                        }\n+                }\n+            }\n+        } else if (channelUID.getId().startsWith(CHANNEL_PITMASTER_1)) {\n+            if (data.getPitmaster() != null && data.getPitmaster().getPm() != null\n+                    && data.getPitmaster().getPm().size() > 0) {\n+                Pm pm = data.getPitmaster().getPm().get(0);\n+                switch (channelUID.getIdWithoutGroup()) {\n+                    case CHANNEL_PITMASTER_CHANNEL_ID:\n+                        return new DecimalType(pm.getChannel());\n+                    case CHANNEL_PITMASTER_PIDPROFILE:\n+                        return new DecimalType(pm.getPid());\n+                    case CHANNEL_PITMASTER_DUTY_CYCLE:\n+                        return new DecimalType(pm.getValue());\n+                    case CHANNEL_PITMASTER_SETPOINT:\n+                        return new QuantityType<>(pm.getSet(), unit);\n+                    case CHANNEL_PITMASTER_STATE:\n+                        return new StringType(pm.getTyp());\n+                }\n+            } else {\n+                return UnDefType.UNDEF;\n+            }\n+        }\n+        throw new WlanThermoUnknownChannelException(channelUID);\n+    }\n+\n+    public static boolean setState(ChannelUID channelUID, Command command, @Nullable Data data) {\n+        if (channelUID.getGroupId() == null || data == null || data.getSystem() == null) {\n+            return false;\n+        }\n+\n+        String groupId = channelUID.getGroupId();\n+        List<Channel> channelList = data.getChannel();\n+        System system = data.getSystem();\n+        Unit<Temperature> unit = \"F\".equals(system.getUnit()) ? ImperialUnits.FAHRENHEIT : SIUnits.CELSIUS;\n+\n+        if (channelUID.getId().startsWith(CHANNEL_PREFIX)) {\n+            int channelId = Integer.parseInt(groupId.substring(CHANNEL_PREFIX.length())) - 1;\n+            if (channelList.size() > 0 && channelId <= channelList.size()) {\n+                Channel channel = channelList.get(channelId);\n+                switch (channelUID.getIdWithoutGroup()) {\n+                    case CHANNEL_NAME:\n+                        if (command instanceof StringType) {\n+                            channel.setName(command.toFullString());\n+                            return true;\n+                        }\n+                    case CHANNEL_MIN:\n+                        if (command instanceof QuantityType) {\n+                            channel.setMin(((QuantityType<?>) command).toUnit(unit).doubleValue());\n+                            return true;\n+                        }\n+                    case CHANNEL_MAX:\n+                        if (command instanceof QuantityType) {\n+                            channel.setMax(((QuantityType<?>) command).toUnit(unit).doubleValue());\n+                            return true;\n+                        }\n+                    case CHANNEL_ALARM_DEVICE:\n+                        if (command instanceof OnOffType) {\n+                            BigInteger value;\n+                            if (command == OnOffType.ON) {\n+                                value = BigInteger.valueOf(channel.getAlarm()).setBit(1);\n+                            } else {\n+                                value = BigInteger.valueOf(channel.getAlarm()).clearBit(1);\n+                            }\n+                            channel.setAlarm(value.intValue());\n+                            return true;\n+                        }\n+                    case CHANNEL_ALARM_PUSH:\n+                        if (command instanceof OnOffType) {\n+                            BigInteger value;\n+                            if (command == OnOffType.ON) {\n+                                value = BigInteger.valueOf(channel.getAlarm()).setBit(0);\n+                            } else {\n+                                value = BigInteger.valueOf(channel.getAlarm()).clearBit(0);\n+                            }\n+                            channel.setAlarm(value.intValue());\n+                            return true;\n+                        }\n+                    case CHANNEL_COLOR_NAME:\n+                        if (command instanceof StringType) {\n+                            channel.setColor(UtilNano.toHex(((StringType) command).toString()));\n+                            return true;\n+                        }\n+                }\n+            }\n+        } else if (channelUID.getId().equals(CHANNEL_PITMASTER_1)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c1c9ac7f28764809641c2454e814ea14e9f54724"}, "originalPosition": 213}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzA3MDc5NQ==", "bodyText": "That's actually a difference in the NanoV1 device, it does only provide a single Pitmaster channel.\nTherefore, I can directly check for the whole id instead of checking the prefix first and then obtaining the actual channel numbers.", "url": "https://github.com/openhab/openhab-addons/pull/9579#discussion_r557070795", "createdAt": "2021-01-14T06:34:05Z", "author": {"login": "CSchlipp"}, "path": "bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/api/nano/WlanThermoNanoV1CommandHandler.java", "diffHunk": "@@ -0,0 +1,266 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.wlanthermo.internal.api.nano;\n+\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.*;\n+\n+import java.awt.*;\n+import java.math.BigInteger;\n+import java.util.List;\n+\n+import javax.measure.Unit;\n+import javax.measure.quantity.Temperature;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.wlanthermo.internal.WlanThermoInputException;\n+import org.openhab.binding.wlanthermo.internal.WlanThermoUnknownChannelException;\n+import org.openhab.binding.wlanthermo.internal.api.nano.dto.data.Channel;\n+import org.openhab.binding.wlanthermo.internal.api.nano.dto.data.Data;\n+import org.openhab.binding.wlanthermo.internal.api.nano.dto.data.Pm;\n+import org.openhab.binding.wlanthermo.internal.api.nano.dto.data.System;\n+import org.openhab.binding.wlanthermo.internal.api.nano.dto.settings.Settings;\n+import org.openhab.core.library.types.*;\n+import org.openhab.core.library.unit.ImperialUnits;\n+import org.openhab.core.library.unit.SIUnits;\n+import org.openhab.core.library.unit.Units;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.UnDefType;\n+\n+/**\n+ * The {@link WlanThermoNanoV1CommandHandler} is responsible for mapping the Commands to the respective data fields\n+ * of the API.\n+ *\n+ * @author Christian Schlipp - Initial contribution\n+ */\n+@NonNullByDefault\n+public class WlanThermoNanoV1CommandHandler {\n+\n+    public static State getState(ChannelUID channelUID, @Nullable Data data, @Nullable Settings settings)\n+            throws WlanThermoUnknownChannelException, WlanThermoInputException {\n+        if (channelUID.getGroupId() == null || data == null || settings == null) {\n+            throw new WlanThermoInputException();\n+        }\n+\n+        String groupId = channelUID.getGroupId();\n+        System system = data.getSystem();\n+        Unit<Temperature> unit = \"F\".equals(system.getUnit()) ? ImperialUnits.FAHRENHEIT : SIUnits.CELSIUS;\n+        List<Channel> channelList = data.getChannel();\n+\n+        if (SYSTEM.equals(groupId)) {\n+            switch (channelUID.getIdWithoutGroup()) {\n+                case SYSTEM_SOC:\n+                    return new DecimalType(system.getSoc());\n+                case SYSTEM_CHARGE:\n+                    return OnOffType.from(system.getCharge());\n+                case SYSTEM_RSSI_SIGNALSTRENGTH:\n+                    int dbm = system.getRssi();\n+                    if (dbm >= -80) {\n+                        return SIGNAL_STRENGTH_4;\n+                    } else if (dbm >= -95) {\n+                        return SIGNAL_STRENGTH_3;\n+                    } else if (dbm >= -105) {\n+                        return SIGNAL_STRENGTH_2;\n+                    } else {\n+                        return SIGNAL_STRENGTH_1;\n+                    }\n+                case SYSTEM_RSSI:\n+                    return new QuantityType<>(system.getRssi(), Units.DECIBEL_MILLIWATTS);\n+            }\n+        } else if (channelUID.getId().startsWith(CHANNEL_PREFIX)) {\n+            int channelId = Integer.parseInt(groupId.substring(CHANNEL_PREFIX.length())) - 1;\n+            if (channelList.size() > 0 && channelId <= channelList.size()) {\n+                Channel channel = channelList.get(channelId);\n+                switch (channelUID.getIdWithoutGroup()) {\n+                    case CHANNEL_NAME:\n+                        return new StringType(channel.getName());\n+                    case CHANNEL_TYP:\n+                        return new StringType(settings.sensors.get(channel.getTyp()));\n+                    case CHANNEL_TEMP:\n+                        return channel.getTemp() == 999.0 ? UnDefType.UNDEF\n+                                : new QuantityType<>(channel.getTemp(), unit);\n+                    case CHANNEL_MIN:\n+                        return new QuantityType<>(channel.getMin(), unit);\n+                    case CHANNEL_MAX:\n+                        return new QuantityType<>(channel.getMax(), unit);\n+                    case CHANNEL_ALARM_DEVICE:\n+                        return OnOffType.from(BigInteger.valueOf(channel.getAlarm()).testBit(1));\n+                    case CHANNEL_ALARM_PUSH:\n+                        return OnOffType.from(BigInteger.valueOf(channel.getAlarm()).testBit(0));\n+                    case CHANNEL_ALARM_OPENHAB_HIGH:\n+                        if (channel.getTemp() != 999 && channel.getTemp() > channel.getMax()) {\n+                            return OnOffType.ON;\n+                        } else {\n+                            return OnOffType.OFF;\n+                        }\n+                    case CHANNEL_ALARM_OPENHAB_LOW:\n+                        if (channel.getTemp() != 999 && channel.getTemp() < channel.getMin()) {\n+                            return OnOffType.ON;\n+                        } else {\n+                            return OnOffType.OFF;\n+                        }\n+                    case CHANNEL_COLOR:\n+                        String color = channel.getColor();\n+                        if (color != null && !color.isEmpty()) {\n+                            Color c = Color.decode(color);\n+                            return HSBType.fromRGB(c.getRed(), c.getGreen(), c.getBlue());\n+                        } else {\n+                            return UnDefType.UNDEF;\n+                        }\n+                    case CHANNEL_COLOR_NAME:\n+                        String colorHex = channel.getColor();\n+                        if (colorHex != null && !colorHex.isEmpty()) {\n+                            return new StringType(UtilNano.toColorName(colorHex));\n+                        } else {\n+                            return UnDefType.UNDEF;\n+                        }\n+                }\n+            }\n+        } else if (channelUID.getId().startsWith(CHANNEL_PITMASTER_1)) {\n+            if (data.getPitmaster() != null && data.getPitmaster().getPm() != null\n+                    && data.getPitmaster().getPm().size() > 0) {\n+                Pm pm = data.getPitmaster().getPm().get(0);\n+                switch (channelUID.getIdWithoutGroup()) {\n+                    case CHANNEL_PITMASTER_CHANNEL_ID:\n+                        return new DecimalType(pm.getChannel());\n+                    case CHANNEL_PITMASTER_PIDPROFILE:\n+                        return new DecimalType(pm.getPid());\n+                    case CHANNEL_PITMASTER_DUTY_CYCLE:\n+                        return new DecimalType(pm.getValue());\n+                    case CHANNEL_PITMASTER_SETPOINT:\n+                        return new QuantityType<>(pm.getSet(), unit);\n+                    case CHANNEL_PITMASTER_STATE:\n+                        return new StringType(pm.getTyp());\n+                }\n+            } else {\n+                return UnDefType.UNDEF;\n+            }\n+        }\n+        throw new WlanThermoUnknownChannelException(channelUID);\n+    }\n+\n+    public static boolean setState(ChannelUID channelUID, Command command, @Nullable Data data) {\n+        if (channelUID.getGroupId() == null || data == null || data.getSystem() == null) {\n+            return false;\n+        }\n+\n+        String groupId = channelUID.getGroupId();\n+        List<Channel> channelList = data.getChannel();\n+        System system = data.getSystem();\n+        Unit<Temperature> unit = \"F\".equals(system.getUnit()) ? ImperialUnits.FAHRENHEIT : SIUnits.CELSIUS;\n+\n+        if (channelUID.getId().startsWith(CHANNEL_PREFIX)) {\n+            int channelId = Integer.parseInt(groupId.substring(CHANNEL_PREFIX.length())) - 1;\n+            if (channelList.size() > 0 && channelId <= channelList.size()) {\n+                Channel channel = channelList.get(channelId);\n+                switch (channelUID.getIdWithoutGroup()) {\n+                    case CHANNEL_NAME:\n+                        if (command instanceof StringType) {\n+                            channel.setName(command.toFullString());\n+                            return true;\n+                        }\n+                    case CHANNEL_MIN:\n+                        if (command instanceof QuantityType) {\n+                            channel.setMin(((QuantityType<?>) command).toUnit(unit).doubleValue());\n+                            return true;\n+                        }\n+                    case CHANNEL_MAX:\n+                        if (command instanceof QuantityType) {\n+                            channel.setMax(((QuantityType<?>) command).toUnit(unit).doubleValue());\n+                            return true;\n+                        }\n+                    case CHANNEL_ALARM_DEVICE:\n+                        if (command instanceof OnOffType) {\n+                            BigInteger value;\n+                            if (command == OnOffType.ON) {\n+                                value = BigInteger.valueOf(channel.getAlarm()).setBit(1);\n+                            } else {\n+                                value = BigInteger.valueOf(channel.getAlarm()).clearBit(1);\n+                            }\n+                            channel.setAlarm(value.intValue());\n+                            return true;\n+                        }\n+                    case CHANNEL_ALARM_PUSH:\n+                        if (command instanceof OnOffType) {\n+                            BigInteger value;\n+                            if (command == OnOffType.ON) {\n+                                value = BigInteger.valueOf(channel.getAlarm()).setBit(0);\n+                            } else {\n+                                value = BigInteger.valueOf(channel.getAlarm()).clearBit(0);\n+                            }\n+                            channel.setAlarm(value.intValue());\n+                            return true;\n+                        }\n+                    case CHANNEL_COLOR_NAME:\n+                        if (command instanceof StringType) {\n+                            channel.setColor(UtilNano.toHex(((StringType) command).toString()));\n+                            return true;\n+                        }\n+                }\n+            }\n+        } else if (channelUID.getId().equals(CHANNEL_PITMASTER_1)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Njg3MzQ4OA=="}, "originalCommit": {"oid": "c1c9ac7f28764809641c2454e814ea14e9f54724"}, "originalPosition": 213}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzcwODQ0Mw==", "bodyText": "But just a couple of lines down you are expecting channelUID.getIdWithoutGroup() to return different results? Wouldn't the CHANNEL_PITMASTER_1 be the only result that could be returned? As the code is written now the switch statement serves no purpose.", "url": "https://github.com/openhab/openhab-addons/pull/9579#discussion_r557708443", "createdAt": "2021-01-14T21:25:40Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/api/nano/WlanThermoNanoV1CommandHandler.java", "diffHunk": "@@ -0,0 +1,266 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.wlanthermo.internal.api.nano;\n+\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.*;\n+\n+import java.awt.*;\n+import java.math.BigInteger;\n+import java.util.List;\n+\n+import javax.measure.Unit;\n+import javax.measure.quantity.Temperature;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.wlanthermo.internal.WlanThermoInputException;\n+import org.openhab.binding.wlanthermo.internal.WlanThermoUnknownChannelException;\n+import org.openhab.binding.wlanthermo.internal.api.nano.dto.data.Channel;\n+import org.openhab.binding.wlanthermo.internal.api.nano.dto.data.Data;\n+import org.openhab.binding.wlanthermo.internal.api.nano.dto.data.Pm;\n+import org.openhab.binding.wlanthermo.internal.api.nano.dto.data.System;\n+import org.openhab.binding.wlanthermo.internal.api.nano.dto.settings.Settings;\n+import org.openhab.core.library.types.*;\n+import org.openhab.core.library.unit.ImperialUnits;\n+import org.openhab.core.library.unit.SIUnits;\n+import org.openhab.core.library.unit.Units;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.UnDefType;\n+\n+/**\n+ * The {@link WlanThermoNanoV1CommandHandler} is responsible for mapping the Commands to the respective data fields\n+ * of the API.\n+ *\n+ * @author Christian Schlipp - Initial contribution\n+ */\n+@NonNullByDefault\n+public class WlanThermoNanoV1CommandHandler {\n+\n+    public static State getState(ChannelUID channelUID, @Nullable Data data, @Nullable Settings settings)\n+            throws WlanThermoUnknownChannelException, WlanThermoInputException {\n+        if (channelUID.getGroupId() == null || data == null || settings == null) {\n+            throw new WlanThermoInputException();\n+        }\n+\n+        String groupId = channelUID.getGroupId();\n+        System system = data.getSystem();\n+        Unit<Temperature> unit = \"F\".equals(system.getUnit()) ? ImperialUnits.FAHRENHEIT : SIUnits.CELSIUS;\n+        List<Channel> channelList = data.getChannel();\n+\n+        if (SYSTEM.equals(groupId)) {\n+            switch (channelUID.getIdWithoutGroup()) {\n+                case SYSTEM_SOC:\n+                    return new DecimalType(system.getSoc());\n+                case SYSTEM_CHARGE:\n+                    return OnOffType.from(system.getCharge());\n+                case SYSTEM_RSSI_SIGNALSTRENGTH:\n+                    int dbm = system.getRssi();\n+                    if (dbm >= -80) {\n+                        return SIGNAL_STRENGTH_4;\n+                    } else if (dbm >= -95) {\n+                        return SIGNAL_STRENGTH_3;\n+                    } else if (dbm >= -105) {\n+                        return SIGNAL_STRENGTH_2;\n+                    } else {\n+                        return SIGNAL_STRENGTH_1;\n+                    }\n+                case SYSTEM_RSSI:\n+                    return new QuantityType<>(system.getRssi(), Units.DECIBEL_MILLIWATTS);\n+            }\n+        } else if (channelUID.getId().startsWith(CHANNEL_PREFIX)) {\n+            int channelId = Integer.parseInt(groupId.substring(CHANNEL_PREFIX.length())) - 1;\n+            if (channelList.size() > 0 && channelId <= channelList.size()) {\n+                Channel channel = channelList.get(channelId);\n+                switch (channelUID.getIdWithoutGroup()) {\n+                    case CHANNEL_NAME:\n+                        return new StringType(channel.getName());\n+                    case CHANNEL_TYP:\n+                        return new StringType(settings.sensors.get(channel.getTyp()));\n+                    case CHANNEL_TEMP:\n+                        return channel.getTemp() == 999.0 ? UnDefType.UNDEF\n+                                : new QuantityType<>(channel.getTemp(), unit);\n+                    case CHANNEL_MIN:\n+                        return new QuantityType<>(channel.getMin(), unit);\n+                    case CHANNEL_MAX:\n+                        return new QuantityType<>(channel.getMax(), unit);\n+                    case CHANNEL_ALARM_DEVICE:\n+                        return OnOffType.from(BigInteger.valueOf(channel.getAlarm()).testBit(1));\n+                    case CHANNEL_ALARM_PUSH:\n+                        return OnOffType.from(BigInteger.valueOf(channel.getAlarm()).testBit(0));\n+                    case CHANNEL_ALARM_OPENHAB_HIGH:\n+                        if (channel.getTemp() != 999 && channel.getTemp() > channel.getMax()) {\n+                            return OnOffType.ON;\n+                        } else {\n+                            return OnOffType.OFF;\n+                        }\n+                    case CHANNEL_ALARM_OPENHAB_LOW:\n+                        if (channel.getTemp() != 999 && channel.getTemp() < channel.getMin()) {\n+                            return OnOffType.ON;\n+                        } else {\n+                            return OnOffType.OFF;\n+                        }\n+                    case CHANNEL_COLOR:\n+                        String color = channel.getColor();\n+                        if (color != null && !color.isEmpty()) {\n+                            Color c = Color.decode(color);\n+                            return HSBType.fromRGB(c.getRed(), c.getGreen(), c.getBlue());\n+                        } else {\n+                            return UnDefType.UNDEF;\n+                        }\n+                    case CHANNEL_COLOR_NAME:\n+                        String colorHex = channel.getColor();\n+                        if (colorHex != null && !colorHex.isEmpty()) {\n+                            return new StringType(UtilNano.toColorName(colorHex));\n+                        } else {\n+                            return UnDefType.UNDEF;\n+                        }\n+                }\n+            }\n+        } else if (channelUID.getId().startsWith(CHANNEL_PITMASTER_1)) {\n+            if (data.getPitmaster() != null && data.getPitmaster().getPm() != null\n+                    && data.getPitmaster().getPm().size() > 0) {\n+                Pm pm = data.getPitmaster().getPm().get(0);\n+                switch (channelUID.getIdWithoutGroup()) {\n+                    case CHANNEL_PITMASTER_CHANNEL_ID:\n+                        return new DecimalType(pm.getChannel());\n+                    case CHANNEL_PITMASTER_PIDPROFILE:\n+                        return new DecimalType(pm.getPid());\n+                    case CHANNEL_PITMASTER_DUTY_CYCLE:\n+                        return new DecimalType(pm.getValue());\n+                    case CHANNEL_PITMASTER_SETPOINT:\n+                        return new QuantityType<>(pm.getSet(), unit);\n+                    case CHANNEL_PITMASTER_STATE:\n+                        return new StringType(pm.getTyp());\n+                }\n+            } else {\n+                return UnDefType.UNDEF;\n+            }\n+        }\n+        throw new WlanThermoUnknownChannelException(channelUID);\n+    }\n+\n+    public static boolean setState(ChannelUID channelUID, Command command, @Nullable Data data) {\n+        if (channelUID.getGroupId() == null || data == null || data.getSystem() == null) {\n+            return false;\n+        }\n+\n+        String groupId = channelUID.getGroupId();\n+        List<Channel> channelList = data.getChannel();\n+        System system = data.getSystem();\n+        Unit<Temperature> unit = \"F\".equals(system.getUnit()) ? ImperialUnits.FAHRENHEIT : SIUnits.CELSIUS;\n+\n+        if (channelUID.getId().startsWith(CHANNEL_PREFIX)) {\n+            int channelId = Integer.parseInt(groupId.substring(CHANNEL_PREFIX.length())) - 1;\n+            if (channelList.size() > 0 && channelId <= channelList.size()) {\n+                Channel channel = channelList.get(channelId);\n+                switch (channelUID.getIdWithoutGroup()) {\n+                    case CHANNEL_NAME:\n+                        if (command instanceof StringType) {\n+                            channel.setName(command.toFullString());\n+                            return true;\n+                        }\n+                    case CHANNEL_MIN:\n+                        if (command instanceof QuantityType) {\n+                            channel.setMin(((QuantityType<?>) command).toUnit(unit).doubleValue());\n+                            return true;\n+                        }\n+                    case CHANNEL_MAX:\n+                        if (command instanceof QuantityType) {\n+                            channel.setMax(((QuantityType<?>) command).toUnit(unit).doubleValue());\n+                            return true;\n+                        }\n+                    case CHANNEL_ALARM_DEVICE:\n+                        if (command instanceof OnOffType) {\n+                            BigInteger value;\n+                            if (command == OnOffType.ON) {\n+                                value = BigInteger.valueOf(channel.getAlarm()).setBit(1);\n+                            } else {\n+                                value = BigInteger.valueOf(channel.getAlarm()).clearBit(1);\n+                            }\n+                            channel.setAlarm(value.intValue());\n+                            return true;\n+                        }\n+                    case CHANNEL_ALARM_PUSH:\n+                        if (command instanceof OnOffType) {\n+                            BigInteger value;\n+                            if (command == OnOffType.ON) {\n+                                value = BigInteger.valueOf(channel.getAlarm()).setBit(0);\n+                            } else {\n+                                value = BigInteger.valueOf(channel.getAlarm()).clearBit(0);\n+                            }\n+                            channel.setAlarm(value.intValue());\n+                            return true;\n+                        }\n+                    case CHANNEL_COLOR_NAME:\n+                        if (command instanceof StringType) {\n+                            channel.setColor(UtilNano.toHex(((StringType) command).toString()));\n+                            return true;\n+                        }\n+                }\n+            }\n+        } else if (channelUID.getId().equals(CHANNEL_PITMASTER_1)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Njg3MzQ4OA=="}, "originalCommit": {"oid": "c1c9ac7f28764809641c2454e814ea14e9f54724"}, "originalPosition": 213}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzcxNTgxMQ==", "bodyText": "True, mixed up group and ID. Fixed.", "url": "https://github.com/openhab/openhab-addons/pull/9579#discussion_r557715811", "createdAt": "2021-01-14T21:40:01Z", "author": {"login": "CSchlipp"}, "path": "bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/api/nano/WlanThermoNanoV1CommandHandler.java", "diffHunk": "@@ -0,0 +1,266 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.wlanthermo.internal.api.nano;\n+\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.*;\n+\n+import java.awt.*;\n+import java.math.BigInteger;\n+import java.util.List;\n+\n+import javax.measure.Unit;\n+import javax.measure.quantity.Temperature;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.wlanthermo.internal.WlanThermoInputException;\n+import org.openhab.binding.wlanthermo.internal.WlanThermoUnknownChannelException;\n+import org.openhab.binding.wlanthermo.internal.api.nano.dto.data.Channel;\n+import org.openhab.binding.wlanthermo.internal.api.nano.dto.data.Data;\n+import org.openhab.binding.wlanthermo.internal.api.nano.dto.data.Pm;\n+import org.openhab.binding.wlanthermo.internal.api.nano.dto.data.System;\n+import org.openhab.binding.wlanthermo.internal.api.nano.dto.settings.Settings;\n+import org.openhab.core.library.types.*;\n+import org.openhab.core.library.unit.ImperialUnits;\n+import org.openhab.core.library.unit.SIUnits;\n+import org.openhab.core.library.unit.Units;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.UnDefType;\n+\n+/**\n+ * The {@link WlanThermoNanoV1CommandHandler} is responsible for mapping the Commands to the respective data fields\n+ * of the API.\n+ *\n+ * @author Christian Schlipp - Initial contribution\n+ */\n+@NonNullByDefault\n+public class WlanThermoNanoV1CommandHandler {\n+\n+    public static State getState(ChannelUID channelUID, @Nullable Data data, @Nullable Settings settings)\n+            throws WlanThermoUnknownChannelException, WlanThermoInputException {\n+        if (channelUID.getGroupId() == null || data == null || settings == null) {\n+            throw new WlanThermoInputException();\n+        }\n+\n+        String groupId = channelUID.getGroupId();\n+        System system = data.getSystem();\n+        Unit<Temperature> unit = \"F\".equals(system.getUnit()) ? ImperialUnits.FAHRENHEIT : SIUnits.CELSIUS;\n+        List<Channel> channelList = data.getChannel();\n+\n+        if (SYSTEM.equals(groupId)) {\n+            switch (channelUID.getIdWithoutGroup()) {\n+                case SYSTEM_SOC:\n+                    return new DecimalType(system.getSoc());\n+                case SYSTEM_CHARGE:\n+                    return OnOffType.from(system.getCharge());\n+                case SYSTEM_RSSI_SIGNALSTRENGTH:\n+                    int dbm = system.getRssi();\n+                    if (dbm >= -80) {\n+                        return SIGNAL_STRENGTH_4;\n+                    } else if (dbm >= -95) {\n+                        return SIGNAL_STRENGTH_3;\n+                    } else if (dbm >= -105) {\n+                        return SIGNAL_STRENGTH_2;\n+                    } else {\n+                        return SIGNAL_STRENGTH_1;\n+                    }\n+                case SYSTEM_RSSI:\n+                    return new QuantityType<>(system.getRssi(), Units.DECIBEL_MILLIWATTS);\n+            }\n+        } else if (channelUID.getId().startsWith(CHANNEL_PREFIX)) {\n+            int channelId = Integer.parseInt(groupId.substring(CHANNEL_PREFIX.length())) - 1;\n+            if (channelList.size() > 0 && channelId <= channelList.size()) {\n+                Channel channel = channelList.get(channelId);\n+                switch (channelUID.getIdWithoutGroup()) {\n+                    case CHANNEL_NAME:\n+                        return new StringType(channel.getName());\n+                    case CHANNEL_TYP:\n+                        return new StringType(settings.sensors.get(channel.getTyp()));\n+                    case CHANNEL_TEMP:\n+                        return channel.getTemp() == 999.0 ? UnDefType.UNDEF\n+                                : new QuantityType<>(channel.getTemp(), unit);\n+                    case CHANNEL_MIN:\n+                        return new QuantityType<>(channel.getMin(), unit);\n+                    case CHANNEL_MAX:\n+                        return new QuantityType<>(channel.getMax(), unit);\n+                    case CHANNEL_ALARM_DEVICE:\n+                        return OnOffType.from(BigInteger.valueOf(channel.getAlarm()).testBit(1));\n+                    case CHANNEL_ALARM_PUSH:\n+                        return OnOffType.from(BigInteger.valueOf(channel.getAlarm()).testBit(0));\n+                    case CHANNEL_ALARM_OPENHAB_HIGH:\n+                        if (channel.getTemp() != 999 && channel.getTemp() > channel.getMax()) {\n+                            return OnOffType.ON;\n+                        } else {\n+                            return OnOffType.OFF;\n+                        }\n+                    case CHANNEL_ALARM_OPENHAB_LOW:\n+                        if (channel.getTemp() != 999 && channel.getTemp() < channel.getMin()) {\n+                            return OnOffType.ON;\n+                        } else {\n+                            return OnOffType.OFF;\n+                        }\n+                    case CHANNEL_COLOR:\n+                        String color = channel.getColor();\n+                        if (color != null && !color.isEmpty()) {\n+                            Color c = Color.decode(color);\n+                            return HSBType.fromRGB(c.getRed(), c.getGreen(), c.getBlue());\n+                        } else {\n+                            return UnDefType.UNDEF;\n+                        }\n+                    case CHANNEL_COLOR_NAME:\n+                        String colorHex = channel.getColor();\n+                        if (colorHex != null && !colorHex.isEmpty()) {\n+                            return new StringType(UtilNano.toColorName(colorHex));\n+                        } else {\n+                            return UnDefType.UNDEF;\n+                        }\n+                }\n+            }\n+        } else if (channelUID.getId().startsWith(CHANNEL_PITMASTER_1)) {\n+            if (data.getPitmaster() != null && data.getPitmaster().getPm() != null\n+                    && data.getPitmaster().getPm().size() > 0) {\n+                Pm pm = data.getPitmaster().getPm().get(0);\n+                switch (channelUID.getIdWithoutGroup()) {\n+                    case CHANNEL_PITMASTER_CHANNEL_ID:\n+                        return new DecimalType(pm.getChannel());\n+                    case CHANNEL_PITMASTER_PIDPROFILE:\n+                        return new DecimalType(pm.getPid());\n+                    case CHANNEL_PITMASTER_DUTY_CYCLE:\n+                        return new DecimalType(pm.getValue());\n+                    case CHANNEL_PITMASTER_SETPOINT:\n+                        return new QuantityType<>(pm.getSet(), unit);\n+                    case CHANNEL_PITMASTER_STATE:\n+                        return new StringType(pm.getTyp());\n+                }\n+            } else {\n+                return UnDefType.UNDEF;\n+            }\n+        }\n+        throw new WlanThermoUnknownChannelException(channelUID);\n+    }\n+\n+    public static boolean setState(ChannelUID channelUID, Command command, @Nullable Data data) {\n+        if (channelUID.getGroupId() == null || data == null || data.getSystem() == null) {\n+            return false;\n+        }\n+\n+        String groupId = channelUID.getGroupId();\n+        List<Channel> channelList = data.getChannel();\n+        System system = data.getSystem();\n+        Unit<Temperature> unit = \"F\".equals(system.getUnit()) ? ImperialUnits.FAHRENHEIT : SIUnits.CELSIUS;\n+\n+        if (channelUID.getId().startsWith(CHANNEL_PREFIX)) {\n+            int channelId = Integer.parseInt(groupId.substring(CHANNEL_PREFIX.length())) - 1;\n+            if (channelList.size() > 0 && channelId <= channelList.size()) {\n+                Channel channel = channelList.get(channelId);\n+                switch (channelUID.getIdWithoutGroup()) {\n+                    case CHANNEL_NAME:\n+                        if (command instanceof StringType) {\n+                            channel.setName(command.toFullString());\n+                            return true;\n+                        }\n+                    case CHANNEL_MIN:\n+                        if (command instanceof QuantityType) {\n+                            channel.setMin(((QuantityType<?>) command).toUnit(unit).doubleValue());\n+                            return true;\n+                        }\n+                    case CHANNEL_MAX:\n+                        if (command instanceof QuantityType) {\n+                            channel.setMax(((QuantityType<?>) command).toUnit(unit).doubleValue());\n+                            return true;\n+                        }\n+                    case CHANNEL_ALARM_DEVICE:\n+                        if (command instanceof OnOffType) {\n+                            BigInteger value;\n+                            if (command == OnOffType.ON) {\n+                                value = BigInteger.valueOf(channel.getAlarm()).setBit(1);\n+                            } else {\n+                                value = BigInteger.valueOf(channel.getAlarm()).clearBit(1);\n+                            }\n+                            channel.setAlarm(value.intValue());\n+                            return true;\n+                        }\n+                    case CHANNEL_ALARM_PUSH:\n+                        if (command instanceof OnOffType) {\n+                            BigInteger value;\n+                            if (command == OnOffType.ON) {\n+                                value = BigInteger.valueOf(channel.getAlarm()).setBit(0);\n+                            } else {\n+                                value = BigInteger.valueOf(channel.getAlarm()).clearBit(0);\n+                            }\n+                            channel.setAlarm(value.intValue());\n+                            return true;\n+                        }\n+                    case CHANNEL_COLOR_NAME:\n+                        if (command instanceof StringType) {\n+                            channel.setColor(UtilNano.toHex(((StringType) command).toString()));\n+                            return true;\n+                        }\n+                }\n+            }\n+        } else if (channelUID.getId().equals(CHANNEL_PITMASTER_1)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Njg3MzQ4OA=="}, "originalCommit": {"oid": "c1c9ac7f28764809641c2454e814ea14e9f54724"}, "originalPosition": 213}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzUwNjAyNjU1OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/api/esp32/WlanThermoEsp32Handler.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xM1QyMTo1ODowNFrOITFGng==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xNVQwNjo1OTowOVrOIUEvaA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Njg3NzQ3MA==", "bodyText": "Why are you changing the properties every time? Thing properties should generally be considered immutable characteristics of the device so you should only need to update it when something changes.", "url": "https://github.com/openhab/openhab-addons/pull/9579#discussion_r556877470", "createdAt": "2021-01-13T21:58:04Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/api/esp32/WlanThermoEsp32Handler.java", "diffHunk": "@@ -0,0 +1,248 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.wlanthermo.internal.api.esp32;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.Map;\n+import java.util.concurrent.*;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.Authentication;\n+import org.eclipse.jetty.client.api.AuthenticationStore;\n+import org.eclipse.jetty.client.util.DigestAuthentication;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants;\n+import org.openhab.binding.wlanthermo.internal.WlanThermoException;\n+import org.openhab.binding.wlanthermo.internal.WlanThermoExtendedConfiguration;\n+import org.openhab.binding.wlanthermo.internal.WlanThermoUnknownChannelException;\n+import org.openhab.binding.wlanthermo.internal.api.esp32.dto.data.Data;\n+import org.openhab.binding.wlanthermo.internal.api.esp32.dto.settings.Settings;\n+import org.openhab.core.thing.*;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+\n+/**\n+ * The {@link WlanThermoEsp32Handler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Christian Schlipp - Initial contribution\n+ */\n+@NonNullByDefault\n+public class WlanThermoEsp32Handler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(WlanThermoEsp32Handler.class);\n+\n+    private WlanThermoExtendedConfiguration config = new WlanThermoExtendedConfiguration();\n+    private final HttpClient httpClient;\n+    private @Nullable ScheduledFuture<?> pollingScheduler;\n+    private final Gson gson = new Gson();\n+    private @Nullable Data data = new Data();\n+    private @Nullable Settings settings = new Settings();\n+\n+    public WlanThermoEsp32Handler(Thing thing, HttpClient httpClient) {\n+        super(thing);\n+        this.httpClient = httpClient;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        config = getConfigAs(WlanThermoExtendedConfiguration.class);\n+\n+        updateStatus(ThingStatus.UNKNOWN);\n+        try {\n+            if (!config.getUsername().isEmpty() && !config.getPassword().isEmpty()) {\n+                AuthenticationStore authStore = httpClient.getAuthenticationStore();\n+                authStore.addAuthentication(new DigestAuthentication(config.getUri(), Authentication.ANY_REALM,\n+                        config.getUsername(), config.getPassword()));\n+            }\n+            pollingScheduler = scheduler.scheduleWithFixedDelay(this::checkConnectionAndUpdate, 0,\n+                    config.getPollingInterval(), TimeUnit.SECONDS);\n+        } catch (URISyntaxException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"Failed to initialize WlanThermo Nano: \" + e.getMessage());\n+        }\n+    }\n+\n+    private void checkConnectionAndUpdate() {\n+        if (this.thing.getStatus() != ThingStatus.ONLINE) {\n+            try {\n+                if (httpClient.GET(config.getUri()).getStatus() == 200) {\n+                    updateStatus(ThingStatus.ONLINE);\n+                    // rerun immediately to update state\n+                    checkConnectionAndUpdate();\n+                } else {\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                            \"WlanThermo not found under given address.\");\n+                }\n+            } catch (URISyntaxException | ExecutionException | TimeoutException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        \"Could not connect to WlanThermo at \" + config.getIpAddress() + \": \" + e.getMessage());\n+            } catch (InterruptedException e) {\n+                logger.debug(\"Connection check interrupted. {}\", e.getMessage());\n+            }\n+        } else {\n+            try {\n+                // Update objects with data from device\n+                String json = httpClient.GET(config.getUri(\"/data\")).getContentAsString();\n+                data = gson.fromJson(json, Data.class);\n+                logger.debug(\"Received at /data: {}\", json);\n+                json = httpClient.GET(config.getUri(\"/settings\")).getContentAsString();\n+                settings = gson.fromJson(json, Settings.class);\n+                logger.debug(\"Received at /settings: {}\", json);\n+\n+                if (data == null || settings == null) {\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                            \"Failed to parse Data and/or Settings values!\");\n+                    return;\n+                }\n+\n+                // Update Channels if required\n+                Map<String, String> properties = editProperties();\n+                Boolean pmEnabled = settings.getFeatures().getBluetooth();\n+                int pmChannels = pmEnabled ? data.getPitmaster().getPm().size() : 0;\n+                int tempChannels = data.getChannel().size();\n+\n+                // Update properties\n+                properties.put(WlanThermoBindingConstants.PROPERTY_MODEL, settings.getDevice().getDevice());\n+                properties.put(WlanThermoBindingConstants.PROPERTY_SERIAL, settings.getDevice().getSerial());\n+                properties.put(WlanThermoBindingConstants.PROPERTY_ESP32_BT_ENABLED,\n+                        settings.getFeatures().getBluetooth().toString());\n+                properties.put(WlanThermoBindingConstants.PROPERTY_ESP32_PM_ENABLED, pmEnabled.toString());\n+                properties.put(WlanThermoBindingConstants.PROPERTY_ESP32_TEMP_CHANNELS, String.valueOf(tempChannels));\n+                properties.put(WlanThermoBindingConstants.PROPERTY_ESP32_PM_CHANNELS, String.valueOf(pmChannels));\n+                updateProperties(properties);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c1c9ac7f28764809641c2454e814ea14e9f54724"}, "originalPosition": 133}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzA4MjgzMA==", "bodyText": "The number of temperature and pitmaster channels might change during operation as the user attaches bluetooth sensors.\nOn the one hand, I do understand that properties should usually be immutable, but on the other hand I don't think that having the number of attached sensors is worth an own channel.\nI've changed the code so that only the channel number properties are updated, is that okay for you?", "url": "https://github.com/openhab/openhab-addons/pull/9579#discussion_r557082830", "createdAt": "2021-01-14T07:05:44Z", "author": {"login": "CSchlipp"}, "path": "bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/api/esp32/WlanThermoEsp32Handler.java", "diffHunk": "@@ -0,0 +1,248 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.wlanthermo.internal.api.esp32;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.Map;\n+import java.util.concurrent.*;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.Authentication;\n+import org.eclipse.jetty.client.api.AuthenticationStore;\n+import org.eclipse.jetty.client.util.DigestAuthentication;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants;\n+import org.openhab.binding.wlanthermo.internal.WlanThermoException;\n+import org.openhab.binding.wlanthermo.internal.WlanThermoExtendedConfiguration;\n+import org.openhab.binding.wlanthermo.internal.WlanThermoUnknownChannelException;\n+import org.openhab.binding.wlanthermo.internal.api.esp32.dto.data.Data;\n+import org.openhab.binding.wlanthermo.internal.api.esp32.dto.settings.Settings;\n+import org.openhab.core.thing.*;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+\n+/**\n+ * The {@link WlanThermoEsp32Handler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Christian Schlipp - Initial contribution\n+ */\n+@NonNullByDefault\n+public class WlanThermoEsp32Handler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(WlanThermoEsp32Handler.class);\n+\n+    private WlanThermoExtendedConfiguration config = new WlanThermoExtendedConfiguration();\n+    private final HttpClient httpClient;\n+    private @Nullable ScheduledFuture<?> pollingScheduler;\n+    private final Gson gson = new Gson();\n+    private @Nullable Data data = new Data();\n+    private @Nullable Settings settings = new Settings();\n+\n+    public WlanThermoEsp32Handler(Thing thing, HttpClient httpClient) {\n+        super(thing);\n+        this.httpClient = httpClient;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        config = getConfigAs(WlanThermoExtendedConfiguration.class);\n+\n+        updateStatus(ThingStatus.UNKNOWN);\n+        try {\n+            if (!config.getUsername().isEmpty() && !config.getPassword().isEmpty()) {\n+                AuthenticationStore authStore = httpClient.getAuthenticationStore();\n+                authStore.addAuthentication(new DigestAuthentication(config.getUri(), Authentication.ANY_REALM,\n+                        config.getUsername(), config.getPassword()));\n+            }\n+            pollingScheduler = scheduler.scheduleWithFixedDelay(this::checkConnectionAndUpdate, 0,\n+                    config.getPollingInterval(), TimeUnit.SECONDS);\n+        } catch (URISyntaxException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"Failed to initialize WlanThermo Nano: \" + e.getMessage());\n+        }\n+    }\n+\n+    private void checkConnectionAndUpdate() {\n+        if (this.thing.getStatus() != ThingStatus.ONLINE) {\n+            try {\n+                if (httpClient.GET(config.getUri()).getStatus() == 200) {\n+                    updateStatus(ThingStatus.ONLINE);\n+                    // rerun immediately to update state\n+                    checkConnectionAndUpdate();\n+                } else {\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                            \"WlanThermo not found under given address.\");\n+                }\n+            } catch (URISyntaxException | ExecutionException | TimeoutException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        \"Could not connect to WlanThermo at \" + config.getIpAddress() + \": \" + e.getMessage());\n+            } catch (InterruptedException e) {\n+                logger.debug(\"Connection check interrupted. {}\", e.getMessage());\n+            }\n+        } else {\n+            try {\n+                // Update objects with data from device\n+                String json = httpClient.GET(config.getUri(\"/data\")).getContentAsString();\n+                data = gson.fromJson(json, Data.class);\n+                logger.debug(\"Received at /data: {}\", json);\n+                json = httpClient.GET(config.getUri(\"/settings\")).getContentAsString();\n+                settings = gson.fromJson(json, Settings.class);\n+                logger.debug(\"Received at /settings: {}\", json);\n+\n+                if (data == null || settings == null) {\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                            \"Failed to parse Data and/or Settings values!\");\n+                    return;\n+                }\n+\n+                // Update Channels if required\n+                Map<String, String> properties = editProperties();\n+                Boolean pmEnabled = settings.getFeatures().getBluetooth();\n+                int pmChannels = pmEnabled ? data.getPitmaster().getPm().size() : 0;\n+                int tempChannels = data.getChannel().size();\n+\n+                // Update properties\n+                properties.put(WlanThermoBindingConstants.PROPERTY_MODEL, settings.getDevice().getDevice());\n+                properties.put(WlanThermoBindingConstants.PROPERTY_SERIAL, settings.getDevice().getSerial());\n+                properties.put(WlanThermoBindingConstants.PROPERTY_ESP32_BT_ENABLED,\n+                        settings.getFeatures().getBluetooth().toString());\n+                properties.put(WlanThermoBindingConstants.PROPERTY_ESP32_PM_ENABLED, pmEnabled.toString());\n+                properties.put(WlanThermoBindingConstants.PROPERTY_ESP32_TEMP_CHANNELS, String.valueOf(tempChannels));\n+                properties.put(WlanThermoBindingConstants.PROPERTY_ESP32_PM_CHANNELS, String.valueOf(pmChannels));\n+                updateProperties(properties);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Njg3NzQ3MA=="}, "originalCommit": {"oid": "c1c9ac7f28764809641c2454e814ea14e9f54724"}, "originalPosition": 133}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzkyMDEwNA==", "bodyText": "It wasn't really what I had in mind but it doesn't really sound like you can avoid updating the properties. So I guess this is fine.", "url": "https://github.com/openhab/openhab-addons/pull/9579#discussion_r557920104", "createdAt": "2021-01-15T06:59:09Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/api/esp32/WlanThermoEsp32Handler.java", "diffHunk": "@@ -0,0 +1,248 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.wlanthermo.internal.api.esp32;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.Map;\n+import java.util.concurrent.*;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.Authentication;\n+import org.eclipse.jetty.client.api.AuthenticationStore;\n+import org.eclipse.jetty.client.util.DigestAuthentication;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants;\n+import org.openhab.binding.wlanthermo.internal.WlanThermoException;\n+import org.openhab.binding.wlanthermo.internal.WlanThermoExtendedConfiguration;\n+import org.openhab.binding.wlanthermo.internal.WlanThermoUnknownChannelException;\n+import org.openhab.binding.wlanthermo.internal.api.esp32.dto.data.Data;\n+import org.openhab.binding.wlanthermo.internal.api.esp32.dto.settings.Settings;\n+import org.openhab.core.thing.*;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+\n+/**\n+ * The {@link WlanThermoEsp32Handler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Christian Schlipp - Initial contribution\n+ */\n+@NonNullByDefault\n+public class WlanThermoEsp32Handler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(WlanThermoEsp32Handler.class);\n+\n+    private WlanThermoExtendedConfiguration config = new WlanThermoExtendedConfiguration();\n+    private final HttpClient httpClient;\n+    private @Nullable ScheduledFuture<?> pollingScheduler;\n+    private final Gson gson = new Gson();\n+    private @Nullable Data data = new Data();\n+    private @Nullable Settings settings = new Settings();\n+\n+    public WlanThermoEsp32Handler(Thing thing, HttpClient httpClient) {\n+        super(thing);\n+        this.httpClient = httpClient;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        config = getConfigAs(WlanThermoExtendedConfiguration.class);\n+\n+        updateStatus(ThingStatus.UNKNOWN);\n+        try {\n+            if (!config.getUsername().isEmpty() && !config.getPassword().isEmpty()) {\n+                AuthenticationStore authStore = httpClient.getAuthenticationStore();\n+                authStore.addAuthentication(new DigestAuthentication(config.getUri(), Authentication.ANY_REALM,\n+                        config.getUsername(), config.getPassword()));\n+            }\n+            pollingScheduler = scheduler.scheduleWithFixedDelay(this::checkConnectionAndUpdate, 0,\n+                    config.getPollingInterval(), TimeUnit.SECONDS);\n+        } catch (URISyntaxException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"Failed to initialize WlanThermo Nano: \" + e.getMessage());\n+        }\n+    }\n+\n+    private void checkConnectionAndUpdate() {\n+        if (this.thing.getStatus() != ThingStatus.ONLINE) {\n+            try {\n+                if (httpClient.GET(config.getUri()).getStatus() == 200) {\n+                    updateStatus(ThingStatus.ONLINE);\n+                    // rerun immediately to update state\n+                    checkConnectionAndUpdate();\n+                } else {\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                            \"WlanThermo not found under given address.\");\n+                }\n+            } catch (URISyntaxException | ExecutionException | TimeoutException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        \"Could not connect to WlanThermo at \" + config.getIpAddress() + \": \" + e.getMessage());\n+            } catch (InterruptedException e) {\n+                logger.debug(\"Connection check interrupted. {}\", e.getMessage());\n+            }\n+        } else {\n+            try {\n+                // Update objects with data from device\n+                String json = httpClient.GET(config.getUri(\"/data\")).getContentAsString();\n+                data = gson.fromJson(json, Data.class);\n+                logger.debug(\"Received at /data: {}\", json);\n+                json = httpClient.GET(config.getUri(\"/settings\")).getContentAsString();\n+                settings = gson.fromJson(json, Settings.class);\n+                logger.debug(\"Received at /settings: {}\", json);\n+\n+                if (data == null || settings == null) {\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                            \"Failed to parse Data and/or Settings values!\");\n+                    return;\n+                }\n+\n+                // Update Channels if required\n+                Map<String, String> properties = editProperties();\n+                Boolean pmEnabled = settings.getFeatures().getBluetooth();\n+                int pmChannels = pmEnabled ? data.getPitmaster().getPm().size() : 0;\n+                int tempChannels = data.getChannel().size();\n+\n+                // Update properties\n+                properties.put(WlanThermoBindingConstants.PROPERTY_MODEL, settings.getDevice().getDevice());\n+                properties.put(WlanThermoBindingConstants.PROPERTY_SERIAL, settings.getDevice().getSerial());\n+                properties.put(WlanThermoBindingConstants.PROPERTY_ESP32_BT_ENABLED,\n+                        settings.getFeatures().getBluetooth().toString());\n+                properties.put(WlanThermoBindingConstants.PROPERTY_ESP32_PM_ENABLED, pmEnabled.toString());\n+                properties.put(WlanThermoBindingConstants.PROPERTY_ESP32_TEMP_CHANNELS, String.valueOf(tempChannels));\n+                properties.put(WlanThermoBindingConstants.PROPERTY_ESP32_PM_CHANNELS, String.valueOf(pmChannels));\n+                updateProperties(properties);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Njg3NzQ3MA=="}, "originalCommit": {"oid": "c1c9ac7f28764809641c2454e814ea14e9f54724"}, "originalPosition": 133}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzUxMTI4MjUxOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/api/nano/WlanThermoNanoV1Handler.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xNFQyMTozNzozNVrOIT4MgA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xNFQyMjowNTowNFrOIT5DHQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzcxNDU2MA==", "bodyText": "This code is nearly identical to the code right above it. Please consider refactoring this into a separate method.", "url": "https://github.com/openhab/openhab-addons/pull/9579#discussion_r557714560", "createdAt": "2021-01-14T21:37:35Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/api/nano/WlanThermoNanoV1Handler.java", "diffHunk": "@@ -0,0 +1,229 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.wlanthermo.internal.api.nano;\n+\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.TRIGGER_NONE;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.concurrent.*;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.Authentication;\n+import org.eclipse.jetty.client.api.AuthenticationStore;\n+import org.eclipse.jetty.client.util.DigestAuthentication;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.openhab.binding.wlanthermo.internal.WlanThermoException;\n+import org.openhab.binding.wlanthermo.internal.WlanThermoExtendedConfiguration;\n+import org.openhab.binding.wlanthermo.internal.WlanThermoUnknownChannelException;\n+import org.openhab.binding.wlanthermo.internal.api.nano.dto.data.Data;\n+import org.openhab.binding.wlanthermo.internal.api.nano.dto.settings.Settings;\n+import org.openhab.core.thing.*;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+\n+/**\n+ * The {@link WlanThermoNanoV1Handler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Christian Schlipp - Initial contribution\n+ */\n+@NonNullByDefault\n+public class WlanThermoNanoV1Handler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(WlanThermoNanoV1Handler.class);\n+\n+    private WlanThermoExtendedConfiguration config = new WlanThermoExtendedConfiguration();\n+    private final HttpClient httpClient;\n+    private @Nullable ScheduledFuture<?> pollingScheduler;\n+    private final Gson gson = new Gson();\n+    private @Nullable Data data = new Data();\n+    private @Nullable Settings settings = new Settings();\n+\n+    public WlanThermoNanoV1Handler(Thing thing, HttpClient httpClient) {\n+        super(thing);\n+        this.httpClient = httpClient;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        config = getConfigAs(WlanThermoExtendedConfiguration.class);\n+\n+        updateStatus(ThingStatus.UNKNOWN);\n+        try {\n+            if (!config.getUsername().isEmpty() && !config.getPassword().isEmpty()) {\n+                AuthenticationStore authStore = httpClient.getAuthenticationStore();\n+                authStore.addAuthentication(new DigestAuthentication(config.getUri(), Authentication.ANY_REALM,\n+                        config.getUsername(), config.getPassword()));\n+            }\n+            pollingScheduler = scheduler.scheduleWithFixedDelay(this::checkConnectionAndUpdate, 0,\n+                    config.getPollingInterval(), TimeUnit.SECONDS);\n+        } catch (URISyntaxException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"Failed to initialize WlanThermo Nano: \" + e.getMessage());\n+        }\n+    }\n+\n+    private void checkConnectionAndUpdate() {\n+        if (this.thing.getStatus() != ThingStatus.ONLINE) {\n+            try {\n+                if (httpClient.GET(config.getUri()).getStatus() == 200) {\n+                    updateStatus(ThingStatus.ONLINE);\n+                    // rerun immediately to update state\n+                    checkConnectionAndUpdate();\n+                } else {\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                            \"WlanThermo not found under given address.\");\n+                }\n+            } catch (URISyntaxException | ExecutionException | TimeoutException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        \"Could not connect to WlanThermo at \" + config.getIpAddress() + \": \" + e.getMessage());\n+            } catch (InterruptedException e) {\n+                logger.debug(\"Connection check interrupted. {}\", e.getMessage());\n+            }\n+        } else {\n+            try {\n+                // Update objects with data from device\n+                String json = httpClient.GET(config.getUri(\"/data\")).getContentAsString();\n+                data = gson.fromJson(json, Data.class);\n+                logger.debug(\"Received at /data: {}\", json);\n+                json = httpClient.GET(config.getUri(\"/settings\")).getContentAsString();\n+                settings = gson.fromJson(json, Settings.class);\n+                logger.debug(\"Received at /settings: {}\", json);\n+\n+                // Update channels\n+                for (Channel channel : thing.getChannels()) {\n+                    try {\n+                        State state = WlanThermoNanoV1CommandHandler.getState(channel.getUID(), data, settings);\n+                        updateState(channel.getUID(), state);\n+                    } catch (WlanThermoUnknownChannelException e) {\n+                        // if we could not obtain a state, try trigger instead\n+                        try {\n+                            String trigger = WlanThermoNanoV1CommandHandler.getTrigger(channel.getUID(), data);\n+                            if (!trigger.equals(TRIGGER_NONE)) {\n+                                triggerChannel(channel.getUID(), trigger);\n+                            }\n+                        } catch (WlanThermoUnknownChannelException e1) {\n+                            logger.debug(\"{}\", e.getMessage());\n+                        }\n+                    }\n+                }\n+            } catch (URISyntaxException | ExecutionException | TimeoutException | WlanThermoException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        \"Update failed: \" + e.getMessage());\n+                for (Channel channel : thing.getChannels()) {\n+                    updateState(channel.getUID(), UnDefType.UNDEF);\n+                }\n+            } catch (InterruptedException e) {\n+                logger.debug(\"Update interrupted. {}\", e.getMessage());\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            try {\n+                State s = WlanThermoNanoV1CommandHandler.getState(channelUID, data, settings);\n+                updateState(channelUID, s);\n+            } catch (WlanThermoException e) {\n+                logger.debug(\"Could not handle command of type {} for channel {}!\",\n+                        command.getClass().toGenericString(), channelUID.getId());\n+            }\n+        } else {\n+            if (WlanThermoNanoV1CommandHandler.setState(channelUID, command, data)) {\n+                logger.debug(\"Data updated, pushing changes\");\n+                scheduler.execute(this::push);\n+            } else {\n+                logger.debug(\"Could not handle command of type {} for channel {}!\",\n+                        command.getClass().toGenericString(), channelUID.getId());\n+            }\n+        }\n+    }\n+\n+    private void push() {\n+        if (data == null || this.thing.getStatus() != ThingStatus.ONLINE) {\n+            return;\n+        }\n+\n+        // push update for sensor channels\n+        for (org.openhab.binding.wlanthermo.internal.api.nano.dto.data.Channel c : data.getChannel()) {\n+            try {\n+                String json = gson.toJson(c);\n+                URI uri = config.getUri(\"/setchannels\");\n+                int status = httpClient.POST(uri).content(new StringContentProvider(json), \"application/json\")\n+                        .timeout(5, TimeUnit.SECONDS).send().getStatus();\n+                if (status == 401) {\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                            \"No or wrong login credentials provided. Please configure username/password for write access to WlanThermo!\");\n+                    break;\n+                } else if (status != 200) {\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, \"Failed to update channel \"\n+                            + c.getName() + \" on device, Statuscode \" + status + \" on URI \" + uri.toString());\n+                    logger.debug(\"Payload sent: {}\", json);\n+                } else {\n+                    updateStatus(ThingStatus.ONLINE);\n+                }\n+            } catch (TimeoutException | ExecutionException | URISyntaxException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        \"Failed to update channel \" + c.getName() + \" on device: \" + e.getMessage());\n+            } catch (InterruptedException e) {\n+                logger.debug(\"Push interrupted. {}\", e.getMessage());\n+                return;\n+            }\n+        }\n+\n+        // push update for pitmaster channels\n+        try {\n+            String json = gson.toJson(data.getPitmaster().getPm());\n+            URI uri = config.getUri(\"/setpitmaster\");\n+            int status = httpClient.POST(uri).content(new StringContentProvider(json), \"application/json\")\n+                    .timeout(5, TimeUnit.SECONDS).send().getStatus();\n+            if (status == 401) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        \"No or wrong login credentials provided. Please configure username/password for write access to WlanThermo!\");\n+            } else if (status != 200) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        \"Failed to update pitmaster channel on device, Statuscode \" + status + \" on URI \"\n+                                + uri.toString());\n+                logger.debug(\"Payload sent: {}\", json);\n+            } else {\n+                updateStatus(ThingStatus.ONLINE);\n+            }\n+        } catch (TimeoutException | ExecutionException | URISyntaxException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                    \"Failed to update pitmaster channel on device: \" + e.getMessage());\n+        } catch (InterruptedException e) {\n+            logger.debug(\"Push interrupted. {}\", e.getMessage());\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0aaff6395abedf04f6d586a4729d8f0782e98239"}, "originalPosition": 217}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzcyODU0MQ==", "bodyText": "Done", "url": "https://github.com/openhab/openhab-addons/pull/9579#discussion_r557728541", "createdAt": "2021-01-14T22:05:04Z", "author": {"login": "CSchlipp"}, "path": "bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/api/nano/WlanThermoNanoV1Handler.java", "diffHunk": "@@ -0,0 +1,229 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.wlanthermo.internal.api.nano;\n+\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.TRIGGER_NONE;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.concurrent.*;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.Authentication;\n+import org.eclipse.jetty.client.api.AuthenticationStore;\n+import org.eclipse.jetty.client.util.DigestAuthentication;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.openhab.binding.wlanthermo.internal.WlanThermoException;\n+import org.openhab.binding.wlanthermo.internal.WlanThermoExtendedConfiguration;\n+import org.openhab.binding.wlanthermo.internal.WlanThermoUnknownChannelException;\n+import org.openhab.binding.wlanthermo.internal.api.nano.dto.data.Data;\n+import org.openhab.binding.wlanthermo.internal.api.nano.dto.settings.Settings;\n+import org.openhab.core.thing.*;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+\n+/**\n+ * The {@link WlanThermoNanoV1Handler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Christian Schlipp - Initial contribution\n+ */\n+@NonNullByDefault\n+public class WlanThermoNanoV1Handler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(WlanThermoNanoV1Handler.class);\n+\n+    private WlanThermoExtendedConfiguration config = new WlanThermoExtendedConfiguration();\n+    private final HttpClient httpClient;\n+    private @Nullable ScheduledFuture<?> pollingScheduler;\n+    private final Gson gson = new Gson();\n+    private @Nullable Data data = new Data();\n+    private @Nullable Settings settings = new Settings();\n+\n+    public WlanThermoNanoV1Handler(Thing thing, HttpClient httpClient) {\n+        super(thing);\n+        this.httpClient = httpClient;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        config = getConfigAs(WlanThermoExtendedConfiguration.class);\n+\n+        updateStatus(ThingStatus.UNKNOWN);\n+        try {\n+            if (!config.getUsername().isEmpty() && !config.getPassword().isEmpty()) {\n+                AuthenticationStore authStore = httpClient.getAuthenticationStore();\n+                authStore.addAuthentication(new DigestAuthentication(config.getUri(), Authentication.ANY_REALM,\n+                        config.getUsername(), config.getPassword()));\n+            }\n+            pollingScheduler = scheduler.scheduleWithFixedDelay(this::checkConnectionAndUpdate, 0,\n+                    config.getPollingInterval(), TimeUnit.SECONDS);\n+        } catch (URISyntaxException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"Failed to initialize WlanThermo Nano: \" + e.getMessage());\n+        }\n+    }\n+\n+    private void checkConnectionAndUpdate() {\n+        if (this.thing.getStatus() != ThingStatus.ONLINE) {\n+            try {\n+                if (httpClient.GET(config.getUri()).getStatus() == 200) {\n+                    updateStatus(ThingStatus.ONLINE);\n+                    // rerun immediately to update state\n+                    checkConnectionAndUpdate();\n+                } else {\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                            \"WlanThermo not found under given address.\");\n+                }\n+            } catch (URISyntaxException | ExecutionException | TimeoutException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        \"Could not connect to WlanThermo at \" + config.getIpAddress() + \": \" + e.getMessage());\n+            } catch (InterruptedException e) {\n+                logger.debug(\"Connection check interrupted. {}\", e.getMessage());\n+            }\n+        } else {\n+            try {\n+                // Update objects with data from device\n+                String json = httpClient.GET(config.getUri(\"/data\")).getContentAsString();\n+                data = gson.fromJson(json, Data.class);\n+                logger.debug(\"Received at /data: {}\", json);\n+                json = httpClient.GET(config.getUri(\"/settings\")).getContentAsString();\n+                settings = gson.fromJson(json, Settings.class);\n+                logger.debug(\"Received at /settings: {}\", json);\n+\n+                // Update channels\n+                for (Channel channel : thing.getChannels()) {\n+                    try {\n+                        State state = WlanThermoNanoV1CommandHandler.getState(channel.getUID(), data, settings);\n+                        updateState(channel.getUID(), state);\n+                    } catch (WlanThermoUnknownChannelException e) {\n+                        // if we could not obtain a state, try trigger instead\n+                        try {\n+                            String trigger = WlanThermoNanoV1CommandHandler.getTrigger(channel.getUID(), data);\n+                            if (!trigger.equals(TRIGGER_NONE)) {\n+                                triggerChannel(channel.getUID(), trigger);\n+                            }\n+                        } catch (WlanThermoUnknownChannelException e1) {\n+                            logger.debug(\"{}\", e.getMessage());\n+                        }\n+                    }\n+                }\n+            } catch (URISyntaxException | ExecutionException | TimeoutException | WlanThermoException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        \"Update failed: \" + e.getMessage());\n+                for (Channel channel : thing.getChannels()) {\n+                    updateState(channel.getUID(), UnDefType.UNDEF);\n+                }\n+            } catch (InterruptedException e) {\n+                logger.debug(\"Update interrupted. {}\", e.getMessage());\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            try {\n+                State s = WlanThermoNanoV1CommandHandler.getState(channelUID, data, settings);\n+                updateState(channelUID, s);\n+            } catch (WlanThermoException e) {\n+                logger.debug(\"Could not handle command of type {} for channel {}!\",\n+                        command.getClass().toGenericString(), channelUID.getId());\n+            }\n+        } else {\n+            if (WlanThermoNanoV1CommandHandler.setState(channelUID, command, data)) {\n+                logger.debug(\"Data updated, pushing changes\");\n+                scheduler.execute(this::push);\n+            } else {\n+                logger.debug(\"Could not handle command of type {} for channel {}!\",\n+                        command.getClass().toGenericString(), channelUID.getId());\n+            }\n+        }\n+    }\n+\n+    private void push() {\n+        if (data == null || this.thing.getStatus() != ThingStatus.ONLINE) {\n+            return;\n+        }\n+\n+        // push update for sensor channels\n+        for (org.openhab.binding.wlanthermo.internal.api.nano.dto.data.Channel c : data.getChannel()) {\n+            try {\n+                String json = gson.toJson(c);\n+                URI uri = config.getUri(\"/setchannels\");\n+                int status = httpClient.POST(uri).content(new StringContentProvider(json), \"application/json\")\n+                        .timeout(5, TimeUnit.SECONDS).send().getStatus();\n+                if (status == 401) {\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                            \"No or wrong login credentials provided. Please configure username/password for write access to WlanThermo!\");\n+                    break;\n+                } else if (status != 200) {\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, \"Failed to update channel \"\n+                            + c.getName() + \" on device, Statuscode \" + status + \" on URI \" + uri.toString());\n+                    logger.debug(\"Payload sent: {}\", json);\n+                } else {\n+                    updateStatus(ThingStatus.ONLINE);\n+                }\n+            } catch (TimeoutException | ExecutionException | URISyntaxException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        \"Failed to update channel \" + c.getName() + \" on device: \" + e.getMessage());\n+            } catch (InterruptedException e) {\n+                logger.debug(\"Push interrupted. {}\", e.getMessage());\n+                return;\n+            }\n+        }\n+\n+        // push update for pitmaster channels\n+        try {\n+            String json = gson.toJson(data.getPitmaster().getPm());\n+            URI uri = config.getUri(\"/setpitmaster\");\n+            int status = httpClient.POST(uri).content(new StringContentProvider(json), \"application/json\")\n+                    .timeout(5, TimeUnit.SECONDS).send().getStatus();\n+            if (status == 401) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        \"No or wrong login credentials provided. Please configure username/password for write access to WlanThermo!\");\n+            } else if (status != 200) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        \"Failed to update pitmaster channel on device, Statuscode \" + status + \" on URI \"\n+                                + uri.toString());\n+                logger.debug(\"Payload sent: {}\", json);\n+            } else {\n+                updateStatus(ThingStatus.ONLINE);\n+            }\n+        } catch (TimeoutException | ExecutionException | URISyntaxException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                    \"Failed to update pitmaster channel on device: \" + e.getMessage());\n+        } catch (InterruptedException e) {\n+            logger.debug(\"Push interrupted. {}\", e.getMessage());\n+        }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzcxNDU2MA=="}, "originalCommit": {"oid": "0aaff6395abedf04f6d586a4729d8f0782e98239"}, "originalPosition": 217}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzUxMTMwMjcwOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/api/esp32/WlanThermoEsp32Handler.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xNFQyMTo0NDowMFrOIT4ZIw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xNFQyMTo0NDowMFrOIT4ZIw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzcxNzc5NQ==", "bodyText": "Same suggestion here.", "url": "https://github.com/openhab/openhab-addons/pull/9579#discussion_r557717795", "createdAt": "2021-01-14T21:44:00Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/api/esp32/WlanThermoEsp32Handler.java", "diffHunk": "@@ -0,0 +1,253 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.wlanthermo.internal.api.esp32;\n+\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.TRIGGER_NONE;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.Map;\n+import java.util.concurrent.*;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.Authentication;\n+import org.eclipse.jetty.client.api.AuthenticationStore;\n+import org.eclipse.jetty.client.util.DigestAuthentication;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants;\n+import org.openhab.binding.wlanthermo.internal.WlanThermoException;\n+import org.openhab.binding.wlanthermo.internal.WlanThermoExtendedConfiguration;\n+import org.openhab.binding.wlanthermo.internal.WlanThermoUnknownChannelException;\n+import org.openhab.binding.wlanthermo.internal.api.esp32.dto.data.Data;\n+import org.openhab.binding.wlanthermo.internal.api.esp32.dto.settings.Settings;\n+import org.openhab.core.thing.*;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+\n+/**\n+ * The {@link WlanThermoEsp32Handler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Christian Schlipp - Initial contribution\n+ */\n+@NonNullByDefault\n+public class WlanThermoEsp32Handler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(WlanThermoEsp32Handler.class);\n+\n+    private WlanThermoExtendedConfiguration config = new WlanThermoExtendedConfiguration();\n+    private final HttpClient httpClient;\n+    private @Nullable ScheduledFuture<?> pollingScheduler;\n+    private final Gson gson = new Gson();\n+    private @Nullable Data data = new Data();\n+    private @Nullable Settings settings = new Settings();\n+\n+    public WlanThermoEsp32Handler(Thing thing, HttpClient httpClient) {\n+        super(thing);\n+        this.httpClient = httpClient;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        config = getConfigAs(WlanThermoExtendedConfiguration.class);\n+\n+        updateStatus(ThingStatus.UNKNOWN);\n+        try {\n+            if (!config.getUsername().isEmpty() && !config.getPassword().isEmpty()) {\n+                AuthenticationStore authStore = httpClient.getAuthenticationStore();\n+                authStore.addAuthentication(new DigestAuthentication(config.getUri(), Authentication.ANY_REALM,\n+                        config.getUsername(), config.getPassword()));\n+            }\n+            pollingScheduler = scheduler.scheduleWithFixedDelay(this::checkConnectionAndUpdate, 0,\n+                    config.getPollingInterval(), TimeUnit.SECONDS);\n+        } catch (URISyntaxException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"Failed to initialize WlanThermo Nano: \" + e.getMessage());\n+        }\n+    }\n+\n+    private void checkConnectionAndUpdate() {\n+        if (this.thing.getStatus() != ThingStatus.ONLINE) {\n+            try {\n+                if (httpClient.GET(config.getUri()).getStatus() == 200) {\n+                    updateStatus(ThingStatus.ONLINE);\n+                    // rerun immediately to update state\n+                    checkConnectionAndUpdate();\n+                } else {\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                            \"WlanThermo not found under given address.\");\n+                }\n+            } catch (URISyntaxException | ExecutionException | TimeoutException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        \"Could not connect to WlanThermo at \" + config.getIpAddress() + \": \" + e.getMessage());\n+            } catch (InterruptedException e) {\n+                logger.debug(\"Connection check interrupted. {}\", e.getMessage());\n+            }\n+        } else {\n+            try {\n+                // Update objects with data from device\n+                String json = httpClient.GET(config.getUri(\"/data\")).getContentAsString();\n+                data = gson.fromJson(json, Data.class);\n+                logger.debug(\"Received at /data: {}\", json);\n+                json = httpClient.GET(config.getUri(\"/settings\")).getContentAsString();\n+                settings = gson.fromJson(json, Settings.class);\n+                logger.debug(\"Received at /settings: {}\", json);\n+\n+                if (data == null || settings == null) {\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                            \"Failed to parse Data and/or Settings values!\");\n+                    return;\n+                }\n+\n+                // Update Channels if required\n+                Map<String, String> properties = editProperties();\n+                Boolean pmEnabled = settings.getFeatures().getBluetooth();\n+                int pmChannels = pmEnabled ? data.getPitmaster().getPm().size() : 0;\n+                int tempChannels = data.getChannel().size();\n+\n+                // Update properties\n+                properties.putIfAbsent(WlanThermoBindingConstants.PROPERTY_MODEL, settings.getDevice().getDevice());\n+                properties.putIfAbsent(WlanThermoBindingConstants.PROPERTY_SERIAL, settings.getDevice().getSerial());\n+                properties.putIfAbsent(WlanThermoBindingConstants.PROPERTY_ESP32_BT_ENABLED,\n+                        settings.getFeatures().getBluetooth().toString());\n+                properties.putIfAbsent(WlanThermoBindingConstants.PROPERTY_ESP32_PM_ENABLED, pmEnabled.toString());\n+                properties.put(WlanThermoBindingConstants.PROPERTY_ESP32_TEMP_CHANNELS, String.valueOf(tempChannels));\n+                properties.put(WlanThermoBindingConstants.PROPERTY_ESP32_PM_CHANNELS, String.valueOf(pmChannels));\n+                updateProperties(properties);\n+\n+                // Update channel state\n+                for (Channel channel : thing.getChannels()) {\n+                    try {\n+                        State state = WlanThermoEsp32CommandHandler.getState(channel.getUID(), data, settings);\n+                        updateState(channel.getUID(), state);\n+                    } catch (WlanThermoUnknownChannelException e) {\n+                        // if we could not obtain a state, try trigger instead\n+                        try {\n+                            String trigger = WlanThermoEsp32CommandHandler.getTrigger(channel.getUID(), data);\n+                            if (!trigger.equals(TRIGGER_NONE)) {\n+                                triggerChannel(channel.getUID(), trigger);\n+                            }\n+                        } catch (WlanThermoUnknownChannelException e1) {\n+                            logger.debug(\"{}\", e.getMessage());\n+                        }\n+                    }\n+                }\n+            } catch (URISyntaxException | ExecutionException | TimeoutException | WlanThermoException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        \"Update failed: \" + e.getMessage());\n+                for (Channel channel : thing.getChannels()) {\n+                    updateState(channel.getUID(), UnDefType.UNDEF);\n+                }\n+            } catch (InterruptedException e) {\n+                logger.debug(\"Update interrupted. {}\", e.getMessage());\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            try {\n+                State s = WlanThermoEsp32CommandHandler.getState(channelUID, data, settings);\n+                updateState(channelUID, s);\n+            } catch (WlanThermoException e) {\n+                logger.debug(\"Could not handle command of type {} for channel {}!\",\n+                        command.getClass().toGenericString(), channelUID.getId());\n+            }\n+        } else {\n+            if (WlanThermoEsp32CommandHandler.setState(channelUID, command, data)) {\n+                logger.debug(\"Data updated, pushing changes\");\n+                scheduler.execute(this::push);\n+            } else {\n+                logger.debug(\"Could not handle command of type {} for channel {}!\",\n+                        command.getClass().toGenericString(), channelUID.getId());\n+            }\n+        }\n+    }\n+\n+    private void push() {\n+        if (data == null || this.thing.getStatus() != ThingStatus.ONLINE) {\n+            return;\n+        }\n+\n+        // Push update for sensor channels\n+        for (org.openhab.binding.wlanthermo.internal.api.esp32.dto.data.Channel c : data.getChannel()) {\n+            try {\n+                String json = gson.toJson(c);\n+                URI uri = config.getUri(\"/setchannels\");\n+                int status = httpClient.POST(uri).content(new StringContentProvider(json), \"application/json\")\n+                        .timeout(5, TimeUnit.SECONDS).send().getStatus();\n+                if (status == 401) {\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                            \"No or wrong login credentials provided. Please configure username/password for write access to WlanThermo!\");\n+                    break;\n+                } else if (status != 200) {\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, \"Failed to update channel \"\n+                            + c.getName() + \" on device, Statuscode \" + status + \" on URI \" + uri.toString());\n+                    logger.debug(\"Payload sent: {}\", json);\n+                } else {\n+                    updateStatus(ThingStatus.ONLINE);\n+                }\n+            } catch (TimeoutException | ExecutionException | URISyntaxException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        \"Failed to update channel \" + c.getName() + \" on device: \" + e.getMessage());\n+            } catch (InterruptedException e) {\n+                logger.debug(\"Push interrupted. {}\", e.getMessage());\n+                return;\n+            }\n+        }\n+\n+        // push update for pitmaster channels\n+        try {\n+            String json = gson.toJson(data.getPitmaster().getPm());\n+            URI uri = config.getUri(\"/setpitmaster\");\n+            int status = httpClient.POST(uri).content(new StringContentProvider(json), \"application/json\")\n+                    .timeout(5, TimeUnit.SECONDS).send().getStatus();\n+            if (status == 401) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        \"No or wrong login credentials provided. Please configure username/password for write access to WlanThermo!\");\n+            } else if (status != 200) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        \"Failed to update pitmaster channel on device, Statuscode \" + status + \" on URI \"\n+                                + uri.toString());\n+                logger.debug(\"Payload sent: {}\", json);\n+            } else {\n+                updateStatus(ThingStatus.ONLINE);\n+            }\n+        } catch (TimeoutException | ExecutionException | URISyntaxException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                    \"Failed to update pitmaster channel on device: \" + e.getMessage());\n+        } catch (InterruptedException e) {\n+            logger.debug(\"Push interrupted. {}\", e.getMessage());\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0aaff6395abedf04f6d586a4729d8f0782e98239"}, "originalPosition": 241}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzUyMTA4NTgxOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/WlanThermoHandler.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xN1QyMToyNDozNVrOIVVVEg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xOFQwNjo0OTo1OVrOIVb1Sw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTI0MDQ2Ng==", "bodyText": "Always pass the cause exceptions into new exceptions you throw.\nPlease add such a constructor is one doesn't already exist.\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        throw new WlanThermoInputException();\n          \n          \n            \n                        throw new WlanThermoInputException(e);\n          \n      \n    \n    \n  \n\nAlso, I don't think that a WlanThermoInputException is the correct thing to throw here if you get a TimeoutException. The WlanThermoInputException message implies incorrect data but a Timeout is not related to that at all, so the exception message would be misleading. Consider having the doGet method throw WlanThermoException instead so you can throw broader types of exceptions.", "url": "https://github.com/openhab/openhab-addons/pull/9579#discussion_r559240466", "createdAt": "2021-01-17T21:24:35Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/WlanThermoHandler.java", "diffHunk": "@@ -0,0 +1,190 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.wlanthermo.internal;\n+\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoUtil.requireNonNull;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.Authentication;\n+import org.eclipse.jetty.client.api.AuthenticationStore;\n+import org.eclipse.jetty.client.util.DigestAuthentication;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.openhab.core.thing.*;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+\n+/**\n+ * The {@link WlanThermoHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Christian Schlipp - Initial contribution\n+ */\n+@NonNullByDefault\n+public abstract class WlanThermoHandler extends BaseThingHandler {\n+\n+    private final boolean extendedConfig;\n+    protected WlanThermoConfiguration config = new WlanThermoConfiguration();\n+    protected final HttpClient httpClient;\n+    protected final Logger logger = LoggerFactory.getLogger(WlanThermoHandler.class);\n+    protected final Gson gson = new Gson();\n+    @Nullable\n+    protected ScheduledFuture<?> pollingScheduler;\n+\n+    public WlanThermoHandler(Thing thing, HttpClient httpClient, boolean extendedConfig) {\n+        super(thing);\n+        this.httpClient = httpClient;\n+        this.extendedConfig = extendedConfig;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        updateStatus(ThingStatus.UNKNOWN);\n+        try {\n+            if (extendedConfig) {\n+                config = getConfigAs(WlanThermoExtendedConfiguration.class);\n+                WlanThermoExtendedConfiguration extendedConfig = (WlanThermoExtendedConfiguration) config;\n+                if (extendedConfig.getUsername().isEmpty() && !extendedConfig.getPassword().isEmpty()) {\n+                    AuthenticationStore authStore = httpClient.getAuthenticationStore();\n+                    authStore.addAuthentication(new DigestAuthentication(config.getUri(), Authentication.ANY_REALM,\n+                            extendedConfig.getUsername(), extendedConfig.getPassword()));\n+                }\n+            } else {\n+                config = getConfigAs(WlanThermoConfiguration.class);\n+            }\n+            pollingScheduler = scheduler.scheduleWithFixedDelay(this::checkConnectionAndUpdate, 0,\n+                    config.getPollingInterval(), TimeUnit.SECONDS);\n+        } catch (URISyntaxException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"Failed to initialize WlanThermo: \" + e.getMessage());\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        ScheduledFuture<?> oldScheduler = pollingScheduler;\n+        if (oldScheduler != null) {\n+            boolean stopped = oldScheduler.cancel(true);\n+            logger.debug(\"Stopped polling: {}\", stopped);\n+        }\n+        pollingScheduler = null;\n+    }\n+\n+    protected void checkConnectionAndUpdate() {\n+        if (this.thing.getStatus() != ThingStatus.ONLINE) {\n+            try {\n+                if (httpClient.GET(config.getUri()).getStatus() == 200) {\n+                    updateStatus(ThingStatus.ONLINE);\n+                    // rerun immediately to update state\n+                    checkConnectionAndUpdate();\n+                } else {\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                            \"WlanThermo not found under given address.\");\n+                }\n+            } catch (URISyntaxException | ExecutionException | TimeoutException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        \"Could not connect to WlanThermo at \" + config.getIpAddress() + \": \" + e.getMessage());\n+            } catch (InterruptedException e) {\n+                logger.debug(\"Connection check interrupted. {}\", e.getMessage());\n+            }\n+        } else {\n+            pull();\n+        }\n+    }\n+\n+    protected boolean doPost(String endpoint, String json) throws InterruptedException {\n+        try {\n+            URI uri = config.getUri(endpoint);\n+            int status = httpClient.POST(uri).content(new StringContentProvider(json), \"application/json\")\n+                    .timeout(5, TimeUnit.SECONDS).send().getStatus();\n+            if (status == 401) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        \"No or wrong login credentials provided. Please configure username/password for write access to WlanThermo!\");\n+                return false;\n+            } else if (status != 200) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        \"Failed to update channel on device, Statuscode \" + status + \" on URI \" + uri.toString());\n+                logger.debug(\"Payload sent: {}\", json);\n+                // Still continue to try next channel\n+                return true;\n+            } else {\n+                updateStatus(ThingStatus.ONLINE);\n+                return true;\n+            }\n+        } catch (TimeoutException | ExecutionException | URISyntaxException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                    \"Failed to update channel on device: \" + e.getMessage());\n+            return false;\n+        }\n+    }\n+\n+    protected <T> T doGet(String endpoint, Class<T> object) throws InterruptedException, WlanThermoInputException {\n+        try {\n+            String json = httpClient.GET(config.getUri(endpoint)).getContentAsString();\n+            logger.debug(\"Received at {}: {}\", endpoint, json);\n+            return requireNonNull(gson.fromJson(json, object));\n+        } catch (URISyntaxException | ExecutionException | TimeoutException | WlanThermoException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                    \"Update failed: \" + e.getMessage());\n+            for (Channel channel : thing.getChannels()) {\n+                updateState(channel.getUID(), UnDefType.UNDEF);\n+            }\n+            throw new WlanThermoInputException();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "483da477f329def4b5438d2ef1e3839552c901a0"}, "originalPosition": 157}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTM0NzAxOQ==", "bodyText": "A Timeout would however result in invalid input data for the binding.\nChanged it anyways.", "url": "https://github.com/openhab/openhab-addons/pull/9579#discussion_r559347019", "createdAt": "2021-01-18T06:49:59Z", "author": {"login": "CSchlipp"}, "path": "bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/WlanThermoHandler.java", "diffHunk": "@@ -0,0 +1,190 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.wlanthermo.internal;\n+\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoUtil.requireNonNull;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.Authentication;\n+import org.eclipse.jetty.client.api.AuthenticationStore;\n+import org.eclipse.jetty.client.util.DigestAuthentication;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.openhab.core.thing.*;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+\n+/**\n+ * The {@link WlanThermoHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Christian Schlipp - Initial contribution\n+ */\n+@NonNullByDefault\n+public abstract class WlanThermoHandler extends BaseThingHandler {\n+\n+    private final boolean extendedConfig;\n+    protected WlanThermoConfiguration config = new WlanThermoConfiguration();\n+    protected final HttpClient httpClient;\n+    protected final Logger logger = LoggerFactory.getLogger(WlanThermoHandler.class);\n+    protected final Gson gson = new Gson();\n+    @Nullable\n+    protected ScheduledFuture<?> pollingScheduler;\n+\n+    public WlanThermoHandler(Thing thing, HttpClient httpClient, boolean extendedConfig) {\n+        super(thing);\n+        this.httpClient = httpClient;\n+        this.extendedConfig = extendedConfig;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        updateStatus(ThingStatus.UNKNOWN);\n+        try {\n+            if (extendedConfig) {\n+                config = getConfigAs(WlanThermoExtendedConfiguration.class);\n+                WlanThermoExtendedConfiguration extendedConfig = (WlanThermoExtendedConfiguration) config;\n+                if (extendedConfig.getUsername().isEmpty() && !extendedConfig.getPassword().isEmpty()) {\n+                    AuthenticationStore authStore = httpClient.getAuthenticationStore();\n+                    authStore.addAuthentication(new DigestAuthentication(config.getUri(), Authentication.ANY_REALM,\n+                            extendedConfig.getUsername(), extendedConfig.getPassword()));\n+                }\n+            } else {\n+                config = getConfigAs(WlanThermoConfiguration.class);\n+            }\n+            pollingScheduler = scheduler.scheduleWithFixedDelay(this::checkConnectionAndUpdate, 0,\n+                    config.getPollingInterval(), TimeUnit.SECONDS);\n+        } catch (URISyntaxException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"Failed to initialize WlanThermo: \" + e.getMessage());\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        ScheduledFuture<?> oldScheduler = pollingScheduler;\n+        if (oldScheduler != null) {\n+            boolean stopped = oldScheduler.cancel(true);\n+            logger.debug(\"Stopped polling: {}\", stopped);\n+        }\n+        pollingScheduler = null;\n+    }\n+\n+    protected void checkConnectionAndUpdate() {\n+        if (this.thing.getStatus() != ThingStatus.ONLINE) {\n+            try {\n+                if (httpClient.GET(config.getUri()).getStatus() == 200) {\n+                    updateStatus(ThingStatus.ONLINE);\n+                    // rerun immediately to update state\n+                    checkConnectionAndUpdate();\n+                } else {\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                            \"WlanThermo not found under given address.\");\n+                }\n+            } catch (URISyntaxException | ExecutionException | TimeoutException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        \"Could not connect to WlanThermo at \" + config.getIpAddress() + \": \" + e.getMessage());\n+            } catch (InterruptedException e) {\n+                logger.debug(\"Connection check interrupted. {}\", e.getMessage());\n+            }\n+        } else {\n+            pull();\n+        }\n+    }\n+\n+    protected boolean doPost(String endpoint, String json) throws InterruptedException {\n+        try {\n+            URI uri = config.getUri(endpoint);\n+            int status = httpClient.POST(uri).content(new StringContentProvider(json), \"application/json\")\n+                    .timeout(5, TimeUnit.SECONDS).send().getStatus();\n+            if (status == 401) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        \"No or wrong login credentials provided. Please configure username/password for write access to WlanThermo!\");\n+                return false;\n+            } else if (status != 200) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        \"Failed to update channel on device, Statuscode \" + status + \" on URI \" + uri.toString());\n+                logger.debug(\"Payload sent: {}\", json);\n+                // Still continue to try next channel\n+                return true;\n+            } else {\n+                updateStatus(ThingStatus.ONLINE);\n+                return true;\n+            }\n+        } catch (TimeoutException | ExecutionException | URISyntaxException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                    \"Failed to update channel on device: \" + e.getMessage());\n+            return false;\n+        }\n+    }\n+\n+    protected <T> T doGet(String endpoint, Class<T> object) throws InterruptedException, WlanThermoInputException {\n+        try {\n+            String json = httpClient.GET(config.getUri(endpoint)).getContentAsString();\n+            logger.debug(\"Received at {}: {}\", endpoint, json);\n+            return requireNonNull(gson.fromJson(json, object));\n+        } catch (URISyntaxException | ExecutionException | TimeoutException | WlanThermoException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                    \"Update failed: \" + e.getMessage());\n+            for (Channel channel : thing.getChannels()) {\n+                updateState(channel.getUID(), UnDefType.UNDEF);\n+            }\n+            throw new WlanThermoInputException();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTI0MDQ2Ng=="}, "originalCommit": {"oid": "483da477f329def4b5438d2ef1e3839552c901a0"}, "originalPosition": 157}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzUyMTA5NDc4OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/WlanThermoHandler.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xN1QyMTozMzo1MlrOIVVZYQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xN1QyMTozMzo1MlrOIVVZYQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTI0MTU2OQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                @Nullable\n          \n          \n            \n                protected ScheduledFuture<?> pollingScheduler;\n          \n          \n            \n                protected @Nullable ScheduledFuture<?> pollingScheduler;", "url": "https://github.com/openhab/openhab-addons/pull/9579#discussion_r559241569", "createdAt": "2021-01-17T21:33:52Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/WlanThermoHandler.java", "diffHunk": "@@ -0,0 +1,190 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.wlanthermo.internal;\n+\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoUtil.requireNonNull;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.Authentication;\n+import org.eclipse.jetty.client.api.AuthenticationStore;\n+import org.eclipse.jetty.client.util.DigestAuthentication;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.openhab.core.thing.*;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+\n+/**\n+ * The {@link WlanThermoHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Christian Schlipp - Initial contribution\n+ */\n+@NonNullByDefault\n+public abstract class WlanThermoHandler extends BaseThingHandler {\n+\n+    private final boolean extendedConfig;\n+    protected WlanThermoConfiguration config = new WlanThermoConfiguration();\n+    protected final HttpClient httpClient;\n+    protected final Logger logger = LoggerFactory.getLogger(WlanThermoHandler.class);\n+    protected final Gson gson = new Gson();\n+    @Nullable\n+    protected ScheduledFuture<?> pollingScheduler;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "483da477f329def4b5438d2ef1e3839552c901a0"}, "originalPosition": 57}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzUyMTA5NzgyOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.wlanthermo/src/test/java/org/openhab/binding/wlanthermo/internal/api/esp32/WlanThermoEsp32CommandHandlerTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xN1QyMTozNjo0MVrOIVVaxQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xN1QyMTozNjo0MVrOIVVaxQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTI0MTkyNQ==", "bodyText": "Please put test data in their own files and then load them in runtime. You can do this by loading the resources from the ClassLoader.", "url": "https://github.com/openhab/openhab-addons/pull/9579#discussion_r559241925", "createdAt": "2021-01-17T21:36:41Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.wlanthermo/src/test/java/org/openhab/binding/wlanthermo/internal/api/esp32/WlanThermoEsp32CommandHandlerTest.java", "diffHunk": "@@ -0,0 +1,601 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.wlanthermo.internal.api.esp32;\n+\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.*;\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.TRIGGER_NONE;\n+\n+import java.awt.*;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.function.Executable;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n+import org.openhab.binding.wlanthermo.internal.WlanThermoException;\n+import org.openhab.binding.wlanthermo.internal.WlanThermoUnknownChannelException;\n+import org.openhab.binding.wlanthermo.internal.WlanThermoUtil;\n+import org.openhab.binding.wlanthermo.internal.api.esp32.dto.data.Data;\n+import org.openhab.binding.wlanthermo.internal.api.esp32.dto.settings.Settings;\n+import org.openhab.core.library.types.*;\n+import org.openhab.core.library.unit.SIUnits;\n+import org.openhab.core.library.unit.Units;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.ThingUID;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.UnDefType;\n+\n+import com.google.gson.Gson;\n+\n+/**\n+ * The {@link WlanThermoEsp32CommandHandlerTest} class tests the {@link WlanThermoEsp32CommandHandler}\n+ *\n+ * @author Christian Schlipp - Initial contribution\n+ */\n+@NonNullByDefault\n+class WlanThermoEsp32CommandHandlerTest {\n+\n+    private static final ThingUID THING_UID = new ThingUID(\"wlanthermo\", \"esp32\", \"test\");\n+\n+    //@formatter:off\n+    private static final String DATA_INPUT_JSON = \"{\\n\" +", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "483da477f329def4b5438d2ef1e3839552c901a0"}, "originalPosition": 56}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzUyMTEwMjU5OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/api/nano/WlanThermoNanoV1CommandHandler.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xN1QyMTo0MTowN1rOIVVc9w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xOFQwNjo1MDoyOVrOIVb18A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTI0MjQ4Nw==", "bodyText": "Is this fall through intentional?", "url": "https://github.com/openhab/openhab-addons/pull/9579#discussion_r559242487", "createdAt": "2021-01-17T21:41:07Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/api/nano/WlanThermoNanoV1CommandHandler.java", "diffHunk": "@@ -0,0 +1,275 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.wlanthermo.internal.api.nano;\n+\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.*;\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoUtil.requireNonNull;\n+\n+import java.awt.*;\n+import java.math.BigInteger;\n+import java.util.List;\n+\n+import javax.measure.Unit;\n+import javax.measure.quantity.Temperature;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.binding.wlanthermo.internal.WlanThermoInputException;\n+import org.openhab.binding.wlanthermo.internal.WlanThermoUnknownChannelException;\n+import org.openhab.binding.wlanthermo.internal.api.nano.dto.data.Channel;\n+import org.openhab.binding.wlanthermo.internal.api.nano.dto.data.Data;\n+import org.openhab.binding.wlanthermo.internal.api.nano.dto.data.Pm;\n+import org.openhab.binding.wlanthermo.internal.api.nano.dto.data.System;\n+import org.openhab.binding.wlanthermo.internal.api.nano.dto.settings.Settings;\n+import org.openhab.core.library.types.*;\n+import org.openhab.core.library.unit.ImperialUnits;\n+import org.openhab.core.library.unit.SIUnits;\n+import org.openhab.core.library.unit.Units;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.UnDefType;\n+\n+/**\n+ * The {@link WlanThermoNanoV1CommandHandler} is responsible for mapping the Commands to the respective data fields\n+ * of the API.\n+ *\n+ * @author Christian Schlipp - Initial contribution\n+ */\n+@NonNullByDefault\n+public class WlanThermoNanoV1CommandHandler {\n+\n+    public static State getState(ChannelUID channelUID, Data data, Settings settings)\n+            throws WlanThermoUnknownChannelException, WlanThermoInputException {\n+        String groupId = requireNonNull(channelUID.getGroupId());\n+        System system = data.getSystem();\n+        Unit<Temperature> unit = \"F\".equals(system.getUnit()) ? ImperialUnits.FAHRENHEIT : SIUnits.CELSIUS;\n+        List<Channel> channelList = data.getChannel();\n+\n+        if (SYSTEM.equals(groupId)) {\n+            switch (channelUID.getIdWithoutGroup()) {\n+                case SYSTEM_SOC:\n+                    return new DecimalType(system.getSoc());\n+                case SYSTEM_CHARGE:\n+                    return OnOffType.from(system.getCharge());\n+                case SYSTEM_RSSI_SIGNALSTRENGTH:\n+                    int dbm = system.getRssi();\n+                    if (dbm >= -80) {\n+                        return SIGNAL_STRENGTH_4;\n+                    } else if (dbm >= -95) {\n+                        return SIGNAL_STRENGTH_3;\n+                    } else if (dbm >= -105) {\n+                        return SIGNAL_STRENGTH_2;\n+                    } else {\n+                        return SIGNAL_STRENGTH_1;\n+                    }\n+                case SYSTEM_RSSI:\n+                    return new QuantityType<>(system.getRssi(), Units.DECIBEL_MILLIWATTS);\n+            }\n+        } else if (channelUID.getId().startsWith(CHANNEL_PREFIX)) {\n+            int channelId = Integer.parseInt(groupId.substring(CHANNEL_PREFIX.length())) - 1;\n+            if (channelList.size() > 0 && channelId < channelList.size()) {\n+                Channel channel = channelList.get(channelId);\n+                switch (channelUID.getIdWithoutGroup()) {\n+                    case CHANNEL_NAME:\n+                        return new StringType(channel.getName());\n+                    case CHANNEL_TYP:\n+                        return new StringType(settings.sensors.get(channel.getTyp()));\n+                    case CHANNEL_TEMP:\n+                        return channel.getTemp() == 999.0 ? UnDefType.UNDEF\n+                                : new QuantityType<>(channel.getTemp(), unit);\n+                    case CHANNEL_MIN:\n+                        return new QuantityType<>(channel.getMin(), unit);\n+                    case CHANNEL_MAX:\n+                        return new QuantityType<>(channel.getMax(), unit);\n+                    case CHANNEL_ALARM_DEVICE:\n+                        return OnOffType.from(BigInteger.valueOf(channel.getAlarm()).testBit(1));\n+                    case CHANNEL_ALARM_PUSH:\n+                        return OnOffType.from(BigInteger.valueOf(channel.getAlarm()).testBit(0));\n+                    case CHANNEL_ALARM_OPENHAB_HIGH:\n+                        if (channel.getTemp() != 999 && channel.getTemp() > channel.getMax()) {\n+                            return OnOffType.ON;\n+                        } else {\n+                            return OnOffType.OFF;\n+                        }\n+                    case CHANNEL_ALARM_OPENHAB_LOW:\n+                        if (channel.getTemp() != 999 && channel.getTemp() < channel.getMin()) {\n+                            return OnOffType.ON;\n+                        } else {\n+                            return OnOffType.OFF;\n+                        }\n+                    case CHANNEL_COLOR:\n+                        String color = channel.getColor();\n+                        if (color != null && !color.isEmpty()) {\n+                            Color c = Color.decode(color);\n+                            return HSBType.fromRGB(c.getRed(), c.getGreen(), c.getBlue());\n+                        } else {\n+                            return UnDefType.UNDEF;\n+                        }\n+                    case CHANNEL_COLOR_NAME:\n+                        String colorHex = channel.getColor();\n+                        if (colorHex != null && !colorHex.isEmpty()) {\n+                            return new StringType(WlanThermoNanoV1Util.toColorName(colorHex));\n+                        } else {\n+                            return UnDefType.UNDEF;\n+                        }\n+                }\n+            }\n+        } else if (channelUID.getId().startsWith(CHANNEL_PITMASTER_1)) {\n+            if (data.getPitmaster() != null && data.getPitmaster().getPm() != null\n+                    && data.getPitmaster().getPm().size() > 0) {\n+                Pm pm = data.getPitmaster().getPm().get(0);\n+                switch (channelUID.getIdWithoutGroup()) {\n+                    case CHANNEL_PITMASTER_CHANNEL_ID:\n+                        return new DecimalType(pm.getChannel());\n+                    case CHANNEL_PITMASTER_PIDPROFILE:\n+                        return new DecimalType(pm.getPid());\n+                    case CHANNEL_PITMASTER_DUTY_CYCLE:\n+                        return new DecimalType(pm.getValue());\n+                    case CHANNEL_PITMASTER_SETPOINT:\n+                        return new QuantityType<>(pm.getSet(), unit);\n+                    case CHANNEL_PITMASTER_STATE:\n+                        return new StringType(pm.getTyp());\n+                }\n+            } else {\n+                return UnDefType.UNDEF;\n+            }\n+        }\n+        throw new WlanThermoUnknownChannelException(channelUID);\n+    }\n+\n+    public static boolean setState(ChannelUID channelUID, Command command, Data data) {\n+        String groupId;\n+        try {\n+            groupId = requireNonNull(channelUID.getGroupId());\n+        } catch (WlanThermoInputException e) {\n+            return false;\n+        }\n+\n+        List<Channel> channelList = data.getChannel();\n+        System system = data.getSystem();\n+        Unit<Temperature> unit = \"F\".equals(system.getUnit()) ? ImperialUnits.FAHRENHEIT : SIUnits.CELSIUS;\n+\n+        if (channelUID.getId().startsWith(CHANNEL_PREFIX)) {\n+            int channelId = Integer.parseInt(groupId.substring(CHANNEL_PREFIX.length())) - 1;\n+            if (channelList.size() > 0 && channelId < channelList.size()) {\n+                Channel channel = channelList.get(channelId);\n+                switch (channelUID.getIdWithoutGroup()) {\n+                    case CHANNEL_NAME:\n+                        if (command instanceof StringType) {\n+                            channel.setName(command.toFullString());\n+                            return true;\n+                        }\n+                    case CHANNEL_MIN:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "483da477f329def4b5438d2ef1e3839552c901a0"}, "originalPosition": 172}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTM0NzE4NA==", "bodyText": "No, this bug was introduced by the change of the return handling. Thanks, fixed.", "url": "https://github.com/openhab/openhab-addons/pull/9579#discussion_r559347184", "createdAt": "2021-01-18T06:50:29Z", "author": {"login": "CSchlipp"}, "path": "bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/api/nano/WlanThermoNanoV1CommandHandler.java", "diffHunk": "@@ -0,0 +1,275 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.wlanthermo.internal.api.nano;\n+\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.*;\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoUtil.requireNonNull;\n+\n+import java.awt.*;\n+import java.math.BigInteger;\n+import java.util.List;\n+\n+import javax.measure.Unit;\n+import javax.measure.quantity.Temperature;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.binding.wlanthermo.internal.WlanThermoInputException;\n+import org.openhab.binding.wlanthermo.internal.WlanThermoUnknownChannelException;\n+import org.openhab.binding.wlanthermo.internal.api.nano.dto.data.Channel;\n+import org.openhab.binding.wlanthermo.internal.api.nano.dto.data.Data;\n+import org.openhab.binding.wlanthermo.internal.api.nano.dto.data.Pm;\n+import org.openhab.binding.wlanthermo.internal.api.nano.dto.data.System;\n+import org.openhab.binding.wlanthermo.internal.api.nano.dto.settings.Settings;\n+import org.openhab.core.library.types.*;\n+import org.openhab.core.library.unit.ImperialUnits;\n+import org.openhab.core.library.unit.SIUnits;\n+import org.openhab.core.library.unit.Units;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.UnDefType;\n+\n+/**\n+ * The {@link WlanThermoNanoV1CommandHandler} is responsible for mapping the Commands to the respective data fields\n+ * of the API.\n+ *\n+ * @author Christian Schlipp - Initial contribution\n+ */\n+@NonNullByDefault\n+public class WlanThermoNanoV1CommandHandler {\n+\n+    public static State getState(ChannelUID channelUID, Data data, Settings settings)\n+            throws WlanThermoUnknownChannelException, WlanThermoInputException {\n+        String groupId = requireNonNull(channelUID.getGroupId());\n+        System system = data.getSystem();\n+        Unit<Temperature> unit = \"F\".equals(system.getUnit()) ? ImperialUnits.FAHRENHEIT : SIUnits.CELSIUS;\n+        List<Channel> channelList = data.getChannel();\n+\n+        if (SYSTEM.equals(groupId)) {\n+            switch (channelUID.getIdWithoutGroup()) {\n+                case SYSTEM_SOC:\n+                    return new DecimalType(system.getSoc());\n+                case SYSTEM_CHARGE:\n+                    return OnOffType.from(system.getCharge());\n+                case SYSTEM_RSSI_SIGNALSTRENGTH:\n+                    int dbm = system.getRssi();\n+                    if (dbm >= -80) {\n+                        return SIGNAL_STRENGTH_4;\n+                    } else if (dbm >= -95) {\n+                        return SIGNAL_STRENGTH_3;\n+                    } else if (dbm >= -105) {\n+                        return SIGNAL_STRENGTH_2;\n+                    } else {\n+                        return SIGNAL_STRENGTH_1;\n+                    }\n+                case SYSTEM_RSSI:\n+                    return new QuantityType<>(system.getRssi(), Units.DECIBEL_MILLIWATTS);\n+            }\n+        } else if (channelUID.getId().startsWith(CHANNEL_PREFIX)) {\n+            int channelId = Integer.parseInt(groupId.substring(CHANNEL_PREFIX.length())) - 1;\n+            if (channelList.size() > 0 && channelId < channelList.size()) {\n+                Channel channel = channelList.get(channelId);\n+                switch (channelUID.getIdWithoutGroup()) {\n+                    case CHANNEL_NAME:\n+                        return new StringType(channel.getName());\n+                    case CHANNEL_TYP:\n+                        return new StringType(settings.sensors.get(channel.getTyp()));\n+                    case CHANNEL_TEMP:\n+                        return channel.getTemp() == 999.0 ? UnDefType.UNDEF\n+                                : new QuantityType<>(channel.getTemp(), unit);\n+                    case CHANNEL_MIN:\n+                        return new QuantityType<>(channel.getMin(), unit);\n+                    case CHANNEL_MAX:\n+                        return new QuantityType<>(channel.getMax(), unit);\n+                    case CHANNEL_ALARM_DEVICE:\n+                        return OnOffType.from(BigInteger.valueOf(channel.getAlarm()).testBit(1));\n+                    case CHANNEL_ALARM_PUSH:\n+                        return OnOffType.from(BigInteger.valueOf(channel.getAlarm()).testBit(0));\n+                    case CHANNEL_ALARM_OPENHAB_HIGH:\n+                        if (channel.getTemp() != 999 && channel.getTemp() > channel.getMax()) {\n+                            return OnOffType.ON;\n+                        } else {\n+                            return OnOffType.OFF;\n+                        }\n+                    case CHANNEL_ALARM_OPENHAB_LOW:\n+                        if (channel.getTemp() != 999 && channel.getTemp() < channel.getMin()) {\n+                            return OnOffType.ON;\n+                        } else {\n+                            return OnOffType.OFF;\n+                        }\n+                    case CHANNEL_COLOR:\n+                        String color = channel.getColor();\n+                        if (color != null && !color.isEmpty()) {\n+                            Color c = Color.decode(color);\n+                            return HSBType.fromRGB(c.getRed(), c.getGreen(), c.getBlue());\n+                        } else {\n+                            return UnDefType.UNDEF;\n+                        }\n+                    case CHANNEL_COLOR_NAME:\n+                        String colorHex = channel.getColor();\n+                        if (colorHex != null && !colorHex.isEmpty()) {\n+                            return new StringType(WlanThermoNanoV1Util.toColorName(colorHex));\n+                        } else {\n+                            return UnDefType.UNDEF;\n+                        }\n+                }\n+            }\n+        } else if (channelUID.getId().startsWith(CHANNEL_PITMASTER_1)) {\n+            if (data.getPitmaster() != null && data.getPitmaster().getPm() != null\n+                    && data.getPitmaster().getPm().size() > 0) {\n+                Pm pm = data.getPitmaster().getPm().get(0);\n+                switch (channelUID.getIdWithoutGroup()) {\n+                    case CHANNEL_PITMASTER_CHANNEL_ID:\n+                        return new DecimalType(pm.getChannel());\n+                    case CHANNEL_PITMASTER_PIDPROFILE:\n+                        return new DecimalType(pm.getPid());\n+                    case CHANNEL_PITMASTER_DUTY_CYCLE:\n+                        return new DecimalType(pm.getValue());\n+                    case CHANNEL_PITMASTER_SETPOINT:\n+                        return new QuantityType<>(pm.getSet(), unit);\n+                    case CHANNEL_PITMASTER_STATE:\n+                        return new StringType(pm.getTyp());\n+                }\n+            } else {\n+                return UnDefType.UNDEF;\n+            }\n+        }\n+        throw new WlanThermoUnknownChannelException(channelUID);\n+    }\n+\n+    public static boolean setState(ChannelUID channelUID, Command command, Data data) {\n+        String groupId;\n+        try {\n+            groupId = requireNonNull(channelUID.getGroupId());\n+        } catch (WlanThermoInputException e) {\n+            return false;\n+        }\n+\n+        List<Channel> channelList = data.getChannel();\n+        System system = data.getSystem();\n+        Unit<Temperature> unit = \"F\".equals(system.getUnit()) ? ImperialUnits.FAHRENHEIT : SIUnits.CELSIUS;\n+\n+        if (channelUID.getId().startsWith(CHANNEL_PREFIX)) {\n+            int channelId = Integer.parseInt(groupId.substring(CHANNEL_PREFIX.length())) - 1;\n+            if (channelList.size() > 0 && channelId < channelList.size()) {\n+                Channel channel = channelList.get(channelId);\n+                switch (channelUID.getIdWithoutGroup()) {\n+                    case CHANNEL_NAME:\n+                        if (command instanceof StringType) {\n+                            channel.setName(command.toFullString());\n+                            return true;\n+                        }\n+                    case CHANNEL_MIN:", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTI0MjQ4Nw=="}, "originalCommit": {"oid": "483da477f329def4b5438d2ef1e3839552c901a0"}, "originalPosition": 172}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3570, "cost": 1, "resetAt": "2021-11-13T12:10:21Z"}}}