{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDEyNDY1OTg2", "number": 7528, "reviewThreads": {"totalCount": 52, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMlQxOToyNTowNFrOD_DQSg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xM1QyMDo0ODo1OFrOEFRnng==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY3NDQwMjAyOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.novafinedust/README.md", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMlQxOToyNTowNFrOGZhrng==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMlQxOToyNTowNFrOGZhrng==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTQxOTQyMg==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            | port              | yes       | the port the sensor is connected to, i.e. /detv/ttyUSB0.                              |\n          \n          \n            \n            | port              | yes       | the port the sensor is connected to, i.e. /dev/ttyUSB0.                               |", "url": "https://github.com/openhab/openhab-addons/pull/7528#discussion_r429419422", "createdAt": "2020-05-22T19:25:04Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.novafinedust/README.md", "diffHunk": "@@ -0,0 +1,78 @@\n+# NovaFineDust Binding\n+\n+This binding is for the fine dust sensor (PM Sensor) from Nova Fitness. Currently only one model is supported, the SDS011.\n+\n+It basically implements the protocol specified in [this document](https://cdn.sparkfun.com/assets/parts/1/2/2/7/5/Laser_Dust_Sensor_Control_Protocol_V1.3.pdf).\n+One can measure the PM 2.5 and PM 10 values with this device. It comes very handy for detecting air pollution like neighbors firing their oven with wet wood etc. so one can deactivate the ventilation system. \n+\n+## Supported Things\n+\n+There is only one Thing for this binding is `SDS011`.\n+\n+## Discovery\n+\n+There is no automatic discovery. The Thing has to be added manually via the `.things` configuration file or via (Paper) UI.\n+\n+## Thing Configuration\n+\n+There are 2 different working modes for the `SDS011` thing: Reporting and Polling.\n+\n+### Reporting\n+\n+This is the preferred mode and thus also configured as a default. In this mode the sensor wakes up every `reportingInterval` minutes, performs a measurement for 30 seconds and sleeps for `reportingInterval` minus 30 seconds. Remember: According to the [datasheet](https://www-sd-nf.oss-cn-beijing.aliyuncs.com/%E5%AE%98%E7%BD%91%E4%B8%8B%E8%BD%BD/SDS011%20laser%20PM2.5%20sensor%20specification-V1.4.pdf) the sensor has a lifetime of 8000 hours. Using a 0 as `reportingInterval` will make the sensor report its data as fast as possible.\n+\n+### Polling\n+\n+If one needs data in different intervals, i.e. not as fast as possible and not in intervals that are a multiple of full minutes, polling can be configured. The `pollingInterval` parameter specifies the time in seconds when data will be polled from the sensor.\n+\n+In addition to the mode one has to provide the port to which the device is connected.\n+\n+A full overview about the parameters of the `SDS011` thing is given in the following table:\n+\n+| parameter name    | mandatory | description                                                                           |\n+|-------------------|-----------|---------------------------------------------------------------------------------------|\n+| port              | yes       | the port the sensor is connected to, i.e. /detv/ttyUSB0.                              |", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "17ab9e48eb7ee697b10405fcdabcba5a6d99288a"}, "originalPosition": 34}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY3NDQwODgyOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.novafinedust/src/main/java/org/openhab/binding/novafinedust/internal/SDS011Handler.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMlQxOToyNzo1N1rOGZhv0w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMlQxOToyNzo1N1rOGZhv0w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTQyMDQ5OQ==", "bodyText": "typo \"Tolerance\"", "url": "https://github.com/openhab/openhab-addons/pull/7528#discussion_r429420499", "createdAt": "2020-05-22T19:27:57Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.novafinedust/src/main/java/org/openhab/binding/novafinedust/internal/SDS011Handler.java", "diffHunk": "@@ -0,0 +1,244 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.novafinedust.internal;\n+\n+import java.io.IOException;\n+import java.time.Duration;\n+import java.time.ZonedDateTime;\n+import java.time.chrono.ChronoZonedDateTime;\n+import java.time.temporal.Temporal;\n+import java.util.TooManyListenersException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.dimension.Density;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.unit.SmartHomeUnits;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.io.transport.serial.PortInUseException;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortIdentifier;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.eclipse.smarthome.io.transport.serial.UnsupportedCommOperationException;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.SDS011Communicator;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.WorkMode;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.SensorMeasuredDataReply;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link SDS011Handler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Stefan Triller - Initial contribution\n+ */\n+@NonNullByDefault\n+public class SDS011Handler extends BaseThingHandler {\n+    private static final Duration CONNECTION_MONITOR_START_DELAY_OFFSET = Duration.ofSeconds(10);\n+\n+    private final Logger logger = LoggerFactory.getLogger(SDS011Handler.class);\n+    private final SerialPortManager serialPortManager;\n+\n+    private @NonNullByDefault({}) NovaFineDustConfiguration config;\n+    private @NonNullByDefault({}) SDS011Communicator communicator;\n+\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+    private @Nullable ScheduledFuture<?> connectionMonitor;\n+\n+    private Temporal lastCommunication = ZonedDateTime.now();\n+\n+    // initialize timeBetweenDataShouldArrive with a large number\n+    private Duration timeBetweenDataShouldArrive = Duration.ofDays(1);\n+    private final Duration dataCanBeLateTollerance = Duration.ofSeconds(5);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "17ab9e48eb7ee697b10405fcdabcba5a6d99288a"}, "originalPosition": 68}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY3NDQzMTM3OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.novafinedust/src/main/java/org/openhab/binding/novafinedust/internal/SDS011Handler.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMlQxOTozODoxNVrOGZh-Mg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yM1QxMzowMTowMVrOGZpTZg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTQyNDE3OA==", "bodyText": "The Thing is not set as online again, if the connection succeeds in one of the upcoming cycles.", "url": "https://github.com/openhab/openhab-addons/pull/7528#discussion_r429424178", "createdAt": "2020-05-22T19:38:15Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.novafinedust/src/main/java/org/openhab/binding/novafinedust/internal/SDS011Handler.java", "diffHunk": "@@ -0,0 +1,244 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.novafinedust.internal;\n+\n+import java.io.IOException;\n+import java.time.Duration;\n+import java.time.ZonedDateTime;\n+import java.time.chrono.ChronoZonedDateTime;\n+import java.time.temporal.Temporal;\n+import java.util.TooManyListenersException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.dimension.Density;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.unit.SmartHomeUnits;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.io.transport.serial.PortInUseException;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortIdentifier;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.eclipse.smarthome.io.transport.serial.UnsupportedCommOperationException;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.SDS011Communicator;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.WorkMode;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.SensorMeasuredDataReply;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link SDS011Handler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Stefan Triller - Initial contribution\n+ */\n+@NonNullByDefault\n+public class SDS011Handler extends BaseThingHandler {\n+    private static final Duration CONNECTION_MONITOR_START_DELAY_OFFSET = Duration.ofSeconds(10);\n+\n+    private final Logger logger = LoggerFactory.getLogger(SDS011Handler.class);\n+    private final SerialPortManager serialPortManager;\n+\n+    private @NonNullByDefault({}) NovaFineDustConfiguration config;\n+    private @NonNullByDefault({}) SDS011Communicator communicator;\n+\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+    private @Nullable ScheduledFuture<?> connectionMonitor;\n+\n+    private Temporal lastCommunication = ZonedDateTime.now();\n+\n+    // initialize timeBetweenDataShouldArrive with a large number\n+    private Duration timeBetweenDataShouldArrive = Duration.ofDays(1);\n+    private final Duration dataCanBeLateTollerance = Duration.ofSeconds(5);\n+\n+    public SDS011Handler(Thing thing, SerialPortManager serialPortManager) {\n+        super(thing);\n+        this.serialPortManager = serialPortManager;\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        // we do not support refreshing as values are either reported by the device or polled from the device in fixed\n+        // intervals\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        config = getConfigAs(NovaFineDustConfiguration.class);\n+\n+        if (!validateConfiguration()) {\n+            return;\n+        }\n+\n+        // parse ports and if the port is found, initialize the reader\n+        SerialPortIdentifier portId = serialPortManager.getIdentifier(config.port);\n+        if (portId == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR, \"Port is not known!\");\n+            return;\n+        }\n+\n+        this.communicator = new SDS011Communicator(this, portId);\n+\n+        if (config.reporting) {\n+            timeBetweenDataShouldArrive = Duration.ofMinutes(config.reportingInterval);\n+            scheduler.schedule(() -> initializeCommunicator(WorkMode.REPORTING, timeBetweenDataShouldArrive), 0,\n+                    TimeUnit.SECONDS);\n+        } else {\n+            timeBetweenDataShouldArrive = Duration.ofSeconds(config.pollingInterval);\n+            scheduler.schedule(() -> initializeCommunicator(WorkMode.POLLING, timeBetweenDataShouldArrive), 0,\n+                    TimeUnit.SECONDS);\n+        }\n+\n+        Duration connectionMonitorStartDelay = timeBetweenDataShouldArrive.plus(CONNECTION_MONITOR_START_DELAY_OFFSET);\n+        connectionMonitor = scheduler.scheduleWithFixedDelay(this::verifyIfStillConnected,\n+                connectionMonitorStartDelay.getSeconds(), timeBetweenDataShouldArrive.getSeconds(), TimeUnit.SECONDS);\n+    }\n+\n+    private void initializeCommunicator(WorkMode mode, Duration interval) {\n+        boolean initSuccessful = false;\n+        try {\n+            initSuccessful = communicator.initialize(mode, interval);\n+        } catch (final IOException ex) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR, \"I/O error!\");\n+            return;\n+        } catch (PortInUseException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR, \"Port is in use!\");\n+            return;\n+        } catch (TooManyListenersException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                    \"Cannot attach listener to port!\");\n+            return;\n+        } catch (UnsupportedCommOperationException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                    \"Cannot set serial port parameters\");\n+            return;\n+        }\n+\n+        if (initSuccessful) {\n+            lastCommunication = ZonedDateTime.now();\n+            updateStatus(ThingStatus.ONLINE);\n+\n+            if (mode == WorkMode.POLLING) {\n+                pollingJob = scheduler.scheduleWithFixedDelay(() -> {\n+                    try {\n+                        communicator.requestSensorData();\n+                    } catch (IOException e) {\n+                        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "17ab9e48eb7ee697b10405fcdabcba5a6d99288a"}, "originalPosition": 144}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTU0NDI5NA==", "bodyText": "it will be set to ONLINE again once there is valid data received, see method updateChannels.", "url": "https://github.com/openhab/openhab-addons/pull/7528#discussion_r429544294", "createdAt": "2020-05-23T13:01:01Z", "author": {"login": "t2000"}, "path": "bundles/org.openhab.binding.novafinedust/src/main/java/org/openhab/binding/novafinedust/internal/SDS011Handler.java", "diffHunk": "@@ -0,0 +1,244 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.novafinedust.internal;\n+\n+import java.io.IOException;\n+import java.time.Duration;\n+import java.time.ZonedDateTime;\n+import java.time.chrono.ChronoZonedDateTime;\n+import java.time.temporal.Temporal;\n+import java.util.TooManyListenersException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.dimension.Density;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.unit.SmartHomeUnits;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.io.transport.serial.PortInUseException;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortIdentifier;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.eclipse.smarthome.io.transport.serial.UnsupportedCommOperationException;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.SDS011Communicator;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.WorkMode;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.SensorMeasuredDataReply;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link SDS011Handler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Stefan Triller - Initial contribution\n+ */\n+@NonNullByDefault\n+public class SDS011Handler extends BaseThingHandler {\n+    private static final Duration CONNECTION_MONITOR_START_DELAY_OFFSET = Duration.ofSeconds(10);\n+\n+    private final Logger logger = LoggerFactory.getLogger(SDS011Handler.class);\n+    private final SerialPortManager serialPortManager;\n+\n+    private @NonNullByDefault({}) NovaFineDustConfiguration config;\n+    private @NonNullByDefault({}) SDS011Communicator communicator;\n+\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+    private @Nullable ScheduledFuture<?> connectionMonitor;\n+\n+    private Temporal lastCommunication = ZonedDateTime.now();\n+\n+    // initialize timeBetweenDataShouldArrive with a large number\n+    private Duration timeBetweenDataShouldArrive = Duration.ofDays(1);\n+    private final Duration dataCanBeLateTollerance = Duration.ofSeconds(5);\n+\n+    public SDS011Handler(Thing thing, SerialPortManager serialPortManager) {\n+        super(thing);\n+        this.serialPortManager = serialPortManager;\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        // we do not support refreshing as values are either reported by the device or polled from the device in fixed\n+        // intervals\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        config = getConfigAs(NovaFineDustConfiguration.class);\n+\n+        if (!validateConfiguration()) {\n+            return;\n+        }\n+\n+        // parse ports and if the port is found, initialize the reader\n+        SerialPortIdentifier portId = serialPortManager.getIdentifier(config.port);\n+        if (portId == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR, \"Port is not known!\");\n+            return;\n+        }\n+\n+        this.communicator = new SDS011Communicator(this, portId);\n+\n+        if (config.reporting) {\n+            timeBetweenDataShouldArrive = Duration.ofMinutes(config.reportingInterval);\n+            scheduler.schedule(() -> initializeCommunicator(WorkMode.REPORTING, timeBetweenDataShouldArrive), 0,\n+                    TimeUnit.SECONDS);\n+        } else {\n+            timeBetweenDataShouldArrive = Duration.ofSeconds(config.pollingInterval);\n+            scheduler.schedule(() -> initializeCommunicator(WorkMode.POLLING, timeBetweenDataShouldArrive), 0,\n+                    TimeUnit.SECONDS);\n+        }\n+\n+        Duration connectionMonitorStartDelay = timeBetweenDataShouldArrive.plus(CONNECTION_MONITOR_START_DELAY_OFFSET);\n+        connectionMonitor = scheduler.scheduleWithFixedDelay(this::verifyIfStillConnected,\n+                connectionMonitorStartDelay.getSeconds(), timeBetweenDataShouldArrive.getSeconds(), TimeUnit.SECONDS);\n+    }\n+\n+    private void initializeCommunicator(WorkMode mode, Duration interval) {\n+        boolean initSuccessful = false;\n+        try {\n+            initSuccessful = communicator.initialize(mode, interval);\n+        } catch (final IOException ex) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR, \"I/O error!\");\n+            return;\n+        } catch (PortInUseException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR, \"Port is in use!\");\n+            return;\n+        } catch (TooManyListenersException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                    \"Cannot attach listener to port!\");\n+            return;\n+        } catch (UnsupportedCommOperationException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                    \"Cannot set serial port parameters\");\n+            return;\n+        }\n+\n+        if (initSuccessful) {\n+            lastCommunication = ZonedDateTime.now();\n+            updateStatus(ThingStatus.ONLINE);\n+\n+            if (mode == WorkMode.POLLING) {\n+                pollingJob = scheduler.scheduleWithFixedDelay(() -> {\n+                    try {\n+                        communicator.requestSensorData();\n+                    } catch (IOException e) {\n+                        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTQyNDE3OA=="}, "originalCommit": {"oid": "17ab9e48eb7ee697b10405fcdabcba5a6d99288a"}, "originalPosition": 144}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY3NDQzNTY1OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.novafinedust/src/main/java/org/openhab/binding/novafinedust/internal/SDS011Handler.java", "isResolved": false, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMlQxOTo0MDoxN1rOGZiBFw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNlQxNjoyMzowNFrOGamPTA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTQyNDkxOQ==", "bodyText": "You don't need to check the config again, if you configured min/max etc. in the XML files.", "url": "https://github.com/openhab/openhab-addons/pull/7528#discussion_r429424919", "createdAt": "2020-05-22T19:40:17Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.novafinedust/src/main/java/org/openhab/binding/novafinedust/internal/SDS011Handler.java", "diffHunk": "@@ -0,0 +1,244 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.novafinedust.internal;\n+\n+import java.io.IOException;\n+import java.time.Duration;\n+import java.time.ZonedDateTime;\n+import java.time.chrono.ChronoZonedDateTime;\n+import java.time.temporal.Temporal;\n+import java.util.TooManyListenersException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.dimension.Density;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.unit.SmartHomeUnits;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.io.transport.serial.PortInUseException;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortIdentifier;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.eclipse.smarthome.io.transport.serial.UnsupportedCommOperationException;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.SDS011Communicator;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.WorkMode;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.SensorMeasuredDataReply;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link SDS011Handler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Stefan Triller - Initial contribution\n+ */\n+@NonNullByDefault\n+public class SDS011Handler extends BaseThingHandler {\n+    private static final Duration CONNECTION_MONITOR_START_DELAY_OFFSET = Duration.ofSeconds(10);\n+\n+    private final Logger logger = LoggerFactory.getLogger(SDS011Handler.class);\n+    private final SerialPortManager serialPortManager;\n+\n+    private @NonNullByDefault({}) NovaFineDustConfiguration config;\n+    private @NonNullByDefault({}) SDS011Communicator communicator;\n+\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+    private @Nullable ScheduledFuture<?> connectionMonitor;\n+\n+    private Temporal lastCommunication = ZonedDateTime.now();\n+\n+    // initialize timeBetweenDataShouldArrive with a large number\n+    private Duration timeBetweenDataShouldArrive = Duration.ofDays(1);\n+    private final Duration dataCanBeLateTollerance = Duration.ofSeconds(5);\n+\n+    public SDS011Handler(Thing thing, SerialPortManager serialPortManager) {\n+        super(thing);\n+        this.serialPortManager = serialPortManager;\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        // we do not support refreshing as values are either reported by the device or polled from the device in fixed\n+        // intervals\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        config = getConfigAs(NovaFineDustConfiguration.class);\n+\n+        if (!validateConfiguration()) {\n+            return;\n+        }\n+\n+        // parse ports and if the port is found, initialize the reader\n+        SerialPortIdentifier portId = serialPortManager.getIdentifier(config.port);\n+        if (portId == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR, \"Port is not known!\");\n+            return;\n+        }\n+\n+        this.communicator = new SDS011Communicator(this, portId);\n+\n+        if (config.reporting) {\n+            timeBetweenDataShouldArrive = Duration.ofMinutes(config.reportingInterval);\n+            scheduler.schedule(() -> initializeCommunicator(WorkMode.REPORTING, timeBetweenDataShouldArrive), 0,\n+                    TimeUnit.SECONDS);\n+        } else {\n+            timeBetweenDataShouldArrive = Duration.ofSeconds(config.pollingInterval);\n+            scheduler.schedule(() -> initializeCommunicator(WorkMode.POLLING, timeBetweenDataShouldArrive), 0,\n+                    TimeUnit.SECONDS);\n+        }\n+\n+        Duration connectionMonitorStartDelay = timeBetweenDataShouldArrive.plus(CONNECTION_MONITOR_START_DELAY_OFFSET);\n+        connectionMonitor = scheduler.scheduleWithFixedDelay(this::verifyIfStillConnected,\n+                connectionMonitorStartDelay.getSeconds(), timeBetweenDataShouldArrive.getSeconds(), TimeUnit.SECONDS);\n+    }\n+\n+    private void initializeCommunicator(WorkMode mode, Duration interval) {\n+        boolean initSuccessful = false;\n+        try {\n+            initSuccessful = communicator.initialize(mode, interval);\n+        } catch (final IOException ex) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR, \"I/O error!\");\n+            return;\n+        } catch (PortInUseException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR, \"Port is in use!\");\n+            return;\n+        } catch (TooManyListenersException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                    \"Cannot attach listener to port!\");\n+            return;\n+        } catch (UnsupportedCommOperationException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                    \"Cannot set serial port parameters\");\n+            return;\n+        }\n+\n+        if (initSuccessful) {\n+            lastCommunication = ZonedDateTime.now();\n+            updateStatus(ThingStatus.ONLINE);\n+\n+            if (mode == WorkMode.POLLING) {\n+                pollingJob = scheduler.scheduleWithFixedDelay(() -> {\n+                    try {\n+                        communicator.requestSensorData();\n+                    } catch (IOException e) {\n+                        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                                \"Cannot query data from device\");\n+                    }\n+                }, 2, config.pollingInterval, TimeUnit.SECONDS);\n+            }\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                    \"Commands and replies from the device don't seem to match\");\n+            logger.debug(\"Could not configure sensor -> setting Thing to OFFLINE and disposing the handler\");\n+            dispose();\n+        }\n+    }\n+\n+    private boolean validateConfiguration() {\n+        if (config.port == null || config.port.isEmpty()) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR, \"Port must be set!\");\n+            return false;\n+        }\n+\n+        if (config.reporting) {\n+            if (config.reportingInterval < 0 || config.reportingInterval > 30) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR,\n+                        \"Reporting interval has to be between 0 and 30 minutes\");\n+                return false;\n+            }\n+        } else {\n+            if (config.pollingInterval < 3 || config.pollingInterval > 3600) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR,\n+                        \"Polling interval has to be between 3 and 3600 seconds\");\n+                return false;\n+            }\n+        }\n+        return true;\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "17ab9e48eb7ee697b10405fcdabcba5a6d99288a"}, "originalPosition": 177}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTU0NDMwMg==", "bodyText": "Oh wow, so openHAB now validates these values before passing them to the handler? That's cool, I didn't know that this was implemented. Thanks for letting me know. I have removed the checks.", "url": "https://github.com/openhab/openhab-addons/pull/7528#discussion_r429544302", "createdAt": "2020-05-23T13:01:06Z", "author": {"login": "t2000"}, "path": "bundles/org.openhab.binding.novafinedust/src/main/java/org/openhab/binding/novafinedust/internal/SDS011Handler.java", "diffHunk": "@@ -0,0 +1,244 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.novafinedust.internal;\n+\n+import java.io.IOException;\n+import java.time.Duration;\n+import java.time.ZonedDateTime;\n+import java.time.chrono.ChronoZonedDateTime;\n+import java.time.temporal.Temporal;\n+import java.util.TooManyListenersException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.dimension.Density;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.unit.SmartHomeUnits;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.io.transport.serial.PortInUseException;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortIdentifier;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.eclipse.smarthome.io.transport.serial.UnsupportedCommOperationException;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.SDS011Communicator;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.WorkMode;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.SensorMeasuredDataReply;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link SDS011Handler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Stefan Triller - Initial contribution\n+ */\n+@NonNullByDefault\n+public class SDS011Handler extends BaseThingHandler {\n+    private static final Duration CONNECTION_MONITOR_START_DELAY_OFFSET = Duration.ofSeconds(10);\n+\n+    private final Logger logger = LoggerFactory.getLogger(SDS011Handler.class);\n+    private final SerialPortManager serialPortManager;\n+\n+    private @NonNullByDefault({}) NovaFineDustConfiguration config;\n+    private @NonNullByDefault({}) SDS011Communicator communicator;\n+\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+    private @Nullable ScheduledFuture<?> connectionMonitor;\n+\n+    private Temporal lastCommunication = ZonedDateTime.now();\n+\n+    // initialize timeBetweenDataShouldArrive with a large number\n+    private Duration timeBetweenDataShouldArrive = Duration.ofDays(1);\n+    private final Duration dataCanBeLateTollerance = Duration.ofSeconds(5);\n+\n+    public SDS011Handler(Thing thing, SerialPortManager serialPortManager) {\n+        super(thing);\n+        this.serialPortManager = serialPortManager;\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        // we do not support refreshing as values are either reported by the device or polled from the device in fixed\n+        // intervals\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        config = getConfigAs(NovaFineDustConfiguration.class);\n+\n+        if (!validateConfiguration()) {\n+            return;\n+        }\n+\n+        // parse ports and if the port is found, initialize the reader\n+        SerialPortIdentifier portId = serialPortManager.getIdentifier(config.port);\n+        if (portId == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR, \"Port is not known!\");\n+            return;\n+        }\n+\n+        this.communicator = new SDS011Communicator(this, portId);\n+\n+        if (config.reporting) {\n+            timeBetweenDataShouldArrive = Duration.ofMinutes(config.reportingInterval);\n+            scheduler.schedule(() -> initializeCommunicator(WorkMode.REPORTING, timeBetweenDataShouldArrive), 0,\n+                    TimeUnit.SECONDS);\n+        } else {\n+            timeBetweenDataShouldArrive = Duration.ofSeconds(config.pollingInterval);\n+            scheduler.schedule(() -> initializeCommunicator(WorkMode.POLLING, timeBetweenDataShouldArrive), 0,\n+                    TimeUnit.SECONDS);\n+        }\n+\n+        Duration connectionMonitorStartDelay = timeBetweenDataShouldArrive.plus(CONNECTION_MONITOR_START_DELAY_OFFSET);\n+        connectionMonitor = scheduler.scheduleWithFixedDelay(this::verifyIfStillConnected,\n+                connectionMonitorStartDelay.getSeconds(), timeBetweenDataShouldArrive.getSeconds(), TimeUnit.SECONDS);\n+    }\n+\n+    private void initializeCommunicator(WorkMode mode, Duration interval) {\n+        boolean initSuccessful = false;\n+        try {\n+            initSuccessful = communicator.initialize(mode, interval);\n+        } catch (final IOException ex) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR, \"I/O error!\");\n+            return;\n+        } catch (PortInUseException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR, \"Port is in use!\");\n+            return;\n+        } catch (TooManyListenersException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                    \"Cannot attach listener to port!\");\n+            return;\n+        } catch (UnsupportedCommOperationException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                    \"Cannot set serial port parameters\");\n+            return;\n+        }\n+\n+        if (initSuccessful) {\n+            lastCommunication = ZonedDateTime.now();\n+            updateStatus(ThingStatus.ONLINE);\n+\n+            if (mode == WorkMode.POLLING) {\n+                pollingJob = scheduler.scheduleWithFixedDelay(() -> {\n+                    try {\n+                        communicator.requestSensorData();\n+                    } catch (IOException e) {\n+                        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                                \"Cannot query data from device\");\n+                    }\n+                }, 2, config.pollingInterval, TimeUnit.SECONDS);\n+            }\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                    \"Commands and replies from the device don't seem to match\");\n+            logger.debug(\"Could not configure sensor -> setting Thing to OFFLINE and disposing the handler\");\n+            dispose();\n+        }\n+    }\n+\n+    private boolean validateConfiguration() {\n+        if (config.port == null || config.port.isEmpty()) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR, \"Port must be set!\");\n+            return false;\n+        }\n+\n+        if (config.reporting) {\n+            if (config.reportingInterval < 0 || config.reportingInterval > 30) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR,\n+                        \"Reporting interval has to be between 0 and 30 minutes\");\n+                return false;\n+            }\n+        } else {\n+            if (config.pollingInterval < 3 || config.pollingInterval > 3600) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR,\n+                        \"Polling interval has to be between 3 and 3600 seconds\");\n+                return false;\n+            }\n+        }\n+        return true;\n+    }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTQyNDkxOQ=="}, "originalCommit": {"oid": "17ab9e48eb7ee697b10405fcdabcba5a6d99288a"}, "originalPosition": 177}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDA3NzMzMg==", "bodyText": "I'm afraid I have to retract my words. The config is only validated in Paper UI, but not when configuring via a things file. @cpmeister should bindings double check their config?", "url": "https://github.com/openhab/openhab-addons/pull/7528#discussion_r430077332", "createdAt": "2020-05-25T21:22:01Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.novafinedust/src/main/java/org/openhab/binding/novafinedust/internal/SDS011Handler.java", "diffHunk": "@@ -0,0 +1,244 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.novafinedust.internal;\n+\n+import java.io.IOException;\n+import java.time.Duration;\n+import java.time.ZonedDateTime;\n+import java.time.chrono.ChronoZonedDateTime;\n+import java.time.temporal.Temporal;\n+import java.util.TooManyListenersException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.dimension.Density;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.unit.SmartHomeUnits;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.io.transport.serial.PortInUseException;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortIdentifier;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.eclipse.smarthome.io.transport.serial.UnsupportedCommOperationException;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.SDS011Communicator;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.WorkMode;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.SensorMeasuredDataReply;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link SDS011Handler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Stefan Triller - Initial contribution\n+ */\n+@NonNullByDefault\n+public class SDS011Handler extends BaseThingHandler {\n+    private static final Duration CONNECTION_MONITOR_START_DELAY_OFFSET = Duration.ofSeconds(10);\n+\n+    private final Logger logger = LoggerFactory.getLogger(SDS011Handler.class);\n+    private final SerialPortManager serialPortManager;\n+\n+    private @NonNullByDefault({}) NovaFineDustConfiguration config;\n+    private @NonNullByDefault({}) SDS011Communicator communicator;\n+\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+    private @Nullable ScheduledFuture<?> connectionMonitor;\n+\n+    private Temporal lastCommunication = ZonedDateTime.now();\n+\n+    // initialize timeBetweenDataShouldArrive with a large number\n+    private Duration timeBetweenDataShouldArrive = Duration.ofDays(1);\n+    private final Duration dataCanBeLateTollerance = Duration.ofSeconds(5);\n+\n+    public SDS011Handler(Thing thing, SerialPortManager serialPortManager) {\n+        super(thing);\n+        this.serialPortManager = serialPortManager;\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        // we do not support refreshing as values are either reported by the device or polled from the device in fixed\n+        // intervals\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        config = getConfigAs(NovaFineDustConfiguration.class);\n+\n+        if (!validateConfiguration()) {\n+            return;\n+        }\n+\n+        // parse ports and if the port is found, initialize the reader\n+        SerialPortIdentifier portId = serialPortManager.getIdentifier(config.port);\n+        if (portId == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR, \"Port is not known!\");\n+            return;\n+        }\n+\n+        this.communicator = new SDS011Communicator(this, portId);\n+\n+        if (config.reporting) {\n+            timeBetweenDataShouldArrive = Duration.ofMinutes(config.reportingInterval);\n+            scheduler.schedule(() -> initializeCommunicator(WorkMode.REPORTING, timeBetweenDataShouldArrive), 0,\n+                    TimeUnit.SECONDS);\n+        } else {\n+            timeBetweenDataShouldArrive = Duration.ofSeconds(config.pollingInterval);\n+            scheduler.schedule(() -> initializeCommunicator(WorkMode.POLLING, timeBetweenDataShouldArrive), 0,\n+                    TimeUnit.SECONDS);\n+        }\n+\n+        Duration connectionMonitorStartDelay = timeBetweenDataShouldArrive.plus(CONNECTION_MONITOR_START_DELAY_OFFSET);\n+        connectionMonitor = scheduler.scheduleWithFixedDelay(this::verifyIfStillConnected,\n+                connectionMonitorStartDelay.getSeconds(), timeBetweenDataShouldArrive.getSeconds(), TimeUnit.SECONDS);\n+    }\n+\n+    private void initializeCommunicator(WorkMode mode, Duration interval) {\n+        boolean initSuccessful = false;\n+        try {\n+            initSuccessful = communicator.initialize(mode, interval);\n+        } catch (final IOException ex) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR, \"I/O error!\");\n+            return;\n+        } catch (PortInUseException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR, \"Port is in use!\");\n+            return;\n+        } catch (TooManyListenersException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                    \"Cannot attach listener to port!\");\n+            return;\n+        } catch (UnsupportedCommOperationException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                    \"Cannot set serial port parameters\");\n+            return;\n+        }\n+\n+        if (initSuccessful) {\n+            lastCommunication = ZonedDateTime.now();\n+            updateStatus(ThingStatus.ONLINE);\n+\n+            if (mode == WorkMode.POLLING) {\n+                pollingJob = scheduler.scheduleWithFixedDelay(() -> {\n+                    try {\n+                        communicator.requestSensorData();\n+                    } catch (IOException e) {\n+                        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                                \"Cannot query data from device\");\n+                    }\n+                }, 2, config.pollingInterval, TimeUnit.SECONDS);\n+            }\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                    \"Commands and replies from the device don't seem to match\");\n+            logger.debug(\"Could not configure sensor -> setting Thing to OFFLINE and disposing the handler\");\n+            dispose();\n+        }\n+    }\n+\n+    private boolean validateConfiguration() {\n+        if (config.port == null || config.port.isEmpty()) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR, \"Port must be set!\");\n+            return false;\n+        }\n+\n+        if (config.reporting) {\n+            if (config.reportingInterval < 0 || config.reportingInterval > 30) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR,\n+                        \"Reporting interval has to be between 0 and 30 minutes\");\n+                return false;\n+            }\n+        } else {\n+            if (config.pollingInterval < 3 || config.pollingInterval > 3600) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR,\n+                        \"Polling interval has to be between 3 and 3600 seconds\");\n+                return false;\n+            }\n+        }\n+        return true;\n+    }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTQyNDkxOQ=="}, "originalCommit": {"oid": "17ab9e48eb7ee697b10405fcdabcba5a6d99288a"}, "originalPosition": 177}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDEwNTYzMw==", "bodyText": "It is always better if the binding double checks the configs.", "url": "https://github.com/openhab/openhab-addons/pull/7528#discussion_r430105633", "createdAt": "2020-05-26T00:35:35Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.novafinedust/src/main/java/org/openhab/binding/novafinedust/internal/SDS011Handler.java", "diffHunk": "@@ -0,0 +1,244 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.novafinedust.internal;\n+\n+import java.io.IOException;\n+import java.time.Duration;\n+import java.time.ZonedDateTime;\n+import java.time.chrono.ChronoZonedDateTime;\n+import java.time.temporal.Temporal;\n+import java.util.TooManyListenersException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.dimension.Density;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.unit.SmartHomeUnits;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.io.transport.serial.PortInUseException;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortIdentifier;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.eclipse.smarthome.io.transport.serial.UnsupportedCommOperationException;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.SDS011Communicator;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.WorkMode;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.SensorMeasuredDataReply;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link SDS011Handler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Stefan Triller - Initial contribution\n+ */\n+@NonNullByDefault\n+public class SDS011Handler extends BaseThingHandler {\n+    private static final Duration CONNECTION_MONITOR_START_DELAY_OFFSET = Duration.ofSeconds(10);\n+\n+    private final Logger logger = LoggerFactory.getLogger(SDS011Handler.class);\n+    private final SerialPortManager serialPortManager;\n+\n+    private @NonNullByDefault({}) NovaFineDustConfiguration config;\n+    private @NonNullByDefault({}) SDS011Communicator communicator;\n+\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+    private @Nullable ScheduledFuture<?> connectionMonitor;\n+\n+    private Temporal lastCommunication = ZonedDateTime.now();\n+\n+    // initialize timeBetweenDataShouldArrive with a large number\n+    private Duration timeBetweenDataShouldArrive = Duration.ofDays(1);\n+    private final Duration dataCanBeLateTollerance = Duration.ofSeconds(5);\n+\n+    public SDS011Handler(Thing thing, SerialPortManager serialPortManager) {\n+        super(thing);\n+        this.serialPortManager = serialPortManager;\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        // we do not support refreshing as values are either reported by the device or polled from the device in fixed\n+        // intervals\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        config = getConfigAs(NovaFineDustConfiguration.class);\n+\n+        if (!validateConfiguration()) {\n+            return;\n+        }\n+\n+        // parse ports and if the port is found, initialize the reader\n+        SerialPortIdentifier portId = serialPortManager.getIdentifier(config.port);\n+        if (portId == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR, \"Port is not known!\");\n+            return;\n+        }\n+\n+        this.communicator = new SDS011Communicator(this, portId);\n+\n+        if (config.reporting) {\n+            timeBetweenDataShouldArrive = Duration.ofMinutes(config.reportingInterval);\n+            scheduler.schedule(() -> initializeCommunicator(WorkMode.REPORTING, timeBetweenDataShouldArrive), 0,\n+                    TimeUnit.SECONDS);\n+        } else {\n+            timeBetweenDataShouldArrive = Duration.ofSeconds(config.pollingInterval);\n+            scheduler.schedule(() -> initializeCommunicator(WorkMode.POLLING, timeBetweenDataShouldArrive), 0,\n+                    TimeUnit.SECONDS);\n+        }\n+\n+        Duration connectionMonitorStartDelay = timeBetweenDataShouldArrive.plus(CONNECTION_MONITOR_START_DELAY_OFFSET);\n+        connectionMonitor = scheduler.scheduleWithFixedDelay(this::verifyIfStillConnected,\n+                connectionMonitorStartDelay.getSeconds(), timeBetweenDataShouldArrive.getSeconds(), TimeUnit.SECONDS);\n+    }\n+\n+    private void initializeCommunicator(WorkMode mode, Duration interval) {\n+        boolean initSuccessful = false;\n+        try {\n+            initSuccessful = communicator.initialize(mode, interval);\n+        } catch (final IOException ex) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR, \"I/O error!\");\n+            return;\n+        } catch (PortInUseException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR, \"Port is in use!\");\n+            return;\n+        } catch (TooManyListenersException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                    \"Cannot attach listener to port!\");\n+            return;\n+        } catch (UnsupportedCommOperationException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                    \"Cannot set serial port parameters\");\n+            return;\n+        }\n+\n+        if (initSuccessful) {\n+            lastCommunication = ZonedDateTime.now();\n+            updateStatus(ThingStatus.ONLINE);\n+\n+            if (mode == WorkMode.POLLING) {\n+                pollingJob = scheduler.scheduleWithFixedDelay(() -> {\n+                    try {\n+                        communicator.requestSensorData();\n+                    } catch (IOException e) {\n+                        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                                \"Cannot query data from device\");\n+                    }\n+                }, 2, config.pollingInterval, TimeUnit.SECONDS);\n+            }\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                    \"Commands and replies from the device don't seem to match\");\n+            logger.debug(\"Could not configure sensor -> setting Thing to OFFLINE and disposing the handler\");\n+            dispose();\n+        }\n+    }\n+\n+    private boolean validateConfiguration() {\n+        if (config.port == null || config.port.isEmpty()) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR, \"Port must be set!\");\n+            return false;\n+        }\n+\n+        if (config.reporting) {\n+            if (config.reportingInterval < 0 || config.reportingInterval > 30) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR,\n+                        \"Reporting interval has to be between 0 and 30 minutes\");\n+                return false;\n+            }\n+        } else {\n+            if (config.pollingInterval < 3 || config.pollingInterval > 3600) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR,\n+                        \"Polling interval has to be between 3 and 3600 seconds\");\n+                return false;\n+            }\n+        }\n+        return true;\n+    }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTQyNDkxOQ=="}, "originalCommit": {"oid": "17ab9e48eb7ee697b10405fcdabcba5a6d99288a"}, "originalPosition": 177}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDU0MjY2OA==", "bodyText": "Alright, I have reverted the removal of the check, so it is back in place.", "url": "https://github.com/openhab/openhab-addons/pull/7528#discussion_r430542668", "createdAt": "2020-05-26T16:23:04Z", "author": {"login": "t2000"}, "path": "bundles/org.openhab.binding.novafinedust/src/main/java/org/openhab/binding/novafinedust/internal/SDS011Handler.java", "diffHunk": "@@ -0,0 +1,244 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.novafinedust.internal;\n+\n+import java.io.IOException;\n+import java.time.Duration;\n+import java.time.ZonedDateTime;\n+import java.time.chrono.ChronoZonedDateTime;\n+import java.time.temporal.Temporal;\n+import java.util.TooManyListenersException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.dimension.Density;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.unit.SmartHomeUnits;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.io.transport.serial.PortInUseException;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortIdentifier;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.eclipse.smarthome.io.transport.serial.UnsupportedCommOperationException;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.SDS011Communicator;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.WorkMode;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.SensorMeasuredDataReply;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link SDS011Handler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Stefan Triller - Initial contribution\n+ */\n+@NonNullByDefault\n+public class SDS011Handler extends BaseThingHandler {\n+    private static final Duration CONNECTION_MONITOR_START_DELAY_OFFSET = Duration.ofSeconds(10);\n+\n+    private final Logger logger = LoggerFactory.getLogger(SDS011Handler.class);\n+    private final SerialPortManager serialPortManager;\n+\n+    private @NonNullByDefault({}) NovaFineDustConfiguration config;\n+    private @NonNullByDefault({}) SDS011Communicator communicator;\n+\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+    private @Nullable ScheduledFuture<?> connectionMonitor;\n+\n+    private Temporal lastCommunication = ZonedDateTime.now();\n+\n+    // initialize timeBetweenDataShouldArrive with a large number\n+    private Duration timeBetweenDataShouldArrive = Duration.ofDays(1);\n+    private final Duration dataCanBeLateTollerance = Duration.ofSeconds(5);\n+\n+    public SDS011Handler(Thing thing, SerialPortManager serialPortManager) {\n+        super(thing);\n+        this.serialPortManager = serialPortManager;\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        // we do not support refreshing as values are either reported by the device or polled from the device in fixed\n+        // intervals\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        config = getConfigAs(NovaFineDustConfiguration.class);\n+\n+        if (!validateConfiguration()) {\n+            return;\n+        }\n+\n+        // parse ports and if the port is found, initialize the reader\n+        SerialPortIdentifier portId = serialPortManager.getIdentifier(config.port);\n+        if (portId == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR, \"Port is not known!\");\n+            return;\n+        }\n+\n+        this.communicator = new SDS011Communicator(this, portId);\n+\n+        if (config.reporting) {\n+            timeBetweenDataShouldArrive = Duration.ofMinutes(config.reportingInterval);\n+            scheduler.schedule(() -> initializeCommunicator(WorkMode.REPORTING, timeBetweenDataShouldArrive), 0,\n+                    TimeUnit.SECONDS);\n+        } else {\n+            timeBetweenDataShouldArrive = Duration.ofSeconds(config.pollingInterval);\n+            scheduler.schedule(() -> initializeCommunicator(WorkMode.POLLING, timeBetweenDataShouldArrive), 0,\n+                    TimeUnit.SECONDS);\n+        }\n+\n+        Duration connectionMonitorStartDelay = timeBetweenDataShouldArrive.plus(CONNECTION_MONITOR_START_DELAY_OFFSET);\n+        connectionMonitor = scheduler.scheduleWithFixedDelay(this::verifyIfStillConnected,\n+                connectionMonitorStartDelay.getSeconds(), timeBetweenDataShouldArrive.getSeconds(), TimeUnit.SECONDS);\n+    }\n+\n+    private void initializeCommunicator(WorkMode mode, Duration interval) {\n+        boolean initSuccessful = false;\n+        try {\n+            initSuccessful = communicator.initialize(mode, interval);\n+        } catch (final IOException ex) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR, \"I/O error!\");\n+            return;\n+        } catch (PortInUseException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR, \"Port is in use!\");\n+            return;\n+        } catch (TooManyListenersException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                    \"Cannot attach listener to port!\");\n+            return;\n+        } catch (UnsupportedCommOperationException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                    \"Cannot set serial port parameters\");\n+            return;\n+        }\n+\n+        if (initSuccessful) {\n+            lastCommunication = ZonedDateTime.now();\n+            updateStatus(ThingStatus.ONLINE);\n+\n+            if (mode == WorkMode.POLLING) {\n+                pollingJob = scheduler.scheduleWithFixedDelay(() -> {\n+                    try {\n+                        communicator.requestSensorData();\n+                    } catch (IOException e) {\n+                        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                                \"Cannot query data from device\");\n+                    }\n+                }, 2, config.pollingInterval, TimeUnit.SECONDS);\n+            }\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                    \"Commands and replies from the device don't seem to match\");\n+            logger.debug(\"Could not configure sensor -> setting Thing to OFFLINE and disposing the handler\");\n+            dispose();\n+        }\n+    }\n+\n+    private boolean validateConfiguration() {\n+        if (config.port == null || config.port.isEmpty()) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR, \"Port must be set!\");\n+            return false;\n+        }\n+\n+        if (config.reporting) {\n+            if (config.reportingInterval < 0 || config.reportingInterval > 30) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR,\n+                        \"Reporting interval has to be between 0 and 30 minutes\");\n+                return false;\n+            }\n+        } else {\n+            if (config.pollingInterval < 3 || config.pollingInterval > 3600) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR,\n+                        \"Polling interval has to be between 3 and 3600 seconds\");\n+                return false;\n+            }\n+        }\n+        return true;\n+    }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTQyNDkxOQ=="}, "originalCommit": {"oid": "17ab9e48eb7ee697b10405fcdabcba5a6d99288a"}, "originalPosition": 177}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY3NDQ0NTUwOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.novafinedust/src/main/java/org/openhab/binding/novafinedust/internal/SDS011Handler.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMlQxOTo0NDo0MFrOGZiHHQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMlQxOTo0NDo0MFrOGZiHHQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTQyNjQ2MQ==", "bodyText": "If you use ZonedDateTime instead of Temporal, you could remove this cast.", "url": "https://github.com/openhab/openhab-addons/pull/7528#discussion_r429426461", "createdAt": "2020-05-22T19:44:40Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.novafinedust/src/main/java/org/openhab/binding/novafinedust/internal/SDS011Handler.java", "diffHunk": "@@ -0,0 +1,244 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.novafinedust.internal;\n+\n+import java.io.IOException;\n+import java.time.Duration;\n+import java.time.ZonedDateTime;\n+import java.time.chrono.ChronoZonedDateTime;\n+import java.time.temporal.Temporal;\n+import java.util.TooManyListenersException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.dimension.Density;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.unit.SmartHomeUnits;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.io.transport.serial.PortInUseException;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortIdentifier;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.eclipse.smarthome.io.transport.serial.UnsupportedCommOperationException;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.SDS011Communicator;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.WorkMode;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.SensorMeasuredDataReply;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link SDS011Handler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Stefan Triller - Initial contribution\n+ */\n+@NonNullByDefault\n+public class SDS011Handler extends BaseThingHandler {\n+    private static final Duration CONNECTION_MONITOR_START_DELAY_OFFSET = Duration.ofSeconds(10);\n+\n+    private final Logger logger = LoggerFactory.getLogger(SDS011Handler.class);\n+    private final SerialPortManager serialPortManager;\n+\n+    private @NonNullByDefault({}) NovaFineDustConfiguration config;\n+    private @NonNullByDefault({}) SDS011Communicator communicator;\n+\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+    private @Nullable ScheduledFuture<?> connectionMonitor;\n+\n+    private Temporal lastCommunication = ZonedDateTime.now();\n+\n+    // initialize timeBetweenDataShouldArrive with a large number\n+    private Duration timeBetweenDataShouldArrive = Duration.ofDays(1);\n+    private final Duration dataCanBeLateTollerance = Duration.ofSeconds(5);\n+\n+    public SDS011Handler(Thing thing, SerialPortManager serialPortManager) {\n+        super(thing);\n+        this.serialPortManager = serialPortManager;\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        // we do not support refreshing as values are either reported by the device or polled from the device in fixed\n+        // intervals\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        config = getConfigAs(NovaFineDustConfiguration.class);\n+\n+        if (!validateConfiguration()) {\n+            return;\n+        }\n+\n+        // parse ports and if the port is found, initialize the reader\n+        SerialPortIdentifier portId = serialPortManager.getIdentifier(config.port);\n+        if (portId == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR, \"Port is not known!\");\n+            return;\n+        }\n+\n+        this.communicator = new SDS011Communicator(this, portId);\n+\n+        if (config.reporting) {\n+            timeBetweenDataShouldArrive = Duration.ofMinutes(config.reportingInterval);\n+            scheduler.schedule(() -> initializeCommunicator(WorkMode.REPORTING, timeBetweenDataShouldArrive), 0,\n+                    TimeUnit.SECONDS);\n+        } else {\n+            timeBetweenDataShouldArrive = Duration.ofSeconds(config.pollingInterval);\n+            scheduler.schedule(() -> initializeCommunicator(WorkMode.POLLING, timeBetweenDataShouldArrive), 0,\n+                    TimeUnit.SECONDS);\n+        }\n+\n+        Duration connectionMonitorStartDelay = timeBetweenDataShouldArrive.plus(CONNECTION_MONITOR_START_DELAY_OFFSET);\n+        connectionMonitor = scheduler.scheduleWithFixedDelay(this::verifyIfStillConnected,\n+                connectionMonitorStartDelay.getSeconds(), timeBetweenDataShouldArrive.getSeconds(), TimeUnit.SECONDS);\n+    }\n+\n+    private void initializeCommunicator(WorkMode mode, Duration interval) {\n+        boolean initSuccessful = false;\n+        try {\n+            initSuccessful = communicator.initialize(mode, interval);\n+        } catch (final IOException ex) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR, \"I/O error!\");\n+            return;\n+        } catch (PortInUseException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR, \"Port is in use!\");\n+            return;\n+        } catch (TooManyListenersException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                    \"Cannot attach listener to port!\");\n+            return;\n+        } catch (UnsupportedCommOperationException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                    \"Cannot set serial port parameters\");\n+            return;\n+        }\n+\n+        if (initSuccessful) {\n+            lastCommunication = ZonedDateTime.now();\n+            updateStatus(ThingStatus.ONLINE);\n+\n+            if (mode == WorkMode.POLLING) {\n+                pollingJob = scheduler.scheduleWithFixedDelay(() -> {\n+                    try {\n+                        communicator.requestSensorData();\n+                    } catch (IOException e) {\n+                        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                                \"Cannot query data from device\");\n+                    }\n+                }, 2, config.pollingInterval, TimeUnit.SECONDS);\n+            }\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                    \"Commands and replies from the device don't seem to match\");\n+            logger.debug(\"Could not configure sensor -> setting Thing to OFFLINE and disposing the handler\");\n+            dispose();\n+        }\n+    }\n+\n+    private boolean validateConfiguration() {\n+        if (config.port == null || config.port.isEmpty()) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR, \"Port must be set!\");\n+            return false;\n+        }\n+\n+        if (config.reporting) {\n+            if (config.reportingInterval < 0 || config.reportingInterval > 30) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR,\n+                        \"Reporting interval has to be between 0 and 30 minutes\");\n+                return false;\n+            }\n+        } else {\n+            if (config.pollingInterval < 3 || config.pollingInterval > 3600) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR,\n+                        \"Polling interval has to be between 3 and 3600 seconds\");\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        if (pollingJob != null && !pollingJob.isCancelled()) {\n+            pollingJob.cancel(true);\n+            pollingJob = null;\n+        }\n+\n+        if (connectionMonitor != null && !connectionMonitor.isCancelled()) {\n+            connectionMonitor.cancel(true);\n+            connectionMonitor = null;\n+        }\n+\n+        if (communicator != null) {\n+            scheduler.schedule(() -> communicator.dispose(), 0, TimeUnit.SECONDS);\n+        }\n+    }\n+\n+    /**\n+     * Pass the data from the device to the Thing channels\n+     *\n+     * @param sensorData the parsed data from the sensor\n+     */\n+    public void updateChannels(SensorMeasuredDataReply sensorData) {\n+        if (sensorData.isValidData()) {\n+            logger.debug(\"Updating channels with data: {}\", sensorData);\n+\n+            QuantityType<Density> statePM10 = new QuantityType<>(sensorData.getPm10(),\n+                    SmartHomeUnits.MICROGRAM_PER_CUBICMETRE);\n+            updateState(NovaFineDustBindingConstants.CHANNEL_PM10, statePM10);\n+\n+            QuantityType<Density> statePM25 = new QuantityType<>(sensorData.getPm25(),\n+                    SmartHomeUnits.MICROGRAM_PER_CUBICMETRE);\n+            updateState(NovaFineDustBindingConstants.CHANNEL_PM25, statePM25);\n+\n+            updateStatus(ThingStatus.ONLINE);\n+        }\n+        // there was a communication, even if the data was not valid, thus resetting the value here\n+        lastCommunication = ZonedDateTime.now();\n+    }\n+\n+    private void verifyIfStillConnected() {\n+        ZonedDateTime now = ZonedDateTime.now();\n+        Temporal lastData = lastCommunication.plus(timeBetweenDataShouldArrive).plus(dataCanBeLateTollerance);\n+        if (now.isAfter((ChronoZonedDateTime<?>) lastData)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "17ab9e48eb7ee697b10405fcdabcba5a6d99288a"}, "originalPosition": 222}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY3NDQ2ODM5OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.novafinedust/src/main/java/org/openhab/binding/novafinedust/internal/sds011protocol/SDS011Communicator.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMlQxOTo1NzowMlrOGZiVvA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMlQxOTo1NzowMlrOGZiVvA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTQzMDIwNA==", "bodyText": "Bindings should only log as error, when a bug in the code is detected. You could use warn here.", "url": "https://github.com/openhab/openhab-addons/pull/7528#discussion_r429430204", "createdAt": "2020-05-22T19:57:02Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.novafinedust/src/main/java/org/openhab/binding/novafinedust/internal/sds011protocol/SDS011Communicator.java", "diffHunk": "@@ -0,0 +1,287 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.novafinedust.internal.sds011protocol;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.time.Duration;\n+import java.util.Arrays;\n+import java.util.TooManyListenersException;\n+\n+import org.apache.commons.io.IOUtils;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.io.transport.serial.PortInUseException;\n+import org.eclipse.smarthome.io.transport.serial.SerialPort;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortEvent;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortEventListener;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortIdentifier;\n+import org.eclipse.smarthome.io.transport.serial.UnsupportedCommOperationException;\n+import org.openhab.binding.novafinedust.internal.SDS011Handler;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.CommandMessage;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.Constants;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.ModeReply;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.SensorFirmwareReply;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.SensorMeasuredDataReply;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.SensorReply;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.SleepReply;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.WorkingPeriodReply;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Central instance to communicate with the device, i.e. receive data from it and send commands to it\n+ *\n+ * @author Stefan Triller - Initial contribution\n+ *\n+ */\n+@NonNullByDefault\n+public class SDS011Communicator implements SerialPortEventListener {\n+\n+    private final Logger logger = LoggerFactory.getLogger(SDS011Communicator.class);\n+\n+    private SerialPortIdentifier portId;\n+    private SDS011Handler thingHandler;\n+    private @NonNullByDefault({}) SerialPort serialPort;\n+\n+    private @NonNullByDefault({}) OutputStream outputStream;\n+    private @NonNullByDefault({}) InputStream inputStream;\n+\n+    public SDS011Communicator(SDS011Handler thingHandler, SerialPortIdentifier portId) {\n+        this.thingHandler = thingHandler;\n+        this.portId = portId;\n+    }\n+\n+    /**\n+     * Initialize the communication with the device, i.e. open the serial port etc.\n+     *\n+     * @param mode the {@link WorkMode} if we want to use polling or reporting\n+     * @param interval the time between polling or reportings\n+     * @return {@code true} if we can communicate with the device\n+     * @throws PortInUseException\n+     * @throws TooManyListenersException\n+     * @throws IOException\n+     * @throws UnsupportedCommOperationException\n+     */\n+    public boolean initialize(WorkMode mode, Duration interval)\n+            throws PortInUseException, TooManyListenersException, IOException, UnsupportedCommOperationException {\n+        boolean initSuccessful = true;\n+\n+        SerialPort localSerialPort = portId.open(thingHandler.getThing().getUID().toString(), 2000);\n+        localSerialPort.setSerialPortParams(9600, 8, 1, 0);\n+\n+        outputStream = localSerialPort.getOutputStream();\n+        inputStream = localSerialPort.getInputStream();\n+\n+        if (inputStream == null || outputStream == null) {\n+            throw new IOException(\"Could not create input or outputstream for the port\");\n+        }\n+\n+        // wake up the device\n+        initSuccessful &= sendSleep(false);\n+        initSuccessful &= getFirmware();\n+\n+        if (mode == WorkMode.POLLING) {\n+            initSuccessful &= setMode(WorkMode.POLLING);\n+            initSuccessful &= setWorkingPeriod((byte) 0);\n+        } else {\n+            // reporting\n+            initSuccessful &= setWorkingPeriod((byte) interval.toMinutes());\n+            initSuccessful &= setMode(WorkMode.REPORTING);\n+        }\n+\n+        // enable listeners only after we have configured the sensor above because for configuring we send and read data\n+        // sequentially\n+        localSerialPort.notifyOnDataAvailable(true);\n+        localSerialPort.addEventListener(this);\n+        this.serialPort = localSerialPort;\n+\n+        return initSuccessful;\n+    }\n+\n+    private @Nullable SensorReply sendCommand(CommandMessage message) throws IOException {\n+        byte[] commandData = message.getBytes();\n+        if (logger.isDebugEnabled()) {\n+            logger.debug(\"Will send command: {} ({})\", Helper.toHexString(commandData), Arrays.toString(commandData));\n+        }\n+        outputStream.write(commandData, 0, commandData.length);\n+        outputStream.flush();\n+        try {\n+            // Give the sensor some time to handle the command\n+            Thread.sleep(500);\n+        } catch (InterruptedException e) {\n+            logger.warn(\"Problem while waiting for reading a reply to our command.\");\n+            Thread.currentThread().interrupt();\n+        }\n+        SensorReply reply = readReply();\n+        // in case there is still another reporting active, we want to discard the sensor data and read the reply to our\n+        // command again\n+        if (reply instanceof SensorMeasuredDataReply) {\n+            reply = readReply();\n+        }\n+        return reply;\n+    }\n+\n+    private boolean setWorkingPeriod(byte period) throws IOException {\n+        CommandMessage m = new CommandMessage(Command.WORKING_PERIOD, new byte[] { Constants.SET_ACTION, period });\n+        logger.debug(\"Sending work period: {}\", period);\n+        SensorReply reply = sendCommand(m);\n+        logger.debug(\"Got reply to setWorkingPeriod command: {}\", reply);\n+        if (reply instanceof WorkingPeriodReply) {\n+            WorkingPeriodReply wpReply = (WorkingPeriodReply) reply;\n+            if (wpReply.getPeriod() == period && wpReply.getActionType() == Constants.SET_ACTION) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    private boolean setMode(WorkMode workMode) throws IOException {\n+        byte haveToRequestData = 0;\n+        if (workMode == WorkMode.POLLING) {\n+            haveToRequestData = 1;\n+        }\n+\n+        CommandMessage m = new CommandMessage(Command.MODE, new byte[] { Constants.SET_ACTION, haveToRequestData });\n+        logger.debug(\"Sending mode: {}\", workMode);\n+        SensorReply reply = sendCommand(m);\n+        logger.debug(\"Got reply to setMode command: {}\", reply);\n+        if (reply instanceof ModeReply) {\n+            ModeReply mr = (ModeReply) reply;\n+            if (mr.getActionType() == Constants.SET_ACTION && mr.getMode() == workMode) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    private boolean sendSleep(boolean doSleep) throws IOException {\n+        byte payload = (byte) 1;\n+        if (doSleep) {\n+            payload = (byte) 0;\n+        }\n+\n+        CommandMessage m = new CommandMessage(Command.SLEEP, new byte[] { Constants.SET_ACTION, payload });\n+        logger.debug(\"Sending doSleep: {}\", doSleep);\n+        SensorReply reply = sendCommand(m);\n+        logger.debug(\"Got reply to sendSleep command: {}\", reply);\n+\n+        if (!doSleep) {\n+            // sometimes the sensor does not wakeup on the first attempt, thus we try again\n+            for (int i = 0; reply == null && i < 3; i++) {\n+                reply = sendCommand(m);\n+                logger.debug(\"Got reply to sendSleep command after retry#{}: {}\", i + 1, reply);\n+            }\n+        }\n+\n+        if (reply instanceof SleepReply) {\n+            SleepReply sr = (SleepReply) reply;\n+            if (sr.getActionType() == Constants.SET_ACTION && sr.getSleep() == payload) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    private boolean getFirmware() throws IOException {\n+        CommandMessage m = new CommandMessage(Command.FIRMWARE, new byte[] {});\n+        logger.debug(\"Sending get firmware request\");\n+        SensorReply reply = sendCommand(m);\n+        logger.debug(\"Got reply to getFirmware command: {}\", reply);\n+\n+        if (reply instanceof SensorFirmwareReply) {\n+            SensorFirmwareReply fwReply = (SensorFirmwareReply) reply;\n+            thingHandler.setFirmware(fwReply.getFirmware());\n+            return true;\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Request data from the device, they will be returned via the serialEvent callback\n+     *\n+     * @throws IOException\n+     */\n+    public void requestSensorData() throws IOException {\n+        CommandMessage m = new CommandMessage(Command.REQUEST_DATA, new byte[] {});\n+        byte[] data = m.getBytes();\n+        if (logger.isDebugEnabled()) {\n+            logger.debug(\"Requesting sensor data, will send: {}\", Helper.toHexString(data));\n+        }\n+        outputStream.write(data, 0, data.length);\n+    }\n+\n+    private @Nullable SensorReply readReply() throws IOException {\n+        byte[] readBuffer = new byte[Constants.REPLY_LENGTH];\n+\n+        int b = -1;\n+        if (inputStream.available() > 0) {\n+            while ((b = inputStream.read()) != Constants.MESSAGE_START_AS_INT) {\n+                logger.debug(\"Trying to find first reply byte now...\");\n+            }\n+            readBuffer[0] = (byte) b;\n+            int remainingBytesRead = inputStream.read(readBuffer, 1, Constants.REPLY_LENGTH - 1);\n+            if (logger.isDebugEnabled()) {\n+                logger.debug(\"Read remaining bytes: {}, full reply={}\", remainingBytesRead,\n+                        Helper.toHexString(readBuffer));\n+            }\n+            return ReplyFactory.create(readBuffer);\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * Data from the device is arriving and will be parsed accordingly\n+     */\n+    @Override\n+    public void serialEvent(SerialPortEvent event) {\n+        if (event.getEventType() == SerialPortEvent.DATA_AVAILABLE) {\n+            // we get here if data has been received\n+            SensorReply reply = null;\n+            try {\n+                reply = readReply();\n+                logger.debug(\"Got data from sensor: {}\", reply);\n+            } catch (IOException e) {\n+                logger.error(\"Could not read available data from the serial port\", e);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "17ab9e48eb7ee697b10405fcdabcba5a6d99288a"}, "originalPosition": 256}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY3NDQ3MzAzOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.novafinedust/src/main/java/org/openhab/binding/novafinedust/internal/sds011protocol/SDS011Communicator.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMlQyMDowMDoxMFrOGZiYuA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMlQyMDowMDoxMFrOGZiYuA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTQzMDk2OA==", "bodyText": "Since we are going to remove the Apache Commons dependencies, could you replace the lines with standard Java code? See #7722", "url": "https://github.com/openhab/openhab-addons/pull/7528#discussion_r429430968", "createdAt": "2020-05-22T20:00:10Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.novafinedust/src/main/java/org/openhab/binding/novafinedust/internal/sds011protocol/SDS011Communicator.java", "diffHunk": "@@ -0,0 +1,287 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.novafinedust.internal.sds011protocol;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.time.Duration;\n+import java.util.Arrays;\n+import java.util.TooManyListenersException;\n+\n+import org.apache.commons.io.IOUtils;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.io.transport.serial.PortInUseException;\n+import org.eclipse.smarthome.io.transport.serial.SerialPort;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortEvent;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortEventListener;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortIdentifier;\n+import org.eclipse.smarthome.io.transport.serial.UnsupportedCommOperationException;\n+import org.openhab.binding.novafinedust.internal.SDS011Handler;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.CommandMessage;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.Constants;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.ModeReply;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.SensorFirmwareReply;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.SensorMeasuredDataReply;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.SensorReply;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.SleepReply;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.WorkingPeriodReply;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Central instance to communicate with the device, i.e. receive data from it and send commands to it\n+ *\n+ * @author Stefan Triller - Initial contribution\n+ *\n+ */\n+@NonNullByDefault\n+public class SDS011Communicator implements SerialPortEventListener {\n+\n+    private final Logger logger = LoggerFactory.getLogger(SDS011Communicator.class);\n+\n+    private SerialPortIdentifier portId;\n+    private SDS011Handler thingHandler;\n+    private @NonNullByDefault({}) SerialPort serialPort;\n+\n+    private @NonNullByDefault({}) OutputStream outputStream;\n+    private @NonNullByDefault({}) InputStream inputStream;\n+\n+    public SDS011Communicator(SDS011Handler thingHandler, SerialPortIdentifier portId) {\n+        this.thingHandler = thingHandler;\n+        this.portId = portId;\n+    }\n+\n+    /**\n+     * Initialize the communication with the device, i.e. open the serial port etc.\n+     *\n+     * @param mode the {@link WorkMode} if we want to use polling or reporting\n+     * @param interval the time between polling or reportings\n+     * @return {@code true} if we can communicate with the device\n+     * @throws PortInUseException\n+     * @throws TooManyListenersException\n+     * @throws IOException\n+     * @throws UnsupportedCommOperationException\n+     */\n+    public boolean initialize(WorkMode mode, Duration interval)\n+            throws PortInUseException, TooManyListenersException, IOException, UnsupportedCommOperationException {\n+        boolean initSuccessful = true;\n+\n+        SerialPort localSerialPort = portId.open(thingHandler.getThing().getUID().toString(), 2000);\n+        localSerialPort.setSerialPortParams(9600, 8, 1, 0);\n+\n+        outputStream = localSerialPort.getOutputStream();\n+        inputStream = localSerialPort.getInputStream();\n+\n+        if (inputStream == null || outputStream == null) {\n+            throw new IOException(\"Could not create input or outputstream for the port\");\n+        }\n+\n+        // wake up the device\n+        initSuccessful &= sendSleep(false);\n+        initSuccessful &= getFirmware();\n+\n+        if (mode == WorkMode.POLLING) {\n+            initSuccessful &= setMode(WorkMode.POLLING);\n+            initSuccessful &= setWorkingPeriod((byte) 0);\n+        } else {\n+            // reporting\n+            initSuccessful &= setWorkingPeriod((byte) interval.toMinutes());\n+            initSuccessful &= setMode(WorkMode.REPORTING);\n+        }\n+\n+        // enable listeners only after we have configured the sensor above because for configuring we send and read data\n+        // sequentially\n+        localSerialPort.notifyOnDataAvailable(true);\n+        localSerialPort.addEventListener(this);\n+        this.serialPort = localSerialPort;\n+\n+        return initSuccessful;\n+    }\n+\n+    private @Nullable SensorReply sendCommand(CommandMessage message) throws IOException {\n+        byte[] commandData = message.getBytes();\n+        if (logger.isDebugEnabled()) {\n+            logger.debug(\"Will send command: {} ({})\", Helper.toHexString(commandData), Arrays.toString(commandData));\n+        }\n+        outputStream.write(commandData, 0, commandData.length);\n+        outputStream.flush();\n+        try {\n+            // Give the sensor some time to handle the command\n+            Thread.sleep(500);\n+        } catch (InterruptedException e) {\n+            logger.warn(\"Problem while waiting for reading a reply to our command.\");\n+            Thread.currentThread().interrupt();\n+        }\n+        SensorReply reply = readReply();\n+        // in case there is still another reporting active, we want to discard the sensor data and read the reply to our\n+        // command again\n+        if (reply instanceof SensorMeasuredDataReply) {\n+            reply = readReply();\n+        }\n+        return reply;\n+    }\n+\n+    private boolean setWorkingPeriod(byte period) throws IOException {\n+        CommandMessage m = new CommandMessage(Command.WORKING_PERIOD, new byte[] { Constants.SET_ACTION, period });\n+        logger.debug(\"Sending work period: {}\", period);\n+        SensorReply reply = sendCommand(m);\n+        logger.debug(\"Got reply to setWorkingPeriod command: {}\", reply);\n+        if (reply instanceof WorkingPeriodReply) {\n+            WorkingPeriodReply wpReply = (WorkingPeriodReply) reply;\n+            if (wpReply.getPeriod() == period && wpReply.getActionType() == Constants.SET_ACTION) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    private boolean setMode(WorkMode workMode) throws IOException {\n+        byte haveToRequestData = 0;\n+        if (workMode == WorkMode.POLLING) {\n+            haveToRequestData = 1;\n+        }\n+\n+        CommandMessage m = new CommandMessage(Command.MODE, new byte[] { Constants.SET_ACTION, haveToRequestData });\n+        logger.debug(\"Sending mode: {}\", workMode);\n+        SensorReply reply = sendCommand(m);\n+        logger.debug(\"Got reply to setMode command: {}\", reply);\n+        if (reply instanceof ModeReply) {\n+            ModeReply mr = (ModeReply) reply;\n+            if (mr.getActionType() == Constants.SET_ACTION && mr.getMode() == workMode) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    private boolean sendSleep(boolean doSleep) throws IOException {\n+        byte payload = (byte) 1;\n+        if (doSleep) {\n+            payload = (byte) 0;\n+        }\n+\n+        CommandMessage m = new CommandMessage(Command.SLEEP, new byte[] { Constants.SET_ACTION, payload });\n+        logger.debug(\"Sending doSleep: {}\", doSleep);\n+        SensorReply reply = sendCommand(m);\n+        logger.debug(\"Got reply to sendSleep command: {}\", reply);\n+\n+        if (!doSleep) {\n+            // sometimes the sensor does not wakeup on the first attempt, thus we try again\n+            for (int i = 0; reply == null && i < 3; i++) {\n+                reply = sendCommand(m);\n+                logger.debug(\"Got reply to sendSleep command after retry#{}: {}\", i + 1, reply);\n+            }\n+        }\n+\n+        if (reply instanceof SleepReply) {\n+            SleepReply sr = (SleepReply) reply;\n+            if (sr.getActionType() == Constants.SET_ACTION && sr.getSleep() == payload) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    private boolean getFirmware() throws IOException {\n+        CommandMessage m = new CommandMessage(Command.FIRMWARE, new byte[] {});\n+        logger.debug(\"Sending get firmware request\");\n+        SensorReply reply = sendCommand(m);\n+        logger.debug(\"Got reply to getFirmware command: {}\", reply);\n+\n+        if (reply instanceof SensorFirmwareReply) {\n+            SensorFirmwareReply fwReply = (SensorFirmwareReply) reply;\n+            thingHandler.setFirmware(fwReply.getFirmware());\n+            return true;\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Request data from the device, they will be returned via the serialEvent callback\n+     *\n+     * @throws IOException\n+     */\n+    public void requestSensorData() throws IOException {\n+        CommandMessage m = new CommandMessage(Command.REQUEST_DATA, new byte[] {});\n+        byte[] data = m.getBytes();\n+        if (logger.isDebugEnabled()) {\n+            logger.debug(\"Requesting sensor data, will send: {}\", Helper.toHexString(data));\n+        }\n+        outputStream.write(data, 0, data.length);\n+    }\n+\n+    private @Nullable SensorReply readReply() throws IOException {\n+        byte[] readBuffer = new byte[Constants.REPLY_LENGTH];\n+\n+        int b = -1;\n+        if (inputStream.available() > 0) {\n+            while ((b = inputStream.read()) != Constants.MESSAGE_START_AS_INT) {\n+                logger.debug(\"Trying to find first reply byte now...\");\n+            }\n+            readBuffer[0] = (byte) b;\n+            int remainingBytesRead = inputStream.read(readBuffer, 1, Constants.REPLY_LENGTH - 1);\n+            if (logger.isDebugEnabled()) {\n+                logger.debug(\"Read remaining bytes: {}, full reply={}\", remainingBytesRead,\n+                        Helper.toHexString(readBuffer));\n+            }\n+            return ReplyFactory.create(readBuffer);\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * Data from the device is arriving and will be parsed accordingly\n+     */\n+    @Override\n+    public void serialEvent(SerialPortEvent event) {\n+        if (event.getEventType() == SerialPortEvent.DATA_AVAILABLE) {\n+            // we get here if data has been received\n+            SensorReply reply = null;\n+            try {\n+                reply = readReply();\n+                logger.debug(\"Got data from sensor: {}\", reply);\n+            } catch (IOException e) {\n+                logger.error(\"Could not read available data from the serial port\", e);\n+            }\n+            if (reply instanceof SensorMeasuredDataReply) {\n+                SensorMeasuredDataReply sensorData = (SensorMeasuredDataReply) reply;\n+                if (sensorData.isValidData()) {\n+                    thingHandler.updateChannels(sensorData);\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Shutdown the communication, i.e. send the device to sleep and close the serial port\n+     */\n+    public void dispose() {\n+        if (serialPort != null) {\n+            try {\n+                // send the device to sleep to preserve power and extend the lifetime of the sensor\n+                sendSleep(true);\n+            } catch (IOException e) {\n+                // ignore because we are shutting down anyway\n+                logger.debug(\"Exception while disposing communicator (will ignore it)\", e);\n+            } finally {\n+                serialPort.removeEventListener();\n+                serialPort.close();\n+                serialPort = null;\n+            }\n+        }\n+        IOUtils.closeQuietly(inputStream);\n+        IOUtils.closeQuietly(outputStream);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "17ab9e48eb7ee697b10405fcdabcba5a6d99288a"}, "originalPosition": 285}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY3NTMyMTU4OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.novafinedust/src/main/java/org/openhab/binding/novafinedust/internal/sds011protocol/SDS011Communicator.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yM1QxNToxMjowNlrOGZp5yw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yM1QxNjo1MTo0MVrOGZqWBQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTU1NDEyMw==", "bodyText": "No need to log the stacktrace here, but you could log the exception message:\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            logger.warn(\"Could not read available data from the serial port\", e);\n          \n          \n            \n                            logger.warn(\"Could not read available data from the serial port: {}\", e.getMessage());", "url": "https://github.com/openhab/openhab-addons/pull/7528#discussion_r429554123", "createdAt": "2020-05-23T15:12:06Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.novafinedust/src/main/java/org/openhab/binding/novafinedust/internal/sds011protocol/SDS011Communicator.java", "diffHunk": "@@ -253,7 +252,7 @@ public void serialEvent(SerialPortEvent event) {\n                 reply = readReply();\n                 logger.debug(\"Got data from sensor: {}\", reply);\n             } catch (IOException e) {\n-                logger.error(\"Could not read available data from the serial port\", e);\n+                logger.warn(\"Could not read available data from the serial port\", e);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bde3d2b7dce707a863eafa496bd10e55b6dc7cd2"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTU2MTM0OQ==", "bodyText": "Indeed, this makes sense to only log the message. I have changed it, thanks!", "url": "https://github.com/openhab/openhab-addons/pull/7528#discussion_r429561349", "createdAt": "2020-05-23T16:51:41Z", "author": {"login": "t2000"}, "path": "bundles/org.openhab.binding.novafinedust/src/main/java/org/openhab/binding/novafinedust/internal/sds011protocol/SDS011Communicator.java", "diffHunk": "@@ -253,7 +252,7 @@ public void serialEvent(SerialPortEvent event) {\n                 reply = readReply();\n                 logger.debug(\"Got data from sensor: {}\", reply);\n             } catch (IOException e) {\n-                logger.error(\"Could not read available data from the serial port\", e);\n+                logger.warn(\"Could not read available data from the serial port\", e);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTU1NDEyMw=="}, "originalCommit": {"oid": "bde3d2b7dce707a863eafa496bd10e55b6dc7cd2"}, "originalPosition": 13}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY3NTQ2MjY5OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.novafinedust/src/main/java/org/openhab/binding/novafinedust/internal/sds011protocol/Helper.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yM1QxOTo1MDoyNFrOGZrFLg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yM1QxOTo1MDoyNFrOGZrFLg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTU3MzQyMg==", "bodyText": "There is an implementation of this in HexUtils from openhab core.", "url": "https://github.com/openhab/openhab-addons/pull/7528#discussion_r429573422", "createdAt": "2020-05-23T19:50:24Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.novafinedust/src/main/java/org/openhab/binding/novafinedust/internal/sds011protocol/Helper.java", "diffHunk": "@@ -0,0 +1,42 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.novafinedust.internal.sds011protocol;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+\n+/**\n+ * Class with useful utility functions\n+ *\n+ * @author Stefan Triller - Initial contribution\n+ *\n+ */\n+@NonNullByDefault\n+public class Helper {\n+\n+    private Helper() {\n+    }\n+\n+    /**\n+     * Converts a byte array to a hexadecimal string, handy for printing\n+     *\n+     * @param bytes the byte array to be converted\n+     * @return a String describing the byte array in hexadecimal values\n+     */\n+    public static String toHexString(byte[] bytes) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0d2971b437b5c6dffb681d35908a946d857530be"}, "originalPosition": 35}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY3NTQ3NTIwOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.novafinedust/src/main/java/org/openhab/binding/novafinedust/internal/SDS011Handler.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yM1QyMDoxNTo1NlrOGZrLiQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yM1QyMDoxNTo1NlrOGZrLiQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTU3NTA0OQ==", "bodyText": "Perhaps you could cache the values so that a Refresh command would be able to get the most recently reported ones.", "url": "https://github.com/openhab/openhab-addons/pull/7528#discussion_r429575049", "createdAt": "2020-05-23T20:15:56Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.novafinedust/src/main/java/org/openhab/binding/novafinedust/internal/SDS011Handler.java", "diffHunk": "@@ -0,0 +1,228 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.novafinedust.internal;\n+\n+import java.io.IOException;\n+import java.time.Duration;\n+import java.time.ZonedDateTime;\n+import java.util.TooManyListenersException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.dimension.Density;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.unit.SmartHomeUnits;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.io.transport.serial.PortInUseException;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortIdentifier;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.eclipse.smarthome.io.transport.serial.UnsupportedCommOperationException;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.SDS011Communicator;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.WorkMode;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.SensorMeasuredDataReply;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link SDS011Handler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Stefan Triller - Initial contribution\n+ */\n+@NonNullByDefault\n+public class SDS011Handler extends BaseThingHandler {\n+    private static final Duration CONNECTION_MONITOR_START_DELAY_OFFSET = Duration.ofSeconds(10);\n+\n+    private final Logger logger = LoggerFactory.getLogger(SDS011Handler.class);\n+    private final SerialPortManager serialPortManager;\n+\n+    private @NonNullByDefault({}) NovaFineDustConfiguration config;\n+    private @NonNullByDefault({}) SDS011Communicator communicator;\n+\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+    private @Nullable ScheduledFuture<?> connectionMonitor;\n+\n+    private ZonedDateTime lastCommunication = ZonedDateTime.now();\n+\n+    // initialize timeBetweenDataShouldArrive with a large number\n+    private Duration timeBetweenDataShouldArrive = Duration.ofDays(1);\n+    private final Duration dataCanBeLateTolerance = Duration.ofSeconds(5);\n+\n+    public SDS011Handler(Thing thing, SerialPortManager serialPortManager) {\n+        super(thing);\n+        this.serialPortManager = serialPortManager;\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        // we do not support refreshing as values are either reported by the device or polled from the device in fixed\n+        // intervals", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0d2971b437b5c6dffb681d35908a946d857530be"}, "originalPosition": 76}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY3NTQ3NjAwOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.novafinedust/src/main/java/org/openhab/binding/novafinedust/internal/SDS011Handler.java", "isResolved": false, "comments": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yM1QyMDoxNzozNFrOGZrL-A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOFQwNjoyOToxNVrOGbnTNQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTU3NTE2MA==", "bodyText": "why is this disposed asynchronously?", "url": "https://github.com/openhab/openhab-addons/pull/7528#discussion_r429575160", "createdAt": "2020-05-23T20:17:34Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.novafinedust/src/main/java/org/openhab/binding/novafinedust/internal/SDS011Handler.java", "diffHunk": "@@ -0,0 +1,228 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.novafinedust.internal;\n+\n+import java.io.IOException;\n+import java.time.Duration;\n+import java.time.ZonedDateTime;\n+import java.util.TooManyListenersException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.dimension.Density;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.unit.SmartHomeUnits;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.io.transport.serial.PortInUseException;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortIdentifier;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.eclipse.smarthome.io.transport.serial.UnsupportedCommOperationException;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.SDS011Communicator;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.WorkMode;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.SensorMeasuredDataReply;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link SDS011Handler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Stefan Triller - Initial contribution\n+ */\n+@NonNullByDefault\n+public class SDS011Handler extends BaseThingHandler {\n+    private static final Duration CONNECTION_MONITOR_START_DELAY_OFFSET = Duration.ofSeconds(10);\n+\n+    private final Logger logger = LoggerFactory.getLogger(SDS011Handler.class);\n+    private final SerialPortManager serialPortManager;\n+\n+    private @NonNullByDefault({}) NovaFineDustConfiguration config;\n+    private @NonNullByDefault({}) SDS011Communicator communicator;\n+\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+    private @Nullable ScheduledFuture<?> connectionMonitor;\n+\n+    private ZonedDateTime lastCommunication = ZonedDateTime.now();\n+\n+    // initialize timeBetweenDataShouldArrive with a large number\n+    private Duration timeBetweenDataShouldArrive = Duration.ofDays(1);\n+    private final Duration dataCanBeLateTolerance = Duration.ofSeconds(5);\n+\n+    public SDS011Handler(Thing thing, SerialPortManager serialPortManager) {\n+        super(thing);\n+        this.serialPortManager = serialPortManager;\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        // we do not support refreshing as values are either reported by the device or polled from the device in fixed\n+        // intervals\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        config = getConfigAs(NovaFineDustConfiguration.class);\n+\n+        if (!validateConfiguration()) {\n+            return;\n+        }\n+\n+        // parse ports and if the port is found, initialize the reader\n+        SerialPortIdentifier portId = serialPortManager.getIdentifier(config.port);\n+        if (portId == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR, \"Port is not known!\");\n+            return;\n+        }\n+\n+        this.communicator = new SDS011Communicator(this, portId);\n+\n+        if (config.reporting) {\n+            timeBetweenDataShouldArrive = Duration.ofMinutes(config.reportingInterval);\n+            scheduler.schedule(() -> initializeCommunicator(WorkMode.REPORTING, timeBetweenDataShouldArrive), 0,\n+                    TimeUnit.SECONDS);\n+        } else {\n+            timeBetweenDataShouldArrive = Duration.ofSeconds(config.pollingInterval);\n+            scheduler.schedule(() -> initializeCommunicator(WorkMode.POLLING, timeBetweenDataShouldArrive), 0,\n+                    TimeUnit.SECONDS);\n+        }\n+\n+        Duration connectionMonitorStartDelay = timeBetweenDataShouldArrive.plus(CONNECTION_MONITOR_START_DELAY_OFFSET);\n+        connectionMonitor = scheduler.scheduleWithFixedDelay(this::verifyIfStillConnected,\n+                connectionMonitorStartDelay.getSeconds(), timeBetweenDataShouldArrive.getSeconds(), TimeUnit.SECONDS);\n+    }\n+\n+    private void initializeCommunicator(WorkMode mode, Duration interval) {\n+        boolean initSuccessful = false;\n+        try {\n+            initSuccessful = communicator.initialize(mode, interval);\n+        } catch (final IOException ex) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR, \"I/O error!\");\n+            return;\n+        } catch (PortInUseException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR, \"Port is in use!\");\n+            return;\n+        } catch (TooManyListenersException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                    \"Cannot attach listener to port!\");\n+            return;\n+        } catch (UnsupportedCommOperationException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                    \"Cannot set serial port parameters\");\n+            return;\n+        }\n+\n+        if (initSuccessful) {\n+            lastCommunication = ZonedDateTime.now();\n+            updateStatus(ThingStatus.ONLINE);\n+\n+            if (mode == WorkMode.POLLING) {\n+                pollingJob = scheduler.scheduleWithFixedDelay(() -> {\n+                    try {\n+                        communicator.requestSensorData();\n+                    } catch (IOException e) {\n+                        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                                \"Cannot query data from device\");\n+                    }\n+                }, 2, config.pollingInterval, TimeUnit.SECONDS);\n+            }\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                    \"Commands and replies from the device don't seem to match\");\n+            logger.debug(\"Could not configure sensor -> setting Thing to OFFLINE and disposing the handler\");\n+            dispose();\n+        }\n+    }\n+\n+    private boolean validateConfiguration() {\n+        if (config.port == null || config.port.isEmpty()) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR, \"Port must be set!\");\n+            return false;\n+        }\n+        return true;\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        if (pollingJob != null && !pollingJob.isCancelled()) {\n+            pollingJob.cancel(true);\n+            pollingJob = null;\n+        }\n+\n+        if (connectionMonitor != null && !connectionMonitor.isCancelled()) {\n+            connectionMonitor.cancel(true);\n+            connectionMonitor = null;\n+        }\n+\n+        if (communicator != null) {\n+            scheduler.schedule(() -> communicator.dispose(), 0, TimeUnit.SECONDS);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0d2971b437b5c6dffb681d35908a946d857530be"}, "originalPosition": 176}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDAwNDIzMQ==", "bodyText": "Because I think initialize and dispose from a ThingHandler should return quickly, i.e. within 5 seconds. Inside the dispose I send the sensor to sleep by communicating with it. This is important to enhance its lifetime.\nSo in order to not block the disposing call, I do it asynchronously.", "url": "https://github.com/openhab/openhab-addons/pull/7528#discussion_r430004231", "createdAt": "2020-05-25T16:06:06Z", "author": {"login": "t2000"}, "path": "bundles/org.openhab.binding.novafinedust/src/main/java/org/openhab/binding/novafinedust/internal/SDS011Handler.java", "diffHunk": "@@ -0,0 +1,228 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.novafinedust.internal;\n+\n+import java.io.IOException;\n+import java.time.Duration;\n+import java.time.ZonedDateTime;\n+import java.util.TooManyListenersException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.dimension.Density;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.unit.SmartHomeUnits;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.io.transport.serial.PortInUseException;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortIdentifier;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.eclipse.smarthome.io.transport.serial.UnsupportedCommOperationException;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.SDS011Communicator;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.WorkMode;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.SensorMeasuredDataReply;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link SDS011Handler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Stefan Triller - Initial contribution\n+ */\n+@NonNullByDefault\n+public class SDS011Handler extends BaseThingHandler {\n+    private static final Duration CONNECTION_MONITOR_START_DELAY_OFFSET = Duration.ofSeconds(10);\n+\n+    private final Logger logger = LoggerFactory.getLogger(SDS011Handler.class);\n+    private final SerialPortManager serialPortManager;\n+\n+    private @NonNullByDefault({}) NovaFineDustConfiguration config;\n+    private @NonNullByDefault({}) SDS011Communicator communicator;\n+\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+    private @Nullable ScheduledFuture<?> connectionMonitor;\n+\n+    private ZonedDateTime lastCommunication = ZonedDateTime.now();\n+\n+    // initialize timeBetweenDataShouldArrive with a large number\n+    private Duration timeBetweenDataShouldArrive = Duration.ofDays(1);\n+    private final Duration dataCanBeLateTolerance = Duration.ofSeconds(5);\n+\n+    public SDS011Handler(Thing thing, SerialPortManager serialPortManager) {\n+        super(thing);\n+        this.serialPortManager = serialPortManager;\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        // we do not support refreshing as values are either reported by the device or polled from the device in fixed\n+        // intervals\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        config = getConfigAs(NovaFineDustConfiguration.class);\n+\n+        if (!validateConfiguration()) {\n+            return;\n+        }\n+\n+        // parse ports and if the port is found, initialize the reader\n+        SerialPortIdentifier portId = serialPortManager.getIdentifier(config.port);\n+        if (portId == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR, \"Port is not known!\");\n+            return;\n+        }\n+\n+        this.communicator = new SDS011Communicator(this, portId);\n+\n+        if (config.reporting) {\n+            timeBetweenDataShouldArrive = Duration.ofMinutes(config.reportingInterval);\n+            scheduler.schedule(() -> initializeCommunicator(WorkMode.REPORTING, timeBetweenDataShouldArrive), 0,\n+                    TimeUnit.SECONDS);\n+        } else {\n+            timeBetweenDataShouldArrive = Duration.ofSeconds(config.pollingInterval);\n+            scheduler.schedule(() -> initializeCommunicator(WorkMode.POLLING, timeBetweenDataShouldArrive), 0,\n+                    TimeUnit.SECONDS);\n+        }\n+\n+        Duration connectionMonitorStartDelay = timeBetweenDataShouldArrive.plus(CONNECTION_MONITOR_START_DELAY_OFFSET);\n+        connectionMonitor = scheduler.scheduleWithFixedDelay(this::verifyIfStillConnected,\n+                connectionMonitorStartDelay.getSeconds(), timeBetweenDataShouldArrive.getSeconds(), TimeUnit.SECONDS);\n+    }\n+\n+    private void initializeCommunicator(WorkMode mode, Duration interval) {\n+        boolean initSuccessful = false;\n+        try {\n+            initSuccessful = communicator.initialize(mode, interval);\n+        } catch (final IOException ex) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR, \"I/O error!\");\n+            return;\n+        } catch (PortInUseException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR, \"Port is in use!\");\n+            return;\n+        } catch (TooManyListenersException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                    \"Cannot attach listener to port!\");\n+            return;\n+        } catch (UnsupportedCommOperationException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                    \"Cannot set serial port parameters\");\n+            return;\n+        }\n+\n+        if (initSuccessful) {\n+            lastCommunication = ZonedDateTime.now();\n+            updateStatus(ThingStatus.ONLINE);\n+\n+            if (mode == WorkMode.POLLING) {\n+                pollingJob = scheduler.scheduleWithFixedDelay(() -> {\n+                    try {\n+                        communicator.requestSensorData();\n+                    } catch (IOException e) {\n+                        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                                \"Cannot query data from device\");\n+                    }\n+                }, 2, config.pollingInterval, TimeUnit.SECONDS);\n+            }\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                    \"Commands and replies from the device don't seem to match\");\n+            logger.debug(\"Could not configure sensor -> setting Thing to OFFLINE and disposing the handler\");\n+            dispose();\n+        }\n+    }\n+\n+    private boolean validateConfiguration() {\n+        if (config.port == null || config.port.isEmpty()) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR, \"Port must be set!\");\n+            return false;\n+        }\n+        return true;\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        if (pollingJob != null && !pollingJob.isCancelled()) {\n+            pollingJob.cancel(true);\n+            pollingJob = null;\n+        }\n+\n+        if (connectionMonitor != null && !connectionMonitor.isCancelled()) {\n+            connectionMonitor.cancel(true);\n+            connectionMonitor = null;\n+        }\n+\n+        if (communicator != null) {\n+            scheduler.schedule(() -> communicator.dispose(), 0, TimeUnit.SECONDS);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTU3NTE2MA=="}, "originalCommit": {"oid": "0d2971b437b5c6dffb681d35908a946d857530be"}, "originalPosition": 176}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDc1NDgyOA==", "bodyText": "So what happens if the handler is restarted (disposed then initialized again)? Would the handler be stuck in a configuration COMMUNICATION_ERROR because the port is still in use?", "url": "https://github.com/openhab/openhab-addons/pull/7528#discussion_r430754828", "createdAt": "2020-05-26T23:05:26Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.novafinedust/src/main/java/org/openhab/binding/novafinedust/internal/SDS011Handler.java", "diffHunk": "@@ -0,0 +1,228 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.novafinedust.internal;\n+\n+import java.io.IOException;\n+import java.time.Duration;\n+import java.time.ZonedDateTime;\n+import java.util.TooManyListenersException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.dimension.Density;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.unit.SmartHomeUnits;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.io.transport.serial.PortInUseException;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortIdentifier;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.eclipse.smarthome.io.transport.serial.UnsupportedCommOperationException;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.SDS011Communicator;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.WorkMode;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.SensorMeasuredDataReply;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link SDS011Handler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Stefan Triller - Initial contribution\n+ */\n+@NonNullByDefault\n+public class SDS011Handler extends BaseThingHandler {\n+    private static final Duration CONNECTION_MONITOR_START_DELAY_OFFSET = Duration.ofSeconds(10);\n+\n+    private final Logger logger = LoggerFactory.getLogger(SDS011Handler.class);\n+    private final SerialPortManager serialPortManager;\n+\n+    private @NonNullByDefault({}) NovaFineDustConfiguration config;\n+    private @NonNullByDefault({}) SDS011Communicator communicator;\n+\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+    private @Nullable ScheduledFuture<?> connectionMonitor;\n+\n+    private ZonedDateTime lastCommunication = ZonedDateTime.now();\n+\n+    // initialize timeBetweenDataShouldArrive with a large number\n+    private Duration timeBetweenDataShouldArrive = Duration.ofDays(1);\n+    private final Duration dataCanBeLateTolerance = Duration.ofSeconds(5);\n+\n+    public SDS011Handler(Thing thing, SerialPortManager serialPortManager) {\n+        super(thing);\n+        this.serialPortManager = serialPortManager;\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        // we do not support refreshing as values are either reported by the device or polled from the device in fixed\n+        // intervals\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        config = getConfigAs(NovaFineDustConfiguration.class);\n+\n+        if (!validateConfiguration()) {\n+            return;\n+        }\n+\n+        // parse ports and if the port is found, initialize the reader\n+        SerialPortIdentifier portId = serialPortManager.getIdentifier(config.port);\n+        if (portId == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR, \"Port is not known!\");\n+            return;\n+        }\n+\n+        this.communicator = new SDS011Communicator(this, portId);\n+\n+        if (config.reporting) {\n+            timeBetweenDataShouldArrive = Duration.ofMinutes(config.reportingInterval);\n+            scheduler.schedule(() -> initializeCommunicator(WorkMode.REPORTING, timeBetweenDataShouldArrive), 0,\n+                    TimeUnit.SECONDS);\n+        } else {\n+            timeBetweenDataShouldArrive = Duration.ofSeconds(config.pollingInterval);\n+            scheduler.schedule(() -> initializeCommunicator(WorkMode.POLLING, timeBetweenDataShouldArrive), 0,\n+                    TimeUnit.SECONDS);\n+        }\n+\n+        Duration connectionMonitorStartDelay = timeBetweenDataShouldArrive.plus(CONNECTION_MONITOR_START_DELAY_OFFSET);\n+        connectionMonitor = scheduler.scheduleWithFixedDelay(this::verifyIfStillConnected,\n+                connectionMonitorStartDelay.getSeconds(), timeBetweenDataShouldArrive.getSeconds(), TimeUnit.SECONDS);\n+    }\n+\n+    private void initializeCommunicator(WorkMode mode, Duration interval) {\n+        boolean initSuccessful = false;\n+        try {\n+            initSuccessful = communicator.initialize(mode, interval);\n+        } catch (final IOException ex) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR, \"I/O error!\");\n+            return;\n+        } catch (PortInUseException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR, \"Port is in use!\");\n+            return;\n+        } catch (TooManyListenersException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                    \"Cannot attach listener to port!\");\n+            return;\n+        } catch (UnsupportedCommOperationException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                    \"Cannot set serial port parameters\");\n+            return;\n+        }\n+\n+        if (initSuccessful) {\n+            lastCommunication = ZonedDateTime.now();\n+            updateStatus(ThingStatus.ONLINE);\n+\n+            if (mode == WorkMode.POLLING) {\n+                pollingJob = scheduler.scheduleWithFixedDelay(() -> {\n+                    try {\n+                        communicator.requestSensorData();\n+                    } catch (IOException e) {\n+                        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                                \"Cannot query data from device\");\n+                    }\n+                }, 2, config.pollingInterval, TimeUnit.SECONDS);\n+            }\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                    \"Commands and replies from the device don't seem to match\");\n+            logger.debug(\"Could not configure sensor -> setting Thing to OFFLINE and disposing the handler\");\n+            dispose();\n+        }\n+    }\n+\n+    private boolean validateConfiguration() {\n+        if (config.port == null || config.port.isEmpty()) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR, \"Port must be set!\");\n+            return false;\n+        }\n+        return true;\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        if (pollingJob != null && !pollingJob.isCancelled()) {\n+            pollingJob.cancel(true);\n+            pollingJob = null;\n+        }\n+\n+        if (connectionMonitor != null && !connectionMonitor.isCancelled()) {\n+            connectionMonitor.cancel(true);\n+            connectionMonitor = null;\n+        }\n+\n+        if (communicator != null) {\n+            scheduler.schedule(() -> communicator.dispose(), 0, TimeUnit.SECONDS);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTU3NTE2MA=="}, "originalCommit": {"oid": "0d2971b437b5c6dffb681d35908a946d857530be"}, "originalPosition": 176}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTI1MjU5OQ==", "bodyText": "This is a VERY interesting point! :-)\nThere are similar problems in the zigbee binding, because there it also takes a while to startup the stack and if this gets restarted through dispose/initialize calls, everything gets messed up too. Synchronization might help there but is a pain in the ass to do that for every binding.\nAnd I am afraid to say that with the 5 second rule for initialize/dispose, bindings are forced to spawn a separate task, which will ALWAYS cause these troubles if dispose/initialize is called within a short time frame (i.e. by a disable/enable of the thing).\nIf you prefer to have my dispose here running in sync with the framework, I am fine to replace the task with a direct call. In my case this usually only takes about 1-2 seconds anyway, but I wanted to play safe since I am communicating with an external device and this might timeout, etc.\nBut the overall problem for all bindings will stay, especially with the use case of enabling and disabling of a thing.\nWDYT?", "url": "https://github.com/openhab/openhab-addons/pull/7528#discussion_r431252599", "createdAt": "2020-05-27T15:55:11Z", "author": {"login": "t2000"}, "path": "bundles/org.openhab.binding.novafinedust/src/main/java/org/openhab/binding/novafinedust/internal/SDS011Handler.java", "diffHunk": "@@ -0,0 +1,228 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.novafinedust.internal;\n+\n+import java.io.IOException;\n+import java.time.Duration;\n+import java.time.ZonedDateTime;\n+import java.util.TooManyListenersException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.dimension.Density;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.unit.SmartHomeUnits;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.io.transport.serial.PortInUseException;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortIdentifier;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.eclipse.smarthome.io.transport.serial.UnsupportedCommOperationException;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.SDS011Communicator;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.WorkMode;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.SensorMeasuredDataReply;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link SDS011Handler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Stefan Triller - Initial contribution\n+ */\n+@NonNullByDefault\n+public class SDS011Handler extends BaseThingHandler {\n+    private static final Duration CONNECTION_MONITOR_START_DELAY_OFFSET = Duration.ofSeconds(10);\n+\n+    private final Logger logger = LoggerFactory.getLogger(SDS011Handler.class);\n+    private final SerialPortManager serialPortManager;\n+\n+    private @NonNullByDefault({}) NovaFineDustConfiguration config;\n+    private @NonNullByDefault({}) SDS011Communicator communicator;\n+\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+    private @Nullable ScheduledFuture<?> connectionMonitor;\n+\n+    private ZonedDateTime lastCommunication = ZonedDateTime.now();\n+\n+    // initialize timeBetweenDataShouldArrive with a large number\n+    private Duration timeBetweenDataShouldArrive = Duration.ofDays(1);\n+    private final Duration dataCanBeLateTolerance = Duration.ofSeconds(5);\n+\n+    public SDS011Handler(Thing thing, SerialPortManager serialPortManager) {\n+        super(thing);\n+        this.serialPortManager = serialPortManager;\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        // we do not support refreshing as values are either reported by the device or polled from the device in fixed\n+        // intervals\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        config = getConfigAs(NovaFineDustConfiguration.class);\n+\n+        if (!validateConfiguration()) {\n+            return;\n+        }\n+\n+        // parse ports and if the port is found, initialize the reader\n+        SerialPortIdentifier portId = serialPortManager.getIdentifier(config.port);\n+        if (portId == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR, \"Port is not known!\");\n+            return;\n+        }\n+\n+        this.communicator = new SDS011Communicator(this, portId);\n+\n+        if (config.reporting) {\n+            timeBetweenDataShouldArrive = Duration.ofMinutes(config.reportingInterval);\n+            scheduler.schedule(() -> initializeCommunicator(WorkMode.REPORTING, timeBetweenDataShouldArrive), 0,\n+                    TimeUnit.SECONDS);\n+        } else {\n+            timeBetweenDataShouldArrive = Duration.ofSeconds(config.pollingInterval);\n+            scheduler.schedule(() -> initializeCommunicator(WorkMode.POLLING, timeBetweenDataShouldArrive), 0,\n+                    TimeUnit.SECONDS);\n+        }\n+\n+        Duration connectionMonitorStartDelay = timeBetweenDataShouldArrive.plus(CONNECTION_MONITOR_START_DELAY_OFFSET);\n+        connectionMonitor = scheduler.scheduleWithFixedDelay(this::verifyIfStillConnected,\n+                connectionMonitorStartDelay.getSeconds(), timeBetweenDataShouldArrive.getSeconds(), TimeUnit.SECONDS);\n+    }\n+\n+    private void initializeCommunicator(WorkMode mode, Duration interval) {\n+        boolean initSuccessful = false;\n+        try {\n+            initSuccessful = communicator.initialize(mode, interval);\n+        } catch (final IOException ex) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR, \"I/O error!\");\n+            return;\n+        } catch (PortInUseException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR, \"Port is in use!\");\n+            return;\n+        } catch (TooManyListenersException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                    \"Cannot attach listener to port!\");\n+            return;\n+        } catch (UnsupportedCommOperationException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                    \"Cannot set serial port parameters\");\n+            return;\n+        }\n+\n+        if (initSuccessful) {\n+            lastCommunication = ZonedDateTime.now();\n+            updateStatus(ThingStatus.ONLINE);\n+\n+            if (mode == WorkMode.POLLING) {\n+                pollingJob = scheduler.scheduleWithFixedDelay(() -> {\n+                    try {\n+                        communicator.requestSensorData();\n+                    } catch (IOException e) {\n+                        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                                \"Cannot query data from device\");\n+                    }\n+                }, 2, config.pollingInterval, TimeUnit.SECONDS);\n+            }\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                    \"Commands and replies from the device don't seem to match\");\n+            logger.debug(\"Could not configure sensor -> setting Thing to OFFLINE and disposing the handler\");\n+            dispose();\n+        }\n+    }\n+\n+    private boolean validateConfiguration() {\n+        if (config.port == null || config.port.isEmpty()) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR, \"Port must be set!\");\n+            return false;\n+        }\n+        return true;\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        if (pollingJob != null && !pollingJob.isCancelled()) {\n+            pollingJob.cancel(true);\n+            pollingJob = null;\n+        }\n+\n+        if (connectionMonitor != null && !connectionMonitor.isCancelled()) {\n+            connectionMonitor.cancel(true);\n+            connectionMonitor = null;\n+        }\n+\n+        if (communicator != null) {\n+            scheduler.schedule(() -> communicator.dispose(), 0, TimeUnit.SECONDS);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTU3NTE2MA=="}, "originalCommit": {"oid": "0d2971b437b5c6dffb681d35908a946d857530be"}, "originalPosition": 176}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTM1NjA0Mw==", "bodyText": "The only way I can see of dealing with delayed initialize/dispose is to make your handler and communicator objects have different lifecycles.\nYou would need to create a your own communicator factory class that handlers would request communicators for a given port.\npublic interface CommunicatorFactory{\n     SDS011Communicator getCommunicator(SerialPortIdentifier portId);\n}\n\nThe factory itself would share the same lifecycle as an osgi component so either you could make your handler factory a communicator factory or implement it in a new osgi component.\nThe key benefit here is that you would be able to reuse SDS011Communicator instances across handler restarts.", "url": "https://github.com/openhab/openhab-addons/pull/7528#discussion_r431356043", "createdAt": "2020-05-27T18:29:32Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.novafinedust/src/main/java/org/openhab/binding/novafinedust/internal/SDS011Handler.java", "diffHunk": "@@ -0,0 +1,228 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.novafinedust.internal;\n+\n+import java.io.IOException;\n+import java.time.Duration;\n+import java.time.ZonedDateTime;\n+import java.util.TooManyListenersException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.dimension.Density;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.unit.SmartHomeUnits;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.io.transport.serial.PortInUseException;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortIdentifier;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.eclipse.smarthome.io.transport.serial.UnsupportedCommOperationException;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.SDS011Communicator;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.WorkMode;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.SensorMeasuredDataReply;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link SDS011Handler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Stefan Triller - Initial contribution\n+ */\n+@NonNullByDefault\n+public class SDS011Handler extends BaseThingHandler {\n+    private static final Duration CONNECTION_MONITOR_START_DELAY_OFFSET = Duration.ofSeconds(10);\n+\n+    private final Logger logger = LoggerFactory.getLogger(SDS011Handler.class);\n+    private final SerialPortManager serialPortManager;\n+\n+    private @NonNullByDefault({}) NovaFineDustConfiguration config;\n+    private @NonNullByDefault({}) SDS011Communicator communicator;\n+\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+    private @Nullable ScheduledFuture<?> connectionMonitor;\n+\n+    private ZonedDateTime lastCommunication = ZonedDateTime.now();\n+\n+    // initialize timeBetweenDataShouldArrive with a large number\n+    private Duration timeBetweenDataShouldArrive = Duration.ofDays(1);\n+    private final Duration dataCanBeLateTolerance = Duration.ofSeconds(5);\n+\n+    public SDS011Handler(Thing thing, SerialPortManager serialPortManager) {\n+        super(thing);\n+        this.serialPortManager = serialPortManager;\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        // we do not support refreshing as values are either reported by the device or polled from the device in fixed\n+        // intervals\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        config = getConfigAs(NovaFineDustConfiguration.class);\n+\n+        if (!validateConfiguration()) {\n+            return;\n+        }\n+\n+        // parse ports and if the port is found, initialize the reader\n+        SerialPortIdentifier portId = serialPortManager.getIdentifier(config.port);\n+        if (portId == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR, \"Port is not known!\");\n+            return;\n+        }\n+\n+        this.communicator = new SDS011Communicator(this, portId);\n+\n+        if (config.reporting) {\n+            timeBetweenDataShouldArrive = Duration.ofMinutes(config.reportingInterval);\n+            scheduler.schedule(() -> initializeCommunicator(WorkMode.REPORTING, timeBetweenDataShouldArrive), 0,\n+                    TimeUnit.SECONDS);\n+        } else {\n+            timeBetweenDataShouldArrive = Duration.ofSeconds(config.pollingInterval);\n+            scheduler.schedule(() -> initializeCommunicator(WorkMode.POLLING, timeBetweenDataShouldArrive), 0,\n+                    TimeUnit.SECONDS);\n+        }\n+\n+        Duration connectionMonitorStartDelay = timeBetweenDataShouldArrive.plus(CONNECTION_MONITOR_START_DELAY_OFFSET);\n+        connectionMonitor = scheduler.scheduleWithFixedDelay(this::verifyIfStillConnected,\n+                connectionMonitorStartDelay.getSeconds(), timeBetweenDataShouldArrive.getSeconds(), TimeUnit.SECONDS);\n+    }\n+\n+    private void initializeCommunicator(WorkMode mode, Duration interval) {\n+        boolean initSuccessful = false;\n+        try {\n+            initSuccessful = communicator.initialize(mode, interval);\n+        } catch (final IOException ex) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR, \"I/O error!\");\n+            return;\n+        } catch (PortInUseException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR, \"Port is in use!\");\n+            return;\n+        } catch (TooManyListenersException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                    \"Cannot attach listener to port!\");\n+            return;\n+        } catch (UnsupportedCommOperationException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                    \"Cannot set serial port parameters\");\n+            return;\n+        }\n+\n+        if (initSuccessful) {\n+            lastCommunication = ZonedDateTime.now();\n+            updateStatus(ThingStatus.ONLINE);\n+\n+            if (mode == WorkMode.POLLING) {\n+                pollingJob = scheduler.scheduleWithFixedDelay(() -> {\n+                    try {\n+                        communicator.requestSensorData();\n+                    } catch (IOException e) {\n+                        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                                \"Cannot query data from device\");\n+                    }\n+                }, 2, config.pollingInterval, TimeUnit.SECONDS);\n+            }\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                    \"Commands and replies from the device don't seem to match\");\n+            logger.debug(\"Could not configure sensor -> setting Thing to OFFLINE and disposing the handler\");\n+            dispose();\n+        }\n+    }\n+\n+    private boolean validateConfiguration() {\n+        if (config.port == null || config.port.isEmpty()) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR, \"Port must be set!\");\n+            return false;\n+        }\n+        return true;\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        if (pollingJob != null && !pollingJob.isCancelled()) {\n+            pollingJob.cancel(true);\n+            pollingJob = null;\n+        }\n+\n+        if (connectionMonitor != null && !connectionMonitor.isCancelled()) {\n+            connectionMonitor.cancel(true);\n+            connectionMonitor = null;\n+        }\n+\n+        if (communicator != null) {\n+            scheduler.schedule(() -> communicator.dispose(), 0, TimeUnit.SECONDS);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTU3NTE2MA=="}, "originalCommit": {"oid": "0d2971b437b5c6dffb681d35908a946d857530be"}, "originalPosition": 176}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQ1MDc5NA==", "bodyText": "This doesn't really solve the problem, I could still have the communicator instance running if i dispose the handler and then the port is blocked.\nAlso its not worth the effort as I said before the communication takes max 1-2 seconds.\nI have changed it to be synchronous now.", "url": "https://github.com/openhab/openhab-addons/pull/7528#discussion_r431450794", "createdAt": "2020-05-27T21:23:55Z", "author": {"login": "t2000"}, "path": "bundles/org.openhab.binding.novafinedust/src/main/java/org/openhab/binding/novafinedust/internal/SDS011Handler.java", "diffHunk": "@@ -0,0 +1,228 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.novafinedust.internal;\n+\n+import java.io.IOException;\n+import java.time.Duration;\n+import java.time.ZonedDateTime;\n+import java.util.TooManyListenersException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.dimension.Density;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.unit.SmartHomeUnits;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.io.transport.serial.PortInUseException;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortIdentifier;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.eclipse.smarthome.io.transport.serial.UnsupportedCommOperationException;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.SDS011Communicator;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.WorkMode;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.SensorMeasuredDataReply;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link SDS011Handler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Stefan Triller - Initial contribution\n+ */\n+@NonNullByDefault\n+public class SDS011Handler extends BaseThingHandler {\n+    private static final Duration CONNECTION_MONITOR_START_DELAY_OFFSET = Duration.ofSeconds(10);\n+\n+    private final Logger logger = LoggerFactory.getLogger(SDS011Handler.class);\n+    private final SerialPortManager serialPortManager;\n+\n+    private @NonNullByDefault({}) NovaFineDustConfiguration config;\n+    private @NonNullByDefault({}) SDS011Communicator communicator;\n+\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+    private @Nullable ScheduledFuture<?> connectionMonitor;\n+\n+    private ZonedDateTime lastCommunication = ZonedDateTime.now();\n+\n+    // initialize timeBetweenDataShouldArrive with a large number\n+    private Duration timeBetweenDataShouldArrive = Duration.ofDays(1);\n+    private final Duration dataCanBeLateTolerance = Duration.ofSeconds(5);\n+\n+    public SDS011Handler(Thing thing, SerialPortManager serialPortManager) {\n+        super(thing);\n+        this.serialPortManager = serialPortManager;\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        // we do not support refreshing as values are either reported by the device or polled from the device in fixed\n+        // intervals\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        config = getConfigAs(NovaFineDustConfiguration.class);\n+\n+        if (!validateConfiguration()) {\n+            return;\n+        }\n+\n+        // parse ports and if the port is found, initialize the reader\n+        SerialPortIdentifier portId = serialPortManager.getIdentifier(config.port);\n+        if (portId == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR, \"Port is not known!\");\n+            return;\n+        }\n+\n+        this.communicator = new SDS011Communicator(this, portId);\n+\n+        if (config.reporting) {\n+            timeBetweenDataShouldArrive = Duration.ofMinutes(config.reportingInterval);\n+            scheduler.schedule(() -> initializeCommunicator(WorkMode.REPORTING, timeBetweenDataShouldArrive), 0,\n+                    TimeUnit.SECONDS);\n+        } else {\n+            timeBetweenDataShouldArrive = Duration.ofSeconds(config.pollingInterval);\n+            scheduler.schedule(() -> initializeCommunicator(WorkMode.POLLING, timeBetweenDataShouldArrive), 0,\n+                    TimeUnit.SECONDS);\n+        }\n+\n+        Duration connectionMonitorStartDelay = timeBetweenDataShouldArrive.plus(CONNECTION_MONITOR_START_DELAY_OFFSET);\n+        connectionMonitor = scheduler.scheduleWithFixedDelay(this::verifyIfStillConnected,\n+                connectionMonitorStartDelay.getSeconds(), timeBetweenDataShouldArrive.getSeconds(), TimeUnit.SECONDS);\n+    }\n+\n+    private void initializeCommunicator(WorkMode mode, Duration interval) {\n+        boolean initSuccessful = false;\n+        try {\n+            initSuccessful = communicator.initialize(mode, interval);\n+        } catch (final IOException ex) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR, \"I/O error!\");\n+            return;\n+        } catch (PortInUseException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR, \"Port is in use!\");\n+            return;\n+        } catch (TooManyListenersException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                    \"Cannot attach listener to port!\");\n+            return;\n+        } catch (UnsupportedCommOperationException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                    \"Cannot set serial port parameters\");\n+            return;\n+        }\n+\n+        if (initSuccessful) {\n+            lastCommunication = ZonedDateTime.now();\n+            updateStatus(ThingStatus.ONLINE);\n+\n+            if (mode == WorkMode.POLLING) {\n+                pollingJob = scheduler.scheduleWithFixedDelay(() -> {\n+                    try {\n+                        communicator.requestSensorData();\n+                    } catch (IOException e) {\n+                        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                                \"Cannot query data from device\");\n+                    }\n+                }, 2, config.pollingInterval, TimeUnit.SECONDS);\n+            }\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                    \"Commands and replies from the device don't seem to match\");\n+            logger.debug(\"Could not configure sensor -> setting Thing to OFFLINE and disposing the handler\");\n+            dispose();\n+        }\n+    }\n+\n+    private boolean validateConfiguration() {\n+        if (config.port == null || config.port.isEmpty()) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR, \"Port must be set!\");\n+            return false;\n+        }\n+        return true;\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        if (pollingJob != null && !pollingJob.isCancelled()) {\n+            pollingJob.cancel(true);\n+            pollingJob = null;\n+        }\n+\n+        if (connectionMonitor != null && !connectionMonitor.isCancelled()) {\n+            connectionMonitor.cancel(true);\n+            connectionMonitor = null;\n+        }\n+\n+        if (communicator != null) {\n+            scheduler.schedule(() -> communicator.dispose(), 0, TimeUnit.SECONDS);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTU3NTE2MA=="}, "originalCommit": {"oid": "0d2971b437b5c6dffb681d35908a946d857530be"}, "originalPosition": 176}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQ2MDk0Mg==", "bodyText": "This doesn't really solve the problem, I could still have the communicator instance running if i dispose the handler and then the port is blocked.\n\nNot really since you can prevent a communicator from opening the port if it is already open. Likewise a communicator can stop its disposal process if a new handler requests to use it.\n\nI have changed it to be synchronous now.\n\nI don't think would work, a new handler means a new communicator object. Synchronization only works on the same object instance.\nNvm, just saw what you committed.", "url": "https://github.com/openhab/openhab-addons/pull/7528#discussion_r431460942", "createdAt": "2020-05-27T21:45:48Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.novafinedust/src/main/java/org/openhab/binding/novafinedust/internal/SDS011Handler.java", "diffHunk": "@@ -0,0 +1,228 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.novafinedust.internal;\n+\n+import java.io.IOException;\n+import java.time.Duration;\n+import java.time.ZonedDateTime;\n+import java.util.TooManyListenersException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.dimension.Density;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.unit.SmartHomeUnits;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.io.transport.serial.PortInUseException;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortIdentifier;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.eclipse.smarthome.io.transport.serial.UnsupportedCommOperationException;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.SDS011Communicator;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.WorkMode;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.SensorMeasuredDataReply;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link SDS011Handler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Stefan Triller - Initial contribution\n+ */\n+@NonNullByDefault\n+public class SDS011Handler extends BaseThingHandler {\n+    private static final Duration CONNECTION_MONITOR_START_DELAY_OFFSET = Duration.ofSeconds(10);\n+\n+    private final Logger logger = LoggerFactory.getLogger(SDS011Handler.class);\n+    private final SerialPortManager serialPortManager;\n+\n+    private @NonNullByDefault({}) NovaFineDustConfiguration config;\n+    private @NonNullByDefault({}) SDS011Communicator communicator;\n+\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+    private @Nullable ScheduledFuture<?> connectionMonitor;\n+\n+    private ZonedDateTime lastCommunication = ZonedDateTime.now();\n+\n+    // initialize timeBetweenDataShouldArrive with a large number\n+    private Duration timeBetweenDataShouldArrive = Duration.ofDays(1);\n+    private final Duration dataCanBeLateTolerance = Duration.ofSeconds(5);\n+\n+    public SDS011Handler(Thing thing, SerialPortManager serialPortManager) {\n+        super(thing);\n+        this.serialPortManager = serialPortManager;\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        // we do not support refreshing as values are either reported by the device or polled from the device in fixed\n+        // intervals\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        config = getConfigAs(NovaFineDustConfiguration.class);\n+\n+        if (!validateConfiguration()) {\n+            return;\n+        }\n+\n+        // parse ports and if the port is found, initialize the reader\n+        SerialPortIdentifier portId = serialPortManager.getIdentifier(config.port);\n+        if (portId == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR, \"Port is not known!\");\n+            return;\n+        }\n+\n+        this.communicator = new SDS011Communicator(this, portId);\n+\n+        if (config.reporting) {\n+            timeBetweenDataShouldArrive = Duration.ofMinutes(config.reportingInterval);\n+            scheduler.schedule(() -> initializeCommunicator(WorkMode.REPORTING, timeBetweenDataShouldArrive), 0,\n+                    TimeUnit.SECONDS);\n+        } else {\n+            timeBetweenDataShouldArrive = Duration.ofSeconds(config.pollingInterval);\n+            scheduler.schedule(() -> initializeCommunicator(WorkMode.POLLING, timeBetweenDataShouldArrive), 0,\n+                    TimeUnit.SECONDS);\n+        }\n+\n+        Duration connectionMonitorStartDelay = timeBetweenDataShouldArrive.plus(CONNECTION_MONITOR_START_DELAY_OFFSET);\n+        connectionMonitor = scheduler.scheduleWithFixedDelay(this::verifyIfStillConnected,\n+                connectionMonitorStartDelay.getSeconds(), timeBetweenDataShouldArrive.getSeconds(), TimeUnit.SECONDS);\n+    }\n+\n+    private void initializeCommunicator(WorkMode mode, Duration interval) {\n+        boolean initSuccessful = false;\n+        try {\n+            initSuccessful = communicator.initialize(mode, interval);\n+        } catch (final IOException ex) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR, \"I/O error!\");\n+            return;\n+        } catch (PortInUseException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR, \"Port is in use!\");\n+            return;\n+        } catch (TooManyListenersException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                    \"Cannot attach listener to port!\");\n+            return;\n+        } catch (UnsupportedCommOperationException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                    \"Cannot set serial port parameters\");\n+            return;\n+        }\n+\n+        if (initSuccessful) {\n+            lastCommunication = ZonedDateTime.now();\n+            updateStatus(ThingStatus.ONLINE);\n+\n+            if (mode == WorkMode.POLLING) {\n+                pollingJob = scheduler.scheduleWithFixedDelay(() -> {\n+                    try {\n+                        communicator.requestSensorData();\n+                    } catch (IOException e) {\n+                        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                                \"Cannot query data from device\");\n+                    }\n+                }, 2, config.pollingInterval, TimeUnit.SECONDS);\n+            }\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                    \"Commands and replies from the device don't seem to match\");\n+            logger.debug(\"Could not configure sensor -> setting Thing to OFFLINE and disposing the handler\");\n+            dispose();\n+        }\n+    }\n+\n+    private boolean validateConfiguration() {\n+        if (config.port == null || config.port.isEmpty()) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR, \"Port must be set!\");\n+            return false;\n+        }\n+        return true;\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        if (pollingJob != null && !pollingJob.isCancelled()) {\n+            pollingJob.cancel(true);\n+            pollingJob = null;\n+        }\n+\n+        if (connectionMonitor != null && !connectionMonitor.isCancelled()) {\n+            connectionMonitor.cancel(true);\n+            connectionMonitor = null;\n+        }\n+\n+        if (communicator != null) {\n+            scheduler.schedule(() -> communicator.dispose(), 0, TimeUnit.SECONDS);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTU3NTE2MA=="}, "originalCommit": {"oid": "0d2971b437b5c6dffb681d35908a946d857530be"}, "originalPosition": 176}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTYwODYyOQ==", "bodyText": "Not really since you can prevent a communicator from opening the port if it is already open. Likewise a communicator can stop its disposal process if a new handler requests to use it.\n\nThe problem is not having a different thing, let's say \"thing2\" wanting the very same port. This is already handled, because the port in use exception is dealt with. And this is always a user problem, since he has configured thing1 and thing2 with the same port.\nWhat I am talking about is that the ThingHandler from thing1 is disposed and shortly afterwards initialized again. This can happen if one disabled and enables a thing, see https://github.com/openhab/openhab-core/blob/5b325aa3d210c2dfa490c676520fe755b0f3fe1c/bundles/org.openhab.core.thing/src/main/java/org/openhab/core/thing/internal/ThingManagerImpl.java#L1167-L1216\nHere it doesnt matter if a communicator object or the thinghandler itself want to open the port on initialize. If it is currently in use by a thinghandler that gets disposed at the moment, then there is no way for a starting thinghandler to open the port and he will run into the port in use exception.\nThis applies to ALL binding which are operating on a shared resource like a port btw...\nSo with the change I did yesterday evening, the dispose is always called and finished before an initialize, so for now all is good within this binding.\nHowever, one should think about the general problem of shared resources and scenarios where an initialize or dispose might take longer and one has no other choice than putting this in an external task because of this 5 second rule from openHAB.", "url": "https://github.com/openhab/openhab-addons/pull/7528#discussion_r431608629", "createdAt": "2020-05-28T06:29:15Z", "author": {"login": "t2000"}, "path": "bundles/org.openhab.binding.novafinedust/src/main/java/org/openhab/binding/novafinedust/internal/SDS011Handler.java", "diffHunk": "@@ -0,0 +1,228 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.novafinedust.internal;\n+\n+import java.io.IOException;\n+import java.time.Duration;\n+import java.time.ZonedDateTime;\n+import java.util.TooManyListenersException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.dimension.Density;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.unit.SmartHomeUnits;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.io.transport.serial.PortInUseException;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortIdentifier;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.eclipse.smarthome.io.transport.serial.UnsupportedCommOperationException;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.SDS011Communicator;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.WorkMode;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.SensorMeasuredDataReply;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link SDS011Handler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Stefan Triller - Initial contribution\n+ */\n+@NonNullByDefault\n+public class SDS011Handler extends BaseThingHandler {\n+    private static final Duration CONNECTION_MONITOR_START_DELAY_OFFSET = Duration.ofSeconds(10);\n+\n+    private final Logger logger = LoggerFactory.getLogger(SDS011Handler.class);\n+    private final SerialPortManager serialPortManager;\n+\n+    private @NonNullByDefault({}) NovaFineDustConfiguration config;\n+    private @NonNullByDefault({}) SDS011Communicator communicator;\n+\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+    private @Nullable ScheduledFuture<?> connectionMonitor;\n+\n+    private ZonedDateTime lastCommunication = ZonedDateTime.now();\n+\n+    // initialize timeBetweenDataShouldArrive with a large number\n+    private Duration timeBetweenDataShouldArrive = Duration.ofDays(1);\n+    private final Duration dataCanBeLateTolerance = Duration.ofSeconds(5);\n+\n+    public SDS011Handler(Thing thing, SerialPortManager serialPortManager) {\n+        super(thing);\n+        this.serialPortManager = serialPortManager;\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        // we do not support refreshing as values are either reported by the device or polled from the device in fixed\n+        // intervals\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        config = getConfigAs(NovaFineDustConfiguration.class);\n+\n+        if (!validateConfiguration()) {\n+            return;\n+        }\n+\n+        // parse ports and if the port is found, initialize the reader\n+        SerialPortIdentifier portId = serialPortManager.getIdentifier(config.port);\n+        if (portId == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR, \"Port is not known!\");\n+            return;\n+        }\n+\n+        this.communicator = new SDS011Communicator(this, portId);\n+\n+        if (config.reporting) {\n+            timeBetweenDataShouldArrive = Duration.ofMinutes(config.reportingInterval);\n+            scheduler.schedule(() -> initializeCommunicator(WorkMode.REPORTING, timeBetweenDataShouldArrive), 0,\n+                    TimeUnit.SECONDS);\n+        } else {\n+            timeBetweenDataShouldArrive = Duration.ofSeconds(config.pollingInterval);\n+            scheduler.schedule(() -> initializeCommunicator(WorkMode.POLLING, timeBetweenDataShouldArrive), 0,\n+                    TimeUnit.SECONDS);\n+        }\n+\n+        Duration connectionMonitorStartDelay = timeBetweenDataShouldArrive.plus(CONNECTION_MONITOR_START_DELAY_OFFSET);\n+        connectionMonitor = scheduler.scheduleWithFixedDelay(this::verifyIfStillConnected,\n+                connectionMonitorStartDelay.getSeconds(), timeBetweenDataShouldArrive.getSeconds(), TimeUnit.SECONDS);\n+    }\n+\n+    private void initializeCommunicator(WorkMode mode, Duration interval) {\n+        boolean initSuccessful = false;\n+        try {\n+            initSuccessful = communicator.initialize(mode, interval);\n+        } catch (final IOException ex) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR, \"I/O error!\");\n+            return;\n+        } catch (PortInUseException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR, \"Port is in use!\");\n+            return;\n+        } catch (TooManyListenersException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                    \"Cannot attach listener to port!\");\n+            return;\n+        } catch (UnsupportedCommOperationException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                    \"Cannot set serial port parameters\");\n+            return;\n+        }\n+\n+        if (initSuccessful) {\n+            lastCommunication = ZonedDateTime.now();\n+            updateStatus(ThingStatus.ONLINE);\n+\n+            if (mode == WorkMode.POLLING) {\n+                pollingJob = scheduler.scheduleWithFixedDelay(() -> {\n+                    try {\n+                        communicator.requestSensorData();\n+                    } catch (IOException e) {\n+                        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                                \"Cannot query data from device\");\n+                    }\n+                }, 2, config.pollingInterval, TimeUnit.SECONDS);\n+            }\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                    \"Commands and replies from the device don't seem to match\");\n+            logger.debug(\"Could not configure sensor -> setting Thing to OFFLINE and disposing the handler\");\n+            dispose();\n+        }\n+    }\n+\n+    private boolean validateConfiguration() {\n+        if (config.port == null || config.port.isEmpty()) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR, \"Port must be set!\");\n+            return false;\n+        }\n+        return true;\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        if (pollingJob != null && !pollingJob.isCancelled()) {\n+            pollingJob.cancel(true);\n+            pollingJob = null;\n+        }\n+\n+        if (connectionMonitor != null && !connectionMonitor.isCancelled()) {\n+            connectionMonitor.cancel(true);\n+            connectionMonitor = null;\n+        }\n+\n+        if (communicator != null) {\n+            scheduler.schedule(() -> communicator.dispose(), 0, TimeUnit.SECONDS);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTU3NTE2MA=="}, "originalCommit": {"oid": "0d2971b437b5c6dffb681d35908a946d857530be"}, "originalPosition": 176}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY3NTU0NDYxOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.novafinedust/src/main/java/org/openhab/binding/novafinedust/internal/NovaFineDustHandlerFactory.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yM1QyMjo0NzoxOFrOGZruWg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yM1QyMjo0NzoxOFrOGZruWg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTU4Mzk2Mg==", "bodyText": "I suggest populating this through the NovaFineDustHandlerFactory constructor.\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private @NonNullByDefault({}) SerialPortManager serialPortManager;\n          \n          \n            \n                private final SerialPortManager serialPortManager;\n          \n          \n            \n                \n          \n          \n            \n                @Activate\n          \n          \n            \n                public NovaFineDustHandlerFactory(@Reference SerialPortManager serialPortManager){\n          \n          \n            \n                    this.serialPortManager = serialPortManager;\n          \n          \n            \n                }\n          \n      \n    \n    \n  \n\nThen you can remove the setSerialPortManager and unsetSerialPortManager methods.", "url": "https://github.com/openhab/openhab-addons/pull/7528#discussion_r429583962", "createdAt": "2020-05-23T22:47:18Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.novafinedust/src/main/java/org/openhab/binding/novafinedust/internal/NovaFineDustHandlerFactory.java", "diffHunk": "@@ -0,0 +1,69 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.novafinedust.internal;\n+\n+import static org.openhab.binding.novafinedust.internal.NovaFineDustBindingConstants.THING_TYPE_SDS011;\n+\n+import java.util.Collections;\n+import java.util.Set;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandlerFactory;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerFactory;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Reference;\n+\n+/**\n+ * The {@link NovaFineDustHandlerFactory} is responsible for creating things and thing\n+ * handlers.\n+ *\n+ * @author Stefan Triller - Initial contribution\n+ */\n+@NonNullByDefault\n+@Component(configurationPid = \"binding.novafinedust\", service = ThingHandlerFactory.class)\n+public class NovaFineDustHandlerFactory extends BaseThingHandlerFactory {\n+\n+    private static final Set<ThingTypeUID> SUPPORTED_THING_TYPES_UIDS = Collections.singleton(THING_TYPE_SDS011);\n+\n+    private @NonNullByDefault({}) SerialPortManager serialPortManager;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0d2971b437b5c6dffb681d35908a946d857530be"}, "originalPosition": 43}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY3NTU0NTI2OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.novafinedust/src/main/java/org/openhab/binding/novafinedust/internal/SDS011Handler.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yM1QyMjo0ODo1NVrOGZrurA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yM1QyMjo0ODo1NVrOGZrurA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTU4NDA0NA==", "bodyText": "No harm in cancelling something that is already cancelled.\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    if (pollingJob != null && !pollingJob.isCancelled()) {\n          \n          \n            \n                    if (pollingJob != null) {", "url": "https://github.com/openhab/openhab-addons/pull/7528#discussion_r429584044", "createdAt": "2020-05-23T22:48:55Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.novafinedust/src/main/java/org/openhab/binding/novafinedust/internal/SDS011Handler.java", "diffHunk": "@@ -0,0 +1,228 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.novafinedust.internal;\n+\n+import java.io.IOException;\n+import java.time.Duration;\n+import java.time.ZonedDateTime;\n+import java.util.TooManyListenersException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.dimension.Density;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.unit.SmartHomeUnits;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.io.transport.serial.PortInUseException;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortIdentifier;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.eclipse.smarthome.io.transport.serial.UnsupportedCommOperationException;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.SDS011Communicator;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.WorkMode;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.SensorMeasuredDataReply;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link SDS011Handler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Stefan Triller - Initial contribution\n+ */\n+@NonNullByDefault\n+public class SDS011Handler extends BaseThingHandler {\n+    private static final Duration CONNECTION_MONITOR_START_DELAY_OFFSET = Duration.ofSeconds(10);\n+\n+    private final Logger logger = LoggerFactory.getLogger(SDS011Handler.class);\n+    private final SerialPortManager serialPortManager;\n+\n+    private @NonNullByDefault({}) NovaFineDustConfiguration config;\n+    private @NonNullByDefault({}) SDS011Communicator communicator;\n+\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+    private @Nullable ScheduledFuture<?> connectionMonitor;\n+\n+    private ZonedDateTime lastCommunication = ZonedDateTime.now();\n+\n+    // initialize timeBetweenDataShouldArrive with a large number\n+    private Duration timeBetweenDataShouldArrive = Duration.ofDays(1);\n+    private final Duration dataCanBeLateTolerance = Duration.ofSeconds(5);\n+\n+    public SDS011Handler(Thing thing, SerialPortManager serialPortManager) {\n+        super(thing);\n+        this.serialPortManager = serialPortManager;\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        // we do not support refreshing as values are either reported by the device or polled from the device in fixed\n+        // intervals\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        config = getConfigAs(NovaFineDustConfiguration.class);\n+\n+        if (!validateConfiguration()) {\n+            return;\n+        }\n+\n+        // parse ports and if the port is found, initialize the reader\n+        SerialPortIdentifier portId = serialPortManager.getIdentifier(config.port);\n+        if (portId == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR, \"Port is not known!\");\n+            return;\n+        }\n+\n+        this.communicator = new SDS011Communicator(this, portId);\n+\n+        if (config.reporting) {\n+            timeBetweenDataShouldArrive = Duration.ofMinutes(config.reportingInterval);\n+            scheduler.schedule(() -> initializeCommunicator(WorkMode.REPORTING, timeBetweenDataShouldArrive), 0,\n+                    TimeUnit.SECONDS);\n+        } else {\n+            timeBetweenDataShouldArrive = Duration.ofSeconds(config.pollingInterval);\n+            scheduler.schedule(() -> initializeCommunicator(WorkMode.POLLING, timeBetweenDataShouldArrive), 0,\n+                    TimeUnit.SECONDS);\n+        }\n+\n+        Duration connectionMonitorStartDelay = timeBetweenDataShouldArrive.plus(CONNECTION_MONITOR_START_DELAY_OFFSET);\n+        connectionMonitor = scheduler.scheduleWithFixedDelay(this::verifyIfStillConnected,\n+                connectionMonitorStartDelay.getSeconds(), timeBetweenDataShouldArrive.getSeconds(), TimeUnit.SECONDS);\n+    }\n+\n+    private void initializeCommunicator(WorkMode mode, Duration interval) {\n+        boolean initSuccessful = false;\n+        try {\n+            initSuccessful = communicator.initialize(mode, interval);\n+        } catch (final IOException ex) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR, \"I/O error!\");\n+            return;\n+        } catch (PortInUseException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR, \"Port is in use!\");\n+            return;\n+        } catch (TooManyListenersException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                    \"Cannot attach listener to port!\");\n+            return;\n+        } catch (UnsupportedCommOperationException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                    \"Cannot set serial port parameters\");\n+            return;\n+        }\n+\n+        if (initSuccessful) {\n+            lastCommunication = ZonedDateTime.now();\n+            updateStatus(ThingStatus.ONLINE);\n+\n+            if (mode == WorkMode.POLLING) {\n+                pollingJob = scheduler.scheduleWithFixedDelay(() -> {\n+                    try {\n+                        communicator.requestSensorData();\n+                    } catch (IOException e) {\n+                        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                                \"Cannot query data from device\");\n+                    }\n+                }, 2, config.pollingInterval, TimeUnit.SECONDS);\n+            }\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                    \"Commands and replies from the device don't seem to match\");\n+            logger.debug(\"Could not configure sensor -> setting Thing to OFFLINE and disposing the handler\");\n+            dispose();\n+        }\n+    }\n+\n+    private boolean validateConfiguration() {\n+        if (config.port == null || config.port.isEmpty()) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR, \"Port must be set!\");\n+            return false;\n+        }\n+        return true;\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        if (pollingJob != null && !pollingJob.isCancelled()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0d2971b437b5c6dffb681d35908a946d857530be"}, "originalPosition": 165}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY3NTU0NTM1OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.novafinedust/src/main/java/org/openhab/binding/novafinedust/internal/SDS011Handler.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yM1QyMjo0OToxNVrOGZruuA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yM1QyMjo0OToxNVrOGZruuA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTU4NDA1Ng==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    if (connectionMonitor != null && !connectionMonitor.isCancelled()) {\n          \n          \n            \n                    if (connectionMonitor != null) {", "url": "https://github.com/openhab/openhab-addons/pull/7528#discussion_r429584056", "createdAt": "2020-05-23T22:49:15Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.novafinedust/src/main/java/org/openhab/binding/novafinedust/internal/SDS011Handler.java", "diffHunk": "@@ -0,0 +1,228 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.novafinedust.internal;\n+\n+import java.io.IOException;\n+import java.time.Duration;\n+import java.time.ZonedDateTime;\n+import java.util.TooManyListenersException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.dimension.Density;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.unit.SmartHomeUnits;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.io.transport.serial.PortInUseException;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortIdentifier;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.eclipse.smarthome.io.transport.serial.UnsupportedCommOperationException;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.SDS011Communicator;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.WorkMode;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.SensorMeasuredDataReply;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link SDS011Handler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Stefan Triller - Initial contribution\n+ */\n+@NonNullByDefault\n+public class SDS011Handler extends BaseThingHandler {\n+    private static final Duration CONNECTION_MONITOR_START_DELAY_OFFSET = Duration.ofSeconds(10);\n+\n+    private final Logger logger = LoggerFactory.getLogger(SDS011Handler.class);\n+    private final SerialPortManager serialPortManager;\n+\n+    private @NonNullByDefault({}) NovaFineDustConfiguration config;\n+    private @NonNullByDefault({}) SDS011Communicator communicator;\n+\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+    private @Nullable ScheduledFuture<?> connectionMonitor;\n+\n+    private ZonedDateTime lastCommunication = ZonedDateTime.now();\n+\n+    // initialize timeBetweenDataShouldArrive with a large number\n+    private Duration timeBetweenDataShouldArrive = Duration.ofDays(1);\n+    private final Duration dataCanBeLateTolerance = Duration.ofSeconds(5);\n+\n+    public SDS011Handler(Thing thing, SerialPortManager serialPortManager) {\n+        super(thing);\n+        this.serialPortManager = serialPortManager;\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        // we do not support refreshing as values are either reported by the device or polled from the device in fixed\n+        // intervals\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        config = getConfigAs(NovaFineDustConfiguration.class);\n+\n+        if (!validateConfiguration()) {\n+            return;\n+        }\n+\n+        // parse ports and if the port is found, initialize the reader\n+        SerialPortIdentifier portId = serialPortManager.getIdentifier(config.port);\n+        if (portId == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR, \"Port is not known!\");\n+            return;\n+        }\n+\n+        this.communicator = new SDS011Communicator(this, portId);\n+\n+        if (config.reporting) {\n+            timeBetweenDataShouldArrive = Duration.ofMinutes(config.reportingInterval);\n+            scheduler.schedule(() -> initializeCommunicator(WorkMode.REPORTING, timeBetweenDataShouldArrive), 0,\n+                    TimeUnit.SECONDS);\n+        } else {\n+            timeBetweenDataShouldArrive = Duration.ofSeconds(config.pollingInterval);\n+            scheduler.schedule(() -> initializeCommunicator(WorkMode.POLLING, timeBetweenDataShouldArrive), 0,\n+                    TimeUnit.SECONDS);\n+        }\n+\n+        Duration connectionMonitorStartDelay = timeBetweenDataShouldArrive.plus(CONNECTION_MONITOR_START_DELAY_OFFSET);\n+        connectionMonitor = scheduler.scheduleWithFixedDelay(this::verifyIfStillConnected,\n+                connectionMonitorStartDelay.getSeconds(), timeBetweenDataShouldArrive.getSeconds(), TimeUnit.SECONDS);\n+    }\n+\n+    private void initializeCommunicator(WorkMode mode, Duration interval) {\n+        boolean initSuccessful = false;\n+        try {\n+            initSuccessful = communicator.initialize(mode, interval);\n+        } catch (final IOException ex) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR, \"I/O error!\");\n+            return;\n+        } catch (PortInUseException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR, \"Port is in use!\");\n+            return;\n+        } catch (TooManyListenersException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                    \"Cannot attach listener to port!\");\n+            return;\n+        } catch (UnsupportedCommOperationException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                    \"Cannot set serial port parameters\");\n+            return;\n+        }\n+\n+        if (initSuccessful) {\n+            lastCommunication = ZonedDateTime.now();\n+            updateStatus(ThingStatus.ONLINE);\n+\n+            if (mode == WorkMode.POLLING) {\n+                pollingJob = scheduler.scheduleWithFixedDelay(() -> {\n+                    try {\n+                        communicator.requestSensorData();\n+                    } catch (IOException e) {\n+                        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                                \"Cannot query data from device\");\n+                    }\n+                }, 2, config.pollingInterval, TimeUnit.SECONDS);\n+            }\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                    \"Commands and replies from the device don't seem to match\");\n+            logger.debug(\"Could not configure sensor -> setting Thing to OFFLINE and disposing the handler\");\n+            dispose();\n+        }\n+    }\n+\n+    private boolean validateConfiguration() {\n+        if (config.port == null || config.port.isEmpty()) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR, \"Port must be set!\");\n+            return false;\n+        }\n+        return true;\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        if (pollingJob != null && !pollingJob.isCancelled()) {\n+            pollingJob.cancel(true);\n+            pollingJob = null;\n+        }\n+\n+        if (connectionMonitor != null && !connectionMonitor.isCancelled()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0d2971b437b5c6dffb681d35908a946d857530be"}, "originalPosition": 170}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY3NTU0NjM2OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.novafinedust/src/main/java/org/openhab/binding/novafinedust/internal/sds011protocol/SDS011Communicator.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yM1QyMjo1MToyNFrOGZrvOw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yM1QyMjo1MToyNFrOGZrvOw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTU4NDE4Nw==", "bodyText": "Please make these nullable.", "url": "https://github.com/openhab/openhab-addons/pull/7528#discussion_r429584187", "createdAt": "2020-05-23T22:51:24Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.novafinedust/src/main/java/org/openhab/binding/novafinedust/internal/sds011protocol/SDS011Communicator.java", "diffHunk": "@@ -0,0 +1,296 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.novafinedust.internal.sds011protocol;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.time.Duration;\n+import java.util.Arrays;\n+import java.util.TooManyListenersException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.io.transport.serial.PortInUseException;\n+import org.eclipse.smarthome.io.transport.serial.SerialPort;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortEvent;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortEventListener;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortIdentifier;\n+import org.eclipse.smarthome.io.transport.serial.UnsupportedCommOperationException;\n+import org.openhab.binding.novafinedust.internal.SDS011Handler;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.CommandMessage;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.Constants;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.ModeReply;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.SensorFirmwareReply;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.SensorMeasuredDataReply;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.SensorReply;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.SleepReply;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.WorkingPeriodReply;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Central instance to communicate with the device, i.e. receive data from it and send commands to it\n+ *\n+ * @author Stefan Triller - Initial contribution\n+ *\n+ */\n+@NonNullByDefault\n+public class SDS011Communicator implements SerialPortEventListener {\n+\n+    private final Logger logger = LoggerFactory.getLogger(SDS011Communicator.class);\n+\n+    private SerialPortIdentifier portId;\n+    private SDS011Handler thingHandler;\n+    private @NonNullByDefault({}) SerialPort serialPort;\n+\n+    private @NonNullByDefault({}) OutputStream outputStream;\n+    private @NonNullByDefault({}) InputStream inputStream;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0d2971b437b5c6dffb681d35908a946d857530be"}, "originalPosition": 58}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY3NTU0NzQ3OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.novafinedust/src/main/java/org/openhab/binding/novafinedust/internal/sds011protocol/SDS011Communicator.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yM1QyMjo1NDo0NlrOGZrvyQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNlQyMzoxMDozOVrOGazSfQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTU4NDMyOQ==", "bodyText": "Why is this necessary? inputStream.read() will block until data becomes available anyway.", "url": "https://github.com/openhab/openhab-addons/pull/7528#discussion_r429584329", "createdAt": "2020-05-23T22:54:46Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.novafinedust/src/main/java/org/openhab/binding/novafinedust/internal/sds011protocol/SDS011Communicator.java", "diffHunk": "@@ -0,0 +1,296 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.novafinedust.internal.sds011protocol;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.time.Duration;\n+import java.util.Arrays;\n+import java.util.TooManyListenersException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.io.transport.serial.PortInUseException;\n+import org.eclipse.smarthome.io.transport.serial.SerialPort;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortEvent;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortEventListener;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortIdentifier;\n+import org.eclipse.smarthome.io.transport.serial.UnsupportedCommOperationException;\n+import org.openhab.binding.novafinedust.internal.SDS011Handler;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.CommandMessage;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.Constants;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.ModeReply;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.SensorFirmwareReply;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.SensorMeasuredDataReply;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.SensorReply;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.SleepReply;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.WorkingPeriodReply;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Central instance to communicate with the device, i.e. receive data from it and send commands to it\n+ *\n+ * @author Stefan Triller - Initial contribution\n+ *\n+ */\n+@NonNullByDefault\n+public class SDS011Communicator implements SerialPortEventListener {\n+\n+    private final Logger logger = LoggerFactory.getLogger(SDS011Communicator.class);\n+\n+    private SerialPortIdentifier portId;\n+    private SDS011Handler thingHandler;\n+    private @NonNullByDefault({}) SerialPort serialPort;\n+\n+    private @NonNullByDefault({}) OutputStream outputStream;\n+    private @NonNullByDefault({}) InputStream inputStream;\n+\n+    public SDS011Communicator(SDS011Handler thingHandler, SerialPortIdentifier portId) {\n+        this.thingHandler = thingHandler;\n+        this.portId = portId;\n+    }\n+\n+    /**\n+     * Initialize the communication with the device, i.e. open the serial port etc.\n+     *\n+     * @param mode the {@link WorkMode} if we want to use polling or reporting\n+     * @param interval the time between polling or reportings\n+     * @return {@code true} if we can communicate with the device\n+     * @throws PortInUseException\n+     * @throws TooManyListenersException\n+     * @throws IOException\n+     * @throws UnsupportedCommOperationException\n+     */\n+    public boolean initialize(WorkMode mode, Duration interval)\n+            throws PortInUseException, TooManyListenersException, IOException, UnsupportedCommOperationException {\n+        boolean initSuccessful = true;\n+\n+        SerialPort localSerialPort = portId.open(thingHandler.getThing().getUID().toString(), 2000);\n+        localSerialPort.setSerialPortParams(9600, 8, 1, 0);\n+\n+        outputStream = localSerialPort.getOutputStream();\n+        inputStream = localSerialPort.getInputStream();\n+\n+        if (inputStream == null || outputStream == null) {\n+            throw new IOException(\"Could not create input or outputstream for the port\");\n+        }\n+\n+        // wake up the device\n+        initSuccessful &= sendSleep(false);\n+        initSuccessful &= getFirmware();\n+\n+        if (mode == WorkMode.POLLING) {\n+            initSuccessful &= setMode(WorkMode.POLLING);\n+            initSuccessful &= setWorkingPeriod((byte) 0);\n+        } else {\n+            // reporting\n+            initSuccessful &= setWorkingPeriod((byte) interval.toMinutes());\n+            initSuccessful &= setMode(WorkMode.REPORTING);\n+        }\n+\n+        // enable listeners only after we have configured the sensor above because for configuring we send and read data\n+        // sequentially\n+        localSerialPort.notifyOnDataAvailable(true);\n+        localSerialPort.addEventListener(this);\n+        this.serialPort = localSerialPort;\n+\n+        return initSuccessful;\n+    }\n+\n+    private @Nullable SensorReply sendCommand(CommandMessage message) throws IOException {\n+        byte[] commandData = message.getBytes();\n+        if (logger.isDebugEnabled()) {\n+            logger.debug(\"Will send command: {} ({})\", Helper.toHexString(commandData), Arrays.toString(commandData));\n+        }\n+        outputStream.write(commandData, 0, commandData.length);\n+        outputStream.flush();\n+        try {\n+            // Give the sensor some time to handle the command\n+            Thread.sleep(500);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0d2971b437b5c6dffb681d35908a946d857530be"}, "originalPosition": 121}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDAwNDE5MQ==", "bodyText": "Unfortunately this doesn't work. It is probably a \"feature\" of the sensor. So I have to wait here before reading the reply, otherwise the communication with the sensor will be broken.", "url": "https://github.com/openhab/openhab-addons/pull/7528#discussion_r430004191", "createdAt": "2020-05-25T16:05:58Z", "author": {"login": "t2000"}, "path": "bundles/org.openhab.binding.novafinedust/src/main/java/org/openhab/binding/novafinedust/internal/sds011protocol/SDS011Communicator.java", "diffHunk": "@@ -0,0 +1,296 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.novafinedust.internal.sds011protocol;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.time.Duration;\n+import java.util.Arrays;\n+import java.util.TooManyListenersException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.io.transport.serial.PortInUseException;\n+import org.eclipse.smarthome.io.transport.serial.SerialPort;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortEvent;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortEventListener;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortIdentifier;\n+import org.eclipse.smarthome.io.transport.serial.UnsupportedCommOperationException;\n+import org.openhab.binding.novafinedust.internal.SDS011Handler;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.CommandMessage;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.Constants;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.ModeReply;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.SensorFirmwareReply;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.SensorMeasuredDataReply;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.SensorReply;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.SleepReply;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.WorkingPeriodReply;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Central instance to communicate with the device, i.e. receive data from it and send commands to it\n+ *\n+ * @author Stefan Triller - Initial contribution\n+ *\n+ */\n+@NonNullByDefault\n+public class SDS011Communicator implements SerialPortEventListener {\n+\n+    private final Logger logger = LoggerFactory.getLogger(SDS011Communicator.class);\n+\n+    private SerialPortIdentifier portId;\n+    private SDS011Handler thingHandler;\n+    private @NonNullByDefault({}) SerialPort serialPort;\n+\n+    private @NonNullByDefault({}) OutputStream outputStream;\n+    private @NonNullByDefault({}) InputStream inputStream;\n+\n+    public SDS011Communicator(SDS011Handler thingHandler, SerialPortIdentifier portId) {\n+        this.thingHandler = thingHandler;\n+        this.portId = portId;\n+    }\n+\n+    /**\n+     * Initialize the communication with the device, i.e. open the serial port etc.\n+     *\n+     * @param mode the {@link WorkMode} if we want to use polling or reporting\n+     * @param interval the time between polling or reportings\n+     * @return {@code true} if we can communicate with the device\n+     * @throws PortInUseException\n+     * @throws TooManyListenersException\n+     * @throws IOException\n+     * @throws UnsupportedCommOperationException\n+     */\n+    public boolean initialize(WorkMode mode, Duration interval)\n+            throws PortInUseException, TooManyListenersException, IOException, UnsupportedCommOperationException {\n+        boolean initSuccessful = true;\n+\n+        SerialPort localSerialPort = portId.open(thingHandler.getThing().getUID().toString(), 2000);\n+        localSerialPort.setSerialPortParams(9600, 8, 1, 0);\n+\n+        outputStream = localSerialPort.getOutputStream();\n+        inputStream = localSerialPort.getInputStream();\n+\n+        if (inputStream == null || outputStream == null) {\n+            throw new IOException(\"Could not create input or outputstream for the port\");\n+        }\n+\n+        // wake up the device\n+        initSuccessful &= sendSleep(false);\n+        initSuccessful &= getFirmware();\n+\n+        if (mode == WorkMode.POLLING) {\n+            initSuccessful &= setMode(WorkMode.POLLING);\n+            initSuccessful &= setWorkingPeriod((byte) 0);\n+        } else {\n+            // reporting\n+            initSuccessful &= setWorkingPeriod((byte) interval.toMinutes());\n+            initSuccessful &= setMode(WorkMode.REPORTING);\n+        }\n+\n+        // enable listeners only after we have configured the sensor above because for configuring we send and read data\n+        // sequentially\n+        localSerialPort.notifyOnDataAvailable(true);\n+        localSerialPort.addEventListener(this);\n+        this.serialPort = localSerialPort;\n+\n+        return initSuccessful;\n+    }\n+\n+    private @Nullable SensorReply sendCommand(CommandMessage message) throws IOException {\n+        byte[] commandData = message.getBytes();\n+        if (logger.isDebugEnabled()) {\n+            logger.debug(\"Will send command: {} ({})\", Helper.toHexString(commandData), Arrays.toString(commandData));\n+        }\n+        outputStream.write(commandData, 0, commandData.length);\n+        outputStream.flush();\n+        try {\n+            // Give the sensor some time to handle the command\n+            Thread.sleep(500);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTU4NDMyOQ=="}, "originalCommit": {"oid": "0d2971b437b5c6dffb681d35908a946d857530be"}, "originalPosition": 121}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDc1NjQ3Nw==", "bodyText": "I'm still confused, how does reading data from a serial port break communication with the sensor. Are you sure this isn't a bug in the gnu.io serial library?", "url": "https://github.com/openhab/openhab-addons/pull/7528#discussion_r430756477", "createdAt": "2020-05-26T23:10:39Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.novafinedust/src/main/java/org/openhab/binding/novafinedust/internal/sds011protocol/SDS011Communicator.java", "diffHunk": "@@ -0,0 +1,296 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.novafinedust.internal.sds011protocol;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.time.Duration;\n+import java.util.Arrays;\n+import java.util.TooManyListenersException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.io.transport.serial.PortInUseException;\n+import org.eclipse.smarthome.io.transport.serial.SerialPort;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortEvent;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortEventListener;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortIdentifier;\n+import org.eclipse.smarthome.io.transport.serial.UnsupportedCommOperationException;\n+import org.openhab.binding.novafinedust.internal.SDS011Handler;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.CommandMessage;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.Constants;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.ModeReply;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.SensorFirmwareReply;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.SensorMeasuredDataReply;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.SensorReply;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.SleepReply;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.WorkingPeriodReply;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Central instance to communicate with the device, i.e. receive data from it and send commands to it\n+ *\n+ * @author Stefan Triller - Initial contribution\n+ *\n+ */\n+@NonNullByDefault\n+public class SDS011Communicator implements SerialPortEventListener {\n+\n+    private final Logger logger = LoggerFactory.getLogger(SDS011Communicator.class);\n+\n+    private SerialPortIdentifier portId;\n+    private SDS011Handler thingHandler;\n+    private @NonNullByDefault({}) SerialPort serialPort;\n+\n+    private @NonNullByDefault({}) OutputStream outputStream;\n+    private @NonNullByDefault({}) InputStream inputStream;\n+\n+    public SDS011Communicator(SDS011Handler thingHandler, SerialPortIdentifier portId) {\n+        this.thingHandler = thingHandler;\n+        this.portId = portId;\n+    }\n+\n+    /**\n+     * Initialize the communication with the device, i.e. open the serial port etc.\n+     *\n+     * @param mode the {@link WorkMode} if we want to use polling or reporting\n+     * @param interval the time between polling or reportings\n+     * @return {@code true} if we can communicate with the device\n+     * @throws PortInUseException\n+     * @throws TooManyListenersException\n+     * @throws IOException\n+     * @throws UnsupportedCommOperationException\n+     */\n+    public boolean initialize(WorkMode mode, Duration interval)\n+            throws PortInUseException, TooManyListenersException, IOException, UnsupportedCommOperationException {\n+        boolean initSuccessful = true;\n+\n+        SerialPort localSerialPort = portId.open(thingHandler.getThing().getUID().toString(), 2000);\n+        localSerialPort.setSerialPortParams(9600, 8, 1, 0);\n+\n+        outputStream = localSerialPort.getOutputStream();\n+        inputStream = localSerialPort.getInputStream();\n+\n+        if (inputStream == null || outputStream == null) {\n+            throw new IOException(\"Could not create input or outputstream for the port\");\n+        }\n+\n+        // wake up the device\n+        initSuccessful &= sendSleep(false);\n+        initSuccessful &= getFirmware();\n+\n+        if (mode == WorkMode.POLLING) {\n+            initSuccessful &= setMode(WorkMode.POLLING);\n+            initSuccessful &= setWorkingPeriod((byte) 0);\n+        } else {\n+            // reporting\n+            initSuccessful &= setWorkingPeriod((byte) interval.toMinutes());\n+            initSuccessful &= setMode(WorkMode.REPORTING);\n+        }\n+\n+        // enable listeners only after we have configured the sensor above because for configuring we send and read data\n+        // sequentially\n+        localSerialPort.notifyOnDataAvailable(true);\n+        localSerialPort.addEventListener(this);\n+        this.serialPort = localSerialPort;\n+\n+        return initSuccessful;\n+    }\n+\n+    private @Nullable SensorReply sendCommand(CommandMessage message) throws IOException {\n+        byte[] commandData = message.getBytes();\n+        if (logger.isDebugEnabled()) {\n+            logger.debug(\"Will send command: {} ({})\", Helper.toHexString(commandData), Arrays.toString(commandData));\n+        }\n+        outputStream.write(commandData, 0, commandData.length);\n+        outputStream.flush();\n+        try {\n+            // Give the sensor some time to handle the command\n+            Thread.sleep(500);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTU4NDMyOQ=="}, "originalCommit": {"oid": "0d2971b437b5c6dffb681d35908a946d857530be"}, "originalPosition": 121}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY3NTU1MTMzOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.novafinedust/src/main/java/org/openhab/binding/novafinedust/internal/sds011protocol/SDS011Communicator.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yM1QyMzowNTo0NFrOGZrxpQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNlQyMzoxNjozNlrOGazZ3w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTU4NDgwNQ==", "bodyText": "Wouldn't this already be called implicitly through serialEvent? Wouldn't the data on the input stream be gone at that point? Could you explain how this works? I might be misunderstanding how the serial protocol works.", "url": "https://github.com/openhab/openhab-addons/pull/7528#discussion_r429584805", "createdAt": "2020-05-23T23:05:44Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.novafinedust/src/main/java/org/openhab/binding/novafinedust/internal/sds011protocol/SDS011Communicator.java", "diffHunk": "@@ -0,0 +1,296 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.novafinedust.internal.sds011protocol;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.time.Duration;\n+import java.util.Arrays;\n+import java.util.TooManyListenersException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.io.transport.serial.PortInUseException;\n+import org.eclipse.smarthome.io.transport.serial.SerialPort;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortEvent;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortEventListener;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortIdentifier;\n+import org.eclipse.smarthome.io.transport.serial.UnsupportedCommOperationException;\n+import org.openhab.binding.novafinedust.internal.SDS011Handler;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.CommandMessage;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.Constants;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.ModeReply;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.SensorFirmwareReply;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.SensorMeasuredDataReply;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.SensorReply;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.SleepReply;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.WorkingPeriodReply;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Central instance to communicate with the device, i.e. receive data from it and send commands to it\n+ *\n+ * @author Stefan Triller - Initial contribution\n+ *\n+ */\n+@NonNullByDefault\n+public class SDS011Communicator implements SerialPortEventListener {\n+\n+    private final Logger logger = LoggerFactory.getLogger(SDS011Communicator.class);\n+\n+    private SerialPortIdentifier portId;\n+    private SDS011Handler thingHandler;\n+    private @NonNullByDefault({}) SerialPort serialPort;\n+\n+    private @NonNullByDefault({}) OutputStream outputStream;\n+    private @NonNullByDefault({}) InputStream inputStream;\n+\n+    public SDS011Communicator(SDS011Handler thingHandler, SerialPortIdentifier portId) {\n+        this.thingHandler = thingHandler;\n+        this.portId = portId;\n+    }\n+\n+    /**\n+     * Initialize the communication with the device, i.e. open the serial port etc.\n+     *\n+     * @param mode the {@link WorkMode} if we want to use polling or reporting\n+     * @param interval the time between polling or reportings\n+     * @return {@code true} if we can communicate with the device\n+     * @throws PortInUseException\n+     * @throws TooManyListenersException\n+     * @throws IOException\n+     * @throws UnsupportedCommOperationException\n+     */\n+    public boolean initialize(WorkMode mode, Duration interval)\n+            throws PortInUseException, TooManyListenersException, IOException, UnsupportedCommOperationException {\n+        boolean initSuccessful = true;\n+\n+        SerialPort localSerialPort = portId.open(thingHandler.getThing().getUID().toString(), 2000);\n+        localSerialPort.setSerialPortParams(9600, 8, 1, 0);\n+\n+        outputStream = localSerialPort.getOutputStream();\n+        inputStream = localSerialPort.getInputStream();\n+\n+        if (inputStream == null || outputStream == null) {\n+            throw new IOException(\"Could not create input or outputstream for the port\");\n+        }\n+\n+        // wake up the device\n+        initSuccessful &= sendSleep(false);\n+        initSuccessful &= getFirmware();\n+\n+        if (mode == WorkMode.POLLING) {\n+            initSuccessful &= setMode(WorkMode.POLLING);\n+            initSuccessful &= setWorkingPeriod((byte) 0);\n+        } else {\n+            // reporting\n+            initSuccessful &= setWorkingPeriod((byte) interval.toMinutes());\n+            initSuccessful &= setMode(WorkMode.REPORTING);\n+        }\n+\n+        // enable listeners only after we have configured the sensor above because for configuring we send and read data\n+        // sequentially\n+        localSerialPort.notifyOnDataAvailable(true);\n+        localSerialPort.addEventListener(this);\n+        this.serialPort = localSerialPort;\n+\n+        return initSuccessful;\n+    }\n+\n+    private @Nullable SensorReply sendCommand(CommandMessage message) throws IOException {\n+        byte[] commandData = message.getBytes();\n+        if (logger.isDebugEnabled()) {\n+            logger.debug(\"Will send command: {} ({})\", Helper.toHexString(commandData), Arrays.toString(commandData));\n+        }\n+        outputStream.write(commandData, 0, commandData.length);\n+        outputStream.flush();\n+        try {\n+            // Give the sensor some time to handle the command\n+            Thread.sleep(500);\n+        } catch (InterruptedException e) {\n+            logger.warn(\"Problem while waiting for reading a reply to our command.\");\n+            Thread.currentThread().interrupt();\n+        }\n+        SensorReply reply = readReply();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0d2971b437b5c6dffb681d35908a946d857530be"}, "originalPosition": 126}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDAwNDE3Mg==", "bodyText": "I am configuring the sensor with the commands BEFORE I register the listener.\nI found it a lot easier to do the protocol stuff in a synchronous manner so I have commands and their replies in one place to check if they belong together and there are no errors.\nSo this is all done before the calls:\nlocalSerialPort.notifyOnDataAvailable(true);\nlocalSerialPort.addEventListener(this);", "url": "https://github.com/openhab/openhab-addons/pull/7528#discussion_r430004172", "createdAt": "2020-05-25T16:05:54Z", "author": {"login": "t2000"}, "path": "bundles/org.openhab.binding.novafinedust/src/main/java/org/openhab/binding/novafinedust/internal/sds011protocol/SDS011Communicator.java", "diffHunk": "@@ -0,0 +1,296 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.novafinedust.internal.sds011protocol;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.time.Duration;\n+import java.util.Arrays;\n+import java.util.TooManyListenersException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.io.transport.serial.PortInUseException;\n+import org.eclipse.smarthome.io.transport.serial.SerialPort;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortEvent;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortEventListener;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortIdentifier;\n+import org.eclipse.smarthome.io.transport.serial.UnsupportedCommOperationException;\n+import org.openhab.binding.novafinedust.internal.SDS011Handler;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.CommandMessage;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.Constants;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.ModeReply;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.SensorFirmwareReply;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.SensorMeasuredDataReply;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.SensorReply;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.SleepReply;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.WorkingPeriodReply;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Central instance to communicate with the device, i.e. receive data from it and send commands to it\n+ *\n+ * @author Stefan Triller - Initial contribution\n+ *\n+ */\n+@NonNullByDefault\n+public class SDS011Communicator implements SerialPortEventListener {\n+\n+    private final Logger logger = LoggerFactory.getLogger(SDS011Communicator.class);\n+\n+    private SerialPortIdentifier portId;\n+    private SDS011Handler thingHandler;\n+    private @NonNullByDefault({}) SerialPort serialPort;\n+\n+    private @NonNullByDefault({}) OutputStream outputStream;\n+    private @NonNullByDefault({}) InputStream inputStream;\n+\n+    public SDS011Communicator(SDS011Handler thingHandler, SerialPortIdentifier portId) {\n+        this.thingHandler = thingHandler;\n+        this.portId = portId;\n+    }\n+\n+    /**\n+     * Initialize the communication with the device, i.e. open the serial port etc.\n+     *\n+     * @param mode the {@link WorkMode} if we want to use polling or reporting\n+     * @param interval the time between polling or reportings\n+     * @return {@code true} if we can communicate with the device\n+     * @throws PortInUseException\n+     * @throws TooManyListenersException\n+     * @throws IOException\n+     * @throws UnsupportedCommOperationException\n+     */\n+    public boolean initialize(WorkMode mode, Duration interval)\n+            throws PortInUseException, TooManyListenersException, IOException, UnsupportedCommOperationException {\n+        boolean initSuccessful = true;\n+\n+        SerialPort localSerialPort = portId.open(thingHandler.getThing().getUID().toString(), 2000);\n+        localSerialPort.setSerialPortParams(9600, 8, 1, 0);\n+\n+        outputStream = localSerialPort.getOutputStream();\n+        inputStream = localSerialPort.getInputStream();\n+\n+        if (inputStream == null || outputStream == null) {\n+            throw new IOException(\"Could not create input or outputstream for the port\");\n+        }\n+\n+        // wake up the device\n+        initSuccessful &= sendSleep(false);\n+        initSuccessful &= getFirmware();\n+\n+        if (mode == WorkMode.POLLING) {\n+            initSuccessful &= setMode(WorkMode.POLLING);\n+            initSuccessful &= setWorkingPeriod((byte) 0);\n+        } else {\n+            // reporting\n+            initSuccessful &= setWorkingPeriod((byte) interval.toMinutes());\n+            initSuccessful &= setMode(WorkMode.REPORTING);\n+        }\n+\n+        // enable listeners only after we have configured the sensor above because for configuring we send and read data\n+        // sequentially\n+        localSerialPort.notifyOnDataAvailable(true);\n+        localSerialPort.addEventListener(this);\n+        this.serialPort = localSerialPort;\n+\n+        return initSuccessful;\n+    }\n+\n+    private @Nullable SensorReply sendCommand(CommandMessage message) throws IOException {\n+        byte[] commandData = message.getBytes();\n+        if (logger.isDebugEnabled()) {\n+            logger.debug(\"Will send command: {} ({})\", Helper.toHexString(commandData), Arrays.toString(commandData));\n+        }\n+        outputStream.write(commandData, 0, commandData.length);\n+        outputStream.flush();\n+        try {\n+            // Give the sensor some time to handle the command\n+            Thread.sleep(500);\n+        } catch (InterruptedException e) {\n+            logger.warn(\"Problem while waiting for reading a reply to our command.\");\n+            Thread.currentThread().interrupt();\n+        }\n+        SensorReply reply = readReply();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTU4NDgwNQ=="}, "originalCommit": {"oid": "0d2971b437b5c6dffb681d35908a946d857530be"}, "originalPosition": 126}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDc1ODM2Nw==", "bodyText": "Ah! Didn't notice that, makes a lot more sense now, thanks!", "url": "https://github.com/openhab/openhab-addons/pull/7528#discussion_r430758367", "createdAt": "2020-05-26T23:16:36Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.novafinedust/src/main/java/org/openhab/binding/novafinedust/internal/sds011protocol/SDS011Communicator.java", "diffHunk": "@@ -0,0 +1,296 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.novafinedust.internal.sds011protocol;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.time.Duration;\n+import java.util.Arrays;\n+import java.util.TooManyListenersException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.io.transport.serial.PortInUseException;\n+import org.eclipse.smarthome.io.transport.serial.SerialPort;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortEvent;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortEventListener;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortIdentifier;\n+import org.eclipse.smarthome.io.transport.serial.UnsupportedCommOperationException;\n+import org.openhab.binding.novafinedust.internal.SDS011Handler;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.CommandMessage;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.Constants;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.ModeReply;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.SensorFirmwareReply;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.SensorMeasuredDataReply;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.SensorReply;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.SleepReply;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.WorkingPeriodReply;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Central instance to communicate with the device, i.e. receive data from it and send commands to it\n+ *\n+ * @author Stefan Triller - Initial contribution\n+ *\n+ */\n+@NonNullByDefault\n+public class SDS011Communicator implements SerialPortEventListener {\n+\n+    private final Logger logger = LoggerFactory.getLogger(SDS011Communicator.class);\n+\n+    private SerialPortIdentifier portId;\n+    private SDS011Handler thingHandler;\n+    private @NonNullByDefault({}) SerialPort serialPort;\n+\n+    private @NonNullByDefault({}) OutputStream outputStream;\n+    private @NonNullByDefault({}) InputStream inputStream;\n+\n+    public SDS011Communicator(SDS011Handler thingHandler, SerialPortIdentifier portId) {\n+        this.thingHandler = thingHandler;\n+        this.portId = portId;\n+    }\n+\n+    /**\n+     * Initialize the communication with the device, i.e. open the serial port etc.\n+     *\n+     * @param mode the {@link WorkMode} if we want to use polling or reporting\n+     * @param interval the time between polling or reportings\n+     * @return {@code true} if we can communicate with the device\n+     * @throws PortInUseException\n+     * @throws TooManyListenersException\n+     * @throws IOException\n+     * @throws UnsupportedCommOperationException\n+     */\n+    public boolean initialize(WorkMode mode, Duration interval)\n+            throws PortInUseException, TooManyListenersException, IOException, UnsupportedCommOperationException {\n+        boolean initSuccessful = true;\n+\n+        SerialPort localSerialPort = portId.open(thingHandler.getThing().getUID().toString(), 2000);\n+        localSerialPort.setSerialPortParams(9600, 8, 1, 0);\n+\n+        outputStream = localSerialPort.getOutputStream();\n+        inputStream = localSerialPort.getInputStream();\n+\n+        if (inputStream == null || outputStream == null) {\n+            throw new IOException(\"Could not create input or outputstream for the port\");\n+        }\n+\n+        // wake up the device\n+        initSuccessful &= sendSleep(false);\n+        initSuccessful &= getFirmware();\n+\n+        if (mode == WorkMode.POLLING) {\n+            initSuccessful &= setMode(WorkMode.POLLING);\n+            initSuccessful &= setWorkingPeriod((byte) 0);\n+        } else {\n+            // reporting\n+            initSuccessful &= setWorkingPeriod((byte) interval.toMinutes());\n+            initSuccessful &= setMode(WorkMode.REPORTING);\n+        }\n+\n+        // enable listeners only after we have configured the sensor above because for configuring we send and read data\n+        // sequentially\n+        localSerialPort.notifyOnDataAvailable(true);\n+        localSerialPort.addEventListener(this);\n+        this.serialPort = localSerialPort;\n+\n+        return initSuccessful;\n+    }\n+\n+    private @Nullable SensorReply sendCommand(CommandMessage message) throws IOException {\n+        byte[] commandData = message.getBytes();\n+        if (logger.isDebugEnabled()) {\n+            logger.debug(\"Will send command: {} ({})\", Helper.toHexString(commandData), Arrays.toString(commandData));\n+        }\n+        outputStream.write(commandData, 0, commandData.length);\n+        outputStream.flush();\n+        try {\n+            // Give the sensor some time to handle the command\n+            Thread.sleep(500);\n+        } catch (InterruptedException e) {\n+            logger.warn(\"Problem while waiting for reading a reply to our command.\");\n+            Thread.currentThread().interrupt();\n+        }\n+        SensorReply reply = readReply();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTU4NDgwNQ=="}, "originalCommit": {"oid": "0d2971b437b5c6dffb681d35908a946d857530be"}, "originalPosition": 126}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY3NTU1MjkwOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.novafinedust/src/main/resources/ESH-INF/thing/thing-types.xml", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yM1QyMzoxMDowN1rOGZryYg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yM1QyMzoxMDowN1rOGZryYg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTU4NDk5NA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\t\t<parameter name=\"reportingInterval\" type=\"integer\" min=\"0\" max=\"30\">\n          \n          \n            \n            \t\t\t<parameter name=\"reportingInterval\" type=\"integer\" min=\"0\" max=\"30\" unit=\"min\">", "url": "https://github.com/openhab/openhab-addons/pull/7528#discussion_r429584994", "createdAt": "2020-05-23T23:10:07Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.novafinedust/src/main/resources/ESH-INF/thing/thing-types.xml", "diffHunk": "@@ -0,0 +1,57 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"novafinedust\"\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\n+\t<thing-type id=\"SDS011\">\n+\t\t<label>Nova SDS011 Fine Dust Sensor</label>\n+\t\t<description>Nova SDS011 Fine Dust Sensor connected via USB</description>\n+\n+\t\t<channels>\n+\t\t\t<channel id=\"pm10\" typeId=\"pm10-type\" />\n+\t\t\t<channel id=\"pm25\" typeId=\"pm25-type\" />\n+\t\t</channels>\n+\n+\t\t<config-description>\n+\t\t\t<parameter name=\"port\" type=\"text\" required=\"true\">\n+\t\t\t\t<context>serial-port</context>\n+\t\t\t\t<label>USB Port</label>\n+\t\t\t\t<description>USB port the device is connected to i.e. /dev/ttyUSB0</description>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"reporting\" type=\"boolean\">\n+\t\t\t\t<default>true</default>\n+\t\t\t\t<label>Reporting if true, otherwise polling</label>\n+\t\t\t\t<description>Reporting is strongly recommended to increase sensor lifetime</description>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"reportingInterval\" type=\"integer\" min=\"0\" max=\"30\">", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0d2971b437b5c6dffb681d35908a946d857530be"}, "originalPosition": 27}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY3NTU1MzAxOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.novafinedust/src/main/resources/ESH-INF/thing/thing-types.xml", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yM1QyMzoxMDoyNFrOGZrybw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yM1QyMzoxMDoyNFrOGZrybw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTU4NTAwNw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\t\t<parameter name=\"pollingInterval\" type=\"integer\" min=\"3\" max=\"3600\">\n          \n          \n            \n            \t\t\t<parameter name=\"pollingInterval\" type=\"integer\" min=\"3\" max=\"3600\" unit=\"s\">", "url": "https://github.com/openhab/openhab-addons/pull/7528#discussion_r429585007", "createdAt": "2020-05-23T23:10:24Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.novafinedust/src/main/resources/ESH-INF/thing/thing-types.xml", "diffHunk": "@@ -0,0 +1,57 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"novafinedust\"\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\n+\t<thing-type id=\"SDS011\">\n+\t\t<label>Nova SDS011 Fine Dust Sensor</label>\n+\t\t<description>Nova SDS011 Fine Dust Sensor connected via USB</description>\n+\n+\t\t<channels>\n+\t\t\t<channel id=\"pm10\" typeId=\"pm10-type\" />\n+\t\t\t<channel id=\"pm25\" typeId=\"pm25-type\" />\n+\t\t</channels>\n+\n+\t\t<config-description>\n+\t\t\t<parameter name=\"port\" type=\"text\" required=\"true\">\n+\t\t\t\t<context>serial-port</context>\n+\t\t\t\t<label>USB Port</label>\n+\t\t\t\t<description>USB port the device is connected to i.e. /dev/ttyUSB0</description>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"reporting\" type=\"boolean\">\n+\t\t\t\t<default>true</default>\n+\t\t\t\t<label>Reporting if true, otherwise polling</label>\n+\t\t\t\t<description>Reporting is strongly recommended to increase sensor lifetime</description>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"reportingInterval\" type=\"integer\" min=\"0\" max=\"30\">\n+\t\t\t\t<default>1</default>\n+\t\t\t\t<advanced>true</advanced>\n+\t\t\t\t<label>Time in minutes when a value will be reported</label>\n+\t\t\t\t<description>Device will report every x minutes and sleep for x*60 - 30 seconds afterwards, 0 = as fast as possible without sleep</description>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"pollingInterval\" type=\"integer\" min=\"3\" max=\"3600\">", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0d2971b437b5c6dffb681d35908a946d857530be"}, "originalPosition": 33}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY3NTU1MzQwOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.novafinedust/src/main/resources/ESH-INF/thing/thing-types.xml", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yM1QyMzoxMTowMVrOGZrymA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yM1QyMzoxMTowMVrOGZrymA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTU4NTA0OA==", "bodyText": "The first letter of every word in a label should be capitalized.", "url": "https://github.com/openhab/openhab-addons/pull/7528#discussion_r429585048", "createdAt": "2020-05-23T23:11:01Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.novafinedust/src/main/resources/ESH-INF/thing/thing-types.xml", "diffHunk": "@@ -0,0 +1,57 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"novafinedust\"\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\n+\t<thing-type id=\"SDS011\">\n+\t\t<label>Nova SDS011 Fine Dust Sensor</label>\n+\t\t<description>Nova SDS011 Fine Dust Sensor connected via USB</description>\n+\n+\t\t<channels>\n+\t\t\t<channel id=\"pm10\" typeId=\"pm10-type\" />\n+\t\t\t<channel id=\"pm25\" typeId=\"pm25-type\" />\n+\t\t</channels>\n+\n+\t\t<config-description>\n+\t\t\t<parameter name=\"port\" type=\"text\" required=\"true\">\n+\t\t\t\t<context>serial-port</context>\n+\t\t\t\t<label>USB Port</label>\n+\t\t\t\t<description>USB port the device is connected to i.e. /dev/ttyUSB0</description>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"reporting\" type=\"boolean\">\n+\t\t\t\t<default>true</default>\n+\t\t\t\t<label>Reporting if true, otherwise polling</label>\n+\t\t\t\t<description>Reporting is strongly recommended to increase sensor lifetime</description>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"reportingInterval\" type=\"integer\" min=\"0\" max=\"30\">\n+\t\t\t\t<default>1</default>\n+\t\t\t\t<advanced>true</advanced>\n+\t\t\t\t<label>Time in minutes when a value will be reported</label>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0d2971b437b5c6dffb681d35908a946d857530be"}, "originalPosition": 30}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY3NTU1MzQ1OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.novafinedust/src/main/resources/ESH-INF/thing/thing-types.xml", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yM1QyMzoxMToxMlrOGZrynQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yM1QyMzoxMToxMlrOGZrynQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTU4NTA1Mw==", "bodyText": "The first letter of every word in a label should be capitalized.", "url": "https://github.com/openhab/openhab-addons/pull/7528#discussion_r429585053", "createdAt": "2020-05-23T23:11:12Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.novafinedust/src/main/resources/ESH-INF/thing/thing-types.xml", "diffHunk": "@@ -0,0 +1,57 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"novafinedust\"\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\n+\t<thing-type id=\"SDS011\">\n+\t\t<label>Nova SDS011 Fine Dust Sensor</label>\n+\t\t<description>Nova SDS011 Fine Dust Sensor connected via USB</description>\n+\n+\t\t<channels>\n+\t\t\t<channel id=\"pm10\" typeId=\"pm10-type\" />\n+\t\t\t<channel id=\"pm25\" typeId=\"pm25-type\" />\n+\t\t</channels>\n+\n+\t\t<config-description>\n+\t\t\t<parameter name=\"port\" type=\"text\" required=\"true\">\n+\t\t\t\t<context>serial-port</context>\n+\t\t\t\t<label>USB Port</label>\n+\t\t\t\t<description>USB port the device is connected to i.e. /dev/ttyUSB0</description>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"reporting\" type=\"boolean\">\n+\t\t\t\t<default>true</default>\n+\t\t\t\t<label>Reporting if true, otherwise polling</label>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0d2971b437b5c6dffb681d35908a946d857530be"}, "originalPosition": 24}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY3NTU1MzUwOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.novafinedust/src/main/resources/ESH-INF/thing/thing-types.xml", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yM1QyMzoxMToyOVrOGZrypQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yM1QyMzoxMToyOVrOGZrypQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTU4NTA2MQ==", "bodyText": "The first letter of every word in a label should be capitalized.", "url": "https://github.com/openhab/openhab-addons/pull/7528#discussion_r429585061", "createdAt": "2020-05-23T23:11:29Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.novafinedust/src/main/resources/ESH-INF/thing/thing-types.xml", "diffHunk": "@@ -0,0 +1,57 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"novafinedust\"\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\n+\t<thing-type id=\"SDS011\">\n+\t\t<label>Nova SDS011 Fine Dust Sensor</label>\n+\t\t<description>Nova SDS011 Fine Dust Sensor connected via USB</description>\n+\n+\t\t<channels>\n+\t\t\t<channel id=\"pm10\" typeId=\"pm10-type\" />\n+\t\t\t<channel id=\"pm25\" typeId=\"pm25-type\" />\n+\t\t</channels>\n+\n+\t\t<config-description>\n+\t\t\t<parameter name=\"port\" type=\"text\" required=\"true\">\n+\t\t\t\t<context>serial-port</context>\n+\t\t\t\t<label>USB Port</label>\n+\t\t\t\t<description>USB port the device is connected to i.e. /dev/ttyUSB0</description>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"reporting\" type=\"boolean\">\n+\t\t\t\t<default>true</default>\n+\t\t\t\t<label>Reporting if true, otherwise polling</label>\n+\t\t\t\t<description>Reporting is strongly recommended to increase sensor lifetime</description>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"reportingInterval\" type=\"integer\" min=\"0\" max=\"30\">\n+\t\t\t\t<default>1</default>\n+\t\t\t\t<advanced>true</advanced>\n+\t\t\t\t<label>Time in minutes when a value will be reported</label>\n+\t\t\t\t<description>Device will report every x minutes and sleep for x*60 - 30 seconds afterwards, 0 = as fast as possible without sleep</description>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"pollingInterval\" type=\"integer\" min=\"3\" max=\"3600\">\n+\t\t\t\t<default>10</default>\n+\t\t\t\t<advanced>true</advanced>\n+\t\t\t\t<label>Time in seconds when a value will be polled from the device (min 3 seconds)</label>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0d2971b437b5c6dffb681d35908a946d857530be"}, "originalPosition": 36}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY3NTU1MzcyOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.novafinedust/src/main/java/org/openhab/binding/novafinedust/internal/sds011protocol/WorkMode.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yM1QyMzoxMjoyN1rOGZrywQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yM1QyMzoxMjoyN1rOGZrywQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTU4NTA4OQ==", "bodyText": "Please add @NonNullByDefault", "url": "https://github.com/openhab/openhab-addons/pull/7528#discussion_r429585089", "createdAt": "2020-05-23T23:12:27Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.novafinedust/src/main/java/org/openhab/binding/novafinedust/internal/sds011protocol/WorkMode.java", "diffHunk": "@@ -0,0 +1,24 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.novafinedust.internal.sds011protocol;\n+\n+/**\n+ * Enum for the different sensor modes\n+ *\n+ * @author Stefan Triller - Initial contribution\n+ *\n+ */\n+public enum WorkMode {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0d2971b437b5c6dffb681d35908a946d857530be"}, "originalPosition": 21}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY4MTcxMDAzOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.novafinedust/src/main/java/org/openhab/binding/novafinedust/internal/sds011protocol/messages/SensorReply.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNlQxNjoxNTo1M1rOGal8Hw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNlQxNjoxNTo1M1rOGal8Hw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDUzNzc1OQ==", "bodyText": "Please make these final if possible", "url": "https://github.com/openhab/openhab-addons/pull/7528#discussion_r430537759", "createdAt": "2020-05-26T16:15:53Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.novafinedust/src/main/java/org/openhab/binding/novafinedust/internal/sds011protocol/messages/SensorReply.java", "diffHunk": "@@ -0,0 +1,89 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.novafinedust.internal.sds011protocol.messages;\n+\n+import java.util.Arrays;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.smarthome.core.util.HexUtils;\n+\n+/**\n+ * Base class holding information sent by the sensor to us\n+ *\n+ * @author Stefan Triller - Initial contribution\n+ *\n+ */\n+@NonNullByDefault\n+public class SensorReply {\n+\n+    protected byte header;\n+    protected byte commandID;\n+    protected byte[] payLoad = new byte[4];\n+    protected byte[] deviceID = new byte[2];\n+    protected byte checksum;\n+    protected byte messageTail;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "78275e3df58da1567b75c9b1b2b6ef36af1bc404"}, "originalPosition": 34}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY4MTcyMDcwOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.novafinedust/src/main/java/org/openhab/binding/novafinedust/internal/sds011protocol/messages/SensorMeasuredDataReply.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNlQxNjoxODoxNVrOGamCZg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNlQxNjoxODoxNVrOGamCZg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDUzOTM2Ng==", "bodyText": "Please make these final if possible", "url": "https://github.com/openhab/openhab-addons/pull/7528#discussion_r430539366", "createdAt": "2020-05-26T16:18:15Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.novafinedust/src/main/java/org/openhab/binding/novafinedust/internal/sds011protocol/messages/SensorMeasuredDataReply.java", "diffHunk": "@@ -0,0 +1,79 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.novafinedust.internal.sds011protocol.messages;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.smarthome.core.util.HexUtils;\n+\n+/**\n+ * Class containing the actual measured values from the sensor\n+ *\n+ * @author Stefan Triller - Initial contribution\n+ *\n+ */\n+@NonNullByDefault\n+public class SensorMeasuredDataReply extends SensorReply {\n+    private byte pm25lowByte;\n+    private byte pm25highByte;\n+    private byte pm10lowByte;\n+    private byte pm10highByte;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "78275e3df58da1567b75c9b1b2b6ef36af1bc404"}, "originalPosition": 29}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY4MTc0MDE0OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.novafinedust/src/main/java/org/openhab/binding/novafinedust/internal/sds011protocol/messages/CommandMessage.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNlQxNjoyMjozN1rOGamOFw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNlQxNjoyMjozN1rOGamOFw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDU0MjM1OQ==", "bodyText": "please make this final", "url": "https://github.com/openhab/openhab-addons/pull/7528#discussion_r430542359", "createdAt": "2020-05-26T16:22:37Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.novafinedust/src/main/java/org/openhab/binding/novafinedust/internal/sds011protocol/messages/CommandMessage.java", "diffHunk": "@@ -0,0 +1,97 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.novafinedust.internal.sds011protocol.messages;\n+\n+import java.io.ByteArrayOutputStream;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.smarthome.core.util.HexUtils;\n+\n+/**\n+ * Message to be send to the device\n+ *\n+ * @author Stefan Triller - Initial contribution\n+ *\n+ */\n+@NonNullByDefault\n+public class CommandMessage {\n+    private static final byte HEAD = -86; // AA\n+    private static final byte COMMAND_ID = -76; // B4\n+    private static final byte TAIL = -85; // AB\n+\n+    private static final int DATA_BYTES_AFTER_FIRST_DATA_BYTE = 12;\n+\n+    private byte firstDataByte;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "78275e3df58da1567b75c9b1b2b6ef36af1bc404"}, "originalPosition": 34}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY4MzA3MDcwOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.novafinedust/src/main/java/org/openhab/binding/novafinedust/internal/sds011protocol/SDS011Communicator.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNlQyMzoxNzo1MFrOGazbMA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yN1QxNTo0ODo1NlrOGbRRqg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDc1ODcwNA==", "bodyText": "shouldn't you remove the event listener before you call this?", "url": "https://github.com/openhab/openhab-addons/pull/7528#discussion_r430758704", "createdAt": "2020-05-26T23:17:50Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.novafinedust/src/main/java/org/openhab/binding/novafinedust/internal/sds011protocol/SDS011Communicator.java", "diffHunk": "@@ -0,0 +1,297 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.novafinedust.internal.sds011protocol;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.time.Duration;\n+import java.util.Arrays;\n+import java.util.TooManyListenersException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.util.HexUtils;\n+import org.eclipse.smarthome.io.transport.serial.PortInUseException;\n+import org.eclipse.smarthome.io.transport.serial.SerialPort;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortEvent;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortEventListener;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortIdentifier;\n+import org.eclipse.smarthome.io.transport.serial.UnsupportedCommOperationException;\n+import org.openhab.binding.novafinedust.internal.SDS011Handler;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.CommandMessage;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.Constants;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.ModeReply;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.SensorFirmwareReply;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.SensorMeasuredDataReply;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.SensorReply;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.SleepReply;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.WorkingPeriodReply;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Central instance to communicate with the device, i.e. receive data from it and send commands to it\n+ *\n+ * @author Stefan Triller - Initial contribution\n+ *\n+ */\n+@NonNullByDefault\n+public class SDS011Communicator implements SerialPortEventListener {\n+\n+    private final Logger logger = LoggerFactory.getLogger(SDS011Communicator.class);\n+\n+    private SerialPortIdentifier portId;\n+    private SDS011Handler thingHandler;\n+    private @NonNullByDefault({}) SerialPort serialPort;\n+\n+    private @Nullable OutputStream outputStream;\n+    private @Nullable InputStream inputStream;\n+\n+    public SDS011Communicator(SDS011Handler thingHandler, SerialPortIdentifier portId) {\n+        this.thingHandler = thingHandler;\n+        this.portId = portId;\n+    }\n+\n+    /**\n+     * Initialize the communication with the device, i.e. open the serial port etc.\n+     *\n+     * @param mode the {@link WorkMode} if we want to use polling or reporting\n+     * @param interval the time between polling or reportings\n+     * @return {@code true} if we can communicate with the device\n+     * @throws PortInUseException\n+     * @throws TooManyListenersException\n+     * @throws IOException\n+     * @throws UnsupportedCommOperationException\n+     */\n+    public boolean initialize(WorkMode mode, Duration interval)\n+            throws PortInUseException, TooManyListenersException, IOException, UnsupportedCommOperationException {\n+        boolean initSuccessful = true;\n+\n+        SerialPort localSerialPort = portId.open(thingHandler.getThing().getUID().toString(), 2000);\n+        localSerialPort.setSerialPortParams(9600, 8, 1, 0);\n+\n+        outputStream = localSerialPort.getOutputStream();\n+        inputStream = localSerialPort.getInputStream();\n+\n+        if (inputStream == null || outputStream == null) {\n+            throw new IOException(\"Could not create input or outputstream for the port\");\n+        }\n+\n+        // wake up the device\n+        initSuccessful &= sendSleep(false);\n+        initSuccessful &= getFirmware();\n+\n+        if (mode == WorkMode.POLLING) {\n+            initSuccessful &= setMode(WorkMode.POLLING);\n+            initSuccessful &= setWorkingPeriod((byte) 0);\n+        } else {\n+            // reporting\n+            initSuccessful &= setWorkingPeriod((byte) interval.toMinutes());\n+            initSuccessful &= setMode(WorkMode.REPORTING);\n+        }\n+\n+        // enable listeners only after we have configured the sensor above because for configuring we send and read data\n+        // sequentially\n+        localSerialPort.notifyOnDataAvailable(true);\n+        localSerialPort.addEventListener(this);\n+        this.serialPort = localSerialPort;\n+\n+        return initSuccessful;\n+    }\n+\n+    private @Nullable SensorReply sendCommand(CommandMessage message) throws IOException {\n+        byte[] commandData = message.getBytes();\n+        if (logger.isDebugEnabled()) {\n+            logger.debug(\"Will send command: {} ({})\", HexUtils.bytesToHex(commandData), Arrays.toString(commandData));\n+        }\n+        outputStream.write(commandData, 0, commandData.length);\n+        outputStream.flush();\n+        try {\n+            // Give the sensor some time to handle the command\n+            Thread.sleep(500);\n+        } catch (InterruptedException e) {\n+            logger.warn(\"Problem while waiting for reading a reply to our command.\");\n+            Thread.currentThread().interrupt();\n+        }\n+        SensorReply reply = readReply();\n+        // in case there is still another reporting active, we want to discard the sensor data and read the reply to our\n+        // command again\n+        if (reply instanceof SensorMeasuredDataReply) {\n+            reply = readReply();\n+        }\n+        return reply;\n+    }\n+\n+    private boolean setWorkingPeriod(byte period) throws IOException {\n+        CommandMessage m = new CommandMessage(Command.WORKING_PERIOD, new byte[] { Constants.SET_ACTION, period });\n+        logger.debug(\"Sending work period: {}\", period);\n+        SensorReply reply = sendCommand(m);\n+        logger.debug(\"Got reply to setWorkingPeriod command: {}\", reply);\n+        if (reply instanceof WorkingPeriodReply) {\n+            WorkingPeriodReply wpReply = (WorkingPeriodReply) reply;\n+            if (wpReply.getPeriod() == period && wpReply.getActionType() == Constants.SET_ACTION) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    private boolean setMode(WorkMode workMode) throws IOException {\n+        byte haveToRequestData = 0;\n+        if (workMode == WorkMode.POLLING) {\n+            haveToRequestData = 1;\n+        }\n+\n+        CommandMessage m = new CommandMessage(Command.MODE, new byte[] { Constants.SET_ACTION, haveToRequestData });\n+        logger.debug(\"Sending mode: {}\", workMode);\n+        SensorReply reply = sendCommand(m);\n+        logger.debug(\"Got reply to setMode command: {}\", reply);\n+        if (reply instanceof ModeReply) {\n+            ModeReply mr = (ModeReply) reply;\n+            if (mr.getActionType() == Constants.SET_ACTION && mr.getMode() == workMode) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    private boolean sendSleep(boolean doSleep) throws IOException {\n+        byte payload = (byte) 1;\n+        if (doSleep) {\n+            payload = (byte) 0;\n+        }\n+\n+        CommandMessage m = new CommandMessage(Command.SLEEP, new byte[] { Constants.SET_ACTION, payload });\n+        logger.debug(\"Sending doSleep: {}\", doSleep);\n+        SensorReply reply = sendCommand(m);\n+        logger.debug(\"Got reply to sendSleep command: {}\", reply);\n+\n+        if (!doSleep) {\n+            // sometimes the sensor does not wakeup on the first attempt, thus we try again\n+            for (int i = 0; reply == null && i < 3; i++) {\n+                reply = sendCommand(m);\n+                logger.debug(\"Got reply to sendSleep command after retry#{}: {}\", i + 1, reply);\n+            }\n+        }\n+\n+        if (reply instanceof SleepReply) {\n+            SleepReply sr = (SleepReply) reply;\n+            if (sr.getActionType() == Constants.SET_ACTION && sr.getSleep() == payload) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    private boolean getFirmware() throws IOException {\n+        CommandMessage m = new CommandMessage(Command.FIRMWARE, new byte[] {});\n+        logger.debug(\"Sending get firmware request\");\n+        SensorReply reply = sendCommand(m);\n+        logger.debug(\"Got reply to getFirmware command: {}\", reply);\n+\n+        if (reply instanceof SensorFirmwareReply) {\n+            SensorFirmwareReply fwReply = (SensorFirmwareReply) reply;\n+            thingHandler.setFirmware(fwReply.getFirmware());\n+            return true;\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Request data from the device, they will be returned via the serialEvent callback\n+     *\n+     * @throws IOException\n+     */\n+    public void requestSensorData() throws IOException {\n+        CommandMessage m = new CommandMessage(Command.REQUEST_DATA, new byte[] {});\n+        byte[] data = m.getBytes();\n+        if (logger.isDebugEnabled()) {\n+            logger.debug(\"Requesting sensor data, will send: {}\", HexUtils.bytesToHex(data));\n+        }\n+        outputStream.write(data, 0, data.length);\n+    }\n+\n+    private @Nullable SensorReply readReply() throws IOException {\n+        byte[] readBuffer = new byte[Constants.REPLY_LENGTH];\n+\n+        int b = -1;\n+        if (inputStream.available() > 0) {\n+            while ((b = inputStream.read()) != Constants.MESSAGE_START_AS_INT) {\n+                logger.debug(\"Trying to find first reply byte now...\");\n+            }\n+            readBuffer[0] = (byte) b;\n+            int remainingBytesRead = inputStream.read(readBuffer, 1, Constants.REPLY_LENGTH - 1);\n+            if (logger.isDebugEnabled()) {\n+                logger.debug(\"Read remaining bytes: {}, full reply={}\", remainingBytesRead,\n+                        HexUtils.bytesToHex(readBuffer));\n+            }\n+            return ReplyFactory.create(readBuffer);\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * Data from the device is arriving and will be parsed accordingly\n+     */\n+    @Override\n+    public void serialEvent(SerialPortEvent event) {\n+        if (event.getEventType() == SerialPortEvent.DATA_AVAILABLE) {\n+            // we get here if data has been received\n+            SensorReply reply = null;\n+            try {\n+                reply = readReply();\n+                logger.debug(\"Got data from sensor: {}\", reply);\n+            } catch (IOException e) {\n+                logger.warn(\"Could not read available data from the serial port: {}\", e.getMessage());\n+            }\n+            if (reply instanceof SensorMeasuredDataReply) {\n+                SensorMeasuredDataReply sensorData = (SensorMeasuredDataReply) reply;\n+                if (sensorData.isValidData()) {\n+                    thingHandler.updateChannels(sensorData);\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Shutdown the communication, i.e. send the device to sleep and close the serial port\n+     */\n+    public void dispose() {\n+        if (serialPort != null) {\n+            try {\n+                // send the device to sleep to preserve power and extend the lifetime of the sensor\n+                sendSleep(true);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3b594394ec2080ca6bb8de2fd3710720612a5d20"}, "originalPosition": 274}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTI0Nzc4Ng==", "bodyText": "I tried this before, but somehow the underlieing library does something with the port if I de-register my listener and then my command doesn't go through.\nThis is just a guess from my observation. That is why I did not de-register the listener before that call here.\nAlso in the callback method for the listener I check for valid data, so it doesn't matter if the callback receives the reply to the sleep on shutdown.", "url": "https://github.com/openhab/openhab-addons/pull/7528#discussion_r431247786", "createdAt": "2020-05-27T15:48:56Z", "author": {"login": "t2000"}, "path": "bundles/org.openhab.binding.novafinedust/src/main/java/org/openhab/binding/novafinedust/internal/sds011protocol/SDS011Communicator.java", "diffHunk": "@@ -0,0 +1,297 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.novafinedust.internal.sds011protocol;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.time.Duration;\n+import java.util.Arrays;\n+import java.util.TooManyListenersException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.util.HexUtils;\n+import org.eclipse.smarthome.io.transport.serial.PortInUseException;\n+import org.eclipse.smarthome.io.transport.serial.SerialPort;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortEvent;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortEventListener;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortIdentifier;\n+import org.eclipse.smarthome.io.transport.serial.UnsupportedCommOperationException;\n+import org.openhab.binding.novafinedust.internal.SDS011Handler;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.CommandMessage;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.Constants;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.ModeReply;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.SensorFirmwareReply;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.SensorMeasuredDataReply;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.SensorReply;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.SleepReply;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.WorkingPeriodReply;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Central instance to communicate with the device, i.e. receive data from it and send commands to it\n+ *\n+ * @author Stefan Triller - Initial contribution\n+ *\n+ */\n+@NonNullByDefault\n+public class SDS011Communicator implements SerialPortEventListener {\n+\n+    private final Logger logger = LoggerFactory.getLogger(SDS011Communicator.class);\n+\n+    private SerialPortIdentifier portId;\n+    private SDS011Handler thingHandler;\n+    private @NonNullByDefault({}) SerialPort serialPort;\n+\n+    private @Nullable OutputStream outputStream;\n+    private @Nullable InputStream inputStream;\n+\n+    public SDS011Communicator(SDS011Handler thingHandler, SerialPortIdentifier portId) {\n+        this.thingHandler = thingHandler;\n+        this.portId = portId;\n+    }\n+\n+    /**\n+     * Initialize the communication with the device, i.e. open the serial port etc.\n+     *\n+     * @param mode the {@link WorkMode} if we want to use polling or reporting\n+     * @param interval the time between polling or reportings\n+     * @return {@code true} if we can communicate with the device\n+     * @throws PortInUseException\n+     * @throws TooManyListenersException\n+     * @throws IOException\n+     * @throws UnsupportedCommOperationException\n+     */\n+    public boolean initialize(WorkMode mode, Duration interval)\n+            throws PortInUseException, TooManyListenersException, IOException, UnsupportedCommOperationException {\n+        boolean initSuccessful = true;\n+\n+        SerialPort localSerialPort = portId.open(thingHandler.getThing().getUID().toString(), 2000);\n+        localSerialPort.setSerialPortParams(9600, 8, 1, 0);\n+\n+        outputStream = localSerialPort.getOutputStream();\n+        inputStream = localSerialPort.getInputStream();\n+\n+        if (inputStream == null || outputStream == null) {\n+            throw new IOException(\"Could not create input or outputstream for the port\");\n+        }\n+\n+        // wake up the device\n+        initSuccessful &= sendSleep(false);\n+        initSuccessful &= getFirmware();\n+\n+        if (mode == WorkMode.POLLING) {\n+            initSuccessful &= setMode(WorkMode.POLLING);\n+            initSuccessful &= setWorkingPeriod((byte) 0);\n+        } else {\n+            // reporting\n+            initSuccessful &= setWorkingPeriod((byte) interval.toMinutes());\n+            initSuccessful &= setMode(WorkMode.REPORTING);\n+        }\n+\n+        // enable listeners only after we have configured the sensor above because for configuring we send and read data\n+        // sequentially\n+        localSerialPort.notifyOnDataAvailable(true);\n+        localSerialPort.addEventListener(this);\n+        this.serialPort = localSerialPort;\n+\n+        return initSuccessful;\n+    }\n+\n+    private @Nullable SensorReply sendCommand(CommandMessage message) throws IOException {\n+        byte[] commandData = message.getBytes();\n+        if (logger.isDebugEnabled()) {\n+            logger.debug(\"Will send command: {} ({})\", HexUtils.bytesToHex(commandData), Arrays.toString(commandData));\n+        }\n+        outputStream.write(commandData, 0, commandData.length);\n+        outputStream.flush();\n+        try {\n+            // Give the sensor some time to handle the command\n+            Thread.sleep(500);\n+        } catch (InterruptedException e) {\n+            logger.warn(\"Problem while waiting for reading a reply to our command.\");\n+            Thread.currentThread().interrupt();\n+        }\n+        SensorReply reply = readReply();\n+        // in case there is still another reporting active, we want to discard the sensor data and read the reply to our\n+        // command again\n+        if (reply instanceof SensorMeasuredDataReply) {\n+            reply = readReply();\n+        }\n+        return reply;\n+    }\n+\n+    private boolean setWorkingPeriod(byte period) throws IOException {\n+        CommandMessage m = new CommandMessage(Command.WORKING_PERIOD, new byte[] { Constants.SET_ACTION, period });\n+        logger.debug(\"Sending work period: {}\", period);\n+        SensorReply reply = sendCommand(m);\n+        logger.debug(\"Got reply to setWorkingPeriod command: {}\", reply);\n+        if (reply instanceof WorkingPeriodReply) {\n+            WorkingPeriodReply wpReply = (WorkingPeriodReply) reply;\n+            if (wpReply.getPeriod() == period && wpReply.getActionType() == Constants.SET_ACTION) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    private boolean setMode(WorkMode workMode) throws IOException {\n+        byte haveToRequestData = 0;\n+        if (workMode == WorkMode.POLLING) {\n+            haveToRequestData = 1;\n+        }\n+\n+        CommandMessage m = new CommandMessage(Command.MODE, new byte[] { Constants.SET_ACTION, haveToRequestData });\n+        logger.debug(\"Sending mode: {}\", workMode);\n+        SensorReply reply = sendCommand(m);\n+        logger.debug(\"Got reply to setMode command: {}\", reply);\n+        if (reply instanceof ModeReply) {\n+            ModeReply mr = (ModeReply) reply;\n+            if (mr.getActionType() == Constants.SET_ACTION && mr.getMode() == workMode) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    private boolean sendSleep(boolean doSleep) throws IOException {\n+        byte payload = (byte) 1;\n+        if (doSleep) {\n+            payload = (byte) 0;\n+        }\n+\n+        CommandMessage m = new CommandMessage(Command.SLEEP, new byte[] { Constants.SET_ACTION, payload });\n+        logger.debug(\"Sending doSleep: {}\", doSleep);\n+        SensorReply reply = sendCommand(m);\n+        logger.debug(\"Got reply to sendSleep command: {}\", reply);\n+\n+        if (!doSleep) {\n+            // sometimes the sensor does not wakeup on the first attempt, thus we try again\n+            for (int i = 0; reply == null && i < 3; i++) {\n+                reply = sendCommand(m);\n+                logger.debug(\"Got reply to sendSleep command after retry#{}: {}\", i + 1, reply);\n+            }\n+        }\n+\n+        if (reply instanceof SleepReply) {\n+            SleepReply sr = (SleepReply) reply;\n+            if (sr.getActionType() == Constants.SET_ACTION && sr.getSleep() == payload) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    private boolean getFirmware() throws IOException {\n+        CommandMessage m = new CommandMessage(Command.FIRMWARE, new byte[] {});\n+        logger.debug(\"Sending get firmware request\");\n+        SensorReply reply = sendCommand(m);\n+        logger.debug(\"Got reply to getFirmware command: {}\", reply);\n+\n+        if (reply instanceof SensorFirmwareReply) {\n+            SensorFirmwareReply fwReply = (SensorFirmwareReply) reply;\n+            thingHandler.setFirmware(fwReply.getFirmware());\n+            return true;\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Request data from the device, they will be returned via the serialEvent callback\n+     *\n+     * @throws IOException\n+     */\n+    public void requestSensorData() throws IOException {\n+        CommandMessage m = new CommandMessage(Command.REQUEST_DATA, new byte[] {});\n+        byte[] data = m.getBytes();\n+        if (logger.isDebugEnabled()) {\n+            logger.debug(\"Requesting sensor data, will send: {}\", HexUtils.bytesToHex(data));\n+        }\n+        outputStream.write(data, 0, data.length);\n+    }\n+\n+    private @Nullable SensorReply readReply() throws IOException {\n+        byte[] readBuffer = new byte[Constants.REPLY_LENGTH];\n+\n+        int b = -1;\n+        if (inputStream.available() > 0) {\n+            while ((b = inputStream.read()) != Constants.MESSAGE_START_AS_INT) {\n+                logger.debug(\"Trying to find first reply byte now...\");\n+            }\n+            readBuffer[0] = (byte) b;\n+            int remainingBytesRead = inputStream.read(readBuffer, 1, Constants.REPLY_LENGTH - 1);\n+            if (logger.isDebugEnabled()) {\n+                logger.debug(\"Read remaining bytes: {}, full reply={}\", remainingBytesRead,\n+                        HexUtils.bytesToHex(readBuffer));\n+            }\n+            return ReplyFactory.create(readBuffer);\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * Data from the device is arriving and will be parsed accordingly\n+     */\n+    @Override\n+    public void serialEvent(SerialPortEvent event) {\n+        if (event.getEventType() == SerialPortEvent.DATA_AVAILABLE) {\n+            // we get here if data has been received\n+            SensorReply reply = null;\n+            try {\n+                reply = readReply();\n+                logger.debug(\"Got data from sensor: {}\", reply);\n+            } catch (IOException e) {\n+                logger.warn(\"Could not read available data from the serial port: {}\", e.getMessage());\n+            }\n+            if (reply instanceof SensorMeasuredDataReply) {\n+                SensorMeasuredDataReply sensorData = (SensorMeasuredDataReply) reply;\n+                if (sensorData.isValidData()) {\n+                    thingHandler.updateChannels(sensorData);\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Shutdown the communication, i.e. send the device to sleep and close the serial port\n+     */\n+    public void dispose() {\n+        if (serialPort != null) {\n+            try {\n+                // send the device to sleep to preserve power and extend the lifetime of the sensor\n+                sendSleep(true);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDc1ODcwNA=="}, "originalCommit": {"oid": "3b594394ec2080ca6bb8de2fd3710720612a5d20"}, "originalPosition": 274}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY4MzA3ODgyOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.novafinedust/src/main/java/org/openhab/binding/novafinedust/internal/sds011protocol/SDS011Communicator.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNlQyMzoyMjoxNVrOGazgNw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNlQyMzoyMjoxNVrOGazgNw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDc1OTk5MQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    outputStream.write(commandData, 0, commandData.length);\n          \n          \n            \n                    outputStream.write(commandData);", "url": "https://github.com/openhab/openhab-addons/pull/7528#discussion_r430759991", "createdAt": "2020-05-26T23:22:15Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.novafinedust/src/main/java/org/openhab/binding/novafinedust/internal/sds011protocol/SDS011Communicator.java", "diffHunk": "@@ -0,0 +1,297 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.novafinedust.internal.sds011protocol;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.time.Duration;\n+import java.util.Arrays;\n+import java.util.TooManyListenersException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.util.HexUtils;\n+import org.eclipse.smarthome.io.transport.serial.PortInUseException;\n+import org.eclipse.smarthome.io.transport.serial.SerialPort;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortEvent;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortEventListener;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortIdentifier;\n+import org.eclipse.smarthome.io.transport.serial.UnsupportedCommOperationException;\n+import org.openhab.binding.novafinedust.internal.SDS011Handler;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.CommandMessage;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.Constants;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.ModeReply;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.SensorFirmwareReply;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.SensorMeasuredDataReply;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.SensorReply;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.SleepReply;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.WorkingPeriodReply;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Central instance to communicate with the device, i.e. receive data from it and send commands to it\n+ *\n+ * @author Stefan Triller - Initial contribution\n+ *\n+ */\n+@NonNullByDefault\n+public class SDS011Communicator implements SerialPortEventListener {\n+\n+    private final Logger logger = LoggerFactory.getLogger(SDS011Communicator.class);\n+\n+    private SerialPortIdentifier portId;\n+    private SDS011Handler thingHandler;\n+    private @NonNullByDefault({}) SerialPort serialPort;\n+\n+    private @Nullable OutputStream outputStream;\n+    private @Nullable InputStream inputStream;\n+\n+    public SDS011Communicator(SDS011Handler thingHandler, SerialPortIdentifier portId) {\n+        this.thingHandler = thingHandler;\n+        this.portId = portId;\n+    }\n+\n+    /**\n+     * Initialize the communication with the device, i.e. open the serial port etc.\n+     *\n+     * @param mode the {@link WorkMode} if we want to use polling or reporting\n+     * @param interval the time between polling or reportings\n+     * @return {@code true} if we can communicate with the device\n+     * @throws PortInUseException\n+     * @throws TooManyListenersException\n+     * @throws IOException\n+     * @throws UnsupportedCommOperationException\n+     */\n+    public boolean initialize(WorkMode mode, Duration interval)\n+            throws PortInUseException, TooManyListenersException, IOException, UnsupportedCommOperationException {\n+        boolean initSuccessful = true;\n+\n+        SerialPort localSerialPort = portId.open(thingHandler.getThing().getUID().toString(), 2000);\n+        localSerialPort.setSerialPortParams(9600, 8, 1, 0);\n+\n+        outputStream = localSerialPort.getOutputStream();\n+        inputStream = localSerialPort.getInputStream();\n+\n+        if (inputStream == null || outputStream == null) {\n+            throw new IOException(\"Could not create input or outputstream for the port\");\n+        }\n+\n+        // wake up the device\n+        initSuccessful &= sendSleep(false);\n+        initSuccessful &= getFirmware();\n+\n+        if (mode == WorkMode.POLLING) {\n+            initSuccessful &= setMode(WorkMode.POLLING);\n+            initSuccessful &= setWorkingPeriod((byte) 0);\n+        } else {\n+            // reporting\n+            initSuccessful &= setWorkingPeriod((byte) interval.toMinutes());\n+            initSuccessful &= setMode(WorkMode.REPORTING);\n+        }\n+\n+        // enable listeners only after we have configured the sensor above because for configuring we send and read data\n+        // sequentially\n+        localSerialPort.notifyOnDataAvailable(true);\n+        localSerialPort.addEventListener(this);\n+        this.serialPort = localSerialPort;\n+\n+        return initSuccessful;\n+    }\n+\n+    private @Nullable SensorReply sendCommand(CommandMessage message) throws IOException {\n+        byte[] commandData = message.getBytes();\n+        if (logger.isDebugEnabled()) {\n+            logger.debug(\"Will send command: {} ({})\", HexUtils.bytesToHex(commandData), Arrays.toString(commandData));\n+        }\n+        outputStream.write(commandData, 0, commandData.length);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3b594394ec2080ca6bb8de2fd3710720612a5d20"}, "originalPosition": 118}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY4MzA3OTUwOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.novafinedust/src/main/java/org/openhab/binding/novafinedust/internal/sds011protocol/SDS011Communicator.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNlQyMzoyMjozM1rOGazgog==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNlQyMzoyMjozM1rOGazgog==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDc2MDA5OA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    outputStream.write(data, 0, data.length);\n          \n          \n            \n                    outputStream.write(data);\n          \n          \n            \n                    outputStream.flush();", "url": "https://github.com/openhab/openhab-addons/pull/7528#discussion_r430760098", "createdAt": "2020-05-26T23:22:33Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.novafinedust/src/main/java/org/openhab/binding/novafinedust/internal/sds011protocol/SDS011Communicator.java", "diffHunk": "@@ -0,0 +1,297 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.novafinedust.internal.sds011protocol;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.time.Duration;\n+import java.util.Arrays;\n+import java.util.TooManyListenersException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.util.HexUtils;\n+import org.eclipse.smarthome.io.transport.serial.PortInUseException;\n+import org.eclipse.smarthome.io.transport.serial.SerialPort;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortEvent;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortEventListener;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortIdentifier;\n+import org.eclipse.smarthome.io.transport.serial.UnsupportedCommOperationException;\n+import org.openhab.binding.novafinedust.internal.SDS011Handler;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.CommandMessage;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.Constants;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.ModeReply;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.SensorFirmwareReply;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.SensorMeasuredDataReply;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.SensorReply;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.SleepReply;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.WorkingPeriodReply;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Central instance to communicate with the device, i.e. receive data from it and send commands to it\n+ *\n+ * @author Stefan Triller - Initial contribution\n+ *\n+ */\n+@NonNullByDefault\n+public class SDS011Communicator implements SerialPortEventListener {\n+\n+    private final Logger logger = LoggerFactory.getLogger(SDS011Communicator.class);\n+\n+    private SerialPortIdentifier portId;\n+    private SDS011Handler thingHandler;\n+    private @NonNullByDefault({}) SerialPort serialPort;\n+\n+    private @Nullable OutputStream outputStream;\n+    private @Nullable InputStream inputStream;\n+\n+    public SDS011Communicator(SDS011Handler thingHandler, SerialPortIdentifier portId) {\n+        this.thingHandler = thingHandler;\n+        this.portId = portId;\n+    }\n+\n+    /**\n+     * Initialize the communication with the device, i.e. open the serial port etc.\n+     *\n+     * @param mode the {@link WorkMode} if we want to use polling or reporting\n+     * @param interval the time between polling or reportings\n+     * @return {@code true} if we can communicate with the device\n+     * @throws PortInUseException\n+     * @throws TooManyListenersException\n+     * @throws IOException\n+     * @throws UnsupportedCommOperationException\n+     */\n+    public boolean initialize(WorkMode mode, Duration interval)\n+            throws PortInUseException, TooManyListenersException, IOException, UnsupportedCommOperationException {\n+        boolean initSuccessful = true;\n+\n+        SerialPort localSerialPort = portId.open(thingHandler.getThing().getUID().toString(), 2000);\n+        localSerialPort.setSerialPortParams(9600, 8, 1, 0);\n+\n+        outputStream = localSerialPort.getOutputStream();\n+        inputStream = localSerialPort.getInputStream();\n+\n+        if (inputStream == null || outputStream == null) {\n+            throw new IOException(\"Could not create input or outputstream for the port\");\n+        }\n+\n+        // wake up the device\n+        initSuccessful &= sendSleep(false);\n+        initSuccessful &= getFirmware();\n+\n+        if (mode == WorkMode.POLLING) {\n+            initSuccessful &= setMode(WorkMode.POLLING);\n+            initSuccessful &= setWorkingPeriod((byte) 0);\n+        } else {\n+            // reporting\n+            initSuccessful &= setWorkingPeriod((byte) interval.toMinutes());\n+            initSuccessful &= setMode(WorkMode.REPORTING);\n+        }\n+\n+        // enable listeners only after we have configured the sensor above because for configuring we send and read data\n+        // sequentially\n+        localSerialPort.notifyOnDataAvailable(true);\n+        localSerialPort.addEventListener(this);\n+        this.serialPort = localSerialPort;\n+\n+        return initSuccessful;\n+    }\n+\n+    private @Nullable SensorReply sendCommand(CommandMessage message) throws IOException {\n+        byte[] commandData = message.getBytes();\n+        if (logger.isDebugEnabled()) {\n+            logger.debug(\"Will send command: {} ({})\", HexUtils.bytesToHex(commandData), Arrays.toString(commandData));\n+        }\n+        outputStream.write(commandData, 0, commandData.length);\n+        outputStream.flush();\n+        try {\n+            // Give the sensor some time to handle the command\n+            Thread.sleep(500);\n+        } catch (InterruptedException e) {\n+            logger.warn(\"Problem while waiting for reading a reply to our command.\");\n+            Thread.currentThread().interrupt();\n+        }\n+        SensorReply reply = readReply();\n+        // in case there is still another reporting active, we want to discard the sensor data and read the reply to our\n+        // command again\n+        if (reply instanceof SensorMeasuredDataReply) {\n+            reply = readReply();\n+        }\n+        return reply;\n+    }\n+\n+    private boolean setWorkingPeriod(byte period) throws IOException {\n+        CommandMessage m = new CommandMessage(Command.WORKING_PERIOD, new byte[] { Constants.SET_ACTION, period });\n+        logger.debug(\"Sending work period: {}\", period);\n+        SensorReply reply = sendCommand(m);\n+        logger.debug(\"Got reply to setWorkingPeriod command: {}\", reply);\n+        if (reply instanceof WorkingPeriodReply) {\n+            WorkingPeriodReply wpReply = (WorkingPeriodReply) reply;\n+            if (wpReply.getPeriod() == period && wpReply.getActionType() == Constants.SET_ACTION) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    private boolean setMode(WorkMode workMode) throws IOException {\n+        byte haveToRequestData = 0;\n+        if (workMode == WorkMode.POLLING) {\n+            haveToRequestData = 1;\n+        }\n+\n+        CommandMessage m = new CommandMessage(Command.MODE, new byte[] { Constants.SET_ACTION, haveToRequestData });\n+        logger.debug(\"Sending mode: {}\", workMode);\n+        SensorReply reply = sendCommand(m);\n+        logger.debug(\"Got reply to setMode command: {}\", reply);\n+        if (reply instanceof ModeReply) {\n+            ModeReply mr = (ModeReply) reply;\n+            if (mr.getActionType() == Constants.SET_ACTION && mr.getMode() == workMode) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    private boolean sendSleep(boolean doSleep) throws IOException {\n+        byte payload = (byte) 1;\n+        if (doSleep) {\n+            payload = (byte) 0;\n+        }\n+\n+        CommandMessage m = new CommandMessage(Command.SLEEP, new byte[] { Constants.SET_ACTION, payload });\n+        logger.debug(\"Sending doSleep: {}\", doSleep);\n+        SensorReply reply = sendCommand(m);\n+        logger.debug(\"Got reply to sendSleep command: {}\", reply);\n+\n+        if (!doSleep) {\n+            // sometimes the sensor does not wakeup on the first attempt, thus we try again\n+            for (int i = 0; reply == null && i < 3; i++) {\n+                reply = sendCommand(m);\n+                logger.debug(\"Got reply to sendSleep command after retry#{}: {}\", i + 1, reply);\n+            }\n+        }\n+\n+        if (reply instanceof SleepReply) {\n+            SleepReply sr = (SleepReply) reply;\n+            if (sr.getActionType() == Constants.SET_ACTION && sr.getSleep() == payload) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    private boolean getFirmware() throws IOException {\n+        CommandMessage m = new CommandMessage(Command.FIRMWARE, new byte[] {});\n+        logger.debug(\"Sending get firmware request\");\n+        SensorReply reply = sendCommand(m);\n+        logger.debug(\"Got reply to getFirmware command: {}\", reply);\n+\n+        if (reply instanceof SensorFirmwareReply) {\n+            SensorFirmwareReply fwReply = (SensorFirmwareReply) reply;\n+            thingHandler.setFirmware(fwReply.getFirmware());\n+            return true;\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Request data from the device, they will be returned via the serialEvent callback\n+     *\n+     * @throws IOException\n+     */\n+    public void requestSensorData() throws IOException {\n+        CommandMessage m = new CommandMessage(Command.REQUEST_DATA, new byte[] {});\n+        byte[] data = m.getBytes();\n+        if (logger.isDebugEnabled()) {\n+            logger.debug(\"Requesting sensor data, will send: {}\", HexUtils.bytesToHex(data));\n+        }\n+        outputStream.write(data, 0, data.length);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3b594394ec2080ca6bb8de2fd3710720612a5d20"}, "originalPosition": 222}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY4NjYyNTEyOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.novafinedust/src/main/java/org/openhab/binding/novafinedust/internal/sds011protocol/messages/ModeReply.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yN1QxODowNDo0MVrOGbXBxw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yN1QxODowNDo0MVrOGbXBxw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTM0MjAyMw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private byte actionType;\n          \n          \n            \n                private WorkMode mode;\n          \n          \n            \n                private final byte actionType;\n          \n          \n            \n                private final WorkMode mode;", "url": "https://github.com/openhab/openhab-addons/pull/7528#discussion_r431342023", "createdAt": "2020-05-27T18:04:41Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.novafinedust/src/main/java/org/openhab/binding/novafinedust/internal/sds011protocol/messages/ModeReply.java", "diffHunk": "@@ -0,0 +1,63 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.novafinedust.internal.sds011protocol.messages;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.WorkMode;\n+\n+/**\n+ * Reply from sensor to a set mode command\n+ *\n+ * @author Stefan Triller - Initial contribution\n+ *\n+ */\n+@NonNullByDefault\n+public class ModeReply extends SensorReply {\n+\n+    private byte actionType;\n+    private WorkMode mode;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9ffd0c160059738fff9299756eeb48e25f349c93"}, "originalPosition": 28}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY4NjYyNjk0OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.novafinedust/src/main/java/org/openhab/binding/novafinedust/internal/sds011protocol/messages/SleepReply.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yN1QxODowNToxMFrOGbXC5Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yN1QxODowNToxMFrOGbXC5Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTM0MjMwOQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private byte actionType;\n          \n          \n            \n                private byte sleep;\n          \n          \n            \n                private final byte actionType;\n          \n          \n            \n                private final byte sleep;", "url": "https://github.com/openhab/openhab-addons/pull/7528#discussion_r431342309", "createdAt": "2020-05-27T18:05:10Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.novafinedust/src/main/java/org/openhab/binding/novafinedust/internal/sds011protocol/messages/SleepReply.java", "diffHunk": "@@ -0,0 +1,58 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.novafinedust.internal.sds011protocol.messages;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+\n+/**\n+ * Reply from sensor to a set sleep command\n+ *\n+ * @author Stefan Triller - Initial contribution\n+ *\n+ */\n+@NonNullByDefault\n+public class SleepReply extends SensorReply {\n+\n+    private byte actionType;\n+    private byte sleep;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9ffd0c160059738fff9299756eeb48e25f349c93"}, "originalPosition": 27}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY4NjYyODE3OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.novafinedust/src/main/java/org/openhab/binding/novafinedust/internal/sds011protocol/messages/SensorFirmwareReply.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yN1QxODowNTozNFrOGbXDww==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yN1QxODowNTozNFrOGbXDww==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTM0MjUzMQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private byte year;\n          \n          \n            \n                private byte month;\n          \n          \n            \n                private byte day;\n          \n          \n            \n                private final byte year;\n          \n          \n            \n                private final byte month;\n          \n          \n            \n                private final byte day;", "url": "https://github.com/openhab/openhab-addons/pull/7528#discussion_r431342531", "createdAt": "2020-05-27T18:05:34Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.novafinedust/src/main/java/org/openhab/binding/novafinedust/internal/sds011protocol/messages/SensorFirmwareReply.java", "diffHunk": "@@ -0,0 +1,51 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.novafinedust.internal.sds011protocol.messages;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+\n+/**\n+ * Data from the sensor containing information about the installed firmware\n+ *\n+ * @author Stefan Triller - Initial contribution\n+ *\n+ */\n+@NonNullByDefault\n+public class SensorFirmwareReply extends SensorReply {\n+\n+    private byte year;\n+    private byte month;\n+    private byte day;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9ffd0c160059738fff9299756eeb48e25f349c93"}, "originalPosition": 28}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY4NjYyOTc0OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.novafinedust/src/main/java/org/openhab/binding/novafinedust/internal/sds011protocol/messages/WorkingPeriodReply.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yN1QxODowNjowMVrOGbXEww==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yN1QxODowNjowMVrOGbXEww==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTM0Mjc4Nw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private byte actionType;\n          \n          \n            \n                private byte period;\n          \n          \n            \n                private final byte actionType;\n          \n          \n            \n                private final byte period;", "url": "https://github.com/openhab/openhab-addons/pull/7528#discussion_r431342787", "createdAt": "2020-05-27T18:06:01Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.novafinedust/src/main/java/org/openhab/binding/novafinedust/internal/sds011protocol/messages/WorkingPeriodReply.java", "diffHunk": "@@ -0,0 +1,58 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.novafinedust.internal.sds011protocol.messages;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+\n+/**\n+ * Reply from sensor to a set working period command\n+ *\n+ * @author Stefan Triller - Initial contribution\n+ *\n+ */\n+@NonNullByDefault\n+public class WorkingPeriodReply extends SensorReply {\n+\n+    private byte actionType;\n+    private byte period;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9ffd0c160059738fff9299756eeb48e25f349c93"}, "originalPosition": 27}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY5MTY1OTgzOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.novafinedust/src/main/java/org/openhab/binding/novafinedust/internal/SDS011Handler.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOFQyMjoyODoyMFrOGcI5EQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOFQyMjoyODoyMFrOGcI5EQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjE1ODk5Mw==", "bodyText": "Either make this nullable or initialize it to some default configuration.", "url": "https://github.com/openhab/openhab-addons/pull/7528#discussion_r432158993", "createdAt": "2020-05-28T22:28:20Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.novafinedust/src/main/java/org/openhab/binding/novafinedust/internal/SDS011Handler.java", "diffHunk": "@@ -0,0 +1,258 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.novafinedust.internal;\n+\n+import java.io.IOException;\n+import java.time.Duration;\n+import java.time.ZonedDateTime;\n+import java.util.TooManyListenersException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.dimension.Density;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.unit.SmartHomeUnits;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.eclipse.smarthome.io.transport.serial.PortInUseException;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortIdentifier;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.eclipse.smarthome.io.transport.serial.UnsupportedCommOperationException;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.SDS011Communicator;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.WorkMode;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.SensorMeasuredDataReply;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link SDS011Handler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Stefan Triller - Initial contribution\n+ */\n+@NonNullByDefault\n+public class SDS011Handler extends BaseThingHandler {\n+    private static final Duration CONNECTION_MONITOR_START_DELAY_OFFSET = Duration.ofSeconds(10);\n+\n+    private final Logger logger = LoggerFactory.getLogger(SDS011Handler.class);\n+    private final SerialPortManager serialPortManager;\n+\n+    private @NonNullByDefault({}) NovaFineDustConfiguration config;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "57ed8c622051f16ef63902c4af6a810b1908ee83"}, "originalPosition": 59}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY5MTY2MjEyOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.novafinedust/src/main/java/org/openhab/binding/novafinedust/internal/SDS011Handler.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOFQyMjoyOToxM1rOGcI6YA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOFQyMjoyOToxM1rOGcI6YA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjE1OTMyOA==", "bodyText": "Please make this nullable. I've had times in my own bindings that this ended up null unexpectedly.", "url": "https://github.com/openhab/openhab-addons/pull/7528#discussion_r432159328", "createdAt": "2020-05-28T22:29:13Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.novafinedust/src/main/java/org/openhab/binding/novafinedust/internal/SDS011Handler.java", "diffHunk": "@@ -0,0 +1,258 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.novafinedust.internal;\n+\n+import java.io.IOException;\n+import java.time.Duration;\n+import java.time.ZonedDateTime;\n+import java.util.TooManyListenersException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.dimension.Density;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.unit.SmartHomeUnits;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.eclipse.smarthome.io.transport.serial.PortInUseException;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortIdentifier;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.eclipse.smarthome.io.transport.serial.UnsupportedCommOperationException;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.SDS011Communicator;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.WorkMode;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.SensorMeasuredDataReply;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link SDS011Handler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Stefan Triller - Initial contribution\n+ */\n+@NonNullByDefault\n+public class SDS011Handler extends BaseThingHandler {\n+    private static final Duration CONNECTION_MONITOR_START_DELAY_OFFSET = Duration.ofSeconds(10);\n+\n+    private final Logger logger = LoggerFactory.getLogger(SDS011Handler.class);\n+    private final SerialPortManager serialPortManager;\n+\n+    private @NonNullByDefault({}) NovaFineDustConfiguration config;\n+    private @NonNullByDefault({}) SDS011Communicator communicator;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "57ed8c622051f16ef63902c4af6a810b1908ee83"}, "originalPosition": 60}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY5NjI1NTAyOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.novafinedust/src/main/java/org/openhab/binding/novafinedust/internal/SDS011Handler.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0zMFQyMDowMzoxM1rOGc1EmQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0zMFQyMDowMzoxM1rOGc1EmQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg4Mjg0MQ==", "bodyText": "To avoid null issues with the configs, you can change your config to be non-null and just populate the config with an instance that contains default values:\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private @Nullable NovaFineDustConfiguration config;\n          \n          \n            \n                private NovaFineDustConfiguration config = new NovaFineDustConfiguration();", "url": "https://github.com/openhab/openhab-addons/pull/7528#discussion_r432882841", "createdAt": "2020-05-30T20:03:13Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.novafinedust/src/main/java/org/openhab/binding/novafinedust/internal/SDS011Handler.java", "diffHunk": "@@ -0,0 +1,266 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.novafinedust.internal;\n+\n+import java.io.IOException;\n+import java.time.Duration;\n+import java.time.ZonedDateTime;\n+import java.util.TooManyListenersException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.dimension.Density;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.unit.SmartHomeUnits;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.eclipse.smarthome.io.transport.serial.PortInUseException;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortIdentifier;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.eclipse.smarthome.io.transport.serial.UnsupportedCommOperationException;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.SDS011Communicator;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.WorkMode;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.SensorMeasuredDataReply;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link SDS011Handler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Stefan Triller - Initial contribution\n+ */\n+@NonNullByDefault\n+public class SDS011Handler extends BaseThingHandler {\n+    private static final Duration CONNECTION_MONITOR_START_DELAY_OFFSET = Duration.ofSeconds(10);\n+\n+    private final Logger logger = LoggerFactory.getLogger(SDS011Handler.class);\n+    private final SerialPortManager serialPortManager;\n+\n+    private @Nullable NovaFineDustConfiguration config;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "36cfe9f558a43f29e09c5da567dc9c0f3479d728"}, "originalPosition": 59}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY5NjI1Njk1OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.novafinedust/src/main/java/org/openhab/binding/novafinedust/internal/sds011protocol/SDS011Communicator.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0zMFQyMDowNjozN1rOGc1Fhw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0zMFQyMDowNjozN1rOGc1Fhw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg4MzA3OQ==", "bodyText": "Please don't use @NonNullByDefault({}) if possible.", "url": "https://github.com/openhab/openhab-addons/pull/7528#discussion_r432883079", "createdAt": "2020-05-30T20:06:37Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.novafinedust/src/main/java/org/openhab/binding/novafinedust/internal/sds011protocol/SDS011Communicator.java", "diffHunk": "@@ -0,0 +1,298 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.novafinedust.internal.sds011protocol;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.time.Duration;\n+import java.util.Arrays;\n+import java.util.TooManyListenersException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.util.HexUtils;\n+import org.eclipse.smarthome.io.transport.serial.PortInUseException;\n+import org.eclipse.smarthome.io.transport.serial.SerialPort;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortEvent;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortEventListener;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortIdentifier;\n+import org.eclipse.smarthome.io.transport.serial.UnsupportedCommOperationException;\n+import org.openhab.binding.novafinedust.internal.SDS011Handler;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.CommandMessage;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.Constants;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.ModeReply;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.SensorFirmwareReply;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.SensorMeasuredDataReply;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.SensorReply;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.SleepReply;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.WorkingPeriodReply;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Central instance to communicate with the device, i.e. receive data from it and send commands to it\n+ *\n+ * @author Stefan Triller - Initial contribution\n+ *\n+ */\n+@NonNullByDefault\n+public class SDS011Communicator implements SerialPortEventListener {\n+\n+    private final Logger logger = LoggerFactory.getLogger(SDS011Communicator.class);\n+\n+    private SerialPortIdentifier portId;\n+    private SDS011Handler thingHandler;\n+    private @NonNullByDefault({}) SerialPort serialPort;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "36cfe9f558a43f29e09c5da567dc9c0f3479d728"}, "originalPosition": 56}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY5NjI1ODQ2OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.novafinedust/src/main/java/org/openhab/binding/novafinedust/internal/sds011protocol/SDS011Communicator.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0zMFQyMDowOTozMFrOGc1GUA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0zMVQxMDozNzo1OFrOGc4IXg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg4MzI4MA==", "bodyText": "If you want another way to get around the null checks. You could make these fields get populated from the constructor so you could make them non-null and final.\nYou would then turn your initialize method into a static factory method for SDS011Communicator instances.", "url": "https://github.com/openhab/openhab-addons/pull/7528#discussion_r432883280", "createdAt": "2020-05-30T20:09:30Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.novafinedust/src/main/java/org/openhab/binding/novafinedust/internal/sds011protocol/SDS011Communicator.java", "diffHunk": "@@ -0,0 +1,298 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.novafinedust.internal.sds011protocol;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.time.Duration;\n+import java.util.Arrays;\n+import java.util.TooManyListenersException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.util.HexUtils;\n+import org.eclipse.smarthome.io.transport.serial.PortInUseException;\n+import org.eclipse.smarthome.io.transport.serial.SerialPort;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortEvent;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortEventListener;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortIdentifier;\n+import org.eclipse.smarthome.io.transport.serial.UnsupportedCommOperationException;\n+import org.openhab.binding.novafinedust.internal.SDS011Handler;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.CommandMessage;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.Constants;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.ModeReply;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.SensorFirmwareReply;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.SensorMeasuredDataReply;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.SensorReply;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.SleepReply;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.WorkingPeriodReply;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Central instance to communicate with the device, i.e. receive data from it and send commands to it\n+ *\n+ * @author Stefan Triller - Initial contribution\n+ *\n+ */\n+@NonNullByDefault\n+public class SDS011Communicator implements SerialPortEventListener {\n+\n+    private final Logger logger = LoggerFactory.getLogger(SDS011Communicator.class);\n+\n+    private SerialPortIdentifier portId;\n+    private SDS011Handler thingHandler;\n+    private @NonNullByDefault({}) SerialPort serialPort;\n+\n+    private @Nullable OutputStream outputStream;\n+    private @Nullable InputStream inputStream;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "36cfe9f558a43f29e09c5da567dc9c0f3479d728"}, "originalPosition": 59}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjkzMjk1OA==", "bodyText": "I'd rather structure my code in a way that makes it look clean, i.e. in this case having the serial port and the streams within one object, rather than splitting this throughout the code just to make an analysis tool happy.\nI have made the null checks now...", "url": "https://github.com/openhab/openhab-addons/pull/7528#discussion_r432932958", "createdAt": "2020-05-31T10:37:58Z", "author": {"login": "t2000"}, "path": "bundles/org.openhab.binding.novafinedust/src/main/java/org/openhab/binding/novafinedust/internal/sds011protocol/SDS011Communicator.java", "diffHunk": "@@ -0,0 +1,298 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.novafinedust.internal.sds011protocol;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.time.Duration;\n+import java.util.Arrays;\n+import java.util.TooManyListenersException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.util.HexUtils;\n+import org.eclipse.smarthome.io.transport.serial.PortInUseException;\n+import org.eclipse.smarthome.io.transport.serial.SerialPort;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortEvent;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortEventListener;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortIdentifier;\n+import org.eclipse.smarthome.io.transport.serial.UnsupportedCommOperationException;\n+import org.openhab.binding.novafinedust.internal.SDS011Handler;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.CommandMessage;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.Constants;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.ModeReply;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.SensorFirmwareReply;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.SensorMeasuredDataReply;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.SensorReply;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.SleepReply;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.WorkingPeriodReply;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Central instance to communicate with the device, i.e. receive data from it and send commands to it\n+ *\n+ * @author Stefan Triller - Initial contribution\n+ *\n+ */\n+@NonNullByDefault\n+public class SDS011Communicator implements SerialPortEventListener {\n+\n+    private final Logger logger = LoggerFactory.getLogger(SDS011Communicator.class);\n+\n+    private SerialPortIdentifier portId;\n+    private SDS011Handler thingHandler;\n+    private @NonNullByDefault({}) SerialPort serialPort;\n+\n+    private @Nullable OutputStream outputStream;\n+    private @Nullable InputStream inputStream;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg4MzI4MA=="}, "originalCommit": {"oid": "36cfe9f558a43f29e09c5da567dc9c0f3479d728"}, "originalPosition": 59}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY5NjI3MjQyOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.novafinedust/src/main/java/org/openhab/binding/novafinedust/internal/SDS011Handler.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0zMFQyMDoyODozMFrOGc1M9w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0zMVQxMDozODowM1rOGc4IYg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg4NDk4Mw==", "bodyText": "Another example here of how to easily deal with the null warnings.\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    if (pollingJob != null) {\n          \n          \n            \n                        pollingJob.cancel(true);\n          \n          \n            \n                        pollingJob = null;\n          \n          \n            \n                    }\n          \n          \n            \n                    Future<?> pollingJob = this.pollingJob;\n          \n          \n            \n                    if (pollingJob != null) {\n          \n          \n            \n                        pollingJob.cancel(true);\n          \n          \n            \n                        this.pollingJob = null;\n          \n          \n            \n                    }", "url": "https://github.com/openhab/openhab-addons/pull/7528#discussion_r432884983", "createdAt": "2020-05-30T20:28:30Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.novafinedust/src/main/java/org/openhab/binding/novafinedust/internal/SDS011Handler.java", "diffHunk": "@@ -0,0 +1,266 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.novafinedust.internal;\n+\n+import java.io.IOException;\n+import java.time.Duration;\n+import java.time.ZonedDateTime;\n+import java.util.TooManyListenersException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.dimension.Density;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.unit.SmartHomeUnits;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.eclipse.smarthome.io.transport.serial.PortInUseException;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortIdentifier;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.eclipse.smarthome.io.transport.serial.UnsupportedCommOperationException;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.SDS011Communicator;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.WorkMode;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.SensorMeasuredDataReply;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link SDS011Handler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Stefan Triller - Initial contribution\n+ */\n+@NonNullByDefault\n+public class SDS011Handler extends BaseThingHandler {\n+    private static final Duration CONNECTION_MONITOR_START_DELAY_OFFSET = Duration.ofSeconds(10);\n+\n+    private final Logger logger = LoggerFactory.getLogger(SDS011Handler.class);\n+    private final SerialPortManager serialPortManager;\n+\n+    private @Nullable NovaFineDustConfiguration config;\n+    private @Nullable SDS011Communicator communicator;\n+\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+    private @Nullable ScheduledFuture<?> connectionMonitor;\n+\n+    private ZonedDateTime lastCommunication = ZonedDateTime.now();\n+\n+    // initialize timeBetweenDataShouldArrive with a large number\n+    private Duration timeBetweenDataShouldArrive = Duration.ofDays(1);\n+    private final Duration dataCanBeLateTolerance = Duration.ofSeconds(5);\n+\n+    // cached values fro refresh command\n+    private State statePM10 = UnDefType.UNDEF;\n+    private State statePM25 = UnDefType.UNDEF;\n+\n+    public SDS011Handler(Thing thing, SerialPortManager serialPortManager) {\n+        super(thing);\n+        this.serialPortManager = serialPortManager;\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        // refresh channels with last received values from cache\n+        if (RefreshType.REFRESH.equals(command)) {\n+            if (NovaFineDustBindingConstants.CHANNEL_PM25.equals(channelUID.getId()) && statePM25 != UnDefType.UNDEF) {\n+                updateState(NovaFineDustBindingConstants.CHANNEL_PM25, statePM25);\n+            }\n+            if (NovaFineDustBindingConstants.CHANNEL_PM10.equals(channelUID.getId()) && statePM10 != UnDefType.UNDEF) {\n+                updateState(NovaFineDustBindingConstants.CHANNEL_PM10, statePM10);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        config = getConfigAs(NovaFineDustConfiguration.class);\n+\n+        if (!validateConfiguration()) {\n+            return;\n+        }\n+\n+        // parse ports and if the port is found, initialize the reader\n+        SerialPortIdentifier portId = serialPortManager.getIdentifier(config.port);\n+        if (portId == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR, \"Port is not known!\");\n+            return;\n+        }\n+\n+        this.communicator = new SDS011Communicator(this, portId);\n+\n+        if (config.reporting) {\n+            timeBetweenDataShouldArrive = Duration.ofMinutes(config.reportingInterval);\n+            scheduler.schedule(() -> initializeCommunicator(WorkMode.REPORTING, timeBetweenDataShouldArrive), 0,\n+                    TimeUnit.SECONDS);\n+        } else {\n+            timeBetweenDataShouldArrive = Duration.ofSeconds(config.pollingInterval);\n+            scheduler.schedule(() -> initializeCommunicator(WorkMode.POLLING, timeBetweenDataShouldArrive), 0,\n+                    TimeUnit.SECONDS);\n+        }\n+\n+        Duration connectionMonitorStartDelay = timeBetweenDataShouldArrive.plus(CONNECTION_MONITOR_START_DELAY_OFFSET);\n+        connectionMonitor = scheduler.scheduleWithFixedDelay(this::verifyIfStillConnected,\n+                connectionMonitorStartDelay.getSeconds(), timeBetweenDataShouldArrive.getSeconds(), TimeUnit.SECONDS);\n+    }\n+\n+    private void initializeCommunicator(WorkMode mode, Duration interval) {\n+        boolean initSuccessful = false;\n+        try {\n+            initSuccessful = communicator.initialize(mode, interval);\n+        } catch (final IOException ex) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR, \"I/O error!\");\n+            return;\n+        } catch (PortInUseException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR, \"Port is in use!\");\n+            return;\n+        } catch (TooManyListenersException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                    \"Cannot attach listener to port!\");\n+            return;\n+        } catch (UnsupportedCommOperationException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                    \"Cannot set serial port parameters\");\n+            return;\n+        }\n+\n+        if (initSuccessful) {\n+            lastCommunication = ZonedDateTime.now();\n+            updateStatus(ThingStatus.ONLINE);\n+\n+            if (mode == WorkMode.POLLING) {\n+                pollingJob = scheduler.scheduleWithFixedDelay(() -> {\n+                    try {\n+                        communicator.requestSensorData();\n+                    } catch (IOException e) {\n+                        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                                \"Cannot query data from device\");\n+                    }\n+                }, 2, config.pollingInterval, TimeUnit.SECONDS);\n+            }\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                    \"Commands and replies from the device don't seem to match\");\n+            logger.debug(\"Could not configure sensor -> setting Thing to OFFLINE and disposing the handler\");\n+            dispose();\n+        }\n+    }\n+\n+    private boolean validateConfiguration() {\n+        if (config == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR,\n+                    \"Configuration could not be parsed\");\n+            return false;\n+        }\n+\n+        if (config.port == null || config.port.isEmpty()) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR, \"Port must be set!\");\n+            return false;\n+        }\n+        if (config.reporting) {\n+            if (config.reportingInterval < 0 || config.reportingInterval > 30) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR,\n+                        \"Reporting interval has to be between 0 and 30 minutes\");\n+                return false;\n+            }\n+        } else {\n+            if (config.pollingInterval < 3 || config.pollingInterval > 3600) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR,\n+                        \"Polling interval has to be between 3 and 3600 seconds\");\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        if (pollingJob != null) {\n+            pollingJob.cancel(true);\n+            pollingJob = null;\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "36cfe9f558a43f29e09c5da567dc9c0f3479d728"}, "originalPosition": 201}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjkzMjk2Mg==", "bodyText": "My IDE wasn't even showing this warning.\nSo to me it looks like the IDE checks and the build checks are not in sync. There was even a build failure in travis (a couple of commits back) which was fine in eclipse.\nAlso If you insists of dealing with these warnings, I would recommend to make them errors, not warnings, so the build will fail direclty.\nOne side note:\nIf you implement is as you suggested, you will hide the class variable pollingJob with the local variable with the same name and this is a bad code style which can lead to errors. Even Sonoarlint marks this as something that should be changed.", "url": "https://github.com/openhab/openhab-addons/pull/7528#discussion_r432932962", "createdAt": "2020-05-31T10:38:03Z", "author": {"login": "t2000"}, "path": "bundles/org.openhab.binding.novafinedust/src/main/java/org/openhab/binding/novafinedust/internal/SDS011Handler.java", "diffHunk": "@@ -0,0 +1,266 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.novafinedust.internal;\n+\n+import java.io.IOException;\n+import java.time.Duration;\n+import java.time.ZonedDateTime;\n+import java.util.TooManyListenersException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.dimension.Density;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.unit.SmartHomeUnits;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.eclipse.smarthome.io.transport.serial.PortInUseException;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortIdentifier;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.eclipse.smarthome.io.transport.serial.UnsupportedCommOperationException;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.SDS011Communicator;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.WorkMode;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.SensorMeasuredDataReply;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link SDS011Handler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Stefan Triller - Initial contribution\n+ */\n+@NonNullByDefault\n+public class SDS011Handler extends BaseThingHandler {\n+    private static final Duration CONNECTION_MONITOR_START_DELAY_OFFSET = Duration.ofSeconds(10);\n+\n+    private final Logger logger = LoggerFactory.getLogger(SDS011Handler.class);\n+    private final SerialPortManager serialPortManager;\n+\n+    private @Nullable NovaFineDustConfiguration config;\n+    private @Nullable SDS011Communicator communicator;\n+\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+    private @Nullable ScheduledFuture<?> connectionMonitor;\n+\n+    private ZonedDateTime lastCommunication = ZonedDateTime.now();\n+\n+    // initialize timeBetweenDataShouldArrive with a large number\n+    private Duration timeBetweenDataShouldArrive = Duration.ofDays(1);\n+    private final Duration dataCanBeLateTolerance = Duration.ofSeconds(5);\n+\n+    // cached values fro refresh command\n+    private State statePM10 = UnDefType.UNDEF;\n+    private State statePM25 = UnDefType.UNDEF;\n+\n+    public SDS011Handler(Thing thing, SerialPortManager serialPortManager) {\n+        super(thing);\n+        this.serialPortManager = serialPortManager;\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        // refresh channels with last received values from cache\n+        if (RefreshType.REFRESH.equals(command)) {\n+            if (NovaFineDustBindingConstants.CHANNEL_PM25.equals(channelUID.getId()) && statePM25 != UnDefType.UNDEF) {\n+                updateState(NovaFineDustBindingConstants.CHANNEL_PM25, statePM25);\n+            }\n+            if (NovaFineDustBindingConstants.CHANNEL_PM10.equals(channelUID.getId()) && statePM10 != UnDefType.UNDEF) {\n+                updateState(NovaFineDustBindingConstants.CHANNEL_PM10, statePM10);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        config = getConfigAs(NovaFineDustConfiguration.class);\n+\n+        if (!validateConfiguration()) {\n+            return;\n+        }\n+\n+        // parse ports and if the port is found, initialize the reader\n+        SerialPortIdentifier portId = serialPortManager.getIdentifier(config.port);\n+        if (portId == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR, \"Port is not known!\");\n+            return;\n+        }\n+\n+        this.communicator = new SDS011Communicator(this, portId);\n+\n+        if (config.reporting) {\n+            timeBetweenDataShouldArrive = Duration.ofMinutes(config.reportingInterval);\n+            scheduler.schedule(() -> initializeCommunicator(WorkMode.REPORTING, timeBetweenDataShouldArrive), 0,\n+                    TimeUnit.SECONDS);\n+        } else {\n+            timeBetweenDataShouldArrive = Duration.ofSeconds(config.pollingInterval);\n+            scheduler.schedule(() -> initializeCommunicator(WorkMode.POLLING, timeBetweenDataShouldArrive), 0,\n+                    TimeUnit.SECONDS);\n+        }\n+\n+        Duration connectionMonitorStartDelay = timeBetweenDataShouldArrive.plus(CONNECTION_MONITOR_START_DELAY_OFFSET);\n+        connectionMonitor = scheduler.scheduleWithFixedDelay(this::verifyIfStillConnected,\n+                connectionMonitorStartDelay.getSeconds(), timeBetweenDataShouldArrive.getSeconds(), TimeUnit.SECONDS);\n+    }\n+\n+    private void initializeCommunicator(WorkMode mode, Duration interval) {\n+        boolean initSuccessful = false;\n+        try {\n+            initSuccessful = communicator.initialize(mode, interval);\n+        } catch (final IOException ex) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR, \"I/O error!\");\n+            return;\n+        } catch (PortInUseException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR, \"Port is in use!\");\n+            return;\n+        } catch (TooManyListenersException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                    \"Cannot attach listener to port!\");\n+            return;\n+        } catch (UnsupportedCommOperationException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                    \"Cannot set serial port parameters\");\n+            return;\n+        }\n+\n+        if (initSuccessful) {\n+            lastCommunication = ZonedDateTime.now();\n+            updateStatus(ThingStatus.ONLINE);\n+\n+            if (mode == WorkMode.POLLING) {\n+                pollingJob = scheduler.scheduleWithFixedDelay(() -> {\n+                    try {\n+                        communicator.requestSensorData();\n+                    } catch (IOException e) {\n+                        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                                \"Cannot query data from device\");\n+                    }\n+                }, 2, config.pollingInterval, TimeUnit.SECONDS);\n+            }\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                    \"Commands and replies from the device don't seem to match\");\n+            logger.debug(\"Could not configure sensor -> setting Thing to OFFLINE and disposing the handler\");\n+            dispose();\n+        }\n+    }\n+\n+    private boolean validateConfiguration() {\n+        if (config == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR,\n+                    \"Configuration could not be parsed\");\n+            return false;\n+        }\n+\n+        if (config.port == null || config.port.isEmpty()) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR, \"Port must be set!\");\n+            return false;\n+        }\n+        if (config.reporting) {\n+            if (config.reportingInterval < 0 || config.reportingInterval > 30) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR,\n+                        \"Reporting interval has to be between 0 and 30 minutes\");\n+                return false;\n+            }\n+        } else {\n+            if (config.pollingInterval < 3 || config.pollingInterval > 3600) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR,\n+                        \"Polling interval has to be between 3 and 3600 seconds\");\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        if (pollingJob != null) {\n+            pollingJob.cancel(true);\n+            pollingJob = null;\n+        }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg4NDk4Mw=="}, "originalCommit": {"oid": "36cfe9f558a43f29e09c5da567dc9c0f3479d728"}, "originalPosition": 201}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY5OTYzNDA5OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.novafinedust/src/main/java/org/openhab/binding/novafinedust/internal/SDS011Handler.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMVQxNzo1MjoxM1rOGdUL4A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMVQxNzo1MjoxM1rOGdUL4A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzM5MjYwOA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        scheduler.schedule(() -> initializeCommunicator(WorkMode.REPORTING, timeBetweenDataShouldArrive), 0,\n          \n          \n            \n                                TimeUnit.SECONDS);\n          \n          \n            \n                        scheduler.submit(() -> initializeCommunicator(WorkMode.REPORTING, timeBetweenDataShouldArrive));", "url": "https://github.com/openhab/openhab-addons/pull/7528#discussion_r433392608", "createdAt": "2020-06-01T17:52:13Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.novafinedust/src/main/java/org/openhab/binding/novafinedust/internal/SDS011Handler.java", "diffHunk": "@@ -0,0 +1,270 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.novafinedust.internal;\n+\n+import java.io.IOException;\n+import java.time.Duration;\n+import java.time.ZonedDateTime;\n+import java.util.TooManyListenersException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.dimension.Density;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.unit.SmartHomeUnits;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.eclipse.smarthome.io.transport.serial.PortInUseException;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortIdentifier;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.eclipse.smarthome.io.transport.serial.UnsupportedCommOperationException;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.SDS011Communicator;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.WorkMode;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.SensorMeasuredDataReply;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link SDS011Handler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Stefan Triller - Initial contribution\n+ */\n+@NonNullByDefault\n+public class SDS011Handler extends BaseThingHandler {\n+    private static final Duration CONNECTION_MONITOR_START_DELAY_OFFSET = Duration.ofSeconds(10);\n+\n+    private final Logger logger = LoggerFactory.getLogger(SDS011Handler.class);\n+    private final SerialPortManager serialPortManager;\n+\n+    private NovaFineDustConfiguration config = new NovaFineDustConfiguration();\n+    private @Nullable SDS011Communicator communicator;\n+\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+    private @Nullable ScheduledFuture<?> connectionMonitor;\n+\n+    private ZonedDateTime lastCommunication = ZonedDateTime.now();\n+\n+    // initialize timeBetweenDataShouldArrive with a large number\n+    private Duration timeBetweenDataShouldArrive = Duration.ofDays(1);\n+    private final Duration dataCanBeLateTolerance = Duration.ofSeconds(5);\n+\n+    // cached values for refresh command\n+    private State statePM10 = UnDefType.UNDEF;\n+    private State statePM25 = UnDefType.UNDEF;\n+\n+    public SDS011Handler(Thing thing, SerialPortManager serialPortManager) {\n+        super(thing);\n+        this.serialPortManager = serialPortManager;\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        // refresh channels with last received values from cache\n+        if (RefreshType.REFRESH.equals(command)) {\n+            if (NovaFineDustBindingConstants.CHANNEL_PM25.equals(channelUID.getId()) && statePM25 != UnDefType.UNDEF) {\n+                updateState(NovaFineDustBindingConstants.CHANNEL_PM25, statePM25);\n+            }\n+            if (NovaFineDustBindingConstants.CHANNEL_PM10.equals(channelUID.getId()) && statePM10 != UnDefType.UNDEF) {\n+                updateState(NovaFineDustBindingConstants.CHANNEL_PM10, statePM10);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        config = getConfigAs(NovaFineDustConfiguration.class);\n+\n+        if (!validateConfiguration()) {\n+            return;\n+        }\n+\n+        // parse ports and if the port is found, initialize the reader\n+        SerialPortIdentifier portId = serialPortManager.getIdentifier(config.port);\n+        if (portId == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR, \"Port is not known!\");\n+            return;\n+        }\n+\n+        this.communicator = new SDS011Communicator(this, portId);\n+\n+        if (config.reporting) {\n+            timeBetweenDataShouldArrive = Duration.ofMinutes(config.reportingInterval);\n+            scheduler.schedule(() -> initializeCommunicator(WorkMode.REPORTING, timeBetweenDataShouldArrive), 0,\n+                    TimeUnit.SECONDS);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e685099b38e6dda40cf3326a1182d394983790ac"}, "originalPosition": 115}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY5OTYzNDYyOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.novafinedust/src/main/java/org/openhab/binding/novafinedust/internal/SDS011Handler.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMVQxNzo1MjoyNlrOGdUMPQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMVQxNzo1MjoyNlrOGdUMPQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzM5MjcwMQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        scheduler.schedule(() -> initializeCommunicator(WorkMode.POLLING, timeBetweenDataShouldArrive), 0,\n          \n          \n            \n                                TimeUnit.SECONDS);\n          \n          \n            \n                        scheduler.submit(() -> initializeCommunicator(WorkMode.POLLING, timeBetweenDataShouldArrive));", "url": "https://github.com/openhab/openhab-addons/pull/7528#discussion_r433392701", "createdAt": "2020-06-01T17:52:26Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.novafinedust/src/main/java/org/openhab/binding/novafinedust/internal/SDS011Handler.java", "diffHunk": "@@ -0,0 +1,270 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.novafinedust.internal;\n+\n+import java.io.IOException;\n+import java.time.Duration;\n+import java.time.ZonedDateTime;\n+import java.util.TooManyListenersException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.dimension.Density;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.unit.SmartHomeUnits;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.eclipse.smarthome.io.transport.serial.PortInUseException;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortIdentifier;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.eclipse.smarthome.io.transport.serial.UnsupportedCommOperationException;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.SDS011Communicator;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.WorkMode;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.SensorMeasuredDataReply;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link SDS011Handler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Stefan Triller - Initial contribution\n+ */\n+@NonNullByDefault\n+public class SDS011Handler extends BaseThingHandler {\n+    private static final Duration CONNECTION_MONITOR_START_DELAY_OFFSET = Duration.ofSeconds(10);\n+\n+    private final Logger logger = LoggerFactory.getLogger(SDS011Handler.class);\n+    private final SerialPortManager serialPortManager;\n+\n+    private NovaFineDustConfiguration config = new NovaFineDustConfiguration();\n+    private @Nullable SDS011Communicator communicator;\n+\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+    private @Nullable ScheduledFuture<?> connectionMonitor;\n+\n+    private ZonedDateTime lastCommunication = ZonedDateTime.now();\n+\n+    // initialize timeBetweenDataShouldArrive with a large number\n+    private Duration timeBetweenDataShouldArrive = Duration.ofDays(1);\n+    private final Duration dataCanBeLateTolerance = Duration.ofSeconds(5);\n+\n+    // cached values for refresh command\n+    private State statePM10 = UnDefType.UNDEF;\n+    private State statePM25 = UnDefType.UNDEF;\n+\n+    public SDS011Handler(Thing thing, SerialPortManager serialPortManager) {\n+        super(thing);\n+        this.serialPortManager = serialPortManager;\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        // refresh channels with last received values from cache\n+        if (RefreshType.REFRESH.equals(command)) {\n+            if (NovaFineDustBindingConstants.CHANNEL_PM25.equals(channelUID.getId()) && statePM25 != UnDefType.UNDEF) {\n+                updateState(NovaFineDustBindingConstants.CHANNEL_PM25, statePM25);\n+            }\n+            if (NovaFineDustBindingConstants.CHANNEL_PM10.equals(channelUID.getId()) && statePM10 != UnDefType.UNDEF) {\n+                updateState(NovaFineDustBindingConstants.CHANNEL_PM10, statePM10);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        config = getConfigAs(NovaFineDustConfiguration.class);\n+\n+        if (!validateConfiguration()) {\n+            return;\n+        }\n+\n+        // parse ports and if the port is found, initialize the reader\n+        SerialPortIdentifier portId = serialPortManager.getIdentifier(config.port);\n+        if (portId == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR, \"Port is not known!\");\n+            return;\n+        }\n+\n+        this.communicator = new SDS011Communicator(this, portId);\n+\n+        if (config.reporting) {\n+            timeBetweenDataShouldArrive = Duration.ofMinutes(config.reportingInterval);\n+            scheduler.schedule(() -> initializeCommunicator(WorkMode.REPORTING, timeBetweenDataShouldArrive), 0,\n+                    TimeUnit.SECONDS);\n+        } else {\n+            timeBetweenDataShouldArrive = Duration.ofSeconds(config.pollingInterval);\n+            scheduler.schedule(() -> initializeCommunicator(WorkMode.POLLING, timeBetweenDataShouldArrive), 0,\n+                    TimeUnit.SECONDS);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e685099b38e6dda40cf3326a1182d394983790ac"}, "originalPosition": 119}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY5OTY1MDI4OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.novafinedust/src/main/java/org/openhab/binding/novafinedust/internal/SDS011Handler.java", "isResolved": false, "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMVQxNzo1NzoxN1rOGdUWgw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMlQyMTowODowMFrOGeEA4A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzM5NTMzMQ==", "bodyText": "Just to be safe, I would make sure that initialize, dispose, and initializeCommunicator are synchronized.", "url": "https://github.com/openhab/openhab-addons/pull/7528#discussion_r433395331", "createdAt": "2020-06-01T17:57:17Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.novafinedust/src/main/java/org/openhab/binding/novafinedust/internal/SDS011Handler.java", "diffHunk": "@@ -0,0 +1,270 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.novafinedust.internal;\n+\n+import java.io.IOException;\n+import java.time.Duration;\n+import java.time.ZonedDateTime;\n+import java.util.TooManyListenersException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.dimension.Density;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.unit.SmartHomeUnits;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.eclipse.smarthome.io.transport.serial.PortInUseException;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortIdentifier;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.eclipse.smarthome.io.transport.serial.UnsupportedCommOperationException;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.SDS011Communicator;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.WorkMode;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.SensorMeasuredDataReply;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link SDS011Handler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Stefan Triller - Initial contribution\n+ */\n+@NonNullByDefault\n+public class SDS011Handler extends BaseThingHandler {\n+    private static final Duration CONNECTION_MONITOR_START_DELAY_OFFSET = Duration.ofSeconds(10);\n+\n+    private final Logger logger = LoggerFactory.getLogger(SDS011Handler.class);\n+    private final SerialPortManager serialPortManager;\n+\n+    private NovaFineDustConfiguration config = new NovaFineDustConfiguration();\n+    private @Nullable SDS011Communicator communicator;\n+\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+    private @Nullable ScheduledFuture<?> connectionMonitor;\n+\n+    private ZonedDateTime lastCommunication = ZonedDateTime.now();\n+\n+    // initialize timeBetweenDataShouldArrive with a large number\n+    private Duration timeBetweenDataShouldArrive = Duration.ofDays(1);\n+    private final Duration dataCanBeLateTolerance = Duration.ofSeconds(5);\n+\n+    // cached values for refresh command\n+    private State statePM10 = UnDefType.UNDEF;\n+    private State statePM25 = UnDefType.UNDEF;\n+\n+    public SDS011Handler(Thing thing, SerialPortManager serialPortManager) {\n+        super(thing);\n+        this.serialPortManager = serialPortManager;\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        // refresh channels with last received values from cache\n+        if (RefreshType.REFRESH.equals(command)) {\n+            if (NovaFineDustBindingConstants.CHANNEL_PM25.equals(channelUID.getId()) && statePM25 != UnDefType.UNDEF) {\n+                updateState(NovaFineDustBindingConstants.CHANNEL_PM25, statePM25);\n+            }\n+            if (NovaFineDustBindingConstants.CHANNEL_PM10.equals(channelUID.getId()) && statePM10 != UnDefType.UNDEF) {\n+                updateState(NovaFineDustBindingConstants.CHANNEL_PM10, statePM10);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        config = getConfigAs(NovaFineDustConfiguration.class);\n+\n+        if (!validateConfiguration()) {\n+            return;\n+        }\n+\n+        // parse ports and if the port is found, initialize the reader\n+        SerialPortIdentifier portId = serialPortManager.getIdentifier(config.port);\n+        if (portId == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR, \"Port is not known!\");\n+            return;\n+        }\n+\n+        this.communicator = new SDS011Communicator(this, portId);\n+\n+        if (config.reporting) {\n+            timeBetweenDataShouldArrive = Duration.ofMinutes(config.reportingInterval);\n+            scheduler.schedule(() -> initializeCommunicator(WorkMode.REPORTING, timeBetweenDataShouldArrive), 0,\n+                    TimeUnit.SECONDS);\n+        } else {\n+            timeBetweenDataShouldArrive = Duration.ofSeconds(config.pollingInterval);\n+            scheduler.schedule(() -> initializeCommunicator(WorkMode.POLLING, timeBetweenDataShouldArrive), 0,\n+                    TimeUnit.SECONDS);\n+        }\n+\n+        Duration connectionMonitorStartDelay = timeBetweenDataShouldArrive.plus(CONNECTION_MONITOR_START_DELAY_OFFSET);\n+        connectionMonitor = scheduler.scheduleWithFixedDelay(this::verifyIfStillConnected,\n+                connectionMonitorStartDelay.getSeconds(), timeBetweenDataShouldArrive.getSeconds(), TimeUnit.SECONDS);\n+    }\n+\n+    private void initializeCommunicator(WorkMode mode, Duration interval) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e685099b38e6dda40cf3326a1182d394983790ac"}, "originalPosition": 127}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDA5ODY4Nw==", "bodyText": "How should I do that? This won't work if I write synchronized on those methods.\nThe reason is that this will synchronize of the \u00b4ThingHandlerobject and this is never the same is adisposeand aninitializeare called.  TheThingManagerwill always create a newThingHandlerinstance before callinginitialize, so the call to dispose` will happen on a different (old) object.\nThis is what I wanted to state earlier: The openHAB framework currently does NOT ensure that dispose and initialize run into each other, if one is forced to schedule a task (that runs in a different thread) from initialize if one needs more than 5 seconds.\nSo either: I do NOT schedule this task and risk the warning \"ThingHandler initialize takes longer than 5 seconds\", or I take the (in my case pretty unlikely) risk that dispose and initialize collide eventually.\nSo which option should I pick?", "url": "https://github.com/openhab/openhab-addons/pull/7528#discussion_r434098687", "createdAt": "2020-06-02T18:39:57Z", "author": {"login": "t2000"}, "path": "bundles/org.openhab.binding.novafinedust/src/main/java/org/openhab/binding/novafinedust/internal/SDS011Handler.java", "diffHunk": "@@ -0,0 +1,270 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.novafinedust.internal;\n+\n+import java.io.IOException;\n+import java.time.Duration;\n+import java.time.ZonedDateTime;\n+import java.util.TooManyListenersException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.dimension.Density;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.unit.SmartHomeUnits;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.eclipse.smarthome.io.transport.serial.PortInUseException;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortIdentifier;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.eclipse.smarthome.io.transport.serial.UnsupportedCommOperationException;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.SDS011Communicator;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.WorkMode;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.SensorMeasuredDataReply;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link SDS011Handler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Stefan Triller - Initial contribution\n+ */\n+@NonNullByDefault\n+public class SDS011Handler extends BaseThingHandler {\n+    private static final Duration CONNECTION_MONITOR_START_DELAY_OFFSET = Duration.ofSeconds(10);\n+\n+    private final Logger logger = LoggerFactory.getLogger(SDS011Handler.class);\n+    private final SerialPortManager serialPortManager;\n+\n+    private NovaFineDustConfiguration config = new NovaFineDustConfiguration();\n+    private @Nullable SDS011Communicator communicator;\n+\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+    private @Nullable ScheduledFuture<?> connectionMonitor;\n+\n+    private ZonedDateTime lastCommunication = ZonedDateTime.now();\n+\n+    // initialize timeBetweenDataShouldArrive with a large number\n+    private Duration timeBetweenDataShouldArrive = Duration.ofDays(1);\n+    private final Duration dataCanBeLateTolerance = Duration.ofSeconds(5);\n+\n+    // cached values for refresh command\n+    private State statePM10 = UnDefType.UNDEF;\n+    private State statePM25 = UnDefType.UNDEF;\n+\n+    public SDS011Handler(Thing thing, SerialPortManager serialPortManager) {\n+        super(thing);\n+        this.serialPortManager = serialPortManager;\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        // refresh channels with last received values from cache\n+        if (RefreshType.REFRESH.equals(command)) {\n+            if (NovaFineDustBindingConstants.CHANNEL_PM25.equals(channelUID.getId()) && statePM25 != UnDefType.UNDEF) {\n+                updateState(NovaFineDustBindingConstants.CHANNEL_PM25, statePM25);\n+            }\n+            if (NovaFineDustBindingConstants.CHANNEL_PM10.equals(channelUID.getId()) && statePM10 != UnDefType.UNDEF) {\n+                updateState(NovaFineDustBindingConstants.CHANNEL_PM10, statePM10);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        config = getConfigAs(NovaFineDustConfiguration.class);\n+\n+        if (!validateConfiguration()) {\n+            return;\n+        }\n+\n+        // parse ports and if the port is found, initialize the reader\n+        SerialPortIdentifier portId = serialPortManager.getIdentifier(config.port);\n+        if (portId == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR, \"Port is not known!\");\n+            return;\n+        }\n+\n+        this.communicator = new SDS011Communicator(this, portId);\n+\n+        if (config.reporting) {\n+            timeBetweenDataShouldArrive = Duration.ofMinutes(config.reportingInterval);\n+            scheduler.schedule(() -> initializeCommunicator(WorkMode.REPORTING, timeBetweenDataShouldArrive), 0,\n+                    TimeUnit.SECONDS);\n+        } else {\n+            timeBetweenDataShouldArrive = Duration.ofSeconds(config.pollingInterval);\n+            scheduler.schedule(() -> initializeCommunicator(WorkMode.POLLING, timeBetweenDataShouldArrive), 0,\n+                    TimeUnit.SECONDS);\n+        }\n+\n+        Duration connectionMonitorStartDelay = timeBetweenDataShouldArrive.plus(CONNECTION_MONITOR_START_DELAY_OFFSET);\n+        connectionMonitor = scheduler.scheduleWithFixedDelay(this::verifyIfStillConnected,\n+                connectionMonitorStartDelay.getSeconds(), timeBetweenDataShouldArrive.getSeconds(), TimeUnit.SECONDS);\n+    }\n+\n+    private void initializeCommunicator(WorkMode mode, Duration interval) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzM5NTMzMQ=="}, "originalCommit": {"oid": "e685099b38e6dda40cf3326a1182d394983790ac"}, "originalPosition": 127}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDEyNDc2Nw==", "bodyText": "@J-N-K Could you please weigh in here? I can't tell if I'm being overly concerned or not with regards to thread safety here.", "url": "https://github.com/openhab/openhab-addons/pull/7528#discussion_r434124767", "createdAt": "2020-06-02T19:26:12Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.novafinedust/src/main/java/org/openhab/binding/novafinedust/internal/SDS011Handler.java", "diffHunk": "@@ -0,0 +1,270 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.novafinedust.internal;\n+\n+import java.io.IOException;\n+import java.time.Duration;\n+import java.time.ZonedDateTime;\n+import java.util.TooManyListenersException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.dimension.Density;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.unit.SmartHomeUnits;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.eclipse.smarthome.io.transport.serial.PortInUseException;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortIdentifier;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.eclipse.smarthome.io.transport.serial.UnsupportedCommOperationException;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.SDS011Communicator;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.WorkMode;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.SensorMeasuredDataReply;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link SDS011Handler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Stefan Triller - Initial contribution\n+ */\n+@NonNullByDefault\n+public class SDS011Handler extends BaseThingHandler {\n+    private static final Duration CONNECTION_MONITOR_START_DELAY_OFFSET = Duration.ofSeconds(10);\n+\n+    private final Logger logger = LoggerFactory.getLogger(SDS011Handler.class);\n+    private final SerialPortManager serialPortManager;\n+\n+    private NovaFineDustConfiguration config = new NovaFineDustConfiguration();\n+    private @Nullable SDS011Communicator communicator;\n+\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+    private @Nullable ScheduledFuture<?> connectionMonitor;\n+\n+    private ZonedDateTime lastCommunication = ZonedDateTime.now();\n+\n+    // initialize timeBetweenDataShouldArrive with a large number\n+    private Duration timeBetweenDataShouldArrive = Duration.ofDays(1);\n+    private final Duration dataCanBeLateTolerance = Duration.ofSeconds(5);\n+\n+    // cached values for refresh command\n+    private State statePM10 = UnDefType.UNDEF;\n+    private State statePM25 = UnDefType.UNDEF;\n+\n+    public SDS011Handler(Thing thing, SerialPortManager serialPortManager) {\n+        super(thing);\n+        this.serialPortManager = serialPortManager;\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        // refresh channels with last received values from cache\n+        if (RefreshType.REFRESH.equals(command)) {\n+            if (NovaFineDustBindingConstants.CHANNEL_PM25.equals(channelUID.getId()) && statePM25 != UnDefType.UNDEF) {\n+                updateState(NovaFineDustBindingConstants.CHANNEL_PM25, statePM25);\n+            }\n+            if (NovaFineDustBindingConstants.CHANNEL_PM10.equals(channelUID.getId()) && statePM10 != UnDefType.UNDEF) {\n+                updateState(NovaFineDustBindingConstants.CHANNEL_PM10, statePM10);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        config = getConfigAs(NovaFineDustConfiguration.class);\n+\n+        if (!validateConfiguration()) {\n+            return;\n+        }\n+\n+        // parse ports and if the port is found, initialize the reader\n+        SerialPortIdentifier portId = serialPortManager.getIdentifier(config.port);\n+        if (portId == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR, \"Port is not known!\");\n+            return;\n+        }\n+\n+        this.communicator = new SDS011Communicator(this, portId);\n+\n+        if (config.reporting) {\n+            timeBetweenDataShouldArrive = Duration.ofMinutes(config.reportingInterval);\n+            scheduler.schedule(() -> initializeCommunicator(WorkMode.REPORTING, timeBetweenDataShouldArrive), 0,\n+                    TimeUnit.SECONDS);\n+        } else {\n+            timeBetweenDataShouldArrive = Duration.ofSeconds(config.pollingInterval);\n+            scheduler.schedule(() -> initializeCommunicator(WorkMode.POLLING, timeBetweenDataShouldArrive), 0,\n+                    TimeUnit.SECONDS);\n+        }\n+\n+        Duration connectionMonitorStartDelay = timeBetweenDataShouldArrive.plus(CONNECTION_MONITOR_START_DELAY_OFFSET);\n+        connectionMonitor = scheduler.scheduleWithFixedDelay(this::verifyIfStillConnected,\n+                connectionMonitorStartDelay.getSeconds(), timeBetweenDataShouldArrive.getSeconds(), TimeUnit.SECONDS);\n+    }\n+\n+    private void initializeCommunicator(WorkMode mode, Duration interval) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzM5NTMzMQ=="}, "originalCommit": {"oid": "e685099b38e6dda40cf3326a1182d394983790ac"}, "originalPosition": 127}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDE1MjU2Nw==", "bodyText": "I can chime in here. We never have synchronized keywords on such methods. As @t2000 mentions, the work is done in a separate thread and it is actually intended that the framework is able to dispose the handler, while such jobs might still be running. They should NOT block a call of dispose, so synchronizing it would be counter-productive.", "url": "https://github.com/openhab/openhab-addons/pull/7528#discussion_r434152567", "createdAt": "2020-06-02T20:20:30Z", "author": {"login": "kaikreuzer"}, "path": "bundles/org.openhab.binding.novafinedust/src/main/java/org/openhab/binding/novafinedust/internal/SDS011Handler.java", "diffHunk": "@@ -0,0 +1,270 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.novafinedust.internal;\n+\n+import java.io.IOException;\n+import java.time.Duration;\n+import java.time.ZonedDateTime;\n+import java.util.TooManyListenersException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.dimension.Density;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.unit.SmartHomeUnits;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.eclipse.smarthome.io.transport.serial.PortInUseException;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortIdentifier;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.eclipse.smarthome.io.transport.serial.UnsupportedCommOperationException;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.SDS011Communicator;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.WorkMode;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.SensorMeasuredDataReply;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link SDS011Handler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Stefan Triller - Initial contribution\n+ */\n+@NonNullByDefault\n+public class SDS011Handler extends BaseThingHandler {\n+    private static final Duration CONNECTION_MONITOR_START_DELAY_OFFSET = Duration.ofSeconds(10);\n+\n+    private final Logger logger = LoggerFactory.getLogger(SDS011Handler.class);\n+    private final SerialPortManager serialPortManager;\n+\n+    private NovaFineDustConfiguration config = new NovaFineDustConfiguration();\n+    private @Nullable SDS011Communicator communicator;\n+\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+    private @Nullable ScheduledFuture<?> connectionMonitor;\n+\n+    private ZonedDateTime lastCommunication = ZonedDateTime.now();\n+\n+    // initialize timeBetweenDataShouldArrive with a large number\n+    private Duration timeBetweenDataShouldArrive = Duration.ofDays(1);\n+    private final Duration dataCanBeLateTolerance = Duration.ofSeconds(5);\n+\n+    // cached values for refresh command\n+    private State statePM10 = UnDefType.UNDEF;\n+    private State statePM25 = UnDefType.UNDEF;\n+\n+    public SDS011Handler(Thing thing, SerialPortManager serialPortManager) {\n+        super(thing);\n+        this.serialPortManager = serialPortManager;\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        // refresh channels with last received values from cache\n+        if (RefreshType.REFRESH.equals(command)) {\n+            if (NovaFineDustBindingConstants.CHANNEL_PM25.equals(channelUID.getId()) && statePM25 != UnDefType.UNDEF) {\n+                updateState(NovaFineDustBindingConstants.CHANNEL_PM25, statePM25);\n+            }\n+            if (NovaFineDustBindingConstants.CHANNEL_PM10.equals(channelUID.getId()) && statePM10 != UnDefType.UNDEF) {\n+                updateState(NovaFineDustBindingConstants.CHANNEL_PM10, statePM10);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        config = getConfigAs(NovaFineDustConfiguration.class);\n+\n+        if (!validateConfiguration()) {\n+            return;\n+        }\n+\n+        // parse ports and if the port is found, initialize the reader\n+        SerialPortIdentifier portId = serialPortManager.getIdentifier(config.port);\n+        if (portId == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR, \"Port is not known!\");\n+            return;\n+        }\n+\n+        this.communicator = new SDS011Communicator(this, portId);\n+\n+        if (config.reporting) {\n+            timeBetweenDataShouldArrive = Duration.ofMinutes(config.reportingInterval);\n+            scheduler.schedule(() -> initializeCommunicator(WorkMode.REPORTING, timeBetweenDataShouldArrive), 0,\n+                    TimeUnit.SECONDS);\n+        } else {\n+            timeBetweenDataShouldArrive = Duration.ofSeconds(config.pollingInterval);\n+            scheduler.schedule(() -> initializeCommunicator(WorkMode.POLLING, timeBetweenDataShouldArrive), 0,\n+                    TimeUnit.SECONDS);\n+        }\n+\n+        Duration connectionMonitorStartDelay = timeBetweenDataShouldArrive.plus(CONNECTION_MONITOR_START_DELAY_OFFSET);\n+        connectionMonitor = scheduler.scheduleWithFixedDelay(this::verifyIfStillConnected,\n+                connectionMonitorStartDelay.getSeconds(), timeBetweenDataShouldArrive.getSeconds(), TimeUnit.SECONDS);\n+    }\n+\n+    private void initializeCommunicator(WorkMode mode, Duration interval) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzM5NTMzMQ=="}, "originalCommit": {"oid": "e685099b38e6dda40cf3326a1182d394983790ac"}, "originalPosition": 127}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDE2MzE3MA==", "bodyText": "@kaikreuzer I'm just concerned that initializeCommunicator would be called after dispose since initializeCommunicator is called asynchronously.", "url": "https://github.com/openhab/openhab-addons/pull/7528#discussion_r434163170", "createdAt": "2020-06-02T20:41:41Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.novafinedust/src/main/java/org/openhab/binding/novafinedust/internal/SDS011Handler.java", "diffHunk": "@@ -0,0 +1,270 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.novafinedust.internal;\n+\n+import java.io.IOException;\n+import java.time.Duration;\n+import java.time.ZonedDateTime;\n+import java.util.TooManyListenersException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.dimension.Density;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.unit.SmartHomeUnits;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.eclipse.smarthome.io.transport.serial.PortInUseException;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortIdentifier;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.eclipse.smarthome.io.transport.serial.UnsupportedCommOperationException;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.SDS011Communicator;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.WorkMode;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.SensorMeasuredDataReply;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link SDS011Handler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Stefan Triller - Initial contribution\n+ */\n+@NonNullByDefault\n+public class SDS011Handler extends BaseThingHandler {\n+    private static final Duration CONNECTION_MONITOR_START_DELAY_OFFSET = Duration.ofSeconds(10);\n+\n+    private final Logger logger = LoggerFactory.getLogger(SDS011Handler.class);\n+    private final SerialPortManager serialPortManager;\n+\n+    private NovaFineDustConfiguration config = new NovaFineDustConfiguration();\n+    private @Nullable SDS011Communicator communicator;\n+\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+    private @Nullable ScheduledFuture<?> connectionMonitor;\n+\n+    private ZonedDateTime lastCommunication = ZonedDateTime.now();\n+\n+    // initialize timeBetweenDataShouldArrive with a large number\n+    private Duration timeBetweenDataShouldArrive = Duration.ofDays(1);\n+    private final Duration dataCanBeLateTolerance = Duration.ofSeconds(5);\n+\n+    // cached values for refresh command\n+    private State statePM10 = UnDefType.UNDEF;\n+    private State statePM25 = UnDefType.UNDEF;\n+\n+    public SDS011Handler(Thing thing, SerialPortManager serialPortManager) {\n+        super(thing);\n+        this.serialPortManager = serialPortManager;\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        // refresh channels with last received values from cache\n+        if (RefreshType.REFRESH.equals(command)) {\n+            if (NovaFineDustBindingConstants.CHANNEL_PM25.equals(channelUID.getId()) && statePM25 != UnDefType.UNDEF) {\n+                updateState(NovaFineDustBindingConstants.CHANNEL_PM25, statePM25);\n+            }\n+            if (NovaFineDustBindingConstants.CHANNEL_PM10.equals(channelUID.getId()) && statePM10 != UnDefType.UNDEF) {\n+                updateState(NovaFineDustBindingConstants.CHANNEL_PM10, statePM10);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        config = getConfigAs(NovaFineDustConfiguration.class);\n+\n+        if (!validateConfiguration()) {\n+            return;\n+        }\n+\n+        // parse ports and if the port is found, initialize the reader\n+        SerialPortIdentifier portId = serialPortManager.getIdentifier(config.port);\n+        if (portId == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR, \"Port is not known!\");\n+            return;\n+        }\n+\n+        this.communicator = new SDS011Communicator(this, portId);\n+\n+        if (config.reporting) {\n+            timeBetweenDataShouldArrive = Duration.ofMinutes(config.reportingInterval);\n+            scheduler.schedule(() -> initializeCommunicator(WorkMode.REPORTING, timeBetweenDataShouldArrive), 0,\n+                    TimeUnit.SECONDS);\n+        } else {\n+            timeBetweenDataShouldArrive = Duration.ofSeconds(config.pollingInterval);\n+            scheduler.schedule(() -> initializeCommunicator(WorkMode.POLLING, timeBetweenDataShouldArrive), 0,\n+                    TimeUnit.SECONDS);\n+        }\n+\n+        Duration connectionMonitorStartDelay = timeBetweenDataShouldArrive.plus(CONNECTION_MONITOR_START_DELAY_OFFSET);\n+        connectionMonitor = scheduler.scheduleWithFixedDelay(this::verifyIfStillConnected,\n+                connectionMonitorStartDelay.getSeconds(), timeBetweenDataShouldArrive.getSeconds(), TimeUnit.SECONDS);\n+    }\n+\n+    private void initializeCommunicator(WorkMode mode, Duration interval) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzM5NTMzMQ=="}, "originalCommit": {"oid": "e685099b38e6dda40cf3326a1182d394983790ac"}, "originalPosition": 127}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDE3NjIyNA==", "bodyText": "Sounds pretty unlikely and even if it does, the code should be written in a way that it shouldn't harm much.\nIf dispose would set the communicator to null and initializeCommunicator would not try to set the Thing status upon a null-communicator, it should almost be safe ;-)", "url": "https://github.com/openhab/openhab-addons/pull/7528#discussion_r434176224", "createdAt": "2020-06-02T21:08:00Z", "author": {"login": "kaikreuzer"}, "path": "bundles/org.openhab.binding.novafinedust/src/main/java/org/openhab/binding/novafinedust/internal/SDS011Handler.java", "diffHunk": "@@ -0,0 +1,270 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.novafinedust.internal;\n+\n+import java.io.IOException;\n+import java.time.Duration;\n+import java.time.ZonedDateTime;\n+import java.util.TooManyListenersException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.dimension.Density;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.unit.SmartHomeUnits;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.eclipse.smarthome.io.transport.serial.PortInUseException;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortIdentifier;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.eclipse.smarthome.io.transport.serial.UnsupportedCommOperationException;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.SDS011Communicator;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.WorkMode;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.SensorMeasuredDataReply;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link SDS011Handler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Stefan Triller - Initial contribution\n+ */\n+@NonNullByDefault\n+public class SDS011Handler extends BaseThingHandler {\n+    private static final Duration CONNECTION_MONITOR_START_DELAY_OFFSET = Duration.ofSeconds(10);\n+\n+    private final Logger logger = LoggerFactory.getLogger(SDS011Handler.class);\n+    private final SerialPortManager serialPortManager;\n+\n+    private NovaFineDustConfiguration config = new NovaFineDustConfiguration();\n+    private @Nullable SDS011Communicator communicator;\n+\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+    private @Nullable ScheduledFuture<?> connectionMonitor;\n+\n+    private ZonedDateTime lastCommunication = ZonedDateTime.now();\n+\n+    // initialize timeBetweenDataShouldArrive with a large number\n+    private Duration timeBetweenDataShouldArrive = Duration.ofDays(1);\n+    private final Duration dataCanBeLateTolerance = Duration.ofSeconds(5);\n+\n+    // cached values for refresh command\n+    private State statePM10 = UnDefType.UNDEF;\n+    private State statePM25 = UnDefType.UNDEF;\n+\n+    public SDS011Handler(Thing thing, SerialPortManager serialPortManager) {\n+        super(thing);\n+        this.serialPortManager = serialPortManager;\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        // refresh channels with last received values from cache\n+        if (RefreshType.REFRESH.equals(command)) {\n+            if (NovaFineDustBindingConstants.CHANNEL_PM25.equals(channelUID.getId()) && statePM25 != UnDefType.UNDEF) {\n+                updateState(NovaFineDustBindingConstants.CHANNEL_PM25, statePM25);\n+            }\n+            if (NovaFineDustBindingConstants.CHANNEL_PM10.equals(channelUID.getId()) && statePM10 != UnDefType.UNDEF) {\n+                updateState(NovaFineDustBindingConstants.CHANNEL_PM10, statePM10);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        config = getConfigAs(NovaFineDustConfiguration.class);\n+\n+        if (!validateConfiguration()) {\n+            return;\n+        }\n+\n+        // parse ports and if the port is found, initialize the reader\n+        SerialPortIdentifier portId = serialPortManager.getIdentifier(config.port);\n+        if (portId == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR, \"Port is not known!\");\n+            return;\n+        }\n+\n+        this.communicator = new SDS011Communicator(this, portId);\n+\n+        if (config.reporting) {\n+            timeBetweenDataShouldArrive = Duration.ofMinutes(config.reportingInterval);\n+            scheduler.schedule(() -> initializeCommunicator(WorkMode.REPORTING, timeBetweenDataShouldArrive), 0,\n+                    TimeUnit.SECONDS);\n+        } else {\n+            timeBetweenDataShouldArrive = Duration.ofSeconds(config.pollingInterval);\n+            scheduler.schedule(() -> initializeCommunicator(WorkMode.POLLING, timeBetweenDataShouldArrive), 0,\n+                    TimeUnit.SECONDS);\n+        }\n+\n+        Duration connectionMonitorStartDelay = timeBetweenDataShouldArrive.plus(CONNECTION_MONITOR_START_DELAY_OFFSET);\n+        connectionMonitor = scheduler.scheduleWithFixedDelay(this::verifyIfStillConnected,\n+                connectionMonitorStartDelay.getSeconds(), timeBetweenDataShouldArrive.getSeconds(), TimeUnit.SECONDS);\n+    }\n+\n+    private void initializeCommunicator(WorkMode mode, Duration interval) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzM5NTMzMQ=="}, "originalCommit": {"oid": "e685099b38e6dda40cf3326a1182d394983790ac"}, "originalPosition": 127}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjczOTY2MjU2OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.novafinedust/README.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xM1QyMDozMjoxN1rOGjZQ3Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xM1QyMDozMjoxN1rOGjZQ3Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTc2NzI2MQ==", "bodyText": "Please add a newline after every sentence throughout the README.\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            This binding is for the fine dust sensor (PM Sensor) from Nova Fitness. Currently only one model is supported, the SDS011.\n          \n          \n            \n            This binding is for the fine dust sensor (PM Sensor) from Nova Fitness.\n          \n          \n            \n            Currently only one model is supported, the SDS011.", "url": "https://github.com/openhab/openhab-addons/pull/7528#discussion_r439767261", "createdAt": "2020-06-13T20:32:17Z", "author": {"login": "kaikreuzer"}, "path": "bundles/org.openhab.binding.novafinedust/README.md", "diffHunk": "@@ -0,0 +1,78 @@\n+# NovaFineDust Binding\n+\n+This binding is for the fine dust sensor (PM Sensor) from Nova Fitness. Currently only one model is supported, the SDS011.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d94ddb4ba25efe4248d2a174b64f1be2db773484"}, "originalPosition": 3}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjczOTY2Mjg0OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.novafinedust/README.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xM1QyMDozMjo1MFrOGjZRAw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xM1QyMDozMjo1MFrOGjZRAw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTc2NzI5OQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            There is only one Thing for this binding is `SDS011`.\n          \n          \n            \n            There is only one Thing type for this binding, which is `SDS011`.", "url": "https://github.com/openhab/openhab-addons/pull/7528#discussion_r439767299", "createdAt": "2020-06-13T20:32:50Z", "author": {"login": "kaikreuzer"}, "path": "bundles/org.openhab.binding.novafinedust/README.md", "diffHunk": "@@ -0,0 +1,78 @@\n+# NovaFineDust Binding\n+\n+This binding is for the fine dust sensor (PM Sensor) from Nova Fitness. Currently only one model is supported, the SDS011.\n+\n+It basically implements the protocol specified in [this document](https://cdn.sparkfun.com/assets/parts/1/2/2/7/5/Laser_Dust_Sensor_Control_Protocol_V1.3.pdf).\n+One can measure the PM 2.5 and PM 10 values with this device. It comes very handy for detecting air pollution like neighbors firing their oven with wet wood etc. so one can deactivate the ventilation system. \n+\n+## Supported Things\n+\n+There is only one Thing for this binding is `SDS011`.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d94ddb4ba25efe4248d2a174b64f1be2db773484"}, "originalPosition": 10}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjczOTY2MzA5OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.novafinedust/README.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xM1QyMDozMzoxN1rOGjZRIA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xM1QyMDozMzoxN1rOGjZRIA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTc2NzMyOA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            There is no automatic discovery. The Thing has to be added manually via the `.things` configuration file or via (Paper) UI.\n          \n          \n            \n            There is no automatic discovery.", "url": "https://github.com/openhab/openhab-addons/pull/7528#discussion_r439767328", "createdAt": "2020-06-13T20:33:17Z", "author": {"login": "kaikreuzer"}, "path": "bundles/org.openhab.binding.novafinedust/README.md", "diffHunk": "@@ -0,0 +1,78 @@\n+# NovaFineDust Binding\n+\n+This binding is for the fine dust sensor (PM Sensor) from Nova Fitness. Currently only one model is supported, the SDS011.\n+\n+It basically implements the protocol specified in [this document](https://cdn.sparkfun.com/assets/parts/1/2/2/7/5/Laser_Dust_Sensor_Control_Protocol_V1.3.pdf).\n+One can measure the PM 2.5 and PM 10 values with this device. It comes very handy for detecting air pollution like neighbors firing their oven with wet wood etc. so one can deactivate the ventilation system. \n+\n+## Supported Things\n+\n+There is only one Thing for this binding is `SDS011`.\n+\n+## Discovery\n+\n+There is no automatic discovery. The Thing has to be added manually via the `.things` configuration file or via (Paper) UI.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d94ddb4ba25efe4248d2a174b64f1be2db773484"}, "originalPosition": 14}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjczOTY2Mzc4OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.novafinedust/README.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xM1QyMDozNTowM1rOGjZRfA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xM1QyMDozNTowM1rOGjZRfA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTc2NzQyMA==", "bodyText": "Above you say that \"reporting\" is the default mode. If there's a default, the parameter is not mandatory, but optional.", "url": "https://github.com/openhab/openhab-addons/pull/7528#discussion_r439767420", "createdAt": "2020-06-13T20:35:03Z", "author": {"login": "kaikreuzer"}, "path": "bundles/org.openhab.binding.novafinedust/README.md", "diffHunk": "@@ -0,0 +1,78 @@\n+# NovaFineDust Binding\n+\n+This binding is for the fine dust sensor (PM Sensor) from Nova Fitness. Currently only one model is supported, the SDS011.\n+\n+It basically implements the protocol specified in [this document](https://cdn.sparkfun.com/assets/parts/1/2/2/7/5/Laser_Dust_Sensor_Control_Protocol_V1.3.pdf).\n+One can measure the PM 2.5 and PM 10 values with this device. It comes very handy for detecting air pollution like neighbors firing their oven with wet wood etc. so one can deactivate the ventilation system. \n+\n+## Supported Things\n+\n+There is only one Thing for this binding is `SDS011`.\n+\n+## Discovery\n+\n+There is no automatic discovery. The Thing has to be added manually via the `.things` configuration file or via (Paper) UI.\n+\n+## Thing Configuration\n+\n+There are 2 different working modes for the `SDS011` thing: Reporting and Polling.\n+\n+### Reporting\n+\n+This is the preferred mode and thus also configured as a default. In this mode the sensor wakes up every `reportingInterval` minutes, performs a measurement for 30 seconds and sleeps for `reportingInterval` minus 30 seconds. Remember: According to the [datasheet](https://www-sd-nf.oss-cn-beijing.aliyuncs.com/%E5%AE%98%E7%BD%91%E4%B8%8B%E8%BD%BD/SDS011%20laser%20PM2.5%20sensor%20specification-V1.4.pdf) the sensor has a lifetime of 8000 hours. Using a 0 as `reportingInterval` will make the sensor report its data as fast as possible.\n+\n+### Polling\n+\n+If one needs data in different intervals, i.e. not as fast as possible and not in intervals that are a multiple of full minutes, polling can be configured. The `pollingInterval` parameter specifies the time in seconds when data will be polled from the sensor.\n+\n+In addition to the mode one has to provide the port to which the device is connected.\n+\n+A full overview about the parameters of the `SDS011` thing is given in the following table:\n+\n+| parameter name    | mandatory | description                                                                           |\n+|-------------------|-----------|---------------------------------------------------------------------------------------|\n+| port              | yes       | the port the sensor is connected to, i.e. /dev/ttyUSB0.                              |\n+| reporting         | yes       | whether the reporting mode (value=true) or polling mode should be used.               |", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d94ddb4ba25efe4248d2a174b64f1be2db773484"}, "originalPosition": 35}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjczOTY2NDkyOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.novafinedust/README.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xM1QyMDozNzozN1rOGjZSCw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xM1QyMDozNzozN1rOGjZSCw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTc2NzU2Mw==", "bodyText": "You mean there could be multiple sensors on the same port, right?\nI very much hope that it is possible to have multiple SDS011 things that use different ports.\nMaybe you can clarify this in the statement here a bit.", "url": "https://github.com/openhab/openhab-addons/pull/7528#discussion_r439767563", "createdAt": "2020-06-13T20:37:37Z", "author": {"login": "kaikreuzer"}, "path": "bundles/org.openhab.binding.novafinedust/README.md", "diffHunk": "@@ -0,0 +1,78 @@\n+# NovaFineDust Binding\n+\n+This binding is for the fine dust sensor (PM Sensor) from Nova Fitness. Currently only one model is supported, the SDS011.\n+\n+It basically implements the protocol specified in [this document](https://cdn.sparkfun.com/assets/parts/1/2/2/7/5/Laser_Dust_Sensor_Control_Protocol_V1.3.pdf).\n+One can measure the PM 2.5 and PM 10 values with this device. It comes very handy for detecting air pollution like neighbors firing their oven with wet wood etc. so one can deactivate the ventilation system. \n+\n+## Supported Things\n+\n+There is only one Thing for this binding is `SDS011`.\n+\n+## Discovery\n+\n+There is no automatic discovery. The Thing has to be added manually via the `.things` configuration file or via (Paper) UI.\n+\n+## Thing Configuration\n+\n+There are 2 different working modes for the `SDS011` thing: Reporting and Polling.\n+\n+### Reporting\n+\n+This is the preferred mode and thus also configured as a default. In this mode the sensor wakes up every `reportingInterval` minutes, performs a measurement for 30 seconds and sleeps for `reportingInterval` minus 30 seconds. Remember: According to the [datasheet](https://www-sd-nf.oss-cn-beijing.aliyuncs.com/%E5%AE%98%E7%BD%91%E4%B8%8B%E8%BD%BD/SDS011%20laser%20PM2.5%20sensor%20specification-V1.4.pdf) the sensor has a lifetime of 8000 hours. Using a 0 as `reportingInterval` will make the sensor report its data as fast as possible.\n+\n+### Polling\n+\n+If one needs data in different intervals, i.e. not as fast as possible and not in intervals that are a multiple of full minutes, polling can be configured. The `pollingInterval` parameter specifies the time in seconds when data will be polled from the sensor.\n+\n+In addition to the mode one has to provide the port to which the device is connected.\n+\n+A full overview about the parameters of the `SDS011` thing is given in the following table:\n+\n+| parameter name    | mandatory | description                                                                           |\n+|-------------------|-----------|---------------------------------------------------------------------------------------|\n+| port              | yes       | the port the sensor is connected to, i.e. /dev/ttyUSB0.                              |\n+| reporting         | yes       | whether the reporting mode (value=true) or polling mode should be used.               |\n+| reportingInterval | no        | the time in minutes between reportings from the sensor (default=1, min=0, max=30).    |\n+| pollingInterval   | no        | the time in seconds between data polls from the device. (default=10, min=3, max=3600) |\n+\n+## Channels\n+\n+Since the supported device is a sensor, both channels are read-only channels. \n+\n+| channel  | type           | description                   |\n+|----------|----------------|-------------------------------|\n+| pm25     | Number:Density | This provides the PM2.5 value |\n+| pm10     | Number:Density | This provides the PM10 value  |\n+\n+## Full Example\n+\n+demo.things:\n+\n+```\n+Thing novafinedust:SDS011:mySDS011Report \"My SDS011 Fine Dust Sensor with reporting\" [ port=\"/dev/ttyUSB0\", reporting=true, reportingInterval=1 ]\n+Thing novafinedust:SDS011:mySDS011Poll \"My SDS011 Fine Dust Sensor with polling\" [ port=\"/dev/ttyUSB0\", reporting=false, pollingInterval=10 ]\n+```\n+\n+demo.items:\n+\n+```\n+Number:Density PM25 \"My PM 2.5 value\" { channel=\"novafinedust:SDS011:mySDS011Report:pm25\" }\n+Number:Density PM10 \"My PM 10 value\" { channel=\"novafinedust:SDS011:mySDS011Report:pm10\" }\n+```\n+\n+demo.sitemap:\n+\n+```\n+sitemap demo label=\"Main Menu\"\n+{\n+    Frame {\n+        Text item=PM25 label=\"My PM 2.5 value\"\n+        Text item=PM10 label=\"My PM 10 value\"\n+    }\n+}\n+```\n+\n+## Limitations\n+\n+In theory once can have multiple sensors connected and distinguish them via their device ID. However, this is currently not implemented and the binding always configures any device and accepts data reportings from any device too.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d94ddb4ba25efe4248d2a174b64f1be2db773484"}, "originalPosition": 78}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjczOTY2NTU0OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.novafinedust/README.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xM1QyMDozODo0MVrOGjZSVw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xM1QyMDozODo0MVrOGjZSVw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTc2NzYzOQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            In theory once can have multiple sensors connected and distinguish them via their device ID. However, this is currently not implemented and the binding always configures any device and accepts data reportings from any device too.\n          \n          \n            \n            In theory one can have multiple sensors connected and distinguish them via their device ID. However, this is currently not implemented and the binding always configures any device and accepts data reportings from any device too.", "url": "https://github.com/openhab/openhab-addons/pull/7528#discussion_r439767639", "createdAt": "2020-06-13T20:38:41Z", "author": {"login": "kaikreuzer"}, "path": "bundles/org.openhab.binding.novafinedust/README.md", "diffHunk": "@@ -0,0 +1,78 @@\n+# NovaFineDust Binding\n+\n+This binding is for the fine dust sensor (PM Sensor) from Nova Fitness. Currently only one model is supported, the SDS011.\n+\n+It basically implements the protocol specified in [this document](https://cdn.sparkfun.com/assets/parts/1/2/2/7/5/Laser_Dust_Sensor_Control_Protocol_V1.3.pdf).\n+One can measure the PM 2.5 and PM 10 values with this device. It comes very handy for detecting air pollution like neighbors firing their oven with wet wood etc. so one can deactivate the ventilation system. \n+\n+## Supported Things\n+\n+There is only one Thing for this binding is `SDS011`.\n+\n+## Discovery\n+\n+There is no automatic discovery. The Thing has to be added manually via the `.things` configuration file or via (Paper) UI.\n+\n+## Thing Configuration\n+\n+There are 2 different working modes for the `SDS011` thing: Reporting and Polling.\n+\n+### Reporting\n+\n+This is the preferred mode and thus also configured as a default. In this mode the sensor wakes up every `reportingInterval` minutes, performs a measurement for 30 seconds and sleeps for `reportingInterval` minus 30 seconds. Remember: According to the [datasheet](https://www-sd-nf.oss-cn-beijing.aliyuncs.com/%E5%AE%98%E7%BD%91%E4%B8%8B%E8%BD%BD/SDS011%20laser%20PM2.5%20sensor%20specification-V1.4.pdf) the sensor has a lifetime of 8000 hours. Using a 0 as `reportingInterval` will make the sensor report its data as fast as possible.\n+\n+### Polling\n+\n+If one needs data in different intervals, i.e. not as fast as possible and not in intervals that are a multiple of full minutes, polling can be configured. The `pollingInterval` parameter specifies the time in seconds when data will be polled from the sensor.\n+\n+In addition to the mode one has to provide the port to which the device is connected.\n+\n+A full overview about the parameters of the `SDS011` thing is given in the following table:\n+\n+| parameter name    | mandatory | description                                                                           |\n+|-------------------|-----------|---------------------------------------------------------------------------------------|\n+| port              | yes       | the port the sensor is connected to, i.e. /dev/ttyUSB0.                              |\n+| reporting         | yes       | whether the reporting mode (value=true) or polling mode should be used.               |\n+| reportingInterval | no        | the time in minutes between reportings from the sensor (default=1, min=0, max=30).    |\n+| pollingInterval   | no        | the time in seconds between data polls from the device. (default=10, min=3, max=3600) |\n+\n+## Channels\n+\n+Since the supported device is a sensor, both channels are read-only channels. \n+\n+| channel  | type           | description                   |\n+|----------|----------------|-------------------------------|\n+| pm25     | Number:Density | This provides the PM2.5 value |\n+| pm10     | Number:Density | This provides the PM10 value  |\n+\n+## Full Example\n+\n+demo.things:\n+\n+```\n+Thing novafinedust:SDS011:mySDS011Report \"My SDS011 Fine Dust Sensor with reporting\" [ port=\"/dev/ttyUSB0\", reporting=true, reportingInterval=1 ]\n+Thing novafinedust:SDS011:mySDS011Poll \"My SDS011 Fine Dust Sensor with polling\" [ port=\"/dev/ttyUSB0\", reporting=false, pollingInterval=10 ]\n+```\n+\n+demo.items:\n+\n+```\n+Number:Density PM25 \"My PM 2.5 value\" { channel=\"novafinedust:SDS011:mySDS011Report:pm25\" }\n+Number:Density PM10 \"My PM 10 value\" { channel=\"novafinedust:SDS011:mySDS011Report:pm10\" }\n+```\n+\n+demo.sitemap:\n+\n+```\n+sitemap demo label=\"Main Menu\"\n+{\n+    Frame {\n+        Text item=PM25 label=\"My PM 2.5 value\"\n+        Text item=PM10 label=\"My PM 10 value\"\n+    }\n+}\n+```\n+\n+## Limitations\n+\n+In theory once can have multiple sensors connected and distinguish them via their device ID. However, this is currently not implemented and the binding always configures any device and accepts data reportings from any device too.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d94ddb4ba25efe4248d2a174b64f1be2db773484"}, "originalPosition": 78}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjczOTY2OTQ3OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.novafinedust/src/main/resources/ESH-INF/thing/thing-types.xml", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xM1QyMDo0NzoyMlrOGjZUTQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xM1QyMDo0NzoyMlrOGjZUTQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTc2ODE0MQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\t\t\t<label>Reporting If True, Otherwise Polling</label>\n          \n          \n            \n            \t\t\t\t<label>Mode</label>\n          \n          \n            \n            \t\t\t\t<options>\n          \n          \n            \n            \t\t\t\t\t<option value=\"true\">Reporting</option>\n          \n          \n            \n            \t\t\t\t\t<option value=\"false\">Polling</option>\n          \n          \n            \n            \t\t\t\t</options>", "url": "https://github.com/openhab/openhab-addons/pull/7528#discussion_r439768141", "createdAt": "2020-06-13T20:47:22Z", "author": {"login": "kaikreuzer"}, "path": "bundles/org.openhab.binding.novafinedust/src/main/resources/ESH-INF/thing/thing-types.xml", "diffHunk": "@@ -0,0 +1,57 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"novafinedust\"\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\n+\t<thing-type id=\"SDS011\">\n+\t\t<label>Nova SDS011 Fine Dust Sensor</label>\n+\t\t<description>Nova SDS011 Fine Dust Sensor connected via USB</description>\n+\n+\t\t<channels>\n+\t\t\t<channel id=\"pm10\" typeId=\"pm10-type\" />\n+\t\t\t<channel id=\"pm25\" typeId=\"pm25-type\" />\n+\t\t</channels>\n+\n+\t\t<config-description>\n+\t\t\t<parameter name=\"port\" type=\"text\" required=\"true\">\n+\t\t\t\t<context>serial-port</context>\n+\t\t\t\t<label>USB Port</label>\n+\t\t\t\t<description>USB port the device is connected to i.e. /dev/ttyUSB0</description>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"reporting\" type=\"boolean\">\n+\t\t\t\t<default>true</default>\n+\t\t\t\t<label>Reporting If True, Otherwise Polling</label>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d94ddb4ba25efe4248d2a174b64f1be2db773484"}, "originalPosition": 24}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjczOTY2OTk2OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.novafinedust/src/main/resources/ESH-INF/thing/thing-types.xml", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xM1QyMDo0ODoyM1rOGjZUiw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xM1QyMDo0ODoyM1rOGjZUiw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTc2ODIwMw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\t\t\t<label>Time In Minutes When A Value Will Be Reported</label>\n          \n          \n            \n            \t\t\t\t<label>Reporting Interval</label>", "url": "https://github.com/openhab/openhab-addons/pull/7528#discussion_r439768203", "createdAt": "2020-06-13T20:48:23Z", "author": {"login": "kaikreuzer"}, "path": "bundles/org.openhab.binding.novafinedust/src/main/resources/ESH-INF/thing/thing-types.xml", "diffHunk": "@@ -0,0 +1,57 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"novafinedust\"\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\n+\t<thing-type id=\"SDS011\">\n+\t\t<label>Nova SDS011 Fine Dust Sensor</label>\n+\t\t<description>Nova SDS011 Fine Dust Sensor connected via USB</description>\n+\n+\t\t<channels>\n+\t\t\t<channel id=\"pm10\" typeId=\"pm10-type\" />\n+\t\t\t<channel id=\"pm25\" typeId=\"pm25-type\" />\n+\t\t</channels>\n+\n+\t\t<config-description>\n+\t\t\t<parameter name=\"port\" type=\"text\" required=\"true\">\n+\t\t\t\t<context>serial-port</context>\n+\t\t\t\t<label>USB Port</label>\n+\t\t\t\t<description>USB port the device is connected to i.e. /dev/ttyUSB0</description>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"reporting\" type=\"boolean\">\n+\t\t\t\t<default>true</default>\n+\t\t\t\t<label>Reporting If True, Otherwise Polling</label>\n+\t\t\t\t<description>Reporting is strongly recommended to increase sensor lifetime</description>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"reportingInterval\" type=\"integer\" min=\"0\" max=\"30\" unit=\"min\">\n+\t\t\t\t<default>1</default>\n+\t\t\t\t<advanced>true</advanced>\n+\t\t\t\t<label>Time In Minutes When A Value Will Be Reported</label>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d94ddb4ba25efe4248d2a174b64f1be2db773484"}, "originalPosition": 30}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjczOTY2OTk5OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.novafinedust/src/main/resources/ESH-INF/thing/thing-types.xml", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xM1QyMDo0ODozOFrOGjZUkg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xM1QyMDo0ODozOFrOGjZUkg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTc2ODIxMA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\t\t\t<label>Time In Seconds When A Value Will Be Polled From The Device (Min 3 Seconds)</label>\n          \n          \n            \n            \t\t\t\t<label>Polling Interval</label>", "url": "https://github.com/openhab/openhab-addons/pull/7528#discussion_r439768210", "createdAt": "2020-06-13T20:48:38Z", "author": {"login": "kaikreuzer"}, "path": "bundles/org.openhab.binding.novafinedust/src/main/resources/ESH-INF/thing/thing-types.xml", "diffHunk": "@@ -0,0 +1,57 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"novafinedust\"\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\n+\t<thing-type id=\"SDS011\">\n+\t\t<label>Nova SDS011 Fine Dust Sensor</label>\n+\t\t<description>Nova SDS011 Fine Dust Sensor connected via USB</description>\n+\n+\t\t<channels>\n+\t\t\t<channel id=\"pm10\" typeId=\"pm10-type\" />\n+\t\t\t<channel id=\"pm25\" typeId=\"pm25-type\" />\n+\t\t</channels>\n+\n+\t\t<config-description>\n+\t\t\t<parameter name=\"port\" type=\"text\" required=\"true\">\n+\t\t\t\t<context>serial-port</context>\n+\t\t\t\t<label>USB Port</label>\n+\t\t\t\t<description>USB port the device is connected to i.e. /dev/ttyUSB0</description>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"reporting\" type=\"boolean\">\n+\t\t\t\t<default>true</default>\n+\t\t\t\t<label>Reporting If True, Otherwise Polling</label>\n+\t\t\t\t<description>Reporting is strongly recommended to increase sensor lifetime</description>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"reportingInterval\" type=\"integer\" min=\"0\" max=\"30\" unit=\"min\">\n+\t\t\t\t<default>1</default>\n+\t\t\t\t<advanced>true</advanced>\n+\t\t\t\t<label>Time In Minutes When A Value Will Be Reported</label>\n+\t\t\t\t<description>Device will report every x minutes and sleep for x*60 - 30 seconds afterwards, 0 = as fast as possible without sleep</description>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"pollingInterval\" type=\"integer\" min=\"3\" max=\"3600\" unit=\"s\">\n+\t\t\t\t<default>10</default>\n+\t\t\t\t<advanced>true</advanced>\n+\t\t\t\t<label>Time In Seconds When A Value Will Be Polled From The Device (Min 3 Seconds)</label>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d94ddb4ba25efe4248d2a174b64f1be2db773484"}, "originalPosition": 36}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjczOTY3MDA2OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.novafinedust/src/main/resources/ESH-INF/thing/thing-types.xml", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xM1QyMDo0ODo1OFrOGjZUnQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xM1QyMDo0ODo1OFrOGjZUnQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTc2ODIyMQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\t<label>PM10</label>\n          \n          \n            \n            \t\t<label>PM 10</label>", "url": "https://github.com/openhab/openhab-addons/pull/7528#discussion_r439768221", "createdAt": "2020-06-13T20:48:58Z", "author": {"login": "kaikreuzer"}, "path": "bundles/org.openhab.binding.novafinedust/src/main/resources/ESH-INF/thing/thing-types.xml", "diffHunk": "@@ -0,0 +1,57 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"novafinedust\"\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\n+\t<thing-type id=\"SDS011\">\n+\t\t<label>Nova SDS011 Fine Dust Sensor</label>\n+\t\t<description>Nova SDS011 Fine Dust Sensor connected via USB</description>\n+\n+\t\t<channels>\n+\t\t\t<channel id=\"pm10\" typeId=\"pm10-type\" />\n+\t\t\t<channel id=\"pm25\" typeId=\"pm25-type\" />\n+\t\t</channels>\n+\n+\t\t<config-description>\n+\t\t\t<parameter name=\"port\" type=\"text\" required=\"true\">\n+\t\t\t\t<context>serial-port</context>\n+\t\t\t\t<label>USB Port</label>\n+\t\t\t\t<description>USB port the device is connected to i.e. /dev/ttyUSB0</description>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"reporting\" type=\"boolean\">\n+\t\t\t\t<default>true</default>\n+\t\t\t\t<label>Reporting If True, Otherwise Polling</label>\n+\t\t\t\t<description>Reporting is strongly recommended to increase sensor lifetime</description>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"reportingInterval\" type=\"integer\" min=\"0\" max=\"30\" unit=\"min\">\n+\t\t\t\t<default>1</default>\n+\t\t\t\t<advanced>true</advanced>\n+\t\t\t\t<label>Time In Minutes When A Value Will Be Reported</label>\n+\t\t\t\t<description>Device will report every x minutes and sleep for x*60 - 30 seconds afterwards, 0 = as fast as possible without sleep</description>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"pollingInterval\" type=\"integer\" min=\"3\" max=\"3600\" unit=\"s\">\n+\t\t\t\t<default>10</default>\n+\t\t\t\t<advanced>true</advanced>\n+\t\t\t\t<label>Time In Seconds When A Value Will Be Polled From The Device (Min 3 Seconds)</label>\n+\t\t\t\t<description>Device will be polled every x seconds (polling is not recommended)</description>\n+\t\t\t</parameter>\n+\t\t</config-description>\n+\n+\t</thing-type>\n+\n+\t<channel-type id=\"pm25-type\">\n+\t\t<item-type>Number:Density</item-type>\n+\t\t<label>PM 2.5</label>\n+\t\t<description>The PM 2.5 value</description>\n+\t\t<state readOnly=\"true\" pattern=\"%.1f %unit%\"></state>\n+\t</channel-type>\n+\n+\t<channel-type id=\"pm10-type\">\n+\t\t<item-type>Number:Density</item-type>\n+\t\t<label>PM10</label>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d94ddb4ba25efe4248d2a174b64f1be2db773484"}, "originalPosition": 52}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 151, "cost": 1, "resetAt": "2021-11-12T20:44:06Z"}}}