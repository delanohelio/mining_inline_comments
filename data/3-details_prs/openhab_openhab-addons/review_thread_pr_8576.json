{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDkyNzI2MTQ2", "number": 8576, "reviewThreads": {"totalCount": 142, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0xOVQxOTowNjowOVrOFoLdTg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNC0yOVQxNjowNjozOVrOF4XdRg==", "hasNextPage": false, "hasPreviousPage": true}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzc3Njc1MDg2OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/VehicleHandler.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0xOVQxOTowNjowOVrOI6N0ug==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0yMVQxNTozMToxOFrOI6lISQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5NzkxNDgxMA==", "bodyText": "config cannot be null at this point. But the parameters within the config object can be empty.", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r597914810", "createdAt": "2021-03-19T19:06:09Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/VehicleHandler.java", "diffHunk": "@@ -0,0 +1,826 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bmwconnecteddrive.internal.handler;\n+\n+import static org.openhab.binding.bmwconnecteddrive.internal.ConnectedDriveConstants.*;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.bmwconnecteddrive.internal.VehicleConfiguration;\n+import org.openhab.binding.bmwconnecteddrive.internal.action.ChargeProfileActions;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.DestinationContainer;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.NetworkError;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.compat.VehicleAttributesContainer;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.statistics.AllTrips;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.statistics.AllTripsContainer;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.statistics.LastTrip;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.statistics.LastTripContainer;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.status.VehicleStatus;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.status.VehicleStatusContainer;\n+import org.openhab.binding.bmwconnecteddrive.internal.handler.RemoteServiceHandler.ExecutionState;\n+import org.openhab.binding.bmwconnecteddrive.internal.handler.RemoteServiceHandler.RemoteService;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileUtils;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileUtils.ChargeKeyDay;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileUtils.ChargeKeyHour;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileWrapper;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileWrapper.ProfileKey;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Constants;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Converter;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ImageProperties;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.RemoteServiceUtils;\n+import org.openhab.core.io.net.http.HttpUtil;\n+import org.openhab.core.library.types.DecimalType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.RawType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BridgeHandler;\n+import org.openhab.core.thing.binding.ThingHandlerService;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+\n+import com.google.gson.JsonSyntaxException;\n+\n+/**\n+ * The {@link VehicleHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Bernd Weymann - Initial contribution\n+ * @author Norbert Truchsess - edit & send charge profile\n+ */\n+@NonNullByDefault\n+public class VehicleHandler extends VehicleChannelHandler {\n+    private boolean legacyMode = false; // switch to legacy API in case of 404 Errors\n+\n+    private Optional<ConnectedDriveProxy> proxy = Optional.empty();\n+    private Optional<RemoteServiceHandler> remote = Optional.empty();\n+    private Optional<VehicleConfiguration> configuration = Optional.empty();\n+    private Optional<ConnectedDriveBridgeHandler> bridgeHandler = Optional.empty();\n+    private Optional<ScheduledFuture<?>> refreshJob = Optional.empty();\n+    private Optional<ScheduledFuture<?>> editTimeout = Optional.empty();\n+    private Optional<List<ResponseCallback>> callbackCounter = Optional.empty();\n+\n+    private ImageProperties imageProperties = new ImageProperties();\n+    VehicleStatusCallback vehicleStatusCallback = new VehicleStatusCallback();\n+    StringResponseCallback oldVehicleStatusCallback = new LegacyVehicleStatusCallback();\n+    StringResponseCallback lastTripCallback = new LastTripCallback();\n+    StringResponseCallback allTripsCallback = new AllTripsCallback();\n+    StringResponseCallback chargeProfileCallback = new ChargeProfilesCallback();\n+    StringResponseCallback rangeMapCallback = new RangeMapCallback();\n+    DestinationsCallback destinationCallback = new DestinationsCallback();\n+    ByteResponseCallback imageCallback = new ImageCallback();\n+\n+    private Optional<ChargeProfileWrapper> chargeProfileEdit = Optional.empty();\n+    private Optional<String> chargeProfileSent = Optional.empty();\n+\n+    public VehicleHandler(Thing thing, BMWConnectedDriveOptionProvider op, String type, boolean imperial) {\n+        super(thing, op, type, imperial);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        String group = channelUID.getGroupId();\n+\n+        // Refresh of Channels with cached values\n+        if (command instanceof RefreshType) {\n+            if (CHANNEL_GROUP_LAST_TRIP.equals(group)) {\n+                lastTripCache.ifPresent(lastTrip -> lastTripCallback.onResponse(lastTrip));\n+            } else if (CHANNEL_GROUP_LIFETIME.equals(group)) {\n+                allTripsCache.ifPresent(allTrips -> allTripsCallback.onResponse(allTrips));\n+            } else if (CHANNEL_GROUP_DESTINATION.equals(group)) {\n+                destinationCache.ifPresent(destination -> destinationCallback.onResponse(destination));\n+            } else if (CHANNEL_GROUP_STATUS.equals(group)) {\n+                vehicleStatusCache.ifPresent(vehicleStatus -> vehicleStatusCallback.onResponse(vehicleStatus));\n+            } else if (CHANNEL_GROUP_CHARGE.equals(group)) {\n+                chargeProfileEdit.ifPresentOrElse(this::updateChargeProfile,\n+                        () -> chargeProfileCache.ifPresent(this::updateChargeProfileFromContent));\n+            } else if (CHANNEL_GROUP_VEHICLE_IMAGE.equals(group)) {\n+                imageCache.ifPresent(image -> imageCallback.onResponse(image));\n+            }\n+            // Check for Channel Group and corresponding Actions\n+        } else if (CHANNEL_GROUP_REMOTE.equals(group)) {\n+            // Executing Remote Services\n+            if (command instanceof StringType) {\n+                String serviceCommand = ((StringType) command).toFullString();\n+                remote.ifPresent(remot -> {\n+                    switch (serviceCommand) {\n+                        case REMOTE_SERVICE_LIGHT_FLASH:\n+                        case REMOTE_SERVICE_AIR_CONDITIONING:\n+                        case REMOTE_SERVICE_DOOR_LOCK:\n+                        case REMOTE_SERVICE_DOOR_UNLOCK:\n+                        case REMOTE_SERVICE_HORN:\n+                        case REMOTE_SERVICE_VEHICLE_FINDER:\n+                        case REMOTE_SERVICE_CHARGE_NOW:\n+                            RemoteServiceUtils.getRemoteService(serviceCommand)\n+                                    .ifPresentOrElse(service -> remot.execute(service), () -> {\n+                                        logger.info(\"Remote service execution {} unknown\", serviceCommand);\n+                                    });\n+                            break;\n+                        case REMOTE_SERVICE_CHARGING_CONTROL:\n+                            sendChargeProfile(chargeProfileEdit);\n+                            break;\n+                        default:\n+                            logger.info(\"Remote service execution {} unknown\", serviceCommand);\n+                            break;\n+                    }\n+                });\n+            }\n+        } else if (CHANNEL_GROUP_VEHICLE_IMAGE.equals(group)) {\n+            // Image Change\n+            configuration.ifPresent(config -> {\n+                if (command instanceof StringType) {\n+                    if (channelUID.getIdWithoutGroup().equals(IMAGE_VIEWPORT)) {\n+                        String newViewport = command.toString();\n+                        synchronized (imageProperties) {\n+                            if (!imageProperties.viewport.equals(newViewport)) {\n+                                imageProperties = new ImageProperties(newViewport, imageProperties.size);\n+                                imageCache = Optional.empty();\n+                                proxy.ifPresent(prox -> prox.requestImage(config, imageProperties, imageCallback));\n+                            }\n+                        }\n+                        updateChannel(CHANNEL_GROUP_VEHICLE_IMAGE, IMAGE_VIEWPORT, StringType.valueOf(newViewport));\n+                    }\n+                }\n+                if (command instanceof DecimalType) {\n+                    if (command instanceof DecimalType) {\n+                        int newImageSize = ((DecimalType) command).intValue();\n+                        if (channelUID.getIdWithoutGroup().equals(IMAGE_SIZE)) {\n+                            synchronized (imageProperties) {\n+                                if (imageProperties.size != newImageSize) {\n+                                    imageProperties = new ImageProperties(imageProperties.viewport, newImageSize);\n+                                    imageCache = Optional.empty();\n+                                    proxy.ifPresent(prox -> prox.requestImage(config, imageProperties, imageCallback));\n+                                }\n+                            }\n+                        }\n+                        updateChannel(CHANNEL_GROUP_VEHICLE_IMAGE, IMAGE_SIZE, new DecimalType(newImageSize));\n+                    }\n+                }\n+            });\n+        } else if (CHANNEL_GROUP_DESTINATION.equals(group)) {\n+            if (command instanceof StringType) {\n+                int index = Converter.getIndex(command.toFullString());\n+                if (index != -1) {\n+                    selectDestination(index);\n+                } else {\n+                    logger.debug(\"Cannot select Destination index {}\", command.toFullString());\n+                }\n+            }\n+        } else if (CHANNEL_GROUP_SERVICE.equals(group)) {\n+            if (command instanceof StringType) {\n+                int index = Converter.getIndex(command.toFullString());\n+                if (index != -1) {\n+                    selectService(index);\n+                } else {\n+                    logger.debug(\"Cannot select Service index {}\", command.toFullString());\n+                }\n+            }\n+        } else if (CHANNEL_GROUP_CHECK_CONTROL.equals(group)) {\n+            if (command instanceof StringType) {\n+                int index = Converter.getIndex(command.toFullString());\n+                if (index != -1) {\n+                    selectCheckControl(index);\n+                } else {\n+                    logger.debug(\"Cannot select CheckControl index {}\", command.toFullString());\n+                }\n+            }\n+        } else if (CHANNEL_GROUP_CHARGE.equals(group)) {\n+            handleChargeProfileCommand(channelUID, command);\n+        }\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        callbackCounter = Optional.of(new ArrayList<ResponseCallback>());\n+        updateStatus(ThingStatus.UNKNOWN);\n+        final VehicleConfiguration config = getConfigAs(VehicleConfiguration.class);\n+        if (config != null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "48af48c82562d006b6f2aa35922270f181c885ed"}, "originalPosition": 220}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5ODI5NjY0OQ==", "bodyText": "fixed in weymann#10", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r598296649", "createdAt": "2021-03-21T15:31:18Z", "author": {"login": "ntruchsess"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/VehicleHandler.java", "diffHunk": "@@ -0,0 +1,826 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bmwconnecteddrive.internal.handler;\n+\n+import static org.openhab.binding.bmwconnecteddrive.internal.ConnectedDriveConstants.*;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.bmwconnecteddrive.internal.VehicleConfiguration;\n+import org.openhab.binding.bmwconnecteddrive.internal.action.ChargeProfileActions;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.DestinationContainer;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.NetworkError;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.compat.VehicleAttributesContainer;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.statistics.AllTrips;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.statistics.AllTripsContainer;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.statistics.LastTrip;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.statistics.LastTripContainer;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.status.VehicleStatus;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.status.VehicleStatusContainer;\n+import org.openhab.binding.bmwconnecteddrive.internal.handler.RemoteServiceHandler.ExecutionState;\n+import org.openhab.binding.bmwconnecteddrive.internal.handler.RemoteServiceHandler.RemoteService;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileUtils;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileUtils.ChargeKeyDay;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileUtils.ChargeKeyHour;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileWrapper;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileWrapper.ProfileKey;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Constants;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Converter;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ImageProperties;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.RemoteServiceUtils;\n+import org.openhab.core.io.net.http.HttpUtil;\n+import org.openhab.core.library.types.DecimalType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.RawType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BridgeHandler;\n+import org.openhab.core.thing.binding.ThingHandlerService;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+\n+import com.google.gson.JsonSyntaxException;\n+\n+/**\n+ * The {@link VehicleHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Bernd Weymann - Initial contribution\n+ * @author Norbert Truchsess - edit & send charge profile\n+ */\n+@NonNullByDefault\n+public class VehicleHandler extends VehicleChannelHandler {\n+    private boolean legacyMode = false; // switch to legacy API in case of 404 Errors\n+\n+    private Optional<ConnectedDriveProxy> proxy = Optional.empty();\n+    private Optional<RemoteServiceHandler> remote = Optional.empty();\n+    private Optional<VehicleConfiguration> configuration = Optional.empty();\n+    private Optional<ConnectedDriveBridgeHandler> bridgeHandler = Optional.empty();\n+    private Optional<ScheduledFuture<?>> refreshJob = Optional.empty();\n+    private Optional<ScheduledFuture<?>> editTimeout = Optional.empty();\n+    private Optional<List<ResponseCallback>> callbackCounter = Optional.empty();\n+\n+    private ImageProperties imageProperties = new ImageProperties();\n+    VehicleStatusCallback vehicleStatusCallback = new VehicleStatusCallback();\n+    StringResponseCallback oldVehicleStatusCallback = new LegacyVehicleStatusCallback();\n+    StringResponseCallback lastTripCallback = new LastTripCallback();\n+    StringResponseCallback allTripsCallback = new AllTripsCallback();\n+    StringResponseCallback chargeProfileCallback = new ChargeProfilesCallback();\n+    StringResponseCallback rangeMapCallback = new RangeMapCallback();\n+    DestinationsCallback destinationCallback = new DestinationsCallback();\n+    ByteResponseCallback imageCallback = new ImageCallback();\n+\n+    private Optional<ChargeProfileWrapper> chargeProfileEdit = Optional.empty();\n+    private Optional<String> chargeProfileSent = Optional.empty();\n+\n+    public VehicleHandler(Thing thing, BMWConnectedDriveOptionProvider op, String type, boolean imperial) {\n+        super(thing, op, type, imperial);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        String group = channelUID.getGroupId();\n+\n+        // Refresh of Channels with cached values\n+        if (command instanceof RefreshType) {\n+            if (CHANNEL_GROUP_LAST_TRIP.equals(group)) {\n+                lastTripCache.ifPresent(lastTrip -> lastTripCallback.onResponse(lastTrip));\n+            } else if (CHANNEL_GROUP_LIFETIME.equals(group)) {\n+                allTripsCache.ifPresent(allTrips -> allTripsCallback.onResponse(allTrips));\n+            } else if (CHANNEL_GROUP_DESTINATION.equals(group)) {\n+                destinationCache.ifPresent(destination -> destinationCallback.onResponse(destination));\n+            } else if (CHANNEL_GROUP_STATUS.equals(group)) {\n+                vehicleStatusCache.ifPresent(vehicleStatus -> vehicleStatusCallback.onResponse(vehicleStatus));\n+            } else if (CHANNEL_GROUP_CHARGE.equals(group)) {\n+                chargeProfileEdit.ifPresentOrElse(this::updateChargeProfile,\n+                        () -> chargeProfileCache.ifPresent(this::updateChargeProfileFromContent));\n+            } else if (CHANNEL_GROUP_VEHICLE_IMAGE.equals(group)) {\n+                imageCache.ifPresent(image -> imageCallback.onResponse(image));\n+            }\n+            // Check for Channel Group and corresponding Actions\n+        } else if (CHANNEL_GROUP_REMOTE.equals(group)) {\n+            // Executing Remote Services\n+            if (command instanceof StringType) {\n+                String serviceCommand = ((StringType) command).toFullString();\n+                remote.ifPresent(remot -> {\n+                    switch (serviceCommand) {\n+                        case REMOTE_SERVICE_LIGHT_FLASH:\n+                        case REMOTE_SERVICE_AIR_CONDITIONING:\n+                        case REMOTE_SERVICE_DOOR_LOCK:\n+                        case REMOTE_SERVICE_DOOR_UNLOCK:\n+                        case REMOTE_SERVICE_HORN:\n+                        case REMOTE_SERVICE_VEHICLE_FINDER:\n+                        case REMOTE_SERVICE_CHARGE_NOW:\n+                            RemoteServiceUtils.getRemoteService(serviceCommand)\n+                                    .ifPresentOrElse(service -> remot.execute(service), () -> {\n+                                        logger.info(\"Remote service execution {} unknown\", serviceCommand);\n+                                    });\n+                            break;\n+                        case REMOTE_SERVICE_CHARGING_CONTROL:\n+                            sendChargeProfile(chargeProfileEdit);\n+                            break;\n+                        default:\n+                            logger.info(\"Remote service execution {} unknown\", serviceCommand);\n+                            break;\n+                    }\n+                });\n+            }\n+        } else if (CHANNEL_GROUP_VEHICLE_IMAGE.equals(group)) {\n+            // Image Change\n+            configuration.ifPresent(config -> {\n+                if (command instanceof StringType) {\n+                    if (channelUID.getIdWithoutGroup().equals(IMAGE_VIEWPORT)) {\n+                        String newViewport = command.toString();\n+                        synchronized (imageProperties) {\n+                            if (!imageProperties.viewport.equals(newViewport)) {\n+                                imageProperties = new ImageProperties(newViewport, imageProperties.size);\n+                                imageCache = Optional.empty();\n+                                proxy.ifPresent(prox -> prox.requestImage(config, imageProperties, imageCallback));\n+                            }\n+                        }\n+                        updateChannel(CHANNEL_GROUP_VEHICLE_IMAGE, IMAGE_VIEWPORT, StringType.valueOf(newViewport));\n+                    }\n+                }\n+                if (command instanceof DecimalType) {\n+                    if (command instanceof DecimalType) {\n+                        int newImageSize = ((DecimalType) command).intValue();\n+                        if (channelUID.getIdWithoutGroup().equals(IMAGE_SIZE)) {\n+                            synchronized (imageProperties) {\n+                                if (imageProperties.size != newImageSize) {\n+                                    imageProperties = new ImageProperties(imageProperties.viewport, newImageSize);\n+                                    imageCache = Optional.empty();\n+                                    proxy.ifPresent(prox -> prox.requestImage(config, imageProperties, imageCallback));\n+                                }\n+                            }\n+                        }\n+                        updateChannel(CHANNEL_GROUP_VEHICLE_IMAGE, IMAGE_SIZE, new DecimalType(newImageSize));\n+                    }\n+                }\n+            });\n+        } else if (CHANNEL_GROUP_DESTINATION.equals(group)) {\n+            if (command instanceof StringType) {\n+                int index = Converter.getIndex(command.toFullString());\n+                if (index != -1) {\n+                    selectDestination(index);\n+                } else {\n+                    logger.debug(\"Cannot select Destination index {}\", command.toFullString());\n+                }\n+            }\n+        } else if (CHANNEL_GROUP_SERVICE.equals(group)) {\n+            if (command instanceof StringType) {\n+                int index = Converter.getIndex(command.toFullString());\n+                if (index != -1) {\n+                    selectService(index);\n+                } else {\n+                    logger.debug(\"Cannot select Service index {}\", command.toFullString());\n+                }\n+            }\n+        } else if (CHANNEL_GROUP_CHECK_CONTROL.equals(group)) {\n+            if (command instanceof StringType) {\n+                int index = Converter.getIndex(command.toFullString());\n+                if (index != -1) {\n+                    selectCheckControl(index);\n+                } else {\n+                    logger.debug(\"Cannot select CheckControl index {}\", command.toFullString());\n+                }\n+            }\n+        } else if (CHANNEL_GROUP_CHARGE.equals(group)) {\n+            handleChargeProfileCommand(channelUID, command);\n+        }\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        callbackCounter = Optional.of(new ArrayList<ResponseCallback>());\n+        updateStatus(ThingStatus.UNKNOWN);\n+        final VehicleConfiguration config = getConfigAs(VehicleConfiguration.class);\n+        if (config != null) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5NzkxNDgxMA=="}, "originalCommit": {"oid": "48af48c82562d006b6f2aa35922270f181c885ed"}, "originalPosition": 220}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzc3Njc1OTA3OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/VehicleHandler.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0xOVQxOTowODoxNVrOI6N5gw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0yN1QyMTo0Mjo0OVrOI-3ueQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5NzkxNjAzNQ==", "bodyText": "Is there any blocking method in the following code, or what is the reason for executing this asynchronously?", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r597916035", "createdAt": "2021-03-19T19:08:15Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/VehicleHandler.java", "diffHunk": "@@ -0,0 +1,826 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bmwconnecteddrive.internal.handler;\n+\n+import static org.openhab.binding.bmwconnecteddrive.internal.ConnectedDriveConstants.*;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.bmwconnecteddrive.internal.VehicleConfiguration;\n+import org.openhab.binding.bmwconnecteddrive.internal.action.ChargeProfileActions;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.DestinationContainer;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.NetworkError;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.compat.VehicleAttributesContainer;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.statistics.AllTrips;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.statistics.AllTripsContainer;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.statistics.LastTrip;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.statistics.LastTripContainer;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.status.VehicleStatus;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.status.VehicleStatusContainer;\n+import org.openhab.binding.bmwconnecteddrive.internal.handler.RemoteServiceHandler.ExecutionState;\n+import org.openhab.binding.bmwconnecteddrive.internal.handler.RemoteServiceHandler.RemoteService;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileUtils;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileUtils.ChargeKeyDay;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileUtils.ChargeKeyHour;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileWrapper;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileWrapper.ProfileKey;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Constants;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Converter;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ImageProperties;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.RemoteServiceUtils;\n+import org.openhab.core.io.net.http.HttpUtil;\n+import org.openhab.core.library.types.DecimalType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.RawType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BridgeHandler;\n+import org.openhab.core.thing.binding.ThingHandlerService;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+\n+import com.google.gson.JsonSyntaxException;\n+\n+/**\n+ * The {@link VehicleHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Bernd Weymann - Initial contribution\n+ * @author Norbert Truchsess - edit & send charge profile\n+ */\n+@NonNullByDefault\n+public class VehicleHandler extends VehicleChannelHandler {\n+    private boolean legacyMode = false; // switch to legacy API in case of 404 Errors\n+\n+    private Optional<ConnectedDriveProxy> proxy = Optional.empty();\n+    private Optional<RemoteServiceHandler> remote = Optional.empty();\n+    private Optional<VehicleConfiguration> configuration = Optional.empty();\n+    private Optional<ConnectedDriveBridgeHandler> bridgeHandler = Optional.empty();\n+    private Optional<ScheduledFuture<?>> refreshJob = Optional.empty();\n+    private Optional<ScheduledFuture<?>> editTimeout = Optional.empty();\n+    private Optional<List<ResponseCallback>> callbackCounter = Optional.empty();\n+\n+    private ImageProperties imageProperties = new ImageProperties();\n+    VehicleStatusCallback vehicleStatusCallback = new VehicleStatusCallback();\n+    StringResponseCallback oldVehicleStatusCallback = new LegacyVehicleStatusCallback();\n+    StringResponseCallback lastTripCallback = new LastTripCallback();\n+    StringResponseCallback allTripsCallback = new AllTripsCallback();\n+    StringResponseCallback chargeProfileCallback = new ChargeProfilesCallback();\n+    StringResponseCallback rangeMapCallback = new RangeMapCallback();\n+    DestinationsCallback destinationCallback = new DestinationsCallback();\n+    ByteResponseCallback imageCallback = new ImageCallback();\n+\n+    private Optional<ChargeProfileWrapper> chargeProfileEdit = Optional.empty();\n+    private Optional<String> chargeProfileSent = Optional.empty();\n+\n+    public VehicleHandler(Thing thing, BMWConnectedDriveOptionProvider op, String type, boolean imperial) {\n+        super(thing, op, type, imperial);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        String group = channelUID.getGroupId();\n+\n+        // Refresh of Channels with cached values\n+        if (command instanceof RefreshType) {\n+            if (CHANNEL_GROUP_LAST_TRIP.equals(group)) {\n+                lastTripCache.ifPresent(lastTrip -> lastTripCallback.onResponse(lastTrip));\n+            } else if (CHANNEL_GROUP_LIFETIME.equals(group)) {\n+                allTripsCache.ifPresent(allTrips -> allTripsCallback.onResponse(allTrips));\n+            } else if (CHANNEL_GROUP_DESTINATION.equals(group)) {\n+                destinationCache.ifPresent(destination -> destinationCallback.onResponse(destination));\n+            } else if (CHANNEL_GROUP_STATUS.equals(group)) {\n+                vehicleStatusCache.ifPresent(vehicleStatus -> vehicleStatusCallback.onResponse(vehicleStatus));\n+            } else if (CHANNEL_GROUP_CHARGE.equals(group)) {\n+                chargeProfileEdit.ifPresentOrElse(this::updateChargeProfile,\n+                        () -> chargeProfileCache.ifPresent(this::updateChargeProfileFromContent));\n+            } else if (CHANNEL_GROUP_VEHICLE_IMAGE.equals(group)) {\n+                imageCache.ifPresent(image -> imageCallback.onResponse(image));\n+            }\n+            // Check for Channel Group and corresponding Actions\n+        } else if (CHANNEL_GROUP_REMOTE.equals(group)) {\n+            // Executing Remote Services\n+            if (command instanceof StringType) {\n+                String serviceCommand = ((StringType) command).toFullString();\n+                remote.ifPresent(remot -> {\n+                    switch (serviceCommand) {\n+                        case REMOTE_SERVICE_LIGHT_FLASH:\n+                        case REMOTE_SERVICE_AIR_CONDITIONING:\n+                        case REMOTE_SERVICE_DOOR_LOCK:\n+                        case REMOTE_SERVICE_DOOR_UNLOCK:\n+                        case REMOTE_SERVICE_HORN:\n+                        case REMOTE_SERVICE_VEHICLE_FINDER:\n+                        case REMOTE_SERVICE_CHARGE_NOW:\n+                            RemoteServiceUtils.getRemoteService(serviceCommand)\n+                                    .ifPresentOrElse(service -> remot.execute(service), () -> {\n+                                        logger.info(\"Remote service execution {} unknown\", serviceCommand);\n+                                    });\n+                            break;\n+                        case REMOTE_SERVICE_CHARGING_CONTROL:\n+                            sendChargeProfile(chargeProfileEdit);\n+                            break;\n+                        default:\n+                            logger.info(\"Remote service execution {} unknown\", serviceCommand);\n+                            break;\n+                    }\n+                });\n+            }\n+        } else if (CHANNEL_GROUP_VEHICLE_IMAGE.equals(group)) {\n+            // Image Change\n+            configuration.ifPresent(config -> {\n+                if (command instanceof StringType) {\n+                    if (channelUID.getIdWithoutGroup().equals(IMAGE_VIEWPORT)) {\n+                        String newViewport = command.toString();\n+                        synchronized (imageProperties) {\n+                            if (!imageProperties.viewport.equals(newViewport)) {\n+                                imageProperties = new ImageProperties(newViewport, imageProperties.size);\n+                                imageCache = Optional.empty();\n+                                proxy.ifPresent(prox -> prox.requestImage(config, imageProperties, imageCallback));\n+                            }\n+                        }\n+                        updateChannel(CHANNEL_GROUP_VEHICLE_IMAGE, IMAGE_VIEWPORT, StringType.valueOf(newViewport));\n+                    }\n+                }\n+                if (command instanceof DecimalType) {\n+                    if (command instanceof DecimalType) {\n+                        int newImageSize = ((DecimalType) command).intValue();\n+                        if (channelUID.getIdWithoutGroup().equals(IMAGE_SIZE)) {\n+                            synchronized (imageProperties) {\n+                                if (imageProperties.size != newImageSize) {\n+                                    imageProperties = new ImageProperties(imageProperties.viewport, newImageSize);\n+                                    imageCache = Optional.empty();\n+                                    proxy.ifPresent(prox -> prox.requestImage(config, imageProperties, imageCallback));\n+                                }\n+                            }\n+                        }\n+                        updateChannel(CHANNEL_GROUP_VEHICLE_IMAGE, IMAGE_SIZE, new DecimalType(newImageSize));\n+                    }\n+                }\n+            });\n+        } else if (CHANNEL_GROUP_DESTINATION.equals(group)) {\n+            if (command instanceof StringType) {\n+                int index = Converter.getIndex(command.toFullString());\n+                if (index != -1) {\n+                    selectDestination(index);\n+                } else {\n+                    logger.debug(\"Cannot select Destination index {}\", command.toFullString());\n+                }\n+            }\n+        } else if (CHANNEL_GROUP_SERVICE.equals(group)) {\n+            if (command instanceof StringType) {\n+                int index = Converter.getIndex(command.toFullString());\n+                if (index != -1) {\n+                    selectService(index);\n+                } else {\n+                    logger.debug(\"Cannot select Service index {}\", command.toFullString());\n+                }\n+            }\n+        } else if (CHANNEL_GROUP_CHECK_CONTROL.equals(group)) {\n+            if (command instanceof StringType) {\n+                int index = Converter.getIndex(command.toFullString());\n+                if (index != -1) {\n+                    selectCheckControl(index);\n+                } else {\n+                    logger.debug(\"Cannot select CheckControl index {}\", command.toFullString());\n+                }\n+            }\n+        } else if (CHANNEL_GROUP_CHARGE.equals(group)) {\n+            handleChargeProfileCommand(channelUID, command);\n+        }\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        callbackCounter = Optional.of(new ArrayList<ResponseCallback>());\n+        updateStatus(ThingStatus.UNKNOWN);\n+        final VehicleConfiguration config = getConfigAs(VehicleConfiguration.class);\n+        if (config != null) {\n+            configuration = Optional.of(config);\n+            scheduler.execute(() -> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "48af48c82562d006b6f2aa35922270f181c885ed"}, "originalPosition": 222}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMDA0MDc1Nw==", "bodyText": "Not really blocking but quite some code with constructors and initialization is executed and also one critical section inside. Wanted to be sure to execute this asynchronous. But no problem to make it synchronous. Do you have an advice?", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r600040757", "createdAt": "2021-03-23T23:56:53Z", "author": {"login": "weymann"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/VehicleHandler.java", "diffHunk": "@@ -0,0 +1,826 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bmwconnecteddrive.internal.handler;\n+\n+import static org.openhab.binding.bmwconnecteddrive.internal.ConnectedDriveConstants.*;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.bmwconnecteddrive.internal.VehicleConfiguration;\n+import org.openhab.binding.bmwconnecteddrive.internal.action.ChargeProfileActions;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.DestinationContainer;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.NetworkError;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.compat.VehicleAttributesContainer;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.statistics.AllTrips;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.statistics.AllTripsContainer;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.statistics.LastTrip;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.statistics.LastTripContainer;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.status.VehicleStatus;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.status.VehicleStatusContainer;\n+import org.openhab.binding.bmwconnecteddrive.internal.handler.RemoteServiceHandler.ExecutionState;\n+import org.openhab.binding.bmwconnecteddrive.internal.handler.RemoteServiceHandler.RemoteService;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileUtils;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileUtils.ChargeKeyDay;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileUtils.ChargeKeyHour;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileWrapper;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileWrapper.ProfileKey;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Constants;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Converter;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ImageProperties;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.RemoteServiceUtils;\n+import org.openhab.core.io.net.http.HttpUtil;\n+import org.openhab.core.library.types.DecimalType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.RawType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BridgeHandler;\n+import org.openhab.core.thing.binding.ThingHandlerService;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+\n+import com.google.gson.JsonSyntaxException;\n+\n+/**\n+ * The {@link VehicleHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Bernd Weymann - Initial contribution\n+ * @author Norbert Truchsess - edit & send charge profile\n+ */\n+@NonNullByDefault\n+public class VehicleHandler extends VehicleChannelHandler {\n+    private boolean legacyMode = false; // switch to legacy API in case of 404 Errors\n+\n+    private Optional<ConnectedDriveProxy> proxy = Optional.empty();\n+    private Optional<RemoteServiceHandler> remote = Optional.empty();\n+    private Optional<VehicleConfiguration> configuration = Optional.empty();\n+    private Optional<ConnectedDriveBridgeHandler> bridgeHandler = Optional.empty();\n+    private Optional<ScheduledFuture<?>> refreshJob = Optional.empty();\n+    private Optional<ScheduledFuture<?>> editTimeout = Optional.empty();\n+    private Optional<List<ResponseCallback>> callbackCounter = Optional.empty();\n+\n+    private ImageProperties imageProperties = new ImageProperties();\n+    VehicleStatusCallback vehicleStatusCallback = new VehicleStatusCallback();\n+    StringResponseCallback oldVehicleStatusCallback = new LegacyVehicleStatusCallback();\n+    StringResponseCallback lastTripCallback = new LastTripCallback();\n+    StringResponseCallback allTripsCallback = new AllTripsCallback();\n+    StringResponseCallback chargeProfileCallback = new ChargeProfilesCallback();\n+    StringResponseCallback rangeMapCallback = new RangeMapCallback();\n+    DestinationsCallback destinationCallback = new DestinationsCallback();\n+    ByteResponseCallback imageCallback = new ImageCallback();\n+\n+    private Optional<ChargeProfileWrapper> chargeProfileEdit = Optional.empty();\n+    private Optional<String> chargeProfileSent = Optional.empty();\n+\n+    public VehicleHandler(Thing thing, BMWConnectedDriveOptionProvider op, String type, boolean imperial) {\n+        super(thing, op, type, imperial);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        String group = channelUID.getGroupId();\n+\n+        // Refresh of Channels with cached values\n+        if (command instanceof RefreshType) {\n+            if (CHANNEL_GROUP_LAST_TRIP.equals(group)) {\n+                lastTripCache.ifPresent(lastTrip -> lastTripCallback.onResponse(lastTrip));\n+            } else if (CHANNEL_GROUP_LIFETIME.equals(group)) {\n+                allTripsCache.ifPresent(allTrips -> allTripsCallback.onResponse(allTrips));\n+            } else if (CHANNEL_GROUP_DESTINATION.equals(group)) {\n+                destinationCache.ifPresent(destination -> destinationCallback.onResponse(destination));\n+            } else if (CHANNEL_GROUP_STATUS.equals(group)) {\n+                vehicleStatusCache.ifPresent(vehicleStatus -> vehicleStatusCallback.onResponse(vehicleStatus));\n+            } else if (CHANNEL_GROUP_CHARGE.equals(group)) {\n+                chargeProfileEdit.ifPresentOrElse(this::updateChargeProfile,\n+                        () -> chargeProfileCache.ifPresent(this::updateChargeProfileFromContent));\n+            } else if (CHANNEL_GROUP_VEHICLE_IMAGE.equals(group)) {\n+                imageCache.ifPresent(image -> imageCallback.onResponse(image));\n+            }\n+            // Check for Channel Group and corresponding Actions\n+        } else if (CHANNEL_GROUP_REMOTE.equals(group)) {\n+            // Executing Remote Services\n+            if (command instanceof StringType) {\n+                String serviceCommand = ((StringType) command).toFullString();\n+                remote.ifPresent(remot -> {\n+                    switch (serviceCommand) {\n+                        case REMOTE_SERVICE_LIGHT_FLASH:\n+                        case REMOTE_SERVICE_AIR_CONDITIONING:\n+                        case REMOTE_SERVICE_DOOR_LOCK:\n+                        case REMOTE_SERVICE_DOOR_UNLOCK:\n+                        case REMOTE_SERVICE_HORN:\n+                        case REMOTE_SERVICE_VEHICLE_FINDER:\n+                        case REMOTE_SERVICE_CHARGE_NOW:\n+                            RemoteServiceUtils.getRemoteService(serviceCommand)\n+                                    .ifPresentOrElse(service -> remot.execute(service), () -> {\n+                                        logger.info(\"Remote service execution {} unknown\", serviceCommand);\n+                                    });\n+                            break;\n+                        case REMOTE_SERVICE_CHARGING_CONTROL:\n+                            sendChargeProfile(chargeProfileEdit);\n+                            break;\n+                        default:\n+                            logger.info(\"Remote service execution {} unknown\", serviceCommand);\n+                            break;\n+                    }\n+                });\n+            }\n+        } else if (CHANNEL_GROUP_VEHICLE_IMAGE.equals(group)) {\n+            // Image Change\n+            configuration.ifPresent(config -> {\n+                if (command instanceof StringType) {\n+                    if (channelUID.getIdWithoutGroup().equals(IMAGE_VIEWPORT)) {\n+                        String newViewport = command.toString();\n+                        synchronized (imageProperties) {\n+                            if (!imageProperties.viewport.equals(newViewport)) {\n+                                imageProperties = new ImageProperties(newViewport, imageProperties.size);\n+                                imageCache = Optional.empty();\n+                                proxy.ifPresent(prox -> prox.requestImage(config, imageProperties, imageCallback));\n+                            }\n+                        }\n+                        updateChannel(CHANNEL_GROUP_VEHICLE_IMAGE, IMAGE_VIEWPORT, StringType.valueOf(newViewport));\n+                    }\n+                }\n+                if (command instanceof DecimalType) {\n+                    if (command instanceof DecimalType) {\n+                        int newImageSize = ((DecimalType) command).intValue();\n+                        if (channelUID.getIdWithoutGroup().equals(IMAGE_SIZE)) {\n+                            synchronized (imageProperties) {\n+                                if (imageProperties.size != newImageSize) {\n+                                    imageProperties = new ImageProperties(imageProperties.viewport, newImageSize);\n+                                    imageCache = Optional.empty();\n+                                    proxy.ifPresent(prox -> prox.requestImage(config, imageProperties, imageCallback));\n+                                }\n+                            }\n+                        }\n+                        updateChannel(CHANNEL_GROUP_VEHICLE_IMAGE, IMAGE_SIZE, new DecimalType(newImageSize));\n+                    }\n+                }\n+            });\n+        } else if (CHANNEL_GROUP_DESTINATION.equals(group)) {\n+            if (command instanceof StringType) {\n+                int index = Converter.getIndex(command.toFullString());\n+                if (index != -1) {\n+                    selectDestination(index);\n+                } else {\n+                    logger.debug(\"Cannot select Destination index {}\", command.toFullString());\n+                }\n+            }\n+        } else if (CHANNEL_GROUP_SERVICE.equals(group)) {\n+            if (command instanceof StringType) {\n+                int index = Converter.getIndex(command.toFullString());\n+                if (index != -1) {\n+                    selectService(index);\n+                } else {\n+                    logger.debug(\"Cannot select Service index {}\", command.toFullString());\n+                }\n+            }\n+        } else if (CHANNEL_GROUP_CHECK_CONTROL.equals(group)) {\n+            if (command instanceof StringType) {\n+                int index = Converter.getIndex(command.toFullString());\n+                if (index != -1) {\n+                    selectCheckControl(index);\n+                } else {\n+                    logger.debug(\"Cannot select CheckControl index {}\", command.toFullString());\n+                }\n+            }\n+        } else if (CHANNEL_GROUP_CHARGE.equals(group)) {\n+            handleChargeProfileCommand(channelUID, command);\n+        }\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        callbackCounter = Optional.of(new ArrayList<ResponseCallback>());\n+        updateStatus(ThingStatus.UNKNOWN);\n+        final VehicleConfiguration config = getConfigAs(VehicleConfiguration.class);\n+        if (config != null) {\n+            configuration = Optional.of(config);\n+            scheduler.execute(() -> {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5NzkxNjAzNQ=="}, "originalCommit": {"oid": "48af48c82562d006b6f2aa35922270f181c885ed"}, "originalPosition": 222}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMTg2NDI2Nw==", "bodyText": "Constructors and initialization can be executed synchronously. Critical sections cannot be guarded by executing them asynchronously. These should be synchronized.", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r601864267", "createdAt": "2021-03-25T21:54:12Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/VehicleHandler.java", "diffHunk": "@@ -0,0 +1,826 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bmwconnecteddrive.internal.handler;\n+\n+import static org.openhab.binding.bmwconnecteddrive.internal.ConnectedDriveConstants.*;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.bmwconnecteddrive.internal.VehicleConfiguration;\n+import org.openhab.binding.bmwconnecteddrive.internal.action.ChargeProfileActions;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.DestinationContainer;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.NetworkError;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.compat.VehicleAttributesContainer;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.statistics.AllTrips;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.statistics.AllTripsContainer;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.statistics.LastTrip;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.statistics.LastTripContainer;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.status.VehicleStatus;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.status.VehicleStatusContainer;\n+import org.openhab.binding.bmwconnecteddrive.internal.handler.RemoteServiceHandler.ExecutionState;\n+import org.openhab.binding.bmwconnecteddrive.internal.handler.RemoteServiceHandler.RemoteService;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileUtils;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileUtils.ChargeKeyDay;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileUtils.ChargeKeyHour;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileWrapper;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileWrapper.ProfileKey;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Constants;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Converter;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ImageProperties;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.RemoteServiceUtils;\n+import org.openhab.core.io.net.http.HttpUtil;\n+import org.openhab.core.library.types.DecimalType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.RawType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BridgeHandler;\n+import org.openhab.core.thing.binding.ThingHandlerService;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+\n+import com.google.gson.JsonSyntaxException;\n+\n+/**\n+ * The {@link VehicleHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Bernd Weymann - Initial contribution\n+ * @author Norbert Truchsess - edit & send charge profile\n+ */\n+@NonNullByDefault\n+public class VehicleHandler extends VehicleChannelHandler {\n+    private boolean legacyMode = false; // switch to legacy API in case of 404 Errors\n+\n+    private Optional<ConnectedDriveProxy> proxy = Optional.empty();\n+    private Optional<RemoteServiceHandler> remote = Optional.empty();\n+    private Optional<VehicleConfiguration> configuration = Optional.empty();\n+    private Optional<ConnectedDriveBridgeHandler> bridgeHandler = Optional.empty();\n+    private Optional<ScheduledFuture<?>> refreshJob = Optional.empty();\n+    private Optional<ScheduledFuture<?>> editTimeout = Optional.empty();\n+    private Optional<List<ResponseCallback>> callbackCounter = Optional.empty();\n+\n+    private ImageProperties imageProperties = new ImageProperties();\n+    VehicleStatusCallback vehicleStatusCallback = new VehicleStatusCallback();\n+    StringResponseCallback oldVehicleStatusCallback = new LegacyVehicleStatusCallback();\n+    StringResponseCallback lastTripCallback = new LastTripCallback();\n+    StringResponseCallback allTripsCallback = new AllTripsCallback();\n+    StringResponseCallback chargeProfileCallback = new ChargeProfilesCallback();\n+    StringResponseCallback rangeMapCallback = new RangeMapCallback();\n+    DestinationsCallback destinationCallback = new DestinationsCallback();\n+    ByteResponseCallback imageCallback = new ImageCallback();\n+\n+    private Optional<ChargeProfileWrapper> chargeProfileEdit = Optional.empty();\n+    private Optional<String> chargeProfileSent = Optional.empty();\n+\n+    public VehicleHandler(Thing thing, BMWConnectedDriveOptionProvider op, String type, boolean imperial) {\n+        super(thing, op, type, imperial);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        String group = channelUID.getGroupId();\n+\n+        // Refresh of Channels with cached values\n+        if (command instanceof RefreshType) {\n+            if (CHANNEL_GROUP_LAST_TRIP.equals(group)) {\n+                lastTripCache.ifPresent(lastTrip -> lastTripCallback.onResponse(lastTrip));\n+            } else if (CHANNEL_GROUP_LIFETIME.equals(group)) {\n+                allTripsCache.ifPresent(allTrips -> allTripsCallback.onResponse(allTrips));\n+            } else if (CHANNEL_GROUP_DESTINATION.equals(group)) {\n+                destinationCache.ifPresent(destination -> destinationCallback.onResponse(destination));\n+            } else if (CHANNEL_GROUP_STATUS.equals(group)) {\n+                vehicleStatusCache.ifPresent(vehicleStatus -> vehicleStatusCallback.onResponse(vehicleStatus));\n+            } else if (CHANNEL_GROUP_CHARGE.equals(group)) {\n+                chargeProfileEdit.ifPresentOrElse(this::updateChargeProfile,\n+                        () -> chargeProfileCache.ifPresent(this::updateChargeProfileFromContent));\n+            } else if (CHANNEL_GROUP_VEHICLE_IMAGE.equals(group)) {\n+                imageCache.ifPresent(image -> imageCallback.onResponse(image));\n+            }\n+            // Check for Channel Group and corresponding Actions\n+        } else if (CHANNEL_GROUP_REMOTE.equals(group)) {\n+            // Executing Remote Services\n+            if (command instanceof StringType) {\n+                String serviceCommand = ((StringType) command).toFullString();\n+                remote.ifPresent(remot -> {\n+                    switch (serviceCommand) {\n+                        case REMOTE_SERVICE_LIGHT_FLASH:\n+                        case REMOTE_SERVICE_AIR_CONDITIONING:\n+                        case REMOTE_SERVICE_DOOR_LOCK:\n+                        case REMOTE_SERVICE_DOOR_UNLOCK:\n+                        case REMOTE_SERVICE_HORN:\n+                        case REMOTE_SERVICE_VEHICLE_FINDER:\n+                        case REMOTE_SERVICE_CHARGE_NOW:\n+                            RemoteServiceUtils.getRemoteService(serviceCommand)\n+                                    .ifPresentOrElse(service -> remot.execute(service), () -> {\n+                                        logger.info(\"Remote service execution {} unknown\", serviceCommand);\n+                                    });\n+                            break;\n+                        case REMOTE_SERVICE_CHARGING_CONTROL:\n+                            sendChargeProfile(chargeProfileEdit);\n+                            break;\n+                        default:\n+                            logger.info(\"Remote service execution {} unknown\", serviceCommand);\n+                            break;\n+                    }\n+                });\n+            }\n+        } else if (CHANNEL_GROUP_VEHICLE_IMAGE.equals(group)) {\n+            // Image Change\n+            configuration.ifPresent(config -> {\n+                if (command instanceof StringType) {\n+                    if (channelUID.getIdWithoutGroup().equals(IMAGE_VIEWPORT)) {\n+                        String newViewport = command.toString();\n+                        synchronized (imageProperties) {\n+                            if (!imageProperties.viewport.equals(newViewport)) {\n+                                imageProperties = new ImageProperties(newViewport, imageProperties.size);\n+                                imageCache = Optional.empty();\n+                                proxy.ifPresent(prox -> prox.requestImage(config, imageProperties, imageCallback));\n+                            }\n+                        }\n+                        updateChannel(CHANNEL_GROUP_VEHICLE_IMAGE, IMAGE_VIEWPORT, StringType.valueOf(newViewport));\n+                    }\n+                }\n+                if (command instanceof DecimalType) {\n+                    if (command instanceof DecimalType) {\n+                        int newImageSize = ((DecimalType) command).intValue();\n+                        if (channelUID.getIdWithoutGroup().equals(IMAGE_SIZE)) {\n+                            synchronized (imageProperties) {\n+                                if (imageProperties.size != newImageSize) {\n+                                    imageProperties = new ImageProperties(imageProperties.viewport, newImageSize);\n+                                    imageCache = Optional.empty();\n+                                    proxy.ifPresent(prox -> prox.requestImage(config, imageProperties, imageCallback));\n+                                }\n+                            }\n+                        }\n+                        updateChannel(CHANNEL_GROUP_VEHICLE_IMAGE, IMAGE_SIZE, new DecimalType(newImageSize));\n+                    }\n+                }\n+            });\n+        } else if (CHANNEL_GROUP_DESTINATION.equals(group)) {\n+            if (command instanceof StringType) {\n+                int index = Converter.getIndex(command.toFullString());\n+                if (index != -1) {\n+                    selectDestination(index);\n+                } else {\n+                    logger.debug(\"Cannot select Destination index {}\", command.toFullString());\n+                }\n+            }\n+        } else if (CHANNEL_GROUP_SERVICE.equals(group)) {\n+            if (command instanceof StringType) {\n+                int index = Converter.getIndex(command.toFullString());\n+                if (index != -1) {\n+                    selectService(index);\n+                } else {\n+                    logger.debug(\"Cannot select Service index {}\", command.toFullString());\n+                }\n+            }\n+        } else if (CHANNEL_GROUP_CHECK_CONTROL.equals(group)) {\n+            if (command instanceof StringType) {\n+                int index = Converter.getIndex(command.toFullString());\n+                if (index != -1) {\n+                    selectCheckControl(index);\n+                } else {\n+                    logger.debug(\"Cannot select CheckControl index {}\", command.toFullString());\n+                }\n+            }\n+        } else if (CHANNEL_GROUP_CHARGE.equals(group)) {\n+            handleChargeProfileCommand(channelUID, command);\n+        }\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        callbackCounter = Optional.of(new ArrayList<ResponseCallback>());\n+        updateStatus(ThingStatus.UNKNOWN);\n+        final VehicleConfiguration config = getConfigAs(VehicleConfiguration.class);\n+        if (config != null) {\n+            configuration = Optional.of(config);\n+            scheduler.execute(() -> {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5NzkxNjAzNQ=="}, "originalCommit": {"oid": "48af48c82562d006b6f2aa35922270f181c885ed"}, "originalPosition": 222}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMjc5NTY0MQ==", "bodyText": "Ok, critical section is already synchronized - asnyc execution just in case if it's blocked so I don't want to delay other initializations. But seems acceptable so I'll remoce async init.", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r602795641", "createdAt": "2021-03-27T21:42:49Z", "author": {"login": "weymann"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/VehicleHandler.java", "diffHunk": "@@ -0,0 +1,826 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bmwconnecteddrive.internal.handler;\n+\n+import static org.openhab.binding.bmwconnecteddrive.internal.ConnectedDriveConstants.*;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.bmwconnecteddrive.internal.VehicleConfiguration;\n+import org.openhab.binding.bmwconnecteddrive.internal.action.ChargeProfileActions;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.DestinationContainer;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.NetworkError;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.compat.VehicleAttributesContainer;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.statistics.AllTrips;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.statistics.AllTripsContainer;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.statistics.LastTrip;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.statistics.LastTripContainer;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.status.VehicleStatus;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.status.VehicleStatusContainer;\n+import org.openhab.binding.bmwconnecteddrive.internal.handler.RemoteServiceHandler.ExecutionState;\n+import org.openhab.binding.bmwconnecteddrive.internal.handler.RemoteServiceHandler.RemoteService;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileUtils;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileUtils.ChargeKeyDay;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileUtils.ChargeKeyHour;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileWrapper;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileWrapper.ProfileKey;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Constants;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Converter;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ImageProperties;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.RemoteServiceUtils;\n+import org.openhab.core.io.net.http.HttpUtil;\n+import org.openhab.core.library.types.DecimalType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.RawType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BridgeHandler;\n+import org.openhab.core.thing.binding.ThingHandlerService;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+\n+import com.google.gson.JsonSyntaxException;\n+\n+/**\n+ * The {@link VehicleHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Bernd Weymann - Initial contribution\n+ * @author Norbert Truchsess - edit & send charge profile\n+ */\n+@NonNullByDefault\n+public class VehicleHandler extends VehicleChannelHandler {\n+    private boolean legacyMode = false; // switch to legacy API in case of 404 Errors\n+\n+    private Optional<ConnectedDriveProxy> proxy = Optional.empty();\n+    private Optional<RemoteServiceHandler> remote = Optional.empty();\n+    private Optional<VehicleConfiguration> configuration = Optional.empty();\n+    private Optional<ConnectedDriveBridgeHandler> bridgeHandler = Optional.empty();\n+    private Optional<ScheduledFuture<?>> refreshJob = Optional.empty();\n+    private Optional<ScheduledFuture<?>> editTimeout = Optional.empty();\n+    private Optional<List<ResponseCallback>> callbackCounter = Optional.empty();\n+\n+    private ImageProperties imageProperties = new ImageProperties();\n+    VehicleStatusCallback vehicleStatusCallback = new VehicleStatusCallback();\n+    StringResponseCallback oldVehicleStatusCallback = new LegacyVehicleStatusCallback();\n+    StringResponseCallback lastTripCallback = new LastTripCallback();\n+    StringResponseCallback allTripsCallback = new AllTripsCallback();\n+    StringResponseCallback chargeProfileCallback = new ChargeProfilesCallback();\n+    StringResponseCallback rangeMapCallback = new RangeMapCallback();\n+    DestinationsCallback destinationCallback = new DestinationsCallback();\n+    ByteResponseCallback imageCallback = new ImageCallback();\n+\n+    private Optional<ChargeProfileWrapper> chargeProfileEdit = Optional.empty();\n+    private Optional<String> chargeProfileSent = Optional.empty();\n+\n+    public VehicleHandler(Thing thing, BMWConnectedDriveOptionProvider op, String type, boolean imperial) {\n+        super(thing, op, type, imperial);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        String group = channelUID.getGroupId();\n+\n+        // Refresh of Channels with cached values\n+        if (command instanceof RefreshType) {\n+            if (CHANNEL_GROUP_LAST_TRIP.equals(group)) {\n+                lastTripCache.ifPresent(lastTrip -> lastTripCallback.onResponse(lastTrip));\n+            } else if (CHANNEL_GROUP_LIFETIME.equals(group)) {\n+                allTripsCache.ifPresent(allTrips -> allTripsCallback.onResponse(allTrips));\n+            } else if (CHANNEL_GROUP_DESTINATION.equals(group)) {\n+                destinationCache.ifPresent(destination -> destinationCallback.onResponse(destination));\n+            } else if (CHANNEL_GROUP_STATUS.equals(group)) {\n+                vehicleStatusCache.ifPresent(vehicleStatus -> vehicleStatusCallback.onResponse(vehicleStatus));\n+            } else if (CHANNEL_GROUP_CHARGE.equals(group)) {\n+                chargeProfileEdit.ifPresentOrElse(this::updateChargeProfile,\n+                        () -> chargeProfileCache.ifPresent(this::updateChargeProfileFromContent));\n+            } else if (CHANNEL_GROUP_VEHICLE_IMAGE.equals(group)) {\n+                imageCache.ifPresent(image -> imageCallback.onResponse(image));\n+            }\n+            // Check for Channel Group and corresponding Actions\n+        } else if (CHANNEL_GROUP_REMOTE.equals(group)) {\n+            // Executing Remote Services\n+            if (command instanceof StringType) {\n+                String serviceCommand = ((StringType) command).toFullString();\n+                remote.ifPresent(remot -> {\n+                    switch (serviceCommand) {\n+                        case REMOTE_SERVICE_LIGHT_FLASH:\n+                        case REMOTE_SERVICE_AIR_CONDITIONING:\n+                        case REMOTE_SERVICE_DOOR_LOCK:\n+                        case REMOTE_SERVICE_DOOR_UNLOCK:\n+                        case REMOTE_SERVICE_HORN:\n+                        case REMOTE_SERVICE_VEHICLE_FINDER:\n+                        case REMOTE_SERVICE_CHARGE_NOW:\n+                            RemoteServiceUtils.getRemoteService(serviceCommand)\n+                                    .ifPresentOrElse(service -> remot.execute(service), () -> {\n+                                        logger.info(\"Remote service execution {} unknown\", serviceCommand);\n+                                    });\n+                            break;\n+                        case REMOTE_SERVICE_CHARGING_CONTROL:\n+                            sendChargeProfile(chargeProfileEdit);\n+                            break;\n+                        default:\n+                            logger.info(\"Remote service execution {} unknown\", serviceCommand);\n+                            break;\n+                    }\n+                });\n+            }\n+        } else if (CHANNEL_GROUP_VEHICLE_IMAGE.equals(group)) {\n+            // Image Change\n+            configuration.ifPresent(config -> {\n+                if (command instanceof StringType) {\n+                    if (channelUID.getIdWithoutGroup().equals(IMAGE_VIEWPORT)) {\n+                        String newViewport = command.toString();\n+                        synchronized (imageProperties) {\n+                            if (!imageProperties.viewport.equals(newViewport)) {\n+                                imageProperties = new ImageProperties(newViewport, imageProperties.size);\n+                                imageCache = Optional.empty();\n+                                proxy.ifPresent(prox -> prox.requestImage(config, imageProperties, imageCallback));\n+                            }\n+                        }\n+                        updateChannel(CHANNEL_GROUP_VEHICLE_IMAGE, IMAGE_VIEWPORT, StringType.valueOf(newViewport));\n+                    }\n+                }\n+                if (command instanceof DecimalType) {\n+                    if (command instanceof DecimalType) {\n+                        int newImageSize = ((DecimalType) command).intValue();\n+                        if (channelUID.getIdWithoutGroup().equals(IMAGE_SIZE)) {\n+                            synchronized (imageProperties) {\n+                                if (imageProperties.size != newImageSize) {\n+                                    imageProperties = new ImageProperties(imageProperties.viewport, newImageSize);\n+                                    imageCache = Optional.empty();\n+                                    proxy.ifPresent(prox -> prox.requestImage(config, imageProperties, imageCallback));\n+                                }\n+                            }\n+                        }\n+                        updateChannel(CHANNEL_GROUP_VEHICLE_IMAGE, IMAGE_SIZE, new DecimalType(newImageSize));\n+                    }\n+                }\n+            });\n+        } else if (CHANNEL_GROUP_DESTINATION.equals(group)) {\n+            if (command instanceof StringType) {\n+                int index = Converter.getIndex(command.toFullString());\n+                if (index != -1) {\n+                    selectDestination(index);\n+                } else {\n+                    logger.debug(\"Cannot select Destination index {}\", command.toFullString());\n+                }\n+            }\n+        } else if (CHANNEL_GROUP_SERVICE.equals(group)) {\n+            if (command instanceof StringType) {\n+                int index = Converter.getIndex(command.toFullString());\n+                if (index != -1) {\n+                    selectService(index);\n+                } else {\n+                    logger.debug(\"Cannot select Service index {}\", command.toFullString());\n+                }\n+            }\n+        } else if (CHANNEL_GROUP_CHECK_CONTROL.equals(group)) {\n+            if (command instanceof StringType) {\n+                int index = Converter.getIndex(command.toFullString());\n+                if (index != -1) {\n+                    selectCheckControl(index);\n+                } else {\n+                    logger.debug(\"Cannot select CheckControl index {}\", command.toFullString());\n+                }\n+            }\n+        } else if (CHANNEL_GROUP_CHARGE.equals(group)) {\n+            handleChargeProfileCommand(channelUID, command);\n+        }\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        callbackCounter = Optional.of(new ArrayList<ResponseCallback>());\n+        updateStatus(ThingStatus.UNKNOWN);\n+        final VehicleConfiguration config = getConfigAs(VehicleConfiguration.class);\n+        if (config != null) {\n+            configuration = Optional.of(config);\n+            scheduler.execute(() -> {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5NzkxNjAzNQ=="}, "originalCommit": {"oid": "48af48c82562d006b6f2aa35922270f181c885ed"}, "originalPosition": 222}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzc3Njc3MTQ0OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/VehicleHandler.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0xOVQxOToxMjowOFrOI6OBDQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0yNFQwMDowMzo0OVrOI8Pu-A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5NzkxNzk2NQ==", "bodyText": "You could remove the binding name from the log message as the package name is already logged.", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r597917965", "createdAt": "2021-03-19T19:12:08Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/VehicleHandler.java", "diffHunk": "@@ -0,0 +1,826 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bmwconnecteddrive.internal.handler;\n+\n+import static org.openhab.binding.bmwconnecteddrive.internal.ConnectedDriveConstants.*;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.bmwconnecteddrive.internal.VehicleConfiguration;\n+import org.openhab.binding.bmwconnecteddrive.internal.action.ChargeProfileActions;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.DestinationContainer;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.NetworkError;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.compat.VehicleAttributesContainer;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.statistics.AllTrips;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.statistics.AllTripsContainer;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.statistics.LastTrip;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.statistics.LastTripContainer;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.status.VehicleStatus;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.status.VehicleStatusContainer;\n+import org.openhab.binding.bmwconnecteddrive.internal.handler.RemoteServiceHandler.ExecutionState;\n+import org.openhab.binding.bmwconnecteddrive.internal.handler.RemoteServiceHandler.RemoteService;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileUtils;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileUtils.ChargeKeyDay;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileUtils.ChargeKeyHour;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileWrapper;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileWrapper.ProfileKey;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Constants;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Converter;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ImageProperties;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.RemoteServiceUtils;\n+import org.openhab.core.io.net.http.HttpUtil;\n+import org.openhab.core.library.types.DecimalType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.RawType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BridgeHandler;\n+import org.openhab.core.thing.binding.ThingHandlerService;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+\n+import com.google.gson.JsonSyntaxException;\n+\n+/**\n+ * The {@link VehicleHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Bernd Weymann - Initial contribution\n+ * @author Norbert Truchsess - edit & send charge profile\n+ */\n+@NonNullByDefault\n+public class VehicleHandler extends VehicleChannelHandler {\n+    private boolean legacyMode = false; // switch to legacy API in case of 404 Errors\n+\n+    private Optional<ConnectedDriveProxy> proxy = Optional.empty();\n+    private Optional<RemoteServiceHandler> remote = Optional.empty();\n+    private Optional<VehicleConfiguration> configuration = Optional.empty();\n+    private Optional<ConnectedDriveBridgeHandler> bridgeHandler = Optional.empty();\n+    private Optional<ScheduledFuture<?>> refreshJob = Optional.empty();\n+    private Optional<ScheduledFuture<?>> editTimeout = Optional.empty();\n+    private Optional<List<ResponseCallback>> callbackCounter = Optional.empty();\n+\n+    private ImageProperties imageProperties = new ImageProperties();\n+    VehicleStatusCallback vehicleStatusCallback = new VehicleStatusCallback();\n+    StringResponseCallback oldVehicleStatusCallback = new LegacyVehicleStatusCallback();\n+    StringResponseCallback lastTripCallback = new LastTripCallback();\n+    StringResponseCallback allTripsCallback = new AllTripsCallback();\n+    StringResponseCallback chargeProfileCallback = new ChargeProfilesCallback();\n+    StringResponseCallback rangeMapCallback = new RangeMapCallback();\n+    DestinationsCallback destinationCallback = new DestinationsCallback();\n+    ByteResponseCallback imageCallback = new ImageCallback();\n+\n+    private Optional<ChargeProfileWrapper> chargeProfileEdit = Optional.empty();\n+    private Optional<String> chargeProfileSent = Optional.empty();\n+\n+    public VehicleHandler(Thing thing, BMWConnectedDriveOptionProvider op, String type, boolean imperial) {\n+        super(thing, op, type, imperial);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        String group = channelUID.getGroupId();\n+\n+        // Refresh of Channels with cached values\n+        if (command instanceof RefreshType) {\n+            if (CHANNEL_GROUP_LAST_TRIP.equals(group)) {\n+                lastTripCache.ifPresent(lastTrip -> lastTripCallback.onResponse(lastTrip));\n+            } else if (CHANNEL_GROUP_LIFETIME.equals(group)) {\n+                allTripsCache.ifPresent(allTrips -> allTripsCallback.onResponse(allTrips));\n+            } else if (CHANNEL_GROUP_DESTINATION.equals(group)) {\n+                destinationCache.ifPresent(destination -> destinationCallback.onResponse(destination));\n+            } else if (CHANNEL_GROUP_STATUS.equals(group)) {\n+                vehicleStatusCache.ifPresent(vehicleStatus -> vehicleStatusCallback.onResponse(vehicleStatus));\n+            } else if (CHANNEL_GROUP_CHARGE.equals(group)) {\n+                chargeProfileEdit.ifPresentOrElse(this::updateChargeProfile,\n+                        () -> chargeProfileCache.ifPresent(this::updateChargeProfileFromContent));\n+            } else if (CHANNEL_GROUP_VEHICLE_IMAGE.equals(group)) {\n+                imageCache.ifPresent(image -> imageCallback.onResponse(image));\n+            }\n+            // Check for Channel Group and corresponding Actions\n+        } else if (CHANNEL_GROUP_REMOTE.equals(group)) {\n+            // Executing Remote Services\n+            if (command instanceof StringType) {\n+                String serviceCommand = ((StringType) command).toFullString();\n+                remote.ifPresent(remot -> {\n+                    switch (serviceCommand) {\n+                        case REMOTE_SERVICE_LIGHT_FLASH:\n+                        case REMOTE_SERVICE_AIR_CONDITIONING:\n+                        case REMOTE_SERVICE_DOOR_LOCK:\n+                        case REMOTE_SERVICE_DOOR_UNLOCK:\n+                        case REMOTE_SERVICE_HORN:\n+                        case REMOTE_SERVICE_VEHICLE_FINDER:\n+                        case REMOTE_SERVICE_CHARGE_NOW:\n+                            RemoteServiceUtils.getRemoteService(serviceCommand)\n+                                    .ifPresentOrElse(service -> remot.execute(service), () -> {\n+                                        logger.info(\"Remote service execution {} unknown\", serviceCommand);\n+                                    });\n+                            break;\n+                        case REMOTE_SERVICE_CHARGING_CONTROL:\n+                            sendChargeProfile(chargeProfileEdit);\n+                            break;\n+                        default:\n+                            logger.info(\"Remote service execution {} unknown\", serviceCommand);\n+                            break;\n+                    }\n+                });\n+            }\n+        } else if (CHANNEL_GROUP_VEHICLE_IMAGE.equals(group)) {\n+            // Image Change\n+            configuration.ifPresent(config -> {\n+                if (command instanceof StringType) {\n+                    if (channelUID.getIdWithoutGroup().equals(IMAGE_VIEWPORT)) {\n+                        String newViewport = command.toString();\n+                        synchronized (imageProperties) {\n+                            if (!imageProperties.viewport.equals(newViewport)) {\n+                                imageProperties = new ImageProperties(newViewport, imageProperties.size);\n+                                imageCache = Optional.empty();\n+                                proxy.ifPresent(prox -> prox.requestImage(config, imageProperties, imageCallback));\n+                            }\n+                        }\n+                        updateChannel(CHANNEL_GROUP_VEHICLE_IMAGE, IMAGE_VIEWPORT, StringType.valueOf(newViewport));\n+                    }\n+                }\n+                if (command instanceof DecimalType) {\n+                    if (command instanceof DecimalType) {\n+                        int newImageSize = ((DecimalType) command).intValue();\n+                        if (channelUID.getIdWithoutGroup().equals(IMAGE_SIZE)) {\n+                            synchronized (imageProperties) {\n+                                if (imageProperties.size != newImageSize) {\n+                                    imageProperties = new ImageProperties(imageProperties.viewport, newImageSize);\n+                                    imageCache = Optional.empty();\n+                                    proxy.ifPresent(prox -> prox.requestImage(config, imageProperties, imageCallback));\n+                                }\n+                            }\n+                        }\n+                        updateChannel(CHANNEL_GROUP_VEHICLE_IMAGE, IMAGE_SIZE, new DecimalType(newImageSize));\n+                    }\n+                }\n+            });\n+        } else if (CHANNEL_GROUP_DESTINATION.equals(group)) {\n+            if (command instanceof StringType) {\n+                int index = Converter.getIndex(command.toFullString());\n+                if (index != -1) {\n+                    selectDestination(index);\n+                } else {\n+                    logger.debug(\"Cannot select Destination index {}\", command.toFullString());\n+                }\n+            }\n+        } else if (CHANNEL_GROUP_SERVICE.equals(group)) {\n+            if (command instanceof StringType) {\n+                int index = Converter.getIndex(command.toFullString());\n+                if (index != -1) {\n+                    selectService(index);\n+                } else {\n+                    logger.debug(\"Cannot select Service index {}\", command.toFullString());\n+                }\n+            }\n+        } else if (CHANNEL_GROUP_CHECK_CONTROL.equals(group)) {\n+            if (command instanceof StringType) {\n+                int index = Converter.getIndex(command.toFullString());\n+                if (index != -1) {\n+                    selectCheckControl(index);\n+                } else {\n+                    logger.debug(\"Cannot select CheckControl index {}\", command.toFullString());\n+                }\n+            }\n+        } else if (CHANNEL_GROUP_CHARGE.equals(group)) {\n+            handleChargeProfileCommand(channelUID, command);\n+        }\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        callbackCounter = Optional.of(new ArrayList<ResponseCallback>());\n+        updateStatus(ThingStatus.UNKNOWN);\n+        final VehicleConfiguration config = getConfigAs(VehicleConfiguration.class);\n+        if (config != null) {\n+            configuration = Optional.of(config);\n+            scheduler.execute(() -> {\n+                Bridge bridge = getBridge();\n+                if (bridge != null) {\n+                    BridgeHandler handler = bridge.getHandler();\n+                    if (handler != null) {\n+                        bridgeHandler = Optional.of(((ConnectedDriveBridgeHandler) handler));\n+                        proxy = ((ConnectedDriveBridgeHandler) handler).getProxy();\n+                        remote = proxy.map(prox -> prox.getRemoteServiceHandler(this));\n+                    } else {\n+                        logger.debug(\"Bridge Handler null\");\n+                    }\n+                } else {\n+                    logger.debug(\"Bridge null\");\n+                }\n+\n+                // get Image after init with config values\n+                synchronized (imageProperties) {\n+                    imageProperties = new ImageProperties(config.imageViewport, config.imageSize);\n+                }\n+                updateChannel(CHANNEL_GROUP_VEHICLE_IMAGE, IMAGE_VIEWPORT, StringType.valueOf((config.imageViewport)));\n+                updateChannel(CHANNEL_GROUP_VEHICLE_IMAGE, IMAGE_SIZE, new DecimalType((config.imageSize)));\n+\n+                // check imperial setting is different to AutoDetect\n+                if (!UNITS_AUTODETECT.equals(config.units)) {\n+                    imperial = UNITS_IMPERIAL.equals(config.units);\n+                }\n+\n+                // start update schedule\n+                startSchedule(config.refreshInterval);\n+            });\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR);\n+        }\n+    }\n+\n+    private void startSchedule(int interval) {\n+        refreshJob.ifPresentOrElse(job -> {\n+            if (job.isCancelled()) {\n+                refreshJob = Optional\n+                        .of(scheduler.scheduleWithFixedDelay(this::getData, 0, interval, TimeUnit.MINUTES));\n+            } // else - scheduler is already running!\n+        }, () -> {\n+            refreshJob = Optional.of(scheduler.scheduleWithFixedDelay(this::getData, 0, interval, TimeUnit.MINUTES));\n+        });\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        refreshJob.ifPresent(job -> job.cancel(true));\n+    }\n+\n+    public void getData() {\n+        proxy.ifPresentOrElse(prox -> {\n+            configuration.ifPresentOrElse(config -> {\n+                if (!legacyMode) {\n+                    prox.requestVehcileStatus(config, vehicleStatusCallback);\n+                } else {\n+                    prox.requestLegacyVehcileStatus(config, oldVehicleStatusCallback);\n+                }\n+                addCallback(vehicleStatusCallback);\n+                if (isSupported(Constants.STATISTICS)) {\n+                    prox.requestLastTrip(config, lastTripCallback);\n+                    prox.requestAllTrips(config, allTripsCallback);\n+                    addCallback(lastTripCallback);\n+                    addCallback(allTripsCallback);\n+                }\n+                if (isSupported(Constants.LAST_DESTINATIONS)) {\n+                    prox.requestDestinations(config, destinationCallback);\n+                    addCallback(destinationCallback);\n+                }\n+                if (isElectric) {\n+                    prox.requestChargingProfile(config, chargeProfileCallback);\n+                    addCallback(chargeProfileCallback);\n+                }\n+                synchronized (imageProperties) {\n+                    if (!imageCache.isPresent() && !imageProperties.failLimitReached()) {\n+                        prox.requestImage(config, imageProperties, imageCallback);\n+                        addCallback(imageCallback);\n+                    }\n+                }\n+            }, () -> {\n+                logger.warn(\"ConnectedDrive Configuration isn't present\");\n+            });\n+        }, () -> {\n+            logger.warn(\"ConnectedDrive Proxy isn't present\");\n+        });\n+    }\n+\n+    private synchronized void addCallback(ResponseCallback rc) {\n+        callbackCounter.ifPresent(counter -> counter.add(rc));\n+    }\n+\n+    private synchronized void removeCallback(ResponseCallback rc) {\n+        callbackCounter.ifPresent(counter -> {\n+            counter.remove(rc);\n+            // all necessary callbacks received => print and set to empty\n+            if (counter.isEmpty()) {\n+                logFingerPrint();\n+                callbackCounter = Optional.empty();\n+            }\n+        });\n+    }\n+\n+    private void logFingerPrint() {\n+        final String vin = configuration.map(config -> config.vin).orElse(\"\");\n+        logger.debug(\"###### BMW ConnectedDrive Binding - Vehicle Troubleshoot Fingerprint Data - BEGIN ######\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "48af48c82562d006b6f2aa35922270f181c885ed"}, "originalPosition": 327}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMDA0MzI1Ng==", "bodyText": "Removed", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r600043256", "createdAt": "2021-03-24T00:03:49Z", "author": {"login": "weymann"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/VehicleHandler.java", "diffHunk": "@@ -0,0 +1,826 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bmwconnecteddrive.internal.handler;\n+\n+import static org.openhab.binding.bmwconnecteddrive.internal.ConnectedDriveConstants.*;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.bmwconnecteddrive.internal.VehicleConfiguration;\n+import org.openhab.binding.bmwconnecteddrive.internal.action.ChargeProfileActions;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.DestinationContainer;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.NetworkError;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.compat.VehicleAttributesContainer;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.statistics.AllTrips;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.statistics.AllTripsContainer;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.statistics.LastTrip;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.statistics.LastTripContainer;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.status.VehicleStatus;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.status.VehicleStatusContainer;\n+import org.openhab.binding.bmwconnecteddrive.internal.handler.RemoteServiceHandler.ExecutionState;\n+import org.openhab.binding.bmwconnecteddrive.internal.handler.RemoteServiceHandler.RemoteService;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileUtils;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileUtils.ChargeKeyDay;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileUtils.ChargeKeyHour;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileWrapper;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileWrapper.ProfileKey;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Constants;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Converter;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ImageProperties;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.RemoteServiceUtils;\n+import org.openhab.core.io.net.http.HttpUtil;\n+import org.openhab.core.library.types.DecimalType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.RawType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BridgeHandler;\n+import org.openhab.core.thing.binding.ThingHandlerService;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+\n+import com.google.gson.JsonSyntaxException;\n+\n+/**\n+ * The {@link VehicleHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Bernd Weymann - Initial contribution\n+ * @author Norbert Truchsess - edit & send charge profile\n+ */\n+@NonNullByDefault\n+public class VehicleHandler extends VehicleChannelHandler {\n+    private boolean legacyMode = false; // switch to legacy API in case of 404 Errors\n+\n+    private Optional<ConnectedDriveProxy> proxy = Optional.empty();\n+    private Optional<RemoteServiceHandler> remote = Optional.empty();\n+    private Optional<VehicleConfiguration> configuration = Optional.empty();\n+    private Optional<ConnectedDriveBridgeHandler> bridgeHandler = Optional.empty();\n+    private Optional<ScheduledFuture<?>> refreshJob = Optional.empty();\n+    private Optional<ScheduledFuture<?>> editTimeout = Optional.empty();\n+    private Optional<List<ResponseCallback>> callbackCounter = Optional.empty();\n+\n+    private ImageProperties imageProperties = new ImageProperties();\n+    VehicleStatusCallback vehicleStatusCallback = new VehicleStatusCallback();\n+    StringResponseCallback oldVehicleStatusCallback = new LegacyVehicleStatusCallback();\n+    StringResponseCallback lastTripCallback = new LastTripCallback();\n+    StringResponseCallback allTripsCallback = new AllTripsCallback();\n+    StringResponseCallback chargeProfileCallback = new ChargeProfilesCallback();\n+    StringResponseCallback rangeMapCallback = new RangeMapCallback();\n+    DestinationsCallback destinationCallback = new DestinationsCallback();\n+    ByteResponseCallback imageCallback = new ImageCallback();\n+\n+    private Optional<ChargeProfileWrapper> chargeProfileEdit = Optional.empty();\n+    private Optional<String> chargeProfileSent = Optional.empty();\n+\n+    public VehicleHandler(Thing thing, BMWConnectedDriveOptionProvider op, String type, boolean imperial) {\n+        super(thing, op, type, imperial);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        String group = channelUID.getGroupId();\n+\n+        // Refresh of Channels with cached values\n+        if (command instanceof RefreshType) {\n+            if (CHANNEL_GROUP_LAST_TRIP.equals(group)) {\n+                lastTripCache.ifPresent(lastTrip -> lastTripCallback.onResponse(lastTrip));\n+            } else if (CHANNEL_GROUP_LIFETIME.equals(group)) {\n+                allTripsCache.ifPresent(allTrips -> allTripsCallback.onResponse(allTrips));\n+            } else if (CHANNEL_GROUP_DESTINATION.equals(group)) {\n+                destinationCache.ifPresent(destination -> destinationCallback.onResponse(destination));\n+            } else if (CHANNEL_GROUP_STATUS.equals(group)) {\n+                vehicleStatusCache.ifPresent(vehicleStatus -> vehicleStatusCallback.onResponse(vehicleStatus));\n+            } else if (CHANNEL_GROUP_CHARGE.equals(group)) {\n+                chargeProfileEdit.ifPresentOrElse(this::updateChargeProfile,\n+                        () -> chargeProfileCache.ifPresent(this::updateChargeProfileFromContent));\n+            } else if (CHANNEL_GROUP_VEHICLE_IMAGE.equals(group)) {\n+                imageCache.ifPresent(image -> imageCallback.onResponse(image));\n+            }\n+            // Check for Channel Group and corresponding Actions\n+        } else if (CHANNEL_GROUP_REMOTE.equals(group)) {\n+            // Executing Remote Services\n+            if (command instanceof StringType) {\n+                String serviceCommand = ((StringType) command).toFullString();\n+                remote.ifPresent(remot -> {\n+                    switch (serviceCommand) {\n+                        case REMOTE_SERVICE_LIGHT_FLASH:\n+                        case REMOTE_SERVICE_AIR_CONDITIONING:\n+                        case REMOTE_SERVICE_DOOR_LOCK:\n+                        case REMOTE_SERVICE_DOOR_UNLOCK:\n+                        case REMOTE_SERVICE_HORN:\n+                        case REMOTE_SERVICE_VEHICLE_FINDER:\n+                        case REMOTE_SERVICE_CHARGE_NOW:\n+                            RemoteServiceUtils.getRemoteService(serviceCommand)\n+                                    .ifPresentOrElse(service -> remot.execute(service), () -> {\n+                                        logger.info(\"Remote service execution {} unknown\", serviceCommand);\n+                                    });\n+                            break;\n+                        case REMOTE_SERVICE_CHARGING_CONTROL:\n+                            sendChargeProfile(chargeProfileEdit);\n+                            break;\n+                        default:\n+                            logger.info(\"Remote service execution {} unknown\", serviceCommand);\n+                            break;\n+                    }\n+                });\n+            }\n+        } else if (CHANNEL_GROUP_VEHICLE_IMAGE.equals(group)) {\n+            // Image Change\n+            configuration.ifPresent(config -> {\n+                if (command instanceof StringType) {\n+                    if (channelUID.getIdWithoutGroup().equals(IMAGE_VIEWPORT)) {\n+                        String newViewport = command.toString();\n+                        synchronized (imageProperties) {\n+                            if (!imageProperties.viewport.equals(newViewport)) {\n+                                imageProperties = new ImageProperties(newViewport, imageProperties.size);\n+                                imageCache = Optional.empty();\n+                                proxy.ifPresent(prox -> prox.requestImage(config, imageProperties, imageCallback));\n+                            }\n+                        }\n+                        updateChannel(CHANNEL_GROUP_VEHICLE_IMAGE, IMAGE_VIEWPORT, StringType.valueOf(newViewport));\n+                    }\n+                }\n+                if (command instanceof DecimalType) {\n+                    if (command instanceof DecimalType) {\n+                        int newImageSize = ((DecimalType) command).intValue();\n+                        if (channelUID.getIdWithoutGroup().equals(IMAGE_SIZE)) {\n+                            synchronized (imageProperties) {\n+                                if (imageProperties.size != newImageSize) {\n+                                    imageProperties = new ImageProperties(imageProperties.viewport, newImageSize);\n+                                    imageCache = Optional.empty();\n+                                    proxy.ifPresent(prox -> prox.requestImage(config, imageProperties, imageCallback));\n+                                }\n+                            }\n+                        }\n+                        updateChannel(CHANNEL_GROUP_VEHICLE_IMAGE, IMAGE_SIZE, new DecimalType(newImageSize));\n+                    }\n+                }\n+            });\n+        } else if (CHANNEL_GROUP_DESTINATION.equals(group)) {\n+            if (command instanceof StringType) {\n+                int index = Converter.getIndex(command.toFullString());\n+                if (index != -1) {\n+                    selectDestination(index);\n+                } else {\n+                    logger.debug(\"Cannot select Destination index {}\", command.toFullString());\n+                }\n+            }\n+        } else if (CHANNEL_GROUP_SERVICE.equals(group)) {\n+            if (command instanceof StringType) {\n+                int index = Converter.getIndex(command.toFullString());\n+                if (index != -1) {\n+                    selectService(index);\n+                } else {\n+                    logger.debug(\"Cannot select Service index {}\", command.toFullString());\n+                }\n+            }\n+        } else if (CHANNEL_GROUP_CHECK_CONTROL.equals(group)) {\n+            if (command instanceof StringType) {\n+                int index = Converter.getIndex(command.toFullString());\n+                if (index != -1) {\n+                    selectCheckControl(index);\n+                } else {\n+                    logger.debug(\"Cannot select CheckControl index {}\", command.toFullString());\n+                }\n+            }\n+        } else if (CHANNEL_GROUP_CHARGE.equals(group)) {\n+            handleChargeProfileCommand(channelUID, command);\n+        }\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        callbackCounter = Optional.of(new ArrayList<ResponseCallback>());\n+        updateStatus(ThingStatus.UNKNOWN);\n+        final VehicleConfiguration config = getConfigAs(VehicleConfiguration.class);\n+        if (config != null) {\n+            configuration = Optional.of(config);\n+            scheduler.execute(() -> {\n+                Bridge bridge = getBridge();\n+                if (bridge != null) {\n+                    BridgeHandler handler = bridge.getHandler();\n+                    if (handler != null) {\n+                        bridgeHandler = Optional.of(((ConnectedDriveBridgeHandler) handler));\n+                        proxy = ((ConnectedDriveBridgeHandler) handler).getProxy();\n+                        remote = proxy.map(prox -> prox.getRemoteServiceHandler(this));\n+                    } else {\n+                        logger.debug(\"Bridge Handler null\");\n+                    }\n+                } else {\n+                    logger.debug(\"Bridge null\");\n+                }\n+\n+                // get Image after init with config values\n+                synchronized (imageProperties) {\n+                    imageProperties = new ImageProperties(config.imageViewport, config.imageSize);\n+                }\n+                updateChannel(CHANNEL_GROUP_VEHICLE_IMAGE, IMAGE_VIEWPORT, StringType.valueOf((config.imageViewport)));\n+                updateChannel(CHANNEL_GROUP_VEHICLE_IMAGE, IMAGE_SIZE, new DecimalType((config.imageSize)));\n+\n+                // check imperial setting is different to AutoDetect\n+                if (!UNITS_AUTODETECT.equals(config.units)) {\n+                    imperial = UNITS_IMPERIAL.equals(config.units);\n+                }\n+\n+                // start update schedule\n+                startSchedule(config.refreshInterval);\n+            });\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR);\n+        }\n+    }\n+\n+    private void startSchedule(int interval) {\n+        refreshJob.ifPresentOrElse(job -> {\n+            if (job.isCancelled()) {\n+                refreshJob = Optional\n+                        .of(scheduler.scheduleWithFixedDelay(this::getData, 0, interval, TimeUnit.MINUTES));\n+            } // else - scheduler is already running!\n+        }, () -> {\n+            refreshJob = Optional.of(scheduler.scheduleWithFixedDelay(this::getData, 0, interval, TimeUnit.MINUTES));\n+        });\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        refreshJob.ifPresent(job -> job.cancel(true));\n+    }\n+\n+    public void getData() {\n+        proxy.ifPresentOrElse(prox -> {\n+            configuration.ifPresentOrElse(config -> {\n+                if (!legacyMode) {\n+                    prox.requestVehcileStatus(config, vehicleStatusCallback);\n+                } else {\n+                    prox.requestLegacyVehcileStatus(config, oldVehicleStatusCallback);\n+                }\n+                addCallback(vehicleStatusCallback);\n+                if (isSupported(Constants.STATISTICS)) {\n+                    prox.requestLastTrip(config, lastTripCallback);\n+                    prox.requestAllTrips(config, allTripsCallback);\n+                    addCallback(lastTripCallback);\n+                    addCallback(allTripsCallback);\n+                }\n+                if (isSupported(Constants.LAST_DESTINATIONS)) {\n+                    prox.requestDestinations(config, destinationCallback);\n+                    addCallback(destinationCallback);\n+                }\n+                if (isElectric) {\n+                    prox.requestChargingProfile(config, chargeProfileCallback);\n+                    addCallback(chargeProfileCallback);\n+                }\n+                synchronized (imageProperties) {\n+                    if (!imageCache.isPresent() && !imageProperties.failLimitReached()) {\n+                        prox.requestImage(config, imageProperties, imageCallback);\n+                        addCallback(imageCallback);\n+                    }\n+                }\n+            }, () -> {\n+                logger.warn(\"ConnectedDrive Configuration isn't present\");\n+            });\n+        }, () -> {\n+            logger.warn(\"ConnectedDrive Proxy isn't present\");\n+        });\n+    }\n+\n+    private synchronized void addCallback(ResponseCallback rc) {\n+        callbackCounter.ifPresent(counter -> counter.add(rc));\n+    }\n+\n+    private synchronized void removeCallback(ResponseCallback rc) {\n+        callbackCounter.ifPresent(counter -> {\n+            counter.remove(rc);\n+            // all necessary callbacks received => print and set to empty\n+            if (counter.isEmpty()) {\n+                logFingerPrint();\n+                callbackCounter = Optional.empty();\n+            }\n+        });\n+    }\n+\n+    private void logFingerPrint() {\n+        final String vin = configuration.map(config -> config.vin).orElse(\"\");\n+        logger.debug(\"###### BMW ConnectedDrive Binding - Vehicle Troubleshoot Fingerprint Data - BEGIN ######\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5NzkxNzk2NQ=="}, "originalCommit": {"oid": "48af48c82562d006b6f2aa35922270f181c885ed"}, "originalPosition": 327}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzc3Njc3NDU1OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/VehicleHandler.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0xOVQxOToxMzowOVrOI6ODAQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0yMVQxNTozNDo1NlrOI6lJzg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5NzkxODQ2NQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    if (lastTripCache.isEmpty() || allTripsCache.isEmpty() || destinationCache.isEmpty()) {\n          \n          \n            \n                        return true;\n          \n          \n            \n                    } else {\n          \n          \n            \n                        return false;\n          \n          \n            \n                    }\n          \n          \n            \n                    return lastTripCache.isEmpty() || allTripsCache.isEmpty() || destinationCache.isEmpty();", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r597918465", "createdAt": "2021-03-19T19:13:09Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/VehicleHandler.java", "diffHunk": "@@ -0,0 +1,826 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bmwconnecteddrive.internal.handler;\n+\n+import static org.openhab.binding.bmwconnecteddrive.internal.ConnectedDriveConstants.*;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.bmwconnecteddrive.internal.VehicleConfiguration;\n+import org.openhab.binding.bmwconnecteddrive.internal.action.ChargeProfileActions;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.DestinationContainer;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.NetworkError;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.compat.VehicleAttributesContainer;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.statistics.AllTrips;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.statistics.AllTripsContainer;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.statistics.LastTrip;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.statistics.LastTripContainer;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.status.VehicleStatus;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.status.VehicleStatusContainer;\n+import org.openhab.binding.bmwconnecteddrive.internal.handler.RemoteServiceHandler.ExecutionState;\n+import org.openhab.binding.bmwconnecteddrive.internal.handler.RemoteServiceHandler.RemoteService;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileUtils;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileUtils.ChargeKeyDay;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileUtils.ChargeKeyHour;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileWrapper;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileWrapper.ProfileKey;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Constants;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Converter;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ImageProperties;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.RemoteServiceUtils;\n+import org.openhab.core.io.net.http.HttpUtil;\n+import org.openhab.core.library.types.DecimalType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.RawType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BridgeHandler;\n+import org.openhab.core.thing.binding.ThingHandlerService;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+\n+import com.google.gson.JsonSyntaxException;\n+\n+/**\n+ * The {@link VehicleHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Bernd Weymann - Initial contribution\n+ * @author Norbert Truchsess - edit & send charge profile\n+ */\n+@NonNullByDefault\n+public class VehicleHandler extends VehicleChannelHandler {\n+    private boolean legacyMode = false; // switch to legacy API in case of 404 Errors\n+\n+    private Optional<ConnectedDriveProxy> proxy = Optional.empty();\n+    private Optional<RemoteServiceHandler> remote = Optional.empty();\n+    private Optional<VehicleConfiguration> configuration = Optional.empty();\n+    private Optional<ConnectedDriveBridgeHandler> bridgeHandler = Optional.empty();\n+    private Optional<ScheduledFuture<?>> refreshJob = Optional.empty();\n+    private Optional<ScheduledFuture<?>> editTimeout = Optional.empty();\n+    private Optional<List<ResponseCallback>> callbackCounter = Optional.empty();\n+\n+    private ImageProperties imageProperties = new ImageProperties();\n+    VehicleStatusCallback vehicleStatusCallback = new VehicleStatusCallback();\n+    StringResponseCallback oldVehicleStatusCallback = new LegacyVehicleStatusCallback();\n+    StringResponseCallback lastTripCallback = new LastTripCallback();\n+    StringResponseCallback allTripsCallback = new AllTripsCallback();\n+    StringResponseCallback chargeProfileCallback = new ChargeProfilesCallback();\n+    StringResponseCallback rangeMapCallback = new RangeMapCallback();\n+    DestinationsCallback destinationCallback = new DestinationsCallback();\n+    ByteResponseCallback imageCallback = new ImageCallback();\n+\n+    private Optional<ChargeProfileWrapper> chargeProfileEdit = Optional.empty();\n+    private Optional<String> chargeProfileSent = Optional.empty();\n+\n+    public VehicleHandler(Thing thing, BMWConnectedDriveOptionProvider op, String type, boolean imperial) {\n+        super(thing, op, type, imperial);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        String group = channelUID.getGroupId();\n+\n+        // Refresh of Channels with cached values\n+        if (command instanceof RefreshType) {\n+            if (CHANNEL_GROUP_LAST_TRIP.equals(group)) {\n+                lastTripCache.ifPresent(lastTrip -> lastTripCallback.onResponse(lastTrip));\n+            } else if (CHANNEL_GROUP_LIFETIME.equals(group)) {\n+                allTripsCache.ifPresent(allTrips -> allTripsCallback.onResponse(allTrips));\n+            } else if (CHANNEL_GROUP_DESTINATION.equals(group)) {\n+                destinationCache.ifPresent(destination -> destinationCallback.onResponse(destination));\n+            } else if (CHANNEL_GROUP_STATUS.equals(group)) {\n+                vehicleStatusCache.ifPresent(vehicleStatus -> vehicleStatusCallback.onResponse(vehicleStatus));\n+            } else if (CHANNEL_GROUP_CHARGE.equals(group)) {\n+                chargeProfileEdit.ifPresentOrElse(this::updateChargeProfile,\n+                        () -> chargeProfileCache.ifPresent(this::updateChargeProfileFromContent));\n+            } else if (CHANNEL_GROUP_VEHICLE_IMAGE.equals(group)) {\n+                imageCache.ifPresent(image -> imageCallback.onResponse(image));\n+            }\n+            // Check for Channel Group and corresponding Actions\n+        } else if (CHANNEL_GROUP_REMOTE.equals(group)) {\n+            // Executing Remote Services\n+            if (command instanceof StringType) {\n+                String serviceCommand = ((StringType) command).toFullString();\n+                remote.ifPresent(remot -> {\n+                    switch (serviceCommand) {\n+                        case REMOTE_SERVICE_LIGHT_FLASH:\n+                        case REMOTE_SERVICE_AIR_CONDITIONING:\n+                        case REMOTE_SERVICE_DOOR_LOCK:\n+                        case REMOTE_SERVICE_DOOR_UNLOCK:\n+                        case REMOTE_SERVICE_HORN:\n+                        case REMOTE_SERVICE_VEHICLE_FINDER:\n+                        case REMOTE_SERVICE_CHARGE_NOW:\n+                            RemoteServiceUtils.getRemoteService(serviceCommand)\n+                                    .ifPresentOrElse(service -> remot.execute(service), () -> {\n+                                        logger.info(\"Remote service execution {} unknown\", serviceCommand);\n+                                    });\n+                            break;\n+                        case REMOTE_SERVICE_CHARGING_CONTROL:\n+                            sendChargeProfile(chargeProfileEdit);\n+                            break;\n+                        default:\n+                            logger.info(\"Remote service execution {} unknown\", serviceCommand);\n+                            break;\n+                    }\n+                });\n+            }\n+        } else if (CHANNEL_GROUP_VEHICLE_IMAGE.equals(group)) {\n+            // Image Change\n+            configuration.ifPresent(config -> {\n+                if (command instanceof StringType) {\n+                    if (channelUID.getIdWithoutGroup().equals(IMAGE_VIEWPORT)) {\n+                        String newViewport = command.toString();\n+                        synchronized (imageProperties) {\n+                            if (!imageProperties.viewport.equals(newViewport)) {\n+                                imageProperties = new ImageProperties(newViewport, imageProperties.size);\n+                                imageCache = Optional.empty();\n+                                proxy.ifPresent(prox -> prox.requestImage(config, imageProperties, imageCallback));\n+                            }\n+                        }\n+                        updateChannel(CHANNEL_GROUP_VEHICLE_IMAGE, IMAGE_VIEWPORT, StringType.valueOf(newViewport));\n+                    }\n+                }\n+                if (command instanceof DecimalType) {\n+                    if (command instanceof DecimalType) {\n+                        int newImageSize = ((DecimalType) command).intValue();\n+                        if (channelUID.getIdWithoutGroup().equals(IMAGE_SIZE)) {\n+                            synchronized (imageProperties) {\n+                                if (imageProperties.size != newImageSize) {\n+                                    imageProperties = new ImageProperties(imageProperties.viewport, newImageSize);\n+                                    imageCache = Optional.empty();\n+                                    proxy.ifPresent(prox -> prox.requestImage(config, imageProperties, imageCallback));\n+                                }\n+                            }\n+                        }\n+                        updateChannel(CHANNEL_GROUP_VEHICLE_IMAGE, IMAGE_SIZE, new DecimalType(newImageSize));\n+                    }\n+                }\n+            });\n+        } else if (CHANNEL_GROUP_DESTINATION.equals(group)) {\n+            if (command instanceof StringType) {\n+                int index = Converter.getIndex(command.toFullString());\n+                if (index != -1) {\n+                    selectDestination(index);\n+                } else {\n+                    logger.debug(\"Cannot select Destination index {}\", command.toFullString());\n+                }\n+            }\n+        } else if (CHANNEL_GROUP_SERVICE.equals(group)) {\n+            if (command instanceof StringType) {\n+                int index = Converter.getIndex(command.toFullString());\n+                if (index != -1) {\n+                    selectService(index);\n+                } else {\n+                    logger.debug(\"Cannot select Service index {}\", command.toFullString());\n+                }\n+            }\n+        } else if (CHANNEL_GROUP_CHECK_CONTROL.equals(group)) {\n+            if (command instanceof StringType) {\n+                int index = Converter.getIndex(command.toFullString());\n+                if (index != -1) {\n+                    selectCheckControl(index);\n+                } else {\n+                    logger.debug(\"Cannot select CheckControl index {}\", command.toFullString());\n+                }\n+            }\n+        } else if (CHANNEL_GROUP_CHARGE.equals(group)) {\n+            handleChargeProfileCommand(channelUID, command);\n+        }\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        callbackCounter = Optional.of(new ArrayList<ResponseCallback>());\n+        updateStatus(ThingStatus.UNKNOWN);\n+        final VehicleConfiguration config = getConfigAs(VehicleConfiguration.class);\n+        if (config != null) {\n+            configuration = Optional.of(config);\n+            scheduler.execute(() -> {\n+                Bridge bridge = getBridge();\n+                if (bridge != null) {\n+                    BridgeHandler handler = bridge.getHandler();\n+                    if (handler != null) {\n+                        bridgeHandler = Optional.of(((ConnectedDriveBridgeHandler) handler));\n+                        proxy = ((ConnectedDriveBridgeHandler) handler).getProxy();\n+                        remote = proxy.map(prox -> prox.getRemoteServiceHandler(this));\n+                    } else {\n+                        logger.debug(\"Bridge Handler null\");\n+                    }\n+                } else {\n+                    logger.debug(\"Bridge null\");\n+                }\n+\n+                // get Image after init with config values\n+                synchronized (imageProperties) {\n+                    imageProperties = new ImageProperties(config.imageViewport, config.imageSize);\n+                }\n+                updateChannel(CHANNEL_GROUP_VEHICLE_IMAGE, IMAGE_VIEWPORT, StringType.valueOf((config.imageViewport)));\n+                updateChannel(CHANNEL_GROUP_VEHICLE_IMAGE, IMAGE_SIZE, new DecimalType((config.imageSize)));\n+\n+                // check imperial setting is different to AutoDetect\n+                if (!UNITS_AUTODETECT.equals(config.units)) {\n+                    imperial = UNITS_IMPERIAL.equals(config.units);\n+                }\n+\n+                // start update schedule\n+                startSchedule(config.refreshInterval);\n+            });\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR);\n+        }\n+    }\n+\n+    private void startSchedule(int interval) {\n+        refreshJob.ifPresentOrElse(job -> {\n+            if (job.isCancelled()) {\n+                refreshJob = Optional\n+                        .of(scheduler.scheduleWithFixedDelay(this::getData, 0, interval, TimeUnit.MINUTES));\n+            } // else - scheduler is already running!\n+        }, () -> {\n+            refreshJob = Optional.of(scheduler.scheduleWithFixedDelay(this::getData, 0, interval, TimeUnit.MINUTES));\n+        });\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        refreshJob.ifPresent(job -> job.cancel(true));\n+    }\n+\n+    public void getData() {\n+        proxy.ifPresentOrElse(prox -> {\n+            configuration.ifPresentOrElse(config -> {\n+                if (!legacyMode) {\n+                    prox.requestVehcileStatus(config, vehicleStatusCallback);\n+                } else {\n+                    prox.requestLegacyVehcileStatus(config, oldVehicleStatusCallback);\n+                }\n+                addCallback(vehicleStatusCallback);\n+                if (isSupported(Constants.STATISTICS)) {\n+                    prox.requestLastTrip(config, lastTripCallback);\n+                    prox.requestAllTrips(config, allTripsCallback);\n+                    addCallback(lastTripCallback);\n+                    addCallback(allTripsCallback);\n+                }\n+                if (isSupported(Constants.LAST_DESTINATIONS)) {\n+                    prox.requestDestinations(config, destinationCallback);\n+                    addCallback(destinationCallback);\n+                }\n+                if (isElectric) {\n+                    prox.requestChargingProfile(config, chargeProfileCallback);\n+                    addCallback(chargeProfileCallback);\n+                }\n+                synchronized (imageProperties) {\n+                    if (!imageCache.isPresent() && !imageProperties.failLimitReached()) {\n+                        prox.requestImage(config, imageProperties, imageCallback);\n+                        addCallback(imageCallback);\n+                    }\n+                }\n+            }, () -> {\n+                logger.warn(\"ConnectedDrive Configuration isn't present\");\n+            });\n+        }, () -> {\n+            logger.warn(\"ConnectedDrive Proxy isn't present\");\n+        });\n+    }\n+\n+    private synchronized void addCallback(ResponseCallback rc) {\n+        callbackCounter.ifPresent(counter -> counter.add(rc));\n+    }\n+\n+    private synchronized void removeCallback(ResponseCallback rc) {\n+        callbackCounter.ifPresent(counter -> {\n+            counter.remove(rc);\n+            // all necessary callbacks received => print and set to empty\n+            if (counter.isEmpty()) {\n+                logFingerPrint();\n+                callbackCounter = Optional.empty();\n+            }\n+        });\n+    }\n+\n+    private void logFingerPrint() {\n+        final String vin = configuration.map(config -> config.vin).orElse(\"\");\n+        logger.debug(\"###### BMW ConnectedDrive Binding - Vehicle Troubleshoot Fingerprint Data - BEGIN ######\");\n+        logger.debug(\"### Discovery Result ###\");\n+        bridgeHandler.ifPresent(handler -> {\n+            logger.debug(\"{}\", handler.getDiscoveryFingerprint());\n+        });\n+        vehicleStatusCache.ifPresentOrElse(vehicleStatus -> {\n+            logger.debug(\"### Vehicle Status ###\");\n+\n+            // Anonymous data for VIN and Position\n+            try {\n+                VehicleStatusContainer container = Converter.getGson().fromJson(vehicleStatus,\n+                        VehicleStatusContainer.class);\n+                if (container != null) {\n+                    VehicleStatus status = container.vehicleStatus;\n+                    if (status != null) {\n+                        status.vin = Constants.ANONYMOUS;\n+                        if (status.position != null) {\n+                            status.position.lat = -1;\n+                            status.position.lon = -1;\n+                            status.position.heading = -1;\n+                        }\n+                    }\n+                }\n+                logger.debug(\"{}\", Converter.getGson().toJson(container));\n+            } catch (JsonSyntaxException jse) {\n+                logger.debug(\"{}\", jse.getMessage());\n+            }\n+        }, () -> {\n+            logger.debug(\"### Vehicle Status Empty ###\");\n+        });\n+        lastTripCache.ifPresentOrElse(lastTrip -> {\n+            logger.debug(\"### Last Trip ###\");\n+            logger.debug(\"{}\", lastTrip.replaceAll(vin, Constants.ANONYMOUS));\n+        }, () -> {\n+            logger.debug(\"### Last Trip Empty ###\");\n+        });\n+        allTripsCache.ifPresentOrElse(allTrips -> {\n+            logger.debug(\"### All Trips ###\");\n+            logger.debug(\"{}\", allTrips.replaceAll(vin, Constants.ANONYMOUS));\n+        }, () -> {\n+            logger.debug(\"### All Trips Empty ###\");\n+        });\n+        if (isElectric) {\n+            chargeProfileCache.ifPresentOrElse(chargeProfile -> {\n+                logger.debug(\"### Charge Profile ###\");\n+                logger.debug(\"{}\", chargeProfile.replaceAll(vin, Constants.ANONYMOUS));\n+            }, () -> {\n+                logger.debug(\"### Charge Profile Empty ###\");\n+            });\n+        }\n+        destinationCache.ifPresentOrElse(destination -> {\n+            logger.debug(\"### Charge Profile ###\");\n+            try {\n+                DestinationContainer container = Converter.getGson().fromJson(destination, DestinationContainer.class);\n+                if (container != null) {\n+                    if (container.destinations != null) {\n+                        container.destinations.forEach(entry -> {\n+                            entry.lat = 0;\n+                            entry.lon = 0;\n+                            entry.city = Constants.ANONYMOUS;\n+                            entry.street = Constants.ANONYMOUS;\n+                            entry.streetNumber = Constants.ANONYMOUS;\n+                            entry.country = Constants.ANONYMOUS;\n+                        });\n+                        logger.debug(\"{}\", Converter.getGson().toJson(container));\n+                    }\n+                } else {\n+                    logger.debug(\"### Destinations Empty ###\");\n+                }\n+            } catch (JsonSyntaxException jse) {\n+                logger.debug(\"{}\", jse.getMessage());\n+            }\n+        }, () -> {\n+            logger.debug(\"### Charge Profile Empty ###\");\n+        });\n+        rangeMapCache.ifPresentOrElse(rangeMap -> {\n+            logger.debug(\"### Range Map ###\");\n+            logger.debug(\"{}\", rangeMap.replaceAll(vin, Constants.ANONYMOUS));\n+        }, () -> {\n+            logger.debug(\"### Range Map Empty ###\");\n+        });\n+        logger.debug(\"###### BMW ConnectedDrive Binding - Vehicle Troubleshoot Fingerprint Data - END ######\");\n+    }\n+\n+    /**\n+     * Don't stress ConnectedDrive with unnecessary requests. One call at the beginning is done to check the response.\n+     * After cache has e.g. a proper error response it will be shown in the fingerprint\n+     *\n+     * @return\n+     */\n+    private boolean isSupported(String service) {\n+        final String services = thing.getProperties().get(Constants.SERVICES_SUPPORTED);\n+        if (services != null) {\n+            if (services.contains(service)) {\n+                return true;\n+            }\n+        }\n+        // if cache is empty give it a try one time to collected Troubleshoot data\n+        if (lastTripCache.isEmpty() || allTripsCache.isEmpty() || destinationCache.isEmpty()) {\n+            return true;\n+        } else {\n+            return false;\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "48af48c82562d006b6f2aa35922270f181c885ed"}, "originalPosition": 429}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5ODI5NzAzOA==", "bodyText": "fixed in weymann#10", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r598297038", "createdAt": "2021-03-21T15:34:56Z", "author": {"login": "ntruchsess"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/VehicleHandler.java", "diffHunk": "@@ -0,0 +1,826 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bmwconnecteddrive.internal.handler;\n+\n+import static org.openhab.binding.bmwconnecteddrive.internal.ConnectedDriveConstants.*;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.bmwconnecteddrive.internal.VehicleConfiguration;\n+import org.openhab.binding.bmwconnecteddrive.internal.action.ChargeProfileActions;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.DestinationContainer;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.NetworkError;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.compat.VehicleAttributesContainer;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.statistics.AllTrips;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.statistics.AllTripsContainer;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.statistics.LastTrip;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.statistics.LastTripContainer;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.status.VehicleStatus;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.status.VehicleStatusContainer;\n+import org.openhab.binding.bmwconnecteddrive.internal.handler.RemoteServiceHandler.ExecutionState;\n+import org.openhab.binding.bmwconnecteddrive.internal.handler.RemoteServiceHandler.RemoteService;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileUtils;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileUtils.ChargeKeyDay;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileUtils.ChargeKeyHour;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileWrapper;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileWrapper.ProfileKey;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Constants;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Converter;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ImageProperties;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.RemoteServiceUtils;\n+import org.openhab.core.io.net.http.HttpUtil;\n+import org.openhab.core.library.types.DecimalType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.RawType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BridgeHandler;\n+import org.openhab.core.thing.binding.ThingHandlerService;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+\n+import com.google.gson.JsonSyntaxException;\n+\n+/**\n+ * The {@link VehicleHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Bernd Weymann - Initial contribution\n+ * @author Norbert Truchsess - edit & send charge profile\n+ */\n+@NonNullByDefault\n+public class VehicleHandler extends VehicleChannelHandler {\n+    private boolean legacyMode = false; // switch to legacy API in case of 404 Errors\n+\n+    private Optional<ConnectedDriveProxy> proxy = Optional.empty();\n+    private Optional<RemoteServiceHandler> remote = Optional.empty();\n+    private Optional<VehicleConfiguration> configuration = Optional.empty();\n+    private Optional<ConnectedDriveBridgeHandler> bridgeHandler = Optional.empty();\n+    private Optional<ScheduledFuture<?>> refreshJob = Optional.empty();\n+    private Optional<ScheduledFuture<?>> editTimeout = Optional.empty();\n+    private Optional<List<ResponseCallback>> callbackCounter = Optional.empty();\n+\n+    private ImageProperties imageProperties = new ImageProperties();\n+    VehicleStatusCallback vehicleStatusCallback = new VehicleStatusCallback();\n+    StringResponseCallback oldVehicleStatusCallback = new LegacyVehicleStatusCallback();\n+    StringResponseCallback lastTripCallback = new LastTripCallback();\n+    StringResponseCallback allTripsCallback = new AllTripsCallback();\n+    StringResponseCallback chargeProfileCallback = new ChargeProfilesCallback();\n+    StringResponseCallback rangeMapCallback = new RangeMapCallback();\n+    DestinationsCallback destinationCallback = new DestinationsCallback();\n+    ByteResponseCallback imageCallback = new ImageCallback();\n+\n+    private Optional<ChargeProfileWrapper> chargeProfileEdit = Optional.empty();\n+    private Optional<String> chargeProfileSent = Optional.empty();\n+\n+    public VehicleHandler(Thing thing, BMWConnectedDriveOptionProvider op, String type, boolean imperial) {\n+        super(thing, op, type, imperial);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        String group = channelUID.getGroupId();\n+\n+        // Refresh of Channels with cached values\n+        if (command instanceof RefreshType) {\n+            if (CHANNEL_GROUP_LAST_TRIP.equals(group)) {\n+                lastTripCache.ifPresent(lastTrip -> lastTripCallback.onResponse(lastTrip));\n+            } else if (CHANNEL_GROUP_LIFETIME.equals(group)) {\n+                allTripsCache.ifPresent(allTrips -> allTripsCallback.onResponse(allTrips));\n+            } else if (CHANNEL_GROUP_DESTINATION.equals(group)) {\n+                destinationCache.ifPresent(destination -> destinationCallback.onResponse(destination));\n+            } else if (CHANNEL_GROUP_STATUS.equals(group)) {\n+                vehicleStatusCache.ifPresent(vehicleStatus -> vehicleStatusCallback.onResponse(vehicleStatus));\n+            } else if (CHANNEL_GROUP_CHARGE.equals(group)) {\n+                chargeProfileEdit.ifPresentOrElse(this::updateChargeProfile,\n+                        () -> chargeProfileCache.ifPresent(this::updateChargeProfileFromContent));\n+            } else if (CHANNEL_GROUP_VEHICLE_IMAGE.equals(group)) {\n+                imageCache.ifPresent(image -> imageCallback.onResponse(image));\n+            }\n+            // Check for Channel Group and corresponding Actions\n+        } else if (CHANNEL_GROUP_REMOTE.equals(group)) {\n+            // Executing Remote Services\n+            if (command instanceof StringType) {\n+                String serviceCommand = ((StringType) command).toFullString();\n+                remote.ifPresent(remot -> {\n+                    switch (serviceCommand) {\n+                        case REMOTE_SERVICE_LIGHT_FLASH:\n+                        case REMOTE_SERVICE_AIR_CONDITIONING:\n+                        case REMOTE_SERVICE_DOOR_LOCK:\n+                        case REMOTE_SERVICE_DOOR_UNLOCK:\n+                        case REMOTE_SERVICE_HORN:\n+                        case REMOTE_SERVICE_VEHICLE_FINDER:\n+                        case REMOTE_SERVICE_CHARGE_NOW:\n+                            RemoteServiceUtils.getRemoteService(serviceCommand)\n+                                    .ifPresentOrElse(service -> remot.execute(service), () -> {\n+                                        logger.info(\"Remote service execution {} unknown\", serviceCommand);\n+                                    });\n+                            break;\n+                        case REMOTE_SERVICE_CHARGING_CONTROL:\n+                            sendChargeProfile(chargeProfileEdit);\n+                            break;\n+                        default:\n+                            logger.info(\"Remote service execution {} unknown\", serviceCommand);\n+                            break;\n+                    }\n+                });\n+            }\n+        } else if (CHANNEL_GROUP_VEHICLE_IMAGE.equals(group)) {\n+            // Image Change\n+            configuration.ifPresent(config -> {\n+                if (command instanceof StringType) {\n+                    if (channelUID.getIdWithoutGroup().equals(IMAGE_VIEWPORT)) {\n+                        String newViewport = command.toString();\n+                        synchronized (imageProperties) {\n+                            if (!imageProperties.viewport.equals(newViewport)) {\n+                                imageProperties = new ImageProperties(newViewport, imageProperties.size);\n+                                imageCache = Optional.empty();\n+                                proxy.ifPresent(prox -> prox.requestImage(config, imageProperties, imageCallback));\n+                            }\n+                        }\n+                        updateChannel(CHANNEL_GROUP_VEHICLE_IMAGE, IMAGE_VIEWPORT, StringType.valueOf(newViewport));\n+                    }\n+                }\n+                if (command instanceof DecimalType) {\n+                    if (command instanceof DecimalType) {\n+                        int newImageSize = ((DecimalType) command).intValue();\n+                        if (channelUID.getIdWithoutGroup().equals(IMAGE_SIZE)) {\n+                            synchronized (imageProperties) {\n+                                if (imageProperties.size != newImageSize) {\n+                                    imageProperties = new ImageProperties(imageProperties.viewport, newImageSize);\n+                                    imageCache = Optional.empty();\n+                                    proxy.ifPresent(prox -> prox.requestImage(config, imageProperties, imageCallback));\n+                                }\n+                            }\n+                        }\n+                        updateChannel(CHANNEL_GROUP_VEHICLE_IMAGE, IMAGE_SIZE, new DecimalType(newImageSize));\n+                    }\n+                }\n+            });\n+        } else if (CHANNEL_GROUP_DESTINATION.equals(group)) {\n+            if (command instanceof StringType) {\n+                int index = Converter.getIndex(command.toFullString());\n+                if (index != -1) {\n+                    selectDestination(index);\n+                } else {\n+                    logger.debug(\"Cannot select Destination index {}\", command.toFullString());\n+                }\n+            }\n+        } else if (CHANNEL_GROUP_SERVICE.equals(group)) {\n+            if (command instanceof StringType) {\n+                int index = Converter.getIndex(command.toFullString());\n+                if (index != -1) {\n+                    selectService(index);\n+                } else {\n+                    logger.debug(\"Cannot select Service index {}\", command.toFullString());\n+                }\n+            }\n+        } else if (CHANNEL_GROUP_CHECK_CONTROL.equals(group)) {\n+            if (command instanceof StringType) {\n+                int index = Converter.getIndex(command.toFullString());\n+                if (index != -1) {\n+                    selectCheckControl(index);\n+                } else {\n+                    logger.debug(\"Cannot select CheckControl index {}\", command.toFullString());\n+                }\n+            }\n+        } else if (CHANNEL_GROUP_CHARGE.equals(group)) {\n+            handleChargeProfileCommand(channelUID, command);\n+        }\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        callbackCounter = Optional.of(new ArrayList<ResponseCallback>());\n+        updateStatus(ThingStatus.UNKNOWN);\n+        final VehicleConfiguration config = getConfigAs(VehicleConfiguration.class);\n+        if (config != null) {\n+            configuration = Optional.of(config);\n+            scheduler.execute(() -> {\n+                Bridge bridge = getBridge();\n+                if (bridge != null) {\n+                    BridgeHandler handler = bridge.getHandler();\n+                    if (handler != null) {\n+                        bridgeHandler = Optional.of(((ConnectedDriveBridgeHandler) handler));\n+                        proxy = ((ConnectedDriveBridgeHandler) handler).getProxy();\n+                        remote = proxy.map(prox -> prox.getRemoteServiceHandler(this));\n+                    } else {\n+                        logger.debug(\"Bridge Handler null\");\n+                    }\n+                } else {\n+                    logger.debug(\"Bridge null\");\n+                }\n+\n+                // get Image after init with config values\n+                synchronized (imageProperties) {\n+                    imageProperties = new ImageProperties(config.imageViewport, config.imageSize);\n+                }\n+                updateChannel(CHANNEL_GROUP_VEHICLE_IMAGE, IMAGE_VIEWPORT, StringType.valueOf((config.imageViewport)));\n+                updateChannel(CHANNEL_GROUP_VEHICLE_IMAGE, IMAGE_SIZE, new DecimalType((config.imageSize)));\n+\n+                // check imperial setting is different to AutoDetect\n+                if (!UNITS_AUTODETECT.equals(config.units)) {\n+                    imperial = UNITS_IMPERIAL.equals(config.units);\n+                }\n+\n+                // start update schedule\n+                startSchedule(config.refreshInterval);\n+            });\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR);\n+        }\n+    }\n+\n+    private void startSchedule(int interval) {\n+        refreshJob.ifPresentOrElse(job -> {\n+            if (job.isCancelled()) {\n+                refreshJob = Optional\n+                        .of(scheduler.scheduleWithFixedDelay(this::getData, 0, interval, TimeUnit.MINUTES));\n+            } // else - scheduler is already running!\n+        }, () -> {\n+            refreshJob = Optional.of(scheduler.scheduleWithFixedDelay(this::getData, 0, interval, TimeUnit.MINUTES));\n+        });\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        refreshJob.ifPresent(job -> job.cancel(true));\n+    }\n+\n+    public void getData() {\n+        proxy.ifPresentOrElse(prox -> {\n+            configuration.ifPresentOrElse(config -> {\n+                if (!legacyMode) {\n+                    prox.requestVehcileStatus(config, vehicleStatusCallback);\n+                } else {\n+                    prox.requestLegacyVehcileStatus(config, oldVehicleStatusCallback);\n+                }\n+                addCallback(vehicleStatusCallback);\n+                if (isSupported(Constants.STATISTICS)) {\n+                    prox.requestLastTrip(config, lastTripCallback);\n+                    prox.requestAllTrips(config, allTripsCallback);\n+                    addCallback(lastTripCallback);\n+                    addCallback(allTripsCallback);\n+                }\n+                if (isSupported(Constants.LAST_DESTINATIONS)) {\n+                    prox.requestDestinations(config, destinationCallback);\n+                    addCallback(destinationCallback);\n+                }\n+                if (isElectric) {\n+                    prox.requestChargingProfile(config, chargeProfileCallback);\n+                    addCallback(chargeProfileCallback);\n+                }\n+                synchronized (imageProperties) {\n+                    if (!imageCache.isPresent() && !imageProperties.failLimitReached()) {\n+                        prox.requestImage(config, imageProperties, imageCallback);\n+                        addCallback(imageCallback);\n+                    }\n+                }\n+            }, () -> {\n+                logger.warn(\"ConnectedDrive Configuration isn't present\");\n+            });\n+        }, () -> {\n+            logger.warn(\"ConnectedDrive Proxy isn't present\");\n+        });\n+    }\n+\n+    private synchronized void addCallback(ResponseCallback rc) {\n+        callbackCounter.ifPresent(counter -> counter.add(rc));\n+    }\n+\n+    private synchronized void removeCallback(ResponseCallback rc) {\n+        callbackCounter.ifPresent(counter -> {\n+            counter.remove(rc);\n+            // all necessary callbacks received => print and set to empty\n+            if (counter.isEmpty()) {\n+                logFingerPrint();\n+                callbackCounter = Optional.empty();\n+            }\n+        });\n+    }\n+\n+    private void logFingerPrint() {\n+        final String vin = configuration.map(config -> config.vin).orElse(\"\");\n+        logger.debug(\"###### BMW ConnectedDrive Binding - Vehicle Troubleshoot Fingerprint Data - BEGIN ######\");\n+        logger.debug(\"### Discovery Result ###\");\n+        bridgeHandler.ifPresent(handler -> {\n+            logger.debug(\"{}\", handler.getDiscoveryFingerprint());\n+        });\n+        vehicleStatusCache.ifPresentOrElse(vehicleStatus -> {\n+            logger.debug(\"### Vehicle Status ###\");\n+\n+            // Anonymous data for VIN and Position\n+            try {\n+                VehicleStatusContainer container = Converter.getGson().fromJson(vehicleStatus,\n+                        VehicleStatusContainer.class);\n+                if (container != null) {\n+                    VehicleStatus status = container.vehicleStatus;\n+                    if (status != null) {\n+                        status.vin = Constants.ANONYMOUS;\n+                        if (status.position != null) {\n+                            status.position.lat = -1;\n+                            status.position.lon = -1;\n+                            status.position.heading = -1;\n+                        }\n+                    }\n+                }\n+                logger.debug(\"{}\", Converter.getGson().toJson(container));\n+            } catch (JsonSyntaxException jse) {\n+                logger.debug(\"{}\", jse.getMessage());\n+            }\n+        }, () -> {\n+            logger.debug(\"### Vehicle Status Empty ###\");\n+        });\n+        lastTripCache.ifPresentOrElse(lastTrip -> {\n+            logger.debug(\"### Last Trip ###\");\n+            logger.debug(\"{}\", lastTrip.replaceAll(vin, Constants.ANONYMOUS));\n+        }, () -> {\n+            logger.debug(\"### Last Trip Empty ###\");\n+        });\n+        allTripsCache.ifPresentOrElse(allTrips -> {\n+            logger.debug(\"### All Trips ###\");\n+            logger.debug(\"{}\", allTrips.replaceAll(vin, Constants.ANONYMOUS));\n+        }, () -> {\n+            logger.debug(\"### All Trips Empty ###\");\n+        });\n+        if (isElectric) {\n+            chargeProfileCache.ifPresentOrElse(chargeProfile -> {\n+                logger.debug(\"### Charge Profile ###\");\n+                logger.debug(\"{}\", chargeProfile.replaceAll(vin, Constants.ANONYMOUS));\n+            }, () -> {\n+                logger.debug(\"### Charge Profile Empty ###\");\n+            });\n+        }\n+        destinationCache.ifPresentOrElse(destination -> {\n+            logger.debug(\"### Charge Profile ###\");\n+            try {\n+                DestinationContainer container = Converter.getGson().fromJson(destination, DestinationContainer.class);\n+                if (container != null) {\n+                    if (container.destinations != null) {\n+                        container.destinations.forEach(entry -> {\n+                            entry.lat = 0;\n+                            entry.lon = 0;\n+                            entry.city = Constants.ANONYMOUS;\n+                            entry.street = Constants.ANONYMOUS;\n+                            entry.streetNumber = Constants.ANONYMOUS;\n+                            entry.country = Constants.ANONYMOUS;\n+                        });\n+                        logger.debug(\"{}\", Converter.getGson().toJson(container));\n+                    }\n+                } else {\n+                    logger.debug(\"### Destinations Empty ###\");\n+                }\n+            } catch (JsonSyntaxException jse) {\n+                logger.debug(\"{}\", jse.getMessage());\n+            }\n+        }, () -> {\n+            logger.debug(\"### Charge Profile Empty ###\");\n+        });\n+        rangeMapCache.ifPresentOrElse(rangeMap -> {\n+            logger.debug(\"### Range Map ###\");\n+            logger.debug(\"{}\", rangeMap.replaceAll(vin, Constants.ANONYMOUS));\n+        }, () -> {\n+            logger.debug(\"### Range Map Empty ###\");\n+        });\n+        logger.debug(\"###### BMW ConnectedDrive Binding - Vehicle Troubleshoot Fingerprint Data - END ######\");\n+    }\n+\n+    /**\n+     * Don't stress ConnectedDrive with unnecessary requests. One call at the beginning is done to check the response.\n+     * After cache has e.g. a proper error response it will be shown in the fingerprint\n+     *\n+     * @return\n+     */\n+    private boolean isSupported(String service) {\n+        final String services = thing.getProperties().get(Constants.SERVICES_SUPPORTED);\n+        if (services != null) {\n+            if (services.contains(service)) {\n+                return true;\n+            }\n+        }\n+        // if cache is empty give it a try one time to collected Troubleshoot data\n+        if (lastTripCache.isEmpty() || allTripsCache.isEmpty() || destinationCache.isEmpty()) {\n+            return true;\n+        } else {\n+            return false;\n+        }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5NzkxODQ2NQ=="}, "originalCommit": {"oid": "48af48c82562d006b6f2aa35922270f181c885ed"}, "originalPosition": 429}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzc3Njc3Njg1OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/VehicleHandler.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0xOVQxOToxMzo0N1rOI6OEVQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0yMVQxNTo0MDozMVrOI6lNLQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5NzkxODgwNQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            new StringBuilder(service == null ? \"-\" : service).append(\" \").append(status).toString())));\n          \n          \n            \n                            new StringBuilder(service == null ? \"-\" : service).append(Converter.SPACE).append(status).toString())));", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r597918805", "createdAt": "2021-03-19T19:13:47Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/VehicleHandler.java", "diffHunk": "@@ -0,0 +1,826 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bmwconnecteddrive.internal.handler;\n+\n+import static org.openhab.binding.bmwconnecteddrive.internal.ConnectedDriveConstants.*;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.bmwconnecteddrive.internal.VehicleConfiguration;\n+import org.openhab.binding.bmwconnecteddrive.internal.action.ChargeProfileActions;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.DestinationContainer;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.NetworkError;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.compat.VehicleAttributesContainer;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.statistics.AllTrips;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.statistics.AllTripsContainer;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.statistics.LastTrip;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.statistics.LastTripContainer;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.status.VehicleStatus;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.status.VehicleStatusContainer;\n+import org.openhab.binding.bmwconnecteddrive.internal.handler.RemoteServiceHandler.ExecutionState;\n+import org.openhab.binding.bmwconnecteddrive.internal.handler.RemoteServiceHandler.RemoteService;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileUtils;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileUtils.ChargeKeyDay;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileUtils.ChargeKeyHour;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileWrapper;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileWrapper.ProfileKey;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Constants;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Converter;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ImageProperties;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.RemoteServiceUtils;\n+import org.openhab.core.io.net.http.HttpUtil;\n+import org.openhab.core.library.types.DecimalType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.RawType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BridgeHandler;\n+import org.openhab.core.thing.binding.ThingHandlerService;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+\n+import com.google.gson.JsonSyntaxException;\n+\n+/**\n+ * The {@link VehicleHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Bernd Weymann - Initial contribution\n+ * @author Norbert Truchsess - edit & send charge profile\n+ */\n+@NonNullByDefault\n+public class VehicleHandler extends VehicleChannelHandler {\n+    private boolean legacyMode = false; // switch to legacy API in case of 404 Errors\n+\n+    private Optional<ConnectedDriveProxy> proxy = Optional.empty();\n+    private Optional<RemoteServiceHandler> remote = Optional.empty();\n+    private Optional<VehicleConfiguration> configuration = Optional.empty();\n+    private Optional<ConnectedDriveBridgeHandler> bridgeHandler = Optional.empty();\n+    private Optional<ScheduledFuture<?>> refreshJob = Optional.empty();\n+    private Optional<ScheduledFuture<?>> editTimeout = Optional.empty();\n+    private Optional<List<ResponseCallback>> callbackCounter = Optional.empty();\n+\n+    private ImageProperties imageProperties = new ImageProperties();\n+    VehicleStatusCallback vehicleStatusCallback = new VehicleStatusCallback();\n+    StringResponseCallback oldVehicleStatusCallback = new LegacyVehicleStatusCallback();\n+    StringResponseCallback lastTripCallback = new LastTripCallback();\n+    StringResponseCallback allTripsCallback = new AllTripsCallback();\n+    StringResponseCallback chargeProfileCallback = new ChargeProfilesCallback();\n+    StringResponseCallback rangeMapCallback = new RangeMapCallback();\n+    DestinationsCallback destinationCallback = new DestinationsCallback();\n+    ByteResponseCallback imageCallback = new ImageCallback();\n+\n+    private Optional<ChargeProfileWrapper> chargeProfileEdit = Optional.empty();\n+    private Optional<String> chargeProfileSent = Optional.empty();\n+\n+    public VehicleHandler(Thing thing, BMWConnectedDriveOptionProvider op, String type, boolean imperial) {\n+        super(thing, op, type, imperial);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        String group = channelUID.getGroupId();\n+\n+        // Refresh of Channels with cached values\n+        if (command instanceof RefreshType) {\n+            if (CHANNEL_GROUP_LAST_TRIP.equals(group)) {\n+                lastTripCache.ifPresent(lastTrip -> lastTripCallback.onResponse(lastTrip));\n+            } else if (CHANNEL_GROUP_LIFETIME.equals(group)) {\n+                allTripsCache.ifPresent(allTrips -> allTripsCallback.onResponse(allTrips));\n+            } else if (CHANNEL_GROUP_DESTINATION.equals(group)) {\n+                destinationCache.ifPresent(destination -> destinationCallback.onResponse(destination));\n+            } else if (CHANNEL_GROUP_STATUS.equals(group)) {\n+                vehicleStatusCache.ifPresent(vehicleStatus -> vehicleStatusCallback.onResponse(vehicleStatus));\n+            } else if (CHANNEL_GROUP_CHARGE.equals(group)) {\n+                chargeProfileEdit.ifPresentOrElse(this::updateChargeProfile,\n+                        () -> chargeProfileCache.ifPresent(this::updateChargeProfileFromContent));\n+            } else if (CHANNEL_GROUP_VEHICLE_IMAGE.equals(group)) {\n+                imageCache.ifPresent(image -> imageCallback.onResponse(image));\n+            }\n+            // Check for Channel Group and corresponding Actions\n+        } else if (CHANNEL_GROUP_REMOTE.equals(group)) {\n+            // Executing Remote Services\n+            if (command instanceof StringType) {\n+                String serviceCommand = ((StringType) command).toFullString();\n+                remote.ifPresent(remot -> {\n+                    switch (serviceCommand) {\n+                        case REMOTE_SERVICE_LIGHT_FLASH:\n+                        case REMOTE_SERVICE_AIR_CONDITIONING:\n+                        case REMOTE_SERVICE_DOOR_LOCK:\n+                        case REMOTE_SERVICE_DOOR_UNLOCK:\n+                        case REMOTE_SERVICE_HORN:\n+                        case REMOTE_SERVICE_VEHICLE_FINDER:\n+                        case REMOTE_SERVICE_CHARGE_NOW:\n+                            RemoteServiceUtils.getRemoteService(serviceCommand)\n+                                    .ifPresentOrElse(service -> remot.execute(service), () -> {\n+                                        logger.info(\"Remote service execution {} unknown\", serviceCommand);\n+                                    });\n+                            break;\n+                        case REMOTE_SERVICE_CHARGING_CONTROL:\n+                            sendChargeProfile(chargeProfileEdit);\n+                            break;\n+                        default:\n+                            logger.info(\"Remote service execution {} unknown\", serviceCommand);\n+                            break;\n+                    }\n+                });\n+            }\n+        } else if (CHANNEL_GROUP_VEHICLE_IMAGE.equals(group)) {\n+            // Image Change\n+            configuration.ifPresent(config -> {\n+                if (command instanceof StringType) {\n+                    if (channelUID.getIdWithoutGroup().equals(IMAGE_VIEWPORT)) {\n+                        String newViewport = command.toString();\n+                        synchronized (imageProperties) {\n+                            if (!imageProperties.viewport.equals(newViewport)) {\n+                                imageProperties = new ImageProperties(newViewport, imageProperties.size);\n+                                imageCache = Optional.empty();\n+                                proxy.ifPresent(prox -> prox.requestImage(config, imageProperties, imageCallback));\n+                            }\n+                        }\n+                        updateChannel(CHANNEL_GROUP_VEHICLE_IMAGE, IMAGE_VIEWPORT, StringType.valueOf(newViewport));\n+                    }\n+                }\n+                if (command instanceof DecimalType) {\n+                    if (command instanceof DecimalType) {\n+                        int newImageSize = ((DecimalType) command).intValue();\n+                        if (channelUID.getIdWithoutGroup().equals(IMAGE_SIZE)) {\n+                            synchronized (imageProperties) {\n+                                if (imageProperties.size != newImageSize) {\n+                                    imageProperties = new ImageProperties(imageProperties.viewport, newImageSize);\n+                                    imageCache = Optional.empty();\n+                                    proxy.ifPresent(prox -> prox.requestImage(config, imageProperties, imageCallback));\n+                                }\n+                            }\n+                        }\n+                        updateChannel(CHANNEL_GROUP_VEHICLE_IMAGE, IMAGE_SIZE, new DecimalType(newImageSize));\n+                    }\n+                }\n+            });\n+        } else if (CHANNEL_GROUP_DESTINATION.equals(group)) {\n+            if (command instanceof StringType) {\n+                int index = Converter.getIndex(command.toFullString());\n+                if (index != -1) {\n+                    selectDestination(index);\n+                } else {\n+                    logger.debug(\"Cannot select Destination index {}\", command.toFullString());\n+                }\n+            }\n+        } else if (CHANNEL_GROUP_SERVICE.equals(group)) {\n+            if (command instanceof StringType) {\n+                int index = Converter.getIndex(command.toFullString());\n+                if (index != -1) {\n+                    selectService(index);\n+                } else {\n+                    logger.debug(\"Cannot select Service index {}\", command.toFullString());\n+                }\n+            }\n+        } else if (CHANNEL_GROUP_CHECK_CONTROL.equals(group)) {\n+            if (command instanceof StringType) {\n+                int index = Converter.getIndex(command.toFullString());\n+                if (index != -1) {\n+                    selectCheckControl(index);\n+                } else {\n+                    logger.debug(\"Cannot select CheckControl index {}\", command.toFullString());\n+                }\n+            }\n+        } else if (CHANNEL_GROUP_CHARGE.equals(group)) {\n+            handleChargeProfileCommand(channelUID, command);\n+        }\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        callbackCounter = Optional.of(new ArrayList<ResponseCallback>());\n+        updateStatus(ThingStatus.UNKNOWN);\n+        final VehicleConfiguration config = getConfigAs(VehicleConfiguration.class);\n+        if (config != null) {\n+            configuration = Optional.of(config);\n+            scheduler.execute(() -> {\n+                Bridge bridge = getBridge();\n+                if (bridge != null) {\n+                    BridgeHandler handler = bridge.getHandler();\n+                    if (handler != null) {\n+                        bridgeHandler = Optional.of(((ConnectedDriveBridgeHandler) handler));\n+                        proxy = ((ConnectedDriveBridgeHandler) handler).getProxy();\n+                        remote = proxy.map(prox -> prox.getRemoteServiceHandler(this));\n+                    } else {\n+                        logger.debug(\"Bridge Handler null\");\n+                    }\n+                } else {\n+                    logger.debug(\"Bridge null\");\n+                }\n+\n+                // get Image after init with config values\n+                synchronized (imageProperties) {\n+                    imageProperties = new ImageProperties(config.imageViewport, config.imageSize);\n+                }\n+                updateChannel(CHANNEL_GROUP_VEHICLE_IMAGE, IMAGE_VIEWPORT, StringType.valueOf((config.imageViewport)));\n+                updateChannel(CHANNEL_GROUP_VEHICLE_IMAGE, IMAGE_SIZE, new DecimalType((config.imageSize)));\n+\n+                // check imperial setting is different to AutoDetect\n+                if (!UNITS_AUTODETECT.equals(config.units)) {\n+                    imperial = UNITS_IMPERIAL.equals(config.units);\n+                }\n+\n+                // start update schedule\n+                startSchedule(config.refreshInterval);\n+            });\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR);\n+        }\n+    }\n+\n+    private void startSchedule(int interval) {\n+        refreshJob.ifPresentOrElse(job -> {\n+            if (job.isCancelled()) {\n+                refreshJob = Optional\n+                        .of(scheduler.scheduleWithFixedDelay(this::getData, 0, interval, TimeUnit.MINUTES));\n+            } // else - scheduler is already running!\n+        }, () -> {\n+            refreshJob = Optional.of(scheduler.scheduleWithFixedDelay(this::getData, 0, interval, TimeUnit.MINUTES));\n+        });\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        refreshJob.ifPresent(job -> job.cancel(true));\n+    }\n+\n+    public void getData() {\n+        proxy.ifPresentOrElse(prox -> {\n+            configuration.ifPresentOrElse(config -> {\n+                if (!legacyMode) {\n+                    prox.requestVehcileStatus(config, vehicleStatusCallback);\n+                } else {\n+                    prox.requestLegacyVehcileStatus(config, oldVehicleStatusCallback);\n+                }\n+                addCallback(vehicleStatusCallback);\n+                if (isSupported(Constants.STATISTICS)) {\n+                    prox.requestLastTrip(config, lastTripCallback);\n+                    prox.requestAllTrips(config, allTripsCallback);\n+                    addCallback(lastTripCallback);\n+                    addCallback(allTripsCallback);\n+                }\n+                if (isSupported(Constants.LAST_DESTINATIONS)) {\n+                    prox.requestDestinations(config, destinationCallback);\n+                    addCallback(destinationCallback);\n+                }\n+                if (isElectric) {\n+                    prox.requestChargingProfile(config, chargeProfileCallback);\n+                    addCallback(chargeProfileCallback);\n+                }\n+                synchronized (imageProperties) {\n+                    if (!imageCache.isPresent() && !imageProperties.failLimitReached()) {\n+                        prox.requestImage(config, imageProperties, imageCallback);\n+                        addCallback(imageCallback);\n+                    }\n+                }\n+            }, () -> {\n+                logger.warn(\"ConnectedDrive Configuration isn't present\");\n+            });\n+        }, () -> {\n+            logger.warn(\"ConnectedDrive Proxy isn't present\");\n+        });\n+    }\n+\n+    private synchronized void addCallback(ResponseCallback rc) {\n+        callbackCounter.ifPresent(counter -> counter.add(rc));\n+    }\n+\n+    private synchronized void removeCallback(ResponseCallback rc) {\n+        callbackCounter.ifPresent(counter -> {\n+            counter.remove(rc);\n+            // all necessary callbacks received => print and set to empty\n+            if (counter.isEmpty()) {\n+                logFingerPrint();\n+                callbackCounter = Optional.empty();\n+            }\n+        });\n+    }\n+\n+    private void logFingerPrint() {\n+        final String vin = configuration.map(config -> config.vin).orElse(\"\");\n+        logger.debug(\"###### BMW ConnectedDrive Binding - Vehicle Troubleshoot Fingerprint Data - BEGIN ######\");\n+        logger.debug(\"### Discovery Result ###\");\n+        bridgeHandler.ifPresent(handler -> {\n+            logger.debug(\"{}\", handler.getDiscoveryFingerprint());\n+        });\n+        vehicleStatusCache.ifPresentOrElse(vehicleStatus -> {\n+            logger.debug(\"### Vehicle Status ###\");\n+\n+            // Anonymous data for VIN and Position\n+            try {\n+                VehicleStatusContainer container = Converter.getGson().fromJson(vehicleStatus,\n+                        VehicleStatusContainer.class);\n+                if (container != null) {\n+                    VehicleStatus status = container.vehicleStatus;\n+                    if (status != null) {\n+                        status.vin = Constants.ANONYMOUS;\n+                        if (status.position != null) {\n+                            status.position.lat = -1;\n+                            status.position.lon = -1;\n+                            status.position.heading = -1;\n+                        }\n+                    }\n+                }\n+                logger.debug(\"{}\", Converter.getGson().toJson(container));\n+            } catch (JsonSyntaxException jse) {\n+                logger.debug(\"{}\", jse.getMessage());\n+            }\n+        }, () -> {\n+            logger.debug(\"### Vehicle Status Empty ###\");\n+        });\n+        lastTripCache.ifPresentOrElse(lastTrip -> {\n+            logger.debug(\"### Last Trip ###\");\n+            logger.debug(\"{}\", lastTrip.replaceAll(vin, Constants.ANONYMOUS));\n+        }, () -> {\n+            logger.debug(\"### Last Trip Empty ###\");\n+        });\n+        allTripsCache.ifPresentOrElse(allTrips -> {\n+            logger.debug(\"### All Trips ###\");\n+            logger.debug(\"{}\", allTrips.replaceAll(vin, Constants.ANONYMOUS));\n+        }, () -> {\n+            logger.debug(\"### All Trips Empty ###\");\n+        });\n+        if (isElectric) {\n+            chargeProfileCache.ifPresentOrElse(chargeProfile -> {\n+                logger.debug(\"### Charge Profile ###\");\n+                logger.debug(\"{}\", chargeProfile.replaceAll(vin, Constants.ANONYMOUS));\n+            }, () -> {\n+                logger.debug(\"### Charge Profile Empty ###\");\n+            });\n+        }\n+        destinationCache.ifPresentOrElse(destination -> {\n+            logger.debug(\"### Charge Profile ###\");\n+            try {\n+                DestinationContainer container = Converter.getGson().fromJson(destination, DestinationContainer.class);\n+                if (container != null) {\n+                    if (container.destinations != null) {\n+                        container.destinations.forEach(entry -> {\n+                            entry.lat = 0;\n+                            entry.lon = 0;\n+                            entry.city = Constants.ANONYMOUS;\n+                            entry.street = Constants.ANONYMOUS;\n+                            entry.streetNumber = Constants.ANONYMOUS;\n+                            entry.country = Constants.ANONYMOUS;\n+                        });\n+                        logger.debug(\"{}\", Converter.getGson().toJson(container));\n+                    }\n+                } else {\n+                    logger.debug(\"### Destinations Empty ###\");\n+                }\n+            } catch (JsonSyntaxException jse) {\n+                logger.debug(\"{}\", jse.getMessage());\n+            }\n+        }, () -> {\n+            logger.debug(\"### Charge Profile Empty ###\");\n+        });\n+        rangeMapCache.ifPresentOrElse(rangeMap -> {\n+            logger.debug(\"### Range Map ###\");\n+            logger.debug(\"{}\", rangeMap.replaceAll(vin, Constants.ANONYMOUS));\n+        }, () -> {\n+            logger.debug(\"### Range Map Empty ###\");\n+        });\n+        logger.debug(\"###### BMW ConnectedDrive Binding - Vehicle Troubleshoot Fingerprint Data - END ######\");\n+    }\n+\n+    /**\n+     * Don't stress ConnectedDrive with unnecessary requests. One call at the beginning is done to check the response.\n+     * After cache has e.g. a proper error response it will be shown in the fingerprint\n+     *\n+     * @return\n+     */\n+    private boolean isSupported(String service) {\n+        final String services = thing.getProperties().get(Constants.SERVICES_SUPPORTED);\n+        if (services != null) {\n+            if (services.contains(service)) {\n+                return true;\n+            }\n+        }\n+        // if cache is empty give it a try one time to collected Troubleshoot data\n+        if (lastTripCache.isEmpty() || allTripsCache.isEmpty() || destinationCache.isEmpty()) {\n+            return true;\n+        } else {\n+            return false;\n+        }\n+    }\n+\n+    public void updateRemoteExecutionStatus(@Nullable String service, @Nullable String status) {\n+        if (RemoteService.CHARGING_CONTROL.toString().equals(service)\n+                && ExecutionState.EXECUTED.name().equals(status)) {\n+            saveChargeProfileSent();\n+        }\n+        updateChannel(CHANNEL_GROUP_REMOTE, REMOTE_STATE, StringType.valueOf(Converter.toTitleCase(\n+                new StringBuilder(service == null ? \"-\" : service).append(\" \").append(status).toString())));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "48af48c82562d006b6f2aa35922270f181c885ed"}, "originalPosition": 438}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5ODI5NzkwMQ==", "bodyText": "fixed in weymann#10", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r598297901", "createdAt": "2021-03-21T15:40:31Z", "author": {"login": "ntruchsess"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/VehicleHandler.java", "diffHunk": "@@ -0,0 +1,826 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bmwconnecteddrive.internal.handler;\n+\n+import static org.openhab.binding.bmwconnecteddrive.internal.ConnectedDriveConstants.*;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.bmwconnecteddrive.internal.VehicleConfiguration;\n+import org.openhab.binding.bmwconnecteddrive.internal.action.ChargeProfileActions;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.DestinationContainer;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.NetworkError;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.compat.VehicleAttributesContainer;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.statistics.AllTrips;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.statistics.AllTripsContainer;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.statistics.LastTrip;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.statistics.LastTripContainer;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.status.VehicleStatus;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.status.VehicleStatusContainer;\n+import org.openhab.binding.bmwconnecteddrive.internal.handler.RemoteServiceHandler.ExecutionState;\n+import org.openhab.binding.bmwconnecteddrive.internal.handler.RemoteServiceHandler.RemoteService;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileUtils;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileUtils.ChargeKeyDay;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileUtils.ChargeKeyHour;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileWrapper;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileWrapper.ProfileKey;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Constants;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Converter;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ImageProperties;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.RemoteServiceUtils;\n+import org.openhab.core.io.net.http.HttpUtil;\n+import org.openhab.core.library.types.DecimalType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.RawType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BridgeHandler;\n+import org.openhab.core.thing.binding.ThingHandlerService;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+\n+import com.google.gson.JsonSyntaxException;\n+\n+/**\n+ * The {@link VehicleHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Bernd Weymann - Initial contribution\n+ * @author Norbert Truchsess - edit & send charge profile\n+ */\n+@NonNullByDefault\n+public class VehicleHandler extends VehicleChannelHandler {\n+    private boolean legacyMode = false; // switch to legacy API in case of 404 Errors\n+\n+    private Optional<ConnectedDriveProxy> proxy = Optional.empty();\n+    private Optional<RemoteServiceHandler> remote = Optional.empty();\n+    private Optional<VehicleConfiguration> configuration = Optional.empty();\n+    private Optional<ConnectedDriveBridgeHandler> bridgeHandler = Optional.empty();\n+    private Optional<ScheduledFuture<?>> refreshJob = Optional.empty();\n+    private Optional<ScheduledFuture<?>> editTimeout = Optional.empty();\n+    private Optional<List<ResponseCallback>> callbackCounter = Optional.empty();\n+\n+    private ImageProperties imageProperties = new ImageProperties();\n+    VehicleStatusCallback vehicleStatusCallback = new VehicleStatusCallback();\n+    StringResponseCallback oldVehicleStatusCallback = new LegacyVehicleStatusCallback();\n+    StringResponseCallback lastTripCallback = new LastTripCallback();\n+    StringResponseCallback allTripsCallback = new AllTripsCallback();\n+    StringResponseCallback chargeProfileCallback = new ChargeProfilesCallback();\n+    StringResponseCallback rangeMapCallback = new RangeMapCallback();\n+    DestinationsCallback destinationCallback = new DestinationsCallback();\n+    ByteResponseCallback imageCallback = new ImageCallback();\n+\n+    private Optional<ChargeProfileWrapper> chargeProfileEdit = Optional.empty();\n+    private Optional<String> chargeProfileSent = Optional.empty();\n+\n+    public VehicleHandler(Thing thing, BMWConnectedDriveOptionProvider op, String type, boolean imperial) {\n+        super(thing, op, type, imperial);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        String group = channelUID.getGroupId();\n+\n+        // Refresh of Channels with cached values\n+        if (command instanceof RefreshType) {\n+            if (CHANNEL_GROUP_LAST_TRIP.equals(group)) {\n+                lastTripCache.ifPresent(lastTrip -> lastTripCallback.onResponse(lastTrip));\n+            } else if (CHANNEL_GROUP_LIFETIME.equals(group)) {\n+                allTripsCache.ifPresent(allTrips -> allTripsCallback.onResponse(allTrips));\n+            } else if (CHANNEL_GROUP_DESTINATION.equals(group)) {\n+                destinationCache.ifPresent(destination -> destinationCallback.onResponse(destination));\n+            } else if (CHANNEL_GROUP_STATUS.equals(group)) {\n+                vehicleStatusCache.ifPresent(vehicleStatus -> vehicleStatusCallback.onResponse(vehicleStatus));\n+            } else if (CHANNEL_GROUP_CHARGE.equals(group)) {\n+                chargeProfileEdit.ifPresentOrElse(this::updateChargeProfile,\n+                        () -> chargeProfileCache.ifPresent(this::updateChargeProfileFromContent));\n+            } else if (CHANNEL_GROUP_VEHICLE_IMAGE.equals(group)) {\n+                imageCache.ifPresent(image -> imageCallback.onResponse(image));\n+            }\n+            // Check for Channel Group and corresponding Actions\n+        } else if (CHANNEL_GROUP_REMOTE.equals(group)) {\n+            // Executing Remote Services\n+            if (command instanceof StringType) {\n+                String serviceCommand = ((StringType) command).toFullString();\n+                remote.ifPresent(remot -> {\n+                    switch (serviceCommand) {\n+                        case REMOTE_SERVICE_LIGHT_FLASH:\n+                        case REMOTE_SERVICE_AIR_CONDITIONING:\n+                        case REMOTE_SERVICE_DOOR_LOCK:\n+                        case REMOTE_SERVICE_DOOR_UNLOCK:\n+                        case REMOTE_SERVICE_HORN:\n+                        case REMOTE_SERVICE_VEHICLE_FINDER:\n+                        case REMOTE_SERVICE_CHARGE_NOW:\n+                            RemoteServiceUtils.getRemoteService(serviceCommand)\n+                                    .ifPresentOrElse(service -> remot.execute(service), () -> {\n+                                        logger.info(\"Remote service execution {} unknown\", serviceCommand);\n+                                    });\n+                            break;\n+                        case REMOTE_SERVICE_CHARGING_CONTROL:\n+                            sendChargeProfile(chargeProfileEdit);\n+                            break;\n+                        default:\n+                            logger.info(\"Remote service execution {} unknown\", serviceCommand);\n+                            break;\n+                    }\n+                });\n+            }\n+        } else if (CHANNEL_GROUP_VEHICLE_IMAGE.equals(group)) {\n+            // Image Change\n+            configuration.ifPresent(config -> {\n+                if (command instanceof StringType) {\n+                    if (channelUID.getIdWithoutGroup().equals(IMAGE_VIEWPORT)) {\n+                        String newViewport = command.toString();\n+                        synchronized (imageProperties) {\n+                            if (!imageProperties.viewport.equals(newViewport)) {\n+                                imageProperties = new ImageProperties(newViewport, imageProperties.size);\n+                                imageCache = Optional.empty();\n+                                proxy.ifPresent(prox -> prox.requestImage(config, imageProperties, imageCallback));\n+                            }\n+                        }\n+                        updateChannel(CHANNEL_GROUP_VEHICLE_IMAGE, IMAGE_VIEWPORT, StringType.valueOf(newViewport));\n+                    }\n+                }\n+                if (command instanceof DecimalType) {\n+                    if (command instanceof DecimalType) {\n+                        int newImageSize = ((DecimalType) command).intValue();\n+                        if (channelUID.getIdWithoutGroup().equals(IMAGE_SIZE)) {\n+                            synchronized (imageProperties) {\n+                                if (imageProperties.size != newImageSize) {\n+                                    imageProperties = new ImageProperties(imageProperties.viewport, newImageSize);\n+                                    imageCache = Optional.empty();\n+                                    proxy.ifPresent(prox -> prox.requestImage(config, imageProperties, imageCallback));\n+                                }\n+                            }\n+                        }\n+                        updateChannel(CHANNEL_GROUP_VEHICLE_IMAGE, IMAGE_SIZE, new DecimalType(newImageSize));\n+                    }\n+                }\n+            });\n+        } else if (CHANNEL_GROUP_DESTINATION.equals(group)) {\n+            if (command instanceof StringType) {\n+                int index = Converter.getIndex(command.toFullString());\n+                if (index != -1) {\n+                    selectDestination(index);\n+                } else {\n+                    logger.debug(\"Cannot select Destination index {}\", command.toFullString());\n+                }\n+            }\n+        } else if (CHANNEL_GROUP_SERVICE.equals(group)) {\n+            if (command instanceof StringType) {\n+                int index = Converter.getIndex(command.toFullString());\n+                if (index != -1) {\n+                    selectService(index);\n+                } else {\n+                    logger.debug(\"Cannot select Service index {}\", command.toFullString());\n+                }\n+            }\n+        } else if (CHANNEL_GROUP_CHECK_CONTROL.equals(group)) {\n+            if (command instanceof StringType) {\n+                int index = Converter.getIndex(command.toFullString());\n+                if (index != -1) {\n+                    selectCheckControl(index);\n+                } else {\n+                    logger.debug(\"Cannot select CheckControl index {}\", command.toFullString());\n+                }\n+            }\n+        } else if (CHANNEL_GROUP_CHARGE.equals(group)) {\n+            handleChargeProfileCommand(channelUID, command);\n+        }\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        callbackCounter = Optional.of(new ArrayList<ResponseCallback>());\n+        updateStatus(ThingStatus.UNKNOWN);\n+        final VehicleConfiguration config = getConfigAs(VehicleConfiguration.class);\n+        if (config != null) {\n+            configuration = Optional.of(config);\n+            scheduler.execute(() -> {\n+                Bridge bridge = getBridge();\n+                if (bridge != null) {\n+                    BridgeHandler handler = bridge.getHandler();\n+                    if (handler != null) {\n+                        bridgeHandler = Optional.of(((ConnectedDriveBridgeHandler) handler));\n+                        proxy = ((ConnectedDriveBridgeHandler) handler).getProxy();\n+                        remote = proxy.map(prox -> prox.getRemoteServiceHandler(this));\n+                    } else {\n+                        logger.debug(\"Bridge Handler null\");\n+                    }\n+                } else {\n+                    logger.debug(\"Bridge null\");\n+                }\n+\n+                // get Image after init with config values\n+                synchronized (imageProperties) {\n+                    imageProperties = new ImageProperties(config.imageViewport, config.imageSize);\n+                }\n+                updateChannel(CHANNEL_GROUP_VEHICLE_IMAGE, IMAGE_VIEWPORT, StringType.valueOf((config.imageViewport)));\n+                updateChannel(CHANNEL_GROUP_VEHICLE_IMAGE, IMAGE_SIZE, new DecimalType((config.imageSize)));\n+\n+                // check imperial setting is different to AutoDetect\n+                if (!UNITS_AUTODETECT.equals(config.units)) {\n+                    imperial = UNITS_IMPERIAL.equals(config.units);\n+                }\n+\n+                // start update schedule\n+                startSchedule(config.refreshInterval);\n+            });\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR);\n+        }\n+    }\n+\n+    private void startSchedule(int interval) {\n+        refreshJob.ifPresentOrElse(job -> {\n+            if (job.isCancelled()) {\n+                refreshJob = Optional\n+                        .of(scheduler.scheduleWithFixedDelay(this::getData, 0, interval, TimeUnit.MINUTES));\n+            } // else - scheduler is already running!\n+        }, () -> {\n+            refreshJob = Optional.of(scheduler.scheduleWithFixedDelay(this::getData, 0, interval, TimeUnit.MINUTES));\n+        });\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        refreshJob.ifPresent(job -> job.cancel(true));\n+    }\n+\n+    public void getData() {\n+        proxy.ifPresentOrElse(prox -> {\n+            configuration.ifPresentOrElse(config -> {\n+                if (!legacyMode) {\n+                    prox.requestVehcileStatus(config, vehicleStatusCallback);\n+                } else {\n+                    prox.requestLegacyVehcileStatus(config, oldVehicleStatusCallback);\n+                }\n+                addCallback(vehicleStatusCallback);\n+                if (isSupported(Constants.STATISTICS)) {\n+                    prox.requestLastTrip(config, lastTripCallback);\n+                    prox.requestAllTrips(config, allTripsCallback);\n+                    addCallback(lastTripCallback);\n+                    addCallback(allTripsCallback);\n+                }\n+                if (isSupported(Constants.LAST_DESTINATIONS)) {\n+                    prox.requestDestinations(config, destinationCallback);\n+                    addCallback(destinationCallback);\n+                }\n+                if (isElectric) {\n+                    prox.requestChargingProfile(config, chargeProfileCallback);\n+                    addCallback(chargeProfileCallback);\n+                }\n+                synchronized (imageProperties) {\n+                    if (!imageCache.isPresent() && !imageProperties.failLimitReached()) {\n+                        prox.requestImage(config, imageProperties, imageCallback);\n+                        addCallback(imageCallback);\n+                    }\n+                }\n+            }, () -> {\n+                logger.warn(\"ConnectedDrive Configuration isn't present\");\n+            });\n+        }, () -> {\n+            logger.warn(\"ConnectedDrive Proxy isn't present\");\n+        });\n+    }\n+\n+    private synchronized void addCallback(ResponseCallback rc) {\n+        callbackCounter.ifPresent(counter -> counter.add(rc));\n+    }\n+\n+    private synchronized void removeCallback(ResponseCallback rc) {\n+        callbackCounter.ifPresent(counter -> {\n+            counter.remove(rc);\n+            // all necessary callbacks received => print and set to empty\n+            if (counter.isEmpty()) {\n+                logFingerPrint();\n+                callbackCounter = Optional.empty();\n+            }\n+        });\n+    }\n+\n+    private void logFingerPrint() {\n+        final String vin = configuration.map(config -> config.vin).orElse(\"\");\n+        logger.debug(\"###### BMW ConnectedDrive Binding - Vehicle Troubleshoot Fingerprint Data - BEGIN ######\");\n+        logger.debug(\"### Discovery Result ###\");\n+        bridgeHandler.ifPresent(handler -> {\n+            logger.debug(\"{}\", handler.getDiscoveryFingerprint());\n+        });\n+        vehicleStatusCache.ifPresentOrElse(vehicleStatus -> {\n+            logger.debug(\"### Vehicle Status ###\");\n+\n+            // Anonymous data for VIN and Position\n+            try {\n+                VehicleStatusContainer container = Converter.getGson().fromJson(vehicleStatus,\n+                        VehicleStatusContainer.class);\n+                if (container != null) {\n+                    VehicleStatus status = container.vehicleStatus;\n+                    if (status != null) {\n+                        status.vin = Constants.ANONYMOUS;\n+                        if (status.position != null) {\n+                            status.position.lat = -1;\n+                            status.position.lon = -1;\n+                            status.position.heading = -1;\n+                        }\n+                    }\n+                }\n+                logger.debug(\"{}\", Converter.getGson().toJson(container));\n+            } catch (JsonSyntaxException jse) {\n+                logger.debug(\"{}\", jse.getMessage());\n+            }\n+        }, () -> {\n+            logger.debug(\"### Vehicle Status Empty ###\");\n+        });\n+        lastTripCache.ifPresentOrElse(lastTrip -> {\n+            logger.debug(\"### Last Trip ###\");\n+            logger.debug(\"{}\", lastTrip.replaceAll(vin, Constants.ANONYMOUS));\n+        }, () -> {\n+            logger.debug(\"### Last Trip Empty ###\");\n+        });\n+        allTripsCache.ifPresentOrElse(allTrips -> {\n+            logger.debug(\"### All Trips ###\");\n+            logger.debug(\"{}\", allTrips.replaceAll(vin, Constants.ANONYMOUS));\n+        }, () -> {\n+            logger.debug(\"### All Trips Empty ###\");\n+        });\n+        if (isElectric) {\n+            chargeProfileCache.ifPresentOrElse(chargeProfile -> {\n+                logger.debug(\"### Charge Profile ###\");\n+                logger.debug(\"{}\", chargeProfile.replaceAll(vin, Constants.ANONYMOUS));\n+            }, () -> {\n+                logger.debug(\"### Charge Profile Empty ###\");\n+            });\n+        }\n+        destinationCache.ifPresentOrElse(destination -> {\n+            logger.debug(\"### Charge Profile ###\");\n+            try {\n+                DestinationContainer container = Converter.getGson().fromJson(destination, DestinationContainer.class);\n+                if (container != null) {\n+                    if (container.destinations != null) {\n+                        container.destinations.forEach(entry -> {\n+                            entry.lat = 0;\n+                            entry.lon = 0;\n+                            entry.city = Constants.ANONYMOUS;\n+                            entry.street = Constants.ANONYMOUS;\n+                            entry.streetNumber = Constants.ANONYMOUS;\n+                            entry.country = Constants.ANONYMOUS;\n+                        });\n+                        logger.debug(\"{}\", Converter.getGson().toJson(container));\n+                    }\n+                } else {\n+                    logger.debug(\"### Destinations Empty ###\");\n+                }\n+            } catch (JsonSyntaxException jse) {\n+                logger.debug(\"{}\", jse.getMessage());\n+            }\n+        }, () -> {\n+            logger.debug(\"### Charge Profile Empty ###\");\n+        });\n+        rangeMapCache.ifPresentOrElse(rangeMap -> {\n+            logger.debug(\"### Range Map ###\");\n+            logger.debug(\"{}\", rangeMap.replaceAll(vin, Constants.ANONYMOUS));\n+        }, () -> {\n+            logger.debug(\"### Range Map Empty ###\");\n+        });\n+        logger.debug(\"###### BMW ConnectedDrive Binding - Vehicle Troubleshoot Fingerprint Data - END ######\");\n+    }\n+\n+    /**\n+     * Don't stress ConnectedDrive with unnecessary requests. One call at the beginning is done to check the response.\n+     * After cache has e.g. a proper error response it will be shown in the fingerprint\n+     *\n+     * @return\n+     */\n+    private boolean isSupported(String service) {\n+        final String services = thing.getProperties().get(Constants.SERVICES_SUPPORTED);\n+        if (services != null) {\n+            if (services.contains(service)) {\n+                return true;\n+            }\n+        }\n+        // if cache is empty give it a try one time to collected Troubleshoot data\n+        if (lastTripCache.isEmpty() || allTripsCache.isEmpty() || destinationCache.isEmpty()) {\n+            return true;\n+        } else {\n+            return false;\n+        }\n+    }\n+\n+    public void updateRemoteExecutionStatus(@Nullable String service, @Nullable String status) {\n+        if (RemoteService.CHARGING_CONTROL.toString().equals(service)\n+                && ExecutionState.EXECUTED.name().equals(status)) {\n+            saveChargeProfileSent();\n+        }\n+        updateChannel(CHANNEL_GROUP_REMOTE, REMOTE_STATE, StringType.valueOf(Converter.toTitleCase(\n+                new StringBuilder(service == null ? \"-\" : service).append(\" \").append(status).toString())));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5NzkxODgwNQ=="}, "originalCommit": {"oid": "48af48c82562d006b6f2aa35922270f181c885ed"}, "originalPosition": 438}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzc3Njc4MDIxOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/VehicleHandler.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0xOVQxOToxNDo1NFrOI6OGYA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0yNFQwMDoxNzowN1rOI8QM3w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5NzkxOTMyOA==", "bodyText": "This could be removed.", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r597919328", "createdAt": "2021-03-19T19:14:54Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/VehicleHandler.java", "diffHunk": "@@ -0,0 +1,826 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bmwconnecteddrive.internal.handler;\n+\n+import static org.openhab.binding.bmwconnecteddrive.internal.ConnectedDriveConstants.*;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.bmwconnecteddrive.internal.VehicleConfiguration;\n+import org.openhab.binding.bmwconnecteddrive.internal.action.ChargeProfileActions;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.DestinationContainer;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.NetworkError;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.compat.VehicleAttributesContainer;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.statistics.AllTrips;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.statistics.AllTripsContainer;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.statistics.LastTrip;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.statistics.LastTripContainer;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.status.VehicleStatus;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.status.VehicleStatusContainer;\n+import org.openhab.binding.bmwconnecteddrive.internal.handler.RemoteServiceHandler.ExecutionState;\n+import org.openhab.binding.bmwconnecteddrive.internal.handler.RemoteServiceHandler.RemoteService;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileUtils;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileUtils.ChargeKeyDay;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileUtils.ChargeKeyHour;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileWrapper;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileWrapper.ProfileKey;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Constants;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Converter;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ImageProperties;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.RemoteServiceUtils;\n+import org.openhab.core.io.net.http.HttpUtil;\n+import org.openhab.core.library.types.DecimalType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.RawType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BridgeHandler;\n+import org.openhab.core.thing.binding.ThingHandlerService;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+\n+import com.google.gson.JsonSyntaxException;\n+\n+/**\n+ * The {@link VehicleHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Bernd Weymann - Initial contribution\n+ * @author Norbert Truchsess - edit & send charge profile\n+ */\n+@NonNullByDefault\n+public class VehicleHandler extends VehicleChannelHandler {\n+    private boolean legacyMode = false; // switch to legacy API in case of 404 Errors\n+\n+    private Optional<ConnectedDriveProxy> proxy = Optional.empty();\n+    private Optional<RemoteServiceHandler> remote = Optional.empty();\n+    private Optional<VehicleConfiguration> configuration = Optional.empty();\n+    private Optional<ConnectedDriveBridgeHandler> bridgeHandler = Optional.empty();\n+    private Optional<ScheduledFuture<?>> refreshJob = Optional.empty();\n+    private Optional<ScheduledFuture<?>> editTimeout = Optional.empty();\n+    private Optional<List<ResponseCallback>> callbackCounter = Optional.empty();\n+\n+    private ImageProperties imageProperties = new ImageProperties();\n+    VehicleStatusCallback vehicleStatusCallback = new VehicleStatusCallback();\n+    StringResponseCallback oldVehicleStatusCallback = new LegacyVehicleStatusCallback();\n+    StringResponseCallback lastTripCallback = new LastTripCallback();\n+    StringResponseCallback allTripsCallback = new AllTripsCallback();\n+    StringResponseCallback chargeProfileCallback = new ChargeProfilesCallback();\n+    StringResponseCallback rangeMapCallback = new RangeMapCallback();\n+    DestinationsCallback destinationCallback = new DestinationsCallback();\n+    ByteResponseCallback imageCallback = new ImageCallback();\n+\n+    private Optional<ChargeProfileWrapper> chargeProfileEdit = Optional.empty();\n+    private Optional<String> chargeProfileSent = Optional.empty();\n+\n+    public VehicleHandler(Thing thing, BMWConnectedDriveOptionProvider op, String type, boolean imperial) {\n+        super(thing, op, type, imperial);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        String group = channelUID.getGroupId();\n+\n+        // Refresh of Channels with cached values\n+        if (command instanceof RefreshType) {\n+            if (CHANNEL_GROUP_LAST_TRIP.equals(group)) {\n+                lastTripCache.ifPresent(lastTrip -> lastTripCallback.onResponse(lastTrip));\n+            } else if (CHANNEL_GROUP_LIFETIME.equals(group)) {\n+                allTripsCache.ifPresent(allTrips -> allTripsCallback.onResponse(allTrips));\n+            } else if (CHANNEL_GROUP_DESTINATION.equals(group)) {\n+                destinationCache.ifPresent(destination -> destinationCallback.onResponse(destination));\n+            } else if (CHANNEL_GROUP_STATUS.equals(group)) {\n+                vehicleStatusCache.ifPresent(vehicleStatus -> vehicleStatusCallback.onResponse(vehicleStatus));\n+            } else if (CHANNEL_GROUP_CHARGE.equals(group)) {\n+                chargeProfileEdit.ifPresentOrElse(this::updateChargeProfile,\n+                        () -> chargeProfileCache.ifPresent(this::updateChargeProfileFromContent));\n+            } else if (CHANNEL_GROUP_VEHICLE_IMAGE.equals(group)) {\n+                imageCache.ifPresent(image -> imageCallback.onResponse(image));\n+            }\n+            // Check for Channel Group and corresponding Actions\n+        } else if (CHANNEL_GROUP_REMOTE.equals(group)) {\n+            // Executing Remote Services\n+            if (command instanceof StringType) {\n+                String serviceCommand = ((StringType) command).toFullString();\n+                remote.ifPresent(remot -> {\n+                    switch (serviceCommand) {\n+                        case REMOTE_SERVICE_LIGHT_FLASH:\n+                        case REMOTE_SERVICE_AIR_CONDITIONING:\n+                        case REMOTE_SERVICE_DOOR_LOCK:\n+                        case REMOTE_SERVICE_DOOR_UNLOCK:\n+                        case REMOTE_SERVICE_HORN:\n+                        case REMOTE_SERVICE_VEHICLE_FINDER:\n+                        case REMOTE_SERVICE_CHARGE_NOW:\n+                            RemoteServiceUtils.getRemoteService(serviceCommand)\n+                                    .ifPresentOrElse(service -> remot.execute(service), () -> {\n+                                        logger.info(\"Remote service execution {} unknown\", serviceCommand);\n+                                    });\n+                            break;\n+                        case REMOTE_SERVICE_CHARGING_CONTROL:\n+                            sendChargeProfile(chargeProfileEdit);\n+                            break;\n+                        default:\n+                            logger.info(\"Remote service execution {} unknown\", serviceCommand);\n+                            break;\n+                    }\n+                });\n+            }\n+        } else if (CHANNEL_GROUP_VEHICLE_IMAGE.equals(group)) {\n+            // Image Change\n+            configuration.ifPresent(config -> {\n+                if (command instanceof StringType) {\n+                    if (channelUID.getIdWithoutGroup().equals(IMAGE_VIEWPORT)) {\n+                        String newViewport = command.toString();\n+                        synchronized (imageProperties) {\n+                            if (!imageProperties.viewport.equals(newViewport)) {\n+                                imageProperties = new ImageProperties(newViewport, imageProperties.size);\n+                                imageCache = Optional.empty();\n+                                proxy.ifPresent(prox -> prox.requestImage(config, imageProperties, imageCallback));\n+                            }\n+                        }\n+                        updateChannel(CHANNEL_GROUP_VEHICLE_IMAGE, IMAGE_VIEWPORT, StringType.valueOf(newViewport));\n+                    }\n+                }\n+                if (command instanceof DecimalType) {\n+                    if (command instanceof DecimalType) {\n+                        int newImageSize = ((DecimalType) command).intValue();\n+                        if (channelUID.getIdWithoutGroup().equals(IMAGE_SIZE)) {\n+                            synchronized (imageProperties) {\n+                                if (imageProperties.size != newImageSize) {\n+                                    imageProperties = new ImageProperties(imageProperties.viewport, newImageSize);\n+                                    imageCache = Optional.empty();\n+                                    proxy.ifPresent(prox -> prox.requestImage(config, imageProperties, imageCallback));\n+                                }\n+                            }\n+                        }\n+                        updateChannel(CHANNEL_GROUP_VEHICLE_IMAGE, IMAGE_SIZE, new DecimalType(newImageSize));\n+                    }\n+                }\n+            });\n+        } else if (CHANNEL_GROUP_DESTINATION.equals(group)) {\n+            if (command instanceof StringType) {\n+                int index = Converter.getIndex(command.toFullString());\n+                if (index != -1) {\n+                    selectDestination(index);\n+                } else {\n+                    logger.debug(\"Cannot select Destination index {}\", command.toFullString());\n+                }\n+            }\n+        } else if (CHANNEL_GROUP_SERVICE.equals(group)) {\n+            if (command instanceof StringType) {\n+                int index = Converter.getIndex(command.toFullString());\n+                if (index != -1) {\n+                    selectService(index);\n+                } else {\n+                    logger.debug(\"Cannot select Service index {}\", command.toFullString());\n+                }\n+            }\n+        } else if (CHANNEL_GROUP_CHECK_CONTROL.equals(group)) {\n+            if (command instanceof StringType) {\n+                int index = Converter.getIndex(command.toFullString());\n+                if (index != -1) {\n+                    selectCheckControl(index);\n+                } else {\n+                    logger.debug(\"Cannot select CheckControl index {}\", command.toFullString());\n+                }\n+            }\n+        } else if (CHANNEL_GROUP_CHARGE.equals(group)) {\n+            handleChargeProfileCommand(channelUID, command);\n+        }\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        callbackCounter = Optional.of(new ArrayList<ResponseCallback>());\n+        updateStatus(ThingStatus.UNKNOWN);\n+        final VehicleConfiguration config = getConfigAs(VehicleConfiguration.class);\n+        if (config != null) {\n+            configuration = Optional.of(config);\n+            scheduler.execute(() -> {\n+                Bridge bridge = getBridge();\n+                if (bridge != null) {\n+                    BridgeHandler handler = bridge.getHandler();\n+                    if (handler != null) {\n+                        bridgeHandler = Optional.of(((ConnectedDriveBridgeHandler) handler));\n+                        proxy = ((ConnectedDriveBridgeHandler) handler).getProxy();\n+                        remote = proxy.map(prox -> prox.getRemoteServiceHandler(this));\n+                    } else {\n+                        logger.debug(\"Bridge Handler null\");\n+                    }\n+                } else {\n+                    logger.debug(\"Bridge null\");\n+                }\n+\n+                // get Image after init with config values\n+                synchronized (imageProperties) {\n+                    imageProperties = new ImageProperties(config.imageViewport, config.imageSize);\n+                }\n+                updateChannel(CHANNEL_GROUP_VEHICLE_IMAGE, IMAGE_VIEWPORT, StringType.valueOf((config.imageViewport)));\n+                updateChannel(CHANNEL_GROUP_VEHICLE_IMAGE, IMAGE_SIZE, new DecimalType((config.imageSize)));\n+\n+                // check imperial setting is different to AutoDetect\n+                if (!UNITS_AUTODETECT.equals(config.units)) {\n+                    imperial = UNITS_IMPERIAL.equals(config.units);\n+                }\n+\n+                // start update schedule\n+                startSchedule(config.refreshInterval);\n+            });\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR);\n+        }\n+    }\n+\n+    private void startSchedule(int interval) {\n+        refreshJob.ifPresentOrElse(job -> {\n+            if (job.isCancelled()) {\n+                refreshJob = Optional\n+                        .of(scheduler.scheduleWithFixedDelay(this::getData, 0, interval, TimeUnit.MINUTES));\n+            } // else - scheduler is already running!\n+        }, () -> {\n+            refreshJob = Optional.of(scheduler.scheduleWithFixedDelay(this::getData, 0, interval, TimeUnit.MINUTES));\n+        });\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        refreshJob.ifPresent(job -> job.cancel(true));\n+    }\n+\n+    public void getData() {\n+        proxy.ifPresentOrElse(prox -> {\n+            configuration.ifPresentOrElse(config -> {\n+                if (!legacyMode) {\n+                    prox.requestVehcileStatus(config, vehicleStatusCallback);\n+                } else {\n+                    prox.requestLegacyVehcileStatus(config, oldVehicleStatusCallback);\n+                }\n+                addCallback(vehicleStatusCallback);\n+                if (isSupported(Constants.STATISTICS)) {\n+                    prox.requestLastTrip(config, lastTripCallback);\n+                    prox.requestAllTrips(config, allTripsCallback);\n+                    addCallback(lastTripCallback);\n+                    addCallback(allTripsCallback);\n+                }\n+                if (isSupported(Constants.LAST_DESTINATIONS)) {\n+                    prox.requestDestinations(config, destinationCallback);\n+                    addCallback(destinationCallback);\n+                }\n+                if (isElectric) {\n+                    prox.requestChargingProfile(config, chargeProfileCallback);\n+                    addCallback(chargeProfileCallback);\n+                }\n+                synchronized (imageProperties) {\n+                    if (!imageCache.isPresent() && !imageProperties.failLimitReached()) {\n+                        prox.requestImage(config, imageProperties, imageCallback);\n+                        addCallback(imageCallback);\n+                    }\n+                }\n+            }, () -> {\n+                logger.warn(\"ConnectedDrive Configuration isn't present\");\n+            });\n+        }, () -> {\n+            logger.warn(\"ConnectedDrive Proxy isn't present\");\n+        });\n+    }\n+\n+    private synchronized void addCallback(ResponseCallback rc) {\n+        callbackCounter.ifPresent(counter -> counter.add(rc));\n+    }\n+\n+    private synchronized void removeCallback(ResponseCallback rc) {\n+        callbackCounter.ifPresent(counter -> {\n+            counter.remove(rc);\n+            // all necessary callbacks received => print and set to empty\n+            if (counter.isEmpty()) {\n+                logFingerPrint();\n+                callbackCounter = Optional.empty();\n+            }\n+        });\n+    }\n+\n+    private void logFingerPrint() {\n+        final String vin = configuration.map(config -> config.vin).orElse(\"\");\n+        logger.debug(\"###### BMW ConnectedDrive Binding - Vehicle Troubleshoot Fingerprint Data - BEGIN ######\");\n+        logger.debug(\"### Discovery Result ###\");\n+        bridgeHandler.ifPresent(handler -> {\n+            logger.debug(\"{}\", handler.getDiscoveryFingerprint());\n+        });\n+        vehicleStatusCache.ifPresentOrElse(vehicleStatus -> {\n+            logger.debug(\"### Vehicle Status ###\");\n+\n+            // Anonymous data for VIN and Position\n+            try {\n+                VehicleStatusContainer container = Converter.getGson().fromJson(vehicleStatus,\n+                        VehicleStatusContainer.class);\n+                if (container != null) {\n+                    VehicleStatus status = container.vehicleStatus;\n+                    if (status != null) {\n+                        status.vin = Constants.ANONYMOUS;\n+                        if (status.position != null) {\n+                            status.position.lat = -1;\n+                            status.position.lon = -1;\n+                            status.position.heading = -1;\n+                        }\n+                    }\n+                }\n+                logger.debug(\"{}\", Converter.getGson().toJson(container));\n+            } catch (JsonSyntaxException jse) {\n+                logger.debug(\"{}\", jse.getMessage());\n+            }\n+        }, () -> {\n+            logger.debug(\"### Vehicle Status Empty ###\");\n+        });\n+        lastTripCache.ifPresentOrElse(lastTrip -> {\n+            logger.debug(\"### Last Trip ###\");\n+            logger.debug(\"{}\", lastTrip.replaceAll(vin, Constants.ANONYMOUS));\n+        }, () -> {\n+            logger.debug(\"### Last Trip Empty ###\");\n+        });\n+        allTripsCache.ifPresentOrElse(allTrips -> {\n+            logger.debug(\"### All Trips ###\");\n+            logger.debug(\"{}\", allTrips.replaceAll(vin, Constants.ANONYMOUS));\n+        }, () -> {\n+            logger.debug(\"### All Trips Empty ###\");\n+        });\n+        if (isElectric) {\n+            chargeProfileCache.ifPresentOrElse(chargeProfile -> {\n+                logger.debug(\"### Charge Profile ###\");\n+                logger.debug(\"{}\", chargeProfile.replaceAll(vin, Constants.ANONYMOUS));\n+            }, () -> {\n+                logger.debug(\"### Charge Profile Empty ###\");\n+            });\n+        }\n+        destinationCache.ifPresentOrElse(destination -> {\n+            logger.debug(\"### Charge Profile ###\");\n+            try {\n+                DestinationContainer container = Converter.getGson().fromJson(destination, DestinationContainer.class);\n+                if (container != null) {\n+                    if (container.destinations != null) {\n+                        container.destinations.forEach(entry -> {\n+                            entry.lat = 0;\n+                            entry.lon = 0;\n+                            entry.city = Constants.ANONYMOUS;\n+                            entry.street = Constants.ANONYMOUS;\n+                            entry.streetNumber = Constants.ANONYMOUS;\n+                            entry.country = Constants.ANONYMOUS;\n+                        });\n+                        logger.debug(\"{}\", Converter.getGson().toJson(container));\n+                    }\n+                } else {\n+                    logger.debug(\"### Destinations Empty ###\");\n+                }\n+            } catch (JsonSyntaxException jse) {\n+                logger.debug(\"{}\", jse.getMessage());\n+            }\n+        }, () -> {\n+            logger.debug(\"### Charge Profile Empty ###\");\n+        });\n+        rangeMapCache.ifPresentOrElse(rangeMap -> {\n+            logger.debug(\"### Range Map ###\");\n+            logger.debug(\"{}\", rangeMap.replaceAll(vin, Constants.ANONYMOUS));\n+        }, () -> {\n+            logger.debug(\"### Range Map Empty ###\");\n+        });\n+        logger.debug(\"###### BMW ConnectedDrive Binding - Vehicle Troubleshoot Fingerprint Data - END ######\");\n+    }\n+\n+    /**\n+     * Don't stress ConnectedDrive with unnecessary requests. One call at the beginning is done to check the response.\n+     * After cache has e.g. a proper error response it will be shown in the fingerprint\n+     *\n+     * @return\n+     */\n+    private boolean isSupported(String service) {\n+        final String services = thing.getProperties().get(Constants.SERVICES_SUPPORTED);\n+        if (services != null) {\n+            if (services.contains(service)) {\n+                return true;\n+            }\n+        }\n+        // if cache is empty give it a try one time to collected Troubleshoot data\n+        if (lastTripCache.isEmpty() || allTripsCache.isEmpty() || destinationCache.isEmpty()) {\n+            return true;\n+        } else {\n+            return false;\n+        }\n+    }\n+\n+    public void updateRemoteExecutionStatus(@Nullable String service, @Nullable String status) {\n+        if (RemoteService.CHARGING_CONTROL.toString().equals(service)\n+                && ExecutionState.EXECUTED.name().equals(status)) {\n+            saveChargeProfileSent();\n+        }\n+        updateChannel(CHANNEL_GROUP_REMOTE, REMOTE_STATE, StringType.valueOf(Converter.toTitleCase(\n+                new StringBuilder(service == null ? \"-\" : service).append(\" \").append(status).toString())));\n+    }\n+\n+    public Optional<VehicleConfiguration> getConfiguration() {\n+        return configuration;\n+    }\n+\n+    public ScheduledExecutorService getScheduler() {\n+        return scheduler;\n+    }\n+\n+    /**\n+     * Callbacks for ConnectedDrive Portal\n+     *\n+     * @author Bernd Weymann\n+     *\n+     */\n+    @NonNullByDefault({})", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "48af48c82562d006b6f2aa35922270f181c885ed"}, "originalPosition": 455}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMDA1MDkxMQ==", "bodyText": "Removed", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r600050911", "createdAt": "2021-03-24T00:17:07Z", "author": {"login": "weymann"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/VehicleHandler.java", "diffHunk": "@@ -0,0 +1,826 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bmwconnecteddrive.internal.handler;\n+\n+import static org.openhab.binding.bmwconnecteddrive.internal.ConnectedDriveConstants.*;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.bmwconnecteddrive.internal.VehicleConfiguration;\n+import org.openhab.binding.bmwconnecteddrive.internal.action.ChargeProfileActions;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.DestinationContainer;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.NetworkError;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.compat.VehicleAttributesContainer;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.statistics.AllTrips;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.statistics.AllTripsContainer;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.statistics.LastTrip;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.statistics.LastTripContainer;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.status.VehicleStatus;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.status.VehicleStatusContainer;\n+import org.openhab.binding.bmwconnecteddrive.internal.handler.RemoteServiceHandler.ExecutionState;\n+import org.openhab.binding.bmwconnecteddrive.internal.handler.RemoteServiceHandler.RemoteService;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileUtils;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileUtils.ChargeKeyDay;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileUtils.ChargeKeyHour;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileWrapper;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileWrapper.ProfileKey;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Constants;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Converter;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ImageProperties;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.RemoteServiceUtils;\n+import org.openhab.core.io.net.http.HttpUtil;\n+import org.openhab.core.library.types.DecimalType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.RawType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BridgeHandler;\n+import org.openhab.core.thing.binding.ThingHandlerService;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+\n+import com.google.gson.JsonSyntaxException;\n+\n+/**\n+ * The {@link VehicleHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Bernd Weymann - Initial contribution\n+ * @author Norbert Truchsess - edit & send charge profile\n+ */\n+@NonNullByDefault\n+public class VehicleHandler extends VehicleChannelHandler {\n+    private boolean legacyMode = false; // switch to legacy API in case of 404 Errors\n+\n+    private Optional<ConnectedDriveProxy> proxy = Optional.empty();\n+    private Optional<RemoteServiceHandler> remote = Optional.empty();\n+    private Optional<VehicleConfiguration> configuration = Optional.empty();\n+    private Optional<ConnectedDriveBridgeHandler> bridgeHandler = Optional.empty();\n+    private Optional<ScheduledFuture<?>> refreshJob = Optional.empty();\n+    private Optional<ScheduledFuture<?>> editTimeout = Optional.empty();\n+    private Optional<List<ResponseCallback>> callbackCounter = Optional.empty();\n+\n+    private ImageProperties imageProperties = new ImageProperties();\n+    VehicleStatusCallback vehicleStatusCallback = new VehicleStatusCallback();\n+    StringResponseCallback oldVehicleStatusCallback = new LegacyVehicleStatusCallback();\n+    StringResponseCallback lastTripCallback = new LastTripCallback();\n+    StringResponseCallback allTripsCallback = new AllTripsCallback();\n+    StringResponseCallback chargeProfileCallback = new ChargeProfilesCallback();\n+    StringResponseCallback rangeMapCallback = new RangeMapCallback();\n+    DestinationsCallback destinationCallback = new DestinationsCallback();\n+    ByteResponseCallback imageCallback = new ImageCallback();\n+\n+    private Optional<ChargeProfileWrapper> chargeProfileEdit = Optional.empty();\n+    private Optional<String> chargeProfileSent = Optional.empty();\n+\n+    public VehicleHandler(Thing thing, BMWConnectedDriveOptionProvider op, String type, boolean imperial) {\n+        super(thing, op, type, imperial);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        String group = channelUID.getGroupId();\n+\n+        // Refresh of Channels with cached values\n+        if (command instanceof RefreshType) {\n+            if (CHANNEL_GROUP_LAST_TRIP.equals(group)) {\n+                lastTripCache.ifPresent(lastTrip -> lastTripCallback.onResponse(lastTrip));\n+            } else if (CHANNEL_GROUP_LIFETIME.equals(group)) {\n+                allTripsCache.ifPresent(allTrips -> allTripsCallback.onResponse(allTrips));\n+            } else if (CHANNEL_GROUP_DESTINATION.equals(group)) {\n+                destinationCache.ifPresent(destination -> destinationCallback.onResponse(destination));\n+            } else if (CHANNEL_GROUP_STATUS.equals(group)) {\n+                vehicleStatusCache.ifPresent(vehicleStatus -> vehicleStatusCallback.onResponse(vehicleStatus));\n+            } else if (CHANNEL_GROUP_CHARGE.equals(group)) {\n+                chargeProfileEdit.ifPresentOrElse(this::updateChargeProfile,\n+                        () -> chargeProfileCache.ifPresent(this::updateChargeProfileFromContent));\n+            } else if (CHANNEL_GROUP_VEHICLE_IMAGE.equals(group)) {\n+                imageCache.ifPresent(image -> imageCallback.onResponse(image));\n+            }\n+            // Check for Channel Group and corresponding Actions\n+        } else if (CHANNEL_GROUP_REMOTE.equals(group)) {\n+            // Executing Remote Services\n+            if (command instanceof StringType) {\n+                String serviceCommand = ((StringType) command).toFullString();\n+                remote.ifPresent(remot -> {\n+                    switch (serviceCommand) {\n+                        case REMOTE_SERVICE_LIGHT_FLASH:\n+                        case REMOTE_SERVICE_AIR_CONDITIONING:\n+                        case REMOTE_SERVICE_DOOR_LOCK:\n+                        case REMOTE_SERVICE_DOOR_UNLOCK:\n+                        case REMOTE_SERVICE_HORN:\n+                        case REMOTE_SERVICE_VEHICLE_FINDER:\n+                        case REMOTE_SERVICE_CHARGE_NOW:\n+                            RemoteServiceUtils.getRemoteService(serviceCommand)\n+                                    .ifPresentOrElse(service -> remot.execute(service), () -> {\n+                                        logger.info(\"Remote service execution {} unknown\", serviceCommand);\n+                                    });\n+                            break;\n+                        case REMOTE_SERVICE_CHARGING_CONTROL:\n+                            sendChargeProfile(chargeProfileEdit);\n+                            break;\n+                        default:\n+                            logger.info(\"Remote service execution {} unknown\", serviceCommand);\n+                            break;\n+                    }\n+                });\n+            }\n+        } else if (CHANNEL_GROUP_VEHICLE_IMAGE.equals(group)) {\n+            // Image Change\n+            configuration.ifPresent(config -> {\n+                if (command instanceof StringType) {\n+                    if (channelUID.getIdWithoutGroup().equals(IMAGE_VIEWPORT)) {\n+                        String newViewport = command.toString();\n+                        synchronized (imageProperties) {\n+                            if (!imageProperties.viewport.equals(newViewport)) {\n+                                imageProperties = new ImageProperties(newViewport, imageProperties.size);\n+                                imageCache = Optional.empty();\n+                                proxy.ifPresent(prox -> prox.requestImage(config, imageProperties, imageCallback));\n+                            }\n+                        }\n+                        updateChannel(CHANNEL_GROUP_VEHICLE_IMAGE, IMAGE_VIEWPORT, StringType.valueOf(newViewport));\n+                    }\n+                }\n+                if (command instanceof DecimalType) {\n+                    if (command instanceof DecimalType) {\n+                        int newImageSize = ((DecimalType) command).intValue();\n+                        if (channelUID.getIdWithoutGroup().equals(IMAGE_SIZE)) {\n+                            synchronized (imageProperties) {\n+                                if (imageProperties.size != newImageSize) {\n+                                    imageProperties = new ImageProperties(imageProperties.viewport, newImageSize);\n+                                    imageCache = Optional.empty();\n+                                    proxy.ifPresent(prox -> prox.requestImage(config, imageProperties, imageCallback));\n+                                }\n+                            }\n+                        }\n+                        updateChannel(CHANNEL_GROUP_VEHICLE_IMAGE, IMAGE_SIZE, new DecimalType(newImageSize));\n+                    }\n+                }\n+            });\n+        } else if (CHANNEL_GROUP_DESTINATION.equals(group)) {\n+            if (command instanceof StringType) {\n+                int index = Converter.getIndex(command.toFullString());\n+                if (index != -1) {\n+                    selectDestination(index);\n+                } else {\n+                    logger.debug(\"Cannot select Destination index {}\", command.toFullString());\n+                }\n+            }\n+        } else if (CHANNEL_GROUP_SERVICE.equals(group)) {\n+            if (command instanceof StringType) {\n+                int index = Converter.getIndex(command.toFullString());\n+                if (index != -1) {\n+                    selectService(index);\n+                } else {\n+                    logger.debug(\"Cannot select Service index {}\", command.toFullString());\n+                }\n+            }\n+        } else if (CHANNEL_GROUP_CHECK_CONTROL.equals(group)) {\n+            if (command instanceof StringType) {\n+                int index = Converter.getIndex(command.toFullString());\n+                if (index != -1) {\n+                    selectCheckControl(index);\n+                } else {\n+                    logger.debug(\"Cannot select CheckControl index {}\", command.toFullString());\n+                }\n+            }\n+        } else if (CHANNEL_GROUP_CHARGE.equals(group)) {\n+            handleChargeProfileCommand(channelUID, command);\n+        }\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        callbackCounter = Optional.of(new ArrayList<ResponseCallback>());\n+        updateStatus(ThingStatus.UNKNOWN);\n+        final VehicleConfiguration config = getConfigAs(VehicleConfiguration.class);\n+        if (config != null) {\n+            configuration = Optional.of(config);\n+            scheduler.execute(() -> {\n+                Bridge bridge = getBridge();\n+                if (bridge != null) {\n+                    BridgeHandler handler = bridge.getHandler();\n+                    if (handler != null) {\n+                        bridgeHandler = Optional.of(((ConnectedDriveBridgeHandler) handler));\n+                        proxy = ((ConnectedDriveBridgeHandler) handler).getProxy();\n+                        remote = proxy.map(prox -> prox.getRemoteServiceHandler(this));\n+                    } else {\n+                        logger.debug(\"Bridge Handler null\");\n+                    }\n+                } else {\n+                    logger.debug(\"Bridge null\");\n+                }\n+\n+                // get Image after init with config values\n+                synchronized (imageProperties) {\n+                    imageProperties = new ImageProperties(config.imageViewport, config.imageSize);\n+                }\n+                updateChannel(CHANNEL_GROUP_VEHICLE_IMAGE, IMAGE_VIEWPORT, StringType.valueOf((config.imageViewport)));\n+                updateChannel(CHANNEL_GROUP_VEHICLE_IMAGE, IMAGE_SIZE, new DecimalType((config.imageSize)));\n+\n+                // check imperial setting is different to AutoDetect\n+                if (!UNITS_AUTODETECT.equals(config.units)) {\n+                    imperial = UNITS_IMPERIAL.equals(config.units);\n+                }\n+\n+                // start update schedule\n+                startSchedule(config.refreshInterval);\n+            });\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR);\n+        }\n+    }\n+\n+    private void startSchedule(int interval) {\n+        refreshJob.ifPresentOrElse(job -> {\n+            if (job.isCancelled()) {\n+                refreshJob = Optional\n+                        .of(scheduler.scheduleWithFixedDelay(this::getData, 0, interval, TimeUnit.MINUTES));\n+            } // else - scheduler is already running!\n+        }, () -> {\n+            refreshJob = Optional.of(scheduler.scheduleWithFixedDelay(this::getData, 0, interval, TimeUnit.MINUTES));\n+        });\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        refreshJob.ifPresent(job -> job.cancel(true));\n+    }\n+\n+    public void getData() {\n+        proxy.ifPresentOrElse(prox -> {\n+            configuration.ifPresentOrElse(config -> {\n+                if (!legacyMode) {\n+                    prox.requestVehcileStatus(config, vehicleStatusCallback);\n+                } else {\n+                    prox.requestLegacyVehcileStatus(config, oldVehicleStatusCallback);\n+                }\n+                addCallback(vehicleStatusCallback);\n+                if (isSupported(Constants.STATISTICS)) {\n+                    prox.requestLastTrip(config, lastTripCallback);\n+                    prox.requestAllTrips(config, allTripsCallback);\n+                    addCallback(lastTripCallback);\n+                    addCallback(allTripsCallback);\n+                }\n+                if (isSupported(Constants.LAST_DESTINATIONS)) {\n+                    prox.requestDestinations(config, destinationCallback);\n+                    addCallback(destinationCallback);\n+                }\n+                if (isElectric) {\n+                    prox.requestChargingProfile(config, chargeProfileCallback);\n+                    addCallback(chargeProfileCallback);\n+                }\n+                synchronized (imageProperties) {\n+                    if (!imageCache.isPresent() && !imageProperties.failLimitReached()) {\n+                        prox.requestImage(config, imageProperties, imageCallback);\n+                        addCallback(imageCallback);\n+                    }\n+                }\n+            }, () -> {\n+                logger.warn(\"ConnectedDrive Configuration isn't present\");\n+            });\n+        }, () -> {\n+            logger.warn(\"ConnectedDrive Proxy isn't present\");\n+        });\n+    }\n+\n+    private synchronized void addCallback(ResponseCallback rc) {\n+        callbackCounter.ifPresent(counter -> counter.add(rc));\n+    }\n+\n+    private synchronized void removeCallback(ResponseCallback rc) {\n+        callbackCounter.ifPresent(counter -> {\n+            counter.remove(rc);\n+            // all necessary callbacks received => print and set to empty\n+            if (counter.isEmpty()) {\n+                logFingerPrint();\n+                callbackCounter = Optional.empty();\n+            }\n+        });\n+    }\n+\n+    private void logFingerPrint() {\n+        final String vin = configuration.map(config -> config.vin).orElse(\"\");\n+        logger.debug(\"###### BMW ConnectedDrive Binding - Vehicle Troubleshoot Fingerprint Data - BEGIN ######\");\n+        logger.debug(\"### Discovery Result ###\");\n+        bridgeHandler.ifPresent(handler -> {\n+            logger.debug(\"{}\", handler.getDiscoveryFingerprint());\n+        });\n+        vehicleStatusCache.ifPresentOrElse(vehicleStatus -> {\n+            logger.debug(\"### Vehicle Status ###\");\n+\n+            // Anonymous data for VIN and Position\n+            try {\n+                VehicleStatusContainer container = Converter.getGson().fromJson(vehicleStatus,\n+                        VehicleStatusContainer.class);\n+                if (container != null) {\n+                    VehicleStatus status = container.vehicleStatus;\n+                    if (status != null) {\n+                        status.vin = Constants.ANONYMOUS;\n+                        if (status.position != null) {\n+                            status.position.lat = -1;\n+                            status.position.lon = -1;\n+                            status.position.heading = -1;\n+                        }\n+                    }\n+                }\n+                logger.debug(\"{}\", Converter.getGson().toJson(container));\n+            } catch (JsonSyntaxException jse) {\n+                logger.debug(\"{}\", jse.getMessage());\n+            }\n+        }, () -> {\n+            logger.debug(\"### Vehicle Status Empty ###\");\n+        });\n+        lastTripCache.ifPresentOrElse(lastTrip -> {\n+            logger.debug(\"### Last Trip ###\");\n+            logger.debug(\"{}\", lastTrip.replaceAll(vin, Constants.ANONYMOUS));\n+        }, () -> {\n+            logger.debug(\"### Last Trip Empty ###\");\n+        });\n+        allTripsCache.ifPresentOrElse(allTrips -> {\n+            logger.debug(\"### All Trips ###\");\n+            logger.debug(\"{}\", allTrips.replaceAll(vin, Constants.ANONYMOUS));\n+        }, () -> {\n+            logger.debug(\"### All Trips Empty ###\");\n+        });\n+        if (isElectric) {\n+            chargeProfileCache.ifPresentOrElse(chargeProfile -> {\n+                logger.debug(\"### Charge Profile ###\");\n+                logger.debug(\"{}\", chargeProfile.replaceAll(vin, Constants.ANONYMOUS));\n+            }, () -> {\n+                logger.debug(\"### Charge Profile Empty ###\");\n+            });\n+        }\n+        destinationCache.ifPresentOrElse(destination -> {\n+            logger.debug(\"### Charge Profile ###\");\n+            try {\n+                DestinationContainer container = Converter.getGson().fromJson(destination, DestinationContainer.class);\n+                if (container != null) {\n+                    if (container.destinations != null) {\n+                        container.destinations.forEach(entry -> {\n+                            entry.lat = 0;\n+                            entry.lon = 0;\n+                            entry.city = Constants.ANONYMOUS;\n+                            entry.street = Constants.ANONYMOUS;\n+                            entry.streetNumber = Constants.ANONYMOUS;\n+                            entry.country = Constants.ANONYMOUS;\n+                        });\n+                        logger.debug(\"{}\", Converter.getGson().toJson(container));\n+                    }\n+                } else {\n+                    logger.debug(\"### Destinations Empty ###\");\n+                }\n+            } catch (JsonSyntaxException jse) {\n+                logger.debug(\"{}\", jse.getMessage());\n+            }\n+        }, () -> {\n+            logger.debug(\"### Charge Profile Empty ###\");\n+        });\n+        rangeMapCache.ifPresentOrElse(rangeMap -> {\n+            logger.debug(\"### Range Map ###\");\n+            logger.debug(\"{}\", rangeMap.replaceAll(vin, Constants.ANONYMOUS));\n+        }, () -> {\n+            logger.debug(\"### Range Map Empty ###\");\n+        });\n+        logger.debug(\"###### BMW ConnectedDrive Binding - Vehicle Troubleshoot Fingerprint Data - END ######\");\n+    }\n+\n+    /**\n+     * Don't stress ConnectedDrive with unnecessary requests. One call at the beginning is done to check the response.\n+     * After cache has e.g. a proper error response it will be shown in the fingerprint\n+     *\n+     * @return\n+     */\n+    private boolean isSupported(String service) {\n+        final String services = thing.getProperties().get(Constants.SERVICES_SUPPORTED);\n+        if (services != null) {\n+            if (services.contains(service)) {\n+                return true;\n+            }\n+        }\n+        // if cache is empty give it a try one time to collected Troubleshoot data\n+        if (lastTripCache.isEmpty() || allTripsCache.isEmpty() || destinationCache.isEmpty()) {\n+            return true;\n+        } else {\n+            return false;\n+        }\n+    }\n+\n+    public void updateRemoteExecutionStatus(@Nullable String service, @Nullable String status) {\n+        if (RemoteService.CHARGING_CONTROL.toString().equals(service)\n+                && ExecutionState.EXECUTED.name().equals(status)) {\n+            saveChargeProfileSent();\n+        }\n+        updateChannel(CHANNEL_GROUP_REMOTE, REMOTE_STATE, StringType.valueOf(Converter.toTitleCase(\n+                new StringBuilder(service == null ? \"-\" : service).append(\" \").append(status).toString())));\n+    }\n+\n+    public Optional<VehicleConfiguration> getConfiguration() {\n+        return configuration;\n+    }\n+\n+    public ScheduledExecutorService getScheduler() {\n+        return scheduler;\n+    }\n+\n+    /**\n+     * Callbacks for ConnectedDrive Portal\n+     *\n+     * @author Bernd Weymann\n+     *\n+     */\n+    @NonNullByDefault({})", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5NzkxOTMyOA=="}, "originalCommit": {"oid": "48af48c82562d006b6f2aa35922270f181c885ed"}, "originalPosition": 455}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzc3Njc4MjQ0OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/VehicleHandler.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0xOVQxOToxNToyNlrOI6OHrA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0yNFQwMDoxNzozM1rOI8QNjA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5NzkxOTY2MA==", "bodyText": "See above. Remove. Same for below.", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r597919660", "createdAt": "2021-03-19T19:15:26Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/VehicleHandler.java", "diffHunk": "@@ -0,0 +1,826 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bmwconnecteddrive.internal.handler;\n+\n+import static org.openhab.binding.bmwconnecteddrive.internal.ConnectedDriveConstants.*;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.bmwconnecteddrive.internal.VehicleConfiguration;\n+import org.openhab.binding.bmwconnecteddrive.internal.action.ChargeProfileActions;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.DestinationContainer;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.NetworkError;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.compat.VehicleAttributesContainer;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.statistics.AllTrips;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.statistics.AllTripsContainer;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.statistics.LastTrip;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.statistics.LastTripContainer;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.status.VehicleStatus;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.status.VehicleStatusContainer;\n+import org.openhab.binding.bmwconnecteddrive.internal.handler.RemoteServiceHandler.ExecutionState;\n+import org.openhab.binding.bmwconnecteddrive.internal.handler.RemoteServiceHandler.RemoteService;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileUtils;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileUtils.ChargeKeyDay;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileUtils.ChargeKeyHour;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileWrapper;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileWrapper.ProfileKey;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Constants;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Converter;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ImageProperties;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.RemoteServiceUtils;\n+import org.openhab.core.io.net.http.HttpUtil;\n+import org.openhab.core.library.types.DecimalType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.RawType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BridgeHandler;\n+import org.openhab.core.thing.binding.ThingHandlerService;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+\n+import com.google.gson.JsonSyntaxException;\n+\n+/**\n+ * The {@link VehicleHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Bernd Weymann - Initial contribution\n+ * @author Norbert Truchsess - edit & send charge profile\n+ */\n+@NonNullByDefault\n+public class VehicleHandler extends VehicleChannelHandler {\n+    private boolean legacyMode = false; // switch to legacy API in case of 404 Errors\n+\n+    private Optional<ConnectedDriveProxy> proxy = Optional.empty();\n+    private Optional<RemoteServiceHandler> remote = Optional.empty();\n+    private Optional<VehicleConfiguration> configuration = Optional.empty();\n+    private Optional<ConnectedDriveBridgeHandler> bridgeHandler = Optional.empty();\n+    private Optional<ScheduledFuture<?>> refreshJob = Optional.empty();\n+    private Optional<ScheduledFuture<?>> editTimeout = Optional.empty();\n+    private Optional<List<ResponseCallback>> callbackCounter = Optional.empty();\n+\n+    private ImageProperties imageProperties = new ImageProperties();\n+    VehicleStatusCallback vehicleStatusCallback = new VehicleStatusCallback();\n+    StringResponseCallback oldVehicleStatusCallback = new LegacyVehicleStatusCallback();\n+    StringResponseCallback lastTripCallback = new LastTripCallback();\n+    StringResponseCallback allTripsCallback = new AllTripsCallback();\n+    StringResponseCallback chargeProfileCallback = new ChargeProfilesCallback();\n+    StringResponseCallback rangeMapCallback = new RangeMapCallback();\n+    DestinationsCallback destinationCallback = new DestinationsCallback();\n+    ByteResponseCallback imageCallback = new ImageCallback();\n+\n+    private Optional<ChargeProfileWrapper> chargeProfileEdit = Optional.empty();\n+    private Optional<String> chargeProfileSent = Optional.empty();\n+\n+    public VehicleHandler(Thing thing, BMWConnectedDriveOptionProvider op, String type, boolean imperial) {\n+        super(thing, op, type, imperial);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        String group = channelUID.getGroupId();\n+\n+        // Refresh of Channels with cached values\n+        if (command instanceof RefreshType) {\n+            if (CHANNEL_GROUP_LAST_TRIP.equals(group)) {\n+                lastTripCache.ifPresent(lastTrip -> lastTripCallback.onResponse(lastTrip));\n+            } else if (CHANNEL_GROUP_LIFETIME.equals(group)) {\n+                allTripsCache.ifPresent(allTrips -> allTripsCallback.onResponse(allTrips));\n+            } else if (CHANNEL_GROUP_DESTINATION.equals(group)) {\n+                destinationCache.ifPresent(destination -> destinationCallback.onResponse(destination));\n+            } else if (CHANNEL_GROUP_STATUS.equals(group)) {\n+                vehicleStatusCache.ifPresent(vehicleStatus -> vehicleStatusCallback.onResponse(vehicleStatus));\n+            } else if (CHANNEL_GROUP_CHARGE.equals(group)) {\n+                chargeProfileEdit.ifPresentOrElse(this::updateChargeProfile,\n+                        () -> chargeProfileCache.ifPresent(this::updateChargeProfileFromContent));\n+            } else if (CHANNEL_GROUP_VEHICLE_IMAGE.equals(group)) {\n+                imageCache.ifPresent(image -> imageCallback.onResponse(image));\n+            }\n+            // Check for Channel Group and corresponding Actions\n+        } else if (CHANNEL_GROUP_REMOTE.equals(group)) {\n+            // Executing Remote Services\n+            if (command instanceof StringType) {\n+                String serviceCommand = ((StringType) command).toFullString();\n+                remote.ifPresent(remot -> {\n+                    switch (serviceCommand) {\n+                        case REMOTE_SERVICE_LIGHT_FLASH:\n+                        case REMOTE_SERVICE_AIR_CONDITIONING:\n+                        case REMOTE_SERVICE_DOOR_LOCK:\n+                        case REMOTE_SERVICE_DOOR_UNLOCK:\n+                        case REMOTE_SERVICE_HORN:\n+                        case REMOTE_SERVICE_VEHICLE_FINDER:\n+                        case REMOTE_SERVICE_CHARGE_NOW:\n+                            RemoteServiceUtils.getRemoteService(serviceCommand)\n+                                    .ifPresentOrElse(service -> remot.execute(service), () -> {\n+                                        logger.info(\"Remote service execution {} unknown\", serviceCommand);\n+                                    });\n+                            break;\n+                        case REMOTE_SERVICE_CHARGING_CONTROL:\n+                            sendChargeProfile(chargeProfileEdit);\n+                            break;\n+                        default:\n+                            logger.info(\"Remote service execution {} unknown\", serviceCommand);\n+                            break;\n+                    }\n+                });\n+            }\n+        } else if (CHANNEL_GROUP_VEHICLE_IMAGE.equals(group)) {\n+            // Image Change\n+            configuration.ifPresent(config -> {\n+                if (command instanceof StringType) {\n+                    if (channelUID.getIdWithoutGroup().equals(IMAGE_VIEWPORT)) {\n+                        String newViewport = command.toString();\n+                        synchronized (imageProperties) {\n+                            if (!imageProperties.viewport.equals(newViewport)) {\n+                                imageProperties = new ImageProperties(newViewport, imageProperties.size);\n+                                imageCache = Optional.empty();\n+                                proxy.ifPresent(prox -> prox.requestImage(config, imageProperties, imageCallback));\n+                            }\n+                        }\n+                        updateChannel(CHANNEL_GROUP_VEHICLE_IMAGE, IMAGE_VIEWPORT, StringType.valueOf(newViewport));\n+                    }\n+                }\n+                if (command instanceof DecimalType) {\n+                    if (command instanceof DecimalType) {\n+                        int newImageSize = ((DecimalType) command).intValue();\n+                        if (channelUID.getIdWithoutGroup().equals(IMAGE_SIZE)) {\n+                            synchronized (imageProperties) {\n+                                if (imageProperties.size != newImageSize) {\n+                                    imageProperties = new ImageProperties(imageProperties.viewport, newImageSize);\n+                                    imageCache = Optional.empty();\n+                                    proxy.ifPresent(prox -> prox.requestImage(config, imageProperties, imageCallback));\n+                                }\n+                            }\n+                        }\n+                        updateChannel(CHANNEL_GROUP_VEHICLE_IMAGE, IMAGE_SIZE, new DecimalType(newImageSize));\n+                    }\n+                }\n+            });\n+        } else if (CHANNEL_GROUP_DESTINATION.equals(group)) {\n+            if (command instanceof StringType) {\n+                int index = Converter.getIndex(command.toFullString());\n+                if (index != -1) {\n+                    selectDestination(index);\n+                } else {\n+                    logger.debug(\"Cannot select Destination index {}\", command.toFullString());\n+                }\n+            }\n+        } else if (CHANNEL_GROUP_SERVICE.equals(group)) {\n+            if (command instanceof StringType) {\n+                int index = Converter.getIndex(command.toFullString());\n+                if (index != -1) {\n+                    selectService(index);\n+                } else {\n+                    logger.debug(\"Cannot select Service index {}\", command.toFullString());\n+                }\n+            }\n+        } else if (CHANNEL_GROUP_CHECK_CONTROL.equals(group)) {\n+            if (command instanceof StringType) {\n+                int index = Converter.getIndex(command.toFullString());\n+                if (index != -1) {\n+                    selectCheckControl(index);\n+                } else {\n+                    logger.debug(\"Cannot select CheckControl index {}\", command.toFullString());\n+                }\n+            }\n+        } else if (CHANNEL_GROUP_CHARGE.equals(group)) {\n+            handleChargeProfileCommand(channelUID, command);\n+        }\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        callbackCounter = Optional.of(new ArrayList<ResponseCallback>());\n+        updateStatus(ThingStatus.UNKNOWN);\n+        final VehicleConfiguration config = getConfigAs(VehicleConfiguration.class);\n+        if (config != null) {\n+            configuration = Optional.of(config);\n+            scheduler.execute(() -> {\n+                Bridge bridge = getBridge();\n+                if (bridge != null) {\n+                    BridgeHandler handler = bridge.getHandler();\n+                    if (handler != null) {\n+                        bridgeHandler = Optional.of(((ConnectedDriveBridgeHandler) handler));\n+                        proxy = ((ConnectedDriveBridgeHandler) handler).getProxy();\n+                        remote = proxy.map(prox -> prox.getRemoteServiceHandler(this));\n+                    } else {\n+                        logger.debug(\"Bridge Handler null\");\n+                    }\n+                } else {\n+                    logger.debug(\"Bridge null\");\n+                }\n+\n+                // get Image after init with config values\n+                synchronized (imageProperties) {\n+                    imageProperties = new ImageProperties(config.imageViewport, config.imageSize);\n+                }\n+                updateChannel(CHANNEL_GROUP_VEHICLE_IMAGE, IMAGE_VIEWPORT, StringType.valueOf((config.imageViewport)));\n+                updateChannel(CHANNEL_GROUP_VEHICLE_IMAGE, IMAGE_SIZE, new DecimalType((config.imageSize)));\n+\n+                // check imperial setting is different to AutoDetect\n+                if (!UNITS_AUTODETECT.equals(config.units)) {\n+                    imperial = UNITS_IMPERIAL.equals(config.units);\n+                }\n+\n+                // start update schedule\n+                startSchedule(config.refreshInterval);\n+            });\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR);\n+        }\n+    }\n+\n+    private void startSchedule(int interval) {\n+        refreshJob.ifPresentOrElse(job -> {\n+            if (job.isCancelled()) {\n+                refreshJob = Optional\n+                        .of(scheduler.scheduleWithFixedDelay(this::getData, 0, interval, TimeUnit.MINUTES));\n+            } // else - scheduler is already running!\n+        }, () -> {\n+            refreshJob = Optional.of(scheduler.scheduleWithFixedDelay(this::getData, 0, interval, TimeUnit.MINUTES));\n+        });\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        refreshJob.ifPresent(job -> job.cancel(true));\n+    }\n+\n+    public void getData() {\n+        proxy.ifPresentOrElse(prox -> {\n+            configuration.ifPresentOrElse(config -> {\n+                if (!legacyMode) {\n+                    prox.requestVehcileStatus(config, vehicleStatusCallback);\n+                } else {\n+                    prox.requestLegacyVehcileStatus(config, oldVehicleStatusCallback);\n+                }\n+                addCallback(vehicleStatusCallback);\n+                if (isSupported(Constants.STATISTICS)) {\n+                    prox.requestLastTrip(config, lastTripCallback);\n+                    prox.requestAllTrips(config, allTripsCallback);\n+                    addCallback(lastTripCallback);\n+                    addCallback(allTripsCallback);\n+                }\n+                if (isSupported(Constants.LAST_DESTINATIONS)) {\n+                    prox.requestDestinations(config, destinationCallback);\n+                    addCallback(destinationCallback);\n+                }\n+                if (isElectric) {\n+                    prox.requestChargingProfile(config, chargeProfileCallback);\n+                    addCallback(chargeProfileCallback);\n+                }\n+                synchronized (imageProperties) {\n+                    if (!imageCache.isPresent() && !imageProperties.failLimitReached()) {\n+                        prox.requestImage(config, imageProperties, imageCallback);\n+                        addCallback(imageCallback);\n+                    }\n+                }\n+            }, () -> {\n+                logger.warn(\"ConnectedDrive Configuration isn't present\");\n+            });\n+        }, () -> {\n+            logger.warn(\"ConnectedDrive Proxy isn't present\");\n+        });\n+    }\n+\n+    private synchronized void addCallback(ResponseCallback rc) {\n+        callbackCounter.ifPresent(counter -> counter.add(rc));\n+    }\n+\n+    private synchronized void removeCallback(ResponseCallback rc) {\n+        callbackCounter.ifPresent(counter -> {\n+            counter.remove(rc);\n+            // all necessary callbacks received => print and set to empty\n+            if (counter.isEmpty()) {\n+                logFingerPrint();\n+                callbackCounter = Optional.empty();\n+            }\n+        });\n+    }\n+\n+    private void logFingerPrint() {\n+        final String vin = configuration.map(config -> config.vin).orElse(\"\");\n+        logger.debug(\"###### BMW ConnectedDrive Binding - Vehicle Troubleshoot Fingerprint Data - BEGIN ######\");\n+        logger.debug(\"### Discovery Result ###\");\n+        bridgeHandler.ifPresent(handler -> {\n+            logger.debug(\"{}\", handler.getDiscoveryFingerprint());\n+        });\n+        vehicleStatusCache.ifPresentOrElse(vehicleStatus -> {\n+            logger.debug(\"### Vehicle Status ###\");\n+\n+            // Anonymous data for VIN and Position\n+            try {\n+                VehicleStatusContainer container = Converter.getGson().fromJson(vehicleStatus,\n+                        VehicleStatusContainer.class);\n+                if (container != null) {\n+                    VehicleStatus status = container.vehicleStatus;\n+                    if (status != null) {\n+                        status.vin = Constants.ANONYMOUS;\n+                        if (status.position != null) {\n+                            status.position.lat = -1;\n+                            status.position.lon = -1;\n+                            status.position.heading = -1;\n+                        }\n+                    }\n+                }\n+                logger.debug(\"{}\", Converter.getGson().toJson(container));\n+            } catch (JsonSyntaxException jse) {\n+                logger.debug(\"{}\", jse.getMessage());\n+            }\n+        }, () -> {\n+            logger.debug(\"### Vehicle Status Empty ###\");\n+        });\n+        lastTripCache.ifPresentOrElse(lastTrip -> {\n+            logger.debug(\"### Last Trip ###\");\n+            logger.debug(\"{}\", lastTrip.replaceAll(vin, Constants.ANONYMOUS));\n+        }, () -> {\n+            logger.debug(\"### Last Trip Empty ###\");\n+        });\n+        allTripsCache.ifPresentOrElse(allTrips -> {\n+            logger.debug(\"### All Trips ###\");\n+            logger.debug(\"{}\", allTrips.replaceAll(vin, Constants.ANONYMOUS));\n+        }, () -> {\n+            logger.debug(\"### All Trips Empty ###\");\n+        });\n+        if (isElectric) {\n+            chargeProfileCache.ifPresentOrElse(chargeProfile -> {\n+                logger.debug(\"### Charge Profile ###\");\n+                logger.debug(\"{}\", chargeProfile.replaceAll(vin, Constants.ANONYMOUS));\n+            }, () -> {\n+                logger.debug(\"### Charge Profile Empty ###\");\n+            });\n+        }\n+        destinationCache.ifPresentOrElse(destination -> {\n+            logger.debug(\"### Charge Profile ###\");\n+            try {\n+                DestinationContainer container = Converter.getGson().fromJson(destination, DestinationContainer.class);\n+                if (container != null) {\n+                    if (container.destinations != null) {\n+                        container.destinations.forEach(entry -> {\n+                            entry.lat = 0;\n+                            entry.lon = 0;\n+                            entry.city = Constants.ANONYMOUS;\n+                            entry.street = Constants.ANONYMOUS;\n+                            entry.streetNumber = Constants.ANONYMOUS;\n+                            entry.country = Constants.ANONYMOUS;\n+                        });\n+                        logger.debug(\"{}\", Converter.getGson().toJson(container));\n+                    }\n+                } else {\n+                    logger.debug(\"### Destinations Empty ###\");\n+                }\n+            } catch (JsonSyntaxException jse) {\n+                logger.debug(\"{}\", jse.getMessage());\n+            }\n+        }, () -> {\n+            logger.debug(\"### Charge Profile Empty ###\");\n+        });\n+        rangeMapCache.ifPresentOrElse(rangeMap -> {\n+            logger.debug(\"### Range Map ###\");\n+            logger.debug(\"{}\", rangeMap.replaceAll(vin, Constants.ANONYMOUS));\n+        }, () -> {\n+            logger.debug(\"### Range Map Empty ###\");\n+        });\n+        logger.debug(\"###### BMW ConnectedDrive Binding - Vehicle Troubleshoot Fingerprint Data - END ######\");\n+    }\n+\n+    /**\n+     * Don't stress ConnectedDrive with unnecessary requests. One call at the beginning is done to check the response.\n+     * After cache has e.g. a proper error response it will be shown in the fingerprint\n+     *\n+     * @return\n+     */\n+    private boolean isSupported(String service) {\n+        final String services = thing.getProperties().get(Constants.SERVICES_SUPPORTED);\n+        if (services != null) {\n+            if (services.contains(service)) {\n+                return true;\n+            }\n+        }\n+        // if cache is empty give it a try one time to collected Troubleshoot data\n+        if (lastTripCache.isEmpty() || allTripsCache.isEmpty() || destinationCache.isEmpty()) {\n+            return true;\n+        } else {\n+            return false;\n+        }\n+    }\n+\n+    public void updateRemoteExecutionStatus(@Nullable String service, @Nullable String status) {\n+        if (RemoteService.CHARGING_CONTROL.toString().equals(service)\n+                && ExecutionState.EXECUTED.name().equals(status)) {\n+            saveChargeProfileSent();\n+        }\n+        updateChannel(CHANNEL_GROUP_REMOTE, REMOTE_STATE, StringType.valueOf(Converter.toTitleCase(\n+                new StringBuilder(service == null ? \"-\" : service).append(\" \").append(status).toString())));\n+    }\n+\n+    public Optional<VehicleConfiguration> getConfiguration() {\n+        return configuration;\n+    }\n+\n+    public ScheduledExecutorService getScheduler() {\n+        return scheduler;\n+    }\n+\n+    /**\n+     * Callbacks for ConnectedDrive Portal\n+     *\n+     * @author Bernd Weymann\n+     *\n+     */\n+    @NonNullByDefault({})\n+    public class ChargeProfilesCallback implements StringResponseCallback {\n+        @Override\n+        public void onResponse(@Nullable String content) {\n+            if (content != null) {\n+                chargeProfileCache = Optional.of(content);\n+                if (chargeProfileEdit.isEmpty()) {\n+                    updateChargeProfileFromContent(content);\n+                }\n+            }\n+            removeCallback(this);\n+        }\n+\n+        /**\n+         * Store Error Report in cache variable. Via Fingerprint Channel error is logged and Issue can be raised\n+         */\n+        @Override\n+        public void onError(NetworkError error) {\n+            logger.debug(\"{}\", error.toString());\n+            chargeProfileCache = Optional.of(Converter.getGson().toJson(error));\n+            removeCallback(this);\n+        }\n+    }\n+\n+    @NonNullByDefault({})", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "48af48c82562d006b6f2aa35922270f181c885ed"}, "originalPosition": 479}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMDA1MTA4NA==", "bodyText": "removed for all inner classes", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r600051084", "createdAt": "2021-03-24T00:17:33Z", "author": {"login": "weymann"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/VehicleHandler.java", "diffHunk": "@@ -0,0 +1,826 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bmwconnecteddrive.internal.handler;\n+\n+import static org.openhab.binding.bmwconnecteddrive.internal.ConnectedDriveConstants.*;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.bmwconnecteddrive.internal.VehicleConfiguration;\n+import org.openhab.binding.bmwconnecteddrive.internal.action.ChargeProfileActions;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.DestinationContainer;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.NetworkError;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.compat.VehicleAttributesContainer;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.statistics.AllTrips;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.statistics.AllTripsContainer;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.statistics.LastTrip;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.statistics.LastTripContainer;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.status.VehicleStatus;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.status.VehicleStatusContainer;\n+import org.openhab.binding.bmwconnecteddrive.internal.handler.RemoteServiceHandler.ExecutionState;\n+import org.openhab.binding.bmwconnecteddrive.internal.handler.RemoteServiceHandler.RemoteService;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileUtils;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileUtils.ChargeKeyDay;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileUtils.ChargeKeyHour;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileWrapper;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileWrapper.ProfileKey;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Constants;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Converter;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ImageProperties;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.RemoteServiceUtils;\n+import org.openhab.core.io.net.http.HttpUtil;\n+import org.openhab.core.library.types.DecimalType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.RawType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BridgeHandler;\n+import org.openhab.core.thing.binding.ThingHandlerService;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+\n+import com.google.gson.JsonSyntaxException;\n+\n+/**\n+ * The {@link VehicleHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Bernd Weymann - Initial contribution\n+ * @author Norbert Truchsess - edit & send charge profile\n+ */\n+@NonNullByDefault\n+public class VehicleHandler extends VehicleChannelHandler {\n+    private boolean legacyMode = false; // switch to legacy API in case of 404 Errors\n+\n+    private Optional<ConnectedDriveProxy> proxy = Optional.empty();\n+    private Optional<RemoteServiceHandler> remote = Optional.empty();\n+    private Optional<VehicleConfiguration> configuration = Optional.empty();\n+    private Optional<ConnectedDriveBridgeHandler> bridgeHandler = Optional.empty();\n+    private Optional<ScheduledFuture<?>> refreshJob = Optional.empty();\n+    private Optional<ScheduledFuture<?>> editTimeout = Optional.empty();\n+    private Optional<List<ResponseCallback>> callbackCounter = Optional.empty();\n+\n+    private ImageProperties imageProperties = new ImageProperties();\n+    VehicleStatusCallback vehicleStatusCallback = new VehicleStatusCallback();\n+    StringResponseCallback oldVehicleStatusCallback = new LegacyVehicleStatusCallback();\n+    StringResponseCallback lastTripCallback = new LastTripCallback();\n+    StringResponseCallback allTripsCallback = new AllTripsCallback();\n+    StringResponseCallback chargeProfileCallback = new ChargeProfilesCallback();\n+    StringResponseCallback rangeMapCallback = new RangeMapCallback();\n+    DestinationsCallback destinationCallback = new DestinationsCallback();\n+    ByteResponseCallback imageCallback = new ImageCallback();\n+\n+    private Optional<ChargeProfileWrapper> chargeProfileEdit = Optional.empty();\n+    private Optional<String> chargeProfileSent = Optional.empty();\n+\n+    public VehicleHandler(Thing thing, BMWConnectedDriveOptionProvider op, String type, boolean imperial) {\n+        super(thing, op, type, imperial);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        String group = channelUID.getGroupId();\n+\n+        // Refresh of Channels with cached values\n+        if (command instanceof RefreshType) {\n+            if (CHANNEL_GROUP_LAST_TRIP.equals(group)) {\n+                lastTripCache.ifPresent(lastTrip -> lastTripCallback.onResponse(lastTrip));\n+            } else if (CHANNEL_GROUP_LIFETIME.equals(group)) {\n+                allTripsCache.ifPresent(allTrips -> allTripsCallback.onResponse(allTrips));\n+            } else if (CHANNEL_GROUP_DESTINATION.equals(group)) {\n+                destinationCache.ifPresent(destination -> destinationCallback.onResponse(destination));\n+            } else if (CHANNEL_GROUP_STATUS.equals(group)) {\n+                vehicleStatusCache.ifPresent(vehicleStatus -> vehicleStatusCallback.onResponse(vehicleStatus));\n+            } else if (CHANNEL_GROUP_CHARGE.equals(group)) {\n+                chargeProfileEdit.ifPresentOrElse(this::updateChargeProfile,\n+                        () -> chargeProfileCache.ifPresent(this::updateChargeProfileFromContent));\n+            } else if (CHANNEL_GROUP_VEHICLE_IMAGE.equals(group)) {\n+                imageCache.ifPresent(image -> imageCallback.onResponse(image));\n+            }\n+            // Check for Channel Group and corresponding Actions\n+        } else if (CHANNEL_GROUP_REMOTE.equals(group)) {\n+            // Executing Remote Services\n+            if (command instanceof StringType) {\n+                String serviceCommand = ((StringType) command).toFullString();\n+                remote.ifPresent(remot -> {\n+                    switch (serviceCommand) {\n+                        case REMOTE_SERVICE_LIGHT_FLASH:\n+                        case REMOTE_SERVICE_AIR_CONDITIONING:\n+                        case REMOTE_SERVICE_DOOR_LOCK:\n+                        case REMOTE_SERVICE_DOOR_UNLOCK:\n+                        case REMOTE_SERVICE_HORN:\n+                        case REMOTE_SERVICE_VEHICLE_FINDER:\n+                        case REMOTE_SERVICE_CHARGE_NOW:\n+                            RemoteServiceUtils.getRemoteService(serviceCommand)\n+                                    .ifPresentOrElse(service -> remot.execute(service), () -> {\n+                                        logger.info(\"Remote service execution {} unknown\", serviceCommand);\n+                                    });\n+                            break;\n+                        case REMOTE_SERVICE_CHARGING_CONTROL:\n+                            sendChargeProfile(chargeProfileEdit);\n+                            break;\n+                        default:\n+                            logger.info(\"Remote service execution {} unknown\", serviceCommand);\n+                            break;\n+                    }\n+                });\n+            }\n+        } else if (CHANNEL_GROUP_VEHICLE_IMAGE.equals(group)) {\n+            // Image Change\n+            configuration.ifPresent(config -> {\n+                if (command instanceof StringType) {\n+                    if (channelUID.getIdWithoutGroup().equals(IMAGE_VIEWPORT)) {\n+                        String newViewport = command.toString();\n+                        synchronized (imageProperties) {\n+                            if (!imageProperties.viewport.equals(newViewport)) {\n+                                imageProperties = new ImageProperties(newViewport, imageProperties.size);\n+                                imageCache = Optional.empty();\n+                                proxy.ifPresent(prox -> prox.requestImage(config, imageProperties, imageCallback));\n+                            }\n+                        }\n+                        updateChannel(CHANNEL_GROUP_VEHICLE_IMAGE, IMAGE_VIEWPORT, StringType.valueOf(newViewport));\n+                    }\n+                }\n+                if (command instanceof DecimalType) {\n+                    if (command instanceof DecimalType) {\n+                        int newImageSize = ((DecimalType) command).intValue();\n+                        if (channelUID.getIdWithoutGroup().equals(IMAGE_SIZE)) {\n+                            synchronized (imageProperties) {\n+                                if (imageProperties.size != newImageSize) {\n+                                    imageProperties = new ImageProperties(imageProperties.viewport, newImageSize);\n+                                    imageCache = Optional.empty();\n+                                    proxy.ifPresent(prox -> prox.requestImage(config, imageProperties, imageCallback));\n+                                }\n+                            }\n+                        }\n+                        updateChannel(CHANNEL_GROUP_VEHICLE_IMAGE, IMAGE_SIZE, new DecimalType(newImageSize));\n+                    }\n+                }\n+            });\n+        } else if (CHANNEL_GROUP_DESTINATION.equals(group)) {\n+            if (command instanceof StringType) {\n+                int index = Converter.getIndex(command.toFullString());\n+                if (index != -1) {\n+                    selectDestination(index);\n+                } else {\n+                    logger.debug(\"Cannot select Destination index {}\", command.toFullString());\n+                }\n+            }\n+        } else if (CHANNEL_GROUP_SERVICE.equals(group)) {\n+            if (command instanceof StringType) {\n+                int index = Converter.getIndex(command.toFullString());\n+                if (index != -1) {\n+                    selectService(index);\n+                } else {\n+                    logger.debug(\"Cannot select Service index {}\", command.toFullString());\n+                }\n+            }\n+        } else if (CHANNEL_GROUP_CHECK_CONTROL.equals(group)) {\n+            if (command instanceof StringType) {\n+                int index = Converter.getIndex(command.toFullString());\n+                if (index != -1) {\n+                    selectCheckControl(index);\n+                } else {\n+                    logger.debug(\"Cannot select CheckControl index {}\", command.toFullString());\n+                }\n+            }\n+        } else if (CHANNEL_GROUP_CHARGE.equals(group)) {\n+            handleChargeProfileCommand(channelUID, command);\n+        }\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        callbackCounter = Optional.of(new ArrayList<ResponseCallback>());\n+        updateStatus(ThingStatus.UNKNOWN);\n+        final VehicleConfiguration config = getConfigAs(VehicleConfiguration.class);\n+        if (config != null) {\n+            configuration = Optional.of(config);\n+            scheduler.execute(() -> {\n+                Bridge bridge = getBridge();\n+                if (bridge != null) {\n+                    BridgeHandler handler = bridge.getHandler();\n+                    if (handler != null) {\n+                        bridgeHandler = Optional.of(((ConnectedDriveBridgeHandler) handler));\n+                        proxy = ((ConnectedDriveBridgeHandler) handler).getProxy();\n+                        remote = proxy.map(prox -> prox.getRemoteServiceHandler(this));\n+                    } else {\n+                        logger.debug(\"Bridge Handler null\");\n+                    }\n+                } else {\n+                    logger.debug(\"Bridge null\");\n+                }\n+\n+                // get Image after init with config values\n+                synchronized (imageProperties) {\n+                    imageProperties = new ImageProperties(config.imageViewport, config.imageSize);\n+                }\n+                updateChannel(CHANNEL_GROUP_VEHICLE_IMAGE, IMAGE_VIEWPORT, StringType.valueOf((config.imageViewport)));\n+                updateChannel(CHANNEL_GROUP_VEHICLE_IMAGE, IMAGE_SIZE, new DecimalType((config.imageSize)));\n+\n+                // check imperial setting is different to AutoDetect\n+                if (!UNITS_AUTODETECT.equals(config.units)) {\n+                    imperial = UNITS_IMPERIAL.equals(config.units);\n+                }\n+\n+                // start update schedule\n+                startSchedule(config.refreshInterval);\n+            });\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR);\n+        }\n+    }\n+\n+    private void startSchedule(int interval) {\n+        refreshJob.ifPresentOrElse(job -> {\n+            if (job.isCancelled()) {\n+                refreshJob = Optional\n+                        .of(scheduler.scheduleWithFixedDelay(this::getData, 0, interval, TimeUnit.MINUTES));\n+            } // else - scheduler is already running!\n+        }, () -> {\n+            refreshJob = Optional.of(scheduler.scheduleWithFixedDelay(this::getData, 0, interval, TimeUnit.MINUTES));\n+        });\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        refreshJob.ifPresent(job -> job.cancel(true));\n+    }\n+\n+    public void getData() {\n+        proxy.ifPresentOrElse(prox -> {\n+            configuration.ifPresentOrElse(config -> {\n+                if (!legacyMode) {\n+                    prox.requestVehcileStatus(config, vehicleStatusCallback);\n+                } else {\n+                    prox.requestLegacyVehcileStatus(config, oldVehicleStatusCallback);\n+                }\n+                addCallback(vehicleStatusCallback);\n+                if (isSupported(Constants.STATISTICS)) {\n+                    prox.requestLastTrip(config, lastTripCallback);\n+                    prox.requestAllTrips(config, allTripsCallback);\n+                    addCallback(lastTripCallback);\n+                    addCallback(allTripsCallback);\n+                }\n+                if (isSupported(Constants.LAST_DESTINATIONS)) {\n+                    prox.requestDestinations(config, destinationCallback);\n+                    addCallback(destinationCallback);\n+                }\n+                if (isElectric) {\n+                    prox.requestChargingProfile(config, chargeProfileCallback);\n+                    addCallback(chargeProfileCallback);\n+                }\n+                synchronized (imageProperties) {\n+                    if (!imageCache.isPresent() && !imageProperties.failLimitReached()) {\n+                        prox.requestImage(config, imageProperties, imageCallback);\n+                        addCallback(imageCallback);\n+                    }\n+                }\n+            }, () -> {\n+                logger.warn(\"ConnectedDrive Configuration isn't present\");\n+            });\n+        }, () -> {\n+            logger.warn(\"ConnectedDrive Proxy isn't present\");\n+        });\n+    }\n+\n+    private synchronized void addCallback(ResponseCallback rc) {\n+        callbackCounter.ifPresent(counter -> counter.add(rc));\n+    }\n+\n+    private synchronized void removeCallback(ResponseCallback rc) {\n+        callbackCounter.ifPresent(counter -> {\n+            counter.remove(rc);\n+            // all necessary callbacks received => print and set to empty\n+            if (counter.isEmpty()) {\n+                logFingerPrint();\n+                callbackCounter = Optional.empty();\n+            }\n+        });\n+    }\n+\n+    private void logFingerPrint() {\n+        final String vin = configuration.map(config -> config.vin).orElse(\"\");\n+        logger.debug(\"###### BMW ConnectedDrive Binding - Vehicle Troubleshoot Fingerprint Data - BEGIN ######\");\n+        logger.debug(\"### Discovery Result ###\");\n+        bridgeHandler.ifPresent(handler -> {\n+            logger.debug(\"{}\", handler.getDiscoveryFingerprint());\n+        });\n+        vehicleStatusCache.ifPresentOrElse(vehicleStatus -> {\n+            logger.debug(\"### Vehicle Status ###\");\n+\n+            // Anonymous data for VIN and Position\n+            try {\n+                VehicleStatusContainer container = Converter.getGson().fromJson(vehicleStatus,\n+                        VehicleStatusContainer.class);\n+                if (container != null) {\n+                    VehicleStatus status = container.vehicleStatus;\n+                    if (status != null) {\n+                        status.vin = Constants.ANONYMOUS;\n+                        if (status.position != null) {\n+                            status.position.lat = -1;\n+                            status.position.lon = -1;\n+                            status.position.heading = -1;\n+                        }\n+                    }\n+                }\n+                logger.debug(\"{}\", Converter.getGson().toJson(container));\n+            } catch (JsonSyntaxException jse) {\n+                logger.debug(\"{}\", jse.getMessage());\n+            }\n+        }, () -> {\n+            logger.debug(\"### Vehicle Status Empty ###\");\n+        });\n+        lastTripCache.ifPresentOrElse(lastTrip -> {\n+            logger.debug(\"### Last Trip ###\");\n+            logger.debug(\"{}\", lastTrip.replaceAll(vin, Constants.ANONYMOUS));\n+        }, () -> {\n+            logger.debug(\"### Last Trip Empty ###\");\n+        });\n+        allTripsCache.ifPresentOrElse(allTrips -> {\n+            logger.debug(\"### All Trips ###\");\n+            logger.debug(\"{}\", allTrips.replaceAll(vin, Constants.ANONYMOUS));\n+        }, () -> {\n+            logger.debug(\"### All Trips Empty ###\");\n+        });\n+        if (isElectric) {\n+            chargeProfileCache.ifPresentOrElse(chargeProfile -> {\n+                logger.debug(\"### Charge Profile ###\");\n+                logger.debug(\"{}\", chargeProfile.replaceAll(vin, Constants.ANONYMOUS));\n+            }, () -> {\n+                logger.debug(\"### Charge Profile Empty ###\");\n+            });\n+        }\n+        destinationCache.ifPresentOrElse(destination -> {\n+            logger.debug(\"### Charge Profile ###\");\n+            try {\n+                DestinationContainer container = Converter.getGson().fromJson(destination, DestinationContainer.class);\n+                if (container != null) {\n+                    if (container.destinations != null) {\n+                        container.destinations.forEach(entry -> {\n+                            entry.lat = 0;\n+                            entry.lon = 0;\n+                            entry.city = Constants.ANONYMOUS;\n+                            entry.street = Constants.ANONYMOUS;\n+                            entry.streetNumber = Constants.ANONYMOUS;\n+                            entry.country = Constants.ANONYMOUS;\n+                        });\n+                        logger.debug(\"{}\", Converter.getGson().toJson(container));\n+                    }\n+                } else {\n+                    logger.debug(\"### Destinations Empty ###\");\n+                }\n+            } catch (JsonSyntaxException jse) {\n+                logger.debug(\"{}\", jse.getMessage());\n+            }\n+        }, () -> {\n+            logger.debug(\"### Charge Profile Empty ###\");\n+        });\n+        rangeMapCache.ifPresentOrElse(rangeMap -> {\n+            logger.debug(\"### Range Map ###\");\n+            logger.debug(\"{}\", rangeMap.replaceAll(vin, Constants.ANONYMOUS));\n+        }, () -> {\n+            logger.debug(\"### Range Map Empty ###\");\n+        });\n+        logger.debug(\"###### BMW ConnectedDrive Binding - Vehicle Troubleshoot Fingerprint Data - END ######\");\n+    }\n+\n+    /**\n+     * Don't stress ConnectedDrive with unnecessary requests. One call at the beginning is done to check the response.\n+     * After cache has e.g. a proper error response it will be shown in the fingerprint\n+     *\n+     * @return\n+     */\n+    private boolean isSupported(String service) {\n+        final String services = thing.getProperties().get(Constants.SERVICES_SUPPORTED);\n+        if (services != null) {\n+            if (services.contains(service)) {\n+                return true;\n+            }\n+        }\n+        // if cache is empty give it a try one time to collected Troubleshoot data\n+        if (lastTripCache.isEmpty() || allTripsCache.isEmpty() || destinationCache.isEmpty()) {\n+            return true;\n+        } else {\n+            return false;\n+        }\n+    }\n+\n+    public void updateRemoteExecutionStatus(@Nullable String service, @Nullable String status) {\n+        if (RemoteService.CHARGING_CONTROL.toString().equals(service)\n+                && ExecutionState.EXECUTED.name().equals(status)) {\n+            saveChargeProfileSent();\n+        }\n+        updateChannel(CHANNEL_GROUP_REMOTE, REMOTE_STATE, StringType.valueOf(Converter.toTitleCase(\n+                new StringBuilder(service == null ? \"-\" : service).append(\" \").append(status).toString())));\n+    }\n+\n+    public Optional<VehicleConfiguration> getConfiguration() {\n+        return configuration;\n+    }\n+\n+    public ScheduledExecutorService getScheduler() {\n+        return scheduler;\n+    }\n+\n+    /**\n+     * Callbacks for ConnectedDrive Portal\n+     *\n+     * @author Bernd Weymann\n+     *\n+     */\n+    @NonNullByDefault({})\n+    public class ChargeProfilesCallback implements StringResponseCallback {\n+        @Override\n+        public void onResponse(@Nullable String content) {\n+            if (content != null) {\n+                chargeProfileCache = Optional.of(content);\n+                if (chargeProfileEdit.isEmpty()) {\n+                    updateChargeProfileFromContent(content);\n+                }\n+            }\n+            removeCallback(this);\n+        }\n+\n+        /**\n+         * Store Error Report in cache variable. Via Fingerprint Channel error is logged and Issue can be raised\n+         */\n+        @Override\n+        public void onError(NetworkError error) {\n+            logger.debug(\"{}\", error.toString());\n+            chargeProfileCache = Optional.of(Converter.getGson().toJson(error));\n+            removeCallback(this);\n+        }\n+    }\n+\n+    @NonNullByDefault({})", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5NzkxOTY2MA=="}, "originalCommit": {"oid": "48af48c82562d006b6f2aa35922270f181c885ed"}, "originalPosition": 479}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzc3Njc5MzE3OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/VehicleHandler.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0xOVQxOToxODoyMlrOI6ON-w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0yNFQwMTowODowMFrOI8R5rg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5NzkyMTI3NQ==", "bodyText": "The ONLINE state shouldn't contain any detail arguments.", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r597921275", "createdAt": "2021-03-19T19:18:22Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/VehicleHandler.java", "diffHunk": "@@ -0,0 +1,826 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bmwconnecteddrive.internal.handler;\n+\n+import static org.openhab.binding.bmwconnecteddrive.internal.ConnectedDriveConstants.*;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.bmwconnecteddrive.internal.VehicleConfiguration;\n+import org.openhab.binding.bmwconnecteddrive.internal.action.ChargeProfileActions;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.DestinationContainer;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.NetworkError;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.compat.VehicleAttributesContainer;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.statistics.AllTrips;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.statistics.AllTripsContainer;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.statistics.LastTrip;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.statistics.LastTripContainer;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.status.VehicleStatus;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.status.VehicleStatusContainer;\n+import org.openhab.binding.bmwconnecteddrive.internal.handler.RemoteServiceHandler.ExecutionState;\n+import org.openhab.binding.bmwconnecteddrive.internal.handler.RemoteServiceHandler.RemoteService;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileUtils;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileUtils.ChargeKeyDay;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileUtils.ChargeKeyHour;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileWrapper;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileWrapper.ProfileKey;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Constants;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Converter;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ImageProperties;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.RemoteServiceUtils;\n+import org.openhab.core.io.net.http.HttpUtil;\n+import org.openhab.core.library.types.DecimalType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.RawType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BridgeHandler;\n+import org.openhab.core.thing.binding.ThingHandlerService;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+\n+import com.google.gson.JsonSyntaxException;\n+\n+/**\n+ * The {@link VehicleHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Bernd Weymann - Initial contribution\n+ * @author Norbert Truchsess - edit & send charge profile\n+ */\n+@NonNullByDefault\n+public class VehicleHandler extends VehicleChannelHandler {\n+    private boolean legacyMode = false; // switch to legacy API in case of 404 Errors\n+\n+    private Optional<ConnectedDriveProxy> proxy = Optional.empty();\n+    private Optional<RemoteServiceHandler> remote = Optional.empty();\n+    private Optional<VehicleConfiguration> configuration = Optional.empty();\n+    private Optional<ConnectedDriveBridgeHandler> bridgeHandler = Optional.empty();\n+    private Optional<ScheduledFuture<?>> refreshJob = Optional.empty();\n+    private Optional<ScheduledFuture<?>> editTimeout = Optional.empty();\n+    private Optional<List<ResponseCallback>> callbackCounter = Optional.empty();\n+\n+    private ImageProperties imageProperties = new ImageProperties();\n+    VehicleStatusCallback vehicleStatusCallback = new VehicleStatusCallback();\n+    StringResponseCallback oldVehicleStatusCallback = new LegacyVehicleStatusCallback();\n+    StringResponseCallback lastTripCallback = new LastTripCallback();\n+    StringResponseCallback allTripsCallback = new AllTripsCallback();\n+    StringResponseCallback chargeProfileCallback = new ChargeProfilesCallback();\n+    StringResponseCallback rangeMapCallback = new RangeMapCallback();\n+    DestinationsCallback destinationCallback = new DestinationsCallback();\n+    ByteResponseCallback imageCallback = new ImageCallback();\n+\n+    private Optional<ChargeProfileWrapper> chargeProfileEdit = Optional.empty();\n+    private Optional<String> chargeProfileSent = Optional.empty();\n+\n+    public VehicleHandler(Thing thing, BMWConnectedDriveOptionProvider op, String type, boolean imperial) {\n+        super(thing, op, type, imperial);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        String group = channelUID.getGroupId();\n+\n+        // Refresh of Channels with cached values\n+        if (command instanceof RefreshType) {\n+            if (CHANNEL_GROUP_LAST_TRIP.equals(group)) {\n+                lastTripCache.ifPresent(lastTrip -> lastTripCallback.onResponse(lastTrip));\n+            } else if (CHANNEL_GROUP_LIFETIME.equals(group)) {\n+                allTripsCache.ifPresent(allTrips -> allTripsCallback.onResponse(allTrips));\n+            } else if (CHANNEL_GROUP_DESTINATION.equals(group)) {\n+                destinationCache.ifPresent(destination -> destinationCallback.onResponse(destination));\n+            } else if (CHANNEL_GROUP_STATUS.equals(group)) {\n+                vehicleStatusCache.ifPresent(vehicleStatus -> vehicleStatusCallback.onResponse(vehicleStatus));\n+            } else if (CHANNEL_GROUP_CHARGE.equals(group)) {\n+                chargeProfileEdit.ifPresentOrElse(this::updateChargeProfile,\n+                        () -> chargeProfileCache.ifPresent(this::updateChargeProfileFromContent));\n+            } else if (CHANNEL_GROUP_VEHICLE_IMAGE.equals(group)) {\n+                imageCache.ifPresent(image -> imageCallback.onResponse(image));\n+            }\n+            // Check for Channel Group and corresponding Actions\n+        } else if (CHANNEL_GROUP_REMOTE.equals(group)) {\n+            // Executing Remote Services\n+            if (command instanceof StringType) {\n+                String serviceCommand = ((StringType) command).toFullString();\n+                remote.ifPresent(remot -> {\n+                    switch (serviceCommand) {\n+                        case REMOTE_SERVICE_LIGHT_FLASH:\n+                        case REMOTE_SERVICE_AIR_CONDITIONING:\n+                        case REMOTE_SERVICE_DOOR_LOCK:\n+                        case REMOTE_SERVICE_DOOR_UNLOCK:\n+                        case REMOTE_SERVICE_HORN:\n+                        case REMOTE_SERVICE_VEHICLE_FINDER:\n+                        case REMOTE_SERVICE_CHARGE_NOW:\n+                            RemoteServiceUtils.getRemoteService(serviceCommand)\n+                                    .ifPresentOrElse(service -> remot.execute(service), () -> {\n+                                        logger.info(\"Remote service execution {} unknown\", serviceCommand);\n+                                    });\n+                            break;\n+                        case REMOTE_SERVICE_CHARGING_CONTROL:\n+                            sendChargeProfile(chargeProfileEdit);\n+                            break;\n+                        default:\n+                            logger.info(\"Remote service execution {} unknown\", serviceCommand);\n+                            break;\n+                    }\n+                });\n+            }\n+        } else if (CHANNEL_GROUP_VEHICLE_IMAGE.equals(group)) {\n+            // Image Change\n+            configuration.ifPresent(config -> {\n+                if (command instanceof StringType) {\n+                    if (channelUID.getIdWithoutGroup().equals(IMAGE_VIEWPORT)) {\n+                        String newViewport = command.toString();\n+                        synchronized (imageProperties) {\n+                            if (!imageProperties.viewport.equals(newViewport)) {\n+                                imageProperties = new ImageProperties(newViewport, imageProperties.size);\n+                                imageCache = Optional.empty();\n+                                proxy.ifPresent(prox -> prox.requestImage(config, imageProperties, imageCallback));\n+                            }\n+                        }\n+                        updateChannel(CHANNEL_GROUP_VEHICLE_IMAGE, IMAGE_VIEWPORT, StringType.valueOf(newViewport));\n+                    }\n+                }\n+                if (command instanceof DecimalType) {\n+                    if (command instanceof DecimalType) {\n+                        int newImageSize = ((DecimalType) command).intValue();\n+                        if (channelUID.getIdWithoutGroup().equals(IMAGE_SIZE)) {\n+                            synchronized (imageProperties) {\n+                                if (imageProperties.size != newImageSize) {\n+                                    imageProperties = new ImageProperties(imageProperties.viewport, newImageSize);\n+                                    imageCache = Optional.empty();\n+                                    proxy.ifPresent(prox -> prox.requestImage(config, imageProperties, imageCallback));\n+                                }\n+                            }\n+                        }\n+                        updateChannel(CHANNEL_GROUP_VEHICLE_IMAGE, IMAGE_SIZE, new DecimalType(newImageSize));\n+                    }\n+                }\n+            });\n+        } else if (CHANNEL_GROUP_DESTINATION.equals(group)) {\n+            if (command instanceof StringType) {\n+                int index = Converter.getIndex(command.toFullString());\n+                if (index != -1) {\n+                    selectDestination(index);\n+                } else {\n+                    logger.debug(\"Cannot select Destination index {}\", command.toFullString());\n+                }\n+            }\n+        } else if (CHANNEL_GROUP_SERVICE.equals(group)) {\n+            if (command instanceof StringType) {\n+                int index = Converter.getIndex(command.toFullString());\n+                if (index != -1) {\n+                    selectService(index);\n+                } else {\n+                    logger.debug(\"Cannot select Service index {}\", command.toFullString());\n+                }\n+            }\n+        } else if (CHANNEL_GROUP_CHECK_CONTROL.equals(group)) {\n+            if (command instanceof StringType) {\n+                int index = Converter.getIndex(command.toFullString());\n+                if (index != -1) {\n+                    selectCheckControl(index);\n+                } else {\n+                    logger.debug(\"Cannot select CheckControl index {}\", command.toFullString());\n+                }\n+            }\n+        } else if (CHANNEL_GROUP_CHARGE.equals(group)) {\n+            handleChargeProfileCommand(channelUID, command);\n+        }\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        callbackCounter = Optional.of(new ArrayList<ResponseCallback>());\n+        updateStatus(ThingStatus.UNKNOWN);\n+        final VehicleConfiguration config = getConfigAs(VehicleConfiguration.class);\n+        if (config != null) {\n+            configuration = Optional.of(config);\n+            scheduler.execute(() -> {\n+                Bridge bridge = getBridge();\n+                if (bridge != null) {\n+                    BridgeHandler handler = bridge.getHandler();\n+                    if (handler != null) {\n+                        bridgeHandler = Optional.of(((ConnectedDriveBridgeHandler) handler));\n+                        proxy = ((ConnectedDriveBridgeHandler) handler).getProxy();\n+                        remote = proxy.map(prox -> prox.getRemoteServiceHandler(this));\n+                    } else {\n+                        logger.debug(\"Bridge Handler null\");\n+                    }\n+                } else {\n+                    logger.debug(\"Bridge null\");\n+                }\n+\n+                // get Image after init with config values\n+                synchronized (imageProperties) {\n+                    imageProperties = new ImageProperties(config.imageViewport, config.imageSize);\n+                }\n+                updateChannel(CHANNEL_GROUP_VEHICLE_IMAGE, IMAGE_VIEWPORT, StringType.valueOf((config.imageViewport)));\n+                updateChannel(CHANNEL_GROUP_VEHICLE_IMAGE, IMAGE_SIZE, new DecimalType((config.imageSize)));\n+\n+                // check imperial setting is different to AutoDetect\n+                if (!UNITS_AUTODETECT.equals(config.units)) {\n+                    imperial = UNITS_IMPERIAL.equals(config.units);\n+                }\n+\n+                // start update schedule\n+                startSchedule(config.refreshInterval);\n+            });\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR);\n+        }\n+    }\n+\n+    private void startSchedule(int interval) {\n+        refreshJob.ifPresentOrElse(job -> {\n+            if (job.isCancelled()) {\n+                refreshJob = Optional\n+                        .of(scheduler.scheduleWithFixedDelay(this::getData, 0, interval, TimeUnit.MINUTES));\n+            } // else - scheduler is already running!\n+        }, () -> {\n+            refreshJob = Optional.of(scheduler.scheduleWithFixedDelay(this::getData, 0, interval, TimeUnit.MINUTES));\n+        });\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        refreshJob.ifPresent(job -> job.cancel(true));\n+    }\n+\n+    public void getData() {\n+        proxy.ifPresentOrElse(prox -> {\n+            configuration.ifPresentOrElse(config -> {\n+                if (!legacyMode) {\n+                    prox.requestVehcileStatus(config, vehicleStatusCallback);\n+                } else {\n+                    prox.requestLegacyVehcileStatus(config, oldVehicleStatusCallback);\n+                }\n+                addCallback(vehicleStatusCallback);\n+                if (isSupported(Constants.STATISTICS)) {\n+                    prox.requestLastTrip(config, lastTripCallback);\n+                    prox.requestAllTrips(config, allTripsCallback);\n+                    addCallback(lastTripCallback);\n+                    addCallback(allTripsCallback);\n+                }\n+                if (isSupported(Constants.LAST_DESTINATIONS)) {\n+                    prox.requestDestinations(config, destinationCallback);\n+                    addCallback(destinationCallback);\n+                }\n+                if (isElectric) {\n+                    prox.requestChargingProfile(config, chargeProfileCallback);\n+                    addCallback(chargeProfileCallback);\n+                }\n+                synchronized (imageProperties) {\n+                    if (!imageCache.isPresent() && !imageProperties.failLimitReached()) {\n+                        prox.requestImage(config, imageProperties, imageCallback);\n+                        addCallback(imageCallback);\n+                    }\n+                }\n+            }, () -> {\n+                logger.warn(\"ConnectedDrive Configuration isn't present\");\n+            });\n+        }, () -> {\n+            logger.warn(\"ConnectedDrive Proxy isn't present\");\n+        });\n+    }\n+\n+    private synchronized void addCallback(ResponseCallback rc) {\n+        callbackCounter.ifPresent(counter -> counter.add(rc));\n+    }\n+\n+    private synchronized void removeCallback(ResponseCallback rc) {\n+        callbackCounter.ifPresent(counter -> {\n+            counter.remove(rc);\n+            // all necessary callbacks received => print and set to empty\n+            if (counter.isEmpty()) {\n+                logFingerPrint();\n+                callbackCounter = Optional.empty();\n+            }\n+        });\n+    }\n+\n+    private void logFingerPrint() {\n+        final String vin = configuration.map(config -> config.vin).orElse(\"\");\n+        logger.debug(\"###### BMW ConnectedDrive Binding - Vehicle Troubleshoot Fingerprint Data - BEGIN ######\");\n+        logger.debug(\"### Discovery Result ###\");\n+        bridgeHandler.ifPresent(handler -> {\n+            logger.debug(\"{}\", handler.getDiscoveryFingerprint());\n+        });\n+        vehicleStatusCache.ifPresentOrElse(vehicleStatus -> {\n+            logger.debug(\"### Vehicle Status ###\");\n+\n+            // Anonymous data for VIN and Position\n+            try {\n+                VehicleStatusContainer container = Converter.getGson().fromJson(vehicleStatus,\n+                        VehicleStatusContainer.class);\n+                if (container != null) {\n+                    VehicleStatus status = container.vehicleStatus;\n+                    if (status != null) {\n+                        status.vin = Constants.ANONYMOUS;\n+                        if (status.position != null) {\n+                            status.position.lat = -1;\n+                            status.position.lon = -1;\n+                            status.position.heading = -1;\n+                        }\n+                    }\n+                }\n+                logger.debug(\"{}\", Converter.getGson().toJson(container));\n+            } catch (JsonSyntaxException jse) {\n+                logger.debug(\"{}\", jse.getMessage());\n+            }\n+        }, () -> {\n+            logger.debug(\"### Vehicle Status Empty ###\");\n+        });\n+        lastTripCache.ifPresentOrElse(lastTrip -> {\n+            logger.debug(\"### Last Trip ###\");\n+            logger.debug(\"{}\", lastTrip.replaceAll(vin, Constants.ANONYMOUS));\n+        }, () -> {\n+            logger.debug(\"### Last Trip Empty ###\");\n+        });\n+        allTripsCache.ifPresentOrElse(allTrips -> {\n+            logger.debug(\"### All Trips ###\");\n+            logger.debug(\"{}\", allTrips.replaceAll(vin, Constants.ANONYMOUS));\n+        }, () -> {\n+            logger.debug(\"### All Trips Empty ###\");\n+        });\n+        if (isElectric) {\n+            chargeProfileCache.ifPresentOrElse(chargeProfile -> {\n+                logger.debug(\"### Charge Profile ###\");\n+                logger.debug(\"{}\", chargeProfile.replaceAll(vin, Constants.ANONYMOUS));\n+            }, () -> {\n+                logger.debug(\"### Charge Profile Empty ###\");\n+            });\n+        }\n+        destinationCache.ifPresentOrElse(destination -> {\n+            logger.debug(\"### Charge Profile ###\");\n+            try {\n+                DestinationContainer container = Converter.getGson().fromJson(destination, DestinationContainer.class);\n+                if (container != null) {\n+                    if (container.destinations != null) {\n+                        container.destinations.forEach(entry -> {\n+                            entry.lat = 0;\n+                            entry.lon = 0;\n+                            entry.city = Constants.ANONYMOUS;\n+                            entry.street = Constants.ANONYMOUS;\n+                            entry.streetNumber = Constants.ANONYMOUS;\n+                            entry.country = Constants.ANONYMOUS;\n+                        });\n+                        logger.debug(\"{}\", Converter.getGson().toJson(container));\n+                    }\n+                } else {\n+                    logger.debug(\"### Destinations Empty ###\");\n+                }\n+            } catch (JsonSyntaxException jse) {\n+                logger.debug(\"{}\", jse.getMessage());\n+            }\n+        }, () -> {\n+            logger.debug(\"### Charge Profile Empty ###\");\n+        });\n+        rangeMapCache.ifPresentOrElse(rangeMap -> {\n+            logger.debug(\"### Range Map ###\");\n+            logger.debug(\"{}\", rangeMap.replaceAll(vin, Constants.ANONYMOUS));\n+        }, () -> {\n+            logger.debug(\"### Range Map Empty ###\");\n+        });\n+        logger.debug(\"###### BMW ConnectedDrive Binding - Vehicle Troubleshoot Fingerprint Data - END ######\");\n+    }\n+\n+    /**\n+     * Don't stress ConnectedDrive with unnecessary requests. One call at the beginning is done to check the response.\n+     * After cache has e.g. a proper error response it will be shown in the fingerprint\n+     *\n+     * @return\n+     */\n+    private boolean isSupported(String service) {\n+        final String services = thing.getProperties().get(Constants.SERVICES_SUPPORTED);\n+        if (services != null) {\n+            if (services.contains(service)) {\n+                return true;\n+            }\n+        }\n+        // if cache is empty give it a try one time to collected Troubleshoot data\n+        if (lastTripCache.isEmpty() || allTripsCache.isEmpty() || destinationCache.isEmpty()) {\n+            return true;\n+        } else {\n+            return false;\n+        }\n+    }\n+\n+    public void updateRemoteExecutionStatus(@Nullable String service, @Nullable String status) {\n+        if (RemoteService.CHARGING_CONTROL.toString().equals(service)\n+                && ExecutionState.EXECUTED.name().equals(status)) {\n+            saveChargeProfileSent();\n+        }\n+        updateChannel(CHANNEL_GROUP_REMOTE, REMOTE_STATE, StringType.valueOf(Converter.toTitleCase(\n+                new StringBuilder(service == null ? \"-\" : service).append(\" \").append(status).toString())));\n+    }\n+\n+    public Optional<VehicleConfiguration> getConfiguration() {\n+        return configuration;\n+    }\n+\n+    public ScheduledExecutorService getScheduler() {\n+        return scheduler;\n+    }\n+\n+    /**\n+     * Callbacks for ConnectedDrive Portal\n+     *\n+     * @author Bernd Weymann\n+     *\n+     */\n+    @NonNullByDefault({})\n+    public class ChargeProfilesCallback implements StringResponseCallback {\n+        @Override\n+        public void onResponse(@Nullable String content) {\n+            if (content != null) {\n+                chargeProfileCache = Optional.of(content);\n+                if (chargeProfileEdit.isEmpty()) {\n+                    updateChargeProfileFromContent(content);\n+                }\n+            }\n+            removeCallback(this);\n+        }\n+\n+        /**\n+         * Store Error Report in cache variable. Via Fingerprint Channel error is logged and Issue can be raised\n+         */\n+        @Override\n+        public void onError(NetworkError error) {\n+            logger.debug(\"{}\", error.toString());\n+            chargeProfileCache = Optional.of(Converter.getGson().toJson(error));\n+            removeCallback(this);\n+        }\n+    }\n+\n+    @NonNullByDefault({})\n+    public class RangeMapCallback implements StringResponseCallback {\n+        @Override\n+        public void onResponse(@Nullable String content) {\n+            rangeMapCache = Optional.ofNullable(content);\n+            removeCallback(this);\n+        }\n+\n+        /**\n+         * Store Error Report in cache variable. Via Fingerprint Channel error is logged and Issue can be raised\n+         */\n+        @Override\n+        public void onError(NetworkError error) {\n+            logger.debug(\"{}\", error.toString());\n+            rangeMapCache = Optional.of(Converter.getGson().toJson(error));\n+            removeCallback(this);\n+        }\n+    }\n+\n+    @NonNullByDefault({})\n+    public class DestinationsCallback implements StringResponseCallback {\n+\n+        @Override\n+        public void onResponse(@Nullable String content) {\n+            destinationCache = Optional.ofNullable(content);\n+            if (content != null) {\n+                try {\n+                    DestinationContainer dc = Converter.getGson().fromJson(content, DestinationContainer.class);\n+                    if (dc != null && dc.destinations != null) {\n+                        updateDestinations(dc.destinations);\n+                    }\n+                } catch (JsonSyntaxException jse) {\n+                    logger.debug(\"{}\", jse.getMessage());\n+                }\n+            }\n+            removeCallback(this);\n+        }\n+\n+        /**\n+         * Store Error Report in cache variable. Via Fingerprint Channel error is logged and Issue can be raised\n+         */\n+        @Override\n+        public void onError(NetworkError error) {\n+            logger.debug(\"{}\", error.toString());\n+            destinationCache = Optional.of(Converter.getGson().toJson(error));\n+            removeCallback(this);\n+        }\n+    }\n+\n+    @NonNullByDefault({})\n+    public class ImageCallback implements ByteResponseCallback {\n+        @Override\n+        public void onResponse(byte[] content) {\n+            if (content.length > 0) {\n+                imageCache = Optional.of(content);\n+                String contentType = HttpUtil.guessContentTypeFromData(content);\n+                updateChannel(CHANNEL_GROUP_VEHICLE_IMAGE, IMAGE_FORMAT, new RawType(content, contentType));\n+            } else {\n+                synchronized (imageProperties) {\n+                    imageProperties.failed();\n+                }\n+            }\n+            removeCallback(this);\n+        }\n+\n+        /**\n+         * Store Error Report in cache variable. Via Fingerprint Channel error is logged and Issue can be raised\n+         */\n+        @Override\n+        public void onError(NetworkError error) {\n+            logger.debug(\"{}\", error.toString());\n+            synchronized (imageProperties) {\n+                imageProperties.failed();\n+            }\n+            removeCallback(this);\n+        }\n+    }\n+\n+    @NonNullByDefault({})\n+    public class AllTripsCallback implements StringResponseCallback {\n+        @Override\n+        public void onResponse(@Nullable String content) {\n+            if (content != null) {\n+                allTripsCache = Optional.of(content);\n+                try {\n+                    AllTripsContainer atc = Converter.getGson().fromJson(content, AllTripsContainer.class);\n+                    if (atc != null) {\n+                        AllTrips at = atc.allTrips;\n+                        if (at != null) {\n+                            updateAllTrips(at);\n+                        }\n+                    }\n+                } catch (JsonSyntaxException jse) {\n+                    logger.debug(\"{}\", jse.getMessage());\n+                }\n+            }\n+            removeCallback(this);\n+        }\n+\n+        /**\n+         * Store Error Report in cache variable. Via Fingerprint Channel error is logged and Issue can be raised\n+         */\n+        @Override\n+        public void onError(NetworkError error) {\n+            logger.debug(\"{}\", error.toString());\n+            allTripsCache = Optional.of(Converter.getGson().toJson(error));\n+            removeCallback(this);\n+        }\n+    }\n+\n+    @NonNullByDefault({})\n+    public class LastTripCallback implements StringResponseCallback {\n+        @Override\n+        public void onResponse(@Nullable String content) {\n+            if (content != null) {\n+                lastTripCache = Optional.of(content);\n+                try {\n+                    LastTripContainer lt = Converter.getGson().fromJson(content, LastTripContainer.class);\n+                    if (lt != null) {\n+                        LastTrip trip = lt.lastTrip;\n+                        if (trip != null) {\n+                            updateLastTrip(trip);\n+                        }\n+                    }\n+                } catch (JsonSyntaxException jse) {\n+                    logger.debug(\"{}\", jse.getMessage());\n+                }\n+            }\n+            removeCallback(this);\n+        }\n+\n+        /**\n+         * Store Error Report in cache variable. Via Fingerprint Channel error is logged and Issue can be raised\n+         */\n+        @Override\n+        public void onError(NetworkError error) {\n+            logger.debug(\"{}\", error.toString());\n+            lastTripCache = Optional.of(Converter.getGson().toJson(error));\n+            removeCallback(this);\n+        }\n+    }\n+\n+    /**\n+     * The VehicleStatus is supported by all Vehicle Types so it's used to reflect the Thing Status\n+     */\n+    @NonNullByDefault({})\n+    public class VehicleStatusCallback implements StringResponseCallback {\n+        private ThingStatus thingStatus = ThingStatus.UNKNOWN;\n+\n+        /**\n+         * Vehicle Status is supported by all Vehicles so callback result is used to report Thing Status.\n+         * If valid content is delivered in onResponse Thing goes online while onError Thing goes offline\n+         *\n+         * @param status\n+         * @param detail\n+         * @param reason\n+         */\n+        private void setThingStatus(ThingStatus status, ThingStatusDetail detail, String reason) {\n+            if (thingStatus != status) {\n+                updateStatus(status, detail, reason);\n+            }\n+        }\n+\n+        @Override\n+        public void onResponse(@Nullable String content) {\n+            if (content != null) {\n+                setThingStatus(ThingStatus.ONLINE, ThingStatusDetail.NONE, Constants.EMPTY);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "48af48c82562d006b6f2aa35922270f181c885ed"}, "originalPosition": 645}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMDA3ODc2Ng==", "bodyText": "fixed", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r600078766", "createdAt": "2021-03-24T01:08:00Z", "author": {"login": "weymann"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/VehicleHandler.java", "diffHunk": "@@ -0,0 +1,826 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bmwconnecteddrive.internal.handler;\n+\n+import static org.openhab.binding.bmwconnecteddrive.internal.ConnectedDriveConstants.*;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.bmwconnecteddrive.internal.VehicleConfiguration;\n+import org.openhab.binding.bmwconnecteddrive.internal.action.ChargeProfileActions;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.DestinationContainer;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.NetworkError;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.compat.VehicleAttributesContainer;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.statistics.AllTrips;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.statistics.AllTripsContainer;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.statistics.LastTrip;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.statistics.LastTripContainer;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.status.VehicleStatus;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.status.VehicleStatusContainer;\n+import org.openhab.binding.bmwconnecteddrive.internal.handler.RemoteServiceHandler.ExecutionState;\n+import org.openhab.binding.bmwconnecteddrive.internal.handler.RemoteServiceHandler.RemoteService;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileUtils;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileUtils.ChargeKeyDay;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileUtils.ChargeKeyHour;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileWrapper;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileWrapper.ProfileKey;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Constants;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Converter;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ImageProperties;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.RemoteServiceUtils;\n+import org.openhab.core.io.net.http.HttpUtil;\n+import org.openhab.core.library.types.DecimalType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.RawType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BridgeHandler;\n+import org.openhab.core.thing.binding.ThingHandlerService;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+\n+import com.google.gson.JsonSyntaxException;\n+\n+/**\n+ * The {@link VehicleHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Bernd Weymann - Initial contribution\n+ * @author Norbert Truchsess - edit & send charge profile\n+ */\n+@NonNullByDefault\n+public class VehicleHandler extends VehicleChannelHandler {\n+    private boolean legacyMode = false; // switch to legacy API in case of 404 Errors\n+\n+    private Optional<ConnectedDriveProxy> proxy = Optional.empty();\n+    private Optional<RemoteServiceHandler> remote = Optional.empty();\n+    private Optional<VehicleConfiguration> configuration = Optional.empty();\n+    private Optional<ConnectedDriveBridgeHandler> bridgeHandler = Optional.empty();\n+    private Optional<ScheduledFuture<?>> refreshJob = Optional.empty();\n+    private Optional<ScheduledFuture<?>> editTimeout = Optional.empty();\n+    private Optional<List<ResponseCallback>> callbackCounter = Optional.empty();\n+\n+    private ImageProperties imageProperties = new ImageProperties();\n+    VehicleStatusCallback vehicleStatusCallback = new VehicleStatusCallback();\n+    StringResponseCallback oldVehicleStatusCallback = new LegacyVehicleStatusCallback();\n+    StringResponseCallback lastTripCallback = new LastTripCallback();\n+    StringResponseCallback allTripsCallback = new AllTripsCallback();\n+    StringResponseCallback chargeProfileCallback = new ChargeProfilesCallback();\n+    StringResponseCallback rangeMapCallback = new RangeMapCallback();\n+    DestinationsCallback destinationCallback = new DestinationsCallback();\n+    ByteResponseCallback imageCallback = new ImageCallback();\n+\n+    private Optional<ChargeProfileWrapper> chargeProfileEdit = Optional.empty();\n+    private Optional<String> chargeProfileSent = Optional.empty();\n+\n+    public VehicleHandler(Thing thing, BMWConnectedDriveOptionProvider op, String type, boolean imperial) {\n+        super(thing, op, type, imperial);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        String group = channelUID.getGroupId();\n+\n+        // Refresh of Channels with cached values\n+        if (command instanceof RefreshType) {\n+            if (CHANNEL_GROUP_LAST_TRIP.equals(group)) {\n+                lastTripCache.ifPresent(lastTrip -> lastTripCallback.onResponse(lastTrip));\n+            } else if (CHANNEL_GROUP_LIFETIME.equals(group)) {\n+                allTripsCache.ifPresent(allTrips -> allTripsCallback.onResponse(allTrips));\n+            } else if (CHANNEL_GROUP_DESTINATION.equals(group)) {\n+                destinationCache.ifPresent(destination -> destinationCallback.onResponse(destination));\n+            } else if (CHANNEL_GROUP_STATUS.equals(group)) {\n+                vehicleStatusCache.ifPresent(vehicleStatus -> vehicleStatusCallback.onResponse(vehicleStatus));\n+            } else if (CHANNEL_GROUP_CHARGE.equals(group)) {\n+                chargeProfileEdit.ifPresentOrElse(this::updateChargeProfile,\n+                        () -> chargeProfileCache.ifPresent(this::updateChargeProfileFromContent));\n+            } else if (CHANNEL_GROUP_VEHICLE_IMAGE.equals(group)) {\n+                imageCache.ifPresent(image -> imageCallback.onResponse(image));\n+            }\n+            // Check for Channel Group and corresponding Actions\n+        } else if (CHANNEL_GROUP_REMOTE.equals(group)) {\n+            // Executing Remote Services\n+            if (command instanceof StringType) {\n+                String serviceCommand = ((StringType) command).toFullString();\n+                remote.ifPresent(remot -> {\n+                    switch (serviceCommand) {\n+                        case REMOTE_SERVICE_LIGHT_FLASH:\n+                        case REMOTE_SERVICE_AIR_CONDITIONING:\n+                        case REMOTE_SERVICE_DOOR_LOCK:\n+                        case REMOTE_SERVICE_DOOR_UNLOCK:\n+                        case REMOTE_SERVICE_HORN:\n+                        case REMOTE_SERVICE_VEHICLE_FINDER:\n+                        case REMOTE_SERVICE_CHARGE_NOW:\n+                            RemoteServiceUtils.getRemoteService(serviceCommand)\n+                                    .ifPresentOrElse(service -> remot.execute(service), () -> {\n+                                        logger.info(\"Remote service execution {} unknown\", serviceCommand);\n+                                    });\n+                            break;\n+                        case REMOTE_SERVICE_CHARGING_CONTROL:\n+                            sendChargeProfile(chargeProfileEdit);\n+                            break;\n+                        default:\n+                            logger.info(\"Remote service execution {} unknown\", serviceCommand);\n+                            break;\n+                    }\n+                });\n+            }\n+        } else if (CHANNEL_GROUP_VEHICLE_IMAGE.equals(group)) {\n+            // Image Change\n+            configuration.ifPresent(config -> {\n+                if (command instanceof StringType) {\n+                    if (channelUID.getIdWithoutGroup().equals(IMAGE_VIEWPORT)) {\n+                        String newViewport = command.toString();\n+                        synchronized (imageProperties) {\n+                            if (!imageProperties.viewport.equals(newViewport)) {\n+                                imageProperties = new ImageProperties(newViewport, imageProperties.size);\n+                                imageCache = Optional.empty();\n+                                proxy.ifPresent(prox -> prox.requestImage(config, imageProperties, imageCallback));\n+                            }\n+                        }\n+                        updateChannel(CHANNEL_GROUP_VEHICLE_IMAGE, IMAGE_VIEWPORT, StringType.valueOf(newViewport));\n+                    }\n+                }\n+                if (command instanceof DecimalType) {\n+                    if (command instanceof DecimalType) {\n+                        int newImageSize = ((DecimalType) command).intValue();\n+                        if (channelUID.getIdWithoutGroup().equals(IMAGE_SIZE)) {\n+                            synchronized (imageProperties) {\n+                                if (imageProperties.size != newImageSize) {\n+                                    imageProperties = new ImageProperties(imageProperties.viewport, newImageSize);\n+                                    imageCache = Optional.empty();\n+                                    proxy.ifPresent(prox -> prox.requestImage(config, imageProperties, imageCallback));\n+                                }\n+                            }\n+                        }\n+                        updateChannel(CHANNEL_GROUP_VEHICLE_IMAGE, IMAGE_SIZE, new DecimalType(newImageSize));\n+                    }\n+                }\n+            });\n+        } else if (CHANNEL_GROUP_DESTINATION.equals(group)) {\n+            if (command instanceof StringType) {\n+                int index = Converter.getIndex(command.toFullString());\n+                if (index != -1) {\n+                    selectDestination(index);\n+                } else {\n+                    logger.debug(\"Cannot select Destination index {}\", command.toFullString());\n+                }\n+            }\n+        } else if (CHANNEL_GROUP_SERVICE.equals(group)) {\n+            if (command instanceof StringType) {\n+                int index = Converter.getIndex(command.toFullString());\n+                if (index != -1) {\n+                    selectService(index);\n+                } else {\n+                    logger.debug(\"Cannot select Service index {}\", command.toFullString());\n+                }\n+            }\n+        } else if (CHANNEL_GROUP_CHECK_CONTROL.equals(group)) {\n+            if (command instanceof StringType) {\n+                int index = Converter.getIndex(command.toFullString());\n+                if (index != -1) {\n+                    selectCheckControl(index);\n+                } else {\n+                    logger.debug(\"Cannot select CheckControl index {}\", command.toFullString());\n+                }\n+            }\n+        } else if (CHANNEL_GROUP_CHARGE.equals(group)) {\n+            handleChargeProfileCommand(channelUID, command);\n+        }\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        callbackCounter = Optional.of(new ArrayList<ResponseCallback>());\n+        updateStatus(ThingStatus.UNKNOWN);\n+        final VehicleConfiguration config = getConfigAs(VehicleConfiguration.class);\n+        if (config != null) {\n+            configuration = Optional.of(config);\n+            scheduler.execute(() -> {\n+                Bridge bridge = getBridge();\n+                if (bridge != null) {\n+                    BridgeHandler handler = bridge.getHandler();\n+                    if (handler != null) {\n+                        bridgeHandler = Optional.of(((ConnectedDriveBridgeHandler) handler));\n+                        proxy = ((ConnectedDriveBridgeHandler) handler).getProxy();\n+                        remote = proxy.map(prox -> prox.getRemoteServiceHandler(this));\n+                    } else {\n+                        logger.debug(\"Bridge Handler null\");\n+                    }\n+                } else {\n+                    logger.debug(\"Bridge null\");\n+                }\n+\n+                // get Image after init with config values\n+                synchronized (imageProperties) {\n+                    imageProperties = new ImageProperties(config.imageViewport, config.imageSize);\n+                }\n+                updateChannel(CHANNEL_GROUP_VEHICLE_IMAGE, IMAGE_VIEWPORT, StringType.valueOf((config.imageViewport)));\n+                updateChannel(CHANNEL_GROUP_VEHICLE_IMAGE, IMAGE_SIZE, new DecimalType((config.imageSize)));\n+\n+                // check imperial setting is different to AutoDetect\n+                if (!UNITS_AUTODETECT.equals(config.units)) {\n+                    imperial = UNITS_IMPERIAL.equals(config.units);\n+                }\n+\n+                // start update schedule\n+                startSchedule(config.refreshInterval);\n+            });\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR);\n+        }\n+    }\n+\n+    private void startSchedule(int interval) {\n+        refreshJob.ifPresentOrElse(job -> {\n+            if (job.isCancelled()) {\n+                refreshJob = Optional\n+                        .of(scheduler.scheduleWithFixedDelay(this::getData, 0, interval, TimeUnit.MINUTES));\n+            } // else - scheduler is already running!\n+        }, () -> {\n+            refreshJob = Optional.of(scheduler.scheduleWithFixedDelay(this::getData, 0, interval, TimeUnit.MINUTES));\n+        });\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        refreshJob.ifPresent(job -> job.cancel(true));\n+    }\n+\n+    public void getData() {\n+        proxy.ifPresentOrElse(prox -> {\n+            configuration.ifPresentOrElse(config -> {\n+                if (!legacyMode) {\n+                    prox.requestVehcileStatus(config, vehicleStatusCallback);\n+                } else {\n+                    prox.requestLegacyVehcileStatus(config, oldVehicleStatusCallback);\n+                }\n+                addCallback(vehicleStatusCallback);\n+                if (isSupported(Constants.STATISTICS)) {\n+                    prox.requestLastTrip(config, lastTripCallback);\n+                    prox.requestAllTrips(config, allTripsCallback);\n+                    addCallback(lastTripCallback);\n+                    addCallback(allTripsCallback);\n+                }\n+                if (isSupported(Constants.LAST_DESTINATIONS)) {\n+                    prox.requestDestinations(config, destinationCallback);\n+                    addCallback(destinationCallback);\n+                }\n+                if (isElectric) {\n+                    prox.requestChargingProfile(config, chargeProfileCallback);\n+                    addCallback(chargeProfileCallback);\n+                }\n+                synchronized (imageProperties) {\n+                    if (!imageCache.isPresent() && !imageProperties.failLimitReached()) {\n+                        prox.requestImage(config, imageProperties, imageCallback);\n+                        addCallback(imageCallback);\n+                    }\n+                }\n+            }, () -> {\n+                logger.warn(\"ConnectedDrive Configuration isn't present\");\n+            });\n+        }, () -> {\n+            logger.warn(\"ConnectedDrive Proxy isn't present\");\n+        });\n+    }\n+\n+    private synchronized void addCallback(ResponseCallback rc) {\n+        callbackCounter.ifPresent(counter -> counter.add(rc));\n+    }\n+\n+    private synchronized void removeCallback(ResponseCallback rc) {\n+        callbackCounter.ifPresent(counter -> {\n+            counter.remove(rc);\n+            // all necessary callbacks received => print and set to empty\n+            if (counter.isEmpty()) {\n+                logFingerPrint();\n+                callbackCounter = Optional.empty();\n+            }\n+        });\n+    }\n+\n+    private void logFingerPrint() {\n+        final String vin = configuration.map(config -> config.vin).orElse(\"\");\n+        logger.debug(\"###### BMW ConnectedDrive Binding - Vehicle Troubleshoot Fingerprint Data - BEGIN ######\");\n+        logger.debug(\"### Discovery Result ###\");\n+        bridgeHandler.ifPresent(handler -> {\n+            logger.debug(\"{}\", handler.getDiscoveryFingerprint());\n+        });\n+        vehicleStatusCache.ifPresentOrElse(vehicleStatus -> {\n+            logger.debug(\"### Vehicle Status ###\");\n+\n+            // Anonymous data for VIN and Position\n+            try {\n+                VehicleStatusContainer container = Converter.getGson().fromJson(vehicleStatus,\n+                        VehicleStatusContainer.class);\n+                if (container != null) {\n+                    VehicleStatus status = container.vehicleStatus;\n+                    if (status != null) {\n+                        status.vin = Constants.ANONYMOUS;\n+                        if (status.position != null) {\n+                            status.position.lat = -1;\n+                            status.position.lon = -1;\n+                            status.position.heading = -1;\n+                        }\n+                    }\n+                }\n+                logger.debug(\"{}\", Converter.getGson().toJson(container));\n+            } catch (JsonSyntaxException jse) {\n+                logger.debug(\"{}\", jse.getMessage());\n+            }\n+        }, () -> {\n+            logger.debug(\"### Vehicle Status Empty ###\");\n+        });\n+        lastTripCache.ifPresentOrElse(lastTrip -> {\n+            logger.debug(\"### Last Trip ###\");\n+            logger.debug(\"{}\", lastTrip.replaceAll(vin, Constants.ANONYMOUS));\n+        }, () -> {\n+            logger.debug(\"### Last Trip Empty ###\");\n+        });\n+        allTripsCache.ifPresentOrElse(allTrips -> {\n+            logger.debug(\"### All Trips ###\");\n+            logger.debug(\"{}\", allTrips.replaceAll(vin, Constants.ANONYMOUS));\n+        }, () -> {\n+            logger.debug(\"### All Trips Empty ###\");\n+        });\n+        if (isElectric) {\n+            chargeProfileCache.ifPresentOrElse(chargeProfile -> {\n+                logger.debug(\"### Charge Profile ###\");\n+                logger.debug(\"{}\", chargeProfile.replaceAll(vin, Constants.ANONYMOUS));\n+            }, () -> {\n+                logger.debug(\"### Charge Profile Empty ###\");\n+            });\n+        }\n+        destinationCache.ifPresentOrElse(destination -> {\n+            logger.debug(\"### Charge Profile ###\");\n+            try {\n+                DestinationContainer container = Converter.getGson().fromJson(destination, DestinationContainer.class);\n+                if (container != null) {\n+                    if (container.destinations != null) {\n+                        container.destinations.forEach(entry -> {\n+                            entry.lat = 0;\n+                            entry.lon = 0;\n+                            entry.city = Constants.ANONYMOUS;\n+                            entry.street = Constants.ANONYMOUS;\n+                            entry.streetNumber = Constants.ANONYMOUS;\n+                            entry.country = Constants.ANONYMOUS;\n+                        });\n+                        logger.debug(\"{}\", Converter.getGson().toJson(container));\n+                    }\n+                } else {\n+                    logger.debug(\"### Destinations Empty ###\");\n+                }\n+            } catch (JsonSyntaxException jse) {\n+                logger.debug(\"{}\", jse.getMessage());\n+            }\n+        }, () -> {\n+            logger.debug(\"### Charge Profile Empty ###\");\n+        });\n+        rangeMapCache.ifPresentOrElse(rangeMap -> {\n+            logger.debug(\"### Range Map ###\");\n+            logger.debug(\"{}\", rangeMap.replaceAll(vin, Constants.ANONYMOUS));\n+        }, () -> {\n+            logger.debug(\"### Range Map Empty ###\");\n+        });\n+        logger.debug(\"###### BMW ConnectedDrive Binding - Vehicle Troubleshoot Fingerprint Data - END ######\");\n+    }\n+\n+    /**\n+     * Don't stress ConnectedDrive with unnecessary requests. One call at the beginning is done to check the response.\n+     * After cache has e.g. a proper error response it will be shown in the fingerprint\n+     *\n+     * @return\n+     */\n+    private boolean isSupported(String service) {\n+        final String services = thing.getProperties().get(Constants.SERVICES_SUPPORTED);\n+        if (services != null) {\n+            if (services.contains(service)) {\n+                return true;\n+            }\n+        }\n+        // if cache is empty give it a try one time to collected Troubleshoot data\n+        if (lastTripCache.isEmpty() || allTripsCache.isEmpty() || destinationCache.isEmpty()) {\n+            return true;\n+        } else {\n+            return false;\n+        }\n+    }\n+\n+    public void updateRemoteExecutionStatus(@Nullable String service, @Nullable String status) {\n+        if (RemoteService.CHARGING_CONTROL.toString().equals(service)\n+                && ExecutionState.EXECUTED.name().equals(status)) {\n+            saveChargeProfileSent();\n+        }\n+        updateChannel(CHANNEL_GROUP_REMOTE, REMOTE_STATE, StringType.valueOf(Converter.toTitleCase(\n+                new StringBuilder(service == null ? \"-\" : service).append(\" \").append(status).toString())));\n+    }\n+\n+    public Optional<VehicleConfiguration> getConfiguration() {\n+        return configuration;\n+    }\n+\n+    public ScheduledExecutorService getScheduler() {\n+        return scheduler;\n+    }\n+\n+    /**\n+     * Callbacks for ConnectedDrive Portal\n+     *\n+     * @author Bernd Weymann\n+     *\n+     */\n+    @NonNullByDefault({})\n+    public class ChargeProfilesCallback implements StringResponseCallback {\n+        @Override\n+        public void onResponse(@Nullable String content) {\n+            if (content != null) {\n+                chargeProfileCache = Optional.of(content);\n+                if (chargeProfileEdit.isEmpty()) {\n+                    updateChargeProfileFromContent(content);\n+                }\n+            }\n+            removeCallback(this);\n+        }\n+\n+        /**\n+         * Store Error Report in cache variable. Via Fingerprint Channel error is logged and Issue can be raised\n+         */\n+        @Override\n+        public void onError(NetworkError error) {\n+            logger.debug(\"{}\", error.toString());\n+            chargeProfileCache = Optional.of(Converter.getGson().toJson(error));\n+            removeCallback(this);\n+        }\n+    }\n+\n+    @NonNullByDefault({})\n+    public class RangeMapCallback implements StringResponseCallback {\n+        @Override\n+        public void onResponse(@Nullable String content) {\n+            rangeMapCache = Optional.ofNullable(content);\n+            removeCallback(this);\n+        }\n+\n+        /**\n+         * Store Error Report in cache variable. Via Fingerprint Channel error is logged and Issue can be raised\n+         */\n+        @Override\n+        public void onError(NetworkError error) {\n+            logger.debug(\"{}\", error.toString());\n+            rangeMapCache = Optional.of(Converter.getGson().toJson(error));\n+            removeCallback(this);\n+        }\n+    }\n+\n+    @NonNullByDefault({})\n+    public class DestinationsCallback implements StringResponseCallback {\n+\n+        @Override\n+        public void onResponse(@Nullable String content) {\n+            destinationCache = Optional.ofNullable(content);\n+            if (content != null) {\n+                try {\n+                    DestinationContainer dc = Converter.getGson().fromJson(content, DestinationContainer.class);\n+                    if (dc != null && dc.destinations != null) {\n+                        updateDestinations(dc.destinations);\n+                    }\n+                } catch (JsonSyntaxException jse) {\n+                    logger.debug(\"{}\", jse.getMessage());\n+                }\n+            }\n+            removeCallback(this);\n+        }\n+\n+        /**\n+         * Store Error Report in cache variable. Via Fingerprint Channel error is logged and Issue can be raised\n+         */\n+        @Override\n+        public void onError(NetworkError error) {\n+            logger.debug(\"{}\", error.toString());\n+            destinationCache = Optional.of(Converter.getGson().toJson(error));\n+            removeCallback(this);\n+        }\n+    }\n+\n+    @NonNullByDefault({})\n+    public class ImageCallback implements ByteResponseCallback {\n+        @Override\n+        public void onResponse(byte[] content) {\n+            if (content.length > 0) {\n+                imageCache = Optional.of(content);\n+                String contentType = HttpUtil.guessContentTypeFromData(content);\n+                updateChannel(CHANNEL_GROUP_VEHICLE_IMAGE, IMAGE_FORMAT, new RawType(content, contentType));\n+            } else {\n+                synchronized (imageProperties) {\n+                    imageProperties.failed();\n+                }\n+            }\n+            removeCallback(this);\n+        }\n+\n+        /**\n+         * Store Error Report in cache variable. Via Fingerprint Channel error is logged and Issue can be raised\n+         */\n+        @Override\n+        public void onError(NetworkError error) {\n+            logger.debug(\"{}\", error.toString());\n+            synchronized (imageProperties) {\n+                imageProperties.failed();\n+            }\n+            removeCallback(this);\n+        }\n+    }\n+\n+    @NonNullByDefault({})\n+    public class AllTripsCallback implements StringResponseCallback {\n+        @Override\n+        public void onResponse(@Nullable String content) {\n+            if (content != null) {\n+                allTripsCache = Optional.of(content);\n+                try {\n+                    AllTripsContainer atc = Converter.getGson().fromJson(content, AllTripsContainer.class);\n+                    if (atc != null) {\n+                        AllTrips at = atc.allTrips;\n+                        if (at != null) {\n+                            updateAllTrips(at);\n+                        }\n+                    }\n+                } catch (JsonSyntaxException jse) {\n+                    logger.debug(\"{}\", jse.getMessage());\n+                }\n+            }\n+            removeCallback(this);\n+        }\n+\n+        /**\n+         * Store Error Report in cache variable. Via Fingerprint Channel error is logged and Issue can be raised\n+         */\n+        @Override\n+        public void onError(NetworkError error) {\n+            logger.debug(\"{}\", error.toString());\n+            allTripsCache = Optional.of(Converter.getGson().toJson(error));\n+            removeCallback(this);\n+        }\n+    }\n+\n+    @NonNullByDefault({})\n+    public class LastTripCallback implements StringResponseCallback {\n+        @Override\n+        public void onResponse(@Nullable String content) {\n+            if (content != null) {\n+                lastTripCache = Optional.of(content);\n+                try {\n+                    LastTripContainer lt = Converter.getGson().fromJson(content, LastTripContainer.class);\n+                    if (lt != null) {\n+                        LastTrip trip = lt.lastTrip;\n+                        if (trip != null) {\n+                            updateLastTrip(trip);\n+                        }\n+                    }\n+                } catch (JsonSyntaxException jse) {\n+                    logger.debug(\"{}\", jse.getMessage());\n+                }\n+            }\n+            removeCallback(this);\n+        }\n+\n+        /**\n+         * Store Error Report in cache variable. Via Fingerprint Channel error is logged and Issue can be raised\n+         */\n+        @Override\n+        public void onError(NetworkError error) {\n+            logger.debug(\"{}\", error.toString());\n+            lastTripCache = Optional.of(Converter.getGson().toJson(error));\n+            removeCallback(this);\n+        }\n+    }\n+\n+    /**\n+     * The VehicleStatus is supported by all Vehicle Types so it's used to reflect the Thing Status\n+     */\n+    @NonNullByDefault({})\n+    public class VehicleStatusCallback implements StringResponseCallback {\n+        private ThingStatus thingStatus = ThingStatus.UNKNOWN;\n+\n+        /**\n+         * Vehicle Status is supported by all Vehicles so callback result is used to report Thing Status.\n+         * If valid content is delivered in onResponse Thing goes online while onError Thing goes offline\n+         *\n+         * @param status\n+         * @param detail\n+         * @param reason\n+         */\n+        private void setThingStatus(ThingStatus status, ThingStatusDetail detail, String reason) {\n+            if (thingStatus != status) {\n+                updateStatus(status, detail, reason);\n+            }\n+        }\n+\n+        @Override\n+        public void onResponse(@Nullable String content) {\n+            if (content != null) {\n+                setThingStatus(ThingStatus.ONLINE, ThingStatusDetail.NONE, Constants.EMPTY);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5NzkyMTI3NQ=="}, "originalCommit": {"oid": "48af48c82562d006b6f2aa35922270f181c885ed"}, "originalPosition": 645}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzc3Njc5NTYzOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/VehicleHandler.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0xOVQxOToxOTowMFrOI6OPdg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0yNFQwMDoyNjowOFrOI8Qlkg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5NzkyMTY1NA==", "bodyText": "Is there any case where status can be null?", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r597921654", "createdAt": "2021-03-19T19:19:00Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/VehicleHandler.java", "diffHunk": "@@ -0,0 +1,826 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bmwconnecteddrive.internal.handler;\n+\n+import static org.openhab.binding.bmwconnecteddrive.internal.ConnectedDriveConstants.*;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.bmwconnecteddrive.internal.VehicleConfiguration;\n+import org.openhab.binding.bmwconnecteddrive.internal.action.ChargeProfileActions;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.DestinationContainer;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.NetworkError;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.compat.VehicleAttributesContainer;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.statistics.AllTrips;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.statistics.AllTripsContainer;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.statistics.LastTrip;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.statistics.LastTripContainer;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.status.VehicleStatus;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.status.VehicleStatusContainer;\n+import org.openhab.binding.bmwconnecteddrive.internal.handler.RemoteServiceHandler.ExecutionState;\n+import org.openhab.binding.bmwconnecteddrive.internal.handler.RemoteServiceHandler.RemoteService;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileUtils;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileUtils.ChargeKeyDay;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileUtils.ChargeKeyHour;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileWrapper;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileWrapper.ProfileKey;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Constants;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Converter;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ImageProperties;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.RemoteServiceUtils;\n+import org.openhab.core.io.net.http.HttpUtil;\n+import org.openhab.core.library.types.DecimalType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.RawType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BridgeHandler;\n+import org.openhab.core.thing.binding.ThingHandlerService;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+\n+import com.google.gson.JsonSyntaxException;\n+\n+/**\n+ * The {@link VehicleHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Bernd Weymann - Initial contribution\n+ * @author Norbert Truchsess - edit & send charge profile\n+ */\n+@NonNullByDefault\n+public class VehicleHandler extends VehicleChannelHandler {\n+    private boolean legacyMode = false; // switch to legacy API in case of 404 Errors\n+\n+    private Optional<ConnectedDriveProxy> proxy = Optional.empty();\n+    private Optional<RemoteServiceHandler> remote = Optional.empty();\n+    private Optional<VehicleConfiguration> configuration = Optional.empty();\n+    private Optional<ConnectedDriveBridgeHandler> bridgeHandler = Optional.empty();\n+    private Optional<ScheduledFuture<?>> refreshJob = Optional.empty();\n+    private Optional<ScheduledFuture<?>> editTimeout = Optional.empty();\n+    private Optional<List<ResponseCallback>> callbackCounter = Optional.empty();\n+\n+    private ImageProperties imageProperties = new ImageProperties();\n+    VehicleStatusCallback vehicleStatusCallback = new VehicleStatusCallback();\n+    StringResponseCallback oldVehicleStatusCallback = new LegacyVehicleStatusCallback();\n+    StringResponseCallback lastTripCallback = new LastTripCallback();\n+    StringResponseCallback allTripsCallback = new AllTripsCallback();\n+    StringResponseCallback chargeProfileCallback = new ChargeProfilesCallback();\n+    StringResponseCallback rangeMapCallback = new RangeMapCallback();\n+    DestinationsCallback destinationCallback = new DestinationsCallback();\n+    ByteResponseCallback imageCallback = new ImageCallback();\n+\n+    private Optional<ChargeProfileWrapper> chargeProfileEdit = Optional.empty();\n+    private Optional<String> chargeProfileSent = Optional.empty();\n+\n+    public VehicleHandler(Thing thing, BMWConnectedDriveOptionProvider op, String type, boolean imperial) {\n+        super(thing, op, type, imperial);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        String group = channelUID.getGroupId();\n+\n+        // Refresh of Channels with cached values\n+        if (command instanceof RefreshType) {\n+            if (CHANNEL_GROUP_LAST_TRIP.equals(group)) {\n+                lastTripCache.ifPresent(lastTrip -> lastTripCallback.onResponse(lastTrip));\n+            } else if (CHANNEL_GROUP_LIFETIME.equals(group)) {\n+                allTripsCache.ifPresent(allTrips -> allTripsCallback.onResponse(allTrips));\n+            } else if (CHANNEL_GROUP_DESTINATION.equals(group)) {\n+                destinationCache.ifPresent(destination -> destinationCallback.onResponse(destination));\n+            } else if (CHANNEL_GROUP_STATUS.equals(group)) {\n+                vehicleStatusCache.ifPresent(vehicleStatus -> vehicleStatusCallback.onResponse(vehicleStatus));\n+            } else if (CHANNEL_GROUP_CHARGE.equals(group)) {\n+                chargeProfileEdit.ifPresentOrElse(this::updateChargeProfile,\n+                        () -> chargeProfileCache.ifPresent(this::updateChargeProfileFromContent));\n+            } else if (CHANNEL_GROUP_VEHICLE_IMAGE.equals(group)) {\n+                imageCache.ifPresent(image -> imageCallback.onResponse(image));\n+            }\n+            // Check for Channel Group and corresponding Actions\n+        } else if (CHANNEL_GROUP_REMOTE.equals(group)) {\n+            // Executing Remote Services\n+            if (command instanceof StringType) {\n+                String serviceCommand = ((StringType) command).toFullString();\n+                remote.ifPresent(remot -> {\n+                    switch (serviceCommand) {\n+                        case REMOTE_SERVICE_LIGHT_FLASH:\n+                        case REMOTE_SERVICE_AIR_CONDITIONING:\n+                        case REMOTE_SERVICE_DOOR_LOCK:\n+                        case REMOTE_SERVICE_DOOR_UNLOCK:\n+                        case REMOTE_SERVICE_HORN:\n+                        case REMOTE_SERVICE_VEHICLE_FINDER:\n+                        case REMOTE_SERVICE_CHARGE_NOW:\n+                            RemoteServiceUtils.getRemoteService(serviceCommand)\n+                                    .ifPresentOrElse(service -> remot.execute(service), () -> {\n+                                        logger.info(\"Remote service execution {} unknown\", serviceCommand);\n+                                    });\n+                            break;\n+                        case REMOTE_SERVICE_CHARGING_CONTROL:\n+                            sendChargeProfile(chargeProfileEdit);\n+                            break;\n+                        default:\n+                            logger.info(\"Remote service execution {} unknown\", serviceCommand);\n+                            break;\n+                    }\n+                });\n+            }\n+        } else if (CHANNEL_GROUP_VEHICLE_IMAGE.equals(group)) {\n+            // Image Change\n+            configuration.ifPresent(config -> {\n+                if (command instanceof StringType) {\n+                    if (channelUID.getIdWithoutGroup().equals(IMAGE_VIEWPORT)) {\n+                        String newViewport = command.toString();\n+                        synchronized (imageProperties) {\n+                            if (!imageProperties.viewport.equals(newViewport)) {\n+                                imageProperties = new ImageProperties(newViewport, imageProperties.size);\n+                                imageCache = Optional.empty();\n+                                proxy.ifPresent(prox -> prox.requestImage(config, imageProperties, imageCallback));\n+                            }\n+                        }\n+                        updateChannel(CHANNEL_GROUP_VEHICLE_IMAGE, IMAGE_VIEWPORT, StringType.valueOf(newViewport));\n+                    }\n+                }\n+                if (command instanceof DecimalType) {\n+                    if (command instanceof DecimalType) {\n+                        int newImageSize = ((DecimalType) command).intValue();\n+                        if (channelUID.getIdWithoutGroup().equals(IMAGE_SIZE)) {\n+                            synchronized (imageProperties) {\n+                                if (imageProperties.size != newImageSize) {\n+                                    imageProperties = new ImageProperties(imageProperties.viewport, newImageSize);\n+                                    imageCache = Optional.empty();\n+                                    proxy.ifPresent(prox -> prox.requestImage(config, imageProperties, imageCallback));\n+                                }\n+                            }\n+                        }\n+                        updateChannel(CHANNEL_GROUP_VEHICLE_IMAGE, IMAGE_SIZE, new DecimalType(newImageSize));\n+                    }\n+                }\n+            });\n+        } else if (CHANNEL_GROUP_DESTINATION.equals(group)) {\n+            if (command instanceof StringType) {\n+                int index = Converter.getIndex(command.toFullString());\n+                if (index != -1) {\n+                    selectDestination(index);\n+                } else {\n+                    logger.debug(\"Cannot select Destination index {}\", command.toFullString());\n+                }\n+            }\n+        } else if (CHANNEL_GROUP_SERVICE.equals(group)) {\n+            if (command instanceof StringType) {\n+                int index = Converter.getIndex(command.toFullString());\n+                if (index != -1) {\n+                    selectService(index);\n+                } else {\n+                    logger.debug(\"Cannot select Service index {}\", command.toFullString());\n+                }\n+            }\n+        } else if (CHANNEL_GROUP_CHECK_CONTROL.equals(group)) {\n+            if (command instanceof StringType) {\n+                int index = Converter.getIndex(command.toFullString());\n+                if (index != -1) {\n+                    selectCheckControl(index);\n+                } else {\n+                    logger.debug(\"Cannot select CheckControl index {}\", command.toFullString());\n+                }\n+            }\n+        } else if (CHANNEL_GROUP_CHARGE.equals(group)) {\n+            handleChargeProfileCommand(channelUID, command);\n+        }\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        callbackCounter = Optional.of(new ArrayList<ResponseCallback>());\n+        updateStatus(ThingStatus.UNKNOWN);\n+        final VehicleConfiguration config = getConfigAs(VehicleConfiguration.class);\n+        if (config != null) {\n+            configuration = Optional.of(config);\n+            scheduler.execute(() -> {\n+                Bridge bridge = getBridge();\n+                if (bridge != null) {\n+                    BridgeHandler handler = bridge.getHandler();\n+                    if (handler != null) {\n+                        bridgeHandler = Optional.of(((ConnectedDriveBridgeHandler) handler));\n+                        proxy = ((ConnectedDriveBridgeHandler) handler).getProxy();\n+                        remote = proxy.map(prox -> prox.getRemoteServiceHandler(this));\n+                    } else {\n+                        logger.debug(\"Bridge Handler null\");\n+                    }\n+                } else {\n+                    logger.debug(\"Bridge null\");\n+                }\n+\n+                // get Image after init with config values\n+                synchronized (imageProperties) {\n+                    imageProperties = new ImageProperties(config.imageViewport, config.imageSize);\n+                }\n+                updateChannel(CHANNEL_GROUP_VEHICLE_IMAGE, IMAGE_VIEWPORT, StringType.valueOf((config.imageViewport)));\n+                updateChannel(CHANNEL_GROUP_VEHICLE_IMAGE, IMAGE_SIZE, new DecimalType((config.imageSize)));\n+\n+                // check imperial setting is different to AutoDetect\n+                if (!UNITS_AUTODETECT.equals(config.units)) {\n+                    imperial = UNITS_IMPERIAL.equals(config.units);\n+                }\n+\n+                // start update schedule\n+                startSchedule(config.refreshInterval);\n+            });\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR);\n+        }\n+    }\n+\n+    private void startSchedule(int interval) {\n+        refreshJob.ifPresentOrElse(job -> {\n+            if (job.isCancelled()) {\n+                refreshJob = Optional\n+                        .of(scheduler.scheduleWithFixedDelay(this::getData, 0, interval, TimeUnit.MINUTES));\n+            } // else - scheduler is already running!\n+        }, () -> {\n+            refreshJob = Optional.of(scheduler.scheduleWithFixedDelay(this::getData, 0, interval, TimeUnit.MINUTES));\n+        });\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        refreshJob.ifPresent(job -> job.cancel(true));\n+    }\n+\n+    public void getData() {\n+        proxy.ifPresentOrElse(prox -> {\n+            configuration.ifPresentOrElse(config -> {\n+                if (!legacyMode) {\n+                    prox.requestVehcileStatus(config, vehicleStatusCallback);\n+                } else {\n+                    prox.requestLegacyVehcileStatus(config, oldVehicleStatusCallback);\n+                }\n+                addCallback(vehicleStatusCallback);\n+                if (isSupported(Constants.STATISTICS)) {\n+                    prox.requestLastTrip(config, lastTripCallback);\n+                    prox.requestAllTrips(config, allTripsCallback);\n+                    addCallback(lastTripCallback);\n+                    addCallback(allTripsCallback);\n+                }\n+                if (isSupported(Constants.LAST_DESTINATIONS)) {\n+                    prox.requestDestinations(config, destinationCallback);\n+                    addCallback(destinationCallback);\n+                }\n+                if (isElectric) {\n+                    prox.requestChargingProfile(config, chargeProfileCallback);\n+                    addCallback(chargeProfileCallback);\n+                }\n+                synchronized (imageProperties) {\n+                    if (!imageCache.isPresent() && !imageProperties.failLimitReached()) {\n+                        prox.requestImage(config, imageProperties, imageCallback);\n+                        addCallback(imageCallback);\n+                    }\n+                }\n+            }, () -> {\n+                logger.warn(\"ConnectedDrive Configuration isn't present\");\n+            });\n+        }, () -> {\n+            logger.warn(\"ConnectedDrive Proxy isn't present\");\n+        });\n+    }\n+\n+    private synchronized void addCallback(ResponseCallback rc) {\n+        callbackCounter.ifPresent(counter -> counter.add(rc));\n+    }\n+\n+    private synchronized void removeCallback(ResponseCallback rc) {\n+        callbackCounter.ifPresent(counter -> {\n+            counter.remove(rc);\n+            // all necessary callbacks received => print and set to empty\n+            if (counter.isEmpty()) {\n+                logFingerPrint();\n+                callbackCounter = Optional.empty();\n+            }\n+        });\n+    }\n+\n+    private void logFingerPrint() {\n+        final String vin = configuration.map(config -> config.vin).orElse(\"\");\n+        logger.debug(\"###### BMW ConnectedDrive Binding - Vehicle Troubleshoot Fingerprint Data - BEGIN ######\");\n+        logger.debug(\"### Discovery Result ###\");\n+        bridgeHandler.ifPresent(handler -> {\n+            logger.debug(\"{}\", handler.getDiscoveryFingerprint());\n+        });\n+        vehicleStatusCache.ifPresentOrElse(vehicleStatus -> {\n+            logger.debug(\"### Vehicle Status ###\");\n+\n+            // Anonymous data for VIN and Position\n+            try {\n+                VehicleStatusContainer container = Converter.getGson().fromJson(vehicleStatus,\n+                        VehicleStatusContainer.class);\n+                if (container != null) {\n+                    VehicleStatus status = container.vehicleStatus;\n+                    if (status != null) {\n+                        status.vin = Constants.ANONYMOUS;\n+                        if (status.position != null) {\n+                            status.position.lat = -1;\n+                            status.position.lon = -1;\n+                            status.position.heading = -1;\n+                        }\n+                    }\n+                }\n+                logger.debug(\"{}\", Converter.getGson().toJson(container));\n+            } catch (JsonSyntaxException jse) {\n+                logger.debug(\"{}\", jse.getMessage());\n+            }\n+        }, () -> {\n+            logger.debug(\"### Vehicle Status Empty ###\");\n+        });\n+        lastTripCache.ifPresentOrElse(lastTrip -> {\n+            logger.debug(\"### Last Trip ###\");\n+            logger.debug(\"{}\", lastTrip.replaceAll(vin, Constants.ANONYMOUS));\n+        }, () -> {\n+            logger.debug(\"### Last Trip Empty ###\");\n+        });\n+        allTripsCache.ifPresentOrElse(allTrips -> {\n+            logger.debug(\"### All Trips ###\");\n+            logger.debug(\"{}\", allTrips.replaceAll(vin, Constants.ANONYMOUS));\n+        }, () -> {\n+            logger.debug(\"### All Trips Empty ###\");\n+        });\n+        if (isElectric) {\n+            chargeProfileCache.ifPresentOrElse(chargeProfile -> {\n+                logger.debug(\"### Charge Profile ###\");\n+                logger.debug(\"{}\", chargeProfile.replaceAll(vin, Constants.ANONYMOUS));\n+            }, () -> {\n+                logger.debug(\"### Charge Profile Empty ###\");\n+            });\n+        }\n+        destinationCache.ifPresentOrElse(destination -> {\n+            logger.debug(\"### Charge Profile ###\");\n+            try {\n+                DestinationContainer container = Converter.getGson().fromJson(destination, DestinationContainer.class);\n+                if (container != null) {\n+                    if (container.destinations != null) {\n+                        container.destinations.forEach(entry -> {\n+                            entry.lat = 0;\n+                            entry.lon = 0;\n+                            entry.city = Constants.ANONYMOUS;\n+                            entry.street = Constants.ANONYMOUS;\n+                            entry.streetNumber = Constants.ANONYMOUS;\n+                            entry.country = Constants.ANONYMOUS;\n+                        });\n+                        logger.debug(\"{}\", Converter.getGson().toJson(container));\n+                    }\n+                } else {\n+                    logger.debug(\"### Destinations Empty ###\");\n+                }\n+            } catch (JsonSyntaxException jse) {\n+                logger.debug(\"{}\", jse.getMessage());\n+            }\n+        }, () -> {\n+            logger.debug(\"### Charge Profile Empty ###\");\n+        });\n+        rangeMapCache.ifPresentOrElse(rangeMap -> {\n+            logger.debug(\"### Range Map ###\");\n+            logger.debug(\"{}\", rangeMap.replaceAll(vin, Constants.ANONYMOUS));\n+        }, () -> {\n+            logger.debug(\"### Range Map Empty ###\");\n+        });\n+        logger.debug(\"###### BMW ConnectedDrive Binding - Vehicle Troubleshoot Fingerprint Data - END ######\");\n+    }\n+\n+    /**\n+     * Don't stress ConnectedDrive with unnecessary requests. One call at the beginning is done to check the response.\n+     * After cache has e.g. a proper error response it will be shown in the fingerprint\n+     *\n+     * @return\n+     */\n+    private boolean isSupported(String service) {\n+        final String services = thing.getProperties().get(Constants.SERVICES_SUPPORTED);\n+        if (services != null) {\n+            if (services.contains(service)) {\n+                return true;\n+            }\n+        }\n+        // if cache is empty give it a try one time to collected Troubleshoot data\n+        if (lastTripCache.isEmpty() || allTripsCache.isEmpty() || destinationCache.isEmpty()) {\n+            return true;\n+        } else {\n+            return false;\n+        }\n+    }\n+\n+    public void updateRemoteExecutionStatus(@Nullable String service, @Nullable String status) {\n+        if (RemoteService.CHARGING_CONTROL.toString().equals(service)\n+                && ExecutionState.EXECUTED.name().equals(status)) {\n+            saveChargeProfileSent();\n+        }\n+        updateChannel(CHANNEL_GROUP_REMOTE, REMOTE_STATE, StringType.valueOf(Converter.toTitleCase(\n+                new StringBuilder(service == null ? \"-\" : service).append(\" \").append(status).toString())));\n+    }\n+\n+    public Optional<VehicleConfiguration> getConfiguration() {\n+        return configuration;\n+    }\n+\n+    public ScheduledExecutorService getScheduler() {\n+        return scheduler;\n+    }\n+\n+    /**\n+     * Callbacks for ConnectedDrive Portal\n+     *\n+     * @author Bernd Weymann\n+     *\n+     */\n+    @NonNullByDefault({})\n+    public class ChargeProfilesCallback implements StringResponseCallback {\n+        @Override\n+        public void onResponse(@Nullable String content) {\n+            if (content != null) {\n+                chargeProfileCache = Optional.of(content);\n+                if (chargeProfileEdit.isEmpty()) {\n+                    updateChargeProfileFromContent(content);\n+                }\n+            }\n+            removeCallback(this);\n+        }\n+\n+        /**\n+         * Store Error Report in cache variable. Via Fingerprint Channel error is logged and Issue can be raised\n+         */\n+        @Override\n+        public void onError(NetworkError error) {\n+            logger.debug(\"{}\", error.toString());\n+            chargeProfileCache = Optional.of(Converter.getGson().toJson(error));\n+            removeCallback(this);\n+        }\n+    }\n+\n+    @NonNullByDefault({})\n+    public class RangeMapCallback implements StringResponseCallback {\n+        @Override\n+        public void onResponse(@Nullable String content) {\n+            rangeMapCache = Optional.ofNullable(content);\n+            removeCallback(this);\n+        }\n+\n+        /**\n+         * Store Error Report in cache variable. Via Fingerprint Channel error is logged and Issue can be raised\n+         */\n+        @Override\n+        public void onError(NetworkError error) {\n+            logger.debug(\"{}\", error.toString());\n+            rangeMapCache = Optional.of(Converter.getGson().toJson(error));\n+            removeCallback(this);\n+        }\n+    }\n+\n+    @NonNullByDefault({})\n+    public class DestinationsCallback implements StringResponseCallback {\n+\n+        @Override\n+        public void onResponse(@Nullable String content) {\n+            destinationCache = Optional.ofNullable(content);\n+            if (content != null) {\n+                try {\n+                    DestinationContainer dc = Converter.getGson().fromJson(content, DestinationContainer.class);\n+                    if (dc != null && dc.destinations != null) {\n+                        updateDestinations(dc.destinations);\n+                    }\n+                } catch (JsonSyntaxException jse) {\n+                    logger.debug(\"{}\", jse.getMessage());\n+                }\n+            }\n+            removeCallback(this);\n+        }\n+\n+        /**\n+         * Store Error Report in cache variable. Via Fingerprint Channel error is logged and Issue can be raised\n+         */\n+        @Override\n+        public void onError(NetworkError error) {\n+            logger.debug(\"{}\", error.toString());\n+            destinationCache = Optional.of(Converter.getGson().toJson(error));\n+            removeCallback(this);\n+        }\n+    }\n+\n+    @NonNullByDefault({})\n+    public class ImageCallback implements ByteResponseCallback {\n+        @Override\n+        public void onResponse(byte[] content) {\n+            if (content.length > 0) {\n+                imageCache = Optional.of(content);\n+                String contentType = HttpUtil.guessContentTypeFromData(content);\n+                updateChannel(CHANNEL_GROUP_VEHICLE_IMAGE, IMAGE_FORMAT, new RawType(content, contentType));\n+            } else {\n+                synchronized (imageProperties) {\n+                    imageProperties.failed();\n+                }\n+            }\n+            removeCallback(this);\n+        }\n+\n+        /**\n+         * Store Error Report in cache variable. Via Fingerprint Channel error is logged and Issue can be raised\n+         */\n+        @Override\n+        public void onError(NetworkError error) {\n+            logger.debug(\"{}\", error.toString());\n+            synchronized (imageProperties) {\n+                imageProperties.failed();\n+            }\n+            removeCallback(this);\n+        }\n+    }\n+\n+    @NonNullByDefault({})\n+    public class AllTripsCallback implements StringResponseCallback {\n+        @Override\n+        public void onResponse(@Nullable String content) {\n+            if (content != null) {\n+                allTripsCache = Optional.of(content);\n+                try {\n+                    AllTripsContainer atc = Converter.getGson().fromJson(content, AllTripsContainer.class);\n+                    if (atc != null) {\n+                        AllTrips at = atc.allTrips;\n+                        if (at != null) {\n+                            updateAllTrips(at);\n+                        }\n+                    }\n+                } catch (JsonSyntaxException jse) {\n+                    logger.debug(\"{}\", jse.getMessage());\n+                }\n+            }\n+            removeCallback(this);\n+        }\n+\n+        /**\n+         * Store Error Report in cache variable. Via Fingerprint Channel error is logged and Issue can be raised\n+         */\n+        @Override\n+        public void onError(NetworkError error) {\n+            logger.debug(\"{}\", error.toString());\n+            allTripsCache = Optional.of(Converter.getGson().toJson(error));\n+            removeCallback(this);\n+        }\n+    }\n+\n+    @NonNullByDefault({})\n+    public class LastTripCallback implements StringResponseCallback {\n+        @Override\n+        public void onResponse(@Nullable String content) {\n+            if (content != null) {\n+                lastTripCache = Optional.of(content);\n+                try {\n+                    LastTripContainer lt = Converter.getGson().fromJson(content, LastTripContainer.class);\n+                    if (lt != null) {\n+                        LastTrip trip = lt.lastTrip;\n+                        if (trip != null) {\n+                            updateLastTrip(trip);\n+                        }\n+                    }\n+                } catch (JsonSyntaxException jse) {\n+                    logger.debug(\"{}\", jse.getMessage());\n+                }\n+            }\n+            removeCallback(this);\n+        }\n+\n+        /**\n+         * Store Error Report in cache variable. Via Fingerprint Channel error is logged and Issue can be raised\n+         */\n+        @Override\n+        public void onError(NetworkError error) {\n+            logger.debug(\"{}\", error.toString());\n+            lastTripCache = Optional.of(Converter.getGson().toJson(error));\n+            removeCallback(this);\n+        }\n+    }\n+\n+    /**\n+     * The VehicleStatus is supported by all Vehicle Types so it's used to reflect the Thing Status\n+     */\n+    @NonNullByDefault({})\n+    public class VehicleStatusCallback implements StringResponseCallback {\n+        private ThingStatus thingStatus = ThingStatus.UNKNOWN;\n+\n+        /**\n+         * Vehicle Status is supported by all Vehicles so callback result is used to report Thing Status.\n+         * If valid content is delivered in onResponse Thing goes online while onError Thing goes offline\n+         *\n+         * @param status\n+         * @param detail\n+         * @param reason\n+         */\n+        private void setThingStatus(ThingStatus status, ThingStatusDetail detail, String reason) {\n+            if (thingStatus != status) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "48af48c82562d006b6f2aa35922270f181c885ed"}, "originalPosition": 637}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMDA1NzIzNA==", "bodyText": "Fixed", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r600057234", "createdAt": "2021-03-24T00:26:08Z", "author": {"login": "weymann"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/VehicleHandler.java", "diffHunk": "@@ -0,0 +1,826 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bmwconnecteddrive.internal.handler;\n+\n+import static org.openhab.binding.bmwconnecteddrive.internal.ConnectedDriveConstants.*;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.bmwconnecteddrive.internal.VehicleConfiguration;\n+import org.openhab.binding.bmwconnecteddrive.internal.action.ChargeProfileActions;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.DestinationContainer;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.NetworkError;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.compat.VehicleAttributesContainer;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.statistics.AllTrips;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.statistics.AllTripsContainer;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.statistics.LastTrip;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.statistics.LastTripContainer;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.status.VehicleStatus;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.status.VehicleStatusContainer;\n+import org.openhab.binding.bmwconnecteddrive.internal.handler.RemoteServiceHandler.ExecutionState;\n+import org.openhab.binding.bmwconnecteddrive.internal.handler.RemoteServiceHandler.RemoteService;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileUtils;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileUtils.ChargeKeyDay;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileUtils.ChargeKeyHour;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileWrapper;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileWrapper.ProfileKey;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Constants;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Converter;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ImageProperties;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.RemoteServiceUtils;\n+import org.openhab.core.io.net.http.HttpUtil;\n+import org.openhab.core.library.types.DecimalType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.RawType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BridgeHandler;\n+import org.openhab.core.thing.binding.ThingHandlerService;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+\n+import com.google.gson.JsonSyntaxException;\n+\n+/**\n+ * The {@link VehicleHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Bernd Weymann - Initial contribution\n+ * @author Norbert Truchsess - edit & send charge profile\n+ */\n+@NonNullByDefault\n+public class VehicleHandler extends VehicleChannelHandler {\n+    private boolean legacyMode = false; // switch to legacy API in case of 404 Errors\n+\n+    private Optional<ConnectedDriveProxy> proxy = Optional.empty();\n+    private Optional<RemoteServiceHandler> remote = Optional.empty();\n+    private Optional<VehicleConfiguration> configuration = Optional.empty();\n+    private Optional<ConnectedDriveBridgeHandler> bridgeHandler = Optional.empty();\n+    private Optional<ScheduledFuture<?>> refreshJob = Optional.empty();\n+    private Optional<ScheduledFuture<?>> editTimeout = Optional.empty();\n+    private Optional<List<ResponseCallback>> callbackCounter = Optional.empty();\n+\n+    private ImageProperties imageProperties = new ImageProperties();\n+    VehicleStatusCallback vehicleStatusCallback = new VehicleStatusCallback();\n+    StringResponseCallback oldVehicleStatusCallback = new LegacyVehicleStatusCallback();\n+    StringResponseCallback lastTripCallback = new LastTripCallback();\n+    StringResponseCallback allTripsCallback = new AllTripsCallback();\n+    StringResponseCallback chargeProfileCallback = new ChargeProfilesCallback();\n+    StringResponseCallback rangeMapCallback = new RangeMapCallback();\n+    DestinationsCallback destinationCallback = new DestinationsCallback();\n+    ByteResponseCallback imageCallback = new ImageCallback();\n+\n+    private Optional<ChargeProfileWrapper> chargeProfileEdit = Optional.empty();\n+    private Optional<String> chargeProfileSent = Optional.empty();\n+\n+    public VehicleHandler(Thing thing, BMWConnectedDriveOptionProvider op, String type, boolean imperial) {\n+        super(thing, op, type, imperial);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        String group = channelUID.getGroupId();\n+\n+        // Refresh of Channels with cached values\n+        if (command instanceof RefreshType) {\n+            if (CHANNEL_GROUP_LAST_TRIP.equals(group)) {\n+                lastTripCache.ifPresent(lastTrip -> lastTripCallback.onResponse(lastTrip));\n+            } else if (CHANNEL_GROUP_LIFETIME.equals(group)) {\n+                allTripsCache.ifPresent(allTrips -> allTripsCallback.onResponse(allTrips));\n+            } else if (CHANNEL_GROUP_DESTINATION.equals(group)) {\n+                destinationCache.ifPresent(destination -> destinationCallback.onResponse(destination));\n+            } else if (CHANNEL_GROUP_STATUS.equals(group)) {\n+                vehicleStatusCache.ifPresent(vehicleStatus -> vehicleStatusCallback.onResponse(vehicleStatus));\n+            } else if (CHANNEL_GROUP_CHARGE.equals(group)) {\n+                chargeProfileEdit.ifPresentOrElse(this::updateChargeProfile,\n+                        () -> chargeProfileCache.ifPresent(this::updateChargeProfileFromContent));\n+            } else if (CHANNEL_GROUP_VEHICLE_IMAGE.equals(group)) {\n+                imageCache.ifPresent(image -> imageCallback.onResponse(image));\n+            }\n+            // Check for Channel Group and corresponding Actions\n+        } else if (CHANNEL_GROUP_REMOTE.equals(group)) {\n+            // Executing Remote Services\n+            if (command instanceof StringType) {\n+                String serviceCommand = ((StringType) command).toFullString();\n+                remote.ifPresent(remot -> {\n+                    switch (serviceCommand) {\n+                        case REMOTE_SERVICE_LIGHT_FLASH:\n+                        case REMOTE_SERVICE_AIR_CONDITIONING:\n+                        case REMOTE_SERVICE_DOOR_LOCK:\n+                        case REMOTE_SERVICE_DOOR_UNLOCK:\n+                        case REMOTE_SERVICE_HORN:\n+                        case REMOTE_SERVICE_VEHICLE_FINDER:\n+                        case REMOTE_SERVICE_CHARGE_NOW:\n+                            RemoteServiceUtils.getRemoteService(serviceCommand)\n+                                    .ifPresentOrElse(service -> remot.execute(service), () -> {\n+                                        logger.info(\"Remote service execution {} unknown\", serviceCommand);\n+                                    });\n+                            break;\n+                        case REMOTE_SERVICE_CHARGING_CONTROL:\n+                            sendChargeProfile(chargeProfileEdit);\n+                            break;\n+                        default:\n+                            logger.info(\"Remote service execution {} unknown\", serviceCommand);\n+                            break;\n+                    }\n+                });\n+            }\n+        } else if (CHANNEL_GROUP_VEHICLE_IMAGE.equals(group)) {\n+            // Image Change\n+            configuration.ifPresent(config -> {\n+                if (command instanceof StringType) {\n+                    if (channelUID.getIdWithoutGroup().equals(IMAGE_VIEWPORT)) {\n+                        String newViewport = command.toString();\n+                        synchronized (imageProperties) {\n+                            if (!imageProperties.viewport.equals(newViewport)) {\n+                                imageProperties = new ImageProperties(newViewport, imageProperties.size);\n+                                imageCache = Optional.empty();\n+                                proxy.ifPresent(prox -> prox.requestImage(config, imageProperties, imageCallback));\n+                            }\n+                        }\n+                        updateChannel(CHANNEL_GROUP_VEHICLE_IMAGE, IMAGE_VIEWPORT, StringType.valueOf(newViewport));\n+                    }\n+                }\n+                if (command instanceof DecimalType) {\n+                    if (command instanceof DecimalType) {\n+                        int newImageSize = ((DecimalType) command).intValue();\n+                        if (channelUID.getIdWithoutGroup().equals(IMAGE_SIZE)) {\n+                            synchronized (imageProperties) {\n+                                if (imageProperties.size != newImageSize) {\n+                                    imageProperties = new ImageProperties(imageProperties.viewport, newImageSize);\n+                                    imageCache = Optional.empty();\n+                                    proxy.ifPresent(prox -> prox.requestImage(config, imageProperties, imageCallback));\n+                                }\n+                            }\n+                        }\n+                        updateChannel(CHANNEL_GROUP_VEHICLE_IMAGE, IMAGE_SIZE, new DecimalType(newImageSize));\n+                    }\n+                }\n+            });\n+        } else if (CHANNEL_GROUP_DESTINATION.equals(group)) {\n+            if (command instanceof StringType) {\n+                int index = Converter.getIndex(command.toFullString());\n+                if (index != -1) {\n+                    selectDestination(index);\n+                } else {\n+                    logger.debug(\"Cannot select Destination index {}\", command.toFullString());\n+                }\n+            }\n+        } else if (CHANNEL_GROUP_SERVICE.equals(group)) {\n+            if (command instanceof StringType) {\n+                int index = Converter.getIndex(command.toFullString());\n+                if (index != -1) {\n+                    selectService(index);\n+                } else {\n+                    logger.debug(\"Cannot select Service index {}\", command.toFullString());\n+                }\n+            }\n+        } else if (CHANNEL_GROUP_CHECK_CONTROL.equals(group)) {\n+            if (command instanceof StringType) {\n+                int index = Converter.getIndex(command.toFullString());\n+                if (index != -1) {\n+                    selectCheckControl(index);\n+                } else {\n+                    logger.debug(\"Cannot select CheckControl index {}\", command.toFullString());\n+                }\n+            }\n+        } else if (CHANNEL_GROUP_CHARGE.equals(group)) {\n+            handleChargeProfileCommand(channelUID, command);\n+        }\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        callbackCounter = Optional.of(new ArrayList<ResponseCallback>());\n+        updateStatus(ThingStatus.UNKNOWN);\n+        final VehicleConfiguration config = getConfigAs(VehicleConfiguration.class);\n+        if (config != null) {\n+            configuration = Optional.of(config);\n+            scheduler.execute(() -> {\n+                Bridge bridge = getBridge();\n+                if (bridge != null) {\n+                    BridgeHandler handler = bridge.getHandler();\n+                    if (handler != null) {\n+                        bridgeHandler = Optional.of(((ConnectedDriveBridgeHandler) handler));\n+                        proxy = ((ConnectedDriveBridgeHandler) handler).getProxy();\n+                        remote = proxy.map(prox -> prox.getRemoteServiceHandler(this));\n+                    } else {\n+                        logger.debug(\"Bridge Handler null\");\n+                    }\n+                } else {\n+                    logger.debug(\"Bridge null\");\n+                }\n+\n+                // get Image after init with config values\n+                synchronized (imageProperties) {\n+                    imageProperties = new ImageProperties(config.imageViewport, config.imageSize);\n+                }\n+                updateChannel(CHANNEL_GROUP_VEHICLE_IMAGE, IMAGE_VIEWPORT, StringType.valueOf((config.imageViewport)));\n+                updateChannel(CHANNEL_GROUP_VEHICLE_IMAGE, IMAGE_SIZE, new DecimalType((config.imageSize)));\n+\n+                // check imperial setting is different to AutoDetect\n+                if (!UNITS_AUTODETECT.equals(config.units)) {\n+                    imperial = UNITS_IMPERIAL.equals(config.units);\n+                }\n+\n+                // start update schedule\n+                startSchedule(config.refreshInterval);\n+            });\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR);\n+        }\n+    }\n+\n+    private void startSchedule(int interval) {\n+        refreshJob.ifPresentOrElse(job -> {\n+            if (job.isCancelled()) {\n+                refreshJob = Optional\n+                        .of(scheduler.scheduleWithFixedDelay(this::getData, 0, interval, TimeUnit.MINUTES));\n+            } // else - scheduler is already running!\n+        }, () -> {\n+            refreshJob = Optional.of(scheduler.scheduleWithFixedDelay(this::getData, 0, interval, TimeUnit.MINUTES));\n+        });\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        refreshJob.ifPresent(job -> job.cancel(true));\n+    }\n+\n+    public void getData() {\n+        proxy.ifPresentOrElse(prox -> {\n+            configuration.ifPresentOrElse(config -> {\n+                if (!legacyMode) {\n+                    prox.requestVehcileStatus(config, vehicleStatusCallback);\n+                } else {\n+                    prox.requestLegacyVehcileStatus(config, oldVehicleStatusCallback);\n+                }\n+                addCallback(vehicleStatusCallback);\n+                if (isSupported(Constants.STATISTICS)) {\n+                    prox.requestLastTrip(config, lastTripCallback);\n+                    prox.requestAllTrips(config, allTripsCallback);\n+                    addCallback(lastTripCallback);\n+                    addCallback(allTripsCallback);\n+                }\n+                if (isSupported(Constants.LAST_DESTINATIONS)) {\n+                    prox.requestDestinations(config, destinationCallback);\n+                    addCallback(destinationCallback);\n+                }\n+                if (isElectric) {\n+                    prox.requestChargingProfile(config, chargeProfileCallback);\n+                    addCallback(chargeProfileCallback);\n+                }\n+                synchronized (imageProperties) {\n+                    if (!imageCache.isPresent() && !imageProperties.failLimitReached()) {\n+                        prox.requestImage(config, imageProperties, imageCallback);\n+                        addCallback(imageCallback);\n+                    }\n+                }\n+            }, () -> {\n+                logger.warn(\"ConnectedDrive Configuration isn't present\");\n+            });\n+        }, () -> {\n+            logger.warn(\"ConnectedDrive Proxy isn't present\");\n+        });\n+    }\n+\n+    private synchronized void addCallback(ResponseCallback rc) {\n+        callbackCounter.ifPresent(counter -> counter.add(rc));\n+    }\n+\n+    private synchronized void removeCallback(ResponseCallback rc) {\n+        callbackCounter.ifPresent(counter -> {\n+            counter.remove(rc);\n+            // all necessary callbacks received => print and set to empty\n+            if (counter.isEmpty()) {\n+                logFingerPrint();\n+                callbackCounter = Optional.empty();\n+            }\n+        });\n+    }\n+\n+    private void logFingerPrint() {\n+        final String vin = configuration.map(config -> config.vin).orElse(\"\");\n+        logger.debug(\"###### BMW ConnectedDrive Binding - Vehicle Troubleshoot Fingerprint Data - BEGIN ######\");\n+        logger.debug(\"### Discovery Result ###\");\n+        bridgeHandler.ifPresent(handler -> {\n+            logger.debug(\"{}\", handler.getDiscoveryFingerprint());\n+        });\n+        vehicleStatusCache.ifPresentOrElse(vehicleStatus -> {\n+            logger.debug(\"### Vehicle Status ###\");\n+\n+            // Anonymous data for VIN and Position\n+            try {\n+                VehicleStatusContainer container = Converter.getGson().fromJson(vehicleStatus,\n+                        VehicleStatusContainer.class);\n+                if (container != null) {\n+                    VehicleStatus status = container.vehicleStatus;\n+                    if (status != null) {\n+                        status.vin = Constants.ANONYMOUS;\n+                        if (status.position != null) {\n+                            status.position.lat = -1;\n+                            status.position.lon = -1;\n+                            status.position.heading = -1;\n+                        }\n+                    }\n+                }\n+                logger.debug(\"{}\", Converter.getGson().toJson(container));\n+            } catch (JsonSyntaxException jse) {\n+                logger.debug(\"{}\", jse.getMessage());\n+            }\n+        }, () -> {\n+            logger.debug(\"### Vehicle Status Empty ###\");\n+        });\n+        lastTripCache.ifPresentOrElse(lastTrip -> {\n+            logger.debug(\"### Last Trip ###\");\n+            logger.debug(\"{}\", lastTrip.replaceAll(vin, Constants.ANONYMOUS));\n+        }, () -> {\n+            logger.debug(\"### Last Trip Empty ###\");\n+        });\n+        allTripsCache.ifPresentOrElse(allTrips -> {\n+            logger.debug(\"### All Trips ###\");\n+            logger.debug(\"{}\", allTrips.replaceAll(vin, Constants.ANONYMOUS));\n+        }, () -> {\n+            logger.debug(\"### All Trips Empty ###\");\n+        });\n+        if (isElectric) {\n+            chargeProfileCache.ifPresentOrElse(chargeProfile -> {\n+                logger.debug(\"### Charge Profile ###\");\n+                logger.debug(\"{}\", chargeProfile.replaceAll(vin, Constants.ANONYMOUS));\n+            }, () -> {\n+                logger.debug(\"### Charge Profile Empty ###\");\n+            });\n+        }\n+        destinationCache.ifPresentOrElse(destination -> {\n+            logger.debug(\"### Charge Profile ###\");\n+            try {\n+                DestinationContainer container = Converter.getGson().fromJson(destination, DestinationContainer.class);\n+                if (container != null) {\n+                    if (container.destinations != null) {\n+                        container.destinations.forEach(entry -> {\n+                            entry.lat = 0;\n+                            entry.lon = 0;\n+                            entry.city = Constants.ANONYMOUS;\n+                            entry.street = Constants.ANONYMOUS;\n+                            entry.streetNumber = Constants.ANONYMOUS;\n+                            entry.country = Constants.ANONYMOUS;\n+                        });\n+                        logger.debug(\"{}\", Converter.getGson().toJson(container));\n+                    }\n+                } else {\n+                    logger.debug(\"### Destinations Empty ###\");\n+                }\n+            } catch (JsonSyntaxException jse) {\n+                logger.debug(\"{}\", jse.getMessage());\n+            }\n+        }, () -> {\n+            logger.debug(\"### Charge Profile Empty ###\");\n+        });\n+        rangeMapCache.ifPresentOrElse(rangeMap -> {\n+            logger.debug(\"### Range Map ###\");\n+            logger.debug(\"{}\", rangeMap.replaceAll(vin, Constants.ANONYMOUS));\n+        }, () -> {\n+            logger.debug(\"### Range Map Empty ###\");\n+        });\n+        logger.debug(\"###### BMW ConnectedDrive Binding - Vehicle Troubleshoot Fingerprint Data - END ######\");\n+    }\n+\n+    /**\n+     * Don't stress ConnectedDrive with unnecessary requests. One call at the beginning is done to check the response.\n+     * After cache has e.g. a proper error response it will be shown in the fingerprint\n+     *\n+     * @return\n+     */\n+    private boolean isSupported(String service) {\n+        final String services = thing.getProperties().get(Constants.SERVICES_SUPPORTED);\n+        if (services != null) {\n+            if (services.contains(service)) {\n+                return true;\n+            }\n+        }\n+        // if cache is empty give it a try one time to collected Troubleshoot data\n+        if (lastTripCache.isEmpty() || allTripsCache.isEmpty() || destinationCache.isEmpty()) {\n+            return true;\n+        } else {\n+            return false;\n+        }\n+    }\n+\n+    public void updateRemoteExecutionStatus(@Nullable String service, @Nullable String status) {\n+        if (RemoteService.CHARGING_CONTROL.toString().equals(service)\n+                && ExecutionState.EXECUTED.name().equals(status)) {\n+            saveChargeProfileSent();\n+        }\n+        updateChannel(CHANNEL_GROUP_REMOTE, REMOTE_STATE, StringType.valueOf(Converter.toTitleCase(\n+                new StringBuilder(service == null ? \"-\" : service).append(\" \").append(status).toString())));\n+    }\n+\n+    public Optional<VehicleConfiguration> getConfiguration() {\n+        return configuration;\n+    }\n+\n+    public ScheduledExecutorService getScheduler() {\n+        return scheduler;\n+    }\n+\n+    /**\n+     * Callbacks for ConnectedDrive Portal\n+     *\n+     * @author Bernd Weymann\n+     *\n+     */\n+    @NonNullByDefault({})\n+    public class ChargeProfilesCallback implements StringResponseCallback {\n+        @Override\n+        public void onResponse(@Nullable String content) {\n+            if (content != null) {\n+                chargeProfileCache = Optional.of(content);\n+                if (chargeProfileEdit.isEmpty()) {\n+                    updateChargeProfileFromContent(content);\n+                }\n+            }\n+            removeCallback(this);\n+        }\n+\n+        /**\n+         * Store Error Report in cache variable. Via Fingerprint Channel error is logged and Issue can be raised\n+         */\n+        @Override\n+        public void onError(NetworkError error) {\n+            logger.debug(\"{}\", error.toString());\n+            chargeProfileCache = Optional.of(Converter.getGson().toJson(error));\n+            removeCallback(this);\n+        }\n+    }\n+\n+    @NonNullByDefault({})\n+    public class RangeMapCallback implements StringResponseCallback {\n+        @Override\n+        public void onResponse(@Nullable String content) {\n+            rangeMapCache = Optional.ofNullable(content);\n+            removeCallback(this);\n+        }\n+\n+        /**\n+         * Store Error Report in cache variable. Via Fingerprint Channel error is logged and Issue can be raised\n+         */\n+        @Override\n+        public void onError(NetworkError error) {\n+            logger.debug(\"{}\", error.toString());\n+            rangeMapCache = Optional.of(Converter.getGson().toJson(error));\n+            removeCallback(this);\n+        }\n+    }\n+\n+    @NonNullByDefault({})\n+    public class DestinationsCallback implements StringResponseCallback {\n+\n+        @Override\n+        public void onResponse(@Nullable String content) {\n+            destinationCache = Optional.ofNullable(content);\n+            if (content != null) {\n+                try {\n+                    DestinationContainer dc = Converter.getGson().fromJson(content, DestinationContainer.class);\n+                    if (dc != null && dc.destinations != null) {\n+                        updateDestinations(dc.destinations);\n+                    }\n+                } catch (JsonSyntaxException jse) {\n+                    logger.debug(\"{}\", jse.getMessage());\n+                }\n+            }\n+            removeCallback(this);\n+        }\n+\n+        /**\n+         * Store Error Report in cache variable. Via Fingerprint Channel error is logged and Issue can be raised\n+         */\n+        @Override\n+        public void onError(NetworkError error) {\n+            logger.debug(\"{}\", error.toString());\n+            destinationCache = Optional.of(Converter.getGson().toJson(error));\n+            removeCallback(this);\n+        }\n+    }\n+\n+    @NonNullByDefault({})\n+    public class ImageCallback implements ByteResponseCallback {\n+        @Override\n+        public void onResponse(byte[] content) {\n+            if (content.length > 0) {\n+                imageCache = Optional.of(content);\n+                String contentType = HttpUtil.guessContentTypeFromData(content);\n+                updateChannel(CHANNEL_GROUP_VEHICLE_IMAGE, IMAGE_FORMAT, new RawType(content, contentType));\n+            } else {\n+                synchronized (imageProperties) {\n+                    imageProperties.failed();\n+                }\n+            }\n+            removeCallback(this);\n+        }\n+\n+        /**\n+         * Store Error Report in cache variable. Via Fingerprint Channel error is logged and Issue can be raised\n+         */\n+        @Override\n+        public void onError(NetworkError error) {\n+            logger.debug(\"{}\", error.toString());\n+            synchronized (imageProperties) {\n+                imageProperties.failed();\n+            }\n+            removeCallback(this);\n+        }\n+    }\n+\n+    @NonNullByDefault({})\n+    public class AllTripsCallback implements StringResponseCallback {\n+        @Override\n+        public void onResponse(@Nullable String content) {\n+            if (content != null) {\n+                allTripsCache = Optional.of(content);\n+                try {\n+                    AllTripsContainer atc = Converter.getGson().fromJson(content, AllTripsContainer.class);\n+                    if (atc != null) {\n+                        AllTrips at = atc.allTrips;\n+                        if (at != null) {\n+                            updateAllTrips(at);\n+                        }\n+                    }\n+                } catch (JsonSyntaxException jse) {\n+                    logger.debug(\"{}\", jse.getMessage());\n+                }\n+            }\n+            removeCallback(this);\n+        }\n+\n+        /**\n+         * Store Error Report in cache variable. Via Fingerprint Channel error is logged and Issue can be raised\n+         */\n+        @Override\n+        public void onError(NetworkError error) {\n+            logger.debug(\"{}\", error.toString());\n+            allTripsCache = Optional.of(Converter.getGson().toJson(error));\n+            removeCallback(this);\n+        }\n+    }\n+\n+    @NonNullByDefault({})\n+    public class LastTripCallback implements StringResponseCallback {\n+        @Override\n+        public void onResponse(@Nullable String content) {\n+            if (content != null) {\n+                lastTripCache = Optional.of(content);\n+                try {\n+                    LastTripContainer lt = Converter.getGson().fromJson(content, LastTripContainer.class);\n+                    if (lt != null) {\n+                        LastTrip trip = lt.lastTrip;\n+                        if (trip != null) {\n+                            updateLastTrip(trip);\n+                        }\n+                    }\n+                } catch (JsonSyntaxException jse) {\n+                    logger.debug(\"{}\", jse.getMessage());\n+                }\n+            }\n+            removeCallback(this);\n+        }\n+\n+        /**\n+         * Store Error Report in cache variable. Via Fingerprint Channel error is logged and Issue can be raised\n+         */\n+        @Override\n+        public void onError(NetworkError error) {\n+            logger.debug(\"{}\", error.toString());\n+            lastTripCache = Optional.of(Converter.getGson().toJson(error));\n+            removeCallback(this);\n+        }\n+    }\n+\n+    /**\n+     * The VehicleStatus is supported by all Vehicle Types so it's used to reflect the Thing Status\n+     */\n+    @NonNullByDefault({})\n+    public class VehicleStatusCallback implements StringResponseCallback {\n+        private ThingStatus thingStatus = ThingStatus.UNKNOWN;\n+\n+        /**\n+         * Vehicle Status is supported by all Vehicles so callback result is used to report Thing Status.\n+         * If valid content is delivered in onResponse Thing goes online while onError Thing goes offline\n+         *\n+         * @param status\n+         * @param detail\n+         * @param reason\n+         */\n+        private void setThingStatus(ThingStatus status, ThingStatusDetail detail, String reason) {\n+            if (thingStatus != status) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5NzkyMTY1NA=="}, "originalCommit": {"oid": "48af48c82562d006b6f2aa35922270f181c885ed"}, "originalPosition": 637}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzc3NjgwNDIwOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/VehicleHandler.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0xOVQxOToyMToyNlrOI6OUsw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0yMVQxNTo1MDoxNlrOI6lSgg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5NzkyMjk5NQ==", "bodyText": "This needs to be cancelled in dispose().", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r597922995", "createdAt": "2021-03-19T19:21:26Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/VehicleHandler.java", "diffHunk": "@@ -0,0 +1,826 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bmwconnecteddrive.internal.handler;\n+\n+import static org.openhab.binding.bmwconnecteddrive.internal.ConnectedDriveConstants.*;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.bmwconnecteddrive.internal.VehicleConfiguration;\n+import org.openhab.binding.bmwconnecteddrive.internal.action.ChargeProfileActions;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.DestinationContainer;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.NetworkError;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.compat.VehicleAttributesContainer;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.statistics.AllTrips;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.statistics.AllTripsContainer;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.statistics.LastTrip;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.statistics.LastTripContainer;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.status.VehicleStatus;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.status.VehicleStatusContainer;\n+import org.openhab.binding.bmwconnecteddrive.internal.handler.RemoteServiceHandler.ExecutionState;\n+import org.openhab.binding.bmwconnecteddrive.internal.handler.RemoteServiceHandler.RemoteService;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileUtils;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileUtils.ChargeKeyDay;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileUtils.ChargeKeyHour;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileWrapper;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileWrapper.ProfileKey;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Constants;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Converter;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ImageProperties;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.RemoteServiceUtils;\n+import org.openhab.core.io.net.http.HttpUtil;\n+import org.openhab.core.library.types.DecimalType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.RawType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BridgeHandler;\n+import org.openhab.core.thing.binding.ThingHandlerService;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+\n+import com.google.gson.JsonSyntaxException;\n+\n+/**\n+ * The {@link VehicleHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Bernd Weymann - Initial contribution\n+ * @author Norbert Truchsess - edit & send charge profile\n+ */\n+@NonNullByDefault\n+public class VehicleHandler extends VehicleChannelHandler {\n+    private boolean legacyMode = false; // switch to legacy API in case of 404 Errors\n+\n+    private Optional<ConnectedDriveProxy> proxy = Optional.empty();\n+    private Optional<RemoteServiceHandler> remote = Optional.empty();\n+    private Optional<VehicleConfiguration> configuration = Optional.empty();\n+    private Optional<ConnectedDriveBridgeHandler> bridgeHandler = Optional.empty();\n+    private Optional<ScheduledFuture<?>> refreshJob = Optional.empty();\n+    private Optional<ScheduledFuture<?>> editTimeout = Optional.empty();\n+    private Optional<List<ResponseCallback>> callbackCounter = Optional.empty();\n+\n+    private ImageProperties imageProperties = new ImageProperties();\n+    VehicleStatusCallback vehicleStatusCallback = new VehicleStatusCallback();\n+    StringResponseCallback oldVehicleStatusCallback = new LegacyVehicleStatusCallback();\n+    StringResponseCallback lastTripCallback = new LastTripCallback();\n+    StringResponseCallback allTripsCallback = new AllTripsCallback();\n+    StringResponseCallback chargeProfileCallback = new ChargeProfilesCallback();\n+    StringResponseCallback rangeMapCallback = new RangeMapCallback();\n+    DestinationsCallback destinationCallback = new DestinationsCallback();\n+    ByteResponseCallback imageCallback = new ImageCallback();\n+\n+    private Optional<ChargeProfileWrapper> chargeProfileEdit = Optional.empty();\n+    private Optional<String> chargeProfileSent = Optional.empty();\n+\n+    public VehicleHandler(Thing thing, BMWConnectedDriveOptionProvider op, String type, boolean imperial) {\n+        super(thing, op, type, imperial);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        String group = channelUID.getGroupId();\n+\n+        // Refresh of Channels with cached values\n+        if (command instanceof RefreshType) {\n+            if (CHANNEL_GROUP_LAST_TRIP.equals(group)) {\n+                lastTripCache.ifPresent(lastTrip -> lastTripCallback.onResponse(lastTrip));\n+            } else if (CHANNEL_GROUP_LIFETIME.equals(group)) {\n+                allTripsCache.ifPresent(allTrips -> allTripsCallback.onResponse(allTrips));\n+            } else if (CHANNEL_GROUP_DESTINATION.equals(group)) {\n+                destinationCache.ifPresent(destination -> destinationCallback.onResponse(destination));\n+            } else if (CHANNEL_GROUP_STATUS.equals(group)) {\n+                vehicleStatusCache.ifPresent(vehicleStatus -> vehicleStatusCallback.onResponse(vehicleStatus));\n+            } else if (CHANNEL_GROUP_CHARGE.equals(group)) {\n+                chargeProfileEdit.ifPresentOrElse(this::updateChargeProfile,\n+                        () -> chargeProfileCache.ifPresent(this::updateChargeProfileFromContent));\n+            } else if (CHANNEL_GROUP_VEHICLE_IMAGE.equals(group)) {\n+                imageCache.ifPresent(image -> imageCallback.onResponse(image));\n+            }\n+            // Check for Channel Group and corresponding Actions\n+        } else if (CHANNEL_GROUP_REMOTE.equals(group)) {\n+            // Executing Remote Services\n+            if (command instanceof StringType) {\n+                String serviceCommand = ((StringType) command).toFullString();\n+                remote.ifPresent(remot -> {\n+                    switch (serviceCommand) {\n+                        case REMOTE_SERVICE_LIGHT_FLASH:\n+                        case REMOTE_SERVICE_AIR_CONDITIONING:\n+                        case REMOTE_SERVICE_DOOR_LOCK:\n+                        case REMOTE_SERVICE_DOOR_UNLOCK:\n+                        case REMOTE_SERVICE_HORN:\n+                        case REMOTE_SERVICE_VEHICLE_FINDER:\n+                        case REMOTE_SERVICE_CHARGE_NOW:\n+                            RemoteServiceUtils.getRemoteService(serviceCommand)\n+                                    .ifPresentOrElse(service -> remot.execute(service), () -> {\n+                                        logger.info(\"Remote service execution {} unknown\", serviceCommand);\n+                                    });\n+                            break;\n+                        case REMOTE_SERVICE_CHARGING_CONTROL:\n+                            sendChargeProfile(chargeProfileEdit);\n+                            break;\n+                        default:\n+                            logger.info(\"Remote service execution {} unknown\", serviceCommand);\n+                            break;\n+                    }\n+                });\n+            }\n+        } else if (CHANNEL_GROUP_VEHICLE_IMAGE.equals(group)) {\n+            // Image Change\n+            configuration.ifPresent(config -> {\n+                if (command instanceof StringType) {\n+                    if (channelUID.getIdWithoutGroup().equals(IMAGE_VIEWPORT)) {\n+                        String newViewport = command.toString();\n+                        synchronized (imageProperties) {\n+                            if (!imageProperties.viewport.equals(newViewport)) {\n+                                imageProperties = new ImageProperties(newViewport, imageProperties.size);\n+                                imageCache = Optional.empty();\n+                                proxy.ifPresent(prox -> prox.requestImage(config, imageProperties, imageCallback));\n+                            }\n+                        }\n+                        updateChannel(CHANNEL_GROUP_VEHICLE_IMAGE, IMAGE_VIEWPORT, StringType.valueOf(newViewport));\n+                    }\n+                }\n+                if (command instanceof DecimalType) {\n+                    if (command instanceof DecimalType) {\n+                        int newImageSize = ((DecimalType) command).intValue();\n+                        if (channelUID.getIdWithoutGroup().equals(IMAGE_SIZE)) {\n+                            synchronized (imageProperties) {\n+                                if (imageProperties.size != newImageSize) {\n+                                    imageProperties = new ImageProperties(imageProperties.viewport, newImageSize);\n+                                    imageCache = Optional.empty();\n+                                    proxy.ifPresent(prox -> prox.requestImage(config, imageProperties, imageCallback));\n+                                }\n+                            }\n+                        }\n+                        updateChannel(CHANNEL_GROUP_VEHICLE_IMAGE, IMAGE_SIZE, new DecimalType(newImageSize));\n+                    }\n+                }\n+            });\n+        } else if (CHANNEL_GROUP_DESTINATION.equals(group)) {\n+            if (command instanceof StringType) {\n+                int index = Converter.getIndex(command.toFullString());\n+                if (index != -1) {\n+                    selectDestination(index);\n+                } else {\n+                    logger.debug(\"Cannot select Destination index {}\", command.toFullString());\n+                }\n+            }\n+        } else if (CHANNEL_GROUP_SERVICE.equals(group)) {\n+            if (command instanceof StringType) {\n+                int index = Converter.getIndex(command.toFullString());\n+                if (index != -1) {\n+                    selectService(index);\n+                } else {\n+                    logger.debug(\"Cannot select Service index {}\", command.toFullString());\n+                }\n+            }\n+        } else if (CHANNEL_GROUP_CHECK_CONTROL.equals(group)) {\n+            if (command instanceof StringType) {\n+                int index = Converter.getIndex(command.toFullString());\n+                if (index != -1) {\n+                    selectCheckControl(index);\n+                } else {\n+                    logger.debug(\"Cannot select CheckControl index {}\", command.toFullString());\n+                }\n+            }\n+        } else if (CHANNEL_GROUP_CHARGE.equals(group)) {\n+            handleChargeProfileCommand(channelUID, command);\n+        }\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        callbackCounter = Optional.of(new ArrayList<ResponseCallback>());\n+        updateStatus(ThingStatus.UNKNOWN);\n+        final VehicleConfiguration config = getConfigAs(VehicleConfiguration.class);\n+        if (config != null) {\n+            configuration = Optional.of(config);\n+            scheduler.execute(() -> {\n+                Bridge bridge = getBridge();\n+                if (bridge != null) {\n+                    BridgeHandler handler = bridge.getHandler();\n+                    if (handler != null) {\n+                        bridgeHandler = Optional.of(((ConnectedDriveBridgeHandler) handler));\n+                        proxy = ((ConnectedDriveBridgeHandler) handler).getProxy();\n+                        remote = proxy.map(prox -> prox.getRemoteServiceHandler(this));\n+                    } else {\n+                        logger.debug(\"Bridge Handler null\");\n+                    }\n+                } else {\n+                    logger.debug(\"Bridge null\");\n+                }\n+\n+                // get Image after init with config values\n+                synchronized (imageProperties) {\n+                    imageProperties = new ImageProperties(config.imageViewport, config.imageSize);\n+                }\n+                updateChannel(CHANNEL_GROUP_VEHICLE_IMAGE, IMAGE_VIEWPORT, StringType.valueOf((config.imageViewport)));\n+                updateChannel(CHANNEL_GROUP_VEHICLE_IMAGE, IMAGE_SIZE, new DecimalType((config.imageSize)));\n+\n+                // check imperial setting is different to AutoDetect\n+                if (!UNITS_AUTODETECT.equals(config.units)) {\n+                    imperial = UNITS_IMPERIAL.equals(config.units);\n+                }\n+\n+                // start update schedule\n+                startSchedule(config.refreshInterval);\n+            });\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR);\n+        }\n+    }\n+\n+    private void startSchedule(int interval) {\n+        refreshJob.ifPresentOrElse(job -> {\n+            if (job.isCancelled()) {\n+                refreshJob = Optional\n+                        .of(scheduler.scheduleWithFixedDelay(this::getData, 0, interval, TimeUnit.MINUTES));\n+            } // else - scheduler is already running!\n+        }, () -> {\n+            refreshJob = Optional.of(scheduler.scheduleWithFixedDelay(this::getData, 0, interval, TimeUnit.MINUTES));\n+        });\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        refreshJob.ifPresent(job -> job.cancel(true));\n+    }\n+\n+    public void getData() {\n+        proxy.ifPresentOrElse(prox -> {\n+            configuration.ifPresentOrElse(config -> {\n+                if (!legacyMode) {\n+                    prox.requestVehcileStatus(config, vehicleStatusCallback);\n+                } else {\n+                    prox.requestLegacyVehcileStatus(config, oldVehicleStatusCallback);\n+                }\n+                addCallback(vehicleStatusCallback);\n+                if (isSupported(Constants.STATISTICS)) {\n+                    prox.requestLastTrip(config, lastTripCallback);\n+                    prox.requestAllTrips(config, allTripsCallback);\n+                    addCallback(lastTripCallback);\n+                    addCallback(allTripsCallback);\n+                }\n+                if (isSupported(Constants.LAST_DESTINATIONS)) {\n+                    prox.requestDestinations(config, destinationCallback);\n+                    addCallback(destinationCallback);\n+                }\n+                if (isElectric) {\n+                    prox.requestChargingProfile(config, chargeProfileCallback);\n+                    addCallback(chargeProfileCallback);\n+                }\n+                synchronized (imageProperties) {\n+                    if (!imageCache.isPresent() && !imageProperties.failLimitReached()) {\n+                        prox.requestImage(config, imageProperties, imageCallback);\n+                        addCallback(imageCallback);\n+                    }\n+                }\n+            }, () -> {\n+                logger.warn(\"ConnectedDrive Configuration isn't present\");\n+            });\n+        }, () -> {\n+            logger.warn(\"ConnectedDrive Proxy isn't present\");\n+        });\n+    }\n+\n+    private synchronized void addCallback(ResponseCallback rc) {\n+        callbackCounter.ifPresent(counter -> counter.add(rc));\n+    }\n+\n+    private synchronized void removeCallback(ResponseCallback rc) {\n+        callbackCounter.ifPresent(counter -> {\n+            counter.remove(rc);\n+            // all necessary callbacks received => print and set to empty\n+            if (counter.isEmpty()) {\n+                logFingerPrint();\n+                callbackCounter = Optional.empty();\n+            }\n+        });\n+    }\n+\n+    private void logFingerPrint() {\n+        final String vin = configuration.map(config -> config.vin).orElse(\"\");\n+        logger.debug(\"###### BMW ConnectedDrive Binding - Vehicle Troubleshoot Fingerprint Data - BEGIN ######\");\n+        logger.debug(\"### Discovery Result ###\");\n+        bridgeHandler.ifPresent(handler -> {\n+            logger.debug(\"{}\", handler.getDiscoveryFingerprint());\n+        });\n+        vehicleStatusCache.ifPresentOrElse(vehicleStatus -> {\n+            logger.debug(\"### Vehicle Status ###\");\n+\n+            // Anonymous data for VIN and Position\n+            try {\n+                VehicleStatusContainer container = Converter.getGson().fromJson(vehicleStatus,\n+                        VehicleStatusContainer.class);\n+                if (container != null) {\n+                    VehicleStatus status = container.vehicleStatus;\n+                    if (status != null) {\n+                        status.vin = Constants.ANONYMOUS;\n+                        if (status.position != null) {\n+                            status.position.lat = -1;\n+                            status.position.lon = -1;\n+                            status.position.heading = -1;\n+                        }\n+                    }\n+                }\n+                logger.debug(\"{}\", Converter.getGson().toJson(container));\n+            } catch (JsonSyntaxException jse) {\n+                logger.debug(\"{}\", jse.getMessage());\n+            }\n+        }, () -> {\n+            logger.debug(\"### Vehicle Status Empty ###\");\n+        });\n+        lastTripCache.ifPresentOrElse(lastTrip -> {\n+            logger.debug(\"### Last Trip ###\");\n+            logger.debug(\"{}\", lastTrip.replaceAll(vin, Constants.ANONYMOUS));\n+        }, () -> {\n+            logger.debug(\"### Last Trip Empty ###\");\n+        });\n+        allTripsCache.ifPresentOrElse(allTrips -> {\n+            logger.debug(\"### All Trips ###\");\n+            logger.debug(\"{}\", allTrips.replaceAll(vin, Constants.ANONYMOUS));\n+        }, () -> {\n+            logger.debug(\"### All Trips Empty ###\");\n+        });\n+        if (isElectric) {\n+            chargeProfileCache.ifPresentOrElse(chargeProfile -> {\n+                logger.debug(\"### Charge Profile ###\");\n+                logger.debug(\"{}\", chargeProfile.replaceAll(vin, Constants.ANONYMOUS));\n+            }, () -> {\n+                logger.debug(\"### Charge Profile Empty ###\");\n+            });\n+        }\n+        destinationCache.ifPresentOrElse(destination -> {\n+            logger.debug(\"### Charge Profile ###\");\n+            try {\n+                DestinationContainer container = Converter.getGson().fromJson(destination, DestinationContainer.class);\n+                if (container != null) {\n+                    if (container.destinations != null) {\n+                        container.destinations.forEach(entry -> {\n+                            entry.lat = 0;\n+                            entry.lon = 0;\n+                            entry.city = Constants.ANONYMOUS;\n+                            entry.street = Constants.ANONYMOUS;\n+                            entry.streetNumber = Constants.ANONYMOUS;\n+                            entry.country = Constants.ANONYMOUS;\n+                        });\n+                        logger.debug(\"{}\", Converter.getGson().toJson(container));\n+                    }\n+                } else {\n+                    logger.debug(\"### Destinations Empty ###\");\n+                }\n+            } catch (JsonSyntaxException jse) {\n+                logger.debug(\"{}\", jse.getMessage());\n+            }\n+        }, () -> {\n+            logger.debug(\"### Charge Profile Empty ###\");\n+        });\n+        rangeMapCache.ifPresentOrElse(rangeMap -> {\n+            logger.debug(\"### Range Map ###\");\n+            logger.debug(\"{}\", rangeMap.replaceAll(vin, Constants.ANONYMOUS));\n+        }, () -> {\n+            logger.debug(\"### Range Map Empty ###\");\n+        });\n+        logger.debug(\"###### BMW ConnectedDrive Binding - Vehicle Troubleshoot Fingerprint Data - END ######\");\n+    }\n+\n+    /**\n+     * Don't stress ConnectedDrive with unnecessary requests. One call at the beginning is done to check the response.\n+     * After cache has e.g. a proper error response it will be shown in the fingerprint\n+     *\n+     * @return\n+     */\n+    private boolean isSupported(String service) {\n+        final String services = thing.getProperties().get(Constants.SERVICES_SUPPORTED);\n+        if (services != null) {\n+            if (services.contains(service)) {\n+                return true;\n+            }\n+        }\n+        // if cache is empty give it a try one time to collected Troubleshoot data\n+        if (lastTripCache.isEmpty() || allTripsCache.isEmpty() || destinationCache.isEmpty()) {\n+            return true;\n+        } else {\n+            return false;\n+        }\n+    }\n+\n+    public void updateRemoteExecutionStatus(@Nullable String service, @Nullable String status) {\n+        if (RemoteService.CHARGING_CONTROL.toString().equals(service)\n+                && ExecutionState.EXECUTED.name().equals(status)) {\n+            saveChargeProfileSent();\n+        }\n+        updateChannel(CHANNEL_GROUP_REMOTE, REMOTE_STATE, StringType.valueOf(Converter.toTitleCase(\n+                new StringBuilder(service == null ? \"-\" : service).append(\" \").append(status).toString())));\n+    }\n+\n+    public Optional<VehicleConfiguration> getConfiguration() {\n+        return configuration;\n+    }\n+\n+    public ScheduledExecutorService getScheduler() {\n+        return scheduler;\n+    }\n+\n+    /**\n+     * Callbacks for ConnectedDrive Portal\n+     *\n+     * @author Bernd Weymann\n+     *\n+     */\n+    @NonNullByDefault({})\n+    public class ChargeProfilesCallback implements StringResponseCallback {\n+        @Override\n+        public void onResponse(@Nullable String content) {\n+            if (content != null) {\n+                chargeProfileCache = Optional.of(content);\n+                if (chargeProfileEdit.isEmpty()) {\n+                    updateChargeProfileFromContent(content);\n+                }\n+            }\n+            removeCallback(this);\n+        }\n+\n+        /**\n+         * Store Error Report in cache variable. Via Fingerprint Channel error is logged and Issue can be raised\n+         */\n+        @Override\n+        public void onError(NetworkError error) {\n+            logger.debug(\"{}\", error.toString());\n+            chargeProfileCache = Optional.of(Converter.getGson().toJson(error));\n+            removeCallback(this);\n+        }\n+    }\n+\n+    @NonNullByDefault({})\n+    public class RangeMapCallback implements StringResponseCallback {\n+        @Override\n+        public void onResponse(@Nullable String content) {\n+            rangeMapCache = Optional.ofNullable(content);\n+            removeCallback(this);\n+        }\n+\n+        /**\n+         * Store Error Report in cache variable. Via Fingerprint Channel error is logged and Issue can be raised\n+         */\n+        @Override\n+        public void onError(NetworkError error) {\n+            logger.debug(\"{}\", error.toString());\n+            rangeMapCache = Optional.of(Converter.getGson().toJson(error));\n+            removeCallback(this);\n+        }\n+    }\n+\n+    @NonNullByDefault({})\n+    public class DestinationsCallback implements StringResponseCallback {\n+\n+        @Override\n+        public void onResponse(@Nullable String content) {\n+            destinationCache = Optional.ofNullable(content);\n+            if (content != null) {\n+                try {\n+                    DestinationContainer dc = Converter.getGson().fromJson(content, DestinationContainer.class);\n+                    if (dc != null && dc.destinations != null) {\n+                        updateDestinations(dc.destinations);\n+                    }\n+                } catch (JsonSyntaxException jse) {\n+                    logger.debug(\"{}\", jse.getMessage());\n+                }\n+            }\n+            removeCallback(this);\n+        }\n+\n+        /**\n+         * Store Error Report in cache variable. Via Fingerprint Channel error is logged and Issue can be raised\n+         */\n+        @Override\n+        public void onError(NetworkError error) {\n+            logger.debug(\"{}\", error.toString());\n+            destinationCache = Optional.of(Converter.getGson().toJson(error));\n+            removeCallback(this);\n+        }\n+    }\n+\n+    @NonNullByDefault({})\n+    public class ImageCallback implements ByteResponseCallback {\n+        @Override\n+        public void onResponse(byte[] content) {\n+            if (content.length > 0) {\n+                imageCache = Optional.of(content);\n+                String contentType = HttpUtil.guessContentTypeFromData(content);\n+                updateChannel(CHANNEL_GROUP_VEHICLE_IMAGE, IMAGE_FORMAT, new RawType(content, contentType));\n+            } else {\n+                synchronized (imageProperties) {\n+                    imageProperties.failed();\n+                }\n+            }\n+            removeCallback(this);\n+        }\n+\n+        /**\n+         * Store Error Report in cache variable. Via Fingerprint Channel error is logged and Issue can be raised\n+         */\n+        @Override\n+        public void onError(NetworkError error) {\n+            logger.debug(\"{}\", error.toString());\n+            synchronized (imageProperties) {\n+                imageProperties.failed();\n+            }\n+            removeCallback(this);\n+        }\n+    }\n+\n+    @NonNullByDefault({})\n+    public class AllTripsCallback implements StringResponseCallback {\n+        @Override\n+        public void onResponse(@Nullable String content) {\n+            if (content != null) {\n+                allTripsCache = Optional.of(content);\n+                try {\n+                    AllTripsContainer atc = Converter.getGson().fromJson(content, AllTripsContainer.class);\n+                    if (atc != null) {\n+                        AllTrips at = atc.allTrips;\n+                        if (at != null) {\n+                            updateAllTrips(at);\n+                        }\n+                    }\n+                } catch (JsonSyntaxException jse) {\n+                    logger.debug(\"{}\", jse.getMessage());\n+                }\n+            }\n+            removeCallback(this);\n+        }\n+\n+        /**\n+         * Store Error Report in cache variable. Via Fingerprint Channel error is logged and Issue can be raised\n+         */\n+        @Override\n+        public void onError(NetworkError error) {\n+            logger.debug(\"{}\", error.toString());\n+            allTripsCache = Optional.of(Converter.getGson().toJson(error));\n+            removeCallback(this);\n+        }\n+    }\n+\n+    @NonNullByDefault({})\n+    public class LastTripCallback implements StringResponseCallback {\n+        @Override\n+        public void onResponse(@Nullable String content) {\n+            if (content != null) {\n+                lastTripCache = Optional.of(content);\n+                try {\n+                    LastTripContainer lt = Converter.getGson().fromJson(content, LastTripContainer.class);\n+                    if (lt != null) {\n+                        LastTrip trip = lt.lastTrip;\n+                        if (trip != null) {\n+                            updateLastTrip(trip);\n+                        }\n+                    }\n+                } catch (JsonSyntaxException jse) {\n+                    logger.debug(\"{}\", jse.getMessage());\n+                }\n+            }\n+            removeCallback(this);\n+        }\n+\n+        /**\n+         * Store Error Report in cache variable. Via Fingerprint Channel error is logged and Issue can be raised\n+         */\n+        @Override\n+        public void onError(NetworkError error) {\n+            logger.debug(\"{}\", error.toString());\n+            lastTripCache = Optional.of(Converter.getGson().toJson(error));\n+            removeCallback(this);\n+        }\n+    }\n+\n+    /**\n+     * The VehicleStatus is supported by all Vehicle Types so it's used to reflect the Thing Status\n+     */\n+    @NonNullByDefault({})\n+    public class VehicleStatusCallback implements StringResponseCallback {\n+        private ThingStatus thingStatus = ThingStatus.UNKNOWN;\n+\n+        /**\n+         * Vehicle Status is supported by all Vehicles so callback result is used to report Thing Status.\n+         * If valid content is delivered in onResponse Thing goes online while onError Thing goes offline\n+         *\n+         * @param status\n+         * @param detail\n+         * @param reason\n+         */\n+        private void setThingStatus(ThingStatus status, ThingStatusDetail detail, String reason) {\n+            if (thingStatus != status) {\n+                updateStatus(status, detail, reason);\n+            }\n+        }\n+\n+        @Override\n+        public void onResponse(@Nullable String content) {\n+            if (content != null) {\n+                setThingStatus(ThingStatus.ONLINE, ThingStatusDetail.NONE, Constants.EMPTY);\n+                vehicleStatusCache = Optional.of(content);\n+                try {\n+                    VehicleStatusContainer status = Converter.getGson().fromJson(content, VehicleStatusContainer.class);\n+                    if (status != null) {\n+                        VehicleStatus vStatus = status.vehicleStatus;\n+                        if (vStatus == null) {\n+                            return;\n+                        }\n+                        updateVehicleStatus(vStatus);\n+                        updateCheckControls(vStatus.checkControlMessages);\n+                        updateServices(vStatus.cbsData);\n+                        updatePosition(vStatus.position);\n+                    }\n+                } catch (JsonSyntaxException jse) {\n+                    logger.debug(\"{}\", jse.getMessage());\n+                }\n+            }\n+            removeCallback(this);\n+        }\n+\n+        @Override\n+        public void onError(NetworkError error) {\n+            logger.debug(\"{}\", error.toString());\n+            if (error.status == 404) {\n+                legacyMode = true;\n+                logger.debug(\"VehicleStatus not found - switch to legacy API\");\n+                proxy.get().requestLegacyVehcileStatus(configuration.get(), oldVehicleStatusCallback);\n+            }\n+            vehicleStatusCache = Optional.of(Converter.getGson().toJson(error));\n+            setThingStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, error.reason);\n+            removeCallback(this);\n+        }\n+    }\n+\n+    /**\n+     * Fallback API if origin isn't supported.\n+     * This comes from the Community Discussion where a Vehicle from 2015 answered with \"404\"\n+     * https://community.openhab.org/t/bmw-connecteddrive-binding/105124\n+     *\n+     * Selection of API was discussed here\n+     * https://community.openhab.org/t/bmw-connecteddrive-bmw-i3/103876\n+     *\n+     * I figured out that only one API was working for this Vehicle. So this backward compatible Callback is introduced.\n+     * The delivered data is converted into the origin dto object so no changes in previous functional code needed\n+     */\n+    @NonNullByDefault({})\n+    public class LegacyVehicleStatusCallback implements StringResponseCallback {\n+        @Override\n+        public void onResponse(@Nullable String content) {\n+            if (content != null) {\n+                try {\n+                    VehicleAttributesContainer vac = Converter.getGson().fromJson(content,\n+                            VehicleAttributesContainer.class);\n+                    if (vac != null) {\n+                        vehicleStatusCallback.onResponse(vac.transform());\n+                    }\n+                } catch (JsonSyntaxException jse) {\n+                    logger.debug(\"{}\", jse.getMessage());\n+                }\n+            }\n+        }\n+\n+        @Override\n+        public void onError(NetworkError error) {\n+            vehicleStatusCallback.onError(error);\n+        }\n+    }\n+\n+    private void handleChargeProfileCommand(ChannelUID channelUID, Command command) {\n+        if (chargeProfileEdit.isEmpty()) {\n+            chargeProfileEdit = getChargeProfileWrapper();\n+        }\n+\n+        chargeProfileEdit.ifPresent(profile -> {\n+\n+            boolean processed = false;\n+\n+            final String id = channelUID.getIdWithoutGroup();\n+\n+            if (command instanceof StringType) {\n+                final String stringCommand = ((StringType) command).toFullString();\n+                switch (id) {\n+                    case CHARGE_PROFILE_PREFERENCE:\n+                        profile.setPreference(stringCommand);\n+                        updateChannel(CHANNEL_GROUP_CHARGE, CHARGE_PROFILE_PREFERENCE,\n+                                StringType.valueOf(Converter.toTitleCase(profile.getPreference())));\n+                        processed = true;\n+                        break;\n+                    case CHARGE_PROFILE_MODE:\n+                        profile.setMode(stringCommand);\n+                        updateChannel(CHANNEL_GROUP_CHARGE, CHARGE_PROFILE_MODE,\n+                                StringType.valueOf(Converter.toTitleCase(profile.getMode())));\n+                        processed = true;\n+                        break;\n+                    default:\n+                        break;\n+                }\n+            } else if (command instanceof OnOffType) {\n+                final ProfileKey enableKey = ChargeProfileUtils.getEnableKey(id);\n+                if (enableKey != null) {\n+                    profile.setEnabled(enableKey, OnOffType.ON.equals(command));\n+                    updateTimedState(profile, enableKey);\n+                    processed = true;\n+                } else {\n+                    final ChargeKeyDay chargeKeyDay = ChargeProfileUtils.getKeyDay(id);\n+                    if (chargeKeyDay != null) {\n+                        profile.setDayEnabled(chargeKeyDay.key, chargeKeyDay.day, OnOffType.ON.equals(command));\n+                        updateTimedState(profile, chargeKeyDay.key);\n+                        processed = true;\n+                    }\n+                }\n+            } else if (command instanceof DecimalType) {\n+                final ChargeKeyHour keyHour = ChargeProfileUtils.getKeyHour(id);\n+                if (keyHour != null) {\n+                    if (keyHour.isHour) {\n+                        profile.setHour(keyHour.key, ((DecimalType) command).intValue());\n+                    } else {\n+                        profile.setMinute(keyHour.key, ((DecimalType) command).intValue());\n+                    }\n+                    updateTimedState(profile, keyHour.key);\n+                    processed = true;\n+                }\n+            }\n+\n+            if (processed) {\n+                // cancel current timer and add another 5 mins - valid for each edit\n+                editTimeout.ifPresent(timeout -> timeout.cancel(true));\n+                // start edit timer with 5 min timeout\n+                editTimeout = Optional.of(scheduler.schedule(() -> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "48af48c82562d006b6f2aa35922270f181c885ed"}, "originalPosition": 774}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5ODI5OTI2Ng==", "bodyText": "fixed in weymann#9", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r598299266", "createdAt": "2021-03-21T15:50:16Z", "author": {"login": "ntruchsess"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/VehicleHandler.java", "diffHunk": "@@ -0,0 +1,826 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bmwconnecteddrive.internal.handler;\n+\n+import static org.openhab.binding.bmwconnecteddrive.internal.ConnectedDriveConstants.*;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.bmwconnecteddrive.internal.VehicleConfiguration;\n+import org.openhab.binding.bmwconnecteddrive.internal.action.ChargeProfileActions;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.DestinationContainer;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.NetworkError;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.compat.VehicleAttributesContainer;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.statistics.AllTrips;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.statistics.AllTripsContainer;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.statistics.LastTrip;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.statistics.LastTripContainer;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.status.VehicleStatus;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.status.VehicleStatusContainer;\n+import org.openhab.binding.bmwconnecteddrive.internal.handler.RemoteServiceHandler.ExecutionState;\n+import org.openhab.binding.bmwconnecteddrive.internal.handler.RemoteServiceHandler.RemoteService;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileUtils;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileUtils.ChargeKeyDay;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileUtils.ChargeKeyHour;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileWrapper;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileWrapper.ProfileKey;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Constants;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Converter;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ImageProperties;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.RemoteServiceUtils;\n+import org.openhab.core.io.net.http.HttpUtil;\n+import org.openhab.core.library.types.DecimalType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.RawType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BridgeHandler;\n+import org.openhab.core.thing.binding.ThingHandlerService;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+\n+import com.google.gson.JsonSyntaxException;\n+\n+/**\n+ * The {@link VehicleHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Bernd Weymann - Initial contribution\n+ * @author Norbert Truchsess - edit & send charge profile\n+ */\n+@NonNullByDefault\n+public class VehicleHandler extends VehicleChannelHandler {\n+    private boolean legacyMode = false; // switch to legacy API in case of 404 Errors\n+\n+    private Optional<ConnectedDriveProxy> proxy = Optional.empty();\n+    private Optional<RemoteServiceHandler> remote = Optional.empty();\n+    private Optional<VehicleConfiguration> configuration = Optional.empty();\n+    private Optional<ConnectedDriveBridgeHandler> bridgeHandler = Optional.empty();\n+    private Optional<ScheduledFuture<?>> refreshJob = Optional.empty();\n+    private Optional<ScheduledFuture<?>> editTimeout = Optional.empty();\n+    private Optional<List<ResponseCallback>> callbackCounter = Optional.empty();\n+\n+    private ImageProperties imageProperties = new ImageProperties();\n+    VehicleStatusCallback vehicleStatusCallback = new VehicleStatusCallback();\n+    StringResponseCallback oldVehicleStatusCallback = new LegacyVehicleStatusCallback();\n+    StringResponseCallback lastTripCallback = new LastTripCallback();\n+    StringResponseCallback allTripsCallback = new AllTripsCallback();\n+    StringResponseCallback chargeProfileCallback = new ChargeProfilesCallback();\n+    StringResponseCallback rangeMapCallback = new RangeMapCallback();\n+    DestinationsCallback destinationCallback = new DestinationsCallback();\n+    ByteResponseCallback imageCallback = new ImageCallback();\n+\n+    private Optional<ChargeProfileWrapper> chargeProfileEdit = Optional.empty();\n+    private Optional<String> chargeProfileSent = Optional.empty();\n+\n+    public VehicleHandler(Thing thing, BMWConnectedDriveOptionProvider op, String type, boolean imperial) {\n+        super(thing, op, type, imperial);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        String group = channelUID.getGroupId();\n+\n+        // Refresh of Channels with cached values\n+        if (command instanceof RefreshType) {\n+            if (CHANNEL_GROUP_LAST_TRIP.equals(group)) {\n+                lastTripCache.ifPresent(lastTrip -> lastTripCallback.onResponse(lastTrip));\n+            } else if (CHANNEL_GROUP_LIFETIME.equals(group)) {\n+                allTripsCache.ifPresent(allTrips -> allTripsCallback.onResponse(allTrips));\n+            } else if (CHANNEL_GROUP_DESTINATION.equals(group)) {\n+                destinationCache.ifPresent(destination -> destinationCallback.onResponse(destination));\n+            } else if (CHANNEL_GROUP_STATUS.equals(group)) {\n+                vehicleStatusCache.ifPresent(vehicleStatus -> vehicleStatusCallback.onResponse(vehicleStatus));\n+            } else if (CHANNEL_GROUP_CHARGE.equals(group)) {\n+                chargeProfileEdit.ifPresentOrElse(this::updateChargeProfile,\n+                        () -> chargeProfileCache.ifPresent(this::updateChargeProfileFromContent));\n+            } else if (CHANNEL_GROUP_VEHICLE_IMAGE.equals(group)) {\n+                imageCache.ifPresent(image -> imageCallback.onResponse(image));\n+            }\n+            // Check for Channel Group and corresponding Actions\n+        } else if (CHANNEL_GROUP_REMOTE.equals(group)) {\n+            // Executing Remote Services\n+            if (command instanceof StringType) {\n+                String serviceCommand = ((StringType) command).toFullString();\n+                remote.ifPresent(remot -> {\n+                    switch (serviceCommand) {\n+                        case REMOTE_SERVICE_LIGHT_FLASH:\n+                        case REMOTE_SERVICE_AIR_CONDITIONING:\n+                        case REMOTE_SERVICE_DOOR_LOCK:\n+                        case REMOTE_SERVICE_DOOR_UNLOCK:\n+                        case REMOTE_SERVICE_HORN:\n+                        case REMOTE_SERVICE_VEHICLE_FINDER:\n+                        case REMOTE_SERVICE_CHARGE_NOW:\n+                            RemoteServiceUtils.getRemoteService(serviceCommand)\n+                                    .ifPresentOrElse(service -> remot.execute(service), () -> {\n+                                        logger.info(\"Remote service execution {} unknown\", serviceCommand);\n+                                    });\n+                            break;\n+                        case REMOTE_SERVICE_CHARGING_CONTROL:\n+                            sendChargeProfile(chargeProfileEdit);\n+                            break;\n+                        default:\n+                            logger.info(\"Remote service execution {} unknown\", serviceCommand);\n+                            break;\n+                    }\n+                });\n+            }\n+        } else if (CHANNEL_GROUP_VEHICLE_IMAGE.equals(group)) {\n+            // Image Change\n+            configuration.ifPresent(config -> {\n+                if (command instanceof StringType) {\n+                    if (channelUID.getIdWithoutGroup().equals(IMAGE_VIEWPORT)) {\n+                        String newViewport = command.toString();\n+                        synchronized (imageProperties) {\n+                            if (!imageProperties.viewport.equals(newViewport)) {\n+                                imageProperties = new ImageProperties(newViewport, imageProperties.size);\n+                                imageCache = Optional.empty();\n+                                proxy.ifPresent(prox -> prox.requestImage(config, imageProperties, imageCallback));\n+                            }\n+                        }\n+                        updateChannel(CHANNEL_GROUP_VEHICLE_IMAGE, IMAGE_VIEWPORT, StringType.valueOf(newViewport));\n+                    }\n+                }\n+                if (command instanceof DecimalType) {\n+                    if (command instanceof DecimalType) {\n+                        int newImageSize = ((DecimalType) command).intValue();\n+                        if (channelUID.getIdWithoutGroup().equals(IMAGE_SIZE)) {\n+                            synchronized (imageProperties) {\n+                                if (imageProperties.size != newImageSize) {\n+                                    imageProperties = new ImageProperties(imageProperties.viewport, newImageSize);\n+                                    imageCache = Optional.empty();\n+                                    proxy.ifPresent(prox -> prox.requestImage(config, imageProperties, imageCallback));\n+                                }\n+                            }\n+                        }\n+                        updateChannel(CHANNEL_GROUP_VEHICLE_IMAGE, IMAGE_SIZE, new DecimalType(newImageSize));\n+                    }\n+                }\n+            });\n+        } else if (CHANNEL_GROUP_DESTINATION.equals(group)) {\n+            if (command instanceof StringType) {\n+                int index = Converter.getIndex(command.toFullString());\n+                if (index != -1) {\n+                    selectDestination(index);\n+                } else {\n+                    logger.debug(\"Cannot select Destination index {}\", command.toFullString());\n+                }\n+            }\n+        } else if (CHANNEL_GROUP_SERVICE.equals(group)) {\n+            if (command instanceof StringType) {\n+                int index = Converter.getIndex(command.toFullString());\n+                if (index != -1) {\n+                    selectService(index);\n+                } else {\n+                    logger.debug(\"Cannot select Service index {}\", command.toFullString());\n+                }\n+            }\n+        } else if (CHANNEL_GROUP_CHECK_CONTROL.equals(group)) {\n+            if (command instanceof StringType) {\n+                int index = Converter.getIndex(command.toFullString());\n+                if (index != -1) {\n+                    selectCheckControl(index);\n+                } else {\n+                    logger.debug(\"Cannot select CheckControl index {}\", command.toFullString());\n+                }\n+            }\n+        } else if (CHANNEL_GROUP_CHARGE.equals(group)) {\n+            handleChargeProfileCommand(channelUID, command);\n+        }\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        callbackCounter = Optional.of(new ArrayList<ResponseCallback>());\n+        updateStatus(ThingStatus.UNKNOWN);\n+        final VehicleConfiguration config = getConfigAs(VehicleConfiguration.class);\n+        if (config != null) {\n+            configuration = Optional.of(config);\n+            scheduler.execute(() -> {\n+                Bridge bridge = getBridge();\n+                if (bridge != null) {\n+                    BridgeHandler handler = bridge.getHandler();\n+                    if (handler != null) {\n+                        bridgeHandler = Optional.of(((ConnectedDriveBridgeHandler) handler));\n+                        proxy = ((ConnectedDriveBridgeHandler) handler).getProxy();\n+                        remote = proxy.map(prox -> prox.getRemoteServiceHandler(this));\n+                    } else {\n+                        logger.debug(\"Bridge Handler null\");\n+                    }\n+                } else {\n+                    logger.debug(\"Bridge null\");\n+                }\n+\n+                // get Image after init with config values\n+                synchronized (imageProperties) {\n+                    imageProperties = new ImageProperties(config.imageViewport, config.imageSize);\n+                }\n+                updateChannel(CHANNEL_GROUP_VEHICLE_IMAGE, IMAGE_VIEWPORT, StringType.valueOf((config.imageViewport)));\n+                updateChannel(CHANNEL_GROUP_VEHICLE_IMAGE, IMAGE_SIZE, new DecimalType((config.imageSize)));\n+\n+                // check imperial setting is different to AutoDetect\n+                if (!UNITS_AUTODETECT.equals(config.units)) {\n+                    imperial = UNITS_IMPERIAL.equals(config.units);\n+                }\n+\n+                // start update schedule\n+                startSchedule(config.refreshInterval);\n+            });\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR);\n+        }\n+    }\n+\n+    private void startSchedule(int interval) {\n+        refreshJob.ifPresentOrElse(job -> {\n+            if (job.isCancelled()) {\n+                refreshJob = Optional\n+                        .of(scheduler.scheduleWithFixedDelay(this::getData, 0, interval, TimeUnit.MINUTES));\n+            } // else - scheduler is already running!\n+        }, () -> {\n+            refreshJob = Optional.of(scheduler.scheduleWithFixedDelay(this::getData, 0, interval, TimeUnit.MINUTES));\n+        });\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        refreshJob.ifPresent(job -> job.cancel(true));\n+    }\n+\n+    public void getData() {\n+        proxy.ifPresentOrElse(prox -> {\n+            configuration.ifPresentOrElse(config -> {\n+                if (!legacyMode) {\n+                    prox.requestVehcileStatus(config, vehicleStatusCallback);\n+                } else {\n+                    prox.requestLegacyVehcileStatus(config, oldVehicleStatusCallback);\n+                }\n+                addCallback(vehicleStatusCallback);\n+                if (isSupported(Constants.STATISTICS)) {\n+                    prox.requestLastTrip(config, lastTripCallback);\n+                    prox.requestAllTrips(config, allTripsCallback);\n+                    addCallback(lastTripCallback);\n+                    addCallback(allTripsCallback);\n+                }\n+                if (isSupported(Constants.LAST_DESTINATIONS)) {\n+                    prox.requestDestinations(config, destinationCallback);\n+                    addCallback(destinationCallback);\n+                }\n+                if (isElectric) {\n+                    prox.requestChargingProfile(config, chargeProfileCallback);\n+                    addCallback(chargeProfileCallback);\n+                }\n+                synchronized (imageProperties) {\n+                    if (!imageCache.isPresent() && !imageProperties.failLimitReached()) {\n+                        prox.requestImage(config, imageProperties, imageCallback);\n+                        addCallback(imageCallback);\n+                    }\n+                }\n+            }, () -> {\n+                logger.warn(\"ConnectedDrive Configuration isn't present\");\n+            });\n+        }, () -> {\n+            logger.warn(\"ConnectedDrive Proxy isn't present\");\n+        });\n+    }\n+\n+    private synchronized void addCallback(ResponseCallback rc) {\n+        callbackCounter.ifPresent(counter -> counter.add(rc));\n+    }\n+\n+    private synchronized void removeCallback(ResponseCallback rc) {\n+        callbackCounter.ifPresent(counter -> {\n+            counter.remove(rc);\n+            // all necessary callbacks received => print and set to empty\n+            if (counter.isEmpty()) {\n+                logFingerPrint();\n+                callbackCounter = Optional.empty();\n+            }\n+        });\n+    }\n+\n+    private void logFingerPrint() {\n+        final String vin = configuration.map(config -> config.vin).orElse(\"\");\n+        logger.debug(\"###### BMW ConnectedDrive Binding - Vehicle Troubleshoot Fingerprint Data - BEGIN ######\");\n+        logger.debug(\"### Discovery Result ###\");\n+        bridgeHandler.ifPresent(handler -> {\n+            logger.debug(\"{}\", handler.getDiscoveryFingerprint());\n+        });\n+        vehicleStatusCache.ifPresentOrElse(vehicleStatus -> {\n+            logger.debug(\"### Vehicle Status ###\");\n+\n+            // Anonymous data for VIN and Position\n+            try {\n+                VehicleStatusContainer container = Converter.getGson().fromJson(vehicleStatus,\n+                        VehicleStatusContainer.class);\n+                if (container != null) {\n+                    VehicleStatus status = container.vehicleStatus;\n+                    if (status != null) {\n+                        status.vin = Constants.ANONYMOUS;\n+                        if (status.position != null) {\n+                            status.position.lat = -1;\n+                            status.position.lon = -1;\n+                            status.position.heading = -1;\n+                        }\n+                    }\n+                }\n+                logger.debug(\"{}\", Converter.getGson().toJson(container));\n+            } catch (JsonSyntaxException jse) {\n+                logger.debug(\"{}\", jse.getMessage());\n+            }\n+        }, () -> {\n+            logger.debug(\"### Vehicle Status Empty ###\");\n+        });\n+        lastTripCache.ifPresentOrElse(lastTrip -> {\n+            logger.debug(\"### Last Trip ###\");\n+            logger.debug(\"{}\", lastTrip.replaceAll(vin, Constants.ANONYMOUS));\n+        }, () -> {\n+            logger.debug(\"### Last Trip Empty ###\");\n+        });\n+        allTripsCache.ifPresentOrElse(allTrips -> {\n+            logger.debug(\"### All Trips ###\");\n+            logger.debug(\"{}\", allTrips.replaceAll(vin, Constants.ANONYMOUS));\n+        }, () -> {\n+            logger.debug(\"### All Trips Empty ###\");\n+        });\n+        if (isElectric) {\n+            chargeProfileCache.ifPresentOrElse(chargeProfile -> {\n+                logger.debug(\"### Charge Profile ###\");\n+                logger.debug(\"{}\", chargeProfile.replaceAll(vin, Constants.ANONYMOUS));\n+            }, () -> {\n+                logger.debug(\"### Charge Profile Empty ###\");\n+            });\n+        }\n+        destinationCache.ifPresentOrElse(destination -> {\n+            logger.debug(\"### Charge Profile ###\");\n+            try {\n+                DestinationContainer container = Converter.getGson().fromJson(destination, DestinationContainer.class);\n+                if (container != null) {\n+                    if (container.destinations != null) {\n+                        container.destinations.forEach(entry -> {\n+                            entry.lat = 0;\n+                            entry.lon = 0;\n+                            entry.city = Constants.ANONYMOUS;\n+                            entry.street = Constants.ANONYMOUS;\n+                            entry.streetNumber = Constants.ANONYMOUS;\n+                            entry.country = Constants.ANONYMOUS;\n+                        });\n+                        logger.debug(\"{}\", Converter.getGson().toJson(container));\n+                    }\n+                } else {\n+                    logger.debug(\"### Destinations Empty ###\");\n+                }\n+            } catch (JsonSyntaxException jse) {\n+                logger.debug(\"{}\", jse.getMessage());\n+            }\n+        }, () -> {\n+            logger.debug(\"### Charge Profile Empty ###\");\n+        });\n+        rangeMapCache.ifPresentOrElse(rangeMap -> {\n+            logger.debug(\"### Range Map ###\");\n+            logger.debug(\"{}\", rangeMap.replaceAll(vin, Constants.ANONYMOUS));\n+        }, () -> {\n+            logger.debug(\"### Range Map Empty ###\");\n+        });\n+        logger.debug(\"###### BMW ConnectedDrive Binding - Vehicle Troubleshoot Fingerprint Data - END ######\");\n+    }\n+\n+    /**\n+     * Don't stress ConnectedDrive with unnecessary requests. One call at the beginning is done to check the response.\n+     * After cache has e.g. a proper error response it will be shown in the fingerprint\n+     *\n+     * @return\n+     */\n+    private boolean isSupported(String service) {\n+        final String services = thing.getProperties().get(Constants.SERVICES_SUPPORTED);\n+        if (services != null) {\n+            if (services.contains(service)) {\n+                return true;\n+            }\n+        }\n+        // if cache is empty give it a try one time to collected Troubleshoot data\n+        if (lastTripCache.isEmpty() || allTripsCache.isEmpty() || destinationCache.isEmpty()) {\n+            return true;\n+        } else {\n+            return false;\n+        }\n+    }\n+\n+    public void updateRemoteExecutionStatus(@Nullable String service, @Nullable String status) {\n+        if (RemoteService.CHARGING_CONTROL.toString().equals(service)\n+                && ExecutionState.EXECUTED.name().equals(status)) {\n+            saveChargeProfileSent();\n+        }\n+        updateChannel(CHANNEL_GROUP_REMOTE, REMOTE_STATE, StringType.valueOf(Converter.toTitleCase(\n+                new StringBuilder(service == null ? \"-\" : service).append(\" \").append(status).toString())));\n+    }\n+\n+    public Optional<VehicleConfiguration> getConfiguration() {\n+        return configuration;\n+    }\n+\n+    public ScheduledExecutorService getScheduler() {\n+        return scheduler;\n+    }\n+\n+    /**\n+     * Callbacks for ConnectedDrive Portal\n+     *\n+     * @author Bernd Weymann\n+     *\n+     */\n+    @NonNullByDefault({})\n+    public class ChargeProfilesCallback implements StringResponseCallback {\n+        @Override\n+        public void onResponse(@Nullable String content) {\n+            if (content != null) {\n+                chargeProfileCache = Optional.of(content);\n+                if (chargeProfileEdit.isEmpty()) {\n+                    updateChargeProfileFromContent(content);\n+                }\n+            }\n+            removeCallback(this);\n+        }\n+\n+        /**\n+         * Store Error Report in cache variable. Via Fingerprint Channel error is logged and Issue can be raised\n+         */\n+        @Override\n+        public void onError(NetworkError error) {\n+            logger.debug(\"{}\", error.toString());\n+            chargeProfileCache = Optional.of(Converter.getGson().toJson(error));\n+            removeCallback(this);\n+        }\n+    }\n+\n+    @NonNullByDefault({})\n+    public class RangeMapCallback implements StringResponseCallback {\n+        @Override\n+        public void onResponse(@Nullable String content) {\n+            rangeMapCache = Optional.ofNullable(content);\n+            removeCallback(this);\n+        }\n+\n+        /**\n+         * Store Error Report in cache variable. Via Fingerprint Channel error is logged and Issue can be raised\n+         */\n+        @Override\n+        public void onError(NetworkError error) {\n+            logger.debug(\"{}\", error.toString());\n+            rangeMapCache = Optional.of(Converter.getGson().toJson(error));\n+            removeCallback(this);\n+        }\n+    }\n+\n+    @NonNullByDefault({})\n+    public class DestinationsCallback implements StringResponseCallback {\n+\n+        @Override\n+        public void onResponse(@Nullable String content) {\n+            destinationCache = Optional.ofNullable(content);\n+            if (content != null) {\n+                try {\n+                    DestinationContainer dc = Converter.getGson().fromJson(content, DestinationContainer.class);\n+                    if (dc != null && dc.destinations != null) {\n+                        updateDestinations(dc.destinations);\n+                    }\n+                } catch (JsonSyntaxException jse) {\n+                    logger.debug(\"{}\", jse.getMessage());\n+                }\n+            }\n+            removeCallback(this);\n+        }\n+\n+        /**\n+         * Store Error Report in cache variable. Via Fingerprint Channel error is logged and Issue can be raised\n+         */\n+        @Override\n+        public void onError(NetworkError error) {\n+            logger.debug(\"{}\", error.toString());\n+            destinationCache = Optional.of(Converter.getGson().toJson(error));\n+            removeCallback(this);\n+        }\n+    }\n+\n+    @NonNullByDefault({})\n+    public class ImageCallback implements ByteResponseCallback {\n+        @Override\n+        public void onResponse(byte[] content) {\n+            if (content.length > 0) {\n+                imageCache = Optional.of(content);\n+                String contentType = HttpUtil.guessContentTypeFromData(content);\n+                updateChannel(CHANNEL_GROUP_VEHICLE_IMAGE, IMAGE_FORMAT, new RawType(content, contentType));\n+            } else {\n+                synchronized (imageProperties) {\n+                    imageProperties.failed();\n+                }\n+            }\n+            removeCallback(this);\n+        }\n+\n+        /**\n+         * Store Error Report in cache variable. Via Fingerprint Channel error is logged and Issue can be raised\n+         */\n+        @Override\n+        public void onError(NetworkError error) {\n+            logger.debug(\"{}\", error.toString());\n+            synchronized (imageProperties) {\n+                imageProperties.failed();\n+            }\n+            removeCallback(this);\n+        }\n+    }\n+\n+    @NonNullByDefault({})\n+    public class AllTripsCallback implements StringResponseCallback {\n+        @Override\n+        public void onResponse(@Nullable String content) {\n+            if (content != null) {\n+                allTripsCache = Optional.of(content);\n+                try {\n+                    AllTripsContainer atc = Converter.getGson().fromJson(content, AllTripsContainer.class);\n+                    if (atc != null) {\n+                        AllTrips at = atc.allTrips;\n+                        if (at != null) {\n+                            updateAllTrips(at);\n+                        }\n+                    }\n+                } catch (JsonSyntaxException jse) {\n+                    logger.debug(\"{}\", jse.getMessage());\n+                }\n+            }\n+            removeCallback(this);\n+        }\n+\n+        /**\n+         * Store Error Report in cache variable. Via Fingerprint Channel error is logged and Issue can be raised\n+         */\n+        @Override\n+        public void onError(NetworkError error) {\n+            logger.debug(\"{}\", error.toString());\n+            allTripsCache = Optional.of(Converter.getGson().toJson(error));\n+            removeCallback(this);\n+        }\n+    }\n+\n+    @NonNullByDefault({})\n+    public class LastTripCallback implements StringResponseCallback {\n+        @Override\n+        public void onResponse(@Nullable String content) {\n+            if (content != null) {\n+                lastTripCache = Optional.of(content);\n+                try {\n+                    LastTripContainer lt = Converter.getGson().fromJson(content, LastTripContainer.class);\n+                    if (lt != null) {\n+                        LastTrip trip = lt.lastTrip;\n+                        if (trip != null) {\n+                            updateLastTrip(trip);\n+                        }\n+                    }\n+                } catch (JsonSyntaxException jse) {\n+                    logger.debug(\"{}\", jse.getMessage());\n+                }\n+            }\n+            removeCallback(this);\n+        }\n+\n+        /**\n+         * Store Error Report in cache variable. Via Fingerprint Channel error is logged and Issue can be raised\n+         */\n+        @Override\n+        public void onError(NetworkError error) {\n+            logger.debug(\"{}\", error.toString());\n+            lastTripCache = Optional.of(Converter.getGson().toJson(error));\n+            removeCallback(this);\n+        }\n+    }\n+\n+    /**\n+     * The VehicleStatus is supported by all Vehicle Types so it's used to reflect the Thing Status\n+     */\n+    @NonNullByDefault({})\n+    public class VehicleStatusCallback implements StringResponseCallback {\n+        private ThingStatus thingStatus = ThingStatus.UNKNOWN;\n+\n+        /**\n+         * Vehicle Status is supported by all Vehicles so callback result is used to report Thing Status.\n+         * If valid content is delivered in onResponse Thing goes online while onError Thing goes offline\n+         *\n+         * @param status\n+         * @param detail\n+         * @param reason\n+         */\n+        private void setThingStatus(ThingStatus status, ThingStatusDetail detail, String reason) {\n+            if (thingStatus != status) {\n+                updateStatus(status, detail, reason);\n+            }\n+        }\n+\n+        @Override\n+        public void onResponse(@Nullable String content) {\n+            if (content != null) {\n+                setThingStatus(ThingStatus.ONLINE, ThingStatusDetail.NONE, Constants.EMPTY);\n+                vehicleStatusCache = Optional.of(content);\n+                try {\n+                    VehicleStatusContainer status = Converter.getGson().fromJson(content, VehicleStatusContainer.class);\n+                    if (status != null) {\n+                        VehicleStatus vStatus = status.vehicleStatus;\n+                        if (vStatus == null) {\n+                            return;\n+                        }\n+                        updateVehicleStatus(vStatus);\n+                        updateCheckControls(vStatus.checkControlMessages);\n+                        updateServices(vStatus.cbsData);\n+                        updatePosition(vStatus.position);\n+                    }\n+                } catch (JsonSyntaxException jse) {\n+                    logger.debug(\"{}\", jse.getMessage());\n+                }\n+            }\n+            removeCallback(this);\n+        }\n+\n+        @Override\n+        public void onError(NetworkError error) {\n+            logger.debug(\"{}\", error.toString());\n+            if (error.status == 404) {\n+                legacyMode = true;\n+                logger.debug(\"VehicleStatus not found - switch to legacy API\");\n+                proxy.get().requestLegacyVehcileStatus(configuration.get(), oldVehicleStatusCallback);\n+            }\n+            vehicleStatusCache = Optional.of(Converter.getGson().toJson(error));\n+            setThingStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, error.reason);\n+            removeCallback(this);\n+        }\n+    }\n+\n+    /**\n+     * Fallback API if origin isn't supported.\n+     * This comes from the Community Discussion where a Vehicle from 2015 answered with \"404\"\n+     * https://community.openhab.org/t/bmw-connecteddrive-binding/105124\n+     *\n+     * Selection of API was discussed here\n+     * https://community.openhab.org/t/bmw-connecteddrive-bmw-i3/103876\n+     *\n+     * I figured out that only one API was working for this Vehicle. So this backward compatible Callback is introduced.\n+     * The delivered data is converted into the origin dto object so no changes in previous functional code needed\n+     */\n+    @NonNullByDefault({})\n+    public class LegacyVehicleStatusCallback implements StringResponseCallback {\n+        @Override\n+        public void onResponse(@Nullable String content) {\n+            if (content != null) {\n+                try {\n+                    VehicleAttributesContainer vac = Converter.getGson().fromJson(content,\n+                            VehicleAttributesContainer.class);\n+                    if (vac != null) {\n+                        vehicleStatusCallback.onResponse(vac.transform());\n+                    }\n+                } catch (JsonSyntaxException jse) {\n+                    logger.debug(\"{}\", jse.getMessage());\n+                }\n+            }\n+        }\n+\n+        @Override\n+        public void onError(NetworkError error) {\n+            vehicleStatusCallback.onError(error);\n+        }\n+    }\n+\n+    private void handleChargeProfileCommand(ChannelUID channelUID, Command command) {\n+        if (chargeProfileEdit.isEmpty()) {\n+            chargeProfileEdit = getChargeProfileWrapper();\n+        }\n+\n+        chargeProfileEdit.ifPresent(profile -> {\n+\n+            boolean processed = false;\n+\n+            final String id = channelUID.getIdWithoutGroup();\n+\n+            if (command instanceof StringType) {\n+                final String stringCommand = ((StringType) command).toFullString();\n+                switch (id) {\n+                    case CHARGE_PROFILE_PREFERENCE:\n+                        profile.setPreference(stringCommand);\n+                        updateChannel(CHANNEL_GROUP_CHARGE, CHARGE_PROFILE_PREFERENCE,\n+                                StringType.valueOf(Converter.toTitleCase(profile.getPreference())));\n+                        processed = true;\n+                        break;\n+                    case CHARGE_PROFILE_MODE:\n+                        profile.setMode(stringCommand);\n+                        updateChannel(CHANNEL_GROUP_CHARGE, CHARGE_PROFILE_MODE,\n+                                StringType.valueOf(Converter.toTitleCase(profile.getMode())));\n+                        processed = true;\n+                        break;\n+                    default:\n+                        break;\n+                }\n+            } else if (command instanceof OnOffType) {\n+                final ProfileKey enableKey = ChargeProfileUtils.getEnableKey(id);\n+                if (enableKey != null) {\n+                    profile.setEnabled(enableKey, OnOffType.ON.equals(command));\n+                    updateTimedState(profile, enableKey);\n+                    processed = true;\n+                } else {\n+                    final ChargeKeyDay chargeKeyDay = ChargeProfileUtils.getKeyDay(id);\n+                    if (chargeKeyDay != null) {\n+                        profile.setDayEnabled(chargeKeyDay.key, chargeKeyDay.day, OnOffType.ON.equals(command));\n+                        updateTimedState(profile, chargeKeyDay.key);\n+                        processed = true;\n+                    }\n+                }\n+            } else if (command instanceof DecimalType) {\n+                final ChargeKeyHour keyHour = ChargeProfileUtils.getKeyHour(id);\n+                if (keyHour != null) {\n+                    if (keyHour.isHour) {\n+                        profile.setHour(keyHour.key, ((DecimalType) command).intValue());\n+                    } else {\n+                        profile.setMinute(keyHour.key, ((DecimalType) command).intValue());\n+                    }\n+                    updateTimedState(profile, keyHour.key);\n+                    processed = true;\n+                }\n+            }\n+\n+            if (processed) {\n+                // cancel current timer and add another 5 mins - valid for each edit\n+                editTimeout.ifPresent(timeout -> timeout.cancel(true));\n+                // start edit timer with 5 min timeout\n+                editTimeout = Optional.of(scheduler.schedule(() -> {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5NzkyMjk5NQ=="}, "originalCommit": {"oid": "48af48c82562d006b6f2aa35922270f181c885ed"}, "originalPosition": 774}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzc3NjgwNjQ1OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/VehicleHandler.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0xOVQxOToyMjowOFrOI6OWJw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0yMVQxNTo1NTo1MFrOI6lVaQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5NzkyMzM2Nw==", "bodyText": "Syntactical sugar. Same for below.\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                chargeProfileCache.ifPresent(content -> updateChargeProfileFromContent(content));\n          \n          \n            \n                                chargeProfileCache.ifPresent(this::updateChargeProfileFromContent);", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r597923367", "createdAt": "2021-03-19T19:22:08Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/VehicleHandler.java", "diffHunk": "@@ -0,0 +1,826 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bmwconnecteddrive.internal.handler;\n+\n+import static org.openhab.binding.bmwconnecteddrive.internal.ConnectedDriveConstants.*;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.bmwconnecteddrive.internal.VehicleConfiguration;\n+import org.openhab.binding.bmwconnecteddrive.internal.action.ChargeProfileActions;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.DestinationContainer;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.NetworkError;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.compat.VehicleAttributesContainer;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.statistics.AllTrips;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.statistics.AllTripsContainer;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.statistics.LastTrip;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.statistics.LastTripContainer;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.status.VehicleStatus;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.status.VehicleStatusContainer;\n+import org.openhab.binding.bmwconnecteddrive.internal.handler.RemoteServiceHandler.ExecutionState;\n+import org.openhab.binding.bmwconnecteddrive.internal.handler.RemoteServiceHandler.RemoteService;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileUtils;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileUtils.ChargeKeyDay;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileUtils.ChargeKeyHour;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileWrapper;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileWrapper.ProfileKey;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Constants;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Converter;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ImageProperties;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.RemoteServiceUtils;\n+import org.openhab.core.io.net.http.HttpUtil;\n+import org.openhab.core.library.types.DecimalType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.RawType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BridgeHandler;\n+import org.openhab.core.thing.binding.ThingHandlerService;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+\n+import com.google.gson.JsonSyntaxException;\n+\n+/**\n+ * The {@link VehicleHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Bernd Weymann - Initial contribution\n+ * @author Norbert Truchsess - edit & send charge profile\n+ */\n+@NonNullByDefault\n+public class VehicleHandler extends VehicleChannelHandler {\n+    private boolean legacyMode = false; // switch to legacy API in case of 404 Errors\n+\n+    private Optional<ConnectedDriveProxy> proxy = Optional.empty();\n+    private Optional<RemoteServiceHandler> remote = Optional.empty();\n+    private Optional<VehicleConfiguration> configuration = Optional.empty();\n+    private Optional<ConnectedDriveBridgeHandler> bridgeHandler = Optional.empty();\n+    private Optional<ScheduledFuture<?>> refreshJob = Optional.empty();\n+    private Optional<ScheduledFuture<?>> editTimeout = Optional.empty();\n+    private Optional<List<ResponseCallback>> callbackCounter = Optional.empty();\n+\n+    private ImageProperties imageProperties = new ImageProperties();\n+    VehicleStatusCallback vehicleStatusCallback = new VehicleStatusCallback();\n+    StringResponseCallback oldVehicleStatusCallback = new LegacyVehicleStatusCallback();\n+    StringResponseCallback lastTripCallback = new LastTripCallback();\n+    StringResponseCallback allTripsCallback = new AllTripsCallback();\n+    StringResponseCallback chargeProfileCallback = new ChargeProfilesCallback();\n+    StringResponseCallback rangeMapCallback = new RangeMapCallback();\n+    DestinationsCallback destinationCallback = new DestinationsCallback();\n+    ByteResponseCallback imageCallback = new ImageCallback();\n+\n+    private Optional<ChargeProfileWrapper> chargeProfileEdit = Optional.empty();\n+    private Optional<String> chargeProfileSent = Optional.empty();\n+\n+    public VehicleHandler(Thing thing, BMWConnectedDriveOptionProvider op, String type, boolean imperial) {\n+        super(thing, op, type, imperial);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        String group = channelUID.getGroupId();\n+\n+        // Refresh of Channels with cached values\n+        if (command instanceof RefreshType) {\n+            if (CHANNEL_GROUP_LAST_TRIP.equals(group)) {\n+                lastTripCache.ifPresent(lastTrip -> lastTripCallback.onResponse(lastTrip));\n+            } else if (CHANNEL_GROUP_LIFETIME.equals(group)) {\n+                allTripsCache.ifPresent(allTrips -> allTripsCallback.onResponse(allTrips));\n+            } else if (CHANNEL_GROUP_DESTINATION.equals(group)) {\n+                destinationCache.ifPresent(destination -> destinationCallback.onResponse(destination));\n+            } else if (CHANNEL_GROUP_STATUS.equals(group)) {\n+                vehicleStatusCache.ifPresent(vehicleStatus -> vehicleStatusCallback.onResponse(vehicleStatus));\n+            } else if (CHANNEL_GROUP_CHARGE.equals(group)) {\n+                chargeProfileEdit.ifPresentOrElse(this::updateChargeProfile,\n+                        () -> chargeProfileCache.ifPresent(this::updateChargeProfileFromContent));\n+            } else if (CHANNEL_GROUP_VEHICLE_IMAGE.equals(group)) {\n+                imageCache.ifPresent(image -> imageCallback.onResponse(image));\n+            }\n+            // Check for Channel Group and corresponding Actions\n+        } else if (CHANNEL_GROUP_REMOTE.equals(group)) {\n+            // Executing Remote Services\n+            if (command instanceof StringType) {\n+                String serviceCommand = ((StringType) command).toFullString();\n+                remote.ifPresent(remot -> {\n+                    switch (serviceCommand) {\n+                        case REMOTE_SERVICE_LIGHT_FLASH:\n+                        case REMOTE_SERVICE_AIR_CONDITIONING:\n+                        case REMOTE_SERVICE_DOOR_LOCK:\n+                        case REMOTE_SERVICE_DOOR_UNLOCK:\n+                        case REMOTE_SERVICE_HORN:\n+                        case REMOTE_SERVICE_VEHICLE_FINDER:\n+                        case REMOTE_SERVICE_CHARGE_NOW:\n+                            RemoteServiceUtils.getRemoteService(serviceCommand)\n+                                    .ifPresentOrElse(service -> remot.execute(service), () -> {\n+                                        logger.info(\"Remote service execution {} unknown\", serviceCommand);\n+                                    });\n+                            break;\n+                        case REMOTE_SERVICE_CHARGING_CONTROL:\n+                            sendChargeProfile(chargeProfileEdit);\n+                            break;\n+                        default:\n+                            logger.info(\"Remote service execution {} unknown\", serviceCommand);\n+                            break;\n+                    }\n+                });\n+            }\n+        } else if (CHANNEL_GROUP_VEHICLE_IMAGE.equals(group)) {\n+            // Image Change\n+            configuration.ifPresent(config -> {\n+                if (command instanceof StringType) {\n+                    if (channelUID.getIdWithoutGroup().equals(IMAGE_VIEWPORT)) {\n+                        String newViewport = command.toString();\n+                        synchronized (imageProperties) {\n+                            if (!imageProperties.viewport.equals(newViewport)) {\n+                                imageProperties = new ImageProperties(newViewport, imageProperties.size);\n+                                imageCache = Optional.empty();\n+                                proxy.ifPresent(prox -> prox.requestImage(config, imageProperties, imageCallback));\n+                            }\n+                        }\n+                        updateChannel(CHANNEL_GROUP_VEHICLE_IMAGE, IMAGE_VIEWPORT, StringType.valueOf(newViewport));\n+                    }\n+                }\n+                if (command instanceof DecimalType) {\n+                    if (command instanceof DecimalType) {\n+                        int newImageSize = ((DecimalType) command).intValue();\n+                        if (channelUID.getIdWithoutGroup().equals(IMAGE_SIZE)) {\n+                            synchronized (imageProperties) {\n+                                if (imageProperties.size != newImageSize) {\n+                                    imageProperties = new ImageProperties(imageProperties.viewport, newImageSize);\n+                                    imageCache = Optional.empty();\n+                                    proxy.ifPresent(prox -> prox.requestImage(config, imageProperties, imageCallback));\n+                                }\n+                            }\n+                        }\n+                        updateChannel(CHANNEL_GROUP_VEHICLE_IMAGE, IMAGE_SIZE, new DecimalType(newImageSize));\n+                    }\n+                }\n+            });\n+        } else if (CHANNEL_GROUP_DESTINATION.equals(group)) {\n+            if (command instanceof StringType) {\n+                int index = Converter.getIndex(command.toFullString());\n+                if (index != -1) {\n+                    selectDestination(index);\n+                } else {\n+                    logger.debug(\"Cannot select Destination index {}\", command.toFullString());\n+                }\n+            }\n+        } else if (CHANNEL_GROUP_SERVICE.equals(group)) {\n+            if (command instanceof StringType) {\n+                int index = Converter.getIndex(command.toFullString());\n+                if (index != -1) {\n+                    selectService(index);\n+                } else {\n+                    logger.debug(\"Cannot select Service index {}\", command.toFullString());\n+                }\n+            }\n+        } else if (CHANNEL_GROUP_CHECK_CONTROL.equals(group)) {\n+            if (command instanceof StringType) {\n+                int index = Converter.getIndex(command.toFullString());\n+                if (index != -1) {\n+                    selectCheckControl(index);\n+                } else {\n+                    logger.debug(\"Cannot select CheckControl index {}\", command.toFullString());\n+                }\n+            }\n+        } else if (CHANNEL_GROUP_CHARGE.equals(group)) {\n+            handleChargeProfileCommand(channelUID, command);\n+        }\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        callbackCounter = Optional.of(new ArrayList<ResponseCallback>());\n+        updateStatus(ThingStatus.UNKNOWN);\n+        final VehicleConfiguration config = getConfigAs(VehicleConfiguration.class);\n+        if (config != null) {\n+            configuration = Optional.of(config);\n+            scheduler.execute(() -> {\n+                Bridge bridge = getBridge();\n+                if (bridge != null) {\n+                    BridgeHandler handler = bridge.getHandler();\n+                    if (handler != null) {\n+                        bridgeHandler = Optional.of(((ConnectedDriveBridgeHandler) handler));\n+                        proxy = ((ConnectedDriveBridgeHandler) handler).getProxy();\n+                        remote = proxy.map(prox -> prox.getRemoteServiceHandler(this));\n+                    } else {\n+                        logger.debug(\"Bridge Handler null\");\n+                    }\n+                } else {\n+                    logger.debug(\"Bridge null\");\n+                }\n+\n+                // get Image after init with config values\n+                synchronized (imageProperties) {\n+                    imageProperties = new ImageProperties(config.imageViewport, config.imageSize);\n+                }\n+                updateChannel(CHANNEL_GROUP_VEHICLE_IMAGE, IMAGE_VIEWPORT, StringType.valueOf((config.imageViewport)));\n+                updateChannel(CHANNEL_GROUP_VEHICLE_IMAGE, IMAGE_SIZE, new DecimalType((config.imageSize)));\n+\n+                // check imperial setting is different to AutoDetect\n+                if (!UNITS_AUTODETECT.equals(config.units)) {\n+                    imperial = UNITS_IMPERIAL.equals(config.units);\n+                }\n+\n+                // start update schedule\n+                startSchedule(config.refreshInterval);\n+            });\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR);\n+        }\n+    }\n+\n+    private void startSchedule(int interval) {\n+        refreshJob.ifPresentOrElse(job -> {\n+            if (job.isCancelled()) {\n+                refreshJob = Optional\n+                        .of(scheduler.scheduleWithFixedDelay(this::getData, 0, interval, TimeUnit.MINUTES));\n+            } // else - scheduler is already running!\n+        }, () -> {\n+            refreshJob = Optional.of(scheduler.scheduleWithFixedDelay(this::getData, 0, interval, TimeUnit.MINUTES));\n+        });\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        refreshJob.ifPresent(job -> job.cancel(true));\n+    }\n+\n+    public void getData() {\n+        proxy.ifPresentOrElse(prox -> {\n+            configuration.ifPresentOrElse(config -> {\n+                if (!legacyMode) {\n+                    prox.requestVehcileStatus(config, vehicleStatusCallback);\n+                } else {\n+                    prox.requestLegacyVehcileStatus(config, oldVehicleStatusCallback);\n+                }\n+                addCallback(vehicleStatusCallback);\n+                if (isSupported(Constants.STATISTICS)) {\n+                    prox.requestLastTrip(config, lastTripCallback);\n+                    prox.requestAllTrips(config, allTripsCallback);\n+                    addCallback(lastTripCallback);\n+                    addCallback(allTripsCallback);\n+                }\n+                if (isSupported(Constants.LAST_DESTINATIONS)) {\n+                    prox.requestDestinations(config, destinationCallback);\n+                    addCallback(destinationCallback);\n+                }\n+                if (isElectric) {\n+                    prox.requestChargingProfile(config, chargeProfileCallback);\n+                    addCallback(chargeProfileCallback);\n+                }\n+                synchronized (imageProperties) {\n+                    if (!imageCache.isPresent() && !imageProperties.failLimitReached()) {\n+                        prox.requestImage(config, imageProperties, imageCallback);\n+                        addCallback(imageCallback);\n+                    }\n+                }\n+            }, () -> {\n+                logger.warn(\"ConnectedDrive Configuration isn't present\");\n+            });\n+        }, () -> {\n+            logger.warn(\"ConnectedDrive Proxy isn't present\");\n+        });\n+    }\n+\n+    private synchronized void addCallback(ResponseCallback rc) {\n+        callbackCounter.ifPresent(counter -> counter.add(rc));\n+    }\n+\n+    private synchronized void removeCallback(ResponseCallback rc) {\n+        callbackCounter.ifPresent(counter -> {\n+            counter.remove(rc);\n+            // all necessary callbacks received => print and set to empty\n+            if (counter.isEmpty()) {\n+                logFingerPrint();\n+                callbackCounter = Optional.empty();\n+            }\n+        });\n+    }\n+\n+    private void logFingerPrint() {\n+        final String vin = configuration.map(config -> config.vin).orElse(\"\");\n+        logger.debug(\"###### BMW ConnectedDrive Binding - Vehicle Troubleshoot Fingerprint Data - BEGIN ######\");\n+        logger.debug(\"### Discovery Result ###\");\n+        bridgeHandler.ifPresent(handler -> {\n+            logger.debug(\"{}\", handler.getDiscoveryFingerprint());\n+        });\n+        vehicleStatusCache.ifPresentOrElse(vehicleStatus -> {\n+            logger.debug(\"### Vehicle Status ###\");\n+\n+            // Anonymous data for VIN and Position\n+            try {\n+                VehicleStatusContainer container = Converter.getGson().fromJson(vehicleStatus,\n+                        VehicleStatusContainer.class);\n+                if (container != null) {\n+                    VehicleStatus status = container.vehicleStatus;\n+                    if (status != null) {\n+                        status.vin = Constants.ANONYMOUS;\n+                        if (status.position != null) {\n+                            status.position.lat = -1;\n+                            status.position.lon = -1;\n+                            status.position.heading = -1;\n+                        }\n+                    }\n+                }\n+                logger.debug(\"{}\", Converter.getGson().toJson(container));\n+            } catch (JsonSyntaxException jse) {\n+                logger.debug(\"{}\", jse.getMessage());\n+            }\n+        }, () -> {\n+            logger.debug(\"### Vehicle Status Empty ###\");\n+        });\n+        lastTripCache.ifPresentOrElse(lastTrip -> {\n+            logger.debug(\"### Last Trip ###\");\n+            logger.debug(\"{}\", lastTrip.replaceAll(vin, Constants.ANONYMOUS));\n+        }, () -> {\n+            logger.debug(\"### Last Trip Empty ###\");\n+        });\n+        allTripsCache.ifPresentOrElse(allTrips -> {\n+            logger.debug(\"### All Trips ###\");\n+            logger.debug(\"{}\", allTrips.replaceAll(vin, Constants.ANONYMOUS));\n+        }, () -> {\n+            logger.debug(\"### All Trips Empty ###\");\n+        });\n+        if (isElectric) {\n+            chargeProfileCache.ifPresentOrElse(chargeProfile -> {\n+                logger.debug(\"### Charge Profile ###\");\n+                logger.debug(\"{}\", chargeProfile.replaceAll(vin, Constants.ANONYMOUS));\n+            }, () -> {\n+                logger.debug(\"### Charge Profile Empty ###\");\n+            });\n+        }\n+        destinationCache.ifPresentOrElse(destination -> {\n+            logger.debug(\"### Charge Profile ###\");\n+            try {\n+                DestinationContainer container = Converter.getGson().fromJson(destination, DestinationContainer.class);\n+                if (container != null) {\n+                    if (container.destinations != null) {\n+                        container.destinations.forEach(entry -> {\n+                            entry.lat = 0;\n+                            entry.lon = 0;\n+                            entry.city = Constants.ANONYMOUS;\n+                            entry.street = Constants.ANONYMOUS;\n+                            entry.streetNumber = Constants.ANONYMOUS;\n+                            entry.country = Constants.ANONYMOUS;\n+                        });\n+                        logger.debug(\"{}\", Converter.getGson().toJson(container));\n+                    }\n+                } else {\n+                    logger.debug(\"### Destinations Empty ###\");\n+                }\n+            } catch (JsonSyntaxException jse) {\n+                logger.debug(\"{}\", jse.getMessage());\n+            }\n+        }, () -> {\n+            logger.debug(\"### Charge Profile Empty ###\");\n+        });\n+        rangeMapCache.ifPresentOrElse(rangeMap -> {\n+            logger.debug(\"### Range Map ###\");\n+            logger.debug(\"{}\", rangeMap.replaceAll(vin, Constants.ANONYMOUS));\n+        }, () -> {\n+            logger.debug(\"### Range Map Empty ###\");\n+        });\n+        logger.debug(\"###### BMW ConnectedDrive Binding - Vehicle Troubleshoot Fingerprint Data - END ######\");\n+    }\n+\n+    /**\n+     * Don't stress ConnectedDrive with unnecessary requests. One call at the beginning is done to check the response.\n+     * After cache has e.g. a proper error response it will be shown in the fingerprint\n+     *\n+     * @return\n+     */\n+    private boolean isSupported(String service) {\n+        final String services = thing.getProperties().get(Constants.SERVICES_SUPPORTED);\n+        if (services != null) {\n+            if (services.contains(service)) {\n+                return true;\n+            }\n+        }\n+        // if cache is empty give it a try one time to collected Troubleshoot data\n+        if (lastTripCache.isEmpty() || allTripsCache.isEmpty() || destinationCache.isEmpty()) {\n+            return true;\n+        } else {\n+            return false;\n+        }\n+    }\n+\n+    public void updateRemoteExecutionStatus(@Nullable String service, @Nullable String status) {\n+        if (RemoteService.CHARGING_CONTROL.toString().equals(service)\n+                && ExecutionState.EXECUTED.name().equals(status)) {\n+            saveChargeProfileSent();\n+        }\n+        updateChannel(CHANNEL_GROUP_REMOTE, REMOTE_STATE, StringType.valueOf(Converter.toTitleCase(\n+                new StringBuilder(service == null ? \"-\" : service).append(\" \").append(status).toString())));\n+    }\n+\n+    public Optional<VehicleConfiguration> getConfiguration() {\n+        return configuration;\n+    }\n+\n+    public ScheduledExecutorService getScheduler() {\n+        return scheduler;\n+    }\n+\n+    /**\n+     * Callbacks for ConnectedDrive Portal\n+     *\n+     * @author Bernd Weymann\n+     *\n+     */\n+    @NonNullByDefault({})\n+    public class ChargeProfilesCallback implements StringResponseCallback {\n+        @Override\n+        public void onResponse(@Nullable String content) {\n+            if (content != null) {\n+                chargeProfileCache = Optional.of(content);\n+                if (chargeProfileEdit.isEmpty()) {\n+                    updateChargeProfileFromContent(content);\n+                }\n+            }\n+            removeCallback(this);\n+        }\n+\n+        /**\n+         * Store Error Report in cache variable. Via Fingerprint Channel error is logged and Issue can be raised\n+         */\n+        @Override\n+        public void onError(NetworkError error) {\n+            logger.debug(\"{}\", error.toString());\n+            chargeProfileCache = Optional.of(Converter.getGson().toJson(error));\n+            removeCallback(this);\n+        }\n+    }\n+\n+    @NonNullByDefault({})\n+    public class RangeMapCallback implements StringResponseCallback {\n+        @Override\n+        public void onResponse(@Nullable String content) {\n+            rangeMapCache = Optional.ofNullable(content);\n+            removeCallback(this);\n+        }\n+\n+        /**\n+         * Store Error Report in cache variable. Via Fingerprint Channel error is logged and Issue can be raised\n+         */\n+        @Override\n+        public void onError(NetworkError error) {\n+            logger.debug(\"{}\", error.toString());\n+            rangeMapCache = Optional.of(Converter.getGson().toJson(error));\n+            removeCallback(this);\n+        }\n+    }\n+\n+    @NonNullByDefault({})\n+    public class DestinationsCallback implements StringResponseCallback {\n+\n+        @Override\n+        public void onResponse(@Nullable String content) {\n+            destinationCache = Optional.ofNullable(content);\n+            if (content != null) {\n+                try {\n+                    DestinationContainer dc = Converter.getGson().fromJson(content, DestinationContainer.class);\n+                    if (dc != null && dc.destinations != null) {\n+                        updateDestinations(dc.destinations);\n+                    }\n+                } catch (JsonSyntaxException jse) {\n+                    logger.debug(\"{}\", jse.getMessage());\n+                }\n+            }\n+            removeCallback(this);\n+        }\n+\n+        /**\n+         * Store Error Report in cache variable. Via Fingerprint Channel error is logged and Issue can be raised\n+         */\n+        @Override\n+        public void onError(NetworkError error) {\n+            logger.debug(\"{}\", error.toString());\n+            destinationCache = Optional.of(Converter.getGson().toJson(error));\n+            removeCallback(this);\n+        }\n+    }\n+\n+    @NonNullByDefault({})\n+    public class ImageCallback implements ByteResponseCallback {\n+        @Override\n+        public void onResponse(byte[] content) {\n+            if (content.length > 0) {\n+                imageCache = Optional.of(content);\n+                String contentType = HttpUtil.guessContentTypeFromData(content);\n+                updateChannel(CHANNEL_GROUP_VEHICLE_IMAGE, IMAGE_FORMAT, new RawType(content, contentType));\n+            } else {\n+                synchronized (imageProperties) {\n+                    imageProperties.failed();\n+                }\n+            }\n+            removeCallback(this);\n+        }\n+\n+        /**\n+         * Store Error Report in cache variable. Via Fingerprint Channel error is logged and Issue can be raised\n+         */\n+        @Override\n+        public void onError(NetworkError error) {\n+            logger.debug(\"{}\", error.toString());\n+            synchronized (imageProperties) {\n+                imageProperties.failed();\n+            }\n+            removeCallback(this);\n+        }\n+    }\n+\n+    @NonNullByDefault({})\n+    public class AllTripsCallback implements StringResponseCallback {\n+        @Override\n+        public void onResponse(@Nullable String content) {\n+            if (content != null) {\n+                allTripsCache = Optional.of(content);\n+                try {\n+                    AllTripsContainer atc = Converter.getGson().fromJson(content, AllTripsContainer.class);\n+                    if (atc != null) {\n+                        AllTrips at = atc.allTrips;\n+                        if (at != null) {\n+                            updateAllTrips(at);\n+                        }\n+                    }\n+                } catch (JsonSyntaxException jse) {\n+                    logger.debug(\"{}\", jse.getMessage());\n+                }\n+            }\n+            removeCallback(this);\n+        }\n+\n+        /**\n+         * Store Error Report in cache variable. Via Fingerprint Channel error is logged and Issue can be raised\n+         */\n+        @Override\n+        public void onError(NetworkError error) {\n+            logger.debug(\"{}\", error.toString());\n+            allTripsCache = Optional.of(Converter.getGson().toJson(error));\n+            removeCallback(this);\n+        }\n+    }\n+\n+    @NonNullByDefault({})\n+    public class LastTripCallback implements StringResponseCallback {\n+        @Override\n+        public void onResponse(@Nullable String content) {\n+            if (content != null) {\n+                lastTripCache = Optional.of(content);\n+                try {\n+                    LastTripContainer lt = Converter.getGson().fromJson(content, LastTripContainer.class);\n+                    if (lt != null) {\n+                        LastTrip trip = lt.lastTrip;\n+                        if (trip != null) {\n+                            updateLastTrip(trip);\n+                        }\n+                    }\n+                } catch (JsonSyntaxException jse) {\n+                    logger.debug(\"{}\", jse.getMessage());\n+                }\n+            }\n+            removeCallback(this);\n+        }\n+\n+        /**\n+         * Store Error Report in cache variable. Via Fingerprint Channel error is logged and Issue can be raised\n+         */\n+        @Override\n+        public void onError(NetworkError error) {\n+            logger.debug(\"{}\", error.toString());\n+            lastTripCache = Optional.of(Converter.getGson().toJson(error));\n+            removeCallback(this);\n+        }\n+    }\n+\n+    /**\n+     * The VehicleStatus is supported by all Vehicle Types so it's used to reflect the Thing Status\n+     */\n+    @NonNullByDefault({})\n+    public class VehicleStatusCallback implements StringResponseCallback {\n+        private ThingStatus thingStatus = ThingStatus.UNKNOWN;\n+\n+        /**\n+         * Vehicle Status is supported by all Vehicles so callback result is used to report Thing Status.\n+         * If valid content is delivered in onResponse Thing goes online while onError Thing goes offline\n+         *\n+         * @param status\n+         * @param detail\n+         * @param reason\n+         */\n+        private void setThingStatus(ThingStatus status, ThingStatusDetail detail, String reason) {\n+            if (thingStatus != status) {\n+                updateStatus(status, detail, reason);\n+            }\n+        }\n+\n+        @Override\n+        public void onResponse(@Nullable String content) {\n+            if (content != null) {\n+                setThingStatus(ThingStatus.ONLINE, ThingStatusDetail.NONE, Constants.EMPTY);\n+                vehicleStatusCache = Optional.of(content);\n+                try {\n+                    VehicleStatusContainer status = Converter.getGson().fromJson(content, VehicleStatusContainer.class);\n+                    if (status != null) {\n+                        VehicleStatus vStatus = status.vehicleStatus;\n+                        if (vStatus == null) {\n+                            return;\n+                        }\n+                        updateVehicleStatus(vStatus);\n+                        updateCheckControls(vStatus.checkControlMessages);\n+                        updateServices(vStatus.cbsData);\n+                        updatePosition(vStatus.position);\n+                    }\n+                } catch (JsonSyntaxException jse) {\n+                    logger.debug(\"{}\", jse.getMessage());\n+                }\n+            }\n+            removeCallback(this);\n+        }\n+\n+        @Override\n+        public void onError(NetworkError error) {\n+            logger.debug(\"{}\", error.toString());\n+            if (error.status == 404) {\n+                legacyMode = true;\n+                logger.debug(\"VehicleStatus not found - switch to legacy API\");\n+                proxy.get().requestLegacyVehcileStatus(configuration.get(), oldVehicleStatusCallback);\n+            }\n+            vehicleStatusCache = Optional.of(Converter.getGson().toJson(error));\n+            setThingStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, error.reason);\n+            removeCallback(this);\n+        }\n+    }\n+\n+    /**\n+     * Fallback API if origin isn't supported.\n+     * This comes from the Community Discussion where a Vehicle from 2015 answered with \"404\"\n+     * https://community.openhab.org/t/bmw-connecteddrive-binding/105124\n+     *\n+     * Selection of API was discussed here\n+     * https://community.openhab.org/t/bmw-connecteddrive-bmw-i3/103876\n+     *\n+     * I figured out that only one API was working for this Vehicle. So this backward compatible Callback is introduced.\n+     * The delivered data is converted into the origin dto object so no changes in previous functional code needed\n+     */\n+    @NonNullByDefault({})\n+    public class LegacyVehicleStatusCallback implements StringResponseCallback {\n+        @Override\n+        public void onResponse(@Nullable String content) {\n+            if (content != null) {\n+                try {\n+                    VehicleAttributesContainer vac = Converter.getGson().fromJson(content,\n+                            VehicleAttributesContainer.class);\n+                    if (vac != null) {\n+                        vehicleStatusCallback.onResponse(vac.transform());\n+                    }\n+                } catch (JsonSyntaxException jse) {\n+                    logger.debug(\"{}\", jse.getMessage());\n+                }\n+            }\n+        }\n+\n+        @Override\n+        public void onError(NetworkError error) {\n+            vehicleStatusCallback.onError(error);\n+        }\n+    }\n+\n+    private void handleChargeProfileCommand(ChannelUID channelUID, Command command) {\n+        if (chargeProfileEdit.isEmpty()) {\n+            chargeProfileEdit = getChargeProfileWrapper();\n+        }\n+\n+        chargeProfileEdit.ifPresent(profile -> {\n+\n+            boolean processed = false;\n+\n+            final String id = channelUID.getIdWithoutGroup();\n+\n+            if (command instanceof StringType) {\n+                final String stringCommand = ((StringType) command).toFullString();\n+                switch (id) {\n+                    case CHARGE_PROFILE_PREFERENCE:\n+                        profile.setPreference(stringCommand);\n+                        updateChannel(CHANNEL_GROUP_CHARGE, CHARGE_PROFILE_PREFERENCE,\n+                                StringType.valueOf(Converter.toTitleCase(profile.getPreference())));\n+                        processed = true;\n+                        break;\n+                    case CHARGE_PROFILE_MODE:\n+                        profile.setMode(stringCommand);\n+                        updateChannel(CHANNEL_GROUP_CHARGE, CHARGE_PROFILE_MODE,\n+                                StringType.valueOf(Converter.toTitleCase(profile.getMode())));\n+                        processed = true;\n+                        break;\n+                    default:\n+                        break;\n+                }\n+            } else if (command instanceof OnOffType) {\n+                final ProfileKey enableKey = ChargeProfileUtils.getEnableKey(id);\n+                if (enableKey != null) {\n+                    profile.setEnabled(enableKey, OnOffType.ON.equals(command));\n+                    updateTimedState(profile, enableKey);\n+                    processed = true;\n+                } else {\n+                    final ChargeKeyDay chargeKeyDay = ChargeProfileUtils.getKeyDay(id);\n+                    if (chargeKeyDay != null) {\n+                        profile.setDayEnabled(chargeKeyDay.key, chargeKeyDay.day, OnOffType.ON.equals(command));\n+                        updateTimedState(profile, chargeKeyDay.key);\n+                        processed = true;\n+                    }\n+                }\n+            } else if (command instanceof DecimalType) {\n+                final ChargeKeyHour keyHour = ChargeProfileUtils.getKeyHour(id);\n+                if (keyHour != null) {\n+                    if (keyHour.isHour) {\n+                        profile.setHour(keyHour.key, ((DecimalType) command).intValue());\n+                    } else {\n+                        profile.setMinute(keyHour.key, ((DecimalType) command).intValue());\n+                    }\n+                    updateTimedState(profile, keyHour.key);\n+                    processed = true;\n+                }\n+            }\n+\n+            if (processed) {\n+                // cancel current timer and add another 5 mins - valid for each edit\n+                editTimeout.ifPresent(timeout -> timeout.cancel(true));\n+                // start edit timer with 5 min timeout\n+                editTimeout = Optional.of(scheduler.schedule(() -> {\n+                    editTimeout = Optional.empty();\n+                    chargeProfileEdit = Optional.empty();\n+                    chargeProfileCache.ifPresent(content -> updateChargeProfileFromContent(content));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "48af48c82562d006b6f2aa35922270f181c885ed"}, "originalPosition": 777}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5ODMwMDAwOQ==", "bodyText": "fixed in weymann#11", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r598300009", "createdAt": "2021-03-21T15:55:50Z", "author": {"login": "ntruchsess"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/VehicleHandler.java", "diffHunk": "@@ -0,0 +1,826 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bmwconnecteddrive.internal.handler;\n+\n+import static org.openhab.binding.bmwconnecteddrive.internal.ConnectedDriveConstants.*;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.bmwconnecteddrive.internal.VehicleConfiguration;\n+import org.openhab.binding.bmwconnecteddrive.internal.action.ChargeProfileActions;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.DestinationContainer;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.NetworkError;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.compat.VehicleAttributesContainer;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.statistics.AllTrips;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.statistics.AllTripsContainer;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.statistics.LastTrip;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.statistics.LastTripContainer;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.status.VehicleStatus;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.status.VehicleStatusContainer;\n+import org.openhab.binding.bmwconnecteddrive.internal.handler.RemoteServiceHandler.ExecutionState;\n+import org.openhab.binding.bmwconnecteddrive.internal.handler.RemoteServiceHandler.RemoteService;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileUtils;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileUtils.ChargeKeyDay;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileUtils.ChargeKeyHour;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileWrapper;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileWrapper.ProfileKey;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Constants;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Converter;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ImageProperties;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.RemoteServiceUtils;\n+import org.openhab.core.io.net.http.HttpUtil;\n+import org.openhab.core.library.types.DecimalType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.RawType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BridgeHandler;\n+import org.openhab.core.thing.binding.ThingHandlerService;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+\n+import com.google.gson.JsonSyntaxException;\n+\n+/**\n+ * The {@link VehicleHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Bernd Weymann - Initial contribution\n+ * @author Norbert Truchsess - edit & send charge profile\n+ */\n+@NonNullByDefault\n+public class VehicleHandler extends VehicleChannelHandler {\n+    private boolean legacyMode = false; // switch to legacy API in case of 404 Errors\n+\n+    private Optional<ConnectedDriveProxy> proxy = Optional.empty();\n+    private Optional<RemoteServiceHandler> remote = Optional.empty();\n+    private Optional<VehicleConfiguration> configuration = Optional.empty();\n+    private Optional<ConnectedDriveBridgeHandler> bridgeHandler = Optional.empty();\n+    private Optional<ScheduledFuture<?>> refreshJob = Optional.empty();\n+    private Optional<ScheduledFuture<?>> editTimeout = Optional.empty();\n+    private Optional<List<ResponseCallback>> callbackCounter = Optional.empty();\n+\n+    private ImageProperties imageProperties = new ImageProperties();\n+    VehicleStatusCallback vehicleStatusCallback = new VehicleStatusCallback();\n+    StringResponseCallback oldVehicleStatusCallback = new LegacyVehicleStatusCallback();\n+    StringResponseCallback lastTripCallback = new LastTripCallback();\n+    StringResponseCallback allTripsCallback = new AllTripsCallback();\n+    StringResponseCallback chargeProfileCallback = new ChargeProfilesCallback();\n+    StringResponseCallback rangeMapCallback = new RangeMapCallback();\n+    DestinationsCallback destinationCallback = new DestinationsCallback();\n+    ByteResponseCallback imageCallback = new ImageCallback();\n+\n+    private Optional<ChargeProfileWrapper> chargeProfileEdit = Optional.empty();\n+    private Optional<String> chargeProfileSent = Optional.empty();\n+\n+    public VehicleHandler(Thing thing, BMWConnectedDriveOptionProvider op, String type, boolean imperial) {\n+        super(thing, op, type, imperial);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        String group = channelUID.getGroupId();\n+\n+        // Refresh of Channels with cached values\n+        if (command instanceof RefreshType) {\n+            if (CHANNEL_GROUP_LAST_TRIP.equals(group)) {\n+                lastTripCache.ifPresent(lastTrip -> lastTripCallback.onResponse(lastTrip));\n+            } else if (CHANNEL_GROUP_LIFETIME.equals(group)) {\n+                allTripsCache.ifPresent(allTrips -> allTripsCallback.onResponse(allTrips));\n+            } else if (CHANNEL_GROUP_DESTINATION.equals(group)) {\n+                destinationCache.ifPresent(destination -> destinationCallback.onResponse(destination));\n+            } else if (CHANNEL_GROUP_STATUS.equals(group)) {\n+                vehicleStatusCache.ifPresent(vehicleStatus -> vehicleStatusCallback.onResponse(vehicleStatus));\n+            } else if (CHANNEL_GROUP_CHARGE.equals(group)) {\n+                chargeProfileEdit.ifPresentOrElse(this::updateChargeProfile,\n+                        () -> chargeProfileCache.ifPresent(this::updateChargeProfileFromContent));\n+            } else if (CHANNEL_GROUP_VEHICLE_IMAGE.equals(group)) {\n+                imageCache.ifPresent(image -> imageCallback.onResponse(image));\n+            }\n+            // Check for Channel Group and corresponding Actions\n+        } else if (CHANNEL_GROUP_REMOTE.equals(group)) {\n+            // Executing Remote Services\n+            if (command instanceof StringType) {\n+                String serviceCommand = ((StringType) command).toFullString();\n+                remote.ifPresent(remot -> {\n+                    switch (serviceCommand) {\n+                        case REMOTE_SERVICE_LIGHT_FLASH:\n+                        case REMOTE_SERVICE_AIR_CONDITIONING:\n+                        case REMOTE_SERVICE_DOOR_LOCK:\n+                        case REMOTE_SERVICE_DOOR_UNLOCK:\n+                        case REMOTE_SERVICE_HORN:\n+                        case REMOTE_SERVICE_VEHICLE_FINDER:\n+                        case REMOTE_SERVICE_CHARGE_NOW:\n+                            RemoteServiceUtils.getRemoteService(serviceCommand)\n+                                    .ifPresentOrElse(service -> remot.execute(service), () -> {\n+                                        logger.info(\"Remote service execution {} unknown\", serviceCommand);\n+                                    });\n+                            break;\n+                        case REMOTE_SERVICE_CHARGING_CONTROL:\n+                            sendChargeProfile(chargeProfileEdit);\n+                            break;\n+                        default:\n+                            logger.info(\"Remote service execution {} unknown\", serviceCommand);\n+                            break;\n+                    }\n+                });\n+            }\n+        } else if (CHANNEL_GROUP_VEHICLE_IMAGE.equals(group)) {\n+            // Image Change\n+            configuration.ifPresent(config -> {\n+                if (command instanceof StringType) {\n+                    if (channelUID.getIdWithoutGroup().equals(IMAGE_VIEWPORT)) {\n+                        String newViewport = command.toString();\n+                        synchronized (imageProperties) {\n+                            if (!imageProperties.viewport.equals(newViewport)) {\n+                                imageProperties = new ImageProperties(newViewport, imageProperties.size);\n+                                imageCache = Optional.empty();\n+                                proxy.ifPresent(prox -> prox.requestImage(config, imageProperties, imageCallback));\n+                            }\n+                        }\n+                        updateChannel(CHANNEL_GROUP_VEHICLE_IMAGE, IMAGE_VIEWPORT, StringType.valueOf(newViewport));\n+                    }\n+                }\n+                if (command instanceof DecimalType) {\n+                    if (command instanceof DecimalType) {\n+                        int newImageSize = ((DecimalType) command).intValue();\n+                        if (channelUID.getIdWithoutGroup().equals(IMAGE_SIZE)) {\n+                            synchronized (imageProperties) {\n+                                if (imageProperties.size != newImageSize) {\n+                                    imageProperties = new ImageProperties(imageProperties.viewport, newImageSize);\n+                                    imageCache = Optional.empty();\n+                                    proxy.ifPresent(prox -> prox.requestImage(config, imageProperties, imageCallback));\n+                                }\n+                            }\n+                        }\n+                        updateChannel(CHANNEL_GROUP_VEHICLE_IMAGE, IMAGE_SIZE, new DecimalType(newImageSize));\n+                    }\n+                }\n+            });\n+        } else if (CHANNEL_GROUP_DESTINATION.equals(group)) {\n+            if (command instanceof StringType) {\n+                int index = Converter.getIndex(command.toFullString());\n+                if (index != -1) {\n+                    selectDestination(index);\n+                } else {\n+                    logger.debug(\"Cannot select Destination index {}\", command.toFullString());\n+                }\n+            }\n+        } else if (CHANNEL_GROUP_SERVICE.equals(group)) {\n+            if (command instanceof StringType) {\n+                int index = Converter.getIndex(command.toFullString());\n+                if (index != -1) {\n+                    selectService(index);\n+                } else {\n+                    logger.debug(\"Cannot select Service index {}\", command.toFullString());\n+                }\n+            }\n+        } else if (CHANNEL_GROUP_CHECK_CONTROL.equals(group)) {\n+            if (command instanceof StringType) {\n+                int index = Converter.getIndex(command.toFullString());\n+                if (index != -1) {\n+                    selectCheckControl(index);\n+                } else {\n+                    logger.debug(\"Cannot select CheckControl index {}\", command.toFullString());\n+                }\n+            }\n+        } else if (CHANNEL_GROUP_CHARGE.equals(group)) {\n+            handleChargeProfileCommand(channelUID, command);\n+        }\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        callbackCounter = Optional.of(new ArrayList<ResponseCallback>());\n+        updateStatus(ThingStatus.UNKNOWN);\n+        final VehicleConfiguration config = getConfigAs(VehicleConfiguration.class);\n+        if (config != null) {\n+            configuration = Optional.of(config);\n+            scheduler.execute(() -> {\n+                Bridge bridge = getBridge();\n+                if (bridge != null) {\n+                    BridgeHandler handler = bridge.getHandler();\n+                    if (handler != null) {\n+                        bridgeHandler = Optional.of(((ConnectedDriveBridgeHandler) handler));\n+                        proxy = ((ConnectedDriveBridgeHandler) handler).getProxy();\n+                        remote = proxy.map(prox -> prox.getRemoteServiceHandler(this));\n+                    } else {\n+                        logger.debug(\"Bridge Handler null\");\n+                    }\n+                } else {\n+                    logger.debug(\"Bridge null\");\n+                }\n+\n+                // get Image after init with config values\n+                synchronized (imageProperties) {\n+                    imageProperties = new ImageProperties(config.imageViewport, config.imageSize);\n+                }\n+                updateChannel(CHANNEL_GROUP_VEHICLE_IMAGE, IMAGE_VIEWPORT, StringType.valueOf((config.imageViewport)));\n+                updateChannel(CHANNEL_GROUP_VEHICLE_IMAGE, IMAGE_SIZE, new DecimalType((config.imageSize)));\n+\n+                // check imperial setting is different to AutoDetect\n+                if (!UNITS_AUTODETECT.equals(config.units)) {\n+                    imperial = UNITS_IMPERIAL.equals(config.units);\n+                }\n+\n+                // start update schedule\n+                startSchedule(config.refreshInterval);\n+            });\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR);\n+        }\n+    }\n+\n+    private void startSchedule(int interval) {\n+        refreshJob.ifPresentOrElse(job -> {\n+            if (job.isCancelled()) {\n+                refreshJob = Optional\n+                        .of(scheduler.scheduleWithFixedDelay(this::getData, 0, interval, TimeUnit.MINUTES));\n+            } // else - scheduler is already running!\n+        }, () -> {\n+            refreshJob = Optional.of(scheduler.scheduleWithFixedDelay(this::getData, 0, interval, TimeUnit.MINUTES));\n+        });\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        refreshJob.ifPresent(job -> job.cancel(true));\n+    }\n+\n+    public void getData() {\n+        proxy.ifPresentOrElse(prox -> {\n+            configuration.ifPresentOrElse(config -> {\n+                if (!legacyMode) {\n+                    prox.requestVehcileStatus(config, vehicleStatusCallback);\n+                } else {\n+                    prox.requestLegacyVehcileStatus(config, oldVehicleStatusCallback);\n+                }\n+                addCallback(vehicleStatusCallback);\n+                if (isSupported(Constants.STATISTICS)) {\n+                    prox.requestLastTrip(config, lastTripCallback);\n+                    prox.requestAllTrips(config, allTripsCallback);\n+                    addCallback(lastTripCallback);\n+                    addCallback(allTripsCallback);\n+                }\n+                if (isSupported(Constants.LAST_DESTINATIONS)) {\n+                    prox.requestDestinations(config, destinationCallback);\n+                    addCallback(destinationCallback);\n+                }\n+                if (isElectric) {\n+                    prox.requestChargingProfile(config, chargeProfileCallback);\n+                    addCallback(chargeProfileCallback);\n+                }\n+                synchronized (imageProperties) {\n+                    if (!imageCache.isPresent() && !imageProperties.failLimitReached()) {\n+                        prox.requestImage(config, imageProperties, imageCallback);\n+                        addCallback(imageCallback);\n+                    }\n+                }\n+            }, () -> {\n+                logger.warn(\"ConnectedDrive Configuration isn't present\");\n+            });\n+        }, () -> {\n+            logger.warn(\"ConnectedDrive Proxy isn't present\");\n+        });\n+    }\n+\n+    private synchronized void addCallback(ResponseCallback rc) {\n+        callbackCounter.ifPresent(counter -> counter.add(rc));\n+    }\n+\n+    private synchronized void removeCallback(ResponseCallback rc) {\n+        callbackCounter.ifPresent(counter -> {\n+            counter.remove(rc);\n+            // all necessary callbacks received => print and set to empty\n+            if (counter.isEmpty()) {\n+                logFingerPrint();\n+                callbackCounter = Optional.empty();\n+            }\n+        });\n+    }\n+\n+    private void logFingerPrint() {\n+        final String vin = configuration.map(config -> config.vin).orElse(\"\");\n+        logger.debug(\"###### BMW ConnectedDrive Binding - Vehicle Troubleshoot Fingerprint Data - BEGIN ######\");\n+        logger.debug(\"### Discovery Result ###\");\n+        bridgeHandler.ifPresent(handler -> {\n+            logger.debug(\"{}\", handler.getDiscoveryFingerprint());\n+        });\n+        vehicleStatusCache.ifPresentOrElse(vehicleStatus -> {\n+            logger.debug(\"### Vehicle Status ###\");\n+\n+            // Anonymous data for VIN and Position\n+            try {\n+                VehicleStatusContainer container = Converter.getGson().fromJson(vehicleStatus,\n+                        VehicleStatusContainer.class);\n+                if (container != null) {\n+                    VehicleStatus status = container.vehicleStatus;\n+                    if (status != null) {\n+                        status.vin = Constants.ANONYMOUS;\n+                        if (status.position != null) {\n+                            status.position.lat = -1;\n+                            status.position.lon = -1;\n+                            status.position.heading = -1;\n+                        }\n+                    }\n+                }\n+                logger.debug(\"{}\", Converter.getGson().toJson(container));\n+            } catch (JsonSyntaxException jse) {\n+                logger.debug(\"{}\", jse.getMessage());\n+            }\n+        }, () -> {\n+            logger.debug(\"### Vehicle Status Empty ###\");\n+        });\n+        lastTripCache.ifPresentOrElse(lastTrip -> {\n+            logger.debug(\"### Last Trip ###\");\n+            logger.debug(\"{}\", lastTrip.replaceAll(vin, Constants.ANONYMOUS));\n+        }, () -> {\n+            logger.debug(\"### Last Trip Empty ###\");\n+        });\n+        allTripsCache.ifPresentOrElse(allTrips -> {\n+            logger.debug(\"### All Trips ###\");\n+            logger.debug(\"{}\", allTrips.replaceAll(vin, Constants.ANONYMOUS));\n+        }, () -> {\n+            logger.debug(\"### All Trips Empty ###\");\n+        });\n+        if (isElectric) {\n+            chargeProfileCache.ifPresentOrElse(chargeProfile -> {\n+                logger.debug(\"### Charge Profile ###\");\n+                logger.debug(\"{}\", chargeProfile.replaceAll(vin, Constants.ANONYMOUS));\n+            }, () -> {\n+                logger.debug(\"### Charge Profile Empty ###\");\n+            });\n+        }\n+        destinationCache.ifPresentOrElse(destination -> {\n+            logger.debug(\"### Charge Profile ###\");\n+            try {\n+                DestinationContainer container = Converter.getGson().fromJson(destination, DestinationContainer.class);\n+                if (container != null) {\n+                    if (container.destinations != null) {\n+                        container.destinations.forEach(entry -> {\n+                            entry.lat = 0;\n+                            entry.lon = 0;\n+                            entry.city = Constants.ANONYMOUS;\n+                            entry.street = Constants.ANONYMOUS;\n+                            entry.streetNumber = Constants.ANONYMOUS;\n+                            entry.country = Constants.ANONYMOUS;\n+                        });\n+                        logger.debug(\"{}\", Converter.getGson().toJson(container));\n+                    }\n+                } else {\n+                    logger.debug(\"### Destinations Empty ###\");\n+                }\n+            } catch (JsonSyntaxException jse) {\n+                logger.debug(\"{}\", jse.getMessage());\n+            }\n+        }, () -> {\n+            logger.debug(\"### Charge Profile Empty ###\");\n+        });\n+        rangeMapCache.ifPresentOrElse(rangeMap -> {\n+            logger.debug(\"### Range Map ###\");\n+            logger.debug(\"{}\", rangeMap.replaceAll(vin, Constants.ANONYMOUS));\n+        }, () -> {\n+            logger.debug(\"### Range Map Empty ###\");\n+        });\n+        logger.debug(\"###### BMW ConnectedDrive Binding - Vehicle Troubleshoot Fingerprint Data - END ######\");\n+    }\n+\n+    /**\n+     * Don't stress ConnectedDrive with unnecessary requests. One call at the beginning is done to check the response.\n+     * After cache has e.g. a proper error response it will be shown in the fingerprint\n+     *\n+     * @return\n+     */\n+    private boolean isSupported(String service) {\n+        final String services = thing.getProperties().get(Constants.SERVICES_SUPPORTED);\n+        if (services != null) {\n+            if (services.contains(service)) {\n+                return true;\n+            }\n+        }\n+        // if cache is empty give it a try one time to collected Troubleshoot data\n+        if (lastTripCache.isEmpty() || allTripsCache.isEmpty() || destinationCache.isEmpty()) {\n+            return true;\n+        } else {\n+            return false;\n+        }\n+    }\n+\n+    public void updateRemoteExecutionStatus(@Nullable String service, @Nullable String status) {\n+        if (RemoteService.CHARGING_CONTROL.toString().equals(service)\n+                && ExecutionState.EXECUTED.name().equals(status)) {\n+            saveChargeProfileSent();\n+        }\n+        updateChannel(CHANNEL_GROUP_REMOTE, REMOTE_STATE, StringType.valueOf(Converter.toTitleCase(\n+                new StringBuilder(service == null ? \"-\" : service).append(\" \").append(status).toString())));\n+    }\n+\n+    public Optional<VehicleConfiguration> getConfiguration() {\n+        return configuration;\n+    }\n+\n+    public ScheduledExecutorService getScheduler() {\n+        return scheduler;\n+    }\n+\n+    /**\n+     * Callbacks for ConnectedDrive Portal\n+     *\n+     * @author Bernd Weymann\n+     *\n+     */\n+    @NonNullByDefault({})\n+    public class ChargeProfilesCallback implements StringResponseCallback {\n+        @Override\n+        public void onResponse(@Nullable String content) {\n+            if (content != null) {\n+                chargeProfileCache = Optional.of(content);\n+                if (chargeProfileEdit.isEmpty()) {\n+                    updateChargeProfileFromContent(content);\n+                }\n+            }\n+            removeCallback(this);\n+        }\n+\n+        /**\n+         * Store Error Report in cache variable. Via Fingerprint Channel error is logged and Issue can be raised\n+         */\n+        @Override\n+        public void onError(NetworkError error) {\n+            logger.debug(\"{}\", error.toString());\n+            chargeProfileCache = Optional.of(Converter.getGson().toJson(error));\n+            removeCallback(this);\n+        }\n+    }\n+\n+    @NonNullByDefault({})\n+    public class RangeMapCallback implements StringResponseCallback {\n+        @Override\n+        public void onResponse(@Nullable String content) {\n+            rangeMapCache = Optional.ofNullable(content);\n+            removeCallback(this);\n+        }\n+\n+        /**\n+         * Store Error Report in cache variable. Via Fingerprint Channel error is logged and Issue can be raised\n+         */\n+        @Override\n+        public void onError(NetworkError error) {\n+            logger.debug(\"{}\", error.toString());\n+            rangeMapCache = Optional.of(Converter.getGson().toJson(error));\n+            removeCallback(this);\n+        }\n+    }\n+\n+    @NonNullByDefault({})\n+    public class DestinationsCallback implements StringResponseCallback {\n+\n+        @Override\n+        public void onResponse(@Nullable String content) {\n+            destinationCache = Optional.ofNullable(content);\n+            if (content != null) {\n+                try {\n+                    DestinationContainer dc = Converter.getGson().fromJson(content, DestinationContainer.class);\n+                    if (dc != null && dc.destinations != null) {\n+                        updateDestinations(dc.destinations);\n+                    }\n+                } catch (JsonSyntaxException jse) {\n+                    logger.debug(\"{}\", jse.getMessage());\n+                }\n+            }\n+            removeCallback(this);\n+        }\n+\n+        /**\n+         * Store Error Report in cache variable. Via Fingerprint Channel error is logged and Issue can be raised\n+         */\n+        @Override\n+        public void onError(NetworkError error) {\n+            logger.debug(\"{}\", error.toString());\n+            destinationCache = Optional.of(Converter.getGson().toJson(error));\n+            removeCallback(this);\n+        }\n+    }\n+\n+    @NonNullByDefault({})\n+    public class ImageCallback implements ByteResponseCallback {\n+        @Override\n+        public void onResponse(byte[] content) {\n+            if (content.length > 0) {\n+                imageCache = Optional.of(content);\n+                String contentType = HttpUtil.guessContentTypeFromData(content);\n+                updateChannel(CHANNEL_GROUP_VEHICLE_IMAGE, IMAGE_FORMAT, new RawType(content, contentType));\n+            } else {\n+                synchronized (imageProperties) {\n+                    imageProperties.failed();\n+                }\n+            }\n+            removeCallback(this);\n+        }\n+\n+        /**\n+         * Store Error Report in cache variable. Via Fingerprint Channel error is logged and Issue can be raised\n+         */\n+        @Override\n+        public void onError(NetworkError error) {\n+            logger.debug(\"{}\", error.toString());\n+            synchronized (imageProperties) {\n+                imageProperties.failed();\n+            }\n+            removeCallback(this);\n+        }\n+    }\n+\n+    @NonNullByDefault({})\n+    public class AllTripsCallback implements StringResponseCallback {\n+        @Override\n+        public void onResponse(@Nullable String content) {\n+            if (content != null) {\n+                allTripsCache = Optional.of(content);\n+                try {\n+                    AllTripsContainer atc = Converter.getGson().fromJson(content, AllTripsContainer.class);\n+                    if (atc != null) {\n+                        AllTrips at = atc.allTrips;\n+                        if (at != null) {\n+                            updateAllTrips(at);\n+                        }\n+                    }\n+                } catch (JsonSyntaxException jse) {\n+                    logger.debug(\"{}\", jse.getMessage());\n+                }\n+            }\n+            removeCallback(this);\n+        }\n+\n+        /**\n+         * Store Error Report in cache variable. Via Fingerprint Channel error is logged and Issue can be raised\n+         */\n+        @Override\n+        public void onError(NetworkError error) {\n+            logger.debug(\"{}\", error.toString());\n+            allTripsCache = Optional.of(Converter.getGson().toJson(error));\n+            removeCallback(this);\n+        }\n+    }\n+\n+    @NonNullByDefault({})\n+    public class LastTripCallback implements StringResponseCallback {\n+        @Override\n+        public void onResponse(@Nullable String content) {\n+            if (content != null) {\n+                lastTripCache = Optional.of(content);\n+                try {\n+                    LastTripContainer lt = Converter.getGson().fromJson(content, LastTripContainer.class);\n+                    if (lt != null) {\n+                        LastTrip trip = lt.lastTrip;\n+                        if (trip != null) {\n+                            updateLastTrip(trip);\n+                        }\n+                    }\n+                } catch (JsonSyntaxException jse) {\n+                    logger.debug(\"{}\", jse.getMessage());\n+                }\n+            }\n+            removeCallback(this);\n+        }\n+\n+        /**\n+         * Store Error Report in cache variable. Via Fingerprint Channel error is logged and Issue can be raised\n+         */\n+        @Override\n+        public void onError(NetworkError error) {\n+            logger.debug(\"{}\", error.toString());\n+            lastTripCache = Optional.of(Converter.getGson().toJson(error));\n+            removeCallback(this);\n+        }\n+    }\n+\n+    /**\n+     * The VehicleStatus is supported by all Vehicle Types so it's used to reflect the Thing Status\n+     */\n+    @NonNullByDefault({})\n+    public class VehicleStatusCallback implements StringResponseCallback {\n+        private ThingStatus thingStatus = ThingStatus.UNKNOWN;\n+\n+        /**\n+         * Vehicle Status is supported by all Vehicles so callback result is used to report Thing Status.\n+         * If valid content is delivered in onResponse Thing goes online while onError Thing goes offline\n+         *\n+         * @param status\n+         * @param detail\n+         * @param reason\n+         */\n+        private void setThingStatus(ThingStatus status, ThingStatusDetail detail, String reason) {\n+            if (thingStatus != status) {\n+                updateStatus(status, detail, reason);\n+            }\n+        }\n+\n+        @Override\n+        public void onResponse(@Nullable String content) {\n+            if (content != null) {\n+                setThingStatus(ThingStatus.ONLINE, ThingStatusDetail.NONE, Constants.EMPTY);\n+                vehicleStatusCache = Optional.of(content);\n+                try {\n+                    VehicleStatusContainer status = Converter.getGson().fromJson(content, VehicleStatusContainer.class);\n+                    if (status != null) {\n+                        VehicleStatus vStatus = status.vehicleStatus;\n+                        if (vStatus == null) {\n+                            return;\n+                        }\n+                        updateVehicleStatus(vStatus);\n+                        updateCheckControls(vStatus.checkControlMessages);\n+                        updateServices(vStatus.cbsData);\n+                        updatePosition(vStatus.position);\n+                    }\n+                } catch (JsonSyntaxException jse) {\n+                    logger.debug(\"{}\", jse.getMessage());\n+                }\n+            }\n+            removeCallback(this);\n+        }\n+\n+        @Override\n+        public void onError(NetworkError error) {\n+            logger.debug(\"{}\", error.toString());\n+            if (error.status == 404) {\n+                legacyMode = true;\n+                logger.debug(\"VehicleStatus not found - switch to legacy API\");\n+                proxy.get().requestLegacyVehcileStatus(configuration.get(), oldVehicleStatusCallback);\n+            }\n+            vehicleStatusCache = Optional.of(Converter.getGson().toJson(error));\n+            setThingStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, error.reason);\n+            removeCallback(this);\n+        }\n+    }\n+\n+    /**\n+     * Fallback API if origin isn't supported.\n+     * This comes from the Community Discussion where a Vehicle from 2015 answered with \"404\"\n+     * https://community.openhab.org/t/bmw-connecteddrive-binding/105124\n+     *\n+     * Selection of API was discussed here\n+     * https://community.openhab.org/t/bmw-connecteddrive-bmw-i3/103876\n+     *\n+     * I figured out that only one API was working for this Vehicle. So this backward compatible Callback is introduced.\n+     * The delivered data is converted into the origin dto object so no changes in previous functional code needed\n+     */\n+    @NonNullByDefault({})\n+    public class LegacyVehicleStatusCallback implements StringResponseCallback {\n+        @Override\n+        public void onResponse(@Nullable String content) {\n+            if (content != null) {\n+                try {\n+                    VehicleAttributesContainer vac = Converter.getGson().fromJson(content,\n+                            VehicleAttributesContainer.class);\n+                    if (vac != null) {\n+                        vehicleStatusCallback.onResponse(vac.transform());\n+                    }\n+                } catch (JsonSyntaxException jse) {\n+                    logger.debug(\"{}\", jse.getMessage());\n+                }\n+            }\n+        }\n+\n+        @Override\n+        public void onError(NetworkError error) {\n+            vehicleStatusCallback.onError(error);\n+        }\n+    }\n+\n+    private void handleChargeProfileCommand(ChannelUID channelUID, Command command) {\n+        if (chargeProfileEdit.isEmpty()) {\n+            chargeProfileEdit = getChargeProfileWrapper();\n+        }\n+\n+        chargeProfileEdit.ifPresent(profile -> {\n+\n+            boolean processed = false;\n+\n+            final String id = channelUID.getIdWithoutGroup();\n+\n+            if (command instanceof StringType) {\n+                final String stringCommand = ((StringType) command).toFullString();\n+                switch (id) {\n+                    case CHARGE_PROFILE_PREFERENCE:\n+                        profile.setPreference(stringCommand);\n+                        updateChannel(CHANNEL_GROUP_CHARGE, CHARGE_PROFILE_PREFERENCE,\n+                                StringType.valueOf(Converter.toTitleCase(profile.getPreference())));\n+                        processed = true;\n+                        break;\n+                    case CHARGE_PROFILE_MODE:\n+                        profile.setMode(stringCommand);\n+                        updateChannel(CHANNEL_GROUP_CHARGE, CHARGE_PROFILE_MODE,\n+                                StringType.valueOf(Converter.toTitleCase(profile.getMode())));\n+                        processed = true;\n+                        break;\n+                    default:\n+                        break;\n+                }\n+            } else if (command instanceof OnOffType) {\n+                final ProfileKey enableKey = ChargeProfileUtils.getEnableKey(id);\n+                if (enableKey != null) {\n+                    profile.setEnabled(enableKey, OnOffType.ON.equals(command));\n+                    updateTimedState(profile, enableKey);\n+                    processed = true;\n+                } else {\n+                    final ChargeKeyDay chargeKeyDay = ChargeProfileUtils.getKeyDay(id);\n+                    if (chargeKeyDay != null) {\n+                        profile.setDayEnabled(chargeKeyDay.key, chargeKeyDay.day, OnOffType.ON.equals(command));\n+                        updateTimedState(profile, chargeKeyDay.key);\n+                        processed = true;\n+                    }\n+                }\n+            } else if (command instanceof DecimalType) {\n+                final ChargeKeyHour keyHour = ChargeProfileUtils.getKeyHour(id);\n+                if (keyHour != null) {\n+                    if (keyHour.isHour) {\n+                        profile.setHour(keyHour.key, ((DecimalType) command).intValue());\n+                    } else {\n+                        profile.setMinute(keyHour.key, ((DecimalType) command).intValue());\n+                    }\n+                    updateTimedState(profile, keyHour.key);\n+                    processed = true;\n+                }\n+            }\n+\n+            if (processed) {\n+                // cancel current timer and add another 5 mins - valid for each edit\n+                editTimeout.ifPresent(timeout -> timeout.cancel(true));\n+                // start edit timer with 5 min timeout\n+                editTimeout = Optional.of(scheduler.schedule(() -> {\n+                    editTimeout = Optional.empty();\n+                    chargeProfileEdit = Optional.empty();\n+                    chargeProfileCache.ifPresent(content -> updateChargeProfileFromContent(content));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5NzkyMzM2Nw=="}, "originalCommit": {"oid": "48af48c82562d006b6f2aa35922270f181c885ed"}, "originalPosition": 777}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzc3NjgwODIwOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/VehicleHandler.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0xOVQxOToyMjo0M1rOI6OXPA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0yN1QyMjo1Njo0NFrOI-4HzQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5NzkyMzY0NA==", "bodyText": "Can this message be replaced by using the debugger or by increasing the framework's log level? See point 4 https://www.openhab.org/docs/developer/guidelines.html#f-logging", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r597923644", "createdAt": "2021-03-19T19:22:43Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/VehicleHandler.java", "diffHunk": "@@ -0,0 +1,826 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bmwconnecteddrive.internal.handler;\n+\n+import static org.openhab.binding.bmwconnecteddrive.internal.ConnectedDriveConstants.*;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.bmwconnecteddrive.internal.VehicleConfiguration;\n+import org.openhab.binding.bmwconnecteddrive.internal.action.ChargeProfileActions;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.DestinationContainer;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.NetworkError;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.compat.VehicleAttributesContainer;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.statistics.AllTrips;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.statistics.AllTripsContainer;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.statistics.LastTrip;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.statistics.LastTripContainer;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.status.VehicleStatus;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.status.VehicleStatusContainer;\n+import org.openhab.binding.bmwconnecteddrive.internal.handler.RemoteServiceHandler.ExecutionState;\n+import org.openhab.binding.bmwconnecteddrive.internal.handler.RemoteServiceHandler.RemoteService;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileUtils;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileUtils.ChargeKeyDay;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileUtils.ChargeKeyHour;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileWrapper;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileWrapper.ProfileKey;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Constants;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Converter;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ImageProperties;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.RemoteServiceUtils;\n+import org.openhab.core.io.net.http.HttpUtil;\n+import org.openhab.core.library.types.DecimalType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.RawType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BridgeHandler;\n+import org.openhab.core.thing.binding.ThingHandlerService;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+\n+import com.google.gson.JsonSyntaxException;\n+\n+/**\n+ * The {@link VehicleHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Bernd Weymann - Initial contribution\n+ * @author Norbert Truchsess - edit & send charge profile\n+ */\n+@NonNullByDefault\n+public class VehicleHandler extends VehicleChannelHandler {\n+    private boolean legacyMode = false; // switch to legacy API in case of 404 Errors\n+\n+    private Optional<ConnectedDriveProxy> proxy = Optional.empty();\n+    private Optional<RemoteServiceHandler> remote = Optional.empty();\n+    private Optional<VehicleConfiguration> configuration = Optional.empty();\n+    private Optional<ConnectedDriveBridgeHandler> bridgeHandler = Optional.empty();\n+    private Optional<ScheduledFuture<?>> refreshJob = Optional.empty();\n+    private Optional<ScheduledFuture<?>> editTimeout = Optional.empty();\n+    private Optional<List<ResponseCallback>> callbackCounter = Optional.empty();\n+\n+    private ImageProperties imageProperties = new ImageProperties();\n+    VehicleStatusCallback vehicleStatusCallback = new VehicleStatusCallback();\n+    StringResponseCallback oldVehicleStatusCallback = new LegacyVehicleStatusCallback();\n+    StringResponseCallback lastTripCallback = new LastTripCallback();\n+    StringResponseCallback allTripsCallback = new AllTripsCallback();\n+    StringResponseCallback chargeProfileCallback = new ChargeProfilesCallback();\n+    StringResponseCallback rangeMapCallback = new RangeMapCallback();\n+    DestinationsCallback destinationCallback = new DestinationsCallback();\n+    ByteResponseCallback imageCallback = new ImageCallback();\n+\n+    private Optional<ChargeProfileWrapper> chargeProfileEdit = Optional.empty();\n+    private Optional<String> chargeProfileSent = Optional.empty();\n+\n+    public VehicleHandler(Thing thing, BMWConnectedDriveOptionProvider op, String type, boolean imperial) {\n+        super(thing, op, type, imperial);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        String group = channelUID.getGroupId();\n+\n+        // Refresh of Channels with cached values\n+        if (command instanceof RefreshType) {\n+            if (CHANNEL_GROUP_LAST_TRIP.equals(group)) {\n+                lastTripCache.ifPresent(lastTrip -> lastTripCallback.onResponse(lastTrip));\n+            } else if (CHANNEL_GROUP_LIFETIME.equals(group)) {\n+                allTripsCache.ifPresent(allTrips -> allTripsCallback.onResponse(allTrips));\n+            } else if (CHANNEL_GROUP_DESTINATION.equals(group)) {\n+                destinationCache.ifPresent(destination -> destinationCallback.onResponse(destination));\n+            } else if (CHANNEL_GROUP_STATUS.equals(group)) {\n+                vehicleStatusCache.ifPresent(vehicleStatus -> vehicleStatusCallback.onResponse(vehicleStatus));\n+            } else if (CHANNEL_GROUP_CHARGE.equals(group)) {\n+                chargeProfileEdit.ifPresentOrElse(this::updateChargeProfile,\n+                        () -> chargeProfileCache.ifPresent(this::updateChargeProfileFromContent));\n+            } else if (CHANNEL_GROUP_VEHICLE_IMAGE.equals(group)) {\n+                imageCache.ifPresent(image -> imageCallback.onResponse(image));\n+            }\n+            // Check for Channel Group and corresponding Actions\n+        } else if (CHANNEL_GROUP_REMOTE.equals(group)) {\n+            // Executing Remote Services\n+            if (command instanceof StringType) {\n+                String serviceCommand = ((StringType) command).toFullString();\n+                remote.ifPresent(remot -> {\n+                    switch (serviceCommand) {\n+                        case REMOTE_SERVICE_LIGHT_FLASH:\n+                        case REMOTE_SERVICE_AIR_CONDITIONING:\n+                        case REMOTE_SERVICE_DOOR_LOCK:\n+                        case REMOTE_SERVICE_DOOR_UNLOCK:\n+                        case REMOTE_SERVICE_HORN:\n+                        case REMOTE_SERVICE_VEHICLE_FINDER:\n+                        case REMOTE_SERVICE_CHARGE_NOW:\n+                            RemoteServiceUtils.getRemoteService(serviceCommand)\n+                                    .ifPresentOrElse(service -> remot.execute(service), () -> {\n+                                        logger.info(\"Remote service execution {} unknown\", serviceCommand);\n+                                    });\n+                            break;\n+                        case REMOTE_SERVICE_CHARGING_CONTROL:\n+                            sendChargeProfile(chargeProfileEdit);\n+                            break;\n+                        default:\n+                            logger.info(\"Remote service execution {} unknown\", serviceCommand);\n+                            break;\n+                    }\n+                });\n+            }\n+        } else if (CHANNEL_GROUP_VEHICLE_IMAGE.equals(group)) {\n+            // Image Change\n+            configuration.ifPresent(config -> {\n+                if (command instanceof StringType) {\n+                    if (channelUID.getIdWithoutGroup().equals(IMAGE_VIEWPORT)) {\n+                        String newViewport = command.toString();\n+                        synchronized (imageProperties) {\n+                            if (!imageProperties.viewport.equals(newViewport)) {\n+                                imageProperties = new ImageProperties(newViewport, imageProperties.size);\n+                                imageCache = Optional.empty();\n+                                proxy.ifPresent(prox -> prox.requestImage(config, imageProperties, imageCallback));\n+                            }\n+                        }\n+                        updateChannel(CHANNEL_GROUP_VEHICLE_IMAGE, IMAGE_VIEWPORT, StringType.valueOf(newViewport));\n+                    }\n+                }\n+                if (command instanceof DecimalType) {\n+                    if (command instanceof DecimalType) {\n+                        int newImageSize = ((DecimalType) command).intValue();\n+                        if (channelUID.getIdWithoutGroup().equals(IMAGE_SIZE)) {\n+                            synchronized (imageProperties) {\n+                                if (imageProperties.size != newImageSize) {\n+                                    imageProperties = new ImageProperties(imageProperties.viewport, newImageSize);\n+                                    imageCache = Optional.empty();\n+                                    proxy.ifPresent(prox -> prox.requestImage(config, imageProperties, imageCallback));\n+                                }\n+                            }\n+                        }\n+                        updateChannel(CHANNEL_GROUP_VEHICLE_IMAGE, IMAGE_SIZE, new DecimalType(newImageSize));\n+                    }\n+                }\n+            });\n+        } else if (CHANNEL_GROUP_DESTINATION.equals(group)) {\n+            if (command instanceof StringType) {\n+                int index = Converter.getIndex(command.toFullString());\n+                if (index != -1) {\n+                    selectDestination(index);\n+                } else {\n+                    logger.debug(\"Cannot select Destination index {}\", command.toFullString());\n+                }\n+            }\n+        } else if (CHANNEL_GROUP_SERVICE.equals(group)) {\n+            if (command instanceof StringType) {\n+                int index = Converter.getIndex(command.toFullString());\n+                if (index != -1) {\n+                    selectService(index);\n+                } else {\n+                    logger.debug(\"Cannot select Service index {}\", command.toFullString());\n+                }\n+            }\n+        } else if (CHANNEL_GROUP_CHECK_CONTROL.equals(group)) {\n+            if (command instanceof StringType) {\n+                int index = Converter.getIndex(command.toFullString());\n+                if (index != -1) {\n+                    selectCheckControl(index);\n+                } else {\n+                    logger.debug(\"Cannot select CheckControl index {}\", command.toFullString());\n+                }\n+            }\n+        } else if (CHANNEL_GROUP_CHARGE.equals(group)) {\n+            handleChargeProfileCommand(channelUID, command);\n+        }\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        callbackCounter = Optional.of(new ArrayList<ResponseCallback>());\n+        updateStatus(ThingStatus.UNKNOWN);\n+        final VehicleConfiguration config = getConfigAs(VehicleConfiguration.class);\n+        if (config != null) {\n+            configuration = Optional.of(config);\n+            scheduler.execute(() -> {\n+                Bridge bridge = getBridge();\n+                if (bridge != null) {\n+                    BridgeHandler handler = bridge.getHandler();\n+                    if (handler != null) {\n+                        bridgeHandler = Optional.of(((ConnectedDriveBridgeHandler) handler));\n+                        proxy = ((ConnectedDriveBridgeHandler) handler).getProxy();\n+                        remote = proxy.map(prox -> prox.getRemoteServiceHandler(this));\n+                    } else {\n+                        logger.debug(\"Bridge Handler null\");\n+                    }\n+                } else {\n+                    logger.debug(\"Bridge null\");\n+                }\n+\n+                // get Image after init with config values\n+                synchronized (imageProperties) {\n+                    imageProperties = new ImageProperties(config.imageViewport, config.imageSize);\n+                }\n+                updateChannel(CHANNEL_GROUP_VEHICLE_IMAGE, IMAGE_VIEWPORT, StringType.valueOf((config.imageViewport)));\n+                updateChannel(CHANNEL_GROUP_VEHICLE_IMAGE, IMAGE_SIZE, new DecimalType((config.imageSize)));\n+\n+                // check imperial setting is different to AutoDetect\n+                if (!UNITS_AUTODETECT.equals(config.units)) {\n+                    imperial = UNITS_IMPERIAL.equals(config.units);\n+                }\n+\n+                // start update schedule\n+                startSchedule(config.refreshInterval);\n+            });\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR);\n+        }\n+    }\n+\n+    private void startSchedule(int interval) {\n+        refreshJob.ifPresentOrElse(job -> {\n+            if (job.isCancelled()) {\n+                refreshJob = Optional\n+                        .of(scheduler.scheduleWithFixedDelay(this::getData, 0, interval, TimeUnit.MINUTES));\n+            } // else - scheduler is already running!\n+        }, () -> {\n+            refreshJob = Optional.of(scheduler.scheduleWithFixedDelay(this::getData, 0, interval, TimeUnit.MINUTES));\n+        });\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        refreshJob.ifPresent(job -> job.cancel(true));\n+    }\n+\n+    public void getData() {\n+        proxy.ifPresentOrElse(prox -> {\n+            configuration.ifPresentOrElse(config -> {\n+                if (!legacyMode) {\n+                    prox.requestVehcileStatus(config, vehicleStatusCallback);\n+                } else {\n+                    prox.requestLegacyVehcileStatus(config, oldVehicleStatusCallback);\n+                }\n+                addCallback(vehicleStatusCallback);\n+                if (isSupported(Constants.STATISTICS)) {\n+                    prox.requestLastTrip(config, lastTripCallback);\n+                    prox.requestAllTrips(config, allTripsCallback);\n+                    addCallback(lastTripCallback);\n+                    addCallback(allTripsCallback);\n+                }\n+                if (isSupported(Constants.LAST_DESTINATIONS)) {\n+                    prox.requestDestinations(config, destinationCallback);\n+                    addCallback(destinationCallback);\n+                }\n+                if (isElectric) {\n+                    prox.requestChargingProfile(config, chargeProfileCallback);\n+                    addCallback(chargeProfileCallback);\n+                }\n+                synchronized (imageProperties) {\n+                    if (!imageCache.isPresent() && !imageProperties.failLimitReached()) {\n+                        prox.requestImage(config, imageProperties, imageCallback);\n+                        addCallback(imageCallback);\n+                    }\n+                }\n+            }, () -> {\n+                logger.warn(\"ConnectedDrive Configuration isn't present\");\n+            });\n+        }, () -> {\n+            logger.warn(\"ConnectedDrive Proxy isn't present\");\n+        });\n+    }\n+\n+    private synchronized void addCallback(ResponseCallback rc) {\n+        callbackCounter.ifPresent(counter -> counter.add(rc));\n+    }\n+\n+    private synchronized void removeCallback(ResponseCallback rc) {\n+        callbackCounter.ifPresent(counter -> {\n+            counter.remove(rc);\n+            // all necessary callbacks received => print and set to empty\n+            if (counter.isEmpty()) {\n+                logFingerPrint();\n+                callbackCounter = Optional.empty();\n+            }\n+        });\n+    }\n+\n+    private void logFingerPrint() {\n+        final String vin = configuration.map(config -> config.vin).orElse(\"\");\n+        logger.debug(\"###### BMW ConnectedDrive Binding - Vehicle Troubleshoot Fingerprint Data - BEGIN ######\");\n+        logger.debug(\"### Discovery Result ###\");\n+        bridgeHandler.ifPresent(handler -> {\n+            logger.debug(\"{}\", handler.getDiscoveryFingerprint());\n+        });\n+        vehicleStatusCache.ifPresentOrElse(vehicleStatus -> {\n+            logger.debug(\"### Vehicle Status ###\");\n+\n+            // Anonymous data for VIN and Position\n+            try {\n+                VehicleStatusContainer container = Converter.getGson().fromJson(vehicleStatus,\n+                        VehicleStatusContainer.class);\n+                if (container != null) {\n+                    VehicleStatus status = container.vehicleStatus;\n+                    if (status != null) {\n+                        status.vin = Constants.ANONYMOUS;\n+                        if (status.position != null) {\n+                            status.position.lat = -1;\n+                            status.position.lon = -1;\n+                            status.position.heading = -1;\n+                        }\n+                    }\n+                }\n+                logger.debug(\"{}\", Converter.getGson().toJson(container));\n+            } catch (JsonSyntaxException jse) {\n+                logger.debug(\"{}\", jse.getMessage());\n+            }\n+        }, () -> {\n+            logger.debug(\"### Vehicle Status Empty ###\");\n+        });\n+        lastTripCache.ifPresentOrElse(lastTrip -> {\n+            logger.debug(\"### Last Trip ###\");\n+            logger.debug(\"{}\", lastTrip.replaceAll(vin, Constants.ANONYMOUS));\n+        }, () -> {\n+            logger.debug(\"### Last Trip Empty ###\");\n+        });\n+        allTripsCache.ifPresentOrElse(allTrips -> {\n+            logger.debug(\"### All Trips ###\");\n+            logger.debug(\"{}\", allTrips.replaceAll(vin, Constants.ANONYMOUS));\n+        }, () -> {\n+            logger.debug(\"### All Trips Empty ###\");\n+        });\n+        if (isElectric) {\n+            chargeProfileCache.ifPresentOrElse(chargeProfile -> {\n+                logger.debug(\"### Charge Profile ###\");\n+                logger.debug(\"{}\", chargeProfile.replaceAll(vin, Constants.ANONYMOUS));\n+            }, () -> {\n+                logger.debug(\"### Charge Profile Empty ###\");\n+            });\n+        }\n+        destinationCache.ifPresentOrElse(destination -> {\n+            logger.debug(\"### Charge Profile ###\");\n+            try {\n+                DestinationContainer container = Converter.getGson().fromJson(destination, DestinationContainer.class);\n+                if (container != null) {\n+                    if (container.destinations != null) {\n+                        container.destinations.forEach(entry -> {\n+                            entry.lat = 0;\n+                            entry.lon = 0;\n+                            entry.city = Constants.ANONYMOUS;\n+                            entry.street = Constants.ANONYMOUS;\n+                            entry.streetNumber = Constants.ANONYMOUS;\n+                            entry.country = Constants.ANONYMOUS;\n+                        });\n+                        logger.debug(\"{}\", Converter.getGson().toJson(container));\n+                    }\n+                } else {\n+                    logger.debug(\"### Destinations Empty ###\");\n+                }\n+            } catch (JsonSyntaxException jse) {\n+                logger.debug(\"{}\", jse.getMessage());\n+            }\n+        }, () -> {\n+            logger.debug(\"### Charge Profile Empty ###\");\n+        });\n+        rangeMapCache.ifPresentOrElse(rangeMap -> {\n+            logger.debug(\"### Range Map ###\");\n+            logger.debug(\"{}\", rangeMap.replaceAll(vin, Constants.ANONYMOUS));\n+        }, () -> {\n+            logger.debug(\"### Range Map Empty ###\");\n+        });\n+        logger.debug(\"###### BMW ConnectedDrive Binding - Vehicle Troubleshoot Fingerprint Data - END ######\");\n+    }\n+\n+    /**\n+     * Don't stress ConnectedDrive with unnecessary requests. One call at the beginning is done to check the response.\n+     * After cache has e.g. a proper error response it will be shown in the fingerprint\n+     *\n+     * @return\n+     */\n+    private boolean isSupported(String service) {\n+        final String services = thing.getProperties().get(Constants.SERVICES_SUPPORTED);\n+        if (services != null) {\n+            if (services.contains(service)) {\n+                return true;\n+            }\n+        }\n+        // if cache is empty give it a try one time to collected Troubleshoot data\n+        if (lastTripCache.isEmpty() || allTripsCache.isEmpty() || destinationCache.isEmpty()) {\n+            return true;\n+        } else {\n+            return false;\n+        }\n+    }\n+\n+    public void updateRemoteExecutionStatus(@Nullable String service, @Nullable String status) {\n+        if (RemoteService.CHARGING_CONTROL.toString().equals(service)\n+                && ExecutionState.EXECUTED.name().equals(status)) {\n+            saveChargeProfileSent();\n+        }\n+        updateChannel(CHANNEL_GROUP_REMOTE, REMOTE_STATE, StringType.valueOf(Converter.toTitleCase(\n+                new StringBuilder(service == null ? \"-\" : service).append(\" \").append(status).toString())));\n+    }\n+\n+    public Optional<VehicleConfiguration> getConfiguration() {\n+        return configuration;\n+    }\n+\n+    public ScheduledExecutorService getScheduler() {\n+        return scheduler;\n+    }\n+\n+    /**\n+     * Callbacks for ConnectedDrive Portal\n+     *\n+     * @author Bernd Weymann\n+     *\n+     */\n+    @NonNullByDefault({})\n+    public class ChargeProfilesCallback implements StringResponseCallback {\n+        @Override\n+        public void onResponse(@Nullable String content) {\n+            if (content != null) {\n+                chargeProfileCache = Optional.of(content);\n+                if (chargeProfileEdit.isEmpty()) {\n+                    updateChargeProfileFromContent(content);\n+                }\n+            }\n+            removeCallback(this);\n+        }\n+\n+        /**\n+         * Store Error Report in cache variable. Via Fingerprint Channel error is logged and Issue can be raised\n+         */\n+        @Override\n+        public void onError(NetworkError error) {\n+            logger.debug(\"{}\", error.toString());\n+            chargeProfileCache = Optional.of(Converter.getGson().toJson(error));\n+            removeCallback(this);\n+        }\n+    }\n+\n+    @NonNullByDefault({})\n+    public class RangeMapCallback implements StringResponseCallback {\n+        @Override\n+        public void onResponse(@Nullable String content) {\n+            rangeMapCache = Optional.ofNullable(content);\n+            removeCallback(this);\n+        }\n+\n+        /**\n+         * Store Error Report in cache variable. Via Fingerprint Channel error is logged and Issue can be raised\n+         */\n+        @Override\n+        public void onError(NetworkError error) {\n+            logger.debug(\"{}\", error.toString());\n+            rangeMapCache = Optional.of(Converter.getGson().toJson(error));\n+            removeCallback(this);\n+        }\n+    }\n+\n+    @NonNullByDefault({})\n+    public class DestinationsCallback implements StringResponseCallback {\n+\n+        @Override\n+        public void onResponse(@Nullable String content) {\n+            destinationCache = Optional.ofNullable(content);\n+            if (content != null) {\n+                try {\n+                    DestinationContainer dc = Converter.getGson().fromJson(content, DestinationContainer.class);\n+                    if (dc != null && dc.destinations != null) {\n+                        updateDestinations(dc.destinations);\n+                    }\n+                } catch (JsonSyntaxException jse) {\n+                    logger.debug(\"{}\", jse.getMessage());\n+                }\n+            }\n+            removeCallback(this);\n+        }\n+\n+        /**\n+         * Store Error Report in cache variable. Via Fingerprint Channel error is logged and Issue can be raised\n+         */\n+        @Override\n+        public void onError(NetworkError error) {\n+            logger.debug(\"{}\", error.toString());\n+            destinationCache = Optional.of(Converter.getGson().toJson(error));\n+            removeCallback(this);\n+        }\n+    }\n+\n+    @NonNullByDefault({})\n+    public class ImageCallback implements ByteResponseCallback {\n+        @Override\n+        public void onResponse(byte[] content) {\n+            if (content.length > 0) {\n+                imageCache = Optional.of(content);\n+                String contentType = HttpUtil.guessContentTypeFromData(content);\n+                updateChannel(CHANNEL_GROUP_VEHICLE_IMAGE, IMAGE_FORMAT, new RawType(content, contentType));\n+            } else {\n+                synchronized (imageProperties) {\n+                    imageProperties.failed();\n+                }\n+            }\n+            removeCallback(this);\n+        }\n+\n+        /**\n+         * Store Error Report in cache variable. Via Fingerprint Channel error is logged and Issue can be raised\n+         */\n+        @Override\n+        public void onError(NetworkError error) {\n+            logger.debug(\"{}\", error.toString());\n+            synchronized (imageProperties) {\n+                imageProperties.failed();\n+            }\n+            removeCallback(this);\n+        }\n+    }\n+\n+    @NonNullByDefault({})\n+    public class AllTripsCallback implements StringResponseCallback {\n+        @Override\n+        public void onResponse(@Nullable String content) {\n+            if (content != null) {\n+                allTripsCache = Optional.of(content);\n+                try {\n+                    AllTripsContainer atc = Converter.getGson().fromJson(content, AllTripsContainer.class);\n+                    if (atc != null) {\n+                        AllTrips at = atc.allTrips;\n+                        if (at != null) {\n+                            updateAllTrips(at);\n+                        }\n+                    }\n+                } catch (JsonSyntaxException jse) {\n+                    logger.debug(\"{}\", jse.getMessage());\n+                }\n+            }\n+            removeCallback(this);\n+        }\n+\n+        /**\n+         * Store Error Report in cache variable. Via Fingerprint Channel error is logged and Issue can be raised\n+         */\n+        @Override\n+        public void onError(NetworkError error) {\n+            logger.debug(\"{}\", error.toString());\n+            allTripsCache = Optional.of(Converter.getGson().toJson(error));\n+            removeCallback(this);\n+        }\n+    }\n+\n+    @NonNullByDefault({})\n+    public class LastTripCallback implements StringResponseCallback {\n+        @Override\n+        public void onResponse(@Nullable String content) {\n+            if (content != null) {\n+                lastTripCache = Optional.of(content);\n+                try {\n+                    LastTripContainer lt = Converter.getGson().fromJson(content, LastTripContainer.class);\n+                    if (lt != null) {\n+                        LastTrip trip = lt.lastTrip;\n+                        if (trip != null) {\n+                            updateLastTrip(trip);\n+                        }\n+                    }\n+                } catch (JsonSyntaxException jse) {\n+                    logger.debug(\"{}\", jse.getMessage());\n+                }\n+            }\n+            removeCallback(this);\n+        }\n+\n+        /**\n+         * Store Error Report in cache variable. Via Fingerprint Channel error is logged and Issue can be raised\n+         */\n+        @Override\n+        public void onError(NetworkError error) {\n+            logger.debug(\"{}\", error.toString());\n+            lastTripCache = Optional.of(Converter.getGson().toJson(error));\n+            removeCallback(this);\n+        }\n+    }\n+\n+    /**\n+     * The VehicleStatus is supported by all Vehicle Types so it's used to reflect the Thing Status\n+     */\n+    @NonNullByDefault({})\n+    public class VehicleStatusCallback implements StringResponseCallback {\n+        private ThingStatus thingStatus = ThingStatus.UNKNOWN;\n+\n+        /**\n+         * Vehicle Status is supported by all Vehicles so callback result is used to report Thing Status.\n+         * If valid content is delivered in onResponse Thing goes online while onError Thing goes offline\n+         *\n+         * @param status\n+         * @param detail\n+         * @param reason\n+         */\n+        private void setThingStatus(ThingStatus status, ThingStatusDetail detail, String reason) {\n+            if (thingStatus != status) {\n+                updateStatus(status, detail, reason);\n+            }\n+        }\n+\n+        @Override\n+        public void onResponse(@Nullable String content) {\n+            if (content != null) {\n+                setThingStatus(ThingStatus.ONLINE, ThingStatusDetail.NONE, Constants.EMPTY);\n+                vehicleStatusCache = Optional.of(content);\n+                try {\n+                    VehicleStatusContainer status = Converter.getGson().fromJson(content, VehicleStatusContainer.class);\n+                    if (status != null) {\n+                        VehicleStatus vStatus = status.vehicleStatus;\n+                        if (vStatus == null) {\n+                            return;\n+                        }\n+                        updateVehicleStatus(vStatus);\n+                        updateCheckControls(vStatus.checkControlMessages);\n+                        updateServices(vStatus.cbsData);\n+                        updatePosition(vStatus.position);\n+                    }\n+                } catch (JsonSyntaxException jse) {\n+                    logger.debug(\"{}\", jse.getMessage());\n+                }\n+            }\n+            removeCallback(this);\n+        }\n+\n+        @Override\n+        public void onError(NetworkError error) {\n+            logger.debug(\"{}\", error.toString());\n+            if (error.status == 404) {\n+                legacyMode = true;\n+                logger.debug(\"VehicleStatus not found - switch to legacy API\");\n+                proxy.get().requestLegacyVehcileStatus(configuration.get(), oldVehicleStatusCallback);\n+            }\n+            vehicleStatusCache = Optional.of(Converter.getGson().toJson(error));\n+            setThingStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, error.reason);\n+            removeCallback(this);\n+        }\n+    }\n+\n+    /**\n+     * Fallback API if origin isn't supported.\n+     * This comes from the Community Discussion where a Vehicle from 2015 answered with \"404\"\n+     * https://community.openhab.org/t/bmw-connecteddrive-binding/105124\n+     *\n+     * Selection of API was discussed here\n+     * https://community.openhab.org/t/bmw-connecteddrive-bmw-i3/103876\n+     *\n+     * I figured out that only one API was working for this Vehicle. So this backward compatible Callback is introduced.\n+     * The delivered data is converted into the origin dto object so no changes in previous functional code needed\n+     */\n+    @NonNullByDefault({})\n+    public class LegacyVehicleStatusCallback implements StringResponseCallback {\n+        @Override\n+        public void onResponse(@Nullable String content) {\n+            if (content != null) {\n+                try {\n+                    VehicleAttributesContainer vac = Converter.getGson().fromJson(content,\n+                            VehicleAttributesContainer.class);\n+                    if (vac != null) {\n+                        vehicleStatusCallback.onResponse(vac.transform());\n+                    }\n+                } catch (JsonSyntaxException jse) {\n+                    logger.debug(\"{}\", jse.getMessage());\n+                }\n+            }\n+        }\n+\n+        @Override\n+        public void onError(NetworkError error) {\n+            vehicleStatusCallback.onError(error);\n+        }\n+    }\n+\n+    private void handleChargeProfileCommand(ChannelUID channelUID, Command command) {\n+        if (chargeProfileEdit.isEmpty()) {\n+            chargeProfileEdit = getChargeProfileWrapper();\n+        }\n+\n+        chargeProfileEdit.ifPresent(profile -> {\n+\n+            boolean processed = false;\n+\n+            final String id = channelUID.getIdWithoutGroup();\n+\n+            if (command instanceof StringType) {\n+                final String stringCommand = ((StringType) command).toFullString();\n+                switch (id) {\n+                    case CHARGE_PROFILE_PREFERENCE:\n+                        profile.setPreference(stringCommand);\n+                        updateChannel(CHANNEL_GROUP_CHARGE, CHARGE_PROFILE_PREFERENCE,\n+                                StringType.valueOf(Converter.toTitleCase(profile.getPreference())));\n+                        processed = true;\n+                        break;\n+                    case CHARGE_PROFILE_MODE:\n+                        profile.setMode(stringCommand);\n+                        updateChannel(CHANNEL_GROUP_CHARGE, CHARGE_PROFILE_MODE,\n+                                StringType.valueOf(Converter.toTitleCase(profile.getMode())));\n+                        processed = true;\n+                        break;\n+                    default:\n+                        break;\n+                }\n+            } else if (command instanceof OnOffType) {\n+                final ProfileKey enableKey = ChargeProfileUtils.getEnableKey(id);\n+                if (enableKey != null) {\n+                    profile.setEnabled(enableKey, OnOffType.ON.equals(command));\n+                    updateTimedState(profile, enableKey);\n+                    processed = true;\n+                } else {\n+                    final ChargeKeyDay chargeKeyDay = ChargeProfileUtils.getKeyDay(id);\n+                    if (chargeKeyDay != null) {\n+                        profile.setDayEnabled(chargeKeyDay.key, chargeKeyDay.day, OnOffType.ON.equals(command));\n+                        updateTimedState(profile, chargeKeyDay.key);\n+                        processed = true;\n+                    }\n+                }\n+            } else if (command instanceof DecimalType) {\n+                final ChargeKeyHour keyHour = ChargeProfileUtils.getKeyHour(id);\n+                if (keyHour != null) {\n+                    if (keyHour.isHour) {\n+                        profile.setHour(keyHour.key, ((DecimalType) command).intValue());\n+                    } else {\n+                        profile.setMinute(keyHour.key, ((DecimalType) command).intValue());\n+                    }\n+                    updateTimedState(profile, keyHour.key);\n+                    processed = true;\n+                }\n+            }\n+\n+            if (processed) {\n+                // cancel current timer and add another 5 mins - valid for each edit\n+                editTimeout.ifPresent(timeout -> timeout.cancel(true));\n+                // start edit timer with 5 min timeout\n+                editTimeout = Optional.of(scheduler.schedule(() -> {\n+                    editTimeout = Optional.empty();\n+                    chargeProfileEdit = Optional.empty();\n+                    chargeProfileCache.ifPresent(content -> updateChargeProfileFromContent(content));\n+                }, 5, TimeUnit.MINUTES));\n+            } else {\n+                logger.info(\"unexpected command {} not processed\", command.toFullString());\n+            }\n+        });\n+    }\n+\n+    private void saveChargeProfileSent() {\n+        editTimeout.ifPresent(timeout -> {\n+            timeout.cancel(true);\n+            editTimeout = Optional.empty();\n+        });\n+        chargeProfileSent.ifPresent(sent -> {\n+            chargeProfileCache = Optional.of(sent);\n+            chargeProfileSent = Optional.empty();\n+            chargeProfileEdit = Optional.empty();\n+            chargeProfileCache.ifPresent(content -> updateChargeProfileFromContent(content));\n+        });\n+    }\n+\n+    @Override\n+    public Collection<Class<? extends ThingHandlerService>> getServices() {\n+        return Set.of(ChargeProfileActions.class);\n+    }\n+\n+    public Optional<ChargeProfileWrapper> getChargeProfileWrapper() {\n+        return chargeProfileCache.flatMap(cache -> {\n+            return ChargeProfileWrapper.fromJson(cache).map(wrapper -> {\n+                logger.debug(\"Charge Profile editing - start\");\n+                logger.debug(\"{}\", wrapper.getJson());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "48af48c82562d006b6f2aa35922270f181c885ed"}, "originalPosition": 807}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMjgwMjEyNQ==", "bodyText": "Right, this is the good case and shall not be logged - deleted", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r602802125", "createdAt": "2021-03-27T22:56:44Z", "author": {"login": "weymann"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/VehicleHandler.java", "diffHunk": "@@ -0,0 +1,826 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bmwconnecteddrive.internal.handler;\n+\n+import static org.openhab.binding.bmwconnecteddrive.internal.ConnectedDriveConstants.*;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.bmwconnecteddrive.internal.VehicleConfiguration;\n+import org.openhab.binding.bmwconnecteddrive.internal.action.ChargeProfileActions;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.DestinationContainer;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.NetworkError;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.compat.VehicleAttributesContainer;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.statistics.AllTrips;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.statistics.AllTripsContainer;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.statistics.LastTrip;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.statistics.LastTripContainer;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.status.VehicleStatus;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.status.VehicleStatusContainer;\n+import org.openhab.binding.bmwconnecteddrive.internal.handler.RemoteServiceHandler.ExecutionState;\n+import org.openhab.binding.bmwconnecteddrive.internal.handler.RemoteServiceHandler.RemoteService;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileUtils;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileUtils.ChargeKeyDay;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileUtils.ChargeKeyHour;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileWrapper;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileWrapper.ProfileKey;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Constants;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Converter;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ImageProperties;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.RemoteServiceUtils;\n+import org.openhab.core.io.net.http.HttpUtil;\n+import org.openhab.core.library.types.DecimalType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.RawType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BridgeHandler;\n+import org.openhab.core.thing.binding.ThingHandlerService;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+\n+import com.google.gson.JsonSyntaxException;\n+\n+/**\n+ * The {@link VehicleHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Bernd Weymann - Initial contribution\n+ * @author Norbert Truchsess - edit & send charge profile\n+ */\n+@NonNullByDefault\n+public class VehicleHandler extends VehicleChannelHandler {\n+    private boolean legacyMode = false; // switch to legacy API in case of 404 Errors\n+\n+    private Optional<ConnectedDriveProxy> proxy = Optional.empty();\n+    private Optional<RemoteServiceHandler> remote = Optional.empty();\n+    private Optional<VehicleConfiguration> configuration = Optional.empty();\n+    private Optional<ConnectedDriveBridgeHandler> bridgeHandler = Optional.empty();\n+    private Optional<ScheduledFuture<?>> refreshJob = Optional.empty();\n+    private Optional<ScheduledFuture<?>> editTimeout = Optional.empty();\n+    private Optional<List<ResponseCallback>> callbackCounter = Optional.empty();\n+\n+    private ImageProperties imageProperties = new ImageProperties();\n+    VehicleStatusCallback vehicleStatusCallback = new VehicleStatusCallback();\n+    StringResponseCallback oldVehicleStatusCallback = new LegacyVehicleStatusCallback();\n+    StringResponseCallback lastTripCallback = new LastTripCallback();\n+    StringResponseCallback allTripsCallback = new AllTripsCallback();\n+    StringResponseCallback chargeProfileCallback = new ChargeProfilesCallback();\n+    StringResponseCallback rangeMapCallback = new RangeMapCallback();\n+    DestinationsCallback destinationCallback = new DestinationsCallback();\n+    ByteResponseCallback imageCallback = new ImageCallback();\n+\n+    private Optional<ChargeProfileWrapper> chargeProfileEdit = Optional.empty();\n+    private Optional<String> chargeProfileSent = Optional.empty();\n+\n+    public VehicleHandler(Thing thing, BMWConnectedDriveOptionProvider op, String type, boolean imperial) {\n+        super(thing, op, type, imperial);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        String group = channelUID.getGroupId();\n+\n+        // Refresh of Channels with cached values\n+        if (command instanceof RefreshType) {\n+            if (CHANNEL_GROUP_LAST_TRIP.equals(group)) {\n+                lastTripCache.ifPresent(lastTrip -> lastTripCallback.onResponse(lastTrip));\n+            } else if (CHANNEL_GROUP_LIFETIME.equals(group)) {\n+                allTripsCache.ifPresent(allTrips -> allTripsCallback.onResponse(allTrips));\n+            } else if (CHANNEL_GROUP_DESTINATION.equals(group)) {\n+                destinationCache.ifPresent(destination -> destinationCallback.onResponse(destination));\n+            } else if (CHANNEL_GROUP_STATUS.equals(group)) {\n+                vehicleStatusCache.ifPresent(vehicleStatus -> vehicleStatusCallback.onResponse(vehicleStatus));\n+            } else if (CHANNEL_GROUP_CHARGE.equals(group)) {\n+                chargeProfileEdit.ifPresentOrElse(this::updateChargeProfile,\n+                        () -> chargeProfileCache.ifPresent(this::updateChargeProfileFromContent));\n+            } else if (CHANNEL_GROUP_VEHICLE_IMAGE.equals(group)) {\n+                imageCache.ifPresent(image -> imageCallback.onResponse(image));\n+            }\n+            // Check for Channel Group and corresponding Actions\n+        } else if (CHANNEL_GROUP_REMOTE.equals(group)) {\n+            // Executing Remote Services\n+            if (command instanceof StringType) {\n+                String serviceCommand = ((StringType) command).toFullString();\n+                remote.ifPresent(remot -> {\n+                    switch (serviceCommand) {\n+                        case REMOTE_SERVICE_LIGHT_FLASH:\n+                        case REMOTE_SERVICE_AIR_CONDITIONING:\n+                        case REMOTE_SERVICE_DOOR_LOCK:\n+                        case REMOTE_SERVICE_DOOR_UNLOCK:\n+                        case REMOTE_SERVICE_HORN:\n+                        case REMOTE_SERVICE_VEHICLE_FINDER:\n+                        case REMOTE_SERVICE_CHARGE_NOW:\n+                            RemoteServiceUtils.getRemoteService(serviceCommand)\n+                                    .ifPresentOrElse(service -> remot.execute(service), () -> {\n+                                        logger.info(\"Remote service execution {} unknown\", serviceCommand);\n+                                    });\n+                            break;\n+                        case REMOTE_SERVICE_CHARGING_CONTROL:\n+                            sendChargeProfile(chargeProfileEdit);\n+                            break;\n+                        default:\n+                            logger.info(\"Remote service execution {} unknown\", serviceCommand);\n+                            break;\n+                    }\n+                });\n+            }\n+        } else if (CHANNEL_GROUP_VEHICLE_IMAGE.equals(group)) {\n+            // Image Change\n+            configuration.ifPresent(config -> {\n+                if (command instanceof StringType) {\n+                    if (channelUID.getIdWithoutGroup().equals(IMAGE_VIEWPORT)) {\n+                        String newViewport = command.toString();\n+                        synchronized (imageProperties) {\n+                            if (!imageProperties.viewport.equals(newViewport)) {\n+                                imageProperties = new ImageProperties(newViewport, imageProperties.size);\n+                                imageCache = Optional.empty();\n+                                proxy.ifPresent(prox -> prox.requestImage(config, imageProperties, imageCallback));\n+                            }\n+                        }\n+                        updateChannel(CHANNEL_GROUP_VEHICLE_IMAGE, IMAGE_VIEWPORT, StringType.valueOf(newViewport));\n+                    }\n+                }\n+                if (command instanceof DecimalType) {\n+                    if (command instanceof DecimalType) {\n+                        int newImageSize = ((DecimalType) command).intValue();\n+                        if (channelUID.getIdWithoutGroup().equals(IMAGE_SIZE)) {\n+                            synchronized (imageProperties) {\n+                                if (imageProperties.size != newImageSize) {\n+                                    imageProperties = new ImageProperties(imageProperties.viewport, newImageSize);\n+                                    imageCache = Optional.empty();\n+                                    proxy.ifPresent(prox -> prox.requestImage(config, imageProperties, imageCallback));\n+                                }\n+                            }\n+                        }\n+                        updateChannel(CHANNEL_GROUP_VEHICLE_IMAGE, IMAGE_SIZE, new DecimalType(newImageSize));\n+                    }\n+                }\n+            });\n+        } else if (CHANNEL_GROUP_DESTINATION.equals(group)) {\n+            if (command instanceof StringType) {\n+                int index = Converter.getIndex(command.toFullString());\n+                if (index != -1) {\n+                    selectDestination(index);\n+                } else {\n+                    logger.debug(\"Cannot select Destination index {}\", command.toFullString());\n+                }\n+            }\n+        } else if (CHANNEL_GROUP_SERVICE.equals(group)) {\n+            if (command instanceof StringType) {\n+                int index = Converter.getIndex(command.toFullString());\n+                if (index != -1) {\n+                    selectService(index);\n+                } else {\n+                    logger.debug(\"Cannot select Service index {}\", command.toFullString());\n+                }\n+            }\n+        } else if (CHANNEL_GROUP_CHECK_CONTROL.equals(group)) {\n+            if (command instanceof StringType) {\n+                int index = Converter.getIndex(command.toFullString());\n+                if (index != -1) {\n+                    selectCheckControl(index);\n+                } else {\n+                    logger.debug(\"Cannot select CheckControl index {}\", command.toFullString());\n+                }\n+            }\n+        } else if (CHANNEL_GROUP_CHARGE.equals(group)) {\n+            handleChargeProfileCommand(channelUID, command);\n+        }\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        callbackCounter = Optional.of(new ArrayList<ResponseCallback>());\n+        updateStatus(ThingStatus.UNKNOWN);\n+        final VehicleConfiguration config = getConfigAs(VehicleConfiguration.class);\n+        if (config != null) {\n+            configuration = Optional.of(config);\n+            scheduler.execute(() -> {\n+                Bridge bridge = getBridge();\n+                if (bridge != null) {\n+                    BridgeHandler handler = bridge.getHandler();\n+                    if (handler != null) {\n+                        bridgeHandler = Optional.of(((ConnectedDriveBridgeHandler) handler));\n+                        proxy = ((ConnectedDriveBridgeHandler) handler).getProxy();\n+                        remote = proxy.map(prox -> prox.getRemoteServiceHandler(this));\n+                    } else {\n+                        logger.debug(\"Bridge Handler null\");\n+                    }\n+                } else {\n+                    logger.debug(\"Bridge null\");\n+                }\n+\n+                // get Image after init with config values\n+                synchronized (imageProperties) {\n+                    imageProperties = new ImageProperties(config.imageViewport, config.imageSize);\n+                }\n+                updateChannel(CHANNEL_GROUP_VEHICLE_IMAGE, IMAGE_VIEWPORT, StringType.valueOf((config.imageViewport)));\n+                updateChannel(CHANNEL_GROUP_VEHICLE_IMAGE, IMAGE_SIZE, new DecimalType((config.imageSize)));\n+\n+                // check imperial setting is different to AutoDetect\n+                if (!UNITS_AUTODETECT.equals(config.units)) {\n+                    imperial = UNITS_IMPERIAL.equals(config.units);\n+                }\n+\n+                // start update schedule\n+                startSchedule(config.refreshInterval);\n+            });\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR);\n+        }\n+    }\n+\n+    private void startSchedule(int interval) {\n+        refreshJob.ifPresentOrElse(job -> {\n+            if (job.isCancelled()) {\n+                refreshJob = Optional\n+                        .of(scheduler.scheduleWithFixedDelay(this::getData, 0, interval, TimeUnit.MINUTES));\n+            } // else - scheduler is already running!\n+        }, () -> {\n+            refreshJob = Optional.of(scheduler.scheduleWithFixedDelay(this::getData, 0, interval, TimeUnit.MINUTES));\n+        });\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        refreshJob.ifPresent(job -> job.cancel(true));\n+    }\n+\n+    public void getData() {\n+        proxy.ifPresentOrElse(prox -> {\n+            configuration.ifPresentOrElse(config -> {\n+                if (!legacyMode) {\n+                    prox.requestVehcileStatus(config, vehicleStatusCallback);\n+                } else {\n+                    prox.requestLegacyVehcileStatus(config, oldVehicleStatusCallback);\n+                }\n+                addCallback(vehicleStatusCallback);\n+                if (isSupported(Constants.STATISTICS)) {\n+                    prox.requestLastTrip(config, lastTripCallback);\n+                    prox.requestAllTrips(config, allTripsCallback);\n+                    addCallback(lastTripCallback);\n+                    addCallback(allTripsCallback);\n+                }\n+                if (isSupported(Constants.LAST_DESTINATIONS)) {\n+                    prox.requestDestinations(config, destinationCallback);\n+                    addCallback(destinationCallback);\n+                }\n+                if (isElectric) {\n+                    prox.requestChargingProfile(config, chargeProfileCallback);\n+                    addCallback(chargeProfileCallback);\n+                }\n+                synchronized (imageProperties) {\n+                    if (!imageCache.isPresent() && !imageProperties.failLimitReached()) {\n+                        prox.requestImage(config, imageProperties, imageCallback);\n+                        addCallback(imageCallback);\n+                    }\n+                }\n+            }, () -> {\n+                logger.warn(\"ConnectedDrive Configuration isn't present\");\n+            });\n+        }, () -> {\n+            logger.warn(\"ConnectedDrive Proxy isn't present\");\n+        });\n+    }\n+\n+    private synchronized void addCallback(ResponseCallback rc) {\n+        callbackCounter.ifPresent(counter -> counter.add(rc));\n+    }\n+\n+    private synchronized void removeCallback(ResponseCallback rc) {\n+        callbackCounter.ifPresent(counter -> {\n+            counter.remove(rc);\n+            // all necessary callbacks received => print and set to empty\n+            if (counter.isEmpty()) {\n+                logFingerPrint();\n+                callbackCounter = Optional.empty();\n+            }\n+        });\n+    }\n+\n+    private void logFingerPrint() {\n+        final String vin = configuration.map(config -> config.vin).orElse(\"\");\n+        logger.debug(\"###### BMW ConnectedDrive Binding - Vehicle Troubleshoot Fingerprint Data - BEGIN ######\");\n+        logger.debug(\"### Discovery Result ###\");\n+        bridgeHandler.ifPresent(handler -> {\n+            logger.debug(\"{}\", handler.getDiscoveryFingerprint());\n+        });\n+        vehicleStatusCache.ifPresentOrElse(vehicleStatus -> {\n+            logger.debug(\"### Vehicle Status ###\");\n+\n+            // Anonymous data for VIN and Position\n+            try {\n+                VehicleStatusContainer container = Converter.getGson().fromJson(vehicleStatus,\n+                        VehicleStatusContainer.class);\n+                if (container != null) {\n+                    VehicleStatus status = container.vehicleStatus;\n+                    if (status != null) {\n+                        status.vin = Constants.ANONYMOUS;\n+                        if (status.position != null) {\n+                            status.position.lat = -1;\n+                            status.position.lon = -1;\n+                            status.position.heading = -1;\n+                        }\n+                    }\n+                }\n+                logger.debug(\"{}\", Converter.getGson().toJson(container));\n+            } catch (JsonSyntaxException jse) {\n+                logger.debug(\"{}\", jse.getMessage());\n+            }\n+        }, () -> {\n+            logger.debug(\"### Vehicle Status Empty ###\");\n+        });\n+        lastTripCache.ifPresentOrElse(lastTrip -> {\n+            logger.debug(\"### Last Trip ###\");\n+            logger.debug(\"{}\", lastTrip.replaceAll(vin, Constants.ANONYMOUS));\n+        }, () -> {\n+            logger.debug(\"### Last Trip Empty ###\");\n+        });\n+        allTripsCache.ifPresentOrElse(allTrips -> {\n+            logger.debug(\"### All Trips ###\");\n+            logger.debug(\"{}\", allTrips.replaceAll(vin, Constants.ANONYMOUS));\n+        }, () -> {\n+            logger.debug(\"### All Trips Empty ###\");\n+        });\n+        if (isElectric) {\n+            chargeProfileCache.ifPresentOrElse(chargeProfile -> {\n+                logger.debug(\"### Charge Profile ###\");\n+                logger.debug(\"{}\", chargeProfile.replaceAll(vin, Constants.ANONYMOUS));\n+            }, () -> {\n+                logger.debug(\"### Charge Profile Empty ###\");\n+            });\n+        }\n+        destinationCache.ifPresentOrElse(destination -> {\n+            logger.debug(\"### Charge Profile ###\");\n+            try {\n+                DestinationContainer container = Converter.getGson().fromJson(destination, DestinationContainer.class);\n+                if (container != null) {\n+                    if (container.destinations != null) {\n+                        container.destinations.forEach(entry -> {\n+                            entry.lat = 0;\n+                            entry.lon = 0;\n+                            entry.city = Constants.ANONYMOUS;\n+                            entry.street = Constants.ANONYMOUS;\n+                            entry.streetNumber = Constants.ANONYMOUS;\n+                            entry.country = Constants.ANONYMOUS;\n+                        });\n+                        logger.debug(\"{}\", Converter.getGson().toJson(container));\n+                    }\n+                } else {\n+                    logger.debug(\"### Destinations Empty ###\");\n+                }\n+            } catch (JsonSyntaxException jse) {\n+                logger.debug(\"{}\", jse.getMessage());\n+            }\n+        }, () -> {\n+            logger.debug(\"### Charge Profile Empty ###\");\n+        });\n+        rangeMapCache.ifPresentOrElse(rangeMap -> {\n+            logger.debug(\"### Range Map ###\");\n+            logger.debug(\"{}\", rangeMap.replaceAll(vin, Constants.ANONYMOUS));\n+        }, () -> {\n+            logger.debug(\"### Range Map Empty ###\");\n+        });\n+        logger.debug(\"###### BMW ConnectedDrive Binding - Vehicle Troubleshoot Fingerprint Data - END ######\");\n+    }\n+\n+    /**\n+     * Don't stress ConnectedDrive with unnecessary requests. One call at the beginning is done to check the response.\n+     * After cache has e.g. a proper error response it will be shown in the fingerprint\n+     *\n+     * @return\n+     */\n+    private boolean isSupported(String service) {\n+        final String services = thing.getProperties().get(Constants.SERVICES_SUPPORTED);\n+        if (services != null) {\n+            if (services.contains(service)) {\n+                return true;\n+            }\n+        }\n+        // if cache is empty give it a try one time to collected Troubleshoot data\n+        if (lastTripCache.isEmpty() || allTripsCache.isEmpty() || destinationCache.isEmpty()) {\n+            return true;\n+        } else {\n+            return false;\n+        }\n+    }\n+\n+    public void updateRemoteExecutionStatus(@Nullable String service, @Nullable String status) {\n+        if (RemoteService.CHARGING_CONTROL.toString().equals(service)\n+                && ExecutionState.EXECUTED.name().equals(status)) {\n+            saveChargeProfileSent();\n+        }\n+        updateChannel(CHANNEL_GROUP_REMOTE, REMOTE_STATE, StringType.valueOf(Converter.toTitleCase(\n+                new StringBuilder(service == null ? \"-\" : service).append(\" \").append(status).toString())));\n+    }\n+\n+    public Optional<VehicleConfiguration> getConfiguration() {\n+        return configuration;\n+    }\n+\n+    public ScheduledExecutorService getScheduler() {\n+        return scheduler;\n+    }\n+\n+    /**\n+     * Callbacks for ConnectedDrive Portal\n+     *\n+     * @author Bernd Weymann\n+     *\n+     */\n+    @NonNullByDefault({})\n+    public class ChargeProfilesCallback implements StringResponseCallback {\n+        @Override\n+        public void onResponse(@Nullable String content) {\n+            if (content != null) {\n+                chargeProfileCache = Optional.of(content);\n+                if (chargeProfileEdit.isEmpty()) {\n+                    updateChargeProfileFromContent(content);\n+                }\n+            }\n+            removeCallback(this);\n+        }\n+\n+        /**\n+         * Store Error Report in cache variable. Via Fingerprint Channel error is logged and Issue can be raised\n+         */\n+        @Override\n+        public void onError(NetworkError error) {\n+            logger.debug(\"{}\", error.toString());\n+            chargeProfileCache = Optional.of(Converter.getGson().toJson(error));\n+            removeCallback(this);\n+        }\n+    }\n+\n+    @NonNullByDefault({})\n+    public class RangeMapCallback implements StringResponseCallback {\n+        @Override\n+        public void onResponse(@Nullable String content) {\n+            rangeMapCache = Optional.ofNullable(content);\n+            removeCallback(this);\n+        }\n+\n+        /**\n+         * Store Error Report in cache variable. Via Fingerprint Channel error is logged and Issue can be raised\n+         */\n+        @Override\n+        public void onError(NetworkError error) {\n+            logger.debug(\"{}\", error.toString());\n+            rangeMapCache = Optional.of(Converter.getGson().toJson(error));\n+            removeCallback(this);\n+        }\n+    }\n+\n+    @NonNullByDefault({})\n+    public class DestinationsCallback implements StringResponseCallback {\n+\n+        @Override\n+        public void onResponse(@Nullable String content) {\n+            destinationCache = Optional.ofNullable(content);\n+            if (content != null) {\n+                try {\n+                    DestinationContainer dc = Converter.getGson().fromJson(content, DestinationContainer.class);\n+                    if (dc != null && dc.destinations != null) {\n+                        updateDestinations(dc.destinations);\n+                    }\n+                } catch (JsonSyntaxException jse) {\n+                    logger.debug(\"{}\", jse.getMessage());\n+                }\n+            }\n+            removeCallback(this);\n+        }\n+\n+        /**\n+         * Store Error Report in cache variable. Via Fingerprint Channel error is logged and Issue can be raised\n+         */\n+        @Override\n+        public void onError(NetworkError error) {\n+            logger.debug(\"{}\", error.toString());\n+            destinationCache = Optional.of(Converter.getGson().toJson(error));\n+            removeCallback(this);\n+        }\n+    }\n+\n+    @NonNullByDefault({})\n+    public class ImageCallback implements ByteResponseCallback {\n+        @Override\n+        public void onResponse(byte[] content) {\n+            if (content.length > 0) {\n+                imageCache = Optional.of(content);\n+                String contentType = HttpUtil.guessContentTypeFromData(content);\n+                updateChannel(CHANNEL_GROUP_VEHICLE_IMAGE, IMAGE_FORMAT, new RawType(content, contentType));\n+            } else {\n+                synchronized (imageProperties) {\n+                    imageProperties.failed();\n+                }\n+            }\n+            removeCallback(this);\n+        }\n+\n+        /**\n+         * Store Error Report in cache variable. Via Fingerprint Channel error is logged and Issue can be raised\n+         */\n+        @Override\n+        public void onError(NetworkError error) {\n+            logger.debug(\"{}\", error.toString());\n+            synchronized (imageProperties) {\n+                imageProperties.failed();\n+            }\n+            removeCallback(this);\n+        }\n+    }\n+\n+    @NonNullByDefault({})\n+    public class AllTripsCallback implements StringResponseCallback {\n+        @Override\n+        public void onResponse(@Nullable String content) {\n+            if (content != null) {\n+                allTripsCache = Optional.of(content);\n+                try {\n+                    AllTripsContainer atc = Converter.getGson().fromJson(content, AllTripsContainer.class);\n+                    if (atc != null) {\n+                        AllTrips at = atc.allTrips;\n+                        if (at != null) {\n+                            updateAllTrips(at);\n+                        }\n+                    }\n+                } catch (JsonSyntaxException jse) {\n+                    logger.debug(\"{}\", jse.getMessage());\n+                }\n+            }\n+            removeCallback(this);\n+        }\n+\n+        /**\n+         * Store Error Report in cache variable. Via Fingerprint Channel error is logged and Issue can be raised\n+         */\n+        @Override\n+        public void onError(NetworkError error) {\n+            logger.debug(\"{}\", error.toString());\n+            allTripsCache = Optional.of(Converter.getGson().toJson(error));\n+            removeCallback(this);\n+        }\n+    }\n+\n+    @NonNullByDefault({})\n+    public class LastTripCallback implements StringResponseCallback {\n+        @Override\n+        public void onResponse(@Nullable String content) {\n+            if (content != null) {\n+                lastTripCache = Optional.of(content);\n+                try {\n+                    LastTripContainer lt = Converter.getGson().fromJson(content, LastTripContainer.class);\n+                    if (lt != null) {\n+                        LastTrip trip = lt.lastTrip;\n+                        if (trip != null) {\n+                            updateLastTrip(trip);\n+                        }\n+                    }\n+                } catch (JsonSyntaxException jse) {\n+                    logger.debug(\"{}\", jse.getMessage());\n+                }\n+            }\n+            removeCallback(this);\n+        }\n+\n+        /**\n+         * Store Error Report in cache variable. Via Fingerprint Channel error is logged and Issue can be raised\n+         */\n+        @Override\n+        public void onError(NetworkError error) {\n+            logger.debug(\"{}\", error.toString());\n+            lastTripCache = Optional.of(Converter.getGson().toJson(error));\n+            removeCallback(this);\n+        }\n+    }\n+\n+    /**\n+     * The VehicleStatus is supported by all Vehicle Types so it's used to reflect the Thing Status\n+     */\n+    @NonNullByDefault({})\n+    public class VehicleStatusCallback implements StringResponseCallback {\n+        private ThingStatus thingStatus = ThingStatus.UNKNOWN;\n+\n+        /**\n+         * Vehicle Status is supported by all Vehicles so callback result is used to report Thing Status.\n+         * If valid content is delivered in onResponse Thing goes online while onError Thing goes offline\n+         *\n+         * @param status\n+         * @param detail\n+         * @param reason\n+         */\n+        private void setThingStatus(ThingStatus status, ThingStatusDetail detail, String reason) {\n+            if (thingStatus != status) {\n+                updateStatus(status, detail, reason);\n+            }\n+        }\n+\n+        @Override\n+        public void onResponse(@Nullable String content) {\n+            if (content != null) {\n+                setThingStatus(ThingStatus.ONLINE, ThingStatusDetail.NONE, Constants.EMPTY);\n+                vehicleStatusCache = Optional.of(content);\n+                try {\n+                    VehicleStatusContainer status = Converter.getGson().fromJson(content, VehicleStatusContainer.class);\n+                    if (status != null) {\n+                        VehicleStatus vStatus = status.vehicleStatus;\n+                        if (vStatus == null) {\n+                            return;\n+                        }\n+                        updateVehicleStatus(vStatus);\n+                        updateCheckControls(vStatus.checkControlMessages);\n+                        updateServices(vStatus.cbsData);\n+                        updatePosition(vStatus.position);\n+                    }\n+                } catch (JsonSyntaxException jse) {\n+                    logger.debug(\"{}\", jse.getMessage());\n+                }\n+            }\n+            removeCallback(this);\n+        }\n+\n+        @Override\n+        public void onError(NetworkError error) {\n+            logger.debug(\"{}\", error.toString());\n+            if (error.status == 404) {\n+                legacyMode = true;\n+                logger.debug(\"VehicleStatus not found - switch to legacy API\");\n+                proxy.get().requestLegacyVehcileStatus(configuration.get(), oldVehicleStatusCallback);\n+            }\n+            vehicleStatusCache = Optional.of(Converter.getGson().toJson(error));\n+            setThingStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, error.reason);\n+            removeCallback(this);\n+        }\n+    }\n+\n+    /**\n+     * Fallback API if origin isn't supported.\n+     * This comes from the Community Discussion where a Vehicle from 2015 answered with \"404\"\n+     * https://community.openhab.org/t/bmw-connecteddrive-binding/105124\n+     *\n+     * Selection of API was discussed here\n+     * https://community.openhab.org/t/bmw-connecteddrive-bmw-i3/103876\n+     *\n+     * I figured out that only one API was working for this Vehicle. So this backward compatible Callback is introduced.\n+     * The delivered data is converted into the origin dto object so no changes in previous functional code needed\n+     */\n+    @NonNullByDefault({})\n+    public class LegacyVehicleStatusCallback implements StringResponseCallback {\n+        @Override\n+        public void onResponse(@Nullable String content) {\n+            if (content != null) {\n+                try {\n+                    VehicleAttributesContainer vac = Converter.getGson().fromJson(content,\n+                            VehicleAttributesContainer.class);\n+                    if (vac != null) {\n+                        vehicleStatusCallback.onResponse(vac.transform());\n+                    }\n+                } catch (JsonSyntaxException jse) {\n+                    logger.debug(\"{}\", jse.getMessage());\n+                }\n+            }\n+        }\n+\n+        @Override\n+        public void onError(NetworkError error) {\n+            vehicleStatusCallback.onError(error);\n+        }\n+    }\n+\n+    private void handleChargeProfileCommand(ChannelUID channelUID, Command command) {\n+        if (chargeProfileEdit.isEmpty()) {\n+            chargeProfileEdit = getChargeProfileWrapper();\n+        }\n+\n+        chargeProfileEdit.ifPresent(profile -> {\n+\n+            boolean processed = false;\n+\n+            final String id = channelUID.getIdWithoutGroup();\n+\n+            if (command instanceof StringType) {\n+                final String stringCommand = ((StringType) command).toFullString();\n+                switch (id) {\n+                    case CHARGE_PROFILE_PREFERENCE:\n+                        profile.setPreference(stringCommand);\n+                        updateChannel(CHANNEL_GROUP_CHARGE, CHARGE_PROFILE_PREFERENCE,\n+                                StringType.valueOf(Converter.toTitleCase(profile.getPreference())));\n+                        processed = true;\n+                        break;\n+                    case CHARGE_PROFILE_MODE:\n+                        profile.setMode(stringCommand);\n+                        updateChannel(CHANNEL_GROUP_CHARGE, CHARGE_PROFILE_MODE,\n+                                StringType.valueOf(Converter.toTitleCase(profile.getMode())));\n+                        processed = true;\n+                        break;\n+                    default:\n+                        break;\n+                }\n+            } else if (command instanceof OnOffType) {\n+                final ProfileKey enableKey = ChargeProfileUtils.getEnableKey(id);\n+                if (enableKey != null) {\n+                    profile.setEnabled(enableKey, OnOffType.ON.equals(command));\n+                    updateTimedState(profile, enableKey);\n+                    processed = true;\n+                } else {\n+                    final ChargeKeyDay chargeKeyDay = ChargeProfileUtils.getKeyDay(id);\n+                    if (chargeKeyDay != null) {\n+                        profile.setDayEnabled(chargeKeyDay.key, chargeKeyDay.day, OnOffType.ON.equals(command));\n+                        updateTimedState(profile, chargeKeyDay.key);\n+                        processed = true;\n+                    }\n+                }\n+            } else if (command instanceof DecimalType) {\n+                final ChargeKeyHour keyHour = ChargeProfileUtils.getKeyHour(id);\n+                if (keyHour != null) {\n+                    if (keyHour.isHour) {\n+                        profile.setHour(keyHour.key, ((DecimalType) command).intValue());\n+                    } else {\n+                        profile.setMinute(keyHour.key, ((DecimalType) command).intValue());\n+                    }\n+                    updateTimedState(profile, keyHour.key);\n+                    processed = true;\n+                }\n+            }\n+\n+            if (processed) {\n+                // cancel current timer and add another 5 mins - valid for each edit\n+                editTimeout.ifPresent(timeout -> timeout.cancel(true));\n+                // start edit timer with 5 min timeout\n+                editTimeout = Optional.of(scheduler.schedule(() -> {\n+                    editTimeout = Optional.empty();\n+                    chargeProfileEdit = Optional.empty();\n+                    chargeProfileCache.ifPresent(content -> updateChargeProfileFromContent(content));\n+                }, 5, TimeUnit.MINUTES));\n+            } else {\n+                logger.info(\"unexpected command {} not processed\", command.toFullString());\n+            }\n+        });\n+    }\n+\n+    private void saveChargeProfileSent() {\n+        editTimeout.ifPresent(timeout -> {\n+            timeout.cancel(true);\n+            editTimeout = Optional.empty();\n+        });\n+        chargeProfileSent.ifPresent(sent -> {\n+            chargeProfileCache = Optional.of(sent);\n+            chargeProfileSent = Optional.empty();\n+            chargeProfileEdit = Optional.empty();\n+            chargeProfileCache.ifPresent(content -> updateChargeProfileFromContent(content));\n+        });\n+    }\n+\n+    @Override\n+    public Collection<Class<? extends ThingHandlerService>> getServices() {\n+        return Set.of(ChargeProfileActions.class);\n+    }\n+\n+    public Optional<ChargeProfileWrapper> getChargeProfileWrapper() {\n+        return chargeProfileCache.flatMap(cache -> {\n+            return ChargeProfileWrapper.fromJson(cache).map(wrapper -> {\n+                logger.debug(\"Charge Profile editing - start\");\n+                logger.debug(\"{}\", wrapper.getJson());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5NzkyMzY0NA=="}, "originalCommit": {"oid": "48af48c82562d006b6f2aa35922270f181c885ed"}, "originalPosition": 807}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzc3NjgxNDAzOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/utils/ChargeProfileUtils.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0xOVQxOToyNDozNVrOI6Oa_A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0yN1QyMzowMDo0M1rOI-4JZg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5NzkyNDYwNA==", "bodyText": "Fields should be at the top of the class. Please check all.", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r597924604", "createdAt": "2021-03-19T19:24:35Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/utils/ChargeProfileUtils.java", "diffHunk": "@@ -0,0 +1,147 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bmwconnecteddrive.internal.utils;\n+\n+import static org.openhab.binding.bmwconnecteddrive.internal.ConnectedDriveConstants.*;\n+\n+import java.time.DayOfWeek;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileWrapper.ProfileKey;\n+\n+/**\n+ * The {@link ChargeProfileUtils} utility functions for charging profiles\n+ *\n+ * @author Norbert Truchsess - initial contribution\n+ */\n+@NonNullByDefault\n+public class ChargeProfileUtils {\n+\n+    // Charging\n+    public static class TimedChannel {\n+        TimedChannel(final String time, @Nullable final String timer, final boolean hasDays) {\n+            this.time = time;\n+            this.timer = timer;\n+            this.hasDays = hasDays;\n+        }\n+\n+        public final String time;\n+        public final @Nullable String timer;\n+        public final boolean hasDays;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "48af48c82562d006b6f2aa35922270f181c885ed"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMjgwMjUzNA==", "bodyText": "Fixed", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r602802534", "createdAt": "2021-03-27T23:00:43Z", "author": {"login": "weymann"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/utils/ChargeProfileUtils.java", "diffHunk": "@@ -0,0 +1,147 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bmwconnecteddrive.internal.utils;\n+\n+import static org.openhab.binding.bmwconnecteddrive.internal.ConnectedDriveConstants.*;\n+\n+import java.time.DayOfWeek;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileWrapper.ProfileKey;\n+\n+/**\n+ * The {@link ChargeProfileUtils} utility functions for charging profiles\n+ *\n+ * @author Norbert Truchsess - initial contribution\n+ */\n+@NonNullByDefault\n+public class ChargeProfileUtils {\n+\n+    // Charging\n+    public static class TimedChannel {\n+        TimedChannel(final String time, @Nullable final String timer, final boolean hasDays) {\n+            this.time = time;\n+            this.timer = timer;\n+            this.hasDays = hasDays;\n+        }\n+\n+        public final String time;\n+        public final @Nullable String timer;\n+        public final boolean hasDays;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5NzkyNDYwNA=="}, "originalCommit": {"oid": "48af48c82562d006b6f2aa35922270f181c885ed"}, "originalPosition": 45}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzc3NjgxODMyOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/utils/ChargeProfileWrapper.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0xOVQxOToyNTo1MFrOI6OdpQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0yOFQyMjoyNjoyOVrOI_AqGw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5NzkyNTI4NQ==", "bodyText": "Should this be logged?", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r597925285", "createdAt": "2021-03-19T19:25:50Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/utils/ChargeProfileWrapper.java", "diffHunk": "@@ -0,0 +1,315 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bmwconnecteddrive.internal.utils;\n+\n+import static org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileWrapper.ProfileKey.*;\n+import static org.openhab.binding.bmwconnecteddrive.internal.utils.Constants.*;\n+\n+import java.time.DayOfWeek;\n+import java.time.LocalTime;\n+import java.time.format.DateTimeParseException;\n+import java.util.ArrayList;\n+import java.util.EnumSet;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.bmwconnecteddrive.internal.ConnectedDriveConstants.ChargingMode;\n+import org.openhab.binding.bmwconnecteddrive.internal.ConnectedDriveConstants.ChargingPreference;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.charge.ChargeProfile;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.charge.ChargingWindow;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.charge.Timer;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.charge.WeeklyPlanner;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonSyntaxException;\n+\n+/**\n+ * The {@link ChargeProfileWrapper} Wrapper for ChargeProfiles\n+ *\n+ * @author Bernd Weymann - Initial contribution\n+ * @author Norbert Truchsess - add ChargeProfileActions\n+ */\n+@NonNullByDefault\n+public class ChargeProfileWrapper {\n+\n+    private final Logger logger = LoggerFactory.getLogger(ChargeProfileWrapper.class);\n+\n+    public enum ProfileType {\n+        WEEKLY,\n+        TWO_TIMES,\n+        EMPTY\n+    }\n+\n+    public enum ProfileKey {\n+        CLIMATE,\n+        TIMER1,\n+        TIMER2,\n+        TIMER3,\n+        TIMER4,\n+        OVERRIDE,\n+        WINDOWSTART,\n+        WINDOWEND\n+    }\n+\n+    protected final ProfileType type;\n+\n+    private Optional<ChargingMode> mode = Optional.empty();\n+    private Optional<ChargingPreference> preference = Optional.empty();\n+\n+    private final Map<ProfileKey, Boolean> enabled = new HashMap<>();\n+    private final Map<ProfileKey, LocalTime> times = new HashMap<>();\n+    private final Map<ProfileKey, Set<DayOfWeek>> daysOfWeek = new HashMap<>();\n+\n+    public static Optional<ChargeProfileWrapper> fromJson(final String content) {\n+        try {\n+            final ChargeProfile cp = Converter.getGson().fromJson(content, ChargeProfile.class);\n+            if (cp != null) {\n+                return Optional.of(new ChargeProfileWrapper(cp));\n+            }\n+        } catch (JsonSyntaxException jse) {\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "48af48c82562d006b6f2aa35922270f181c885ed"}, "originalPosition": 85}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMjgwNDA3MA==", "bodyText": "Yes, maybe this wasn't done due to static function declaration where logger cannot be used. But I think static logger isn't a problem anymore, right?", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r602804070", "createdAt": "2021-03-27T23:18:50Z", "author": {"login": "weymann"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/utils/ChargeProfileWrapper.java", "diffHunk": "@@ -0,0 +1,315 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bmwconnecteddrive.internal.utils;\n+\n+import static org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileWrapper.ProfileKey.*;\n+import static org.openhab.binding.bmwconnecteddrive.internal.utils.Constants.*;\n+\n+import java.time.DayOfWeek;\n+import java.time.LocalTime;\n+import java.time.format.DateTimeParseException;\n+import java.util.ArrayList;\n+import java.util.EnumSet;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.bmwconnecteddrive.internal.ConnectedDriveConstants.ChargingMode;\n+import org.openhab.binding.bmwconnecteddrive.internal.ConnectedDriveConstants.ChargingPreference;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.charge.ChargeProfile;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.charge.ChargingWindow;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.charge.Timer;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.charge.WeeklyPlanner;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonSyntaxException;\n+\n+/**\n+ * The {@link ChargeProfileWrapper} Wrapper for ChargeProfiles\n+ *\n+ * @author Bernd Weymann - Initial contribution\n+ * @author Norbert Truchsess - add ChargeProfileActions\n+ */\n+@NonNullByDefault\n+public class ChargeProfileWrapper {\n+\n+    private final Logger logger = LoggerFactory.getLogger(ChargeProfileWrapper.class);\n+\n+    public enum ProfileType {\n+        WEEKLY,\n+        TWO_TIMES,\n+        EMPTY\n+    }\n+\n+    public enum ProfileKey {\n+        CLIMATE,\n+        TIMER1,\n+        TIMER2,\n+        TIMER3,\n+        TIMER4,\n+        OVERRIDE,\n+        WINDOWSTART,\n+        WINDOWEND\n+    }\n+\n+    protected final ProfileType type;\n+\n+    private Optional<ChargingMode> mode = Optional.empty();\n+    private Optional<ChargingPreference> preference = Optional.empty();\n+\n+    private final Map<ProfileKey, Boolean> enabled = new HashMap<>();\n+    private final Map<ProfileKey, LocalTime> times = new HashMap<>();\n+    private final Map<ProfileKey, Set<DayOfWeek>> daysOfWeek = new HashMap<>();\n+\n+    public static Optional<ChargeProfileWrapper> fromJson(final String content) {\n+        try {\n+            final ChargeProfile cp = Converter.getGson().fromJson(content, ChargeProfile.class);\n+            if (cp != null) {\n+                return Optional.of(new ChargeProfileWrapper(cp));\n+            }\n+        } catch (JsonSyntaxException jse) {\n+        }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5NzkyNTI4NQ=="}, "originalCommit": {"oid": "48af48c82562d006b6f2aa35922270f181c885ed"}, "originalPosition": 85}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMjg1NTY0Ng==", "bodyText": "If you need to access the logger in a static way, it can be static.", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r602855646", "createdAt": "2021-03-28T09:29:52Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/utils/ChargeProfileWrapper.java", "diffHunk": "@@ -0,0 +1,315 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bmwconnecteddrive.internal.utils;\n+\n+import static org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileWrapper.ProfileKey.*;\n+import static org.openhab.binding.bmwconnecteddrive.internal.utils.Constants.*;\n+\n+import java.time.DayOfWeek;\n+import java.time.LocalTime;\n+import java.time.format.DateTimeParseException;\n+import java.util.ArrayList;\n+import java.util.EnumSet;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.bmwconnecteddrive.internal.ConnectedDriveConstants.ChargingMode;\n+import org.openhab.binding.bmwconnecteddrive.internal.ConnectedDriveConstants.ChargingPreference;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.charge.ChargeProfile;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.charge.ChargingWindow;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.charge.Timer;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.charge.WeeklyPlanner;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonSyntaxException;\n+\n+/**\n+ * The {@link ChargeProfileWrapper} Wrapper for ChargeProfiles\n+ *\n+ * @author Bernd Weymann - Initial contribution\n+ * @author Norbert Truchsess - add ChargeProfileActions\n+ */\n+@NonNullByDefault\n+public class ChargeProfileWrapper {\n+\n+    private final Logger logger = LoggerFactory.getLogger(ChargeProfileWrapper.class);\n+\n+    public enum ProfileType {\n+        WEEKLY,\n+        TWO_TIMES,\n+        EMPTY\n+    }\n+\n+    public enum ProfileKey {\n+        CLIMATE,\n+        TIMER1,\n+        TIMER2,\n+        TIMER3,\n+        TIMER4,\n+        OVERRIDE,\n+        WINDOWSTART,\n+        WINDOWEND\n+    }\n+\n+    protected final ProfileType type;\n+\n+    private Optional<ChargingMode> mode = Optional.empty();\n+    private Optional<ChargingPreference> preference = Optional.empty();\n+\n+    private final Map<ProfileKey, Boolean> enabled = new HashMap<>();\n+    private final Map<ProfileKey, LocalTime> times = new HashMap<>();\n+    private final Map<ProfileKey, Set<DayOfWeek>> daysOfWeek = new HashMap<>();\n+\n+    public static Optional<ChargeProfileWrapper> fromJson(final String content) {\n+        try {\n+            final ChargeProfile cp = Converter.getGson().fromJson(content, ChargeProfile.class);\n+            if (cp != null) {\n+                return Optional.of(new ChargeProfileWrapper(cp));\n+            }\n+        } catch (JsonSyntaxException jse) {\n+        }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5NzkyNTI4NQ=="}, "originalCommit": {"oid": "48af48c82562d006b6f2aa35922270f181c885ed"}, "originalPosition": 85}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMjk0MTk3OQ==", "bodyText": "ok, this is already in", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r602941979", "createdAt": "2021-03-28T22:26:29Z", "author": {"login": "weymann"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/utils/ChargeProfileWrapper.java", "diffHunk": "@@ -0,0 +1,315 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bmwconnecteddrive.internal.utils;\n+\n+import static org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileWrapper.ProfileKey.*;\n+import static org.openhab.binding.bmwconnecteddrive.internal.utils.Constants.*;\n+\n+import java.time.DayOfWeek;\n+import java.time.LocalTime;\n+import java.time.format.DateTimeParseException;\n+import java.util.ArrayList;\n+import java.util.EnumSet;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.bmwconnecteddrive.internal.ConnectedDriveConstants.ChargingMode;\n+import org.openhab.binding.bmwconnecteddrive.internal.ConnectedDriveConstants.ChargingPreference;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.charge.ChargeProfile;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.charge.ChargingWindow;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.charge.Timer;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.charge.WeeklyPlanner;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonSyntaxException;\n+\n+/**\n+ * The {@link ChargeProfileWrapper} Wrapper for ChargeProfiles\n+ *\n+ * @author Bernd Weymann - Initial contribution\n+ * @author Norbert Truchsess - add ChargeProfileActions\n+ */\n+@NonNullByDefault\n+public class ChargeProfileWrapper {\n+\n+    private final Logger logger = LoggerFactory.getLogger(ChargeProfileWrapper.class);\n+\n+    public enum ProfileType {\n+        WEEKLY,\n+        TWO_TIMES,\n+        EMPTY\n+    }\n+\n+    public enum ProfileKey {\n+        CLIMATE,\n+        TIMER1,\n+        TIMER2,\n+        TIMER3,\n+        TIMER4,\n+        OVERRIDE,\n+        WINDOWSTART,\n+        WINDOWEND\n+    }\n+\n+    protected final ProfileType type;\n+\n+    private Optional<ChargingMode> mode = Optional.empty();\n+    private Optional<ChargingPreference> preference = Optional.empty();\n+\n+    private final Map<ProfileKey, Boolean> enabled = new HashMap<>();\n+    private final Map<ProfileKey, LocalTime> times = new HashMap<>();\n+    private final Map<ProfileKey, Set<DayOfWeek>> daysOfWeek = new HashMap<>();\n+\n+    public static Optional<ChargeProfileWrapper> fromJson(final String content) {\n+        try {\n+            final ChargeProfile cp = Converter.getGson().fromJson(content, ChargeProfile.class);\n+            if (cp != null) {\n+                return Optional.of(new ChargeProfileWrapper(cp));\n+            }\n+        } catch (JsonSyntaxException jse) {\n+        }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5NzkyNTI4NQ=="}, "originalCommit": {"oid": "48af48c82562d006b6f2aa35922270f181c885ed"}, "originalPosition": 85}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzc3NjgzNTM1OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/utils/Converter.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0xOVQxOTozMDo0MFrOI6Onlg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0yN1QyMzo0MDo0OFrOI-4Weg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5NzkyNzgzMA==", "bodyText": "You could return UnDefType.UNDEF instead of -1", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r597927830", "createdAt": "2021-03-19T19:30:40Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/utils/Converter.java", "diffHunk": "@@ -0,0 +1,204 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bmwconnecteddrive.internal.utils;\n+\n+import java.time.LocalDateTime;\n+import java.time.ZoneId;\n+import java.time.ZonedDateTime;\n+import java.time.format.DateTimeFormatter;\n+import java.time.format.DateTimeParseException;\n+import java.util.Optional;\n+\n+import javax.measure.quantity.Length;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.core.i18n.TimeZoneProvider;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.unit.ImperialUnits;\n+\n+import com.google.gson.Gson;\n+\n+/**\n+ * The {@link Converter} Conversion Helpers\n+ *\n+ * @author Bernd Weymann - Initial contribution\n+ */\n+@NonNullByDefault\n+public class Converter {\n+    public static final DateTimeFormatter SERVICE_DATE_INPUT_PATTERN = DateTimeFormatter.ofPattern(\"yyyy-MM-dd\");\n+    public static final DateTimeFormatter SERVICE_DATE_OUTPUT_PATTERN = DateTimeFormatter.ofPattern(\"MMM yyyy\");\n+\n+    public static final String LOCAL_DATE_INPUT_PATTERN_STRING = \"dd.MM.yyyy HH:mm\";\n+    public static final DateTimeFormatter LOCAL_DATE_INPUT_PATTERN = DateTimeFormatter\n+            .ofPattern(LOCAL_DATE_INPUT_PATTERN_STRING);\n+\n+    public static final String DATE_INPUT_PATTERN_STRING = \"yyyy-MM-dd'T'HH:mm:ss\";\n+    public static final DateTimeFormatter DATE_INPUT_PATTERN = DateTimeFormatter.ofPattern(DATE_INPUT_PATTERN_STRING);\n+\n+    public static final String DATE_INPUT_ZONE_PATTERN_STRING = \"yyyy-MM-dd'T'HH:mm:ssZ\";\n+    public static final DateTimeFormatter DATE_INPUT_ZONE_PATTERN = DateTimeFormatter\n+            .ofPattern(DATE_INPUT_ZONE_PATTERN_STRING);\n+\n+    public static final DateTimeFormatter DATE_OUTPUT_PATTERN = DateTimeFormatter.ofPattern(\"dd.MM.yyyy HH:mm\");\n+\n+    private static final Gson GSON = new Gson();\n+    private static final double SCALE = 10;\n+    public static final double MILES_TO_KM_RATIO = 1.60934;\n+    private static final QuantityType<Length> UNDEF_MILES = QuantityType.valueOf(-1, ImperialUnits.MILE);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "48af48c82562d006b6f2aa35922270f181c885ed"}, "originalPosition": 58}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMjgwNTg4Mg==", "bodyText": "Done", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r602805882", "createdAt": "2021-03-27T23:40:48Z", "author": {"login": "weymann"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/utils/Converter.java", "diffHunk": "@@ -0,0 +1,204 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bmwconnecteddrive.internal.utils;\n+\n+import java.time.LocalDateTime;\n+import java.time.ZoneId;\n+import java.time.ZonedDateTime;\n+import java.time.format.DateTimeFormatter;\n+import java.time.format.DateTimeParseException;\n+import java.util.Optional;\n+\n+import javax.measure.quantity.Length;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.core.i18n.TimeZoneProvider;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.unit.ImperialUnits;\n+\n+import com.google.gson.Gson;\n+\n+/**\n+ * The {@link Converter} Conversion Helpers\n+ *\n+ * @author Bernd Weymann - Initial contribution\n+ */\n+@NonNullByDefault\n+public class Converter {\n+    public static final DateTimeFormatter SERVICE_DATE_INPUT_PATTERN = DateTimeFormatter.ofPattern(\"yyyy-MM-dd\");\n+    public static final DateTimeFormatter SERVICE_DATE_OUTPUT_PATTERN = DateTimeFormatter.ofPattern(\"MMM yyyy\");\n+\n+    public static final String LOCAL_DATE_INPUT_PATTERN_STRING = \"dd.MM.yyyy HH:mm\";\n+    public static final DateTimeFormatter LOCAL_DATE_INPUT_PATTERN = DateTimeFormatter\n+            .ofPattern(LOCAL_DATE_INPUT_PATTERN_STRING);\n+\n+    public static final String DATE_INPUT_PATTERN_STRING = \"yyyy-MM-dd'T'HH:mm:ss\";\n+    public static final DateTimeFormatter DATE_INPUT_PATTERN = DateTimeFormatter.ofPattern(DATE_INPUT_PATTERN_STRING);\n+\n+    public static final String DATE_INPUT_ZONE_PATTERN_STRING = \"yyyy-MM-dd'T'HH:mm:ssZ\";\n+    public static final DateTimeFormatter DATE_INPUT_ZONE_PATTERN = DateTimeFormatter\n+            .ofPattern(DATE_INPUT_ZONE_PATTERN_STRING);\n+\n+    public static final DateTimeFormatter DATE_OUTPUT_PATTERN = DateTimeFormatter.ofPattern(\"dd.MM.yyyy HH:mm\");\n+\n+    private static final Gson GSON = new Gson();\n+    private static final double SCALE = 10;\n+    public static final double MILES_TO_KM_RATIO = 1.60934;\n+    private static final QuantityType<Length> UNDEF_MILES = QuantityType.valueOf(-1, ImperialUnits.MILE);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5NzkyNzgzMA=="}, "originalCommit": {"oid": "48af48c82562d006b6f2aa35922270f181c885ed"}, "originalPosition": 58}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzc3Njg0NjgzOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/utils/Converter.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0xOVQxOTozNDoxNVrOI6OusQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0yN1QyMzo0MTowNFrOI-4WgQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5NzkyOTY0OQ==", "bodyText": "To be able to return UnDefType.UNDEF.\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public static QuantityType<Length> getMiles(QuantityType<Length> qtLength) {\n          \n          \n            \n                public static State getMiles(QuantityType<Length> qtLength) {", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r597929649", "createdAt": "2021-03-19T19:34:15Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/utils/Converter.java", "diffHunk": "@@ -0,0 +1,204 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bmwconnecteddrive.internal.utils;\n+\n+import java.time.LocalDateTime;\n+import java.time.ZoneId;\n+import java.time.ZonedDateTime;\n+import java.time.format.DateTimeFormatter;\n+import java.time.format.DateTimeParseException;\n+import java.util.Optional;\n+\n+import javax.measure.quantity.Length;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.core.i18n.TimeZoneProvider;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.unit.ImperialUnits;\n+\n+import com.google.gson.Gson;\n+\n+/**\n+ * The {@link Converter} Conversion Helpers\n+ *\n+ * @author Bernd Weymann - Initial contribution\n+ */\n+@NonNullByDefault\n+public class Converter {\n+    public static final DateTimeFormatter SERVICE_DATE_INPUT_PATTERN = DateTimeFormatter.ofPattern(\"yyyy-MM-dd\");\n+    public static final DateTimeFormatter SERVICE_DATE_OUTPUT_PATTERN = DateTimeFormatter.ofPattern(\"MMM yyyy\");\n+\n+    public static final String LOCAL_DATE_INPUT_PATTERN_STRING = \"dd.MM.yyyy HH:mm\";\n+    public static final DateTimeFormatter LOCAL_DATE_INPUT_PATTERN = DateTimeFormatter\n+            .ofPattern(LOCAL_DATE_INPUT_PATTERN_STRING);\n+\n+    public static final String DATE_INPUT_PATTERN_STRING = \"yyyy-MM-dd'T'HH:mm:ss\";\n+    public static final DateTimeFormatter DATE_INPUT_PATTERN = DateTimeFormatter.ofPattern(DATE_INPUT_PATTERN_STRING);\n+\n+    public static final String DATE_INPUT_ZONE_PATTERN_STRING = \"yyyy-MM-dd'T'HH:mm:ssZ\";\n+    public static final DateTimeFormatter DATE_INPUT_ZONE_PATTERN = DateTimeFormatter\n+            .ofPattern(DATE_INPUT_ZONE_PATTERN_STRING);\n+\n+    public static final DateTimeFormatter DATE_OUTPUT_PATTERN = DateTimeFormatter.ofPattern(\"dd.MM.yyyy HH:mm\");\n+\n+    private static final Gson GSON = new Gson();\n+    private static final double SCALE = 10;\n+    public static final double MILES_TO_KM_RATIO = 1.60934;\n+    private static final QuantityType<Length> UNDEF_MILES = QuantityType.valueOf(-1, ImperialUnits.MILE);\n+    private static final String SPLIT_HYPHEN = \"-\";\n+    private static final String SPLIT_BRACKET = \"\\\\(\";\n+\n+    public static Optional<TimeZoneProvider> timeZoneProvider = Optional.empty();\n+\n+    public static double round(double value) {\n+        return Math.round(value * SCALE) / SCALE;\n+    }\n+\n+    public static String getLocalDateTimeWithoutOffest(@Nullable String input) {\n+        if (input == null) {\n+            return Constants.NULL_DATE;\n+        }\n+        LocalDateTime ldt;\n+        if (input.contains(Constants.PLUS)) {\n+            ldt = LocalDateTime.parse(input, Converter.DATE_INPUT_ZONE_PATTERN);\n+        } else {\n+            ldt = LocalDateTime.parse(input, Converter.DATE_INPUT_PATTERN);\n+        }\n+        return ldt.format(Converter.DATE_INPUT_PATTERN);\n+    }\n+\n+    public static String getLocalDateTime(@Nullable String input) {\n+        if (input == null) {\n+            return Constants.NULL_DATE;\n+        }\n+\n+        LocalDateTime ldt;\n+        if (input.contains(Constants.PLUS)) {\n+            ldt = LocalDateTime.parse(input, Converter.DATE_INPUT_ZONE_PATTERN);\n+        } else {\n+            try {\n+                ldt = LocalDateTime.parse(input, Converter.DATE_INPUT_PATTERN);\n+            } catch (DateTimeParseException dtpe) {\n+                ldt = LocalDateTime.parse(input, Converter.LOCAL_DATE_INPUT_PATTERN);\n+            }\n+        }\n+        ZonedDateTime zdtUTC = ldt.atZone(ZoneId.of(\"UTC\"));\n+        ZonedDateTime zdtLZ;\n+        zdtLZ = zdtUTC.withZoneSameInstant(ZoneId.systemDefault());\n+        if (timeZoneProvider.isPresent()) {\n+            zdtLZ = zdtUTC.withZoneSameInstant(timeZoneProvider.get().getTimeZone());\n+        } else {\n+            zdtLZ = zdtUTC.withZoneSameInstant(ZoneId.systemDefault());\n+        }\n+        return zdtLZ.format(Converter.DATE_INPUT_PATTERN);\n+    }\n+\n+    public static void setTimeZoneProvider(TimeZoneProvider tzp) {\n+        timeZoneProvider = Optional.of(tzp);\n+    }\n+\n+    public static String toTitleCase(@Nullable String input) {\n+        if (input == null) {\n+            return toTitleCase(Constants.UNDEF);\n+        } else {\n+            String lower = input.replaceAll(Constants.UNDERLINE, Constants.SPACE).toLowerCase();\n+            String converted = toTitleCase(lower, Constants.SPACE);\n+            converted = toTitleCase(converted, SPLIT_HYPHEN);\n+            converted = toTitleCase(converted, SPLIT_BRACKET);\n+            return converted;\n+        }\n+    }\n+\n+    private static String toTitleCase(String input, String splitter) {\n+        String[] arr = input.split(splitter);\n+        StringBuilder sb = new StringBuilder();\n+        for (int i = 0; i < arr.length; i++) {\n+            if (i > 0) {\n+                sb.append(splitter.replaceAll(\"\\\\\\\\\", Constants.EMPTY));\n+            }\n+            sb.append(Character.toUpperCase(arr[i].charAt(0))).append(arr[i].substring(1));\n+        }\n+        return sb.toString().trim();\n+    }\n+\n+    public static String capitalizeFirst(String str) {\n+        return str.substring(0, 1).toUpperCase() + str.substring(1);\n+    }\n+\n+    public static Gson getGson() {\n+        return GSON;\n+    }\n+\n+    /**\n+     * Measure distance between 2 coordinates\n+     *\n+     * @param sourceLatitude\n+     * @param sourceLongitude\n+     * @param destinationLatitude\n+     * @param destinationLongitude\n+     * @return distance\n+     */\n+    public static double measureDistance(double sourceLatitude, double sourceLongitude, double destinationLatitude,\n+            double destinationLongitude) {\n+        double earthRadius = 6378.137; // Radius of earth in KM\n+        double dLat = destinationLatitude * Math.PI / 180 - sourceLatitude * Math.PI / 180;\n+        double dLon = destinationLongitude * Math.PI / 180 - sourceLongitude * Math.PI / 180;\n+        double a = Math.sin(dLat / 2) * Math.sin(dLat / 2) + Math.cos(sourceLatitude * Math.PI / 180)\n+                * Math.cos(destinationLatitude * Math.PI / 180) * Math.sin(dLon / 2) * Math.sin(dLon / 2);\n+        double c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));\n+        return earthRadius * c;\n+    }\n+\n+    /**\n+     * Easy function but there's some measures behind:\n+     * Guessing the range of the Vehicle on Map. If you can drive x kilometers with your Vehicle it's not feasible to\n+     * project this x km Radius on Map. The roads to be taken are causing some overhead because they are not a straight\n+     * line from Location A to B.\n+     * I've taken some measurements to calculate the overhead factor based on Google Maps\n+     * Berlin - Dresden: Road Distance: 193 air-line Distance 167 = Factor 87%\n+     * Kassel - Frankfurt: Road Distance: 199 air-line Distance 143 = Factor 72%\n+     * After measuring more distances you'll find out that the outcome is between 70% and 90%. So\n+     *\n+     * This depends also on the roads of a concrete route but this is only a guess without any Route Navigation behind\n+     *\n+     * In future it's foreseen to replace this with BMW RangeMap Service which isn't running at the moment.\n+     *\n+     * @param range\n+     * @return mapping from air-line distance to \"real road\" distance\n+     */\n+    public static double guessRangeRadius(double range) {\n+        return range * 0.8;\n+    }\n+\n+    public static QuantityType<Length> getMiles(QuantityType<Length> qtLength) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "48af48c82562d006b6f2aa35922270f181c885ed"}, "originalPosition": 184}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMjgwNTg4OQ==", "bodyText": "Done", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r602805889", "createdAt": "2021-03-27T23:41:04Z", "author": {"login": "weymann"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/utils/Converter.java", "diffHunk": "@@ -0,0 +1,204 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bmwconnecteddrive.internal.utils;\n+\n+import java.time.LocalDateTime;\n+import java.time.ZoneId;\n+import java.time.ZonedDateTime;\n+import java.time.format.DateTimeFormatter;\n+import java.time.format.DateTimeParseException;\n+import java.util.Optional;\n+\n+import javax.measure.quantity.Length;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.core.i18n.TimeZoneProvider;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.unit.ImperialUnits;\n+\n+import com.google.gson.Gson;\n+\n+/**\n+ * The {@link Converter} Conversion Helpers\n+ *\n+ * @author Bernd Weymann - Initial contribution\n+ */\n+@NonNullByDefault\n+public class Converter {\n+    public static final DateTimeFormatter SERVICE_DATE_INPUT_PATTERN = DateTimeFormatter.ofPattern(\"yyyy-MM-dd\");\n+    public static final DateTimeFormatter SERVICE_DATE_OUTPUT_PATTERN = DateTimeFormatter.ofPattern(\"MMM yyyy\");\n+\n+    public static final String LOCAL_DATE_INPUT_PATTERN_STRING = \"dd.MM.yyyy HH:mm\";\n+    public static final DateTimeFormatter LOCAL_DATE_INPUT_PATTERN = DateTimeFormatter\n+            .ofPattern(LOCAL_DATE_INPUT_PATTERN_STRING);\n+\n+    public static final String DATE_INPUT_PATTERN_STRING = \"yyyy-MM-dd'T'HH:mm:ss\";\n+    public static final DateTimeFormatter DATE_INPUT_PATTERN = DateTimeFormatter.ofPattern(DATE_INPUT_PATTERN_STRING);\n+\n+    public static final String DATE_INPUT_ZONE_PATTERN_STRING = \"yyyy-MM-dd'T'HH:mm:ssZ\";\n+    public static final DateTimeFormatter DATE_INPUT_ZONE_PATTERN = DateTimeFormatter\n+            .ofPattern(DATE_INPUT_ZONE_PATTERN_STRING);\n+\n+    public static final DateTimeFormatter DATE_OUTPUT_PATTERN = DateTimeFormatter.ofPattern(\"dd.MM.yyyy HH:mm\");\n+\n+    private static final Gson GSON = new Gson();\n+    private static final double SCALE = 10;\n+    public static final double MILES_TO_KM_RATIO = 1.60934;\n+    private static final QuantityType<Length> UNDEF_MILES = QuantityType.valueOf(-1, ImperialUnits.MILE);\n+    private static final String SPLIT_HYPHEN = \"-\";\n+    private static final String SPLIT_BRACKET = \"\\\\(\";\n+\n+    public static Optional<TimeZoneProvider> timeZoneProvider = Optional.empty();\n+\n+    public static double round(double value) {\n+        return Math.round(value * SCALE) / SCALE;\n+    }\n+\n+    public static String getLocalDateTimeWithoutOffest(@Nullable String input) {\n+        if (input == null) {\n+            return Constants.NULL_DATE;\n+        }\n+        LocalDateTime ldt;\n+        if (input.contains(Constants.PLUS)) {\n+            ldt = LocalDateTime.parse(input, Converter.DATE_INPUT_ZONE_PATTERN);\n+        } else {\n+            ldt = LocalDateTime.parse(input, Converter.DATE_INPUT_PATTERN);\n+        }\n+        return ldt.format(Converter.DATE_INPUT_PATTERN);\n+    }\n+\n+    public static String getLocalDateTime(@Nullable String input) {\n+        if (input == null) {\n+            return Constants.NULL_DATE;\n+        }\n+\n+        LocalDateTime ldt;\n+        if (input.contains(Constants.PLUS)) {\n+            ldt = LocalDateTime.parse(input, Converter.DATE_INPUT_ZONE_PATTERN);\n+        } else {\n+            try {\n+                ldt = LocalDateTime.parse(input, Converter.DATE_INPUT_PATTERN);\n+            } catch (DateTimeParseException dtpe) {\n+                ldt = LocalDateTime.parse(input, Converter.LOCAL_DATE_INPUT_PATTERN);\n+            }\n+        }\n+        ZonedDateTime zdtUTC = ldt.atZone(ZoneId.of(\"UTC\"));\n+        ZonedDateTime zdtLZ;\n+        zdtLZ = zdtUTC.withZoneSameInstant(ZoneId.systemDefault());\n+        if (timeZoneProvider.isPresent()) {\n+            zdtLZ = zdtUTC.withZoneSameInstant(timeZoneProvider.get().getTimeZone());\n+        } else {\n+            zdtLZ = zdtUTC.withZoneSameInstant(ZoneId.systemDefault());\n+        }\n+        return zdtLZ.format(Converter.DATE_INPUT_PATTERN);\n+    }\n+\n+    public static void setTimeZoneProvider(TimeZoneProvider tzp) {\n+        timeZoneProvider = Optional.of(tzp);\n+    }\n+\n+    public static String toTitleCase(@Nullable String input) {\n+        if (input == null) {\n+            return toTitleCase(Constants.UNDEF);\n+        } else {\n+            String lower = input.replaceAll(Constants.UNDERLINE, Constants.SPACE).toLowerCase();\n+            String converted = toTitleCase(lower, Constants.SPACE);\n+            converted = toTitleCase(converted, SPLIT_HYPHEN);\n+            converted = toTitleCase(converted, SPLIT_BRACKET);\n+            return converted;\n+        }\n+    }\n+\n+    private static String toTitleCase(String input, String splitter) {\n+        String[] arr = input.split(splitter);\n+        StringBuilder sb = new StringBuilder();\n+        for (int i = 0; i < arr.length; i++) {\n+            if (i > 0) {\n+                sb.append(splitter.replaceAll(\"\\\\\\\\\", Constants.EMPTY));\n+            }\n+            sb.append(Character.toUpperCase(arr[i].charAt(0))).append(arr[i].substring(1));\n+        }\n+        return sb.toString().trim();\n+    }\n+\n+    public static String capitalizeFirst(String str) {\n+        return str.substring(0, 1).toUpperCase() + str.substring(1);\n+    }\n+\n+    public static Gson getGson() {\n+        return GSON;\n+    }\n+\n+    /**\n+     * Measure distance between 2 coordinates\n+     *\n+     * @param sourceLatitude\n+     * @param sourceLongitude\n+     * @param destinationLatitude\n+     * @param destinationLongitude\n+     * @return distance\n+     */\n+    public static double measureDistance(double sourceLatitude, double sourceLongitude, double destinationLatitude,\n+            double destinationLongitude) {\n+        double earthRadius = 6378.137; // Radius of earth in KM\n+        double dLat = destinationLatitude * Math.PI / 180 - sourceLatitude * Math.PI / 180;\n+        double dLon = destinationLongitude * Math.PI / 180 - sourceLongitude * Math.PI / 180;\n+        double a = Math.sin(dLat / 2) * Math.sin(dLat / 2) + Math.cos(sourceLatitude * Math.PI / 180)\n+                * Math.cos(destinationLatitude * Math.PI / 180) * Math.sin(dLon / 2) * Math.sin(dLon / 2);\n+        double c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));\n+        return earthRadius * c;\n+    }\n+\n+    /**\n+     * Easy function but there's some measures behind:\n+     * Guessing the range of the Vehicle on Map. If you can drive x kilometers with your Vehicle it's not feasible to\n+     * project this x km Radius on Map. The roads to be taken are causing some overhead because they are not a straight\n+     * line from Location A to B.\n+     * I've taken some measurements to calculate the overhead factor based on Google Maps\n+     * Berlin - Dresden: Road Distance: 193 air-line Distance 167 = Factor 87%\n+     * Kassel - Frankfurt: Road Distance: 199 air-line Distance 143 = Factor 72%\n+     * After measuring more distances you'll find out that the outcome is between 70% and 90%. So\n+     *\n+     * This depends also on the roads of a concrete route but this is only a guess without any Route Navigation behind\n+     *\n+     * In future it's foreseen to replace this with BMW RangeMap Service which isn't running at the moment.\n+     *\n+     * @param range\n+     * @return mapping from air-line distance to \"real road\" distance\n+     */\n+    public static double guessRangeRadius(double range) {\n+        return range * 0.8;\n+    }\n+\n+    public static QuantityType<Length> getMiles(QuantityType<Length> qtLength) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5NzkyOTY0OQ=="}, "originalCommit": {"oid": "48af48c82562d006b6f2aa35922270f181c885ed"}, "originalPosition": 184}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzc3Njg1MjEzOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/utils/Converter.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0xOVQxOTozNTo0N1rOI6OxvQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0yOFQwMDowMzo1M1rOI-4djg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5NzkzMDQyOQ==", "bodyText": "If it can't be converted, there's something fishy about it. You could log it and return UNDEF.", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r597930429", "createdAt": "2021-03-19T19:35:47Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/utils/Converter.java", "diffHunk": "@@ -0,0 +1,204 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bmwconnecteddrive.internal.utils;\n+\n+import java.time.LocalDateTime;\n+import java.time.ZoneId;\n+import java.time.ZonedDateTime;\n+import java.time.format.DateTimeFormatter;\n+import java.time.format.DateTimeParseException;\n+import java.util.Optional;\n+\n+import javax.measure.quantity.Length;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.core.i18n.TimeZoneProvider;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.unit.ImperialUnits;\n+\n+import com.google.gson.Gson;\n+\n+/**\n+ * The {@link Converter} Conversion Helpers\n+ *\n+ * @author Bernd Weymann - Initial contribution\n+ */\n+@NonNullByDefault\n+public class Converter {\n+    public static final DateTimeFormatter SERVICE_DATE_INPUT_PATTERN = DateTimeFormatter.ofPattern(\"yyyy-MM-dd\");\n+    public static final DateTimeFormatter SERVICE_DATE_OUTPUT_PATTERN = DateTimeFormatter.ofPattern(\"MMM yyyy\");\n+\n+    public static final String LOCAL_DATE_INPUT_PATTERN_STRING = \"dd.MM.yyyy HH:mm\";\n+    public static final DateTimeFormatter LOCAL_DATE_INPUT_PATTERN = DateTimeFormatter\n+            .ofPattern(LOCAL_DATE_INPUT_PATTERN_STRING);\n+\n+    public static final String DATE_INPUT_PATTERN_STRING = \"yyyy-MM-dd'T'HH:mm:ss\";\n+    public static final DateTimeFormatter DATE_INPUT_PATTERN = DateTimeFormatter.ofPattern(DATE_INPUT_PATTERN_STRING);\n+\n+    public static final String DATE_INPUT_ZONE_PATTERN_STRING = \"yyyy-MM-dd'T'HH:mm:ssZ\";\n+    public static final DateTimeFormatter DATE_INPUT_ZONE_PATTERN = DateTimeFormatter\n+            .ofPattern(DATE_INPUT_ZONE_PATTERN_STRING);\n+\n+    public static final DateTimeFormatter DATE_OUTPUT_PATTERN = DateTimeFormatter.ofPattern(\"dd.MM.yyyy HH:mm\");\n+\n+    private static final Gson GSON = new Gson();\n+    private static final double SCALE = 10;\n+    public static final double MILES_TO_KM_RATIO = 1.60934;\n+    private static final QuantityType<Length> UNDEF_MILES = QuantityType.valueOf(-1, ImperialUnits.MILE);\n+    private static final String SPLIT_HYPHEN = \"-\";\n+    private static final String SPLIT_BRACKET = \"\\\\(\";\n+\n+    public static Optional<TimeZoneProvider> timeZoneProvider = Optional.empty();\n+\n+    public static double round(double value) {\n+        return Math.round(value * SCALE) / SCALE;\n+    }\n+\n+    public static String getLocalDateTimeWithoutOffest(@Nullable String input) {\n+        if (input == null) {\n+            return Constants.NULL_DATE;\n+        }\n+        LocalDateTime ldt;\n+        if (input.contains(Constants.PLUS)) {\n+            ldt = LocalDateTime.parse(input, Converter.DATE_INPUT_ZONE_PATTERN);\n+        } else {\n+            ldt = LocalDateTime.parse(input, Converter.DATE_INPUT_PATTERN);\n+        }\n+        return ldt.format(Converter.DATE_INPUT_PATTERN);\n+    }\n+\n+    public static String getLocalDateTime(@Nullable String input) {\n+        if (input == null) {\n+            return Constants.NULL_DATE;\n+        }\n+\n+        LocalDateTime ldt;\n+        if (input.contains(Constants.PLUS)) {\n+            ldt = LocalDateTime.parse(input, Converter.DATE_INPUT_ZONE_PATTERN);\n+        } else {\n+            try {\n+                ldt = LocalDateTime.parse(input, Converter.DATE_INPUT_PATTERN);\n+            } catch (DateTimeParseException dtpe) {\n+                ldt = LocalDateTime.parse(input, Converter.LOCAL_DATE_INPUT_PATTERN);\n+            }\n+        }\n+        ZonedDateTime zdtUTC = ldt.atZone(ZoneId.of(\"UTC\"));\n+        ZonedDateTime zdtLZ;\n+        zdtLZ = zdtUTC.withZoneSameInstant(ZoneId.systemDefault());\n+        if (timeZoneProvider.isPresent()) {\n+            zdtLZ = zdtUTC.withZoneSameInstant(timeZoneProvider.get().getTimeZone());\n+        } else {\n+            zdtLZ = zdtUTC.withZoneSameInstant(ZoneId.systemDefault());\n+        }\n+        return zdtLZ.format(Converter.DATE_INPUT_PATTERN);\n+    }\n+\n+    public static void setTimeZoneProvider(TimeZoneProvider tzp) {\n+        timeZoneProvider = Optional.of(tzp);\n+    }\n+\n+    public static String toTitleCase(@Nullable String input) {\n+        if (input == null) {\n+            return toTitleCase(Constants.UNDEF);\n+        } else {\n+            String lower = input.replaceAll(Constants.UNDERLINE, Constants.SPACE).toLowerCase();\n+            String converted = toTitleCase(lower, Constants.SPACE);\n+            converted = toTitleCase(converted, SPLIT_HYPHEN);\n+            converted = toTitleCase(converted, SPLIT_BRACKET);\n+            return converted;\n+        }\n+    }\n+\n+    private static String toTitleCase(String input, String splitter) {\n+        String[] arr = input.split(splitter);\n+        StringBuilder sb = new StringBuilder();\n+        for (int i = 0; i < arr.length; i++) {\n+            if (i > 0) {\n+                sb.append(splitter.replaceAll(\"\\\\\\\\\", Constants.EMPTY));\n+            }\n+            sb.append(Character.toUpperCase(arr[i].charAt(0))).append(arr[i].substring(1));\n+        }\n+        return sb.toString().trim();\n+    }\n+\n+    public static String capitalizeFirst(String str) {\n+        return str.substring(0, 1).toUpperCase() + str.substring(1);\n+    }\n+\n+    public static Gson getGson() {\n+        return GSON;\n+    }\n+\n+    /**\n+     * Measure distance between 2 coordinates\n+     *\n+     * @param sourceLatitude\n+     * @param sourceLongitude\n+     * @param destinationLatitude\n+     * @param destinationLongitude\n+     * @return distance\n+     */\n+    public static double measureDistance(double sourceLatitude, double sourceLongitude, double destinationLatitude,\n+            double destinationLongitude) {\n+        double earthRadius = 6378.137; // Radius of earth in KM\n+        double dLat = destinationLatitude * Math.PI / 180 - sourceLatitude * Math.PI / 180;\n+        double dLon = destinationLongitude * Math.PI / 180 - sourceLongitude * Math.PI / 180;\n+        double a = Math.sin(dLat / 2) * Math.sin(dLat / 2) + Math.cos(sourceLatitude * Math.PI / 180)\n+                * Math.cos(destinationLatitude * Math.PI / 180) * Math.sin(dLon / 2) * Math.sin(dLon / 2);\n+        double c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));\n+        return earthRadius * c;\n+    }\n+\n+    /**\n+     * Easy function but there's some measures behind:\n+     * Guessing the range of the Vehicle on Map. If you can drive x kilometers with your Vehicle it's not feasible to\n+     * project this x km Radius on Map. The roads to be taken are causing some overhead because they are not a straight\n+     * line from Location A to B.\n+     * I've taken some measurements to calculate the overhead factor based on Google Maps\n+     * Berlin - Dresden: Road Distance: 193 air-line Distance 167 = Factor 87%\n+     * Kassel - Frankfurt: Road Distance: 199 air-line Distance 143 = Factor 72%\n+     * After measuring more distances you'll find out that the outcome is between 70% and 90%. So\n+     *\n+     * This depends also on the roads of a concrete route but this is only a guess without any Route Navigation behind\n+     *\n+     * In future it's foreseen to replace this with BMW RangeMap Service which isn't running at the moment.\n+     *\n+     * @param range\n+     * @return mapping from air-line distance to \"real road\" distance\n+     */\n+    public static double guessRangeRadius(double range) {\n+        return range * 0.8;\n+    }\n+\n+    public static QuantityType<Length> getMiles(QuantityType<Length> qtLength) {\n+        if (qtLength.intValue() == -1) {\n+            return UNDEF_MILES;\n+        }\n+        QuantityType<Length> qt = qtLength.toUnit(ImperialUnits.MILE);\n+        if (qt != null) {\n+            return qt;\n+        } else {\n+            return QuantityType.valueOf(qtLength.doubleValue() / MILES_TO_KM_RATIO, ImperialUnits.MILE);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "48af48c82562d006b6f2aa35922270f181c885ed"}, "originalPosition": 192}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMjgwNzY5NA==", "bodyText": "done", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r602807694", "createdAt": "2021-03-28T00:03:53Z", "author": {"login": "weymann"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/utils/Converter.java", "diffHunk": "@@ -0,0 +1,204 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bmwconnecteddrive.internal.utils;\n+\n+import java.time.LocalDateTime;\n+import java.time.ZoneId;\n+import java.time.ZonedDateTime;\n+import java.time.format.DateTimeFormatter;\n+import java.time.format.DateTimeParseException;\n+import java.util.Optional;\n+\n+import javax.measure.quantity.Length;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.core.i18n.TimeZoneProvider;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.unit.ImperialUnits;\n+\n+import com.google.gson.Gson;\n+\n+/**\n+ * The {@link Converter} Conversion Helpers\n+ *\n+ * @author Bernd Weymann - Initial contribution\n+ */\n+@NonNullByDefault\n+public class Converter {\n+    public static final DateTimeFormatter SERVICE_DATE_INPUT_PATTERN = DateTimeFormatter.ofPattern(\"yyyy-MM-dd\");\n+    public static final DateTimeFormatter SERVICE_DATE_OUTPUT_PATTERN = DateTimeFormatter.ofPattern(\"MMM yyyy\");\n+\n+    public static final String LOCAL_DATE_INPUT_PATTERN_STRING = \"dd.MM.yyyy HH:mm\";\n+    public static final DateTimeFormatter LOCAL_DATE_INPUT_PATTERN = DateTimeFormatter\n+            .ofPattern(LOCAL_DATE_INPUT_PATTERN_STRING);\n+\n+    public static final String DATE_INPUT_PATTERN_STRING = \"yyyy-MM-dd'T'HH:mm:ss\";\n+    public static final DateTimeFormatter DATE_INPUT_PATTERN = DateTimeFormatter.ofPattern(DATE_INPUT_PATTERN_STRING);\n+\n+    public static final String DATE_INPUT_ZONE_PATTERN_STRING = \"yyyy-MM-dd'T'HH:mm:ssZ\";\n+    public static final DateTimeFormatter DATE_INPUT_ZONE_PATTERN = DateTimeFormatter\n+            .ofPattern(DATE_INPUT_ZONE_PATTERN_STRING);\n+\n+    public static final DateTimeFormatter DATE_OUTPUT_PATTERN = DateTimeFormatter.ofPattern(\"dd.MM.yyyy HH:mm\");\n+\n+    private static final Gson GSON = new Gson();\n+    private static final double SCALE = 10;\n+    public static final double MILES_TO_KM_RATIO = 1.60934;\n+    private static final QuantityType<Length> UNDEF_MILES = QuantityType.valueOf(-1, ImperialUnits.MILE);\n+    private static final String SPLIT_HYPHEN = \"-\";\n+    private static final String SPLIT_BRACKET = \"\\\\(\";\n+\n+    public static Optional<TimeZoneProvider> timeZoneProvider = Optional.empty();\n+\n+    public static double round(double value) {\n+        return Math.round(value * SCALE) / SCALE;\n+    }\n+\n+    public static String getLocalDateTimeWithoutOffest(@Nullable String input) {\n+        if (input == null) {\n+            return Constants.NULL_DATE;\n+        }\n+        LocalDateTime ldt;\n+        if (input.contains(Constants.PLUS)) {\n+            ldt = LocalDateTime.parse(input, Converter.DATE_INPUT_ZONE_PATTERN);\n+        } else {\n+            ldt = LocalDateTime.parse(input, Converter.DATE_INPUT_PATTERN);\n+        }\n+        return ldt.format(Converter.DATE_INPUT_PATTERN);\n+    }\n+\n+    public static String getLocalDateTime(@Nullable String input) {\n+        if (input == null) {\n+            return Constants.NULL_DATE;\n+        }\n+\n+        LocalDateTime ldt;\n+        if (input.contains(Constants.PLUS)) {\n+            ldt = LocalDateTime.parse(input, Converter.DATE_INPUT_ZONE_PATTERN);\n+        } else {\n+            try {\n+                ldt = LocalDateTime.parse(input, Converter.DATE_INPUT_PATTERN);\n+            } catch (DateTimeParseException dtpe) {\n+                ldt = LocalDateTime.parse(input, Converter.LOCAL_DATE_INPUT_PATTERN);\n+            }\n+        }\n+        ZonedDateTime zdtUTC = ldt.atZone(ZoneId.of(\"UTC\"));\n+        ZonedDateTime zdtLZ;\n+        zdtLZ = zdtUTC.withZoneSameInstant(ZoneId.systemDefault());\n+        if (timeZoneProvider.isPresent()) {\n+            zdtLZ = zdtUTC.withZoneSameInstant(timeZoneProvider.get().getTimeZone());\n+        } else {\n+            zdtLZ = zdtUTC.withZoneSameInstant(ZoneId.systemDefault());\n+        }\n+        return zdtLZ.format(Converter.DATE_INPUT_PATTERN);\n+    }\n+\n+    public static void setTimeZoneProvider(TimeZoneProvider tzp) {\n+        timeZoneProvider = Optional.of(tzp);\n+    }\n+\n+    public static String toTitleCase(@Nullable String input) {\n+        if (input == null) {\n+            return toTitleCase(Constants.UNDEF);\n+        } else {\n+            String lower = input.replaceAll(Constants.UNDERLINE, Constants.SPACE).toLowerCase();\n+            String converted = toTitleCase(lower, Constants.SPACE);\n+            converted = toTitleCase(converted, SPLIT_HYPHEN);\n+            converted = toTitleCase(converted, SPLIT_BRACKET);\n+            return converted;\n+        }\n+    }\n+\n+    private static String toTitleCase(String input, String splitter) {\n+        String[] arr = input.split(splitter);\n+        StringBuilder sb = new StringBuilder();\n+        for (int i = 0; i < arr.length; i++) {\n+            if (i > 0) {\n+                sb.append(splitter.replaceAll(\"\\\\\\\\\", Constants.EMPTY));\n+            }\n+            sb.append(Character.toUpperCase(arr[i].charAt(0))).append(arr[i].substring(1));\n+        }\n+        return sb.toString().trim();\n+    }\n+\n+    public static String capitalizeFirst(String str) {\n+        return str.substring(0, 1).toUpperCase() + str.substring(1);\n+    }\n+\n+    public static Gson getGson() {\n+        return GSON;\n+    }\n+\n+    /**\n+     * Measure distance between 2 coordinates\n+     *\n+     * @param sourceLatitude\n+     * @param sourceLongitude\n+     * @param destinationLatitude\n+     * @param destinationLongitude\n+     * @return distance\n+     */\n+    public static double measureDistance(double sourceLatitude, double sourceLongitude, double destinationLatitude,\n+            double destinationLongitude) {\n+        double earthRadius = 6378.137; // Radius of earth in KM\n+        double dLat = destinationLatitude * Math.PI / 180 - sourceLatitude * Math.PI / 180;\n+        double dLon = destinationLongitude * Math.PI / 180 - sourceLongitude * Math.PI / 180;\n+        double a = Math.sin(dLat / 2) * Math.sin(dLat / 2) + Math.cos(sourceLatitude * Math.PI / 180)\n+                * Math.cos(destinationLatitude * Math.PI / 180) * Math.sin(dLon / 2) * Math.sin(dLon / 2);\n+        double c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));\n+        return earthRadius * c;\n+    }\n+\n+    /**\n+     * Easy function but there's some measures behind:\n+     * Guessing the range of the Vehicle on Map. If you can drive x kilometers with your Vehicle it's not feasible to\n+     * project this x km Radius on Map. The roads to be taken are causing some overhead because they are not a straight\n+     * line from Location A to B.\n+     * I've taken some measurements to calculate the overhead factor based on Google Maps\n+     * Berlin - Dresden: Road Distance: 193 air-line Distance 167 = Factor 87%\n+     * Kassel - Frankfurt: Road Distance: 199 air-line Distance 143 = Factor 72%\n+     * After measuring more distances you'll find out that the outcome is between 70% and 90%. So\n+     *\n+     * This depends also on the roads of a concrete route but this is only a guess without any Route Navigation behind\n+     *\n+     * In future it's foreseen to replace this with BMW RangeMap Service which isn't running at the moment.\n+     *\n+     * @param range\n+     * @return mapping from air-line distance to \"real road\" distance\n+     */\n+    public static double guessRangeRadius(double range) {\n+        return range * 0.8;\n+    }\n+\n+    public static QuantityType<Length> getMiles(QuantityType<Length> qtLength) {\n+        if (qtLength.intValue() == -1) {\n+            return UNDEF_MILES;\n+        }\n+        QuantityType<Length> qt = qtLength.toUnit(ImperialUnits.MILE);\n+        if (qt != null) {\n+            return qt;\n+        } else {\n+            return QuantityType.valueOf(qtLength.doubleValue() / MILES_TO_KM_RATIO, ImperialUnits.MILE);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5NzkzMDQyOQ=="}, "originalCommit": {"oid": "48af48c82562d006b6f2aa35922270f181c885ed"}, "originalPosition": 192}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzc3Njg1Njk2OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/utils/VehicleStatusUtils.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0xOVQxOTozNzoxNVrOI6O0qQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0yOFQwMDowNzoxM1rOI-4elQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5NzkzMTE3Nw==", "bodyText": "Can this be removed?", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r597931177", "createdAt": "2021-03-19T19:37:15Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/utils/VehicleStatusUtils.java", "diffHunk": "@@ -0,0 +1,143 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bmwconnecteddrive.internal.utils;\n+\n+import static org.openhab.binding.bmwconnecteddrive.internal.utils.Constants.*;\n+\n+import java.lang.reflect.Field;\n+import java.time.LocalDateTime;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.status.CBSMessage;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.status.VehicleStatus;\n+\n+/**\n+ * The {@link VehicleStatusUtils} Data Transfer Object\n+ *\n+ * @author Bernd Weymann - Initial contribution\n+ */\n+@NonNullByDefault\n+public class VehicleStatusUtils {\n+\n+    public static String getNextServiceDate(VehicleStatus vStatus) {\n+        if (vStatus.cbsData == null) {\n+            return Constants.NULL_DATE;\n+        }\n+        if (vStatus.cbsData.isEmpty()) {\n+            return Constants.NULL_DATE;\n+        } else {\n+            LocalDateTime farFuture = LocalDateTime.now().plusYears(100);\n+            LocalDateTime serviceDate = farFuture;\n+            for (int i = 0; i < vStatus.cbsData.size(); i++) {\n+                CBSMessage entry = vStatus.cbsData.get(i);\n+                if (entry.cbsDueDate != null) {\n+                    LocalDateTime d = LocalDateTime.parse(entry.cbsDueDate + Constants.UTC_APPENDIX);\n+                    // LocalDate d = LocalDate.parse(entry.cbsDueDate + APPENDIX_DAY,\n+                    // Converter.SERVICE_DATE_INPUT_PATTERN);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "48af48c82562d006b6f2aa35922270f181c885ed"}, "originalPosition": 46}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMjgwNzk1Nw==", "bodyText": "Fixed", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r602807957", "createdAt": "2021-03-28T00:07:13Z", "author": {"login": "weymann"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/utils/VehicleStatusUtils.java", "diffHunk": "@@ -0,0 +1,143 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bmwconnecteddrive.internal.utils;\n+\n+import static org.openhab.binding.bmwconnecteddrive.internal.utils.Constants.*;\n+\n+import java.lang.reflect.Field;\n+import java.time.LocalDateTime;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.status.CBSMessage;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.status.VehicleStatus;\n+\n+/**\n+ * The {@link VehicleStatusUtils} Data Transfer Object\n+ *\n+ * @author Bernd Weymann - Initial contribution\n+ */\n+@NonNullByDefault\n+public class VehicleStatusUtils {\n+\n+    public static String getNextServiceDate(VehicleStatus vStatus) {\n+        if (vStatus.cbsData == null) {\n+            return Constants.NULL_DATE;\n+        }\n+        if (vStatus.cbsData.isEmpty()) {\n+            return Constants.NULL_DATE;\n+        } else {\n+            LocalDateTime farFuture = LocalDateTime.now().plusYears(100);\n+            LocalDateTime serviceDate = farFuture;\n+            for (int i = 0; i < vStatus.cbsData.size(); i++) {\n+                CBSMessage entry = vStatus.cbsData.get(i);\n+                if (entry.cbsDueDate != null) {\n+                    LocalDateTime d = LocalDateTime.parse(entry.cbsDueDate + Constants.UTC_APPENDIX);\n+                    // LocalDate d = LocalDate.parse(entry.cbsDueDate + APPENDIX_DAY,\n+                    // Converter.SERVICE_DATE_INPUT_PATTERN);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5NzkzMTE3Nw=="}, "originalCommit": {"oid": "48af48c82562d006b6f2aa35922270f181c885ed"}, "originalPosition": 46}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzc3Njg2OTY1OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/resources/OH-INF/i18n/bmwconnecteddrive_de.properties", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0xOVQxOTo0MToxMFrOI6O8RQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0yNFQwMDo0MzoyMVrOI8RKZQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5NzkzMzEyNQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            channel-group-type.bmwconnecteddrive.destination-values.description = Zeigt die gepseicherten Ziele des Fahrzeugs\n          \n          \n            \n            channel-group-type.bmwconnecteddrive.destination-values.description = Zeigt die gespeicherten Ziele des Fahrzeugs", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r597933125", "createdAt": "2021-03-19T19:41:10Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/resources/OH-INF/i18n/bmwconnecteddrive_de.properties", "diffHunk": "@@ -0,0 +1,261 @@\n+# Binding\n+binding.bmwconnecteddrive.name = BMW ConnectedDrive\n+binding.bmwconnecteddrive.description = Zeigt die Fahrzeugdaten \ufffdber das BMW ConnectedDrive Portal\n+\n+# bridge types\n+thing-type.bmwconnecteddrive.account.label = BMW ConnectedDrive Benutzerkonto\n+thing-type.bmwconnecteddrive.account.description = Zugriff auf das BMW ConnectedDrive Portal f\ufffdr einen Benutzer\n+thing-type.config.bmwconnecteddrive.account.userName = Benutzername f\ufffdr das ConnectedDrive Portal\n+thing-type.config.bmwconnecteddrive.account.password = Passwort f\ufffdr das ConnectedDrive Portal\n+thing-type.config.bmwconnecteddrive.account.region = Auswahl Ihrer Region zur Verbindung mit dem korrekten BMW Server \n+thing-type.config.bmwconnecteddrive.account.region.option.NORTH_AMERICA = Nordamerika \n+thing-type.config.bmwconnecteddrive.account.region.option.CHINA = China \n+thing-type.config.bmwconnecteddrive.account.region.option.ROW = Rest der Welt \n+\n+# thing types\n+thing-type.bmwconnecteddrive.bev_rex.label = BMW Elektrofahrzeug mit REX\n+thing-type.bmwconnecteddrive.bev_rex.description = BMW Elektrofahrzeug mit Range Extender (bev_rex)\n+thing-type.config.bmwconnecteddrive.bev_rex.vin.label = Fahrzeug Identifikationsnummer (VIN)\n+thing-type.config.bmwconnecteddrive.bev_rex.vin.description = VIN des Fahrzeugs\n+thing-type.config.bmwconnecteddrive.bev_rex.refreshInterval.label = Datenaktualisierung in Minuten\n+thing-type.config.bmwconnecteddrive.bev_rex.refreshInterval.description = Rate der Datenaktualisierung Ihres Fahrzeugs\n+thing-type.config.bmwconnecteddrive.bev_rex.units.label = Einheiten\n+thing-type.config.bmwconnecteddrive.bev_rex.units.description = Automatische oder direkte Auswahl der Einheiten \n+thing-type.config.bmwconnecteddrive.bev_rex.units.option.AUTODETECT = Automatische Auswahl\n+thing-type.config.bmwconnecteddrive.bev_rex.units.option.IMPERIAL = Angloamerikanisches System\n+thing-type.config.bmwconnecteddrive.bev_rex.units.option.METRIC = Metrisches System\n+thing-type.config.bmwconnecteddrive.bev_rex.imageSize.label = Bildgr\ufffd\ufffde\n+thing-type.config.bmwconnecteddrive.bev_rex.imageSize.description = Bildgr\ufffd\ufffde des Fahrzeugs f\ufffdr L\ufffdnge und Breite\n+thing-type.config.bmwconnecteddrive.bev_rex.imageViewport.label = Bild Ansicht\n+thing-type.config.bmwconnecteddrive.bev_rex.imageViewport.description = Ansicht des Fahrzeugs\n+thing-type.config.bmwconnecteddrive.bev_rex.imageViewport.option.FRONT = Vorderansicht\n+thing-type.config.bmwconnecteddrive.bev_rex.imageViewport.option.REAR = R\ufffdckansicht\n+thing-type.config.bmwconnecteddrive.bev_rex.imageViewport.option.SIDE = Seitenansicht\n+thing-type.config.bmwconnecteddrive.bev_rex.imageViewport.option.DASHBOARD = Innenansicht Armaturen\n+thing-type.config.bmwconnecteddrive.bev_rex.imageViewport.option.DRIVERDOOR = Seitenansicht Fahrert\ufffdr\n+\n+thing-type.bmwconnecteddrive.bev.label = BMW Elektrofahrzeug\n+thing-type.bmwconnecteddrive.bev.description = Batterieelektrisches Fahrzeug (bev)\n+thing-type.config.bmwconnecteddrive.bev.vin.label = Fahrzeug Identifikationsnummer (VIN)\n+thing-type.config.bmwconnecteddrive.bev.vin.description = VIN des Fahrzeugs\n+thing-type.config.bmwconnecteddrive.bev.refreshInterval.label = Datenaktualisierung in Minuten\n+thing-type.config.bmwconnecteddrive.bev.refreshInterval.description = Rate der Datenaktualisierung Ihres Fahrzeugs\n+thing-type.config.bmwconnecteddrive.bev.units.label = Einheiten\n+thing-type.config.bmwconnecteddrive.bev.units.description = Automatische oder direkte Auswahl der Einheiten \n+thing-type.config.bmwconnecteddrive.bev.units.option.AUTODETECT = Automatische Auswahl\n+thing-type.config.bmwconnecteddrive.bev.units.option.IMPERIAL = Angloamerikanisches System\n+thing-type.config.bmwconnecteddrive.bev.units.option.METRIC = Metrisches System\n+thing-type.config.bmwconnecteddrive.bev.imageSize.label = Bildgr\ufffd\ufffde\n+thing-type.config.bmwconnecteddrive.bev.imageSize.description = Bildgr\ufffd\ufffde des Fahrzeugs f\ufffdr L\ufffdnge und Breite\n+thing-type.config.bmwconnecteddrive.bev.imageViewport.label = Bild Ansicht\n+thing-type.config.bmwconnecteddrive.bev.imageViewport.description = Ansicht des Fahrzeugs\n+thing-type.config.bmwconnecteddrive.bev.imageViewport.option.FRONT = Vorderansicht\n+thing-type.config.bmwconnecteddrive.bev.imageViewport.option.REAR = R\ufffdckansicht\n+thing-type.config.bmwconnecteddrive.bev.imageViewport.option.SIDE = Seitenansicht\n+thing-type.config.bmwconnecteddrive.bev.imageViewport.option.DASHBOARD = Innenansicht Armaturen\n+thing-type.config.bmwconnecteddrive.bev.imageViewport.option.DRIVERDOOR = Seitenansicht Fahrert\ufffdr\n+\n+thing-type.bmwconnecteddrive.phev.label = BMW Plug-in-Hybrid Elektrofahrzeug\n+thing-type.bmwconnecteddrive.phev.description = Konventionelles Fahrzeug mit Elektromotor (phev)\n+thing-type.config.bmwconnecteddrive.phev.vin.label = Fahrzeug Identifikationsnummer (VIN)\n+thing-type.config.bmwconnecteddrive.phev.vin.description = VIN des Fahrzeugs\n+thing-type.config.bmwconnecteddrive.phev.refreshInterval.label = Datenaktualisierung in Minuten\n+thing-type.config.bmwconnecteddrive.phev.refreshInterval.description = Rate der Datenaktualisierung Ihres Fahrzeugs\n+thing-type.config.bmwconnecteddrive.phev.units.label = Einheiten\n+thing-type.config.bmwconnecteddrive.phev.units.description = Automatische oder direkte Auswahl der Einheiten \n+thing-type.config.bmwconnecteddrive.phev.units.option.AUTODETECT = Automatische Auswahl\n+thing-type.config.bmwconnecteddrive.phev.units.option.IMPERIAL = Angloamerikanisches System\n+thing-type.config.bmwconnecteddrive.phev.units.option.METRIC = Metrisches System\n+thing-type.config.bmwconnecteddrive.phev.imageSize.label = Bildgr\ufffd\ufffde\n+thing-type.config.bmwconnecteddrive.phev.imageSize.description = Bildgr\ufffd\ufffde des Fahrzeugs f\ufffdr L\ufffdnge und Breite\n+thing-type.config.bmwconnecteddrive.phev.imageViewport.label = Bild Ansicht\n+thing-type.config.bmwconnecteddrive.phev.imageViewport.description = Ansicht des Fahrzeugs\n+thing-type.config.bmwconnecteddrive.phev.imageViewport.option.FRONT = Vorderansicht\n+thing-type.config.bmwconnecteddrive.phev.imageViewport.option.REAR = R\ufffdckansicht\n+thing-type.config.bmwconnecteddrive.phev.imageViewport.option.SIDE = Seitenansicht\n+thing-type.config.bmwconnecteddrive.phev.imageViewport.option.DASHBOARD = Innenansicht Armaturen\n+thing-type.config.bmwconnecteddrive.phev.imageViewport.option.DRIVERDOOR = Seitenansicht Fahrert\ufffdr\n+\n+thing-type.bmwconnecteddrive.conv.label = BMW Konventionelles Fahrzeug\n+thing-type.bmwconnecteddrive.conv.description = Konventionelles Benzin/Diesel Fahrzeug (conv)\n+thing-type.config.bmwconnecteddrive.conv.vin.label = Fahrzeug Identifikationsnummer (VIN)\n+thing-type.config.bmwconnecteddrive.conv.vin.description = VIN des Fahrzeugs\n+thing-type.config.bmwconnecteddrive.conv.refreshInterval.label = Datenaktualisierung in Minuten\n+thing-type.config.bmwconnecteddrive.conv.refreshInterval.description = Rate der Datenaktualisierung Ihres Fahrzeugs\n+thing-type.config.bmwconnecteddrive.conv.units.label = Einheiten\n+thing-type.config.bmwconnecteddrive.conv.units.description = Automatische oder direkte Auswahl der Einheiten \n+thing-type.config.bmwconnecteddrive.conv.units.option.AUTODETECT = Automatische Auswahl\n+thing-type.config.bmwconnecteddrive.conv.units.option.IMPERIAL = Angloamerikanisches System\n+thing-type.config.bmwconnecteddrive.conv.units.option.METRIC = Metrisches System\n+thing-type.config.bmwconnecteddrive.conv.imageSize.label = Bildgr\ufffd\ufffde\n+thing-type.config.bmwconnecteddrive.conv.imageSize.description = Bildgr\ufffd\ufffde des Fahrzeugs f\ufffdr L\ufffdnge und Breite\n+thing-type.config.bmwconnecteddrive.conv.imageViewport.label = Bild Ansicht\n+thing-type.config.bmwconnecteddrive.conv.imageViewport.description = Ansicht des Fahrzeugs\n+thing-type.config.bmwconnecteddrive.conv.imageViewport.option.FRONT = Vorderansicht\n+thing-type.config.bmwconnecteddrive.conv.imageViewport.option.REAR = R\ufffdckansicht\n+thing-type.config.bmwconnecteddrive.conv.imageViewport.option.SIDE = Seitenansicht\n+thing-type.config.bmwconnecteddrive.conv.imageViewport.option.DASHBOARD = Innenansicht Armaturen\n+thing-type.config.bmwconnecteddrive.conv.imageViewport.option.DRIVERDOOR = Seitenansicht Fahrert\ufffdr\n+\n+# Channel Groups\n+channel-group-type.bmwconnecteddrive.charge-values.label = Elektrisches Laden\n+channel-group-type.bmwconnecteddrive.charge-values.description = Ladezustand und Ladeprofile des Fahrzeugs\n+channel-group-type.bmwconnecteddrive.ev-lifetime-values.label = Gesamtlaufzeit Statistik\n+channel-group-type.bmwconnecteddrive.ev-lifetime-values.description = Verbrauchswerte und zur\ufffdckgelegte Strecken \ufffdber die Fahrzeug-Gesamtlaufzeit\n+channel-group-type.bmwconnecteddrive.hybrid-lifetime-values.label = Gesamtlaufzeit Statistik\n+channel-group-type.bmwconnecteddrive.hybrid-lifetime-values.description = Verbrauchswerte und zur\ufffdckgelegte Strecken \ufffdber die Fahrzeug-Gesamtlaufzeit\n+channel-group-type.bmwconnecteddrive.ev-last-trip-values.label = Statistik der letzten Fahrt\n+channel-group-type.bmwconnecteddrive.ev-last-trip-values.description = Verbrauchswerte und zur\ufffdck gelegte Strecke der letzten Fahrt\n+channel-group-type.bmwconnecteddrive.hybrid-last-trip-values.label = Statistik der letzten Fahrt\n+channel-group-type.bmwconnecteddrive.hybrid-last-trip-values.description = Verbrauchswerte und zur\ufffdck gelegte Strecke der letzten Fahrt\n+channel-group-type.bmwconnecteddrive.ev-range-values.label = Elektrische Reichweite\n+channel-group-type.bmwconnecteddrive.ev-range-values.description = Tachostand, Reichweiten und Ladestand des Fahrzeugs\n+channel-group-type.bmwconnecteddrive.check-control-values.label = Warnungen\n+channel-group-type.bmwconnecteddrive.check-control-values.description = Aktuelle Warungen des Fahrzeugs\n+channel-group-type.bmwconnecteddrive.service-values.label = Wartung\n+channel-group-type.bmwconnecteddrive.service-values.description = Zuk\ufffdnftige Wartungstermine des Fahrzeugs\n+channel-group-type.bmwconnecteddrive.conv-range-values.label = Reichweite\n+channel-group-type.bmwconnecteddrive.conv-range-values.description = Tachostand, Reichweite und Tankf\ufffdllung des Fahrzeugs\n+channel-group-type.bmwconnecteddrive.hybrid-range-values.label = Hybride Reichweite\n+channel-group-type.bmwconnecteddrive.hybrid-range-values.description = Tachostand, Reichweite, Ladezustand und Tankf\ufffdllung des Fahrzeugs\n+channel-group-type.bmwconnecteddrive.image-values.label = Fahrzeug Bild\n+channel-group-type.bmwconnecteddrive.image-values.description = Bild des Fahrzeug basierend auf der Ansicht in der Konfiguration\n+channel-group-type.bmwconnecteddrive.remote-services.label = Fahrzeug Fernsteuerung\n+channel-group-type.bmwconnecteddrive.remote-services.description = Fernsteuerung des Fahrzeugs \ufffdber den BMW Server wie T\ufffdren schlie\ufffden / \ufffdffnen, Klimasteuerung und mehr\n+channel-group-type.bmwconnecteddrive.vehicle-status.label = Fahrzeug Zustand\n+channel-group-type.bmwconnecteddrive.vehicle-status.description = Zustand des Fahrzeugs \ufffdber T\ufffdren, Fenster, abgeschlossen, anstehende Wartung und aktive Warnungen\n+channel-group-type.bmwconnecteddrive.ev-vehicle-status.label = Fahrzeug Zustand\n+channel-group-type.bmwconnecteddrive.ev-vehicle-status.description = Zustand des Fahrzeugs \ufffdber T\ufffdren, Fenster, abgeschlossen, anstehende Wartung und aktive Warnungen\n+channel-group-type.bmwconnecteddrive.location-values.label = Fahrzeug Standort\n+channel-group-type.bmwconnecteddrive.location-values.description = Koordinaten und Ausrichtung des Fahrzeugs\n+channel-group-type.bmwconnecteddrive.destination-values.label = Ziele\n+channel-group-type.bmwconnecteddrive.destination-values.description = Zeigt die gepseicherten Ziele des Fahrzeugs", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "48af48c82562d006b6f2aa35922270f181c885ed"}, "originalPosition": 132}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMDA2NjY2MQ==", "bodyText": "corrected", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r600066661", "createdAt": "2021-03-24T00:43:21Z", "author": {"login": "weymann"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/resources/OH-INF/i18n/bmwconnecteddrive_de.properties", "diffHunk": "@@ -0,0 +1,261 @@\n+# Binding\n+binding.bmwconnecteddrive.name = BMW ConnectedDrive\n+binding.bmwconnecteddrive.description = Zeigt die Fahrzeugdaten \ufffdber das BMW ConnectedDrive Portal\n+\n+# bridge types\n+thing-type.bmwconnecteddrive.account.label = BMW ConnectedDrive Benutzerkonto\n+thing-type.bmwconnecteddrive.account.description = Zugriff auf das BMW ConnectedDrive Portal f\ufffdr einen Benutzer\n+thing-type.config.bmwconnecteddrive.account.userName = Benutzername f\ufffdr das ConnectedDrive Portal\n+thing-type.config.bmwconnecteddrive.account.password = Passwort f\ufffdr das ConnectedDrive Portal\n+thing-type.config.bmwconnecteddrive.account.region = Auswahl Ihrer Region zur Verbindung mit dem korrekten BMW Server \n+thing-type.config.bmwconnecteddrive.account.region.option.NORTH_AMERICA = Nordamerika \n+thing-type.config.bmwconnecteddrive.account.region.option.CHINA = China \n+thing-type.config.bmwconnecteddrive.account.region.option.ROW = Rest der Welt \n+\n+# thing types\n+thing-type.bmwconnecteddrive.bev_rex.label = BMW Elektrofahrzeug mit REX\n+thing-type.bmwconnecteddrive.bev_rex.description = BMW Elektrofahrzeug mit Range Extender (bev_rex)\n+thing-type.config.bmwconnecteddrive.bev_rex.vin.label = Fahrzeug Identifikationsnummer (VIN)\n+thing-type.config.bmwconnecteddrive.bev_rex.vin.description = VIN des Fahrzeugs\n+thing-type.config.bmwconnecteddrive.bev_rex.refreshInterval.label = Datenaktualisierung in Minuten\n+thing-type.config.bmwconnecteddrive.bev_rex.refreshInterval.description = Rate der Datenaktualisierung Ihres Fahrzeugs\n+thing-type.config.bmwconnecteddrive.bev_rex.units.label = Einheiten\n+thing-type.config.bmwconnecteddrive.bev_rex.units.description = Automatische oder direkte Auswahl der Einheiten \n+thing-type.config.bmwconnecteddrive.bev_rex.units.option.AUTODETECT = Automatische Auswahl\n+thing-type.config.bmwconnecteddrive.bev_rex.units.option.IMPERIAL = Angloamerikanisches System\n+thing-type.config.bmwconnecteddrive.bev_rex.units.option.METRIC = Metrisches System\n+thing-type.config.bmwconnecteddrive.bev_rex.imageSize.label = Bildgr\ufffd\ufffde\n+thing-type.config.bmwconnecteddrive.bev_rex.imageSize.description = Bildgr\ufffd\ufffde des Fahrzeugs f\ufffdr L\ufffdnge und Breite\n+thing-type.config.bmwconnecteddrive.bev_rex.imageViewport.label = Bild Ansicht\n+thing-type.config.bmwconnecteddrive.bev_rex.imageViewport.description = Ansicht des Fahrzeugs\n+thing-type.config.bmwconnecteddrive.bev_rex.imageViewport.option.FRONT = Vorderansicht\n+thing-type.config.bmwconnecteddrive.bev_rex.imageViewport.option.REAR = R\ufffdckansicht\n+thing-type.config.bmwconnecteddrive.bev_rex.imageViewport.option.SIDE = Seitenansicht\n+thing-type.config.bmwconnecteddrive.bev_rex.imageViewport.option.DASHBOARD = Innenansicht Armaturen\n+thing-type.config.bmwconnecteddrive.bev_rex.imageViewport.option.DRIVERDOOR = Seitenansicht Fahrert\ufffdr\n+\n+thing-type.bmwconnecteddrive.bev.label = BMW Elektrofahrzeug\n+thing-type.bmwconnecteddrive.bev.description = Batterieelektrisches Fahrzeug (bev)\n+thing-type.config.bmwconnecteddrive.bev.vin.label = Fahrzeug Identifikationsnummer (VIN)\n+thing-type.config.bmwconnecteddrive.bev.vin.description = VIN des Fahrzeugs\n+thing-type.config.bmwconnecteddrive.bev.refreshInterval.label = Datenaktualisierung in Minuten\n+thing-type.config.bmwconnecteddrive.bev.refreshInterval.description = Rate der Datenaktualisierung Ihres Fahrzeugs\n+thing-type.config.bmwconnecteddrive.bev.units.label = Einheiten\n+thing-type.config.bmwconnecteddrive.bev.units.description = Automatische oder direkte Auswahl der Einheiten \n+thing-type.config.bmwconnecteddrive.bev.units.option.AUTODETECT = Automatische Auswahl\n+thing-type.config.bmwconnecteddrive.bev.units.option.IMPERIAL = Angloamerikanisches System\n+thing-type.config.bmwconnecteddrive.bev.units.option.METRIC = Metrisches System\n+thing-type.config.bmwconnecteddrive.bev.imageSize.label = Bildgr\ufffd\ufffde\n+thing-type.config.bmwconnecteddrive.bev.imageSize.description = Bildgr\ufffd\ufffde des Fahrzeugs f\ufffdr L\ufffdnge und Breite\n+thing-type.config.bmwconnecteddrive.bev.imageViewport.label = Bild Ansicht\n+thing-type.config.bmwconnecteddrive.bev.imageViewport.description = Ansicht des Fahrzeugs\n+thing-type.config.bmwconnecteddrive.bev.imageViewport.option.FRONT = Vorderansicht\n+thing-type.config.bmwconnecteddrive.bev.imageViewport.option.REAR = R\ufffdckansicht\n+thing-type.config.bmwconnecteddrive.bev.imageViewport.option.SIDE = Seitenansicht\n+thing-type.config.bmwconnecteddrive.bev.imageViewport.option.DASHBOARD = Innenansicht Armaturen\n+thing-type.config.bmwconnecteddrive.bev.imageViewport.option.DRIVERDOOR = Seitenansicht Fahrert\ufffdr\n+\n+thing-type.bmwconnecteddrive.phev.label = BMW Plug-in-Hybrid Elektrofahrzeug\n+thing-type.bmwconnecteddrive.phev.description = Konventionelles Fahrzeug mit Elektromotor (phev)\n+thing-type.config.bmwconnecteddrive.phev.vin.label = Fahrzeug Identifikationsnummer (VIN)\n+thing-type.config.bmwconnecteddrive.phev.vin.description = VIN des Fahrzeugs\n+thing-type.config.bmwconnecteddrive.phev.refreshInterval.label = Datenaktualisierung in Minuten\n+thing-type.config.bmwconnecteddrive.phev.refreshInterval.description = Rate der Datenaktualisierung Ihres Fahrzeugs\n+thing-type.config.bmwconnecteddrive.phev.units.label = Einheiten\n+thing-type.config.bmwconnecteddrive.phev.units.description = Automatische oder direkte Auswahl der Einheiten \n+thing-type.config.bmwconnecteddrive.phev.units.option.AUTODETECT = Automatische Auswahl\n+thing-type.config.bmwconnecteddrive.phev.units.option.IMPERIAL = Angloamerikanisches System\n+thing-type.config.bmwconnecteddrive.phev.units.option.METRIC = Metrisches System\n+thing-type.config.bmwconnecteddrive.phev.imageSize.label = Bildgr\ufffd\ufffde\n+thing-type.config.bmwconnecteddrive.phev.imageSize.description = Bildgr\ufffd\ufffde des Fahrzeugs f\ufffdr L\ufffdnge und Breite\n+thing-type.config.bmwconnecteddrive.phev.imageViewport.label = Bild Ansicht\n+thing-type.config.bmwconnecteddrive.phev.imageViewport.description = Ansicht des Fahrzeugs\n+thing-type.config.bmwconnecteddrive.phev.imageViewport.option.FRONT = Vorderansicht\n+thing-type.config.bmwconnecteddrive.phev.imageViewport.option.REAR = R\ufffdckansicht\n+thing-type.config.bmwconnecteddrive.phev.imageViewport.option.SIDE = Seitenansicht\n+thing-type.config.bmwconnecteddrive.phev.imageViewport.option.DASHBOARD = Innenansicht Armaturen\n+thing-type.config.bmwconnecteddrive.phev.imageViewport.option.DRIVERDOOR = Seitenansicht Fahrert\ufffdr\n+\n+thing-type.bmwconnecteddrive.conv.label = BMW Konventionelles Fahrzeug\n+thing-type.bmwconnecteddrive.conv.description = Konventionelles Benzin/Diesel Fahrzeug (conv)\n+thing-type.config.bmwconnecteddrive.conv.vin.label = Fahrzeug Identifikationsnummer (VIN)\n+thing-type.config.bmwconnecteddrive.conv.vin.description = VIN des Fahrzeugs\n+thing-type.config.bmwconnecteddrive.conv.refreshInterval.label = Datenaktualisierung in Minuten\n+thing-type.config.bmwconnecteddrive.conv.refreshInterval.description = Rate der Datenaktualisierung Ihres Fahrzeugs\n+thing-type.config.bmwconnecteddrive.conv.units.label = Einheiten\n+thing-type.config.bmwconnecteddrive.conv.units.description = Automatische oder direkte Auswahl der Einheiten \n+thing-type.config.bmwconnecteddrive.conv.units.option.AUTODETECT = Automatische Auswahl\n+thing-type.config.bmwconnecteddrive.conv.units.option.IMPERIAL = Angloamerikanisches System\n+thing-type.config.bmwconnecteddrive.conv.units.option.METRIC = Metrisches System\n+thing-type.config.bmwconnecteddrive.conv.imageSize.label = Bildgr\ufffd\ufffde\n+thing-type.config.bmwconnecteddrive.conv.imageSize.description = Bildgr\ufffd\ufffde des Fahrzeugs f\ufffdr L\ufffdnge und Breite\n+thing-type.config.bmwconnecteddrive.conv.imageViewport.label = Bild Ansicht\n+thing-type.config.bmwconnecteddrive.conv.imageViewport.description = Ansicht des Fahrzeugs\n+thing-type.config.bmwconnecteddrive.conv.imageViewport.option.FRONT = Vorderansicht\n+thing-type.config.bmwconnecteddrive.conv.imageViewport.option.REAR = R\ufffdckansicht\n+thing-type.config.bmwconnecteddrive.conv.imageViewport.option.SIDE = Seitenansicht\n+thing-type.config.bmwconnecteddrive.conv.imageViewport.option.DASHBOARD = Innenansicht Armaturen\n+thing-type.config.bmwconnecteddrive.conv.imageViewport.option.DRIVERDOOR = Seitenansicht Fahrert\ufffdr\n+\n+# Channel Groups\n+channel-group-type.bmwconnecteddrive.charge-values.label = Elektrisches Laden\n+channel-group-type.bmwconnecteddrive.charge-values.description = Ladezustand und Ladeprofile des Fahrzeugs\n+channel-group-type.bmwconnecteddrive.ev-lifetime-values.label = Gesamtlaufzeit Statistik\n+channel-group-type.bmwconnecteddrive.ev-lifetime-values.description = Verbrauchswerte und zur\ufffdckgelegte Strecken \ufffdber die Fahrzeug-Gesamtlaufzeit\n+channel-group-type.bmwconnecteddrive.hybrid-lifetime-values.label = Gesamtlaufzeit Statistik\n+channel-group-type.bmwconnecteddrive.hybrid-lifetime-values.description = Verbrauchswerte und zur\ufffdckgelegte Strecken \ufffdber die Fahrzeug-Gesamtlaufzeit\n+channel-group-type.bmwconnecteddrive.ev-last-trip-values.label = Statistik der letzten Fahrt\n+channel-group-type.bmwconnecteddrive.ev-last-trip-values.description = Verbrauchswerte und zur\ufffdck gelegte Strecke der letzten Fahrt\n+channel-group-type.bmwconnecteddrive.hybrid-last-trip-values.label = Statistik der letzten Fahrt\n+channel-group-type.bmwconnecteddrive.hybrid-last-trip-values.description = Verbrauchswerte und zur\ufffdck gelegte Strecke der letzten Fahrt\n+channel-group-type.bmwconnecteddrive.ev-range-values.label = Elektrische Reichweite\n+channel-group-type.bmwconnecteddrive.ev-range-values.description = Tachostand, Reichweiten und Ladestand des Fahrzeugs\n+channel-group-type.bmwconnecteddrive.check-control-values.label = Warnungen\n+channel-group-type.bmwconnecteddrive.check-control-values.description = Aktuelle Warungen des Fahrzeugs\n+channel-group-type.bmwconnecteddrive.service-values.label = Wartung\n+channel-group-type.bmwconnecteddrive.service-values.description = Zuk\ufffdnftige Wartungstermine des Fahrzeugs\n+channel-group-type.bmwconnecteddrive.conv-range-values.label = Reichweite\n+channel-group-type.bmwconnecteddrive.conv-range-values.description = Tachostand, Reichweite und Tankf\ufffdllung des Fahrzeugs\n+channel-group-type.bmwconnecteddrive.hybrid-range-values.label = Hybride Reichweite\n+channel-group-type.bmwconnecteddrive.hybrid-range-values.description = Tachostand, Reichweite, Ladezustand und Tankf\ufffdllung des Fahrzeugs\n+channel-group-type.bmwconnecteddrive.image-values.label = Fahrzeug Bild\n+channel-group-type.bmwconnecteddrive.image-values.description = Bild des Fahrzeug basierend auf der Ansicht in der Konfiguration\n+channel-group-type.bmwconnecteddrive.remote-services.label = Fahrzeug Fernsteuerung\n+channel-group-type.bmwconnecteddrive.remote-services.description = Fernsteuerung des Fahrzeugs \ufffdber den BMW Server wie T\ufffdren schlie\ufffden / \ufffdffnen, Klimasteuerung und mehr\n+channel-group-type.bmwconnecteddrive.vehicle-status.label = Fahrzeug Zustand\n+channel-group-type.bmwconnecteddrive.vehicle-status.description = Zustand des Fahrzeugs \ufffdber T\ufffdren, Fenster, abgeschlossen, anstehende Wartung und aktive Warnungen\n+channel-group-type.bmwconnecteddrive.ev-vehicle-status.label = Fahrzeug Zustand\n+channel-group-type.bmwconnecteddrive.ev-vehicle-status.description = Zustand des Fahrzeugs \ufffdber T\ufffdren, Fenster, abgeschlossen, anstehende Wartung und aktive Warnungen\n+channel-group-type.bmwconnecteddrive.location-values.label = Fahrzeug Standort\n+channel-group-type.bmwconnecteddrive.location-values.description = Koordinaten und Ausrichtung des Fahrzeugs\n+channel-group-type.bmwconnecteddrive.destination-values.label = Ziele\n+channel-group-type.bmwconnecteddrive.destination-values.description = Zeigt die gepseicherten Ziele des Fahrzeugs", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5NzkzMzEyNQ=="}, "originalCommit": {"oid": "48af48c82562d006b6f2aa35922270f181c885ed"}, "originalPosition": 132}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzc3Njg3MDI5OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/resources/OH-INF/i18n/bmwconnecteddrive_de.properties", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0xOVQxOTo0MToyNVrOI6O8pw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0yOFQwMDoxMDo1NFrOI-4gBg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5NzkzMzIyMw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            channel-group-type.bmwconnecteddrive.door-values.description = Zeigt die Dezails der T\ufffdren und Fenster des Fahrzeugs\n          \n          \n            \n            channel-group-type.bmwconnecteddrive.door-values.description = Zeigt die Details der T\ufffdren und Fenster des Fahrzeugs", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r597933223", "createdAt": "2021-03-19T19:41:25Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/resources/OH-INF/i18n/bmwconnecteddrive_de.properties", "diffHunk": "@@ -0,0 +1,261 @@\n+# Binding\n+binding.bmwconnecteddrive.name = BMW ConnectedDrive\n+binding.bmwconnecteddrive.description = Zeigt die Fahrzeugdaten \ufffdber das BMW ConnectedDrive Portal\n+\n+# bridge types\n+thing-type.bmwconnecteddrive.account.label = BMW ConnectedDrive Benutzerkonto\n+thing-type.bmwconnecteddrive.account.description = Zugriff auf das BMW ConnectedDrive Portal f\ufffdr einen Benutzer\n+thing-type.config.bmwconnecteddrive.account.userName = Benutzername f\ufffdr das ConnectedDrive Portal\n+thing-type.config.bmwconnecteddrive.account.password = Passwort f\ufffdr das ConnectedDrive Portal\n+thing-type.config.bmwconnecteddrive.account.region = Auswahl Ihrer Region zur Verbindung mit dem korrekten BMW Server \n+thing-type.config.bmwconnecteddrive.account.region.option.NORTH_AMERICA = Nordamerika \n+thing-type.config.bmwconnecteddrive.account.region.option.CHINA = China \n+thing-type.config.bmwconnecteddrive.account.region.option.ROW = Rest der Welt \n+\n+# thing types\n+thing-type.bmwconnecteddrive.bev_rex.label = BMW Elektrofahrzeug mit REX\n+thing-type.bmwconnecteddrive.bev_rex.description = BMW Elektrofahrzeug mit Range Extender (bev_rex)\n+thing-type.config.bmwconnecteddrive.bev_rex.vin.label = Fahrzeug Identifikationsnummer (VIN)\n+thing-type.config.bmwconnecteddrive.bev_rex.vin.description = VIN des Fahrzeugs\n+thing-type.config.bmwconnecteddrive.bev_rex.refreshInterval.label = Datenaktualisierung in Minuten\n+thing-type.config.bmwconnecteddrive.bev_rex.refreshInterval.description = Rate der Datenaktualisierung Ihres Fahrzeugs\n+thing-type.config.bmwconnecteddrive.bev_rex.units.label = Einheiten\n+thing-type.config.bmwconnecteddrive.bev_rex.units.description = Automatische oder direkte Auswahl der Einheiten \n+thing-type.config.bmwconnecteddrive.bev_rex.units.option.AUTODETECT = Automatische Auswahl\n+thing-type.config.bmwconnecteddrive.bev_rex.units.option.IMPERIAL = Angloamerikanisches System\n+thing-type.config.bmwconnecteddrive.bev_rex.units.option.METRIC = Metrisches System\n+thing-type.config.bmwconnecteddrive.bev_rex.imageSize.label = Bildgr\ufffd\ufffde\n+thing-type.config.bmwconnecteddrive.bev_rex.imageSize.description = Bildgr\ufffd\ufffde des Fahrzeugs f\ufffdr L\ufffdnge und Breite\n+thing-type.config.bmwconnecteddrive.bev_rex.imageViewport.label = Bild Ansicht\n+thing-type.config.bmwconnecteddrive.bev_rex.imageViewport.description = Ansicht des Fahrzeugs\n+thing-type.config.bmwconnecteddrive.bev_rex.imageViewport.option.FRONT = Vorderansicht\n+thing-type.config.bmwconnecteddrive.bev_rex.imageViewport.option.REAR = R\ufffdckansicht\n+thing-type.config.bmwconnecteddrive.bev_rex.imageViewport.option.SIDE = Seitenansicht\n+thing-type.config.bmwconnecteddrive.bev_rex.imageViewport.option.DASHBOARD = Innenansicht Armaturen\n+thing-type.config.bmwconnecteddrive.bev_rex.imageViewport.option.DRIVERDOOR = Seitenansicht Fahrert\ufffdr\n+\n+thing-type.bmwconnecteddrive.bev.label = BMW Elektrofahrzeug\n+thing-type.bmwconnecteddrive.bev.description = Batterieelektrisches Fahrzeug (bev)\n+thing-type.config.bmwconnecteddrive.bev.vin.label = Fahrzeug Identifikationsnummer (VIN)\n+thing-type.config.bmwconnecteddrive.bev.vin.description = VIN des Fahrzeugs\n+thing-type.config.bmwconnecteddrive.bev.refreshInterval.label = Datenaktualisierung in Minuten\n+thing-type.config.bmwconnecteddrive.bev.refreshInterval.description = Rate der Datenaktualisierung Ihres Fahrzeugs\n+thing-type.config.bmwconnecteddrive.bev.units.label = Einheiten\n+thing-type.config.bmwconnecteddrive.bev.units.description = Automatische oder direkte Auswahl der Einheiten \n+thing-type.config.bmwconnecteddrive.bev.units.option.AUTODETECT = Automatische Auswahl\n+thing-type.config.bmwconnecteddrive.bev.units.option.IMPERIAL = Angloamerikanisches System\n+thing-type.config.bmwconnecteddrive.bev.units.option.METRIC = Metrisches System\n+thing-type.config.bmwconnecteddrive.bev.imageSize.label = Bildgr\ufffd\ufffde\n+thing-type.config.bmwconnecteddrive.bev.imageSize.description = Bildgr\ufffd\ufffde des Fahrzeugs f\ufffdr L\ufffdnge und Breite\n+thing-type.config.bmwconnecteddrive.bev.imageViewport.label = Bild Ansicht\n+thing-type.config.bmwconnecteddrive.bev.imageViewport.description = Ansicht des Fahrzeugs\n+thing-type.config.bmwconnecteddrive.bev.imageViewport.option.FRONT = Vorderansicht\n+thing-type.config.bmwconnecteddrive.bev.imageViewport.option.REAR = R\ufffdckansicht\n+thing-type.config.bmwconnecteddrive.bev.imageViewport.option.SIDE = Seitenansicht\n+thing-type.config.bmwconnecteddrive.bev.imageViewport.option.DASHBOARD = Innenansicht Armaturen\n+thing-type.config.bmwconnecteddrive.bev.imageViewport.option.DRIVERDOOR = Seitenansicht Fahrert\ufffdr\n+\n+thing-type.bmwconnecteddrive.phev.label = BMW Plug-in-Hybrid Elektrofahrzeug\n+thing-type.bmwconnecteddrive.phev.description = Konventionelles Fahrzeug mit Elektromotor (phev)\n+thing-type.config.bmwconnecteddrive.phev.vin.label = Fahrzeug Identifikationsnummer (VIN)\n+thing-type.config.bmwconnecteddrive.phev.vin.description = VIN des Fahrzeugs\n+thing-type.config.bmwconnecteddrive.phev.refreshInterval.label = Datenaktualisierung in Minuten\n+thing-type.config.bmwconnecteddrive.phev.refreshInterval.description = Rate der Datenaktualisierung Ihres Fahrzeugs\n+thing-type.config.bmwconnecteddrive.phev.units.label = Einheiten\n+thing-type.config.bmwconnecteddrive.phev.units.description = Automatische oder direkte Auswahl der Einheiten \n+thing-type.config.bmwconnecteddrive.phev.units.option.AUTODETECT = Automatische Auswahl\n+thing-type.config.bmwconnecteddrive.phev.units.option.IMPERIAL = Angloamerikanisches System\n+thing-type.config.bmwconnecteddrive.phev.units.option.METRIC = Metrisches System\n+thing-type.config.bmwconnecteddrive.phev.imageSize.label = Bildgr\ufffd\ufffde\n+thing-type.config.bmwconnecteddrive.phev.imageSize.description = Bildgr\ufffd\ufffde des Fahrzeugs f\ufffdr L\ufffdnge und Breite\n+thing-type.config.bmwconnecteddrive.phev.imageViewport.label = Bild Ansicht\n+thing-type.config.bmwconnecteddrive.phev.imageViewport.description = Ansicht des Fahrzeugs\n+thing-type.config.bmwconnecteddrive.phev.imageViewport.option.FRONT = Vorderansicht\n+thing-type.config.bmwconnecteddrive.phev.imageViewport.option.REAR = R\ufffdckansicht\n+thing-type.config.bmwconnecteddrive.phev.imageViewport.option.SIDE = Seitenansicht\n+thing-type.config.bmwconnecteddrive.phev.imageViewport.option.DASHBOARD = Innenansicht Armaturen\n+thing-type.config.bmwconnecteddrive.phev.imageViewport.option.DRIVERDOOR = Seitenansicht Fahrert\ufffdr\n+\n+thing-type.bmwconnecteddrive.conv.label = BMW Konventionelles Fahrzeug\n+thing-type.bmwconnecteddrive.conv.description = Konventionelles Benzin/Diesel Fahrzeug (conv)\n+thing-type.config.bmwconnecteddrive.conv.vin.label = Fahrzeug Identifikationsnummer (VIN)\n+thing-type.config.bmwconnecteddrive.conv.vin.description = VIN des Fahrzeugs\n+thing-type.config.bmwconnecteddrive.conv.refreshInterval.label = Datenaktualisierung in Minuten\n+thing-type.config.bmwconnecteddrive.conv.refreshInterval.description = Rate der Datenaktualisierung Ihres Fahrzeugs\n+thing-type.config.bmwconnecteddrive.conv.units.label = Einheiten\n+thing-type.config.bmwconnecteddrive.conv.units.description = Automatische oder direkte Auswahl der Einheiten \n+thing-type.config.bmwconnecteddrive.conv.units.option.AUTODETECT = Automatische Auswahl\n+thing-type.config.bmwconnecteddrive.conv.units.option.IMPERIAL = Angloamerikanisches System\n+thing-type.config.bmwconnecteddrive.conv.units.option.METRIC = Metrisches System\n+thing-type.config.bmwconnecteddrive.conv.imageSize.label = Bildgr\ufffd\ufffde\n+thing-type.config.bmwconnecteddrive.conv.imageSize.description = Bildgr\ufffd\ufffde des Fahrzeugs f\ufffdr L\ufffdnge und Breite\n+thing-type.config.bmwconnecteddrive.conv.imageViewport.label = Bild Ansicht\n+thing-type.config.bmwconnecteddrive.conv.imageViewport.description = Ansicht des Fahrzeugs\n+thing-type.config.bmwconnecteddrive.conv.imageViewport.option.FRONT = Vorderansicht\n+thing-type.config.bmwconnecteddrive.conv.imageViewport.option.REAR = R\ufffdckansicht\n+thing-type.config.bmwconnecteddrive.conv.imageViewport.option.SIDE = Seitenansicht\n+thing-type.config.bmwconnecteddrive.conv.imageViewport.option.DASHBOARD = Innenansicht Armaturen\n+thing-type.config.bmwconnecteddrive.conv.imageViewport.option.DRIVERDOOR = Seitenansicht Fahrert\ufffdr\n+\n+# Channel Groups\n+channel-group-type.bmwconnecteddrive.charge-values.label = Elektrisches Laden\n+channel-group-type.bmwconnecteddrive.charge-values.description = Ladezustand und Ladeprofile des Fahrzeugs\n+channel-group-type.bmwconnecteddrive.ev-lifetime-values.label = Gesamtlaufzeit Statistik\n+channel-group-type.bmwconnecteddrive.ev-lifetime-values.description = Verbrauchswerte und zur\ufffdckgelegte Strecken \ufffdber die Fahrzeug-Gesamtlaufzeit\n+channel-group-type.bmwconnecteddrive.hybrid-lifetime-values.label = Gesamtlaufzeit Statistik\n+channel-group-type.bmwconnecteddrive.hybrid-lifetime-values.description = Verbrauchswerte und zur\ufffdckgelegte Strecken \ufffdber die Fahrzeug-Gesamtlaufzeit\n+channel-group-type.bmwconnecteddrive.ev-last-trip-values.label = Statistik der letzten Fahrt\n+channel-group-type.bmwconnecteddrive.ev-last-trip-values.description = Verbrauchswerte und zur\ufffdck gelegte Strecke der letzten Fahrt\n+channel-group-type.bmwconnecteddrive.hybrid-last-trip-values.label = Statistik der letzten Fahrt\n+channel-group-type.bmwconnecteddrive.hybrid-last-trip-values.description = Verbrauchswerte und zur\ufffdck gelegte Strecke der letzten Fahrt\n+channel-group-type.bmwconnecteddrive.ev-range-values.label = Elektrische Reichweite\n+channel-group-type.bmwconnecteddrive.ev-range-values.description = Tachostand, Reichweiten und Ladestand des Fahrzeugs\n+channel-group-type.bmwconnecteddrive.check-control-values.label = Warnungen\n+channel-group-type.bmwconnecteddrive.check-control-values.description = Aktuelle Warungen des Fahrzeugs\n+channel-group-type.bmwconnecteddrive.service-values.label = Wartung\n+channel-group-type.bmwconnecteddrive.service-values.description = Zuk\ufffdnftige Wartungstermine des Fahrzeugs\n+channel-group-type.bmwconnecteddrive.conv-range-values.label = Reichweite\n+channel-group-type.bmwconnecteddrive.conv-range-values.description = Tachostand, Reichweite und Tankf\ufffdllung des Fahrzeugs\n+channel-group-type.bmwconnecteddrive.hybrid-range-values.label = Hybride Reichweite\n+channel-group-type.bmwconnecteddrive.hybrid-range-values.description = Tachostand, Reichweite, Ladezustand und Tankf\ufffdllung des Fahrzeugs\n+channel-group-type.bmwconnecteddrive.image-values.label = Fahrzeug Bild\n+channel-group-type.bmwconnecteddrive.image-values.description = Bild des Fahrzeug basierend auf der Ansicht in der Konfiguration\n+channel-group-type.bmwconnecteddrive.remote-services.label = Fahrzeug Fernsteuerung\n+channel-group-type.bmwconnecteddrive.remote-services.description = Fernsteuerung des Fahrzeugs \ufffdber den BMW Server wie T\ufffdren schlie\ufffden / \ufffdffnen, Klimasteuerung und mehr\n+channel-group-type.bmwconnecteddrive.vehicle-status.label = Fahrzeug Zustand\n+channel-group-type.bmwconnecteddrive.vehicle-status.description = Zustand des Fahrzeugs \ufffdber T\ufffdren, Fenster, abgeschlossen, anstehende Wartung und aktive Warnungen\n+channel-group-type.bmwconnecteddrive.ev-vehicle-status.label = Fahrzeug Zustand\n+channel-group-type.bmwconnecteddrive.ev-vehicle-status.description = Zustand des Fahrzeugs \ufffdber T\ufffdren, Fenster, abgeschlossen, anstehende Wartung und aktive Warnungen\n+channel-group-type.bmwconnecteddrive.location-values.label = Fahrzeug Standort\n+channel-group-type.bmwconnecteddrive.location-values.description = Koordinaten und Ausrichtung des Fahrzeugs\n+channel-group-type.bmwconnecteddrive.destination-values.label = Ziele\n+channel-group-type.bmwconnecteddrive.destination-values.description = Zeigt die gepseicherten Ziele des Fahrzeugs\n+channel-group-type.bmwconnecteddrive.troubleshoot-control.label = Fehlerbehebung\n+channel-group-type.bmwconnecteddrive.troubleshoot-control.description = Generiert Daten zur Fehlerbehebung eines Problems\n+channel-group-type.bmwconnecteddrive.door-values.label = Details aller T\ufffdren\n+channel-group-type.bmwconnecteddrive.door-values.description = Zeigt die Dezails der T\ufffdren und Fenster des Fahrzeugs", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "48af48c82562d006b6f2aa35922270f181c885ed"}, "originalPosition": 136}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMjgwODMyNg==", "bodyText": "Corrected", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r602808326", "createdAt": "2021-03-28T00:10:54Z", "author": {"login": "weymann"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/resources/OH-INF/i18n/bmwconnecteddrive_de.properties", "diffHunk": "@@ -0,0 +1,261 @@\n+# Binding\n+binding.bmwconnecteddrive.name = BMW ConnectedDrive\n+binding.bmwconnecteddrive.description = Zeigt die Fahrzeugdaten \ufffdber das BMW ConnectedDrive Portal\n+\n+# bridge types\n+thing-type.bmwconnecteddrive.account.label = BMW ConnectedDrive Benutzerkonto\n+thing-type.bmwconnecteddrive.account.description = Zugriff auf das BMW ConnectedDrive Portal f\ufffdr einen Benutzer\n+thing-type.config.bmwconnecteddrive.account.userName = Benutzername f\ufffdr das ConnectedDrive Portal\n+thing-type.config.bmwconnecteddrive.account.password = Passwort f\ufffdr das ConnectedDrive Portal\n+thing-type.config.bmwconnecteddrive.account.region = Auswahl Ihrer Region zur Verbindung mit dem korrekten BMW Server \n+thing-type.config.bmwconnecteddrive.account.region.option.NORTH_AMERICA = Nordamerika \n+thing-type.config.bmwconnecteddrive.account.region.option.CHINA = China \n+thing-type.config.bmwconnecteddrive.account.region.option.ROW = Rest der Welt \n+\n+# thing types\n+thing-type.bmwconnecteddrive.bev_rex.label = BMW Elektrofahrzeug mit REX\n+thing-type.bmwconnecteddrive.bev_rex.description = BMW Elektrofahrzeug mit Range Extender (bev_rex)\n+thing-type.config.bmwconnecteddrive.bev_rex.vin.label = Fahrzeug Identifikationsnummer (VIN)\n+thing-type.config.bmwconnecteddrive.bev_rex.vin.description = VIN des Fahrzeugs\n+thing-type.config.bmwconnecteddrive.bev_rex.refreshInterval.label = Datenaktualisierung in Minuten\n+thing-type.config.bmwconnecteddrive.bev_rex.refreshInterval.description = Rate der Datenaktualisierung Ihres Fahrzeugs\n+thing-type.config.bmwconnecteddrive.bev_rex.units.label = Einheiten\n+thing-type.config.bmwconnecteddrive.bev_rex.units.description = Automatische oder direkte Auswahl der Einheiten \n+thing-type.config.bmwconnecteddrive.bev_rex.units.option.AUTODETECT = Automatische Auswahl\n+thing-type.config.bmwconnecteddrive.bev_rex.units.option.IMPERIAL = Angloamerikanisches System\n+thing-type.config.bmwconnecteddrive.bev_rex.units.option.METRIC = Metrisches System\n+thing-type.config.bmwconnecteddrive.bev_rex.imageSize.label = Bildgr\ufffd\ufffde\n+thing-type.config.bmwconnecteddrive.bev_rex.imageSize.description = Bildgr\ufffd\ufffde des Fahrzeugs f\ufffdr L\ufffdnge und Breite\n+thing-type.config.bmwconnecteddrive.bev_rex.imageViewport.label = Bild Ansicht\n+thing-type.config.bmwconnecteddrive.bev_rex.imageViewport.description = Ansicht des Fahrzeugs\n+thing-type.config.bmwconnecteddrive.bev_rex.imageViewport.option.FRONT = Vorderansicht\n+thing-type.config.bmwconnecteddrive.bev_rex.imageViewport.option.REAR = R\ufffdckansicht\n+thing-type.config.bmwconnecteddrive.bev_rex.imageViewport.option.SIDE = Seitenansicht\n+thing-type.config.bmwconnecteddrive.bev_rex.imageViewport.option.DASHBOARD = Innenansicht Armaturen\n+thing-type.config.bmwconnecteddrive.bev_rex.imageViewport.option.DRIVERDOOR = Seitenansicht Fahrert\ufffdr\n+\n+thing-type.bmwconnecteddrive.bev.label = BMW Elektrofahrzeug\n+thing-type.bmwconnecteddrive.bev.description = Batterieelektrisches Fahrzeug (bev)\n+thing-type.config.bmwconnecteddrive.bev.vin.label = Fahrzeug Identifikationsnummer (VIN)\n+thing-type.config.bmwconnecteddrive.bev.vin.description = VIN des Fahrzeugs\n+thing-type.config.bmwconnecteddrive.bev.refreshInterval.label = Datenaktualisierung in Minuten\n+thing-type.config.bmwconnecteddrive.bev.refreshInterval.description = Rate der Datenaktualisierung Ihres Fahrzeugs\n+thing-type.config.bmwconnecteddrive.bev.units.label = Einheiten\n+thing-type.config.bmwconnecteddrive.bev.units.description = Automatische oder direkte Auswahl der Einheiten \n+thing-type.config.bmwconnecteddrive.bev.units.option.AUTODETECT = Automatische Auswahl\n+thing-type.config.bmwconnecteddrive.bev.units.option.IMPERIAL = Angloamerikanisches System\n+thing-type.config.bmwconnecteddrive.bev.units.option.METRIC = Metrisches System\n+thing-type.config.bmwconnecteddrive.bev.imageSize.label = Bildgr\ufffd\ufffde\n+thing-type.config.bmwconnecteddrive.bev.imageSize.description = Bildgr\ufffd\ufffde des Fahrzeugs f\ufffdr L\ufffdnge und Breite\n+thing-type.config.bmwconnecteddrive.bev.imageViewport.label = Bild Ansicht\n+thing-type.config.bmwconnecteddrive.bev.imageViewport.description = Ansicht des Fahrzeugs\n+thing-type.config.bmwconnecteddrive.bev.imageViewport.option.FRONT = Vorderansicht\n+thing-type.config.bmwconnecteddrive.bev.imageViewport.option.REAR = R\ufffdckansicht\n+thing-type.config.bmwconnecteddrive.bev.imageViewport.option.SIDE = Seitenansicht\n+thing-type.config.bmwconnecteddrive.bev.imageViewport.option.DASHBOARD = Innenansicht Armaturen\n+thing-type.config.bmwconnecteddrive.bev.imageViewport.option.DRIVERDOOR = Seitenansicht Fahrert\ufffdr\n+\n+thing-type.bmwconnecteddrive.phev.label = BMW Plug-in-Hybrid Elektrofahrzeug\n+thing-type.bmwconnecteddrive.phev.description = Konventionelles Fahrzeug mit Elektromotor (phev)\n+thing-type.config.bmwconnecteddrive.phev.vin.label = Fahrzeug Identifikationsnummer (VIN)\n+thing-type.config.bmwconnecteddrive.phev.vin.description = VIN des Fahrzeugs\n+thing-type.config.bmwconnecteddrive.phev.refreshInterval.label = Datenaktualisierung in Minuten\n+thing-type.config.bmwconnecteddrive.phev.refreshInterval.description = Rate der Datenaktualisierung Ihres Fahrzeugs\n+thing-type.config.bmwconnecteddrive.phev.units.label = Einheiten\n+thing-type.config.bmwconnecteddrive.phev.units.description = Automatische oder direkte Auswahl der Einheiten \n+thing-type.config.bmwconnecteddrive.phev.units.option.AUTODETECT = Automatische Auswahl\n+thing-type.config.bmwconnecteddrive.phev.units.option.IMPERIAL = Angloamerikanisches System\n+thing-type.config.bmwconnecteddrive.phev.units.option.METRIC = Metrisches System\n+thing-type.config.bmwconnecteddrive.phev.imageSize.label = Bildgr\ufffd\ufffde\n+thing-type.config.bmwconnecteddrive.phev.imageSize.description = Bildgr\ufffd\ufffde des Fahrzeugs f\ufffdr L\ufffdnge und Breite\n+thing-type.config.bmwconnecteddrive.phev.imageViewport.label = Bild Ansicht\n+thing-type.config.bmwconnecteddrive.phev.imageViewport.description = Ansicht des Fahrzeugs\n+thing-type.config.bmwconnecteddrive.phev.imageViewport.option.FRONT = Vorderansicht\n+thing-type.config.bmwconnecteddrive.phev.imageViewport.option.REAR = R\ufffdckansicht\n+thing-type.config.bmwconnecteddrive.phev.imageViewport.option.SIDE = Seitenansicht\n+thing-type.config.bmwconnecteddrive.phev.imageViewport.option.DASHBOARD = Innenansicht Armaturen\n+thing-type.config.bmwconnecteddrive.phev.imageViewport.option.DRIVERDOOR = Seitenansicht Fahrert\ufffdr\n+\n+thing-type.bmwconnecteddrive.conv.label = BMW Konventionelles Fahrzeug\n+thing-type.bmwconnecteddrive.conv.description = Konventionelles Benzin/Diesel Fahrzeug (conv)\n+thing-type.config.bmwconnecteddrive.conv.vin.label = Fahrzeug Identifikationsnummer (VIN)\n+thing-type.config.bmwconnecteddrive.conv.vin.description = VIN des Fahrzeugs\n+thing-type.config.bmwconnecteddrive.conv.refreshInterval.label = Datenaktualisierung in Minuten\n+thing-type.config.bmwconnecteddrive.conv.refreshInterval.description = Rate der Datenaktualisierung Ihres Fahrzeugs\n+thing-type.config.bmwconnecteddrive.conv.units.label = Einheiten\n+thing-type.config.bmwconnecteddrive.conv.units.description = Automatische oder direkte Auswahl der Einheiten \n+thing-type.config.bmwconnecteddrive.conv.units.option.AUTODETECT = Automatische Auswahl\n+thing-type.config.bmwconnecteddrive.conv.units.option.IMPERIAL = Angloamerikanisches System\n+thing-type.config.bmwconnecteddrive.conv.units.option.METRIC = Metrisches System\n+thing-type.config.bmwconnecteddrive.conv.imageSize.label = Bildgr\ufffd\ufffde\n+thing-type.config.bmwconnecteddrive.conv.imageSize.description = Bildgr\ufffd\ufffde des Fahrzeugs f\ufffdr L\ufffdnge und Breite\n+thing-type.config.bmwconnecteddrive.conv.imageViewport.label = Bild Ansicht\n+thing-type.config.bmwconnecteddrive.conv.imageViewport.description = Ansicht des Fahrzeugs\n+thing-type.config.bmwconnecteddrive.conv.imageViewport.option.FRONT = Vorderansicht\n+thing-type.config.bmwconnecteddrive.conv.imageViewport.option.REAR = R\ufffdckansicht\n+thing-type.config.bmwconnecteddrive.conv.imageViewport.option.SIDE = Seitenansicht\n+thing-type.config.bmwconnecteddrive.conv.imageViewport.option.DASHBOARD = Innenansicht Armaturen\n+thing-type.config.bmwconnecteddrive.conv.imageViewport.option.DRIVERDOOR = Seitenansicht Fahrert\ufffdr\n+\n+# Channel Groups\n+channel-group-type.bmwconnecteddrive.charge-values.label = Elektrisches Laden\n+channel-group-type.bmwconnecteddrive.charge-values.description = Ladezustand und Ladeprofile des Fahrzeugs\n+channel-group-type.bmwconnecteddrive.ev-lifetime-values.label = Gesamtlaufzeit Statistik\n+channel-group-type.bmwconnecteddrive.ev-lifetime-values.description = Verbrauchswerte und zur\ufffdckgelegte Strecken \ufffdber die Fahrzeug-Gesamtlaufzeit\n+channel-group-type.bmwconnecteddrive.hybrid-lifetime-values.label = Gesamtlaufzeit Statistik\n+channel-group-type.bmwconnecteddrive.hybrid-lifetime-values.description = Verbrauchswerte und zur\ufffdckgelegte Strecken \ufffdber die Fahrzeug-Gesamtlaufzeit\n+channel-group-type.bmwconnecteddrive.ev-last-trip-values.label = Statistik der letzten Fahrt\n+channel-group-type.bmwconnecteddrive.ev-last-trip-values.description = Verbrauchswerte und zur\ufffdck gelegte Strecke der letzten Fahrt\n+channel-group-type.bmwconnecteddrive.hybrid-last-trip-values.label = Statistik der letzten Fahrt\n+channel-group-type.bmwconnecteddrive.hybrid-last-trip-values.description = Verbrauchswerte und zur\ufffdck gelegte Strecke der letzten Fahrt\n+channel-group-type.bmwconnecteddrive.ev-range-values.label = Elektrische Reichweite\n+channel-group-type.bmwconnecteddrive.ev-range-values.description = Tachostand, Reichweiten und Ladestand des Fahrzeugs\n+channel-group-type.bmwconnecteddrive.check-control-values.label = Warnungen\n+channel-group-type.bmwconnecteddrive.check-control-values.description = Aktuelle Warungen des Fahrzeugs\n+channel-group-type.bmwconnecteddrive.service-values.label = Wartung\n+channel-group-type.bmwconnecteddrive.service-values.description = Zuk\ufffdnftige Wartungstermine des Fahrzeugs\n+channel-group-type.bmwconnecteddrive.conv-range-values.label = Reichweite\n+channel-group-type.bmwconnecteddrive.conv-range-values.description = Tachostand, Reichweite und Tankf\ufffdllung des Fahrzeugs\n+channel-group-type.bmwconnecteddrive.hybrid-range-values.label = Hybride Reichweite\n+channel-group-type.bmwconnecteddrive.hybrid-range-values.description = Tachostand, Reichweite, Ladezustand und Tankf\ufffdllung des Fahrzeugs\n+channel-group-type.bmwconnecteddrive.image-values.label = Fahrzeug Bild\n+channel-group-type.bmwconnecteddrive.image-values.description = Bild des Fahrzeug basierend auf der Ansicht in der Konfiguration\n+channel-group-type.bmwconnecteddrive.remote-services.label = Fahrzeug Fernsteuerung\n+channel-group-type.bmwconnecteddrive.remote-services.description = Fernsteuerung des Fahrzeugs \ufffdber den BMW Server wie T\ufffdren schlie\ufffden / \ufffdffnen, Klimasteuerung und mehr\n+channel-group-type.bmwconnecteddrive.vehicle-status.label = Fahrzeug Zustand\n+channel-group-type.bmwconnecteddrive.vehicle-status.description = Zustand des Fahrzeugs \ufffdber T\ufffdren, Fenster, abgeschlossen, anstehende Wartung und aktive Warnungen\n+channel-group-type.bmwconnecteddrive.ev-vehicle-status.label = Fahrzeug Zustand\n+channel-group-type.bmwconnecteddrive.ev-vehicle-status.description = Zustand des Fahrzeugs \ufffdber T\ufffdren, Fenster, abgeschlossen, anstehende Wartung und aktive Warnungen\n+channel-group-type.bmwconnecteddrive.location-values.label = Fahrzeug Standort\n+channel-group-type.bmwconnecteddrive.location-values.description = Koordinaten und Ausrichtung des Fahrzeugs\n+channel-group-type.bmwconnecteddrive.destination-values.label = Ziele\n+channel-group-type.bmwconnecteddrive.destination-values.description = Zeigt die gepseicherten Ziele des Fahrzeugs\n+channel-group-type.bmwconnecteddrive.troubleshoot-control.label = Fehlerbehebung\n+channel-group-type.bmwconnecteddrive.troubleshoot-control.description = Generiert Daten zur Fehlerbehebung eines Problems\n+channel-group-type.bmwconnecteddrive.door-values.label = Details aller T\ufffdren\n+channel-group-type.bmwconnecteddrive.door-values.description = Zeigt die Dezails der T\ufffdren und Fenster des Fahrzeugs", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5NzkzMzIyMw=="}, "originalCommit": {"oid": "48af48c82562d006b6f2aa35922270f181c885ed"}, "originalPosition": 136}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzc3Njg3MzQ0OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/resources/OH-INF/i18n/bmwconnecteddrive_de.properties", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0xOVQxOTo0MjoyOVrOI6O-rw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0yNFQwMDo0NDowNFrOI8RLcg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5NzkzMzc0Mw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            channel-type.bmwconnecteddrive.destination-gps-channel.label = Ziel Koordinaten\n          \n          \n            \n            channel-type.bmwconnecteddrive.destination-gps-channel.label = Zielkoordinaten", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r597933743", "createdAt": "2021-03-19T19:42:29Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/resources/OH-INF/i18n/bmwconnecteddrive_de.properties", "diffHunk": "@@ -0,0 +1,261 @@\n+# Binding\n+binding.bmwconnecteddrive.name = BMW ConnectedDrive\n+binding.bmwconnecteddrive.description = Zeigt die Fahrzeugdaten \ufffdber das BMW ConnectedDrive Portal\n+\n+# bridge types\n+thing-type.bmwconnecteddrive.account.label = BMW ConnectedDrive Benutzerkonto\n+thing-type.bmwconnecteddrive.account.description = Zugriff auf das BMW ConnectedDrive Portal f\ufffdr einen Benutzer\n+thing-type.config.bmwconnecteddrive.account.userName = Benutzername f\ufffdr das ConnectedDrive Portal\n+thing-type.config.bmwconnecteddrive.account.password = Passwort f\ufffdr das ConnectedDrive Portal\n+thing-type.config.bmwconnecteddrive.account.region = Auswahl Ihrer Region zur Verbindung mit dem korrekten BMW Server \n+thing-type.config.bmwconnecteddrive.account.region.option.NORTH_AMERICA = Nordamerika \n+thing-type.config.bmwconnecteddrive.account.region.option.CHINA = China \n+thing-type.config.bmwconnecteddrive.account.region.option.ROW = Rest der Welt \n+\n+# thing types\n+thing-type.bmwconnecteddrive.bev_rex.label = BMW Elektrofahrzeug mit REX\n+thing-type.bmwconnecteddrive.bev_rex.description = BMW Elektrofahrzeug mit Range Extender (bev_rex)\n+thing-type.config.bmwconnecteddrive.bev_rex.vin.label = Fahrzeug Identifikationsnummer (VIN)\n+thing-type.config.bmwconnecteddrive.bev_rex.vin.description = VIN des Fahrzeugs\n+thing-type.config.bmwconnecteddrive.bev_rex.refreshInterval.label = Datenaktualisierung in Minuten\n+thing-type.config.bmwconnecteddrive.bev_rex.refreshInterval.description = Rate der Datenaktualisierung Ihres Fahrzeugs\n+thing-type.config.bmwconnecteddrive.bev_rex.units.label = Einheiten\n+thing-type.config.bmwconnecteddrive.bev_rex.units.description = Automatische oder direkte Auswahl der Einheiten \n+thing-type.config.bmwconnecteddrive.bev_rex.units.option.AUTODETECT = Automatische Auswahl\n+thing-type.config.bmwconnecteddrive.bev_rex.units.option.IMPERIAL = Angloamerikanisches System\n+thing-type.config.bmwconnecteddrive.bev_rex.units.option.METRIC = Metrisches System\n+thing-type.config.bmwconnecteddrive.bev_rex.imageSize.label = Bildgr\ufffd\ufffde\n+thing-type.config.bmwconnecteddrive.bev_rex.imageSize.description = Bildgr\ufffd\ufffde des Fahrzeugs f\ufffdr L\ufffdnge und Breite\n+thing-type.config.bmwconnecteddrive.bev_rex.imageViewport.label = Bild Ansicht\n+thing-type.config.bmwconnecteddrive.bev_rex.imageViewport.description = Ansicht des Fahrzeugs\n+thing-type.config.bmwconnecteddrive.bev_rex.imageViewport.option.FRONT = Vorderansicht\n+thing-type.config.bmwconnecteddrive.bev_rex.imageViewport.option.REAR = R\ufffdckansicht\n+thing-type.config.bmwconnecteddrive.bev_rex.imageViewport.option.SIDE = Seitenansicht\n+thing-type.config.bmwconnecteddrive.bev_rex.imageViewport.option.DASHBOARD = Innenansicht Armaturen\n+thing-type.config.bmwconnecteddrive.bev_rex.imageViewport.option.DRIVERDOOR = Seitenansicht Fahrert\ufffdr\n+\n+thing-type.bmwconnecteddrive.bev.label = BMW Elektrofahrzeug\n+thing-type.bmwconnecteddrive.bev.description = Batterieelektrisches Fahrzeug (bev)\n+thing-type.config.bmwconnecteddrive.bev.vin.label = Fahrzeug Identifikationsnummer (VIN)\n+thing-type.config.bmwconnecteddrive.bev.vin.description = VIN des Fahrzeugs\n+thing-type.config.bmwconnecteddrive.bev.refreshInterval.label = Datenaktualisierung in Minuten\n+thing-type.config.bmwconnecteddrive.bev.refreshInterval.description = Rate der Datenaktualisierung Ihres Fahrzeugs\n+thing-type.config.bmwconnecteddrive.bev.units.label = Einheiten\n+thing-type.config.bmwconnecteddrive.bev.units.description = Automatische oder direkte Auswahl der Einheiten \n+thing-type.config.bmwconnecteddrive.bev.units.option.AUTODETECT = Automatische Auswahl\n+thing-type.config.bmwconnecteddrive.bev.units.option.IMPERIAL = Angloamerikanisches System\n+thing-type.config.bmwconnecteddrive.bev.units.option.METRIC = Metrisches System\n+thing-type.config.bmwconnecteddrive.bev.imageSize.label = Bildgr\ufffd\ufffde\n+thing-type.config.bmwconnecteddrive.bev.imageSize.description = Bildgr\ufffd\ufffde des Fahrzeugs f\ufffdr L\ufffdnge und Breite\n+thing-type.config.bmwconnecteddrive.bev.imageViewport.label = Bild Ansicht\n+thing-type.config.bmwconnecteddrive.bev.imageViewport.description = Ansicht des Fahrzeugs\n+thing-type.config.bmwconnecteddrive.bev.imageViewport.option.FRONT = Vorderansicht\n+thing-type.config.bmwconnecteddrive.bev.imageViewport.option.REAR = R\ufffdckansicht\n+thing-type.config.bmwconnecteddrive.bev.imageViewport.option.SIDE = Seitenansicht\n+thing-type.config.bmwconnecteddrive.bev.imageViewport.option.DASHBOARD = Innenansicht Armaturen\n+thing-type.config.bmwconnecteddrive.bev.imageViewport.option.DRIVERDOOR = Seitenansicht Fahrert\ufffdr\n+\n+thing-type.bmwconnecteddrive.phev.label = BMW Plug-in-Hybrid Elektrofahrzeug\n+thing-type.bmwconnecteddrive.phev.description = Konventionelles Fahrzeug mit Elektromotor (phev)\n+thing-type.config.bmwconnecteddrive.phev.vin.label = Fahrzeug Identifikationsnummer (VIN)\n+thing-type.config.bmwconnecteddrive.phev.vin.description = VIN des Fahrzeugs\n+thing-type.config.bmwconnecteddrive.phev.refreshInterval.label = Datenaktualisierung in Minuten\n+thing-type.config.bmwconnecteddrive.phev.refreshInterval.description = Rate der Datenaktualisierung Ihres Fahrzeugs\n+thing-type.config.bmwconnecteddrive.phev.units.label = Einheiten\n+thing-type.config.bmwconnecteddrive.phev.units.description = Automatische oder direkte Auswahl der Einheiten \n+thing-type.config.bmwconnecteddrive.phev.units.option.AUTODETECT = Automatische Auswahl\n+thing-type.config.bmwconnecteddrive.phev.units.option.IMPERIAL = Angloamerikanisches System\n+thing-type.config.bmwconnecteddrive.phev.units.option.METRIC = Metrisches System\n+thing-type.config.bmwconnecteddrive.phev.imageSize.label = Bildgr\ufffd\ufffde\n+thing-type.config.bmwconnecteddrive.phev.imageSize.description = Bildgr\ufffd\ufffde des Fahrzeugs f\ufffdr L\ufffdnge und Breite\n+thing-type.config.bmwconnecteddrive.phev.imageViewport.label = Bild Ansicht\n+thing-type.config.bmwconnecteddrive.phev.imageViewport.description = Ansicht des Fahrzeugs\n+thing-type.config.bmwconnecteddrive.phev.imageViewport.option.FRONT = Vorderansicht\n+thing-type.config.bmwconnecteddrive.phev.imageViewport.option.REAR = R\ufffdckansicht\n+thing-type.config.bmwconnecteddrive.phev.imageViewport.option.SIDE = Seitenansicht\n+thing-type.config.bmwconnecteddrive.phev.imageViewport.option.DASHBOARD = Innenansicht Armaturen\n+thing-type.config.bmwconnecteddrive.phev.imageViewport.option.DRIVERDOOR = Seitenansicht Fahrert\ufffdr\n+\n+thing-type.bmwconnecteddrive.conv.label = BMW Konventionelles Fahrzeug\n+thing-type.bmwconnecteddrive.conv.description = Konventionelles Benzin/Diesel Fahrzeug (conv)\n+thing-type.config.bmwconnecteddrive.conv.vin.label = Fahrzeug Identifikationsnummer (VIN)\n+thing-type.config.bmwconnecteddrive.conv.vin.description = VIN des Fahrzeugs\n+thing-type.config.bmwconnecteddrive.conv.refreshInterval.label = Datenaktualisierung in Minuten\n+thing-type.config.bmwconnecteddrive.conv.refreshInterval.description = Rate der Datenaktualisierung Ihres Fahrzeugs\n+thing-type.config.bmwconnecteddrive.conv.units.label = Einheiten\n+thing-type.config.bmwconnecteddrive.conv.units.description = Automatische oder direkte Auswahl der Einheiten \n+thing-type.config.bmwconnecteddrive.conv.units.option.AUTODETECT = Automatische Auswahl\n+thing-type.config.bmwconnecteddrive.conv.units.option.IMPERIAL = Angloamerikanisches System\n+thing-type.config.bmwconnecteddrive.conv.units.option.METRIC = Metrisches System\n+thing-type.config.bmwconnecteddrive.conv.imageSize.label = Bildgr\ufffd\ufffde\n+thing-type.config.bmwconnecteddrive.conv.imageSize.description = Bildgr\ufffd\ufffde des Fahrzeugs f\ufffdr L\ufffdnge und Breite\n+thing-type.config.bmwconnecteddrive.conv.imageViewport.label = Bild Ansicht\n+thing-type.config.bmwconnecteddrive.conv.imageViewport.description = Ansicht des Fahrzeugs\n+thing-type.config.bmwconnecteddrive.conv.imageViewport.option.FRONT = Vorderansicht\n+thing-type.config.bmwconnecteddrive.conv.imageViewport.option.REAR = R\ufffdckansicht\n+thing-type.config.bmwconnecteddrive.conv.imageViewport.option.SIDE = Seitenansicht\n+thing-type.config.bmwconnecteddrive.conv.imageViewport.option.DASHBOARD = Innenansicht Armaturen\n+thing-type.config.bmwconnecteddrive.conv.imageViewport.option.DRIVERDOOR = Seitenansicht Fahrert\ufffdr\n+\n+# Channel Groups\n+channel-group-type.bmwconnecteddrive.charge-values.label = Elektrisches Laden\n+channel-group-type.bmwconnecteddrive.charge-values.description = Ladezustand und Ladeprofile des Fahrzeugs\n+channel-group-type.bmwconnecteddrive.ev-lifetime-values.label = Gesamtlaufzeit Statistik\n+channel-group-type.bmwconnecteddrive.ev-lifetime-values.description = Verbrauchswerte und zur\ufffdckgelegte Strecken \ufffdber die Fahrzeug-Gesamtlaufzeit\n+channel-group-type.bmwconnecteddrive.hybrid-lifetime-values.label = Gesamtlaufzeit Statistik\n+channel-group-type.bmwconnecteddrive.hybrid-lifetime-values.description = Verbrauchswerte und zur\ufffdckgelegte Strecken \ufffdber die Fahrzeug-Gesamtlaufzeit\n+channel-group-type.bmwconnecteddrive.ev-last-trip-values.label = Statistik der letzten Fahrt\n+channel-group-type.bmwconnecteddrive.ev-last-trip-values.description = Verbrauchswerte und zur\ufffdck gelegte Strecke der letzten Fahrt\n+channel-group-type.bmwconnecteddrive.hybrid-last-trip-values.label = Statistik der letzten Fahrt\n+channel-group-type.bmwconnecteddrive.hybrid-last-trip-values.description = Verbrauchswerte und zur\ufffdck gelegte Strecke der letzten Fahrt\n+channel-group-type.bmwconnecteddrive.ev-range-values.label = Elektrische Reichweite\n+channel-group-type.bmwconnecteddrive.ev-range-values.description = Tachostand, Reichweiten und Ladestand des Fahrzeugs\n+channel-group-type.bmwconnecteddrive.check-control-values.label = Warnungen\n+channel-group-type.bmwconnecteddrive.check-control-values.description = Aktuelle Warungen des Fahrzeugs\n+channel-group-type.bmwconnecteddrive.service-values.label = Wartung\n+channel-group-type.bmwconnecteddrive.service-values.description = Zuk\ufffdnftige Wartungstermine des Fahrzeugs\n+channel-group-type.bmwconnecteddrive.conv-range-values.label = Reichweite\n+channel-group-type.bmwconnecteddrive.conv-range-values.description = Tachostand, Reichweite und Tankf\ufffdllung des Fahrzeugs\n+channel-group-type.bmwconnecteddrive.hybrid-range-values.label = Hybride Reichweite\n+channel-group-type.bmwconnecteddrive.hybrid-range-values.description = Tachostand, Reichweite, Ladezustand und Tankf\ufffdllung des Fahrzeugs\n+channel-group-type.bmwconnecteddrive.image-values.label = Fahrzeug Bild\n+channel-group-type.bmwconnecteddrive.image-values.description = Bild des Fahrzeug basierend auf der Ansicht in der Konfiguration\n+channel-group-type.bmwconnecteddrive.remote-services.label = Fahrzeug Fernsteuerung\n+channel-group-type.bmwconnecteddrive.remote-services.description = Fernsteuerung des Fahrzeugs \ufffdber den BMW Server wie T\ufffdren schlie\ufffden / \ufffdffnen, Klimasteuerung und mehr\n+channel-group-type.bmwconnecteddrive.vehicle-status.label = Fahrzeug Zustand\n+channel-group-type.bmwconnecteddrive.vehicle-status.description = Zustand des Fahrzeugs \ufffdber T\ufffdren, Fenster, abgeschlossen, anstehende Wartung und aktive Warnungen\n+channel-group-type.bmwconnecteddrive.ev-vehicle-status.label = Fahrzeug Zustand\n+channel-group-type.bmwconnecteddrive.ev-vehicle-status.description = Zustand des Fahrzeugs \ufffdber T\ufffdren, Fenster, abgeschlossen, anstehende Wartung und aktive Warnungen\n+channel-group-type.bmwconnecteddrive.location-values.label = Fahrzeug Standort\n+channel-group-type.bmwconnecteddrive.location-values.description = Koordinaten und Ausrichtung des Fahrzeugs\n+channel-group-type.bmwconnecteddrive.destination-values.label = Ziele\n+channel-group-type.bmwconnecteddrive.destination-values.description = Zeigt die gepseicherten Ziele des Fahrzeugs\n+channel-group-type.bmwconnecteddrive.troubleshoot-control.label = Fehlerbehebung\n+channel-group-type.bmwconnecteddrive.troubleshoot-control.description = Generiert Daten zur Fehlerbehebung eines Problems\n+channel-group-type.bmwconnecteddrive.door-values.label = Details aller T\ufffdren\n+channel-group-type.bmwconnecteddrive.door-values.description = Zeigt die Dezails der T\ufffdren und Fenster des Fahrzeugs\n+\n+# Channel Types\n+channel-type.bmwconnecteddrive.doors-channel.label = Gesamtzustand der T\ufffdren\n+channel-type.bmwconnecteddrive.windows-channel.label = Gesamtzustand der Fenster\n+channel-type.bmwconnecteddrive.lock-channel.label = Fahrzeug Abgeschlossen\n+channel-type.bmwconnecteddrive.next-service-date-channel.label = N\ufffdchster Service Termin\n+channel-type.bmwconnecteddrive.next-service-mileage-channel.label = N\ufffdchster Service in Kilometern\n+channel-type.bmwconnecteddrive.check-control-channel.label = Warnung Aktiv\n+channel-type.bmwconnecteddrive.charging-status-channel.label = Ladezustand\n+channel-type.bmwconnecteddrive.last-update-channel.label = Letzte Aktualisierung\n+\n+channel-type.bmwconnecteddrive.driver-front-channel.label = Fahrert\ufffdr \n+channel-type.bmwconnecteddrive.driver-rear-channel.label = Fahrert\ufffdr Hinten\n+channel-type.bmwconnecteddrive.passenger-front-channel.label = Beifahrert\ufffdr\n+channel-type.bmwconnecteddrive.passenger-rear-channel.label = Beifahrert\ufffdr Hinten\n+channel-type.bmwconnecteddrive.hood-channel.label = Frontklappe\n+channel-type.bmwconnecteddrive.trunk-channel.label = Heckklappe\n+channel-type.bmwconnecteddrive.window-driver-front-channel.label = Fahrert\ufffdr Fenster\n+channel-type.bmwconnecteddrive.window-driver-rear-channel.label = Fahrert\ufffdr Hinten Fenster\n+channel-type.bmwconnecteddrive.window-passenger-front-channel.label = Beifahrert\ufffdr Fenster\n+channel-type.bmwconnecteddrive.window-passenger-rear-channel.label = Beifahrert\ufffdr Hinten Fenster\n+channel-type.bmwconnecteddrive.window-rear-channel.label = Heckfenster\n+channel-type.bmwconnecteddrive.sunroof-channel.label = Schiebedach\n+\n+channel-type.bmwconnecteddrive.mileage-channel.label = Tachostand\n+channel-type.bmwconnecteddrive.range-hybrid-channel.label = Hybride Reichweite\n+channel-type.bmwconnecteddrive.range-electric-channel.label = Elektrische Reichweite \n+channel-type.bmwconnecteddrive.soc-channel.label = Batterie Ladestand\n+channel-type.bmwconnecteddrive.range-fuel-channel.label = Verbrenner Reichweite\n+channel-type.bmwconnecteddrive.remaining-fuel-channel.label = Tankstand\n+channel-type.bmwconnecteddrive.range-radius-electric-channel.label = Elektrischer Reichweiten-Radius\n+channel-type.bmwconnecteddrive.range-radius-fuel-channel.label =  Verbrenner Reichweiten-Radius\n+channel-type.bmwconnecteddrive.range-radius-hybrid-channel.label = Hybrider Reichweiten-Radius\n+\n+channel-type.bmwconnecteddrive.service-name-channel.label = Service\n+channel-type.bmwconnecteddrive.service-details-channel.label = Service Details\n+channel-type.bmwconnecteddrive.service-date-channel.label = Service Termin\n+channel-type.bmwconnecteddrive.service-mileage-channel.label = Service in Kilometern\n+\n+channel-type.bmwconnecteddrive.checkcontrol-name-channel.label = Warnung\n+channel-type.bmwconnecteddrive.checkcontrol-details-channel.label = Warnung Details\n+channel-type.bmwconnecteddrive.checkcontrol-mileage-channel.label = Warnung bei Kilometer\n+\n+channel-type.bmwconnecteddrive.profile-climate-channel.label = Klimatisierung bei Abfahrt\n+channel-type.bmwconnecteddrive.profile-mode-channel.label = Ladeprofil Methode\n+channel-type.bmwconnecteddrive.profile-prefs-channel.label = Ladeprofil Pr\ufffdferenz\n+channel-type.bmwconnecteddrive.window-start-channel.label = Startzeit Ladefenster\n+channel-type.bmwconnecteddrive.window-start-hour-channel.label = Startzeit Ladefenster Stunde\n+channel-type.bmwconnecteddrive.window-start-minute-channel.label = Startzeit Ladefenster Minute\n+channel-type.bmwconnecteddrive.window-end-channel.label = Endzeit Ladefenster\n+channel-type.bmwconnecteddrive.window-end-hour-channel.label = Endzeit Ladefenster Stunde\n+channel-type.bmwconnecteddrive.window-end-minute-channel.label = Endzeit Ladefenster Minute\n+channel-type.bmwconnecteddrive.timer1-enabled-channel.label = Zeitprofil 1 - Aktiviert\n+channel-type.bmwconnecteddrive.timer1-departure-channel.label = Zeitprofil 1 - Abfahrtszeit\n+channel-type.bmwconnecteddrive.timer1-departure-hour-channel.label = Zeitprofil 1 - Abfahrtszeit Stunde\n+channel-type.bmwconnecteddrive.timer1-departure-minute-channel.label = Zeitprofil 1 - Abfahrtszeit Minute\n+channel-type.bmwconnecteddrive.timer1-days-channel.label = Zeitprofil 1 - Tage\n+channel-type.bmwconnecteddrive.timer1-day-mon-channel.label = Zeitprofil 1 - Montag\n+channel-type.bmwconnecteddrive.timer1-day-tue-channel.label = Zeitprofil 1 - Dienstag\n+channel-type.bmwconnecteddrive.timer1-day-wed-channel.label = Zeitprofil 1 - Mittwoch\n+channel-type.bmwconnecteddrive.timer1-day-thu-channel.label = Zeitprofil 1 - Donnerstag\n+channel-type.bmwconnecteddrive.timer1-day-fri-channel.label = Zeitprofil 1 - Freitag\n+channel-type.bmwconnecteddrive.timer1-day-sat-channel.label = Zeitprofil 1 - Samstag\n+channel-type.bmwconnecteddrive.timer1-day-sun-channel.label = Zeitprofil 1 - Sonntag\n+channel-type.bmwconnecteddrive.timer2-enabled-channel.label = Zeitprofil 2 - Aktiviert\n+channel-type.bmwconnecteddrive.timer2-departure-channel.label = Zeitprofil 2 - Abfahrtszeit\n+channel-type.bmwconnecteddrive.timer2-departure-hour-channel.label = Zeitprofil 2 - Abfahrtszeit Stunde\n+channel-type.bmwconnecteddrive.timer2-departure-minute-channel.label = Zeitprofil 2 - Abfahrtszeit Minute\n+channel-type.bmwconnecteddrive.timer2-days-channel.label = Zeitprofil 2 - Tage\n+channel-type.bmwconnecteddrive.timer2-day-mon-channel.label = Zeitprofil 2 - Montag\n+channel-type.bmwconnecteddrive.timer2-day-tue-channel.label = Zeitprofil 2 - Dienstag\n+channel-type.bmwconnecteddrive.timer2-day-wed-channel.label = Zeitprofil 2 - Mittwoch\n+channel-type.bmwconnecteddrive.timer2-day-thu-channel.label = Zeitprofil 2 - Donnerstag\n+channel-type.bmwconnecteddrive.timer2-day-fri-channel.label = Zeitprofil 2 - Freitag\n+channel-type.bmwconnecteddrive.timer2-day-sat-channel.label = Zeitprofil 2 - Samstag\n+channel-type.bmwconnecteddrive.timer2-day-sun-channel.label = Zeitprofil 2 - Sonnatg\n+channel-type.bmwconnecteddrive.timer3-enabled-channel.label = Zeitprofil 3 - Aktiviert\n+channel-type.bmwconnecteddrive.timer3-departure-channel.label = Zeitprofil 3 - Abfahrtszeit\n+channel-type.bmwconnecteddrive.timer3-departure-hour-channel.label = Zeitprofil 3 - Abfahrtszeit Stunde\n+channel-type.bmwconnecteddrive.timer3-departure-minute-channel.label = Zeitprofil 3 - Abfahrtszeit Minute\n+channel-type.bmwconnecteddrive.timer3-days-channel.label = Zeitprofil 3 - Tage\n+channel-type.bmwconnecteddrive.timer3-day-mon-channel.label = Zeitprofil 3 - Montag\n+channel-type.bmwconnecteddrive.timer3-day-tue-channel.label = Zeitprofil 3 - Dienstag\n+channel-type.bmwconnecteddrive.timer3-day-wed-channel.label = Zeitprofil 3 - Mittwoch\n+channel-type.bmwconnecteddrive.timer3-day-thu-channel.label = Zeitprofil 3 - Donnerstag\n+channel-type.bmwconnecteddrive.timer3-day-fri-channel.label = Zeitprofil 3 - Freitag\n+channel-type.bmwconnecteddrive.timer3-day-sat-channel.label = Zeitprofil 3 - Samstag\n+channel-type.bmwconnecteddrive.timer3-day-sun-channel.label = Zeitprofil 3 - Sonntag\n+channel-type.bmwconnecteddrive.override-departure-channel.label = Einmaliges Zeitprofil - Abfahrtszeit\n+channel-type.bmwconnecteddrive.override-departure-hour-channel.label = Einmaliges Zeitprofil - Abfahrtszeit Stunde \n+channel-type.bmwconnecteddrive.override-departure-minute-channel.label = Einmaliges Zeitprofil - Abfahrtszeit Minute\n+channel-type.bmwconnecteddrive.override-enabled-channel.label = Einmaliges Zeitprofil - Aktiviert\n+\n+channel-type.bmwconnecteddrive.destination-name-channel.label = Zieladresse\n+channel-type.bmwconnecteddrive.destination-gps-channel.label = Ziel Koordinaten", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "48af48c82562d006b6f2aa35922270f181c885ed"}, "originalPosition": 231}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMDA2NjkzMA==", "bodyText": "corrected", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r600066930", "createdAt": "2021-03-24T00:44:04Z", "author": {"login": "weymann"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/resources/OH-INF/i18n/bmwconnecteddrive_de.properties", "diffHunk": "@@ -0,0 +1,261 @@\n+# Binding\n+binding.bmwconnecteddrive.name = BMW ConnectedDrive\n+binding.bmwconnecteddrive.description = Zeigt die Fahrzeugdaten \ufffdber das BMW ConnectedDrive Portal\n+\n+# bridge types\n+thing-type.bmwconnecteddrive.account.label = BMW ConnectedDrive Benutzerkonto\n+thing-type.bmwconnecteddrive.account.description = Zugriff auf das BMW ConnectedDrive Portal f\ufffdr einen Benutzer\n+thing-type.config.bmwconnecteddrive.account.userName = Benutzername f\ufffdr das ConnectedDrive Portal\n+thing-type.config.bmwconnecteddrive.account.password = Passwort f\ufffdr das ConnectedDrive Portal\n+thing-type.config.bmwconnecteddrive.account.region = Auswahl Ihrer Region zur Verbindung mit dem korrekten BMW Server \n+thing-type.config.bmwconnecteddrive.account.region.option.NORTH_AMERICA = Nordamerika \n+thing-type.config.bmwconnecteddrive.account.region.option.CHINA = China \n+thing-type.config.bmwconnecteddrive.account.region.option.ROW = Rest der Welt \n+\n+# thing types\n+thing-type.bmwconnecteddrive.bev_rex.label = BMW Elektrofahrzeug mit REX\n+thing-type.bmwconnecteddrive.bev_rex.description = BMW Elektrofahrzeug mit Range Extender (bev_rex)\n+thing-type.config.bmwconnecteddrive.bev_rex.vin.label = Fahrzeug Identifikationsnummer (VIN)\n+thing-type.config.bmwconnecteddrive.bev_rex.vin.description = VIN des Fahrzeugs\n+thing-type.config.bmwconnecteddrive.bev_rex.refreshInterval.label = Datenaktualisierung in Minuten\n+thing-type.config.bmwconnecteddrive.bev_rex.refreshInterval.description = Rate der Datenaktualisierung Ihres Fahrzeugs\n+thing-type.config.bmwconnecteddrive.bev_rex.units.label = Einheiten\n+thing-type.config.bmwconnecteddrive.bev_rex.units.description = Automatische oder direkte Auswahl der Einheiten \n+thing-type.config.bmwconnecteddrive.bev_rex.units.option.AUTODETECT = Automatische Auswahl\n+thing-type.config.bmwconnecteddrive.bev_rex.units.option.IMPERIAL = Angloamerikanisches System\n+thing-type.config.bmwconnecteddrive.bev_rex.units.option.METRIC = Metrisches System\n+thing-type.config.bmwconnecteddrive.bev_rex.imageSize.label = Bildgr\ufffd\ufffde\n+thing-type.config.bmwconnecteddrive.bev_rex.imageSize.description = Bildgr\ufffd\ufffde des Fahrzeugs f\ufffdr L\ufffdnge und Breite\n+thing-type.config.bmwconnecteddrive.bev_rex.imageViewport.label = Bild Ansicht\n+thing-type.config.bmwconnecteddrive.bev_rex.imageViewport.description = Ansicht des Fahrzeugs\n+thing-type.config.bmwconnecteddrive.bev_rex.imageViewport.option.FRONT = Vorderansicht\n+thing-type.config.bmwconnecteddrive.bev_rex.imageViewport.option.REAR = R\ufffdckansicht\n+thing-type.config.bmwconnecteddrive.bev_rex.imageViewport.option.SIDE = Seitenansicht\n+thing-type.config.bmwconnecteddrive.bev_rex.imageViewport.option.DASHBOARD = Innenansicht Armaturen\n+thing-type.config.bmwconnecteddrive.bev_rex.imageViewport.option.DRIVERDOOR = Seitenansicht Fahrert\ufffdr\n+\n+thing-type.bmwconnecteddrive.bev.label = BMW Elektrofahrzeug\n+thing-type.bmwconnecteddrive.bev.description = Batterieelektrisches Fahrzeug (bev)\n+thing-type.config.bmwconnecteddrive.bev.vin.label = Fahrzeug Identifikationsnummer (VIN)\n+thing-type.config.bmwconnecteddrive.bev.vin.description = VIN des Fahrzeugs\n+thing-type.config.bmwconnecteddrive.bev.refreshInterval.label = Datenaktualisierung in Minuten\n+thing-type.config.bmwconnecteddrive.bev.refreshInterval.description = Rate der Datenaktualisierung Ihres Fahrzeugs\n+thing-type.config.bmwconnecteddrive.bev.units.label = Einheiten\n+thing-type.config.bmwconnecteddrive.bev.units.description = Automatische oder direkte Auswahl der Einheiten \n+thing-type.config.bmwconnecteddrive.bev.units.option.AUTODETECT = Automatische Auswahl\n+thing-type.config.bmwconnecteddrive.bev.units.option.IMPERIAL = Angloamerikanisches System\n+thing-type.config.bmwconnecteddrive.bev.units.option.METRIC = Metrisches System\n+thing-type.config.bmwconnecteddrive.bev.imageSize.label = Bildgr\ufffd\ufffde\n+thing-type.config.bmwconnecteddrive.bev.imageSize.description = Bildgr\ufffd\ufffde des Fahrzeugs f\ufffdr L\ufffdnge und Breite\n+thing-type.config.bmwconnecteddrive.bev.imageViewport.label = Bild Ansicht\n+thing-type.config.bmwconnecteddrive.bev.imageViewport.description = Ansicht des Fahrzeugs\n+thing-type.config.bmwconnecteddrive.bev.imageViewport.option.FRONT = Vorderansicht\n+thing-type.config.bmwconnecteddrive.bev.imageViewport.option.REAR = R\ufffdckansicht\n+thing-type.config.bmwconnecteddrive.bev.imageViewport.option.SIDE = Seitenansicht\n+thing-type.config.bmwconnecteddrive.bev.imageViewport.option.DASHBOARD = Innenansicht Armaturen\n+thing-type.config.bmwconnecteddrive.bev.imageViewport.option.DRIVERDOOR = Seitenansicht Fahrert\ufffdr\n+\n+thing-type.bmwconnecteddrive.phev.label = BMW Plug-in-Hybrid Elektrofahrzeug\n+thing-type.bmwconnecteddrive.phev.description = Konventionelles Fahrzeug mit Elektromotor (phev)\n+thing-type.config.bmwconnecteddrive.phev.vin.label = Fahrzeug Identifikationsnummer (VIN)\n+thing-type.config.bmwconnecteddrive.phev.vin.description = VIN des Fahrzeugs\n+thing-type.config.bmwconnecteddrive.phev.refreshInterval.label = Datenaktualisierung in Minuten\n+thing-type.config.bmwconnecteddrive.phev.refreshInterval.description = Rate der Datenaktualisierung Ihres Fahrzeugs\n+thing-type.config.bmwconnecteddrive.phev.units.label = Einheiten\n+thing-type.config.bmwconnecteddrive.phev.units.description = Automatische oder direkte Auswahl der Einheiten \n+thing-type.config.bmwconnecteddrive.phev.units.option.AUTODETECT = Automatische Auswahl\n+thing-type.config.bmwconnecteddrive.phev.units.option.IMPERIAL = Angloamerikanisches System\n+thing-type.config.bmwconnecteddrive.phev.units.option.METRIC = Metrisches System\n+thing-type.config.bmwconnecteddrive.phev.imageSize.label = Bildgr\ufffd\ufffde\n+thing-type.config.bmwconnecteddrive.phev.imageSize.description = Bildgr\ufffd\ufffde des Fahrzeugs f\ufffdr L\ufffdnge und Breite\n+thing-type.config.bmwconnecteddrive.phev.imageViewport.label = Bild Ansicht\n+thing-type.config.bmwconnecteddrive.phev.imageViewport.description = Ansicht des Fahrzeugs\n+thing-type.config.bmwconnecteddrive.phev.imageViewport.option.FRONT = Vorderansicht\n+thing-type.config.bmwconnecteddrive.phev.imageViewport.option.REAR = R\ufffdckansicht\n+thing-type.config.bmwconnecteddrive.phev.imageViewport.option.SIDE = Seitenansicht\n+thing-type.config.bmwconnecteddrive.phev.imageViewport.option.DASHBOARD = Innenansicht Armaturen\n+thing-type.config.bmwconnecteddrive.phev.imageViewport.option.DRIVERDOOR = Seitenansicht Fahrert\ufffdr\n+\n+thing-type.bmwconnecteddrive.conv.label = BMW Konventionelles Fahrzeug\n+thing-type.bmwconnecteddrive.conv.description = Konventionelles Benzin/Diesel Fahrzeug (conv)\n+thing-type.config.bmwconnecteddrive.conv.vin.label = Fahrzeug Identifikationsnummer (VIN)\n+thing-type.config.bmwconnecteddrive.conv.vin.description = VIN des Fahrzeugs\n+thing-type.config.bmwconnecteddrive.conv.refreshInterval.label = Datenaktualisierung in Minuten\n+thing-type.config.bmwconnecteddrive.conv.refreshInterval.description = Rate der Datenaktualisierung Ihres Fahrzeugs\n+thing-type.config.bmwconnecteddrive.conv.units.label = Einheiten\n+thing-type.config.bmwconnecteddrive.conv.units.description = Automatische oder direkte Auswahl der Einheiten \n+thing-type.config.bmwconnecteddrive.conv.units.option.AUTODETECT = Automatische Auswahl\n+thing-type.config.bmwconnecteddrive.conv.units.option.IMPERIAL = Angloamerikanisches System\n+thing-type.config.bmwconnecteddrive.conv.units.option.METRIC = Metrisches System\n+thing-type.config.bmwconnecteddrive.conv.imageSize.label = Bildgr\ufffd\ufffde\n+thing-type.config.bmwconnecteddrive.conv.imageSize.description = Bildgr\ufffd\ufffde des Fahrzeugs f\ufffdr L\ufffdnge und Breite\n+thing-type.config.bmwconnecteddrive.conv.imageViewport.label = Bild Ansicht\n+thing-type.config.bmwconnecteddrive.conv.imageViewport.description = Ansicht des Fahrzeugs\n+thing-type.config.bmwconnecteddrive.conv.imageViewport.option.FRONT = Vorderansicht\n+thing-type.config.bmwconnecteddrive.conv.imageViewport.option.REAR = R\ufffdckansicht\n+thing-type.config.bmwconnecteddrive.conv.imageViewport.option.SIDE = Seitenansicht\n+thing-type.config.bmwconnecteddrive.conv.imageViewport.option.DASHBOARD = Innenansicht Armaturen\n+thing-type.config.bmwconnecteddrive.conv.imageViewport.option.DRIVERDOOR = Seitenansicht Fahrert\ufffdr\n+\n+# Channel Groups\n+channel-group-type.bmwconnecteddrive.charge-values.label = Elektrisches Laden\n+channel-group-type.bmwconnecteddrive.charge-values.description = Ladezustand und Ladeprofile des Fahrzeugs\n+channel-group-type.bmwconnecteddrive.ev-lifetime-values.label = Gesamtlaufzeit Statistik\n+channel-group-type.bmwconnecteddrive.ev-lifetime-values.description = Verbrauchswerte und zur\ufffdckgelegte Strecken \ufffdber die Fahrzeug-Gesamtlaufzeit\n+channel-group-type.bmwconnecteddrive.hybrid-lifetime-values.label = Gesamtlaufzeit Statistik\n+channel-group-type.bmwconnecteddrive.hybrid-lifetime-values.description = Verbrauchswerte und zur\ufffdckgelegte Strecken \ufffdber die Fahrzeug-Gesamtlaufzeit\n+channel-group-type.bmwconnecteddrive.ev-last-trip-values.label = Statistik der letzten Fahrt\n+channel-group-type.bmwconnecteddrive.ev-last-trip-values.description = Verbrauchswerte und zur\ufffdck gelegte Strecke der letzten Fahrt\n+channel-group-type.bmwconnecteddrive.hybrid-last-trip-values.label = Statistik der letzten Fahrt\n+channel-group-type.bmwconnecteddrive.hybrid-last-trip-values.description = Verbrauchswerte und zur\ufffdck gelegte Strecke der letzten Fahrt\n+channel-group-type.bmwconnecteddrive.ev-range-values.label = Elektrische Reichweite\n+channel-group-type.bmwconnecteddrive.ev-range-values.description = Tachostand, Reichweiten und Ladestand des Fahrzeugs\n+channel-group-type.bmwconnecteddrive.check-control-values.label = Warnungen\n+channel-group-type.bmwconnecteddrive.check-control-values.description = Aktuelle Warungen des Fahrzeugs\n+channel-group-type.bmwconnecteddrive.service-values.label = Wartung\n+channel-group-type.bmwconnecteddrive.service-values.description = Zuk\ufffdnftige Wartungstermine des Fahrzeugs\n+channel-group-type.bmwconnecteddrive.conv-range-values.label = Reichweite\n+channel-group-type.bmwconnecteddrive.conv-range-values.description = Tachostand, Reichweite und Tankf\ufffdllung des Fahrzeugs\n+channel-group-type.bmwconnecteddrive.hybrid-range-values.label = Hybride Reichweite\n+channel-group-type.bmwconnecteddrive.hybrid-range-values.description = Tachostand, Reichweite, Ladezustand und Tankf\ufffdllung des Fahrzeugs\n+channel-group-type.bmwconnecteddrive.image-values.label = Fahrzeug Bild\n+channel-group-type.bmwconnecteddrive.image-values.description = Bild des Fahrzeug basierend auf der Ansicht in der Konfiguration\n+channel-group-type.bmwconnecteddrive.remote-services.label = Fahrzeug Fernsteuerung\n+channel-group-type.bmwconnecteddrive.remote-services.description = Fernsteuerung des Fahrzeugs \ufffdber den BMW Server wie T\ufffdren schlie\ufffden / \ufffdffnen, Klimasteuerung und mehr\n+channel-group-type.bmwconnecteddrive.vehicle-status.label = Fahrzeug Zustand\n+channel-group-type.bmwconnecteddrive.vehicle-status.description = Zustand des Fahrzeugs \ufffdber T\ufffdren, Fenster, abgeschlossen, anstehende Wartung und aktive Warnungen\n+channel-group-type.bmwconnecteddrive.ev-vehicle-status.label = Fahrzeug Zustand\n+channel-group-type.bmwconnecteddrive.ev-vehicle-status.description = Zustand des Fahrzeugs \ufffdber T\ufffdren, Fenster, abgeschlossen, anstehende Wartung und aktive Warnungen\n+channel-group-type.bmwconnecteddrive.location-values.label = Fahrzeug Standort\n+channel-group-type.bmwconnecteddrive.location-values.description = Koordinaten und Ausrichtung des Fahrzeugs\n+channel-group-type.bmwconnecteddrive.destination-values.label = Ziele\n+channel-group-type.bmwconnecteddrive.destination-values.description = Zeigt die gepseicherten Ziele des Fahrzeugs\n+channel-group-type.bmwconnecteddrive.troubleshoot-control.label = Fehlerbehebung\n+channel-group-type.bmwconnecteddrive.troubleshoot-control.description = Generiert Daten zur Fehlerbehebung eines Problems\n+channel-group-type.bmwconnecteddrive.door-values.label = Details aller T\ufffdren\n+channel-group-type.bmwconnecteddrive.door-values.description = Zeigt die Dezails der T\ufffdren und Fenster des Fahrzeugs\n+\n+# Channel Types\n+channel-type.bmwconnecteddrive.doors-channel.label = Gesamtzustand der T\ufffdren\n+channel-type.bmwconnecteddrive.windows-channel.label = Gesamtzustand der Fenster\n+channel-type.bmwconnecteddrive.lock-channel.label = Fahrzeug Abgeschlossen\n+channel-type.bmwconnecteddrive.next-service-date-channel.label = N\ufffdchster Service Termin\n+channel-type.bmwconnecteddrive.next-service-mileage-channel.label = N\ufffdchster Service in Kilometern\n+channel-type.bmwconnecteddrive.check-control-channel.label = Warnung Aktiv\n+channel-type.bmwconnecteddrive.charging-status-channel.label = Ladezustand\n+channel-type.bmwconnecteddrive.last-update-channel.label = Letzte Aktualisierung\n+\n+channel-type.bmwconnecteddrive.driver-front-channel.label = Fahrert\ufffdr \n+channel-type.bmwconnecteddrive.driver-rear-channel.label = Fahrert\ufffdr Hinten\n+channel-type.bmwconnecteddrive.passenger-front-channel.label = Beifahrert\ufffdr\n+channel-type.bmwconnecteddrive.passenger-rear-channel.label = Beifahrert\ufffdr Hinten\n+channel-type.bmwconnecteddrive.hood-channel.label = Frontklappe\n+channel-type.bmwconnecteddrive.trunk-channel.label = Heckklappe\n+channel-type.bmwconnecteddrive.window-driver-front-channel.label = Fahrert\ufffdr Fenster\n+channel-type.bmwconnecteddrive.window-driver-rear-channel.label = Fahrert\ufffdr Hinten Fenster\n+channel-type.bmwconnecteddrive.window-passenger-front-channel.label = Beifahrert\ufffdr Fenster\n+channel-type.bmwconnecteddrive.window-passenger-rear-channel.label = Beifahrert\ufffdr Hinten Fenster\n+channel-type.bmwconnecteddrive.window-rear-channel.label = Heckfenster\n+channel-type.bmwconnecteddrive.sunroof-channel.label = Schiebedach\n+\n+channel-type.bmwconnecteddrive.mileage-channel.label = Tachostand\n+channel-type.bmwconnecteddrive.range-hybrid-channel.label = Hybride Reichweite\n+channel-type.bmwconnecteddrive.range-electric-channel.label = Elektrische Reichweite \n+channel-type.bmwconnecteddrive.soc-channel.label = Batterie Ladestand\n+channel-type.bmwconnecteddrive.range-fuel-channel.label = Verbrenner Reichweite\n+channel-type.bmwconnecteddrive.remaining-fuel-channel.label = Tankstand\n+channel-type.bmwconnecteddrive.range-radius-electric-channel.label = Elektrischer Reichweiten-Radius\n+channel-type.bmwconnecteddrive.range-radius-fuel-channel.label =  Verbrenner Reichweiten-Radius\n+channel-type.bmwconnecteddrive.range-radius-hybrid-channel.label = Hybrider Reichweiten-Radius\n+\n+channel-type.bmwconnecteddrive.service-name-channel.label = Service\n+channel-type.bmwconnecteddrive.service-details-channel.label = Service Details\n+channel-type.bmwconnecteddrive.service-date-channel.label = Service Termin\n+channel-type.bmwconnecteddrive.service-mileage-channel.label = Service in Kilometern\n+\n+channel-type.bmwconnecteddrive.checkcontrol-name-channel.label = Warnung\n+channel-type.bmwconnecteddrive.checkcontrol-details-channel.label = Warnung Details\n+channel-type.bmwconnecteddrive.checkcontrol-mileage-channel.label = Warnung bei Kilometer\n+\n+channel-type.bmwconnecteddrive.profile-climate-channel.label = Klimatisierung bei Abfahrt\n+channel-type.bmwconnecteddrive.profile-mode-channel.label = Ladeprofil Methode\n+channel-type.bmwconnecteddrive.profile-prefs-channel.label = Ladeprofil Pr\ufffdferenz\n+channel-type.bmwconnecteddrive.window-start-channel.label = Startzeit Ladefenster\n+channel-type.bmwconnecteddrive.window-start-hour-channel.label = Startzeit Ladefenster Stunde\n+channel-type.bmwconnecteddrive.window-start-minute-channel.label = Startzeit Ladefenster Minute\n+channel-type.bmwconnecteddrive.window-end-channel.label = Endzeit Ladefenster\n+channel-type.bmwconnecteddrive.window-end-hour-channel.label = Endzeit Ladefenster Stunde\n+channel-type.bmwconnecteddrive.window-end-minute-channel.label = Endzeit Ladefenster Minute\n+channel-type.bmwconnecteddrive.timer1-enabled-channel.label = Zeitprofil 1 - Aktiviert\n+channel-type.bmwconnecteddrive.timer1-departure-channel.label = Zeitprofil 1 - Abfahrtszeit\n+channel-type.bmwconnecteddrive.timer1-departure-hour-channel.label = Zeitprofil 1 - Abfahrtszeit Stunde\n+channel-type.bmwconnecteddrive.timer1-departure-minute-channel.label = Zeitprofil 1 - Abfahrtszeit Minute\n+channel-type.bmwconnecteddrive.timer1-days-channel.label = Zeitprofil 1 - Tage\n+channel-type.bmwconnecteddrive.timer1-day-mon-channel.label = Zeitprofil 1 - Montag\n+channel-type.bmwconnecteddrive.timer1-day-tue-channel.label = Zeitprofil 1 - Dienstag\n+channel-type.bmwconnecteddrive.timer1-day-wed-channel.label = Zeitprofil 1 - Mittwoch\n+channel-type.bmwconnecteddrive.timer1-day-thu-channel.label = Zeitprofil 1 - Donnerstag\n+channel-type.bmwconnecteddrive.timer1-day-fri-channel.label = Zeitprofil 1 - Freitag\n+channel-type.bmwconnecteddrive.timer1-day-sat-channel.label = Zeitprofil 1 - Samstag\n+channel-type.bmwconnecteddrive.timer1-day-sun-channel.label = Zeitprofil 1 - Sonntag\n+channel-type.bmwconnecteddrive.timer2-enabled-channel.label = Zeitprofil 2 - Aktiviert\n+channel-type.bmwconnecteddrive.timer2-departure-channel.label = Zeitprofil 2 - Abfahrtszeit\n+channel-type.bmwconnecteddrive.timer2-departure-hour-channel.label = Zeitprofil 2 - Abfahrtszeit Stunde\n+channel-type.bmwconnecteddrive.timer2-departure-minute-channel.label = Zeitprofil 2 - Abfahrtszeit Minute\n+channel-type.bmwconnecteddrive.timer2-days-channel.label = Zeitprofil 2 - Tage\n+channel-type.bmwconnecteddrive.timer2-day-mon-channel.label = Zeitprofil 2 - Montag\n+channel-type.bmwconnecteddrive.timer2-day-tue-channel.label = Zeitprofil 2 - Dienstag\n+channel-type.bmwconnecteddrive.timer2-day-wed-channel.label = Zeitprofil 2 - Mittwoch\n+channel-type.bmwconnecteddrive.timer2-day-thu-channel.label = Zeitprofil 2 - Donnerstag\n+channel-type.bmwconnecteddrive.timer2-day-fri-channel.label = Zeitprofil 2 - Freitag\n+channel-type.bmwconnecteddrive.timer2-day-sat-channel.label = Zeitprofil 2 - Samstag\n+channel-type.bmwconnecteddrive.timer2-day-sun-channel.label = Zeitprofil 2 - Sonnatg\n+channel-type.bmwconnecteddrive.timer3-enabled-channel.label = Zeitprofil 3 - Aktiviert\n+channel-type.bmwconnecteddrive.timer3-departure-channel.label = Zeitprofil 3 - Abfahrtszeit\n+channel-type.bmwconnecteddrive.timer3-departure-hour-channel.label = Zeitprofil 3 - Abfahrtszeit Stunde\n+channel-type.bmwconnecteddrive.timer3-departure-minute-channel.label = Zeitprofil 3 - Abfahrtszeit Minute\n+channel-type.bmwconnecteddrive.timer3-days-channel.label = Zeitprofil 3 - Tage\n+channel-type.bmwconnecteddrive.timer3-day-mon-channel.label = Zeitprofil 3 - Montag\n+channel-type.bmwconnecteddrive.timer3-day-tue-channel.label = Zeitprofil 3 - Dienstag\n+channel-type.bmwconnecteddrive.timer3-day-wed-channel.label = Zeitprofil 3 - Mittwoch\n+channel-type.bmwconnecteddrive.timer3-day-thu-channel.label = Zeitprofil 3 - Donnerstag\n+channel-type.bmwconnecteddrive.timer3-day-fri-channel.label = Zeitprofil 3 - Freitag\n+channel-type.bmwconnecteddrive.timer3-day-sat-channel.label = Zeitprofil 3 - Samstag\n+channel-type.bmwconnecteddrive.timer3-day-sun-channel.label = Zeitprofil 3 - Sonntag\n+channel-type.bmwconnecteddrive.override-departure-channel.label = Einmaliges Zeitprofil - Abfahrtszeit\n+channel-type.bmwconnecteddrive.override-departure-hour-channel.label = Einmaliges Zeitprofil - Abfahrtszeit Stunde \n+channel-type.bmwconnecteddrive.override-departure-minute-channel.label = Einmaliges Zeitprofil - Abfahrtszeit Minute\n+channel-type.bmwconnecteddrive.override-enabled-channel.label = Einmaliges Zeitprofil - Aktiviert\n+\n+channel-type.bmwconnecteddrive.destination-name-channel.label = Zieladresse\n+channel-type.bmwconnecteddrive.destination-gps-channel.label = Ziel Koordinaten", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5NzkzMzc0Mw=="}, "originalCommit": {"oid": "48af48c82562d006b6f2aa35922270f181c885ed"}, "originalPosition": 231}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzc3Njg3ODY2OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/resources/OH-INF/thing/charge-channel-types.xml", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0xOVQxOTo0NDoxMlrOI6PB5A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0yOFQwMDozMToyMlrOI-4mJA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5NzkzNDU2NA==", "bodyText": "Labels are expected to be as short as possible. Guideline is 2-3 words with max 20-25 chars. See https://www.openhab.org/docs/developer/bindings/thing-xml.html#formatting-labels-and-descriptions", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r597934564", "createdAt": "2021-03-19T19:44:12Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/resources/OH-INF/thing/charge-channel-types.xml", "diffHunk": "@@ -0,0 +1,226 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"bmwconnecteddrive\"\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\t<channel-type id=\"profile-climate-channel\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>A/C at Departure Time</label>\n+\t</channel-type>\n+\t<channel-type id=\"profile-mode-channel\">\n+\t\t<item-type>String</item-type>\n+\t\t<label>Charge Mode for Profile</label>\n+\t\t<command>\n+\t\t\t<options>\n+\t\t\t\t<option value=\"IMMEDIATE_CHARGING\">Immediate Charging</option>\n+\t\t\t\t<option value=\"DELAYED_CHARGING\">Prefer Charging in Charging Window</option>\n+\t\t\t</options>\n+\t\t</command>\n+\t</channel-type>\n+\t<channel-type id=\"profile-prefs-channel\">\n+\t\t<item-type>String</item-type>\n+\t\t<label>Charging Preferences for Profile</label>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "48af48c82562d006b6f2aa35922270f181c885ed"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMjgwOTg5Mg==", "bodyText": "Fixed", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r602809892", "createdAt": "2021-03-28T00:31:22Z", "author": {"login": "weymann"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/resources/OH-INF/thing/charge-channel-types.xml", "diffHunk": "@@ -0,0 +1,226 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"bmwconnecteddrive\"\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\t<channel-type id=\"profile-climate-channel\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>A/C at Departure Time</label>\n+\t</channel-type>\n+\t<channel-type id=\"profile-mode-channel\">\n+\t\t<item-type>String</item-type>\n+\t\t<label>Charge Mode for Profile</label>\n+\t\t<command>\n+\t\t\t<options>\n+\t\t\t\t<option value=\"IMMEDIATE_CHARGING\">Immediate Charging</option>\n+\t\t\t\t<option value=\"DELAYED_CHARGING\">Prefer Charging in Charging Window</option>\n+\t\t\t</options>\n+\t\t</command>\n+\t</channel-type>\n+\t<channel-type id=\"profile-prefs-channel\">\n+\t\t<item-type>String</item-type>\n+\t\t<label>Charging Preferences for Profile</label>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5NzkzNDU2NA=="}, "originalCommit": {"oid": "48af48c82562d006b6f2aa35922270f181c885ed"}, "originalPosition": 22}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzc3Njg3OTI3OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/resources/OH-INF/thing/charge-channel-types.xml", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0xOVQxOTo0NDoyM1rOI6PCOQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0yOFQwMDoyMDoyM1rOI-4iyQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5NzkzNDY0OQ==", "bodyText": "This should be English.", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r597934649", "createdAt": "2021-03-19T19:44:23Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/resources/OH-INF/thing/charge-channel-types.xml", "diffHunk": "@@ -0,0 +1,226 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"bmwconnecteddrive\"\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\t<channel-type id=\"profile-climate-channel\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>A/C at Departure Time</label>\n+\t</channel-type>\n+\t<channel-type id=\"profile-mode-channel\">\n+\t\t<item-type>String</item-type>\n+\t\t<label>Charge Mode for Profile</label>\n+\t\t<command>\n+\t\t\t<options>\n+\t\t\t\t<option value=\"IMMEDIATE_CHARGING\">Immediate Charging</option>\n+\t\t\t\t<option value=\"DELAYED_CHARGING\">Prefer Charging in Charging Window</option>\n+\t\t\t</options>\n+\t\t</command>\n+\t</channel-type>\n+\t<channel-type id=\"profile-prefs-channel\">\n+\t\t<item-type>String</item-type>\n+\t\t<label>Charging Preferences for Profile</label>\n+\t\t<command>\n+\t\t\t<options>\n+\t\t\t\t<option value=\"NO_PRESELECTION\">keine Vorauswahl</option>\n+\t\t\t\t<option value=\"CHARGING_WINDOW\">Ladezeitfenster</option>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "48af48c82562d006b6f2aa35922270f181c885ed"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMjgwOTAzMw==", "bodyText": "English as default, german translation added", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r602809033", "createdAt": "2021-03-28T00:20:23Z", "author": {"login": "weymann"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/resources/OH-INF/thing/charge-channel-types.xml", "diffHunk": "@@ -0,0 +1,226 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"bmwconnecteddrive\"\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\t<channel-type id=\"profile-climate-channel\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>A/C at Departure Time</label>\n+\t</channel-type>\n+\t<channel-type id=\"profile-mode-channel\">\n+\t\t<item-type>String</item-type>\n+\t\t<label>Charge Mode for Profile</label>\n+\t\t<command>\n+\t\t\t<options>\n+\t\t\t\t<option value=\"IMMEDIATE_CHARGING\">Immediate Charging</option>\n+\t\t\t\t<option value=\"DELAYED_CHARGING\">Prefer Charging in Charging Window</option>\n+\t\t\t</options>\n+\t\t</command>\n+\t</channel-type>\n+\t<channel-type id=\"profile-prefs-channel\">\n+\t\t<item-type>String</item-type>\n+\t\t<label>Charging Preferences for Profile</label>\n+\t\t<command>\n+\t\t\t<options>\n+\t\t\t\t<option value=\"NO_PRESELECTION\">keine Vorauswahl</option>\n+\t\t\t\t<option value=\"CHARGING_WINDOW\">Ladezeitfenster</option>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5NzkzNDY0OQ=="}, "originalCommit": {"oid": "48af48c82562d006b6f2aa35922270f181c885ed"}, "originalPosition": 26}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzc3Njg4NTA0OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/resources/OH-INF/thing/charge-channel-types.xml", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0xOVQxOTo0NTo1M1rOI6PFoQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0yOFQyMzo1NTowMFrOI_BUrw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5NzkzNTUyMQ==", "bodyText": "Labels are expected to be as short as possible. Guideline is 2-3 words with max 20-25 chars. See https://www.openhab.org/docs/developer/bindings/thing-xml.html#formatting-labels-and-descriptions\nPlease check all.", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r597935521", "createdAt": "2021-03-19T19:45:53Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/resources/OH-INF/thing/charge-channel-types.xml", "diffHunk": "@@ -0,0 +1,226 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"bmwconnecteddrive\"\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\t<channel-type id=\"profile-climate-channel\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>A/C at Departure Time</label>\n+\t</channel-type>\n+\t<channel-type id=\"profile-mode-channel\">\n+\t\t<item-type>String</item-type>\n+\t\t<label>Charge Mode for Profile</label>\n+\t\t<command>\n+\t\t\t<options>\n+\t\t\t\t<option value=\"IMMEDIATE_CHARGING\">Immediate Charging</option>\n+\t\t\t\t<option value=\"DELAYED_CHARGING\">Prefer Charging in Charging Window</option>\n+\t\t\t</options>\n+\t\t</command>\n+\t</channel-type>\n+\t<channel-type id=\"profile-prefs-channel\">\n+\t\t<item-type>String</item-type>\n+\t\t<label>Charging Preferences for Profile</label>\n+\t\t<command>\n+\t\t\t<options>\n+\t\t\t\t<option value=\"NO_PRESELECTION\">keine Vorauswahl</option>\n+\t\t\t\t<option value=\"CHARGING_WINDOW\">Ladezeitfenster</option>\n+\t\t\t</options>\n+\t\t</command>\n+\t</channel-type>\n+\t<channel-type id=\"window-start-channel\">\n+\t\t<item-type>DateTime</item-type>\n+\t\t<label>Charge Window Start Time</label>\n+\t</channel-type>\n+\t<channel-type id=\"window-start-hour-channel\">\n+\t\t<item-type>Number</item-type>\n+\t\t<label>Charge Window Start Hour</label>\n+\t\t<state min=\"0\" max=\"23\" step=\"1\" pattern=\"%d\" readOnly=\"false\"/>\n+\t</channel-type>\n+\t<channel-type id=\"window-start-minute-channel\">\n+\t\t<item-type>Number</item-type>\n+\t\t<label>Charge Window Start Minute</label>\n+\t\t<state min=\"0\" max=\"55\" step=\"5\" pattern=\"%d\" readOnly=\"false\"/>\n+\t</channel-type>\n+\t<channel-type id=\"window-end-channel\">\n+\t\t<item-type>DateTime</item-type>\n+\t\t<label>Charge Window End Time</label>\n+\t</channel-type>\n+\t<channel-type id=\"window-end-hour-channel\">\n+\t\t<item-type>Number</item-type>\n+\t\t<label>Charge Window End Hour</label>\n+\t\t<state min=\"0\" max=\"23\" step=\"1\" pattern=\"%d\" readOnly=\"false\"/>\n+\t</channel-type>\n+\t<channel-type id=\"window-end-minute-channel\">\n+\t\t<item-type>Number</item-type>\n+\t\t<label>Charge Window End Minute</label>\n+\t\t<state min=\"0\" max=\"55\" step=\"5\" pattern=\"%d\" readOnly=\"false\"/>\n+\t</channel-type>\n+\t<channel-type id=\"timer1-departure-channel\">\n+\t\t<item-type>DateTime</item-type>\n+\t\t<label>Timer 1: Departure Time</label>\n+\t</channel-type>\n+\t<channel-type id=\"timer1-departure-hour-channel\">\n+\t\t<item-type>Number</item-type>\n+\t\t<label>Timer 1: Departure Hour</label>\n+\t\t<state min=\"0\" max=\"23\" step=\"1\" pattern=\"%d\" readOnly=\"false\"/>\n+\t</channel-type>\n+\t<channel-type id=\"timer1-departure-minute-channel\">\n+\t\t<item-type>Number</item-type>\n+\t\t<label>Timer 1: Departure Minute</label>\n+\t\t<state min=\"0\" max=\"55\" step=\"5\" pattern=\"%d\" readOnly=\"false\"/>\n+\t</channel-type>\n+\t<channel-type id=\"timer1-days-channel\">\n+\t\t<item-type>String</item-type>\n+\t\t<label>Timer 1: Scheduled Days</label>\n+\t</channel-type>\n+\t<channel-type id=\"timer1-day-mon-channel\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Timer 1: Scheduled Days Monday</label>\n+\t</channel-type>\n+\t<channel-type id=\"timer1-day-tue-channel\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Timer 1: Scheduled Days Tuesday</label>\n+\t</channel-type>\n+\t<channel-type id=\"timer1-day-wed-channel\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Timer 1: Scheduled Days Wednesday</label>\n+\t</channel-type>\n+\t<channel-type id=\"timer1-day-thu-channel\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Timer 1: Scheduled Days Thursday</label>\n+\t</channel-type>\n+\t<channel-type id=\"timer1-day-fri-channel\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Timer 1: Scheduled Days Friday</label>\n+\t</channel-type>\n+\t<channel-type id=\"timer1-day-sat-channel\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Timer 1: Scheduled Days Saturday</label>\n+\t</channel-type>\n+\t<channel-type id=\"timer1-day-sun-channel\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Timer 1: Scheduled Days Sunday</label>\n+\t</channel-type>\n+\t<channel-type id=\"timer1-enabled-channel\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Timer 1: Enabled</label>\n+\t</channel-type>\n+\t<channel-type id=\"timer2-departure-channel\">\n+\t\t<item-type>DateTime</item-type>\n+\t\t<label>Timer 2: Departure Time</label>\n+\t</channel-type>\n+\t<channel-type id=\"timer2-departure-hour-channel\">\n+\t\t<item-type>Number</item-type>\n+\t\t<label>Timer 2: Departure Hour</label>\n+\t\t<state min=\"0\" max=\"23\" step=\"1\" pattern=\"%d\" readOnly=\"false\"/>\n+\t</channel-type>\n+\t<channel-type id=\"timer2-departure-minute-channel\">\n+\t\t<item-type>Number</item-type>\n+\t\t<label>Timer 2: Departure Minute</label>\n+\t\t<state min=\"0\" max=\"55\" step=\"5\" pattern=\"%d\" readOnly=\"false\"/>\n+\t</channel-type>\n+\t<channel-type id=\"timer2-days-channel\">\n+\t\t<item-type>String</item-type>\n+\t\t<label>Timer 2: Scheduled Days</label>\n+\t</channel-type>\n+\t<channel-type id=\"timer2-day-mon-channel\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Timer 2: Scheduled Days Monday</label>\n+\t</channel-type>\n+\t<channel-type id=\"timer2-day-tue-channel\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Timer 2: Scheduled Days Tuesday</label>\n+\t</channel-type>\n+\t<channel-type id=\"timer2-day-wed-channel\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Timer 2: Scheduled Days Wednesday</label>\n+\t</channel-type>\n+\t<channel-type id=\"timer2-day-thu-channel\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Timer 2: Scheduled Days Thursday</label>\n+\t</channel-type>\n+\t<channel-type id=\"timer2-day-fri-channel\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Timer 2: Scheduled Days Friday</label>\n+\t</channel-type>\n+\t<channel-type id=\"timer2-day-sat-channel\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Timer 2: Scheduled Days Saturday</label>\n+\t</channel-type>\n+\t<channel-type id=\"timer2-day-sun-channel\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Timer 2: Scheduled Days Sunday</label>\n+\t</channel-type>\n+\t<channel-type id=\"timer2-enabled-channel\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Timer 2: Enabled</label>\n+\t</channel-type>\n+\t<channel-type id=\"timer3-departure-channel\">\n+\t\t<item-type>DateTime</item-type>\n+\t\t<label>Timer 3: Departure Time</label>\n+\t</channel-type>\n+\t<channel-type id=\"timer3-departure-hour-channel\">\n+\t\t<item-type>Number</item-type>\n+\t\t<label>Timer 3: Departure Hour</label>\n+\t\t<state min=\"0\" max=\"23\" step=\"1\" pattern=\"%d\" readOnly=\"false\"/>\n+\t</channel-type>\n+\t<channel-type id=\"timer3-departure-minute-channel\">\n+\t\t<item-type>Number</item-type>\n+\t\t<label>Timer 3: Departure Minute</label>\n+\t\t<state min=\"0\" max=\"55\" step=\"5\" pattern=\"%d\" readOnly=\"false\"/>\n+\t</channel-type>\n+\t<channel-type id=\"timer3-days-channel\">\n+\t\t<item-type>String</item-type>\n+\t\t<label>Timer 3: Scheduled Days</label>\n+\t</channel-type>\n+\t<channel-type id=\"timer3-day-mon-channel\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Timer 3: Scheduled Days Monday</label>\n+\t</channel-type>\n+\t<channel-type id=\"timer3-day-tue-channel\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Timer 3: Scheduled Days Tuesday</label>\n+\t</channel-type>\n+\t<channel-type id=\"timer3-day-wed-channel\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Timer 3: Scheduled Days Wednesday</label>\n+\t</channel-type>\n+\t<channel-type id=\"timer3-day-thu-channel\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Timer 3: Scheduled Days Thursday</label>\n+\t</channel-type>\n+\t<channel-type id=\"timer3-day-fri-channel\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Timer 3: Scheduled Days Friday</label>\n+\t</channel-type>\n+\t<channel-type id=\"timer3-day-sat-channel\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Timer 3: Scheduled Days Saturday</label>\n+\t</channel-type>\n+\t<channel-type id=\"timer3-day-sun-channel\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Timer 3: Scheduled Days Sunday</label>\n+\t</channel-type>\n+\t<channel-type id=\"timer3-enabled-channel\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Timer 3: Enabled</label>\n+\t</channel-type>\n+\t<channel-type id=\"override-departure-channel\">\n+\t\t<item-type>DateTime</item-type>\n+\t\t<label>Override Timer: Departure Time</label>\n+\t</channel-type>\n+\t<channel-type id=\"override-departure-hour-channel\">\n+\t\t<item-type>Number</item-type>\n+\t\t<label>Override Timer: Departure Hour</label>\n+\t\t<state min=\"0\" max=\"23\" step=\"1\" pattern=\"%d\" readOnly=\"false\"/>\n+\t</channel-type>\n+\t<channel-type id=\"override-departure-minute-channel\">\n+\t\t<item-type>Number</item-type>\n+\t\t<label>Override Timer: Departure Minute</label>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "48af48c82562d006b6f2aa35922270f181c885ed"}, "originalPosition": 219}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMjk1Mjg3OQ==", "bodyText": "Done", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r602952879", "createdAt": "2021-03-28T23:55:00Z", "author": {"login": "weymann"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/resources/OH-INF/thing/charge-channel-types.xml", "diffHunk": "@@ -0,0 +1,226 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"bmwconnecteddrive\"\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\t<channel-type id=\"profile-climate-channel\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>A/C at Departure Time</label>\n+\t</channel-type>\n+\t<channel-type id=\"profile-mode-channel\">\n+\t\t<item-type>String</item-type>\n+\t\t<label>Charge Mode for Profile</label>\n+\t\t<command>\n+\t\t\t<options>\n+\t\t\t\t<option value=\"IMMEDIATE_CHARGING\">Immediate Charging</option>\n+\t\t\t\t<option value=\"DELAYED_CHARGING\">Prefer Charging in Charging Window</option>\n+\t\t\t</options>\n+\t\t</command>\n+\t</channel-type>\n+\t<channel-type id=\"profile-prefs-channel\">\n+\t\t<item-type>String</item-type>\n+\t\t<label>Charging Preferences for Profile</label>\n+\t\t<command>\n+\t\t\t<options>\n+\t\t\t\t<option value=\"NO_PRESELECTION\">keine Vorauswahl</option>\n+\t\t\t\t<option value=\"CHARGING_WINDOW\">Ladezeitfenster</option>\n+\t\t\t</options>\n+\t\t</command>\n+\t</channel-type>\n+\t<channel-type id=\"window-start-channel\">\n+\t\t<item-type>DateTime</item-type>\n+\t\t<label>Charge Window Start Time</label>\n+\t</channel-type>\n+\t<channel-type id=\"window-start-hour-channel\">\n+\t\t<item-type>Number</item-type>\n+\t\t<label>Charge Window Start Hour</label>\n+\t\t<state min=\"0\" max=\"23\" step=\"1\" pattern=\"%d\" readOnly=\"false\"/>\n+\t</channel-type>\n+\t<channel-type id=\"window-start-minute-channel\">\n+\t\t<item-type>Number</item-type>\n+\t\t<label>Charge Window Start Minute</label>\n+\t\t<state min=\"0\" max=\"55\" step=\"5\" pattern=\"%d\" readOnly=\"false\"/>\n+\t</channel-type>\n+\t<channel-type id=\"window-end-channel\">\n+\t\t<item-type>DateTime</item-type>\n+\t\t<label>Charge Window End Time</label>\n+\t</channel-type>\n+\t<channel-type id=\"window-end-hour-channel\">\n+\t\t<item-type>Number</item-type>\n+\t\t<label>Charge Window End Hour</label>\n+\t\t<state min=\"0\" max=\"23\" step=\"1\" pattern=\"%d\" readOnly=\"false\"/>\n+\t</channel-type>\n+\t<channel-type id=\"window-end-minute-channel\">\n+\t\t<item-type>Number</item-type>\n+\t\t<label>Charge Window End Minute</label>\n+\t\t<state min=\"0\" max=\"55\" step=\"5\" pattern=\"%d\" readOnly=\"false\"/>\n+\t</channel-type>\n+\t<channel-type id=\"timer1-departure-channel\">\n+\t\t<item-type>DateTime</item-type>\n+\t\t<label>Timer 1: Departure Time</label>\n+\t</channel-type>\n+\t<channel-type id=\"timer1-departure-hour-channel\">\n+\t\t<item-type>Number</item-type>\n+\t\t<label>Timer 1: Departure Hour</label>\n+\t\t<state min=\"0\" max=\"23\" step=\"1\" pattern=\"%d\" readOnly=\"false\"/>\n+\t</channel-type>\n+\t<channel-type id=\"timer1-departure-minute-channel\">\n+\t\t<item-type>Number</item-type>\n+\t\t<label>Timer 1: Departure Minute</label>\n+\t\t<state min=\"0\" max=\"55\" step=\"5\" pattern=\"%d\" readOnly=\"false\"/>\n+\t</channel-type>\n+\t<channel-type id=\"timer1-days-channel\">\n+\t\t<item-type>String</item-type>\n+\t\t<label>Timer 1: Scheduled Days</label>\n+\t</channel-type>\n+\t<channel-type id=\"timer1-day-mon-channel\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Timer 1: Scheduled Days Monday</label>\n+\t</channel-type>\n+\t<channel-type id=\"timer1-day-tue-channel\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Timer 1: Scheduled Days Tuesday</label>\n+\t</channel-type>\n+\t<channel-type id=\"timer1-day-wed-channel\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Timer 1: Scheduled Days Wednesday</label>\n+\t</channel-type>\n+\t<channel-type id=\"timer1-day-thu-channel\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Timer 1: Scheduled Days Thursday</label>\n+\t</channel-type>\n+\t<channel-type id=\"timer1-day-fri-channel\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Timer 1: Scheduled Days Friday</label>\n+\t</channel-type>\n+\t<channel-type id=\"timer1-day-sat-channel\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Timer 1: Scheduled Days Saturday</label>\n+\t</channel-type>\n+\t<channel-type id=\"timer1-day-sun-channel\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Timer 1: Scheduled Days Sunday</label>\n+\t</channel-type>\n+\t<channel-type id=\"timer1-enabled-channel\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Timer 1: Enabled</label>\n+\t</channel-type>\n+\t<channel-type id=\"timer2-departure-channel\">\n+\t\t<item-type>DateTime</item-type>\n+\t\t<label>Timer 2: Departure Time</label>\n+\t</channel-type>\n+\t<channel-type id=\"timer2-departure-hour-channel\">\n+\t\t<item-type>Number</item-type>\n+\t\t<label>Timer 2: Departure Hour</label>\n+\t\t<state min=\"0\" max=\"23\" step=\"1\" pattern=\"%d\" readOnly=\"false\"/>\n+\t</channel-type>\n+\t<channel-type id=\"timer2-departure-minute-channel\">\n+\t\t<item-type>Number</item-type>\n+\t\t<label>Timer 2: Departure Minute</label>\n+\t\t<state min=\"0\" max=\"55\" step=\"5\" pattern=\"%d\" readOnly=\"false\"/>\n+\t</channel-type>\n+\t<channel-type id=\"timer2-days-channel\">\n+\t\t<item-type>String</item-type>\n+\t\t<label>Timer 2: Scheduled Days</label>\n+\t</channel-type>\n+\t<channel-type id=\"timer2-day-mon-channel\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Timer 2: Scheduled Days Monday</label>\n+\t</channel-type>\n+\t<channel-type id=\"timer2-day-tue-channel\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Timer 2: Scheduled Days Tuesday</label>\n+\t</channel-type>\n+\t<channel-type id=\"timer2-day-wed-channel\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Timer 2: Scheduled Days Wednesday</label>\n+\t</channel-type>\n+\t<channel-type id=\"timer2-day-thu-channel\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Timer 2: Scheduled Days Thursday</label>\n+\t</channel-type>\n+\t<channel-type id=\"timer2-day-fri-channel\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Timer 2: Scheduled Days Friday</label>\n+\t</channel-type>\n+\t<channel-type id=\"timer2-day-sat-channel\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Timer 2: Scheduled Days Saturday</label>\n+\t</channel-type>\n+\t<channel-type id=\"timer2-day-sun-channel\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Timer 2: Scheduled Days Sunday</label>\n+\t</channel-type>\n+\t<channel-type id=\"timer2-enabled-channel\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Timer 2: Enabled</label>\n+\t</channel-type>\n+\t<channel-type id=\"timer3-departure-channel\">\n+\t\t<item-type>DateTime</item-type>\n+\t\t<label>Timer 3: Departure Time</label>\n+\t</channel-type>\n+\t<channel-type id=\"timer3-departure-hour-channel\">\n+\t\t<item-type>Number</item-type>\n+\t\t<label>Timer 3: Departure Hour</label>\n+\t\t<state min=\"0\" max=\"23\" step=\"1\" pattern=\"%d\" readOnly=\"false\"/>\n+\t</channel-type>\n+\t<channel-type id=\"timer3-departure-minute-channel\">\n+\t\t<item-type>Number</item-type>\n+\t\t<label>Timer 3: Departure Minute</label>\n+\t\t<state min=\"0\" max=\"55\" step=\"5\" pattern=\"%d\" readOnly=\"false\"/>\n+\t</channel-type>\n+\t<channel-type id=\"timer3-days-channel\">\n+\t\t<item-type>String</item-type>\n+\t\t<label>Timer 3: Scheduled Days</label>\n+\t</channel-type>\n+\t<channel-type id=\"timer3-day-mon-channel\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Timer 3: Scheduled Days Monday</label>\n+\t</channel-type>\n+\t<channel-type id=\"timer3-day-tue-channel\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Timer 3: Scheduled Days Tuesday</label>\n+\t</channel-type>\n+\t<channel-type id=\"timer3-day-wed-channel\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Timer 3: Scheduled Days Wednesday</label>\n+\t</channel-type>\n+\t<channel-type id=\"timer3-day-thu-channel\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Timer 3: Scheduled Days Thursday</label>\n+\t</channel-type>\n+\t<channel-type id=\"timer3-day-fri-channel\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Timer 3: Scheduled Days Friday</label>\n+\t</channel-type>\n+\t<channel-type id=\"timer3-day-sat-channel\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Timer 3: Scheduled Days Saturday</label>\n+\t</channel-type>\n+\t<channel-type id=\"timer3-day-sun-channel\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Timer 3: Scheduled Days Sunday</label>\n+\t</channel-type>\n+\t<channel-type id=\"timer3-enabled-channel\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Timer 3: Enabled</label>\n+\t</channel-type>\n+\t<channel-type id=\"override-departure-channel\">\n+\t\t<item-type>DateTime</item-type>\n+\t\t<label>Override Timer: Departure Time</label>\n+\t</channel-type>\n+\t<channel-type id=\"override-departure-hour-channel\">\n+\t\t<item-type>Number</item-type>\n+\t\t<label>Override Timer: Departure Hour</label>\n+\t\t<state min=\"0\" max=\"23\" step=\"1\" pattern=\"%d\" readOnly=\"false\"/>\n+\t</channel-type>\n+\t<channel-type id=\"override-departure-minute-channel\">\n+\t\t<item-type>Number</item-type>\n+\t\t<label>Override Timer: Departure Minute</label>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5NzkzNTUyMQ=="}, "originalCommit": {"oid": "48af48c82562d006b6f2aa35922270f181c885ed"}, "originalPosition": 219}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzc3Njg4NjU3OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/resources/OH-INF/thing/check-control-channel-types.xml", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0xOVQxOTo0NjoyNFrOI6PGkA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0yOVQwMTowOToxNlrOI_B_6g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5NzkzNTc2MA==", "bodyText": "You could add a pattern.", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r597935760", "createdAt": "2021-03-19T19:46:24Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/resources/OH-INF/thing/check-control-channel-types.xml", "diffHunk": "@@ -0,0 +1,18 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"bmwconnecteddrive\"\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\t<channel-type id=\"checkcontrol-name-channel\">\n+\t\t<item-type>String</item-type>\n+\t\t<label>CheckControl Description</label>\n+\t</channel-type>\n+\t<channel-type id=\"checkcontrol-details-channel\">\n+\t\t<item-type>String</item-type>\n+\t\t<label>CheckControl Details</label>\n+\t</channel-type>\n+\t<channel-type id=\"checkcontrol-mileage-channel\">\n+\t\t<item-type>Number:Length</item-type>\n+\t\t<label>Mileage Occurrence</label>\n+\t</channel-type>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "48af48c82562d006b6f2aa35922270f181c885ed"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMjgxMTc2Mg==", "bodyText": "Why exactly for this one?", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r602811762", "createdAt": "2021-03-28T00:55:47Z", "author": {"login": "weymann"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/resources/OH-INF/thing/check-control-channel-types.xml", "diffHunk": "@@ -0,0 +1,18 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"bmwconnecteddrive\"\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\t<channel-type id=\"checkcontrol-name-channel\">\n+\t\t<item-type>String</item-type>\n+\t\t<label>CheckControl Description</label>\n+\t</channel-type>\n+\t<channel-type id=\"checkcontrol-details-channel\">\n+\t\t<item-type>String</item-type>\n+\t\t<label>CheckControl Details</label>\n+\t</channel-type>\n+\t<channel-type id=\"checkcontrol-mileage-channel\">\n+\t\t<item-type>Number:Length</item-type>\n+\t\t<label>Mileage Occurrence</label>\n+\t</channel-type>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5NzkzNTc2MA=="}, "originalCommit": {"oid": "48af48c82562d006b6f2aa35922270f181c885ed"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMjg1NTkxNw==", "bodyText": "Nothing special about this Channel. I picked a random one. Are the units of these Channels appended to the values when displaying them in the UI?", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r602855917", "createdAt": "2021-03-28T09:32:55Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/resources/OH-INF/thing/check-control-channel-types.xml", "diffHunk": "@@ -0,0 +1,18 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"bmwconnecteddrive\"\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\t<channel-type id=\"checkcontrol-name-channel\">\n+\t\t<item-type>String</item-type>\n+\t\t<label>CheckControl Description</label>\n+\t</channel-type>\n+\t<channel-type id=\"checkcontrol-details-channel\">\n+\t\t<item-type>String</item-type>\n+\t\t<label>CheckControl Details</label>\n+\t</channel-type>\n+\t<channel-type id=\"checkcontrol-mileage-channel\">\n+\t\t<item-type>Number:Length</item-type>\n+\t\t<label>Mileage Occurrence</label>\n+\t</channel-type>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5NzkzNTc2MA=="}, "originalCommit": {"oid": "48af48c82562d006b6f2aa35922270f181c885ed"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMjk2Mzk0Ng==", "bodyText": "I see, I did this in the item files before. But this looks quite convenient as default setting. Added state tags in channels.", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r602963946", "createdAt": "2021-03-29T01:09:16Z", "author": {"login": "weymann"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/resources/OH-INF/thing/check-control-channel-types.xml", "diffHunk": "@@ -0,0 +1,18 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"bmwconnecteddrive\"\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\t<channel-type id=\"checkcontrol-name-channel\">\n+\t\t<item-type>String</item-type>\n+\t\t<label>CheckControl Description</label>\n+\t</channel-type>\n+\t<channel-type id=\"checkcontrol-details-channel\">\n+\t\t<item-type>String</item-type>\n+\t\t<label>CheckControl Details</label>\n+\t</channel-type>\n+\t<channel-type id=\"checkcontrol-mileage-channel\">\n+\t\t<item-type>Number:Length</item-type>\n+\t\t<label>Mileage Occurrence</label>\n+\t</channel-type>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5NzkzNTc2MA=="}, "originalCommit": {"oid": "48af48c82562d006b6f2aa35922270f181c885ed"}, "originalPosition": 17}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzc3Njg5NTEyOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/resources/OH-INF/thing/loction-channel-types.xml", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0xOVQxOTo0ODo0MFrOI6PLqg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0yNFQwMDo0NjoxNVrOI8RRJA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5NzkzNzA2Ng==", "bodyText": "There's a typo in the filename.", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r597937066", "createdAt": "2021-03-19T19:48:40Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/resources/OH-INF/thing/loction-channel-types.xml", "diffHunk": "@@ -0,0 +1,14 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "48af48c82562d006b6f2aa35922270f181c885ed"}, "originalPosition": 1}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMDA2ODM4OA==", "bodyText": "fixed", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r600068388", "createdAt": "2021-03-24T00:46:15Z", "author": {"login": "weymann"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/resources/OH-INF/thing/loction-channel-types.xml", "diffHunk": "@@ -0,0 +1,14 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5NzkzNzA2Ng=="}, "originalCommit": {"oid": "48af48c82562d006b6f2aa35922270f181c885ed"}, "originalPosition": 1}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzc3NjkwMjkxOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/resources/OH-INF/thing/range-channel-types.xml", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0xOVQxOTo1MTowNFrOI6PQVg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0yOFQwMDozNTozNlrOI-4nNg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5NzkzODI2Mg==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\t<label>Remaining Fuel </label>\n          \n          \n            \n            \t\t<label>Remaining Fuel</label>", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r597938262", "createdAt": "2021-03-19T19:51:04Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/resources/OH-INF/thing/range-channel-types.xml", "diffHunk": "@@ -0,0 +1,42 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"bmwconnecteddrive\"\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\t<channel-type id=\"mileage-channel\">\n+\t\t<item-type>Number:Length</item-type>\n+\t\t<label>Total Distance Driven</label>\n+\t</channel-type>\n+\t<channel-type id=\"range-electric-channel\">\n+\t\t<item-type>Number:Length</item-type>\n+\t\t<label>Electric Range</label>\n+\t</channel-type>\n+\t<channel-type id=\"range-fuel-channel\">\n+\t\t<item-type>Number:Length</item-type>\n+\t\t<label>Fuel Range</label>\n+\t</channel-type>\n+\t<channel-type id=\"range-hybrid-channel\">\n+\t\t<item-type>Number:Length</item-type>\n+\t\t<label>Hybrid Range</label>\n+\t</channel-type>\n+\t<channel-type id=\"soc-channel\">\n+\t\t<item-type>Number:Dimensionless</item-type>\n+\t\t<label>Battery Charge Level</label>\n+\t</channel-type>\n+\t<channel-type id=\"remaining-fuel-channel\">\n+\t\t<item-type>Number:Volume</item-type>\n+\t\t<label>Remaining Fuel </label>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "48af48c82562d006b6f2aa35922270f181c885ed"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMjgxMDE2Ng==", "bodyText": "Fixed", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r602810166", "createdAt": "2021-03-28T00:35:36Z", "author": {"login": "weymann"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/resources/OH-INF/thing/range-channel-types.xml", "diffHunk": "@@ -0,0 +1,42 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"bmwconnecteddrive\"\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\t<channel-type id=\"mileage-channel\">\n+\t\t<item-type>Number:Length</item-type>\n+\t\t<label>Total Distance Driven</label>\n+\t</channel-type>\n+\t<channel-type id=\"range-electric-channel\">\n+\t\t<item-type>Number:Length</item-type>\n+\t\t<label>Electric Range</label>\n+\t</channel-type>\n+\t<channel-type id=\"range-fuel-channel\">\n+\t\t<item-type>Number:Length</item-type>\n+\t\t<label>Fuel Range</label>\n+\t</channel-type>\n+\t<channel-type id=\"range-hybrid-channel\">\n+\t\t<item-type>Number:Length</item-type>\n+\t\t<label>Hybrid Range</label>\n+\t</channel-type>\n+\t<channel-type id=\"soc-channel\">\n+\t\t<item-type>Number:Dimensionless</item-type>\n+\t\t<label>Battery Charge Level</label>\n+\t</channel-type>\n+\t<channel-type id=\"remaining-fuel-channel\">\n+\t\t<item-type>Number:Volume</item-type>\n+\t\t<label>Remaining Fuel </label>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5NzkzODI2Mg=="}, "originalCommit": {"oid": "48af48c82562d006b6f2aa35922270f181c885ed"}, "originalPosition": 28}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzc3NjkwMzU1OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/resources/OH-INF/thing/range-channel-types.xml", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0xOVQxOTo1MToxOFrOI6PQxQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0yOFQwMDozNTo0N1rOI-4nUw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5NzkzODM3Mw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\t<label>Electric Range Radius </label>\n          \n          \n            \n            \t\t<label>Electric Range Radius</label>", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r597938373", "createdAt": "2021-03-19T19:51:18Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/resources/OH-INF/thing/range-channel-types.xml", "diffHunk": "@@ -0,0 +1,42 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"bmwconnecteddrive\"\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\t<channel-type id=\"mileage-channel\">\n+\t\t<item-type>Number:Length</item-type>\n+\t\t<label>Total Distance Driven</label>\n+\t</channel-type>\n+\t<channel-type id=\"range-electric-channel\">\n+\t\t<item-type>Number:Length</item-type>\n+\t\t<label>Electric Range</label>\n+\t</channel-type>\n+\t<channel-type id=\"range-fuel-channel\">\n+\t\t<item-type>Number:Length</item-type>\n+\t\t<label>Fuel Range</label>\n+\t</channel-type>\n+\t<channel-type id=\"range-hybrid-channel\">\n+\t\t<item-type>Number:Length</item-type>\n+\t\t<label>Hybrid Range</label>\n+\t</channel-type>\n+\t<channel-type id=\"soc-channel\">\n+\t\t<item-type>Number:Dimensionless</item-type>\n+\t\t<label>Battery Charge Level</label>\n+\t</channel-type>\n+\t<channel-type id=\"remaining-fuel-channel\">\n+\t\t<item-type>Number:Volume</item-type>\n+\t\t<label>Remaining Fuel </label>\n+\t</channel-type>\n+\t<channel-type id=\"range-radius-electric-channel\">\n+\t\t<item-type>Number:Length</item-type>\n+\t\t<label>Electric Range Radius </label>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "48af48c82562d006b6f2aa35922270f181c885ed"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMjgxMDE5NQ==", "bodyText": "Fixed", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r602810195", "createdAt": "2021-03-28T00:35:47Z", "author": {"login": "weymann"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/resources/OH-INF/thing/range-channel-types.xml", "diffHunk": "@@ -0,0 +1,42 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"bmwconnecteddrive\"\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\t<channel-type id=\"mileage-channel\">\n+\t\t<item-type>Number:Length</item-type>\n+\t\t<label>Total Distance Driven</label>\n+\t</channel-type>\n+\t<channel-type id=\"range-electric-channel\">\n+\t\t<item-type>Number:Length</item-type>\n+\t\t<label>Electric Range</label>\n+\t</channel-type>\n+\t<channel-type id=\"range-fuel-channel\">\n+\t\t<item-type>Number:Length</item-type>\n+\t\t<label>Fuel Range</label>\n+\t</channel-type>\n+\t<channel-type id=\"range-hybrid-channel\">\n+\t\t<item-type>Number:Length</item-type>\n+\t\t<label>Hybrid Range</label>\n+\t</channel-type>\n+\t<channel-type id=\"soc-channel\">\n+\t\t<item-type>Number:Dimensionless</item-type>\n+\t\t<label>Battery Charge Level</label>\n+\t</channel-type>\n+\t<channel-type id=\"remaining-fuel-channel\">\n+\t\t<item-type>Number:Volume</item-type>\n+\t\t<label>Remaining Fuel </label>\n+\t</channel-type>\n+\t<channel-type id=\"range-radius-electric-channel\">\n+\t\t<item-type>Number:Length</item-type>\n+\t\t<label>Electric Range Radius </label>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5NzkzODM3Mw=="}, "originalCommit": {"oid": "48af48c82562d006b6f2aa35922270f181c885ed"}, "originalPosition": 32}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzc3NjkwNjQ1OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/resources/OH-INF/thing/remote-services-channel-types.xml", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0xOVQxOTo1MjowOVrOI6PSfw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0yMVQxNTo1NzoyM1rOI6lWTg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5NzkzODgxNQ==", "bodyText": "Are there predefined commands? You could add them as options.", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r597938815", "createdAt": "2021-03-19T19:52:09Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/resources/OH-INF/thing/remote-services-channel-types.xml", "diffHunk": "@@ -0,0 +1,14 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"bmwconnecteddrive\"\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\t<channel-type id=\"remote-command-channel\">\n+\t\t<item-type>String</item-type>\n+\t\t<label>Remote Command</label>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "48af48c82562d006b6f2aa35922270f181c885ed"}, "originalPosition": 8}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5ODMwMDIzOA==", "bodyText": "commands are dynamic as they depend on the type of car", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r598300238", "createdAt": "2021-03-21T15:57:23Z", "author": {"login": "ntruchsess"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/resources/OH-INF/thing/remote-services-channel-types.xml", "diffHunk": "@@ -0,0 +1,14 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"bmwconnecteddrive\"\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\t<channel-type id=\"remote-command-channel\">\n+\t\t<item-type>String</item-type>\n+\t\t<label>Remote Command</label>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5NzkzODgxNQ=="}, "originalCommit": {"oid": "48af48c82562d006b6f2aa35922270f181c885ed"}, "originalPosition": 8}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzc3NjkwNzk1OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/resources/OH-INF/thing/remote-services-channel-types.xml", "isResolved": true, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0xOVQxOTo1MjozOVrOI6PTew==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0yOVQwMToxMDo1MFrOI_CBIA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5NzkzOTA2Nw==", "bodyText": "This sounds read-only. You could add the state tag with readonly=\"true\".", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r597939067", "createdAt": "2021-03-19T19:52:39Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/resources/OH-INF/thing/remote-services-channel-types.xml", "diffHunk": "@@ -0,0 +1,14 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"bmwconnecteddrive\"\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\t<channel-type id=\"remote-command-channel\">\n+\t\t<item-type>String</item-type>\n+\t\t<label>Remote Command</label>\n+\t</channel-type>\n+\t<channel-type id=\"remote-state-channel\">\n+\t\t<item-type>String</item-type>\n+\t\t<label>Service Execution State</label>\n+\t</channel-type>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "48af48c82562d006b6f2aa35922270f181c885ed"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMjgxMjI0Nw==", "bodyText": "Yes like described in readme.md. Is there any benefit to add the optional state tag?", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r602812247", "createdAt": "2021-03-28T01:01:35Z", "author": {"login": "weymann"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/resources/OH-INF/thing/remote-services-channel-types.xml", "diffHunk": "@@ -0,0 +1,14 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"bmwconnecteddrive\"\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\t<channel-type id=\"remote-command-channel\">\n+\t\t<item-type>String</item-type>\n+\t\t<label>Remote Command</label>\n+\t</channel-type>\n+\t<channel-type id=\"remote-state-channel\">\n+\t\t<item-type>String</item-type>\n+\t\t<label>Service Execution State</label>\n+\t</channel-type>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5NzkzOTA2Nw=="}, "originalCommit": {"oid": "48af48c82562d006b6f2aa35922270f181c885ed"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMjg1NjI1NA==", "bodyText": "Honestly I don't know what the impact to the UI is, when setting the readonly flag. I recommended it to keep the model consistent to the readme. I won't insist on adding it.", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r602856254", "createdAt": "2021-03-28T09:36:36Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/resources/OH-INF/thing/remote-services-channel-types.xml", "diffHunk": "@@ -0,0 +1,14 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"bmwconnecteddrive\"\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\t<channel-type id=\"remote-command-channel\">\n+\t\t<item-type>String</item-type>\n+\t\t<label>Remote Command</label>\n+\t</channel-type>\n+\t<channel-type id=\"remote-state-channel\">\n+\t\t<item-type>String</item-type>\n+\t\t<label>Service Execution State</label>\n+\t</channel-type>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5NzkzOTA2Nw=="}, "originalCommit": {"oid": "48af48c82562d006b6f2aa35922270f181c885ed"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMjg2NDI4Mw==", "bodyText": "From my understanding it's just a hint for the UI. If it is there it depends on which UI is being used. If it's not there it cannot be respected.", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r602864283", "createdAt": "2021-03-28T10:59:33Z", "author": {"login": "ntruchsess"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/resources/OH-INF/thing/remote-services-channel-types.xml", "diffHunk": "@@ -0,0 +1,14 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"bmwconnecteddrive\"\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\t<channel-type id=\"remote-command-channel\">\n+\t\t<item-type>String</item-type>\n+\t\t<label>Remote Command</label>\n+\t</channel-type>\n+\t<channel-type id=\"remote-state-channel\">\n+\t\t<item-type>String</item-type>\n+\t\t<label>Service Execution State</label>\n+\t</channel-type>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5NzkzOTA2Nw=="}, "originalCommit": {"oid": "48af48c82562d006b6f2aa35922270f181c885ed"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMjk2NDI1Ng==", "bodyText": "As I added the patterns for most of the states also the readOnly=true is added for all read-only channels.", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r602964256", "createdAt": "2021-03-29T01:10:50Z", "author": {"login": "weymann"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/resources/OH-INF/thing/remote-services-channel-types.xml", "diffHunk": "@@ -0,0 +1,14 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"bmwconnecteddrive\"\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\t<channel-type id=\"remote-command-channel\">\n+\t\t<item-type>String</item-type>\n+\t\t<label>Remote Command</label>\n+\t</channel-type>\n+\t<channel-type id=\"remote-state-channel\">\n+\t\t<item-type>String</item-type>\n+\t\t<label>Service Execution State</label>\n+\t</channel-type>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5NzkzOTA2Nw=="}, "originalCommit": {"oid": "48af48c82562d006b6f2aa35922270f181c885ed"}, "originalPosition": 13}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzc3NjkxMTk0OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/resources/OH-INF/thing/service-channel-types.xml", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0xOVQxOTo1Mzo1NlrOI6PV7Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0yNFQwMDo0NzoyM1rOI8RSlQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5NzkzOTY5Mw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\t<label>Service Date </label>\n          \n          \n            \n            \t\t<label>Service Date</label>", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r597939693", "createdAt": "2021-03-19T19:53:56Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/resources/OH-INF/thing/service-channel-types.xml", "diffHunk": "@@ -0,0 +1,22 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"bmwconnecteddrive\"\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\t<channel-type id=\"service-name-channel\">\n+\t\t<item-type>String</item-type>\n+\t\t<label>Service Name</label>\n+\t</channel-type>\n+\t<channel-type id=\"service-details-channel\">\n+\t\t<item-type>String</item-type>\n+\t\t<label>Service Details</label>\n+\t</channel-type>\n+\t<channel-type id=\"service-date-channel\">\n+\t\t<item-type>DateTime</item-type>\n+\t\t<label>Service Date </label>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "48af48c82562d006b6f2aa35922270f181c885ed"}, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMDA2ODc1Nw==", "bodyText": "corrected", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r600068757", "createdAt": "2021-03-24T00:47:23Z", "author": {"login": "weymann"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/resources/OH-INF/thing/service-channel-types.xml", "diffHunk": "@@ -0,0 +1,22 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"bmwconnecteddrive\"\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\t<channel-type id=\"service-name-channel\">\n+\t\t<item-type>String</item-type>\n+\t\t<label>Service Name</label>\n+\t</channel-type>\n+\t<channel-type id=\"service-details-channel\">\n+\t\t<item-type>String</item-type>\n+\t\t<label>Service Details</label>\n+\t</channel-type>\n+\t<channel-type id=\"service-date-channel\">\n+\t\t<item-type>DateTime</item-type>\n+\t\t<label>Service Date </label>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5NzkzOTY5Mw=="}, "originalCommit": {"oid": "48af48c82562d006b6f2aa35922270f181c885ed"}, "originalPosition": 16}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzc3NjkxNjU3OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/resources/OH-INF/thing/thing-bev.xml", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0xOVQxOTo1NToxOVrOI6PYtg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0yOFQwMDozOToxNFrOI-4omg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5Nzk0MDQwNg==", "bodyText": "Please check all.\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\t\t\t<label>Refresh Interval in Minutes</label>\n          \n          \n            \n            \t\t\t\t<label>Refresh Interval</label>", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r597940406", "createdAt": "2021-03-19T19:55:19Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/resources/OH-INF/thing/thing-bev.xml", "diffHunk": "@@ -0,0 +1,69 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"bmwconnecteddrive\"\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\n+\t<thing-type id=\"bev\">\n+\t\t<supported-bridge-type-refs>\n+\t\t\t<bridge-type-ref id=\"account\"/>\n+\t\t</supported-bridge-type-refs>\n+\n+\t\t<label>BMW Electric Vehicle</label>\n+\t\t<description>Battery Electric Vehicle (BEV)</description>\n+\n+\t\t<channel-groups>\n+\t\t\t<channel-group id=\"status\" typeId=\"ev-vehicle-status\"/>\n+\t\t\t<channel-group id=\"doors\" typeId=\"door-values\"/>\n+\t\t\t<channel-group id=\"range\" typeId=\"ev-range-values\"/>\n+\t\t\t<channel-group id=\"check\" typeId=\"check-control-values\"/>\n+\t\t\t<channel-group id=\"service\" typeId=\"service-values\"/>\n+\t\t\t<channel-group id=\"location\" typeId=\"location-values\"/>\n+\t\t\t<channel-group id=\"remote\" typeId=\"remote-services\"/>\n+\t\t\t<channel-group id=\"charge\" typeId=\"charge-values\"/>\n+\t\t\t<channel-group id=\"last-trip\" typeId=\"ev-last-trip-values\"/>\n+\t\t\t<channel-group id=\"lifetime\" typeId=\"ev-lifetime-values\"/>\n+\t\t\t<channel-group id=\"destination\" typeId=\"destination-values\"/>\n+\t\t\t<channel-group id=\"image\" typeId=\"image-values\"/>\n+\t\t</channel-groups>\n+\n+\t\t<config-description>\n+\t\t\t<parameter name=\"vin\" type=\"text\" required=\"true\">\n+\t\t\t\t<label>Vehicle Identification Number (VIN)</label>\n+\t\t\t\t<description>Unique VIN given by BMW</description>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"refreshInterval\" type=\"integer\" min=\"1\" unit=\"min\" required=\"true\">\n+\t\t\t\t<label>Refresh Interval in Minutes</label>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "48af48c82562d006b6f2aa35922270f181c885ed"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMjgxMDUyMg==", "bodyText": "Fixed", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r602810522", "createdAt": "2021-03-28T00:39:14Z", "author": {"login": "weymann"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/resources/OH-INF/thing/thing-bev.xml", "diffHunk": "@@ -0,0 +1,69 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"bmwconnecteddrive\"\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\n+\t<thing-type id=\"bev\">\n+\t\t<supported-bridge-type-refs>\n+\t\t\t<bridge-type-ref id=\"account\"/>\n+\t\t</supported-bridge-type-refs>\n+\n+\t\t<label>BMW Electric Vehicle</label>\n+\t\t<description>Battery Electric Vehicle (BEV)</description>\n+\n+\t\t<channel-groups>\n+\t\t\t<channel-group id=\"status\" typeId=\"ev-vehicle-status\"/>\n+\t\t\t<channel-group id=\"doors\" typeId=\"door-values\"/>\n+\t\t\t<channel-group id=\"range\" typeId=\"ev-range-values\"/>\n+\t\t\t<channel-group id=\"check\" typeId=\"check-control-values\"/>\n+\t\t\t<channel-group id=\"service\" typeId=\"service-values\"/>\n+\t\t\t<channel-group id=\"location\" typeId=\"location-values\"/>\n+\t\t\t<channel-group id=\"remote\" typeId=\"remote-services\"/>\n+\t\t\t<channel-group id=\"charge\" typeId=\"charge-values\"/>\n+\t\t\t<channel-group id=\"last-trip\" typeId=\"ev-last-trip-values\"/>\n+\t\t\t<channel-group id=\"lifetime\" typeId=\"ev-lifetime-values\"/>\n+\t\t\t<channel-group id=\"destination\" typeId=\"destination-values\"/>\n+\t\t\t<channel-group id=\"image\" typeId=\"image-values\"/>\n+\t\t</channel-groups>\n+\n+\t\t<config-description>\n+\t\t\t<parameter name=\"vin\" type=\"text\" required=\"true\">\n+\t\t\t\t<label>Vehicle Identification Number (VIN)</label>\n+\t\t\t\t<description>Unique VIN given by BMW</description>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"refreshInterval\" type=\"integer\" min=\"1\" unit=\"min\" required=\"true\">\n+\t\t\t\t<label>Refresh Interval in Minutes</label>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5Nzk0MDQwNg=="}, "originalCommit": {"oid": "48af48c82562d006b6f2aa35922270f181c885ed"}, "originalPosition": 36}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzc3NjkxNzYxOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/resources/OH-INF/thing/thing-bev.xml", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0xOVQxOTo1NTozNVrOI6PZVQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0yOFQwMDo0MDoyM1rOI-4pCQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5Nzk0MDU2NQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\t\t\t<description>Data Refresh Rate for your Vehicle data </description>\n          \n          \n            \n            \t\t\t\t<description>Data Refresh Rate for your Vehicle data</description>", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r597940565", "createdAt": "2021-03-19T19:55:35Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/resources/OH-INF/thing/thing-bev.xml", "diffHunk": "@@ -0,0 +1,69 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"bmwconnecteddrive\"\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\n+\t<thing-type id=\"bev\">\n+\t\t<supported-bridge-type-refs>\n+\t\t\t<bridge-type-ref id=\"account\"/>\n+\t\t</supported-bridge-type-refs>\n+\n+\t\t<label>BMW Electric Vehicle</label>\n+\t\t<description>Battery Electric Vehicle (BEV)</description>\n+\n+\t\t<channel-groups>\n+\t\t\t<channel-group id=\"status\" typeId=\"ev-vehicle-status\"/>\n+\t\t\t<channel-group id=\"doors\" typeId=\"door-values\"/>\n+\t\t\t<channel-group id=\"range\" typeId=\"ev-range-values\"/>\n+\t\t\t<channel-group id=\"check\" typeId=\"check-control-values\"/>\n+\t\t\t<channel-group id=\"service\" typeId=\"service-values\"/>\n+\t\t\t<channel-group id=\"location\" typeId=\"location-values\"/>\n+\t\t\t<channel-group id=\"remote\" typeId=\"remote-services\"/>\n+\t\t\t<channel-group id=\"charge\" typeId=\"charge-values\"/>\n+\t\t\t<channel-group id=\"last-trip\" typeId=\"ev-last-trip-values\"/>\n+\t\t\t<channel-group id=\"lifetime\" typeId=\"ev-lifetime-values\"/>\n+\t\t\t<channel-group id=\"destination\" typeId=\"destination-values\"/>\n+\t\t\t<channel-group id=\"image\" typeId=\"image-values\"/>\n+\t\t</channel-groups>\n+\n+\t\t<config-description>\n+\t\t\t<parameter name=\"vin\" type=\"text\" required=\"true\">\n+\t\t\t\t<label>Vehicle Identification Number (VIN)</label>\n+\t\t\t\t<description>Unique VIN given by BMW</description>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"refreshInterval\" type=\"integer\" min=\"1\" unit=\"min\" required=\"true\">\n+\t\t\t\t<label>Refresh Interval in Minutes</label>\n+\t\t\t\t<description>Data Refresh Rate for your Vehicle data </description>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "48af48c82562d006b6f2aa35922270f181c885ed"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMjgxMDYzMw==", "bodyText": "Fixed for all locations", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r602810633", "createdAt": "2021-03-28T00:40:23Z", "author": {"login": "weymann"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/resources/OH-INF/thing/thing-bev.xml", "diffHunk": "@@ -0,0 +1,69 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"bmwconnecteddrive\"\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\n+\t<thing-type id=\"bev\">\n+\t\t<supported-bridge-type-refs>\n+\t\t\t<bridge-type-ref id=\"account\"/>\n+\t\t</supported-bridge-type-refs>\n+\n+\t\t<label>BMW Electric Vehicle</label>\n+\t\t<description>Battery Electric Vehicle (BEV)</description>\n+\n+\t\t<channel-groups>\n+\t\t\t<channel-group id=\"status\" typeId=\"ev-vehicle-status\"/>\n+\t\t\t<channel-group id=\"doors\" typeId=\"door-values\"/>\n+\t\t\t<channel-group id=\"range\" typeId=\"ev-range-values\"/>\n+\t\t\t<channel-group id=\"check\" typeId=\"check-control-values\"/>\n+\t\t\t<channel-group id=\"service\" typeId=\"service-values\"/>\n+\t\t\t<channel-group id=\"location\" typeId=\"location-values\"/>\n+\t\t\t<channel-group id=\"remote\" typeId=\"remote-services\"/>\n+\t\t\t<channel-group id=\"charge\" typeId=\"charge-values\"/>\n+\t\t\t<channel-group id=\"last-trip\" typeId=\"ev-last-trip-values\"/>\n+\t\t\t<channel-group id=\"lifetime\" typeId=\"ev-lifetime-values\"/>\n+\t\t\t<channel-group id=\"destination\" typeId=\"destination-values\"/>\n+\t\t\t<channel-group id=\"image\" typeId=\"image-values\"/>\n+\t\t</channel-groups>\n+\n+\t\t<config-description>\n+\t\t\t<parameter name=\"vin\" type=\"text\" required=\"true\">\n+\t\t\t\t<label>Vehicle Identification Number (VIN)</label>\n+\t\t\t\t<description>Unique VIN given by BMW</description>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"refreshInterval\" type=\"integer\" min=\"1\" unit=\"min\" required=\"true\">\n+\t\t\t\t<label>Refresh Interval in Minutes</label>\n+\t\t\t\t<description>Data Refresh Rate for your Vehicle data </description>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5Nzk0MDU2NQ=="}, "originalCommit": {"oid": "48af48c82562d006b6f2aa35922270f181c885ed"}, "originalPosition": 37}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzc3NjkxOTc5OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/resources/OH-INF/thing/thing-bev_rex.xml", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0xOVQxOTo1NjoxNlrOI6PaoQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0yOFQyMzo1OToyNVrOI_BXWQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5Nzk0MDg5Nw==", "bodyText": "See above. Length.", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r597940897", "createdAt": "2021-03-19T19:56:16Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/resources/OH-INF/thing/thing-bev_rex.xml", "diffHunk": "@@ -0,0 +1,69 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"bmwconnecteddrive\"\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\n+\t<thing-type id=\"bev_rex\">\n+\t\t<supported-bridge-type-refs>\n+\t\t\t<bridge-type-ref id=\"account\"/>\n+\t\t</supported-bridge-type-refs>\n+\n+\t\t<label>BMW Electric Vehicle with REX</label>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "48af48c82562d006b6f2aa35922270f181c885ed"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMjk1MzU2MQ==", "bodyText": "Fixed", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r602953561", "createdAt": "2021-03-28T23:59:25Z", "author": {"login": "weymann"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/resources/OH-INF/thing/thing-bev_rex.xml", "diffHunk": "@@ -0,0 +1,69 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"bmwconnecteddrive\"\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\n+\t<thing-type id=\"bev_rex\">\n+\t\t<supported-bridge-type-refs>\n+\t\t\t<bridge-type-ref id=\"account\"/>\n+\t\t</supported-bridge-type-refs>\n+\n+\t\t<label>BMW Electric Vehicle with REX</label>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5Nzk0MDg5Nw=="}, "originalCommit": {"oid": "48af48c82562d006b6f2aa35922270f181c885ed"}, "originalPosition": 12}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzc3NjkyNTczOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/resources/OH-INF/thing/thing-phev.xml", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0xOVQxOTo1Nzo1MlrOI6PeAQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0yOFQyMjoxOTozNlrOI_Am0w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5Nzk0MTc2MQ==", "bodyText": "You could move the config description in a dedicated file and reference it here.", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r597941761", "createdAt": "2021-03-19T19:57:52Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/resources/OH-INF/thing/thing-phev.xml", "diffHunk": "@@ -0,0 +1,69 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"bmwconnecteddrive\"\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\n+\t<thing-type id=\"phev\">\n+\t\t<supported-bridge-type-refs>\n+\t\t\t<bridge-type-ref id=\"account\"/>\n+\t\t</supported-bridge-type-refs>\n+\n+\t\t<label>BMW Plug-In-Hybrid Electric Vehicle</label>\n+\t\t<description>Conventional Fuel Vehicle with supporting Electric Engine (PHEV)</description>\n+\n+\t\t<channel-groups>\n+\t\t\t<channel-group id=\"status\" typeId=\"ev-vehicle-status\"/>\n+\t\t\t<channel-group id=\"doors\" typeId=\"door-values\"/>\n+\t\t\t<channel-group id=\"range\" typeId=\"hybrid-range-values\"/>\n+\t\t\t<channel-group id=\"check\" typeId=\"check-control-values\"/>\n+\t\t\t<channel-group id=\"service\" typeId=\"service-values\"/>\n+\t\t\t<channel-group id=\"location\" typeId=\"location-values\"/>\n+\t\t\t<channel-group id=\"remote\" typeId=\"remote-services\"/>\n+\t\t\t<channel-group id=\"charge\" typeId=\"charge-values\"/>\n+\t\t\t<channel-group id=\"last-trip\" typeId=\"hybrid-last-trip-values\"/>\n+\t\t\t<channel-group id=\"lifetime\" typeId=\"hybrid-lifetime-values\"/>\n+\t\t\t<channel-group id=\"destination\" typeId=\"destination-values\"/>\n+\t\t\t<channel-group id=\"image\" typeId=\"image-values\"/>\n+\t\t</channel-groups>\n+\n+\t\t<config-description>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "48af48c82562d006b6f2aa35922270f181c885ed"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMjk0MTEzOQ==", "bodyText": "Done for Bridge and all Vehicles", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r602941139", "createdAt": "2021-03-28T22:19:36Z", "author": {"login": "weymann"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/resources/OH-INF/thing/thing-phev.xml", "diffHunk": "@@ -0,0 +1,69 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"bmwconnecteddrive\"\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\n+\t<thing-type id=\"phev\">\n+\t\t<supported-bridge-type-refs>\n+\t\t\t<bridge-type-ref id=\"account\"/>\n+\t\t</supported-bridge-type-refs>\n+\n+\t\t<label>BMW Plug-In-Hybrid Electric Vehicle</label>\n+\t\t<description>Conventional Fuel Vehicle with supporting Electric Engine (PHEV)</description>\n+\n+\t\t<channel-groups>\n+\t\t\t<channel-group id=\"status\" typeId=\"ev-vehicle-status\"/>\n+\t\t\t<channel-group id=\"doors\" typeId=\"door-values\"/>\n+\t\t\t<channel-group id=\"range\" typeId=\"hybrid-range-values\"/>\n+\t\t\t<channel-group id=\"check\" typeId=\"check-control-values\"/>\n+\t\t\t<channel-group id=\"service\" typeId=\"service-values\"/>\n+\t\t\t<channel-group id=\"location\" typeId=\"location-values\"/>\n+\t\t\t<channel-group id=\"remote\" typeId=\"remote-services\"/>\n+\t\t\t<channel-group id=\"charge\" typeId=\"charge-values\"/>\n+\t\t\t<channel-group id=\"last-trip\" typeId=\"hybrid-last-trip-values\"/>\n+\t\t\t<channel-group id=\"lifetime\" typeId=\"hybrid-lifetime-values\"/>\n+\t\t\t<channel-group id=\"destination\" typeId=\"destination-values\"/>\n+\t\t\t<channel-group id=\"image\" typeId=\"image-values\"/>\n+\t\t</channel-groups>\n+\n+\t\t<config-description>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5Nzk0MTc2MQ=="}, "originalCommit": {"oid": "48af48c82562d006b6f2aa35922270f181c885ed"}, "originalPosition": 30}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzc3NjkzNDE0OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.bmwconnecteddrive/README.md", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0xOVQyMDowMDozMFrOI6PjLg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0yOFQyMDo0MjowNFrOI-_6hw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5Nzk0MzA4Ng==", "bodyText": "Same for the others.\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            | BMW ConnectedDrive Account | account        | Access to BMW ConnectedDrive Portal for a specific user    |\n          \n          \n            \n            | BMW ConnectedDrive Account | `account`        | Access to BMW ConnectedDrive Portal for a specific user    |", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r597943086", "createdAt": "2021-03-19T20:00:30Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/README.md", "diffHunk": "@@ -0,0 +1,849 @@\n+# BMW ConnectedDrive Binding\n+\n+<img align=\"right\" src=\"./doc/bmw-connected.png\" width=\"150\" height=\"150\"/>\n+\n+The binding provides a connection between [BMW's ConnectedDrive Portal](https://www.bmw-connecteddrive.com/country-region-select/country-region-selection.html) and openHAB.\n+All vehicles connected to an account will be detected by the discovery with the correct type \n+\n+* Conventional Fuel Vehicle\n+* Plugin-Hybrid Electrical Vehicle \n+* Battery Electric Vehicle with Range Extender\n+* Battery Electric Vehicle \n+\n+In addition properties are attached with information and services provided by this vehicle.\n+The provided data depends on \n+\n+1. the [Thing Type](#things) and \n+2. the [Properties](#properties) mentioned in Services\n+\n+Different channel groups are clustering all informations.\n+Check for each group if it's supported for this Vehicle.\n+\n+Please note **this isn't a real-time binding**. \n+If a door is opened the state isn't transmitted and changed immediately. \n+This isn't a flaw in the binding itself because the state in BMW's own ConnectedDrive App is also updated with some delay. \n+\n+## Supported Things\n+\n+### Bridge\n+\n+The bridge establishes the connection between BMW's ConnectedDrive Portal and openHAB.\n+\n+| Name                       | Bridge Type ID | Description                                                |\n+|----------------------------|----------------|------------------------------------------------------------|\n+| BMW ConnectedDrive Account | account        | Access to BMW ConnectedDrive Portal for a specific user    |", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "48af48c82562d006b6f2aa35922270f181c885ed"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMjgxMzMwOA==", "bodyText": "Ok, just for my understanding: Putting all Bridge, Thing and Channel Ids in code fences? Is this a new?", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r602813308", "createdAt": "2021-03-28T01:15:48Z", "author": {"login": "weymann"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/README.md", "diffHunk": "@@ -0,0 +1,849 @@\n+# BMW ConnectedDrive Binding\n+\n+<img align=\"right\" src=\"./doc/bmw-connected.png\" width=\"150\" height=\"150\"/>\n+\n+The binding provides a connection between [BMW's ConnectedDrive Portal](https://www.bmw-connecteddrive.com/country-region-select/country-region-selection.html) and openHAB.\n+All vehicles connected to an account will be detected by the discovery with the correct type \n+\n+* Conventional Fuel Vehicle\n+* Plugin-Hybrid Electrical Vehicle \n+* Battery Electric Vehicle with Range Extender\n+* Battery Electric Vehicle \n+\n+In addition properties are attached with information and services provided by this vehicle.\n+The provided data depends on \n+\n+1. the [Thing Type](#things) and \n+2. the [Properties](#properties) mentioned in Services\n+\n+Different channel groups are clustering all informations.\n+Check for each group if it's supported for this Vehicle.\n+\n+Please note **this isn't a real-time binding**. \n+If a door is opened the state isn't transmitted and changed immediately. \n+This isn't a flaw in the binding itself because the state in BMW's own ConnectedDrive App is also updated with some delay. \n+\n+## Supported Things\n+\n+### Bridge\n+\n+The bridge establishes the connection between BMW's ConnectedDrive Portal and openHAB.\n+\n+| Name                       | Bridge Type ID | Description                                                |\n+|----------------------------|----------------|------------------------------------------------------------|\n+| BMW ConnectedDrive Account | account        | Access to BMW ConnectedDrive Portal for a specific user    |", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5Nzk0MzA4Ng=="}, "originalCommit": {"oid": "48af48c82562d006b6f2aa35922270f181c885ed"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMjg1NjQ5Nw==", "bodyText": "The Thing Type UID. It's not mandatory.", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r602856497", "createdAt": "2021-03-28T09:38:32Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/README.md", "diffHunk": "@@ -0,0 +1,849 @@\n+# BMW ConnectedDrive Binding\n+\n+<img align=\"right\" src=\"./doc/bmw-connected.png\" width=\"150\" height=\"150\"/>\n+\n+The binding provides a connection between [BMW's ConnectedDrive Portal](https://www.bmw-connecteddrive.com/country-region-select/country-region-selection.html) and openHAB.\n+All vehicles connected to an account will be detected by the discovery with the correct type \n+\n+* Conventional Fuel Vehicle\n+* Plugin-Hybrid Electrical Vehicle \n+* Battery Electric Vehicle with Range Extender\n+* Battery Electric Vehicle \n+\n+In addition properties are attached with information and services provided by this vehicle.\n+The provided data depends on \n+\n+1. the [Thing Type](#things) and \n+2. the [Properties](#properties) mentioned in Services\n+\n+Different channel groups are clustering all informations.\n+Check for each group if it's supported for this Vehicle.\n+\n+Please note **this isn't a real-time binding**. \n+If a door is opened the state isn't transmitted and changed immediately. \n+This isn't a flaw in the binding itself because the state in BMW's own ConnectedDrive App is also updated with some delay. \n+\n+## Supported Things\n+\n+### Bridge\n+\n+The bridge establishes the connection between BMW's ConnectedDrive Portal and openHAB.\n+\n+| Name                       | Bridge Type ID | Description                                                |\n+|----------------------------|----------------|------------------------------------------------------------|\n+| BMW ConnectedDrive Account | account        | Access to BMW ConnectedDrive Portal for a specific user    |", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5Nzk0MzA4Ng=="}, "originalCommit": {"oid": "48af48c82562d006b6f2aa35922270f181c885ed"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMjkyOTc5OQ==", "bodyText": "ok, done", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r602929799", "createdAt": "2021-03-28T20:42:04Z", "author": {"login": "weymann"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/README.md", "diffHunk": "@@ -0,0 +1,849 @@\n+# BMW ConnectedDrive Binding\n+\n+<img align=\"right\" src=\"./doc/bmw-connected.png\" width=\"150\" height=\"150\"/>\n+\n+The binding provides a connection between [BMW's ConnectedDrive Portal](https://www.bmw-connecteddrive.com/country-region-select/country-region-selection.html) and openHAB.\n+All vehicles connected to an account will be detected by the discovery with the correct type \n+\n+* Conventional Fuel Vehicle\n+* Plugin-Hybrid Electrical Vehicle \n+* Battery Electric Vehicle with Range Extender\n+* Battery Electric Vehicle \n+\n+In addition properties are attached with information and services provided by this vehicle.\n+The provided data depends on \n+\n+1. the [Thing Type](#things) and \n+2. the [Properties](#properties) mentioned in Services\n+\n+Different channel groups are clustering all informations.\n+Check for each group if it's supported for this Vehicle.\n+\n+Please note **this isn't a real-time binding**. \n+If a door is opened the state isn't transmitted and changed immediately. \n+This isn't a flaw in the binding itself because the state in BMW's own ConnectedDrive App is also updated with some delay. \n+\n+## Supported Things\n+\n+### Bridge\n+\n+The bridge establishes the connection between BMW's ConnectedDrive Portal and openHAB.\n+\n+| Name                       | Bridge Type ID | Description                                                |\n+|----------------------------|----------------|------------------------------------------------------------|\n+| BMW ConnectedDrive Account | account        | Access to BMW ConnectedDrive Portal for a specific user    |", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5Nzk0MzA4Ng=="}, "originalCommit": {"oid": "48af48c82562d006b6f2aa35922270f181c885ed"}, "originalPosition": 34}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzc3NjkzNjcyOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.bmwconnecteddrive/README.md", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0xOVQyMDowMToyMlrOI6Pkxg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0yNFQwMDozOToxMFrOI8RC9w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5Nzk0MzQ5NA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            In  *Services Supported* the entry *LastDestination* is mentioned.\n          \n          \n            \n            In *Services Supported* the entry *LastDestination* is mentioned.", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r597943494", "createdAt": "2021-03-19T20:01:22Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/README.md", "diffHunk": "@@ -0,0 +1,849 @@\n+# BMW ConnectedDrive Binding\n+\n+<img align=\"right\" src=\"./doc/bmw-connected.png\" width=\"150\" height=\"150\"/>\n+\n+The binding provides a connection between [BMW's ConnectedDrive Portal](https://www.bmw-connecteddrive.com/country-region-select/country-region-selection.html) and openHAB.\n+All vehicles connected to an account will be detected by the discovery with the correct type \n+\n+* Conventional Fuel Vehicle\n+* Plugin-Hybrid Electrical Vehicle \n+* Battery Electric Vehicle with Range Extender\n+* Battery Electric Vehicle \n+\n+In addition properties are attached with information and services provided by this vehicle.\n+The provided data depends on \n+\n+1. the [Thing Type](#things) and \n+2. the [Properties](#properties) mentioned in Services\n+\n+Different channel groups are clustering all informations.\n+Check for each group if it's supported for this Vehicle.\n+\n+Please note **this isn't a real-time binding**. \n+If a door is opened the state isn't transmitted and changed immediately. \n+This isn't a flaw in the binding itself because the state in BMW's own ConnectedDrive App is also updated with some delay. \n+\n+## Supported Things\n+\n+### Bridge\n+\n+The bridge establishes the connection between BMW's ConnectedDrive Portal and openHAB.\n+\n+| Name                       | Bridge Type ID | Description                                                |\n+|----------------------------|----------------|------------------------------------------------------------|\n+| BMW ConnectedDrive Account | account        | Access to BMW ConnectedDrive Portal for a specific user    |\n+\n+\n+### Things\n+\n+Four different vehicle types are provided. \n+They differ in the supported channel groups & channels. \n+Conventional Fuel Vehicles have no _Charging Profile_, Electric Vehicles don't provide a _Fuel Range_. \n+For hybrid vehicles in addition to _Fuel and Electric Range_ the _Hybrid Range_ is shown.\n+ \n+| Name                                | Thing Type ID | Supported Channel Groups                               |\n+|-------------------------------------|---------------|--------------------------------------------------------|\n+| BMW Electric Vehicle                | bev           | status, range, location, service, check, charge, image |\n+| BMW Electric Vehicle with REX       | bev_rex       | status, range, location, service, check, charge, image |\n+| BMW Plug-In-Hybrid Electric Vehicle | phev          | status, range, location, service, check, charge, image |\n+| BMW Conventional Vehicle            | conv          | status, range, location, service, check, image         |\n+\n+ \n+#### Properties\n+\n+<img align=\"right\" src=\"./doc/properties.png\" width=\"500\" height=\"225\"/>\n+\n+For each vehicle properties are available. \n+Basically 3 types of information are registered as properties\n+\n+* Informations regarding your dealer with address and phone number\n+* Which services are available / not available\n+* Vehicle properties like color, model type, drive train and construction year\n+\n+In the right picture can see in *Services Activated* e.g. the *DoorLock* and *DoorUnlock* services are mentioned. \n+This ensures channel group [Remote Services](#remote-services) is supporting door lock and unlock remote control.\n+\n+In  *Services Supported* the entry *LastDestination* is mentioned.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "48af48c82562d006b6f2aa35922270f181c885ed"}, "originalPosition": 66}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMDA2NDc1OQ==", "bodyText": "fixed", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r600064759", "createdAt": "2021-03-24T00:39:10Z", "author": {"login": "weymann"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/README.md", "diffHunk": "@@ -0,0 +1,849 @@\n+# BMW ConnectedDrive Binding\n+\n+<img align=\"right\" src=\"./doc/bmw-connected.png\" width=\"150\" height=\"150\"/>\n+\n+The binding provides a connection between [BMW's ConnectedDrive Portal](https://www.bmw-connecteddrive.com/country-region-select/country-region-selection.html) and openHAB.\n+All vehicles connected to an account will be detected by the discovery with the correct type \n+\n+* Conventional Fuel Vehicle\n+* Plugin-Hybrid Electrical Vehicle \n+* Battery Electric Vehicle with Range Extender\n+* Battery Electric Vehicle \n+\n+In addition properties are attached with information and services provided by this vehicle.\n+The provided data depends on \n+\n+1. the [Thing Type](#things) and \n+2. the [Properties](#properties) mentioned in Services\n+\n+Different channel groups are clustering all informations.\n+Check for each group if it's supported for this Vehicle.\n+\n+Please note **this isn't a real-time binding**. \n+If a door is opened the state isn't transmitted and changed immediately. \n+This isn't a flaw in the binding itself because the state in BMW's own ConnectedDrive App is also updated with some delay. \n+\n+## Supported Things\n+\n+### Bridge\n+\n+The bridge establishes the connection between BMW's ConnectedDrive Portal and openHAB.\n+\n+| Name                       | Bridge Type ID | Description                                                |\n+|----------------------------|----------------|------------------------------------------------------------|\n+| BMW ConnectedDrive Account | account        | Access to BMW ConnectedDrive Portal for a specific user    |\n+\n+\n+### Things\n+\n+Four different vehicle types are provided. \n+They differ in the supported channel groups & channels. \n+Conventional Fuel Vehicles have no _Charging Profile_, Electric Vehicles don't provide a _Fuel Range_. \n+For hybrid vehicles in addition to _Fuel and Electric Range_ the _Hybrid Range_ is shown.\n+ \n+| Name                                | Thing Type ID | Supported Channel Groups                               |\n+|-------------------------------------|---------------|--------------------------------------------------------|\n+| BMW Electric Vehicle                | bev           | status, range, location, service, check, charge, image |\n+| BMW Electric Vehicle with REX       | bev_rex       | status, range, location, service, check, charge, image |\n+| BMW Plug-In-Hybrid Electric Vehicle | phev          | status, range, location, service, check, charge, image |\n+| BMW Conventional Vehicle            | conv          | status, range, location, service, check, image         |\n+\n+ \n+#### Properties\n+\n+<img align=\"right\" src=\"./doc/properties.png\" width=\"500\" height=\"225\"/>\n+\n+For each vehicle properties are available. \n+Basically 3 types of information are registered as properties\n+\n+* Informations regarding your dealer with address and phone number\n+* Which services are available / not available\n+* Vehicle properties like color, model type, drive train and construction year\n+\n+In the right picture can see in *Services Activated* e.g. the *DoorLock* and *DoorUnlock* services are mentioned. \n+This ensures channel group [Remote Services](#remote-services) is supporting door lock and unlock remote control.\n+\n+In  *Services Supported* the entry *LastDestination* is mentioned.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5Nzk0MzQ5NA=="}, "originalCommit": {"oid": "48af48c82562d006b6f2aa35922270f181c885ed"}, "originalPosition": 66}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzc3Njk0MjIzOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/resources/OH-INF/thing/thing-bev.xml", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0xOVQyMDowMzoyNlrOI6PoPA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0yNFQwMDozNzo1NFrOI8RBRA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5Nzk0NDM4MA==", "bodyText": "Please add the representation property. Same for the others.", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r597944380", "createdAt": "2021-03-19T20:03:26Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/resources/OH-INF/thing/thing-bev.xml", "diffHunk": "@@ -0,0 +1,69 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"bmwconnecteddrive\"\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\n+\t<thing-type id=\"bev\">", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "48af48c82562d006b6f2aa35922270f181c885ed"}, "originalPosition": 7}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMDA2NDMyNA==", "bodyText": "Fixed", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r600064324", "createdAt": "2021-03-24T00:37:54Z", "author": {"login": "weymann"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/resources/OH-INF/thing/thing-bev.xml", "diffHunk": "@@ -0,0 +1,69 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"bmwconnecteddrive\"\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\n+\t<thing-type id=\"bev\">", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5Nzk0NDM4MA=="}, "originalCommit": {"oid": "48af48c82562d006b6f2aa35922270f181c885ed"}, "originalPosition": 7}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzc3Njk3ODU4OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.bmwconnecteddrive/README.md", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0xOVQyMDoxNTowOFrOI6P-tg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0yMVQxMjo1Mzo1NVrOI6j0iA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5Nzk1MDEzNA==", "bodyText": "Why isn't the command sent after each action automatically? That can lead to race conditions if multiple rules are executed simultaneously.", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r597950134", "createdAt": "2021-03-19T20:15:08Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/README.md", "diffHunk": "@@ -0,0 +1,849 @@\n+# BMW ConnectedDrive Binding\n+\n+<img align=\"right\" src=\"./doc/bmw-connected.png\" width=\"150\" height=\"150\"/>\n+\n+The binding provides a connection between [BMW's ConnectedDrive Portal](https://www.bmw-connecteddrive.com/country-region-select/country-region-selection.html) and openHAB.\n+All vehicles connected to an account will be detected by the discovery with the correct type \n+\n+* Conventional Fuel Vehicle\n+* Plugin-Hybrid Electrical Vehicle \n+* Battery Electric Vehicle with Range Extender\n+* Battery Electric Vehicle \n+\n+In addition properties are attached with information and services provided by this vehicle.\n+The provided data depends on \n+\n+1. the [Thing Type](#things) and \n+2. the [Properties](#properties) mentioned in Services\n+\n+Different channel groups are clustering all informations.\n+Check for each group if it's supported for this Vehicle.\n+\n+Please note **this isn't a real-time binding**. \n+If a door is opened the state isn't transmitted and changed immediately. \n+This isn't a flaw in the binding itself because the state in BMW's own ConnectedDrive App is also updated with some delay. \n+\n+## Supported Things\n+\n+### Bridge\n+\n+The bridge establishes the connection between BMW's ConnectedDrive Portal and openHAB.\n+\n+| Name                       | Bridge Type ID | Description                                                |\n+|----------------------------|----------------|------------------------------------------------------------|\n+| BMW ConnectedDrive Account | account        | Access to BMW ConnectedDrive Portal for a specific user    |\n+\n+\n+### Things\n+\n+Four different vehicle types are provided. \n+They differ in the supported channel groups & channels. \n+Conventional Fuel Vehicles have no _Charging Profile_, Electric Vehicles don't provide a _Fuel Range_. \n+For hybrid vehicles in addition to _Fuel and Electric Range_ the _Hybrid Range_ is shown.\n+ \n+| Name                                | Thing Type ID | Supported Channel Groups                               |\n+|-------------------------------------|---------------|--------------------------------------------------------|\n+| BMW Electric Vehicle                | bev           | status, range, location, service, check, charge, image |\n+| BMW Electric Vehicle with REX       | bev_rex       | status, range, location, service, check, charge, image |\n+| BMW Plug-In-Hybrid Electric Vehicle | phev          | status, range, location, service, check, charge, image |\n+| BMW Conventional Vehicle            | conv          | status, range, location, service, check, image         |\n+\n+ \n+#### Properties\n+\n+<img align=\"right\" src=\"./doc/properties.png\" width=\"500\" height=\"225\"/>\n+\n+For each vehicle properties are available. \n+Basically 3 types of information are registered as properties\n+\n+* Informations regarding your dealer with address and phone number\n+* Which services are available / not available\n+* Vehicle properties like color, model type, drive train and construction year\n+\n+In the right picture can see in *Services Activated* e.g. the *DoorLock* and *DoorUnlock* services are mentioned. \n+This ensures channel group [Remote Services](#remote-services) is supporting door lock and unlock remote control.\n+\n+In  *Services Supported* the entry *LastDestination* is mentioned.\n+So it's valid to connect channel group [Last Destinations](#destinations) in order to display and select the last navigation destinations.\n+\n+| Property Key       | Property Value      |  Supported Channel Groups    |\n+|--------------------|---------------------|------------------------------|\n+| servicesSupported  | Statistics          | last-trip, lifetime          |\n+| servicesSupported  | LastDestinations    | destinations                 |\n+| servicesActivated  | _list of services_  | remote                       |\n+\n+\n+## Discovery\n+\n+Auto discovery is starting after the bridge towards BMW's ConnectedDrive is created. \n+A list of your registered vehicles is queried and all found things are added in the inbox.\n+Unique identifier is the *Vehicle Identification Number* (VIN). \n+If a thing is already declared in a  _.things_ configuration, discovery won't highlight it again.\n+Properties will be attached to predefined vehicles if the VIN is matching.\n+\n+## Configuration\n+\n+### Bridge Configuration\n+\n+| Parameter       | Type    | Description                                                        |           \n+|-----------------|---------|--------------------------------------------------------------------|\n+| userName        | text    | BMW ConnectedDrive Username                                       |\n+| password        | text    | BMW ConnectedDrive Password                                       |\n+| region          | text    | Select region in order to connect to the appropriate BMW server.   |\n+\n+The region Configuration has 3 different options\n+\n+* _NORTH_AMERICA_\n+* _CHINA_\n+* _ROW_  (Rest of World)\n+\n+### Thing Configuration\n+\n+Same configuration is needed for all things\n+\n+| Parameter       | Type    | Description                           |           \n+|-----------------|---------|---------------------------------------|\n+| vin             | text    | Vehicle Identification Number (VIN)   |\n+| refreshInterval | integer | Refresh Interval in Minutes           |\n+| units           | text    | Unit Selection. See below.            |\n+| imageSize       | integer | Image Size                            |\n+| imageViewport   | text    | Image Viewport                        |\n+\n+The unit configuration has 3 options\n+\n+* _AUTODETECT_ selects miles for US & UK, kilometer otherwise\n+* _METRIC_ selects directly kilometers\n+* _IMPERIAL_ selects directly miles\n+\n+The _imageVieport_ allows to show the vehicle from different angels.\n+Possible options are \n+\n+* _FRONT_\n+* _REAR_\n+* _SIDE_\n+* _DASHBOARD_\n+* _DRIVERDOOR_\n+\n+## Channels\n+\n+There are many channels available for each vehicle. \n+For better overview they are clustered in different channel groups.\n+They differ for each vehicle type, build-in sensors and activated services.\n+\n+\n+### Thing Channel Groups \n+\n+#### Vehicle Status\n+\n+Reflects overall status of the vehicle.\n+\n+* Channel Group ID is **status**\n+* Available for all vehicles\n+* Read-only values\n+\n+| Channel Label             | Channel ID          | Type          | Description                                    |\n+|---------------------------|---------------------|---------------|------------------------------------------------|\n+| Overall Door Status       | doors               | String        | Combined status for all doors                  |\n+| Overall Window Status     | windows             | String        | Combined status for all windows                |\n+| Doors Locked              | lock                | String        | Status if doors are locked or unlocked         |\n+| Next Service Date         | service-date        | DateTime      | Date of upcoming service                       |\n+| Mileage till Next Service | service-mileage     | Number:Length | Mileage till upcoming service                  |\n+| Check Control             | check-control       | String        | Presence of active warning messages            |\n+| Charging Status           | charge              | String        | Only available for phev, bev_rex and bev       |\n+| Last Status Timestamp     | last-update         | DateTime      | Date and time of last status update            |\n+\n+Overall Door Status values\n+\n+* _Closed_ - all doors closed\n+* _Open_ - at least one door is open\n+* _Undef_ - no door data delivered at all\n+\n+Overall Windows Status values\n+\n+* _Closed_ - all windows closed\n+* _Open_ - at least one window is completely open\n+* _Intermediate_ - at least one window is partially open\n+* _Undef_ - no window data delivered at all\n+\n+Check Control values\n+\n+* _Active_ - at least one warning message is active\n+* _Not Active_ - no warning message is active\n+* _Undef_ - no data for warnings delivered\n+\n+Charging Status values\n+\n+* _Charging_\n+* _Error_\n+* _Finished Fully Charged_\n+* _Finished Not Full_\n+* _Invalid_\n+* _Not Charging_\n+* _Charging Goal reached_\n+* _Waiting For Charging_\n+\n+#### Services\n+\n+Group for all upcoming services with description, service date and/or service mileage.\n+If more than one service is scheduled in the future the channel _name_ contains all future services as options.\n+\n+* Channel Group ID is **service**\n+* Available for all vehicles\n+* Read/Write access\n+\n+| Channel Label                  | Channel ID          | Type           | Access     |\n+|--------------------------------|---------------------|----------------|------------|\n+| Service Name                   | name                | String         | Read/Write |\n+| Service Details                | details             | String         | Read       |\n+| Service Date                   | date                | Number         | Read       |\n+| Mileage till Service           | mileage             | Number:Length  | Read       |\n+\n+#### Check Control\n+\n+Group for all current active CheckControl messages.\n+If more than one message is active the channel _name_ contains all active messages as options.\n+\n+* Channel Group ID is **check**\n+* Available for all vehicles\n+* Read/Write access\n+\n+| Channel Label                   | Channel ID          | Type           | Access     |\n+|---------------------------------|---------------------|----------------|------------|\n+| CheckControl Description        | name                | String         | Read/Write |\n+| CheckControl Details            | details             | String         | Read       |\n+| Mileage Occurrence              | mileage             | Number:Length  | Read       |\n+\n+#### Doors Details\n+\n+Detailed status of all doors and windows.\n+\n+* Channel Group ID is **doors**\n+* Available for all vehicles if corresponding sensors are built-in \n+* Read-only values\n+ \n+| Channel Label              | Channel ID              | Type          | \n+|----------------------------|-------------------------|---------------|\n+| Driver Door                | driver-front            | String        |\n+| Driver Door Rear           | driver-rear             | String        |\n+| Passenger Door             | passenger-front         | String        |\n+| Passenger Door Rear        | passenger-rear          | String        |\n+| Trunk                      | trunk                   | String        |\n+| Hood                       | hood                    | String        |\n+| Driver Window              | win-driver-front        | String        |\n+| Driver Rear Window         | win-driver-rear         | String        |\n+| Passenger Window           | win-passenger-front     | String        |\n+| Passenger Rear Window      | win-passenger-rear      | String        |\n+| Rear Window                | win-rear                | String        |\n+| Sunroof                    | sunroof                 | String        |\n+\n+Possible states\n+\n+* _Undef_ - no status data available\n+* _Invalid_ - this door / window isn't applicable for this vehicle\n+* _Closed_ - the door / window is closed\n+* _Open_ - the door / window is open\n+* _Intermediate_ - window in intermediate position, not applicable for doors\n+\n+#### Range Data\n+\n+Based on vehicle type some channels are present or not. \n+Conventional fuel vehicles don't provide *Electric Range* and battery electric vehicles don't show *Fuel Range*.\n+Hybrid vehicles have both and in addition *Hybrid Range*.\n+See description [Range vs Range Radius](#range-vs-range-radius) to get more information.\n+\n+* Channel Group ID is **range**\n+* Availability according to table\n+* Read-only values\n+\n+| Channel Label         | Channel ID            | Type                 | conv | phev | bev_rex | bev |\n+|-----------------------|-----------------------|----------------------|------|------|---------|-----|\n+| Mileage               | mileage               | Number:Length        |  X   |  X   |    X    |  X  |\n+| Fuel Range            | range-fuel            | Number:Length        |  X   |  X   |    X    |     |\n+| Battery Range         | range-electric        | Number:Length        |      |  X   |    X    |  X  | \n+| Hybrid Range          | range-hybrid          | Number:Length        |      |  X   |    X    |     | \n+| Battery Charge Level  | soc                   | Number:Dimensionless |      |  X   |    X    |  X  |\n+| Remaining Fuel        | remaining-fuel        | Number:Volume        |  X   |  X   |    X    |     | \n+| Fuel Range Radius     | range-radius-fuel     | Number:Length        |  X   |  X   |    X    |     | \n+| Electric Range Radius | range-radius-electric | Number:Length        |      |  X   |    X    |  X  | \n+| Hybrid Range Radius   | range-radius-hybrid   | Number:Length        |      |  X   |    X    |     | \n+\n+\n+#### Charge Profile\n+\n+Charging options with date and time for preferred time windows and charging modes.\n+\n+* Channel Group ID is **charge**\n+* Available for electric and hybrid vehicles\n+* Read/Write access for UI. Use [Charge Profile Actions](#charge-profile-action) in rules\n+* There are 3 timers available. Replace *X* with number 1,2 or 3 to target the correct timer\n+\n+| Channel Label                         | Channel Group ID | Channel ID                | Type     | \n+|---------------------------------------|------------------|---------------------------|----------| \n+| Charging Mode for Profile             | charge           | profile-mode              | String   | \n+| Charging Preferences for Profile      | charge           | profile-prefs             | String   | \n+| Charging Window Start Time            | charge           | window-start              | DateTime | \n+| Charging Window Start Time Hour       | charge           | window-start-hour         | Number   | \n+| Charging Window Start Time Minute     | charge           | window-start-minute       | Number   | \n+| Charging Window End Time              | charge           | window-end                | DateTime | \n+| Charging Window End Time Hour         | charge           | window-end-hour           | Number   | \n+| Charging Window End Time Minute       | charge           | window-end-minute         | Number   | \n+| Air Conditioning at Departure Time    | charge           | profile-climate           | Switch   | \n+| Timer *X*: Enabled                    | charge           | timer*X*-enabled          | Switch   | \n+| Timer *X*: Departure Time             | charge           | timer*X*-departure        | DateTime | \n+| Timer *X*: Departure Time Hour        | charge           | timer*X*-departure-hour   | Number   | \n+| Timer *X*: Departure Time Minute      | charge           | timer*X*-departure-minute | Number   | \n+| Timer *X*: Monday                     | charge           | timer*X*-day-mon          | Switch   | \n+| Timer *X*: Tuesday                    | charge           | timer*X*-day-tue          | Switch   | \n+| Timer *X*: Wednesday                  | charge           | timer*X*-day-wed          | Switch   | \n+| Timer *X*: Thursday                   | charge           | timer*X*-day-thu          | Switch   | \n+| Timer *X*: Friday                     | charge           | timer*X*-day-fri          | Switch   | \n+| Timer *X*: Saturday                   | charge           | timer*X*-day-sat          | Switch   | \n+| Timer *X*: Sunday                     | charge           | timer*X*-day-sun          | Switch   | \n+| Override Timer: Enabled               | charge           | override-enabled          | Switch   | \n+| Override Timer: Departure Time        | charge           | override-departure        | DateTime | \n+| Override Timer: Departure Time Hour   | charge           | override-departure-hour   | Number   | \n+| Override Timer: Departure Time Minute | charge           | override-departure-minute | Number   | \n+\n+The channel _profile-mode_ supports\n+\n+* *IMMEDIATE_CHARGING*\n+* *DELAYED_CHARGING*\n+\n+The channel _profile-prefs_ supports\n+\n+* *NO_PRESELECTION*\n+* *CHARGING_WINDOW*\n+\n+#### Location\n+\n+GPS location and heading of the vehicle.\n+\n+* Channel Group ID is **location**\n+* Available for all vehicles with built-in GPS sensor. Function can be enabled/disabled in the head unit\n+* Read-only values\n+\n+| Channel Label   | Channel ID          | Type         | \n+|-----------------|---------------------|--------------|\n+| GPS Coordinates | gps                 | Location     | \n+| Heading         | heading             | Number:Angle | \n+\n+#### Last Trip\n+\n+Statistic values of duration, distance and consumption of the last trip.\n+\n+* Channel Group ID is **last-trip**\n+* Available if *Statistics* is present in *Services Supported*. See [Vehicle Properties](#properties) for further details\n+* Read-only values\n+* Depending on units configuration in [Thing Configuration](#thing-configuration) average values are given for 100 kilometers or miles\n+\n+| Channel Label                           | Channel ID                   | Type          |\n+|-----------------------------------------|------------------------------|---------------|\n+| Last Trip Date                          | date                         | DateTime      |\n+| Last Trip Duration                      | duration                     | Number:Time   |\n+| Last Trip Distance                      | distance                     | Number:Length |\n+| Distance since Charge                   | distance-since-charging      | Number:Length |\n+| Avg. Power Consumption                  | avg-consumption              | Number:Power  |\n+| Avg. Power Recuperation                 | avg-recuperation             | Number:Power  |\n+| Avg. Combined Consumption               | avg-combined-consumption     | Number:Volume |\n+\n+\n+#### Lifetime Statistics\n+\n+Providing lifetime consumption values.\n+\n+* Channel Group ID is **lifetime**\n+* Available if *Statistics* is present in *Services Supported*. See [Vehicle Properties](#properties) for further details\n+* Read-only values\n+* Depending on units configuration in [Thing Configuration](#thing-configuration) average values are given for 100 kilometers or miles\n+\n+| Channel Label                           | Channel ID                   | Type          | \n+|-----------------------------------------|------------------------------|---------------|\n+| Total Electric Distance                 | total-driven-distance        | Number:Length |\n+| Longest 1-Charge Distance               | single-longest-distance      | Number:Length |\n+| Avg. Power Consumption                  | avg-consumption              | Number:Power  |\n+| Avg. Power Recuperation                 | avg-recuperation             | Number:Power  |\n+| Avg. Combined Consumption               | avg-combined-consumption     | Number:Volume |\n+\n+\n+#### Remote Services\n+\n+Remote control of the vehicle. \n+Send a *command* to the vehicle and the *state* is reporting the execution progress.\n+Only one command can be executed each time.\n+Parallel execution isn't supported.\n+\n+* Channel Group ID is **remote**\n+* Available for all commands mentioned in *Services Activated*. See [Vehicle Properties](#properties) for further details\n+* Read/Write access\n+\n+\n+| Channel Label           | Channel ID          | Type    | Access |\n+|-------------------------|---------------------|---------|--------|\n+| Remote Service Command  | command             | String  | Write  |\n+| Service Execution State | state               | String  | Read   |\n+\n+The channel _command_ provides options\n+\n+* _Flash Lights_\n+* _Vehicle Finder_\n+* _Door Lock_\n+* _Door Unlock_\n+* _Horn Blow_\n+* _Climate Control_\n+* _Start Charging_\n+* _Send Charging Profile_\n+\n+The channel _state_ shows the progress of the command execution in the following order\n+\n+1) _Initiated_ \n+2) _Pending_\n+3) _Delivered_\n+4) _Executed_\n+\n+#### Destinations\n+\n+Shows the last destinations stored in the navigation system.\n+If several last destinations are stored in the navigation system the channel _name_ contains all addresses as options.\n+\n+* Channel Group ID is **destination**\n+* Available if *LastDestinations* is present in *Services Supported*. Check [Vehicle Properties](#properties) for further details\n+* Read/Write access\n+\n+\n+| Channel Label        | Channel ID    | Type      | Access      |\n+|----------------------|---------------|-----------|-------------|\n+| Name                 | name          | String    | Read/Write  |\n+| GPS Coordinates      | gps           | Location  | Read        |\n+\n+\n+\n+#### Image\n+\n+Image representation of the vehicle. Size and viewport are writable and can be \n+The possible values are the same mentioned in [Thing Configuration](#thing-configuration).\n+\n+* Channel Group ID is **image**\n+* Available for all vehicles\n+* Read/Write access\n+\n+| Channel Label              | Channel ID          | Type   |  Access  |\n+|----------------------------|---------------------|--------|----------|\n+| Rendered Vehicle Image     | png                 | Image  | Read     |\n+| Image Viewport             | view                | String | Write    |\n+| Image Picture Size         | size                | Number | Write    |\n+\n+## Rule Actions\n+\n+## Charge Profile Action\n+\n+The Charge Profile is accessible and modifiable in rules via action. \n+Get the corresponding action from your car using the Thing ID\n+\n+* bmwconnecteddrive - Binding ID, don't change!\n+* bev_rex - [Thing UID](#things) of your car\n+* user - Thing ID of the [Bridge](#bridge)\n+* i3 - Thing ID of your car\n+\n+```\n+  val profile = getActions(\"chargeprofile\", \"bmwconnecteddrive:bev_rex:user:i3\")\n+```\n+\n+Like in the Charge Profile Channels 3 Timers are provided. Replace *X* with 1, 2 or 3 to address the right timer.\n+\n+| Function                              | Parameters       | Returns                   | Description                                                | \n+|---------------------------------------|------------------|---------------------------|------------------------------------------------------------| \n+| getClimatizationEnabled               | void             | Boolean                   | Returns the enabled state of climatization                 | \n+| setClimatizationEnabled               | Boolean          | void                      | Sets the enabled state of climatization                    | \n+| getChargingMode                       | void             | String                    | Gets the charging-mode, see valid options below            | \n+| setChargingMode                       | String           | void                      | Sets the charging-mode, see valid options below            | \n+| getPreferredWindowStart               | void             | LocalTime                 | Returns the preferred charging-window start time           | \n+| setPreferredWindowStart               | LocalTime        | void                      | Sets the preferred charging-window start time              | \n+| getPreferredWindowEnd                 | void             | LocalTime                 | Returns the preferred charging-window end time             | \n+| setPreferredWindowEnd                 | LocalTime        | void                      | Sets the preferred charging-window end time                | \n+| getTimer*X*Enabled                    | void             | Boolean                   | Returns the enabled state of timer*X*                      | \n+| setTimer*X*Enabled                    | Boolean          | void                      | Returns the enabled state of timer*X*                      | \n+| getTimer*X*Departure                  | void             | LocalTime                 | Returns the departure time of timer*X*                     | \n+| setTimer*X*Departure                  | LocalTime        | void                      | Sets the timer*X* departure time                           | \n+| getTimer*X*Days                       | void             | Set<DayOfWeek>            | Returns the days of week timer*X* is enabled for           | \n+| setTimer*X*Days                       | Set<DayOfWeek>   | void                      | sets the days of week timer*X* is enabled for              | \n+| getOverrideTimerEnabled               | void             | Boolean                   | Returns the enabled state of override timer                | \n+| setOverrideTimerEnabled               | Boolean          | void                      | Sets the enabled state of override timer                   | \n+| getOverrideTimerDeparture             | void             | LocalTime                 | Returns the departure time of override timer               | \n+| setOverrideTimerDeparture             | LocalTime        | void                      | Sets the override timer departure time                     | \n+| getOverrideTimerDays                  | void             | Set<DayOfWeek>            | Returns the days of week the overrideTimer is enabled for  | \n+| setOverrideTimerDays                  | Set<DayOfWeek>   | void                      | Sets the days of week the overrideTimer is enabled for     | \n+| cancel                                | void             | void                      | Sends the charging profile to the vehicle                  | \n+| send                                  | void             | void                      | Cancel current edit of charging profile                    | \n+\n+Values for valid charging mode get/set\n+\n+* *IMMEDIATE_CHARGING*\n+* *DELAYED_CHARGING*\n+\n+\n+## Further Descriptions\n+\n+### Dynamic Data\n+\n+<img align=\"right\" src=\"./doc/ServiceOptions.png\" width=\"400\" height=\"350\"/>\n+\n+There are 3 occurrences of dynamic data delivered\n+\n+* Upcoming Services delivered in group [Services](#services)\n+* Check Control Messages delivered in group [Check Control](#check-control)\n+* Last Destinations delivered in group [Destinations](#destinations)\n+\n+The channel id _name_ shows the first element as default. \n+All other possibilities are attached as options. \n+The picture on the right shows the _Service Name_ item and all four possible options. \n+Select the desired service and the corresponding _Service Date & Milage_ will be shown.  \n+\n+### TroubleShooting\n+\n+BMW has a high range of vehicles supported by ConnectedDrive.\n+In case of any issues with this binding help to resolve it! \n+Please perform the following steps:\n+\n+* Can you [log into ConnectedDrive](https://www.bmw-connecteddrive.com/country-region-select/country-region-selection.html) with your credentials? Please note this isn't the BMW Customer portal - it's the ConnectedDrive portal\n+* Is the vehicle listed in your account? There's a one-to-one relation from user to vehicle\n+\n+If the access to the portal is working and the vehicle is listed some debug data is needed in order to identify the issue. \n+\n+#### Generate Debug Fingerprint\n+\n+If you checked the above pre-conditions you need to get the debug fingerprint from the logs.\n+First [enable debug logging](https://www.openhab.org/docs/administration/logging.html#defining-what-to-log) for the binding.\n+\n+```\n+log:set DEBUG org.openhab.binding.bmwconnecteddrive\n+```\n+\n+The debug fingerprint is generated immediately after the vehicle thing is initialized the first time, e.g. after openHAB startup. \n+To force a new fingerprint disable the thing shortly and enable it again. \n+Personal data is eliminated from the log entries so it should be possible to share them in public.\n+Data like\n+\n+* Dealer Properties\n+* Vehicle Identification Number (VIN)\n+* Location latitude / longitude \n+\n+are anonymized.\n+You'll find the fingerprint in the logs with the command\n+\n+```\n+grep \"BMW ConnectedDrive Binding\" openhab.log\n+```\n+\n+After the corresponding fingerprint is generated please [follow the instructions to raise an issue](https://community.openhab.org/t/how-to-file-an-issue/68464) and attach the fingerprint data!\n+Your feedback is highly appreciated!\n+\n+\n+### Range vs Range Radius\n+\n+<img align=\"right\" src=\"./doc/range-radius.png\" width=\"400\" height=\"350\"/>\n+\n+You will observe differences in the vehicle range and range radius values. \n+While range is indicating the possible distance to be driven on roads the range radius indicates the reachable range on the map.\n+\n+The right picture shows the distance between Kassel and Frankfurt in Germany. \n+While the air-line distance is ~145 kilometer the route distance is ~192 kilometer.\n+So range value is the normal remaining range while the range radius values can be used e.g. on [Mapview](https://www.openhab.org/docs/configuration/sitemaps.html#element-type-mapview) to indicate the reachable range on map.\n+Please note this is just an indicator of the effective range.\n+Especially for electric vehicles it depends on many factors like driving style and usage of electric consumers. \n+\n+## Full Example\n+\n+The example is based on a BMW i3 with range extender (REX). \n+Exchange the three configuration parameters in the Things section\n+\n+* YOUR_USERNAME - with your ConnectedDrive login username\n+* YOUR_PASSWORD - with your ConnectedDrive password credentials\n+* VEHICLE_VIN - the vehicle identification number\n+\n+In addition search for all occurrences of *i3* and replace it with your Vehicle Identification like *x3* or *535d* and you're ready to go!\n+\n+### Things File\n+\n+```\n+Bridge bmwconnecteddrive:account:user   \"BMW ConnectedDrive Account\" [userName=\"YOUR_USERNAME\",password=\"YOUR_PASSWORD\",region=\"ROW\"] {\n+         Thing bev_rex i3       \"BMW i3 94h REX\"                [ vin=\"VEHICLE_VIN\",units=\"AUTODETECT\",imageSize=600,imageViewport=\"FRONT\",refreshInterval=5]\n+}\n+```\n+\n+### Items File\n+\n+```\n+Number:Length           i3Mileage                 \"Odometer [%d %unit%]\"                        <line>          (i3)        {channel=\"bmwconnecteddrive:bev_rex:user:i3:range#mileage\" }                                                                           \n+Number:Length           i3Range                   \"Range [%d %unit%]\"                           <motion>        (i3)        {channel=\"bmwconnecteddrive:bev_rex:user:i3:range#hybrid\"}\n+Number:Length           i3RangeElectric           \"Electric Range [%d %unit%]\"                  <motion>        (i3,long)   {channel=\"bmwconnecteddrive:bev_rex:user:i3:range#electric\"}   \n+Number:Length           i3RangeFuel               \"Fuel Range [%d %unit%]\"                      <motion>        (i3)        {channel=\"bmwconnecteddrive:bev_rex:user:i3:range#fuel\"}\n+Number:Dimensionless    i3BatterySoc              \"Battery Charge [%.1f %%]\"                    <battery>       (i3,long)   {channel=\"bmwconnecteddrive:bev_rex:user:i3:range#soc\"}\n+Number:Volume           i3Fuel                    \"Fuel [%.1f %unit%]\"                          <oil>           (i3)        {channel=\"bmwconnecteddrive:bev_rex:user:i3:range#remaining-fuel\"}\n+Number:Length           i3RadiusElectric          \"Electric Radius [%d %unit%]\"                 <zoom>          (i3)        {channel=\"bmwconnecteddrive:bev_rex:user:i3:range#radius-electric\" }\n+Number:Length           i3RadiusHybrid            \"Hybrid Radius [%d %unit%]\"                   <zoom>          (i3)        {channel=\"bmwconnecteddrive:bev_rex:user:i3:range#radius-hybrid\" }\n+\n+String                  i3DoorStatus              \"Door Status [%s]\"                            <lock>          (i3)        {channel=\"bmwconnecteddrive:bev_rex:user:i3:status#doors\" }\n+String                  i3WindowStatus            \"Window Status [%s]\"                          <lock>          (i3)        {channel=\"bmwconnecteddrive:bev_rex:user:i3:status#windows\" }\n+String                  i3LockStatus              \"Lock Status [%s]\"                            <lock>          (i3)        {channel=\"bmwconnecteddrive:bev_rex:user:i3:status#lock\" }\n+DateTime                i3NextServiceDate         \"Next Service Date [%1$tb %1$tY]\"             <calendar>      (i3)        {channel=\"bmwconnecteddrive:bev_rex:user:i3:status#service-date\" }\n+String                  i3NextServiceMileage      \"Next Service Mileage [%d %unit%]\"            <line>          (i3)        {channel=\"bmwconnecteddrive:bev_rex:user:i3:status#service-mileage\" }\n+String                  i3CheckControl            \"Check Control [%s]\"                          <error>         (i3)        {channel=\"bmwconnecteddrive:bev_rex:user:i3:status#check-control\" }\n+String                  i3ChargingStatus          \"Charging [%s]\"                               <energy>        (i3)        {channel=\"bmwconnecteddrive:bev_rex:user:i3:status#charge\" } \n+DateTime                i3LastUpdate              \"Update [%1$tA, %1$td.%1$tm. %1$tH:%1$tM]\"    <calendar>      (i3)        {channel=\"bmwconnecteddrive:bev_rex:user:i3:status#last-update\"}\n+\n+DateTime                i3TripDateTime            \"Trip Date [%1$tA, %1$td.%1$tm. %1$tH:%1$tM]\" <calendar>      (i3)        {channel=\"bmwconnecteddrive:bev_rex:user:i3:last-trip#date\"}\n+Number:Time             i3TripDuration            \"Trip Duration [%d %unit%]\"                   <time>          (i3)        {channel=\"bmwconnecteddrive:bev_rex:user:i3:last-trip#duration\"}\n+Number:Length           i3TripDistance            \"Distance [%d %unit%]\"                        <line>          (i3)        {channel=\"bmwconnecteddrive:bev_rex:user:i3:last-trip#distance\" }                                                                           \n+Number:Length           i3TripDistanceSinceCharge \"Distance since last Charge [%d %unit%]\"      <line>          (i3,long)   {channel=\"bmwconnecteddrive:bev_rex:user:i3:last-trip#distance-since-charging\" }                                                                           \n+Number:Energy           i3AvgTripConsumption      \"Average Consumption [%.1f %unit%]\"           <energy>        (i3)        {channel=\"bmwconnecteddrive:bev_rex:user:i3:last-trip#avg-consumption\" }                                                                           \n+Number:Volume           i3AvgTripCombined         \"Average Combined Consumption [%.1f %unit%]\"  <oil>           (i3)        {channel=\"bmwconnecteddrive:bev_rex:user:i3:last-trip#avg-combined-consumption\" }                                                                           \n+Number:Energy           i3AvgTripRecuperation     \"Average Recuperation [%.1f %unit%]\"          <energy>        (i3)        {channel=\"bmwconnecteddrive:bev_rex:user:i3:last-trip#avg-recuperation\" }                                                                           \n+\n+Number:Length           i3TotalElectric           \"Electric Distance Driven [%d %unit%]\"        <line>          (i3)        {channel=\"bmwconnecteddrive:bev_rex:user:i3:lifetime#total-driven-distance\" }                                                                           \n+Number:Length           i3LongestEVTrip           \"Longest Electric Trip [%d %unit%]\"           <line>          (i3)        {channel=\"bmwconnecteddrive:bev_rex:user:i3:lifetime#single-longest-distance\" }                                                                           \n+Number:Energy           i3AvgConsumption          \"Average Consumption [%.1f %unit%]\"           <energy>        (i3)        {channel=\"bmwconnecteddrive:bev_rex:user:i3:lifetime#avg-consumption\" }                                                                           \n+Number:Volume           i3AvgCombined             \"Average Combined Consumption [%.1f %unit%]\"  <oil>           (i3)        {channel=\"bmwconnecteddrive:bev_rex:user:i3:lifetime#avg-combined-consumption\" }                                                                           \n+Number:Energy           i3AvgRecuperation         \"Average Recuperation [%.1f %unit%]\"          <energy>        (i3)        {channel=\"bmwconnecteddrive:bev_rex:user:i3:lifetime#avg-recuperation\" }  \n+\n+Location                i3Location                \"Location  [%s]\"                              <zoom>          (i3)        {channel=\"bmwconnecteddrive:bev_rex:user:i3:location#gps\" }                                                                           \n+Number:Angle            i3Heading                 \"Heading [%.1f %unit%]\"                       <zoom>          (i3)        {channel=\"bmwconnecteddrive:bev_rex:user:i3:location#heading\" }  \n+\n+String                  i3RemoteCommand           \"Command [%s]\"                                <switch>        (i3)        {channel=\"bmwconnecteddrive:bev_rex:user:i3:remote#command\" } \n+String                  i3RemoteState             \"Remote Execution State [%s]\"                 <status>        (i3)        {channel=\"bmwconnecteddrive:bev_rex:user:i3:remote#state\" } \n+\n+String                  i3DriverDoor              \"Driver Door [%s]\"                            <lock>          (i3)        {channel=\"bmwconnecteddrive:bev_rex:user:i3:doors#driver-front\" }\n+String                  i3DriverDoorRear          \"Driver Door Rear [%s]\"                       <lock>          (i3)        {channel=\"bmwconnecteddrive:bev_rex:user:i3:doors#driver-rear\" }\n+String                  i3PassengerDoor           \"Passenger Door [%s]\"                         <lock>          (i3)        {channel=\"bmwconnecteddrive:bev_rex:user:i3:doors#passenger-front\" }\n+String                  i3PassengerDoorRear       \"Passenger Door Rear [%s]\"                    <lock>          (i3)        {channel=\"bmwconnecteddrive:bev_rex:user:i3:doors#passenger-rear\" }\n+String                  i3Hood                    \"Hood [%s]\"                                   <lock>          (i3)        {channel=\"bmwconnecteddrive:bev_rex:user:i3:doors#hood\" }\n+String                  i3Trunk                   \"Trunk [%s]\"                                  <lock>          (i3)        {channel=\"bmwconnecteddrive:bev_rex:user:i3:doors#trunk\" }\n+String                  i3DriverWindow            \"Driver Window [%s]\"                          <lock>          (i3)        {channel=\"bmwconnecteddrive:bev_rex:user:i3:doors#win-driver-front\" }\n+String                  i3DriverWindowRear        \"Driver Window Rear [%s]\"                     <lock>          (i3)        {channel=\"bmwconnecteddrive:bev_rex:user:i3:doors#win-driver-rear\" }\n+String                  i3PassengerWindow         \"Passenger Window [%s]\"                       <lock>          (i3)        {channel=\"bmwconnecteddrive:bev_rex:user:i3:doors#win-passenger-front\" }\n+String                  i3PassengerWindowRear     \"Passenger Window Rear [%s]\"                  <lock>          (i3)        {channel=\"bmwconnecteddrive:bev_rex:user:i3:doors#win-passenger-rear\" }\n+String                  i3RearWindow              \"Rear Window [%s]\"                            <lock>          (i3)        {channel=\"bmwconnecteddrive:bev_rex:user:i3:doors#win-rear\" }\n+String                  i3Sunroof                 \"Sunroof [%s]\"                                <lock>          (i3)        {channel=\"bmwconnecteddrive:bev_rex:user:i3:doors#sunroof\" }\n+\n+String                  i3ServiceName             \"Service Name [%s]\"                           <text>          (i3)        {channel=\"bmwconnecteddrive:bev_rex:user:i3:service#name\" }\n+String                  i3ServiceDetails          \"Service Details [%s]\"                        <text>          (i3)        {channel=\"bmwconnecteddrive:bev_rex:user:i3:service#details\" }\n+Number:Length           i3ServiceMileage          \"Service Mileage [%d %unit%]\"                 <line>          (i3)        {channel=\"bmwconnecteddrive:bev_rex:user:i3:service#mileage\" }\n+DateTime                i3ServiceDate             \"Service Date [%1$tb %1$tY]\"                  <calendar>      (i3)        {channel=\"bmwconnecteddrive:bev_rex:user:i3:service#date\" }\n+\n+String                  i3CCName                  \"CheckControl Name [%s]\"                      <text>          (i3)        {channel=\"bmwconnecteddrive:bev_rex:user:i3:check#name\" }\n+String                  i3CCDetails               \"CheckControl Details [%s]\"                   <text>          (i3)        {channel=\"bmwconnecteddrive:bev_rex:user:i3:check#details\" }\n+Number:Length           i3CCMileage               \"CheckControl Mileage [%d %unit%]\"            <line>          (i3)        {channel=\"bmwconnecteddrive:bev_rex:user:i3:check#mileage\" }\n+\n+String                  i3DestName                \"Destination [%s]\"                            <house>         (i3)        {channel=\"bmwconnecteddrive:bev_rex:user:i3:destination#name\" } \n+Location                i3DestLocation            \"GPS [%s]\"                                    <zoom>          (i3)        {channel=\"bmwconnecteddrive:bev_rex:user:i3:destination#gps\" }                                                                           \n+ \n+Switch                  i3ChargeProfileClimate    \"Charge Profile Climatization\"                <temperature>   (i3)        {channel=\"bmwconnecteddrive:bev_rex:user:i3:charge#profile-climate\" }  \n+String                  i3ChargeProfileMode       \"Charge Profile Mode [%s]\"                    <energy>        (i3)        {channel=\"bmwconnecteddrive:bev_rex:user:i3:charge#profile-mode\" } \n+DateTime                i3ChargeWindowStart       \"Charge Window Start [%1$tH:%1$tM]\"           <time>          (i3)        {channel=\"bmwconnecteddrive:bev_rex:user:i3:charge#window-start\" } \n+Number                  i3ChargeWindowStartHour   \"Charge Window Start Hour [%d]\"               <time>          (i3)        {channel=\"bmwconnecteddrive:bev_rex:user:i3:charge#window-start-hour\" } \n+Number                  i3ChargeWindowStartMinute \"Charge Window Start Minute [%d]\"             <time>          (i3)        {channel=\"bmwconnecteddrive:bev_rex:user:i3:charge#window-start-minute\" } \n+DateTime                i3ChargeWindowEnd         \"Charge Window End [%1$tH:%1$tM]\"             <time>          (i3)        {channel=\"bmwconnecteddrive:bev_rex:user:i3:charge#window-end\" } \n+Number                  i3ChargeWindowEndHour     \"Charge Window End Hour [%d]\"                 <time>          (i3)        {channel=\"bmwconnecteddrive:bev_rex:user:i3:charge#window-end-hour\" } \n+Number                  i3ChargeWindowEndMinute   \"Charge Window End Minute [%d]\"               <time>          (i3)        {channel=\"bmwconnecteddrive:bev_rex:user:i3:charge#window-end-minute\" } \n+DateTime                i3Timer1Departure         \"Timer 1 Departure [%1$tH:%1$tM]\"             <time>          (i3)        {channel=\"bmwconnecteddrive:bev_rex:user:i3:charge#timer1-departure\" } \n+Number                  i3Timer1DepartureHour     \"Timer 1 Departure Hour [%d]\"                 <time>          (i3)        {channel=\"bmwconnecteddrive:bev_rex:user:i3:charge#timer1-departure-hour\" } \n+Number                  i3Timer1DepartureMinute   \"Timer 1 Departure Minute [%d]\"               <time>          (i3)        {channel=\"bmwconnecteddrive:bev_rex:user:i3:charge#timer1-departure-minute\" } \n+String                  i3Timer1Days              \"Timer 1 Days [%s]\"                           <calendar>      (i3)        {channel=\"bmwconnecteddrive:bev_rex:user:i3:charge#timer1-days\" } \n+Switch                  i3Timer1DayMon            \"Timer 1 Monday\"                              <calendar>      (i3)        {channel=\"bmwconnecteddrive:bev_rex:user:i3:charge#timer1-day-mon\" } \n+Switch                  i3Timer1DayTue            \"Timer 1 Tuesday\"                             <calendar>      (i3)        {channel=\"bmwconnecteddrive:bev_rex:user:i3:charge#timer1-day-tue\" } \n+Switch                  i3Timer1DayWed            \"Timer 1 Wednesday\"                           <calendar>      (i3)        {channel=\"bmwconnecteddrive:bev_rex:user:i3:charge#timer1-day-wed\" } \n+Switch                  i3Timer1DayThu            \"Timer 1 Thursday\"                            <calendar>      (i3)        {channel=\"bmwconnecteddrive:bev_rex:user:i3:charge#timer1-day-thu\" } \n+Switch                  i3Timer1DayFri            \"Timer 1 Friday\"                              <calendar>      (i3)        {channel=\"bmwconnecteddrive:bev_rex:user:i3:charge#timer1-day-fri\" } \n+Switch                  i3Timer1DaySat            \"Timer 1 Saturday\"                            <calendar>      (i3)        {channel=\"bmwconnecteddrive:bev_rex:user:i3:charge#timer1-day-sat\" } \n+Switch                  i3Timer1DaySun            \"Timer 1 Sunday\"                              <calendar>      (i3)        {channel=\"bmwconnecteddrive:bev_rex:user:i3:charge#timer1-day-sun\" } \n+Switch                  i3Timer1Enabled           \"Timer 1 Enabled\"                             <switch>        (i3)        {channel=\"bmwconnecteddrive:bev_rex:user:i3:charge#timer1-enabled\" }  \n+DateTime                i3Timer2Departure         \"Timer 2 Departure [%1$tH:%1$tM]\"             <time>          (i3)        {channel=\"bmwconnecteddrive:bev_rex:user:i3:charge#timer2-departure\" } \n+Number                  i3Timer2DepartureHour     \"Timer 2 Departure Hour [%d]\"                 <time>          (i3)        {channel=\"bmwconnecteddrive:bev_rex:user:i3:charge#timer2-departure-hour\" } \n+Number                  i3Timer2DepartureMinute   \"Timer 2 Departure Minute [%d]\"               <time>          (i3)        {channel=\"bmwconnecteddrive:bev_rex:user:i3:charge#timer2-departure-minute\" } \n+String                  i3Timer2Days              \"Timer 2 Days [%s]\"                           <calendar>      (i3)        {channel=\"bmwconnecteddrive:bev_rex:user:i3:charge#timer2-days\" } \n+Switch                  i3Timer2DayMon            \"Timer 2 Monday\"                              <calendar>      (i3)        {channel=\"bmwconnecteddrive:bev_rex:user:i3:charge#timer2-day-mon\" } \n+Switch                  i3Timer2DayTue            \"Timer 2 Tuesday\"                             <calendar>      (i3)        {channel=\"bmwconnecteddrive:bev_rex:user:i3:charge#timer2-day-tue\" } \n+Switch                  i3Timer2DayWed            \"Timer 2 Wednesday\"                           <calendar>      (i3)        {channel=\"bmwconnecteddrive:bev_rex:user:i3:charge#timer2-day-wed\" } \n+Switch                  i3Timer2DayThu            \"Timer 2 Thursday\"                            <calendar>      (i3)        {channel=\"bmwconnecteddrive:bev_rex:user:i3:charge#timer2-day-thu\" } \n+Switch                  i3Timer2DayFri            \"Timer 2 Friday\"                              <calendar>      (i3)        {channel=\"bmwconnecteddrive:bev_rex:user:i3:charge#timer2-day-fri\" } \n+Switch                  i3Timer2DaySat            \"Timer 2 Saturday\"                            <calendar>      (i3)        {channel=\"bmwconnecteddrive:bev_rex:user:i3:charge#timer2-day-sat\" } \n+Switch                  i3Timer2DaySun            \"Timer 2 Sunday\"                              <calendar>      (i3)        {channel=\"bmwconnecteddrive:bev_rex:user:i3:charge#timer2-day-sun\" } \n+Switch                  i3Timer2Enabled           \"Timer 2 Enabled\"                             <switch>        (i3)        {channel=\"bmwconnecteddrive:bev_rex:user:i3:charge#timer2-enabled\" }  \n+DateTime                i3Timer3Departure         \"Timer 3 Departure [%1$tH:%1$tM]\"             <time>          (i3)        {channel=\"bmwconnecteddrive:bev_rex:user:i3:charge#timer3-departure\" } \n+Number                  i3Timer3DepartureHour     \"Timer 3 Departure Hour [%d]\"                 <time>          (i3)        {channel=\"bmwconnecteddrive:bev_rex:user:i3:charge#timer3-departure-hour\" } \n+Number                  i3Timer3DepartureMinute   \"Timer 3 Departure Minute [%d]\"               <time>          (i3)        {channel=\"bmwconnecteddrive:bev_rex:user:i3:charge#timer3-departure-minute\" } \n+String                  i3Timer3Days              \"Timer 3 Days [%s]\"                           <calendar>      (i3)        {channel=\"bmwconnecteddrive:bev_rex:user:i3:charge#timer3-days\" } \n+Switch                  i3Timer3DayMon            \"Timer 3 Monday\"                              <calendar>      (i3)        {channel=\"bmwconnecteddrive:bev_rex:user:i3:charge#timer3-day-mon\" } \n+Switch                  i3Timer3DayTue            \"Timer 3 Tuesday\"                             <calendar>      (i3)        {channel=\"bmwconnecteddrive:bev_rex:user:i3:charge#timer3-day-tue\" } \n+Switch                  i3Timer3DayWed            \"Timer 3 Wednesday\"                           <calendar>      (i3)        {channel=\"bmwconnecteddrive:bev_rex:user:i3:charge#timer3-day-wed\" } \n+Switch                  i3Timer3DayThu            \"Timer 3 Thursday\"                            <calendar>      (i3)        {channel=\"bmwconnecteddrive:bev_rex:user:i3:charge#timer3-day-thu\" } \n+Switch                  i3Timer3DayFri            \"Timer 3 Friday\"                              <calendar>      (i3)        {channel=\"bmwconnecteddrive:bev_rex:user:i3:charge#timer3-day-fri\" } \n+Switch                  i3Timer3DaySat            \"Timer 3 Saturday\"                            <calendar>      (i3)        {channel=\"bmwconnecteddrive:bev_rex:user:i3:charge#timer3-day-sat\" } \n+Switch                  i3Timer3DaySun            \"Timer 3 Sunday\"                              <calendar>      (i3)        {channel=\"bmwconnecteddrive:bev_rex:user:i3:charge#timer3-day-sun\" } \n+Switch                  i3Timer3Enabled           \"Timer 3 Enabled\"                             <switch>        (i3)        {channel=\"bmwconnecteddrive:bev_rex:user:i3:charge#timer3-enabled\" }\n+Switch                  i3OverrideEnabled         \"Override Timer Enabled\"                      <switch>        (i3)        {channel=\"bmwconnecteddrive:bev_rex:user:i3:charge#override-enabled\"}\n+DateTime                i3OverrideDeparture       \"Override Timer Departure [%1$tH:%1$tM]\"      <time>          (i3)        {channel=\"bmwconnecteddrive:bev_rex:user:i3:charge#override-departure\" } \n+Number                  i3OverrideDepartureHour   \"Override Timer Departure Hour [%d]\"          <time>          (i3)        {channel=\"bmwconnecteddrive:bev_rex:user:i3:charge#override-departure-hour\" } \n+Number                  i3OverrideDepartureMinute \"Override Timer Departure Minute [%d]\"        <time>          (i3)        {channel=\"bmwconnecteddrive:bev_rex:user:i3:charge#override-departure-minute\" } \n+\n+Image                   i3Image                   \"Image\"                                                       (i3)        {channel=\"bmwconnecteddrive:bev_rex:user:i3:image#png\" }  \n+String                  i3ImageViewport           \"Image Viewport [%s]\"                         <zoom>          (i3)        {channel=\"bmwconnecteddrive:bev_rex:user:i3:image#view\" }  \n+Number                  i3ImageSize               \"Image Size [%d]\"                             <zoom>          (i3)        {channel=\"bmwconnecteddrive:bev_rex:user:i3:image#size\" }  \n+```\n+\n+### Sitemap File\n+\n+```\n+sitemap BMW label=\"BMW\" {\n+  Frame label=\"BMW i3\" {\n+    Image  item=i3Image  \n+                       \n+  } \n+  Frame label=\"Range\" {\n+    Text    item=i3Mileage           \n+    Text    item=i3Range             \n+    Text    item=i3RangeElectric     \n+    Text    item=i3RangeFuel         \n+    Text    item=i3BatterySoc        \n+    Text    item=i3Fuel              \n+    Text    item=i3RadiusElectric       \n+    Text    item=i3RadiusHybrid         \n+  }\n+  Frame label=\"Status\" {\n+    Text    item=i3DoorStatus           \n+    Text    item=i3WindowStatus         \n+    Text    item=i3LockStatus           \n+    Text    item=i3NextServiceDate              \n+    Text    item=i3NextServiceMileage       \n+    Text    item=i3CheckControl         \n+    Text    item=i3ChargingStatus           \n+    Text    item=i3LastUpdate               \n+  }\n+  Frame label=\"Remote Services\" {\n+    Selection item=i3RemoteCommand              \n+    Text      item=i3RemoteState              \n+  }\n+  Frame label=\"Last Trip\" {\n+    Text    item=i3TripDateTime            \n+    Text    item=i3TripDuration            \n+    Text    item=i3TripDistance            \n+    Text    item=i3TripDistanceSinceCharge \n+    Text    item=i3AvgTripConsumption      \n+    Text    item=i3AvgTripRecuperation     \n+    Text    item=i3AvgTripCombined     \n+  }\n+  Frame label=\"Lifetime\" {\n+    Text    item=i3TotalElectric  \n+    Text    item=i3LongestEVTrip      \n+    Text    item=i3AvgConsumption     \n+    Text    item=i3AvgRecuperation          \n+    Text    item=i3AvgCombined          \n+  }\n+  Frame label=\"Services\" {\n+    Text    item=i3ServiceName          \n+    Text    item=i3ServiceMileage          \n+    Text    item=i3ServiceDate          \n+  }\n+  Frame label=\"CheckControl\" {\n+    Text    item=i3CCName          \n+    Text    item=i3CCMileage          \n+  }\n+  Frame label=\"Door Details\" {\n+    Text    item=i3DriverDoor visibility=[i3DriverDoor!=\"INVALID\"]\n+    Text    item=i3DriverDoorRear visibility=[i3DriverDoorRear!=\"INVALID\"]  \n+    Text    item=i3PassengerDoor visibility=[i3PassengerDoor!=\"INVALID\"]\n+    Text    item=i3PassengerDoorRear visibility=[i3PassengerDoorRear!=\"INVALID\"]\n+    Text    item=i3Hood visibility=[i3Hood!=\"INVALID\"]\n+    Text    item=i3Trunk visibility=[i3Trunk!=\"INVALID\"]\n+    Text    item=i3DriverWindow visibility=[i3DriverWindow!=\"INVALID\"]\n+    Text    item=i3DriverWindowRear visibility=[i3DriverWindowRear!=\"INVALID\"]\n+    Text    item=i3PassengerWindow visibility=[i3PassengerWindow!=\"INVALID\"]\n+    Text    item=i3PassengerWindowRear visibility=[i3PassengerWindowRear!=\"INVALID\"]\n+    Text    item=i3RearWindow visibility=[i3RearWindow!=\"INVALID\"]\n+    Text    item=i3Sunroof visibility=[i3Sunroof!=\"INVALID\"]\n+  }\n+  Frame label=\"Location\" {\n+    Text    item=i3Location          \n+    Text    item=i3Heading             \n+  }\n+  Frame label=\"Charge Profile\" {    \n+    Switch    item=i3ChargeProfileClimate     \n+    Selection item=i3ChargeProfileMode        \n+    Text      item=i3ChargeWindowStart        \n+    Setpoint  item=i3ChargeWindowStartHour maxValue=23 step=1 icon=\"time\"\n+    Setpoint  item=i3ChargeWindowStartMinute maxValue=55 step=5 icon=\"time\"\n+    Text      item=i3ChargeWindowEnd          \n+    Setpoint  item=i3ChargeWindowEndHour maxValue=23 step=1 icon=\"time\"\n+    Setpoint  item=i3ChargeWindowEndMinute maxValue=55 step=5 icon=\"time\"\n+    Text      item=i3Timer1Departure          \n+    Setpoint  item=i3Timer1DepartureHour maxValue=23 step=1 icon=\"time\"\n+    Setpoint  item=i3Timer1DepartureMinute maxValue=55 step=5 icon=\"time\"\n+    Text      item=i3Timer1Days               \n+    Switch    item=i3Timer1DayMon            \n+    Switch    item=i3Timer1DayTue            \n+    Switch    item=i3Timer1DayWed            \n+    Switch    item=i3Timer1DayThu            \n+    Switch    item=i3Timer1DayFri            \n+    Switch    item=i3Timer1DaySat            \n+    Switch    item=i3Timer1DaySun            \n+    Switch    item=i3Timer1Enabled            \n+    Text      item=i3Timer2Departure          \n+    Setpoint  item=i3Timer2DepartureHour maxValue=23 step=1 icon=\"time\"\n+    Setpoint  item=i3Timer2DepartureMinute maxValue=55 step=5 icon=\"time\"\n+    Text      item=i3Timer2Days               \n+    Switch    item=i3Timer2DayMon            \n+    Switch    item=i3Timer2DayTue            \n+    Switch    item=i3Timer2DayWed            \n+    Switch    item=i3Timer2DayThu            \n+    Switch    item=i3Timer2DayFri            \n+    Switch    item=i3Timer2DaySat            \n+    Switch    item=i3Timer2DaySun            \n+    Switch    item=i3Timer2Enabled            \n+    Text      item=i3Timer3Departure          \n+    Setpoint  item=i3Timer3DepartureHour maxValue=23 step=1 icon=\"time\"\n+    Setpoint  item=i3Timer3DepartureMinute maxValue=55 step=5 icon=\"time\"\n+    Text      item=i3Timer3Days               \n+    Switch    item=i3Timer3DayMon            \n+    Switch    item=i3Timer3DayTue            \n+    Switch    item=i3Timer3DayWed            \n+    Switch    item=i3Timer3DayThu            \n+    Switch    item=i3Timer3DayFri            \n+    Switch    item=i3Timer3DaySat            \n+    Switch    item=i3Timer3DaySun            \n+    Switch    item=i3Timer3Enabled            \n+    Switch    item=i3OverrideEnabled            \n+    Text      item=i3OverrideDeparture          \n+    Setpoint  item=i3OverrideDepartureHour maxValue=23 step=1 icon=\"time\"\n+    Setpoint  item=i3OverrideDepartureMinute maxValue=55 step=5 icon=\"time\"\n+  } \n+  Frame label=\"Last Destinations\" {    \n+    Text  item=i3DestName                 \n+    Text  item=i3DestLocation                                                                                   \n+  }  \n+  Frame label=\"Image Properties\" {\n+    Text    item=i3ImageViewport\n+    Text    item=i3ImageSize \n+  } \n+}\n+```\n+\n+### Action example\n+\n+```\n+  val profile = getActions(\"chargeprofile\", \"bmwconnecteddrive:bev_rex:user:i3\")\n+  val now = ZonedDateTime.now.toLocalTime\n+  profile.setChargingMode(\"DELAYED_CHARGING\")\n+  profile.setTimer1Departure(now.minusHours(2))\n+  profile.setTimer1Days(java.util.Set())\n+  profile.setTimer1Enabled(true)\n+  profile.setTimer2Enabled(false)\n+  profile.setTimer3Enabled(false)\n+  profile.setPreferredWindowStart(now.minusHours(6))\n+  profile.setPreferredWindowEnd(now.minusHours(2))\n+  profile.send()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "48af48c82562d006b6f2aa35922270f181c885ed"}, "originalPosition": 842}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5ODI3Mjc5MA==", "bodyText": "Sending a command including delivery to the car takes significant time - 30 seconds is not unusual. In addition to this there is no way to send individual properties of the charging profile, they can only be sent all at once. To ensure that parallel access will not result in a mixture of edits each actions instance does work on it's own copy of the current charging-profile. The global state of the thing is updated when the command is sent and delivery is confirmed by the api.\nOf course there still is a race-condition as other rules or users do not see a parallel edit unless it is confirmed as delivered. To avoid such races that the binding would have to implement locking internal state but I don't think that is the right way to go as there is no common agreement on how that should behave. How shall that 'channel is locked'-state made visible to the user and rules? Introduce more channels for that? I think if avoidance of race-conditions caused by parallel edits were a formal requirement there should be some locking-concept in the OH-basis in the first place.", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r598272790", "createdAt": "2021-03-21T12:36:15Z", "author": {"login": "ntruchsess"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/README.md", "diffHunk": "@@ -0,0 +1,849 @@\n+# BMW ConnectedDrive Binding\n+\n+<img align=\"right\" src=\"./doc/bmw-connected.png\" width=\"150\" height=\"150\"/>\n+\n+The binding provides a connection between [BMW's ConnectedDrive Portal](https://www.bmw-connecteddrive.com/country-region-select/country-region-selection.html) and openHAB.\n+All vehicles connected to an account will be detected by the discovery with the correct type \n+\n+* Conventional Fuel Vehicle\n+* Plugin-Hybrid Electrical Vehicle \n+* Battery Electric Vehicle with Range Extender\n+* Battery Electric Vehicle \n+\n+In addition properties are attached with information and services provided by this vehicle.\n+The provided data depends on \n+\n+1. the [Thing Type](#things) and \n+2. the [Properties](#properties) mentioned in Services\n+\n+Different channel groups are clustering all informations.\n+Check for each group if it's supported for this Vehicle.\n+\n+Please note **this isn't a real-time binding**. \n+If a door is opened the state isn't transmitted and changed immediately. \n+This isn't a flaw in the binding itself because the state in BMW's own ConnectedDrive App is also updated with some delay. \n+\n+## Supported Things\n+\n+### Bridge\n+\n+The bridge establishes the connection between BMW's ConnectedDrive Portal and openHAB.\n+\n+| Name                       | Bridge Type ID | Description                                                |\n+|----------------------------|----------------|------------------------------------------------------------|\n+| BMW ConnectedDrive Account | account        | Access to BMW ConnectedDrive Portal for a specific user    |\n+\n+\n+### Things\n+\n+Four different vehicle types are provided. \n+They differ in the supported channel groups & channels. \n+Conventional Fuel Vehicles have no _Charging Profile_, Electric Vehicles don't provide a _Fuel Range_. \n+For hybrid vehicles in addition to _Fuel and Electric Range_ the _Hybrid Range_ is shown.\n+ \n+| Name                                | Thing Type ID | Supported Channel Groups                               |\n+|-------------------------------------|---------------|--------------------------------------------------------|\n+| BMW Electric Vehicle                | bev           | status, range, location, service, check, charge, image |\n+| BMW Electric Vehicle with REX       | bev_rex       | status, range, location, service, check, charge, image |\n+| BMW Plug-In-Hybrid Electric Vehicle | phev          | status, range, location, service, check, charge, image |\n+| BMW Conventional Vehicle            | conv          | status, range, location, service, check, image         |\n+\n+ \n+#### Properties\n+\n+<img align=\"right\" src=\"./doc/properties.png\" width=\"500\" height=\"225\"/>\n+\n+For each vehicle properties are available. \n+Basically 3 types of information are registered as properties\n+\n+* Informations regarding your dealer with address and phone number\n+* Which services are available / not available\n+* Vehicle properties like color, model type, drive train and construction year\n+\n+In the right picture can see in *Services Activated* e.g. the *DoorLock* and *DoorUnlock* services are mentioned. \n+This ensures channel group [Remote Services](#remote-services) is supporting door lock and unlock remote control.\n+\n+In  *Services Supported* the entry *LastDestination* is mentioned.\n+So it's valid to connect channel group [Last Destinations](#destinations) in order to display and select the last navigation destinations.\n+\n+| Property Key       | Property Value      |  Supported Channel Groups    |\n+|--------------------|---------------------|------------------------------|\n+| servicesSupported  | Statistics          | last-trip, lifetime          |\n+| servicesSupported  | LastDestinations    | destinations                 |\n+| servicesActivated  | _list of services_  | remote                       |\n+\n+\n+## Discovery\n+\n+Auto discovery is starting after the bridge towards BMW's ConnectedDrive is created. \n+A list of your registered vehicles is queried and all found things are added in the inbox.\n+Unique identifier is the *Vehicle Identification Number* (VIN). \n+If a thing is already declared in a  _.things_ configuration, discovery won't highlight it again.\n+Properties will be attached to predefined vehicles if the VIN is matching.\n+\n+## Configuration\n+\n+### Bridge Configuration\n+\n+| Parameter       | Type    | Description                                                        |           \n+|-----------------|---------|--------------------------------------------------------------------|\n+| userName        | text    | BMW ConnectedDrive Username                                       |\n+| password        | text    | BMW ConnectedDrive Password                                       |\n+| region          | text    | Select region in order to connect to the appropriate BMW server.   |\n+\n+The region Configuration has 3 different options\n+\n+* _NORTH_AMERICA_\n+* _CHINA_\n+* _ROW_  (Rest of World)\n+\n+### Thing Configuration\n+\n+Same configuration is needed for all things\n+\n+| Parameter       | Type    | Description                           |           \n+|-----------------|---------|---------------------------------------|\n+| vin             | text    | Vehicle Identification Number (VIN)   |\n+| refreshInterval | integer | Refresh Interval in Minutes           |\n+| units           | text    | Unit Selection. See below.            |\n+| imageSize       | integer | Image Size                            |\n+| imageViewport   | text    | Image Viewport                        |\n+\n+The unit configuration has 3 options\n+\n+* _AUTODETECT_ selects miles for US & UK, kilometer otherwise\n+* _METRIC_ selects directly kilometers\n+* _IMPERIAL_ selects directly miles\n+\n+The _imageVieport_ allows to show the vehicle from different angels.\n+Possible options are \n+\n+* _FRONT_\n+* _REAR_\n+* _SIDE_\n+* _DASHBOARD_\n+* _DRIVERDOOR_\n+\n+## Channels\n+\n+There are many channels available for each vehicle. \n+For better overview they are clustered in different channel groups.\n+They differ for each vehicle type, build-in sensors and activated services.\n+\n+\n+### Thing Channel Groups \n+\n+#### Vehicle Status\n+\n+Reflects overall status of the vehicle.\n+\n+* Channel Group ID is **status**\n+* Available for all vehicles\n+* Read-only values\n+\n+| Channel Label             | Channel ID          | Type          | Description                                    |\n+|---------------------------|---------------------|---------------|------------------------------------------------|\n+| Overall Door Status       | doors               | String        | Combined status for all doors                  |\n+| Overall Window Status     | windows             | String        | Combined status for all windows                |\n+| Doors Locked              | lock                | String        | Status if doors are locked or unlocked         |\n+| Next Service Date         | service-date        | DateTime      | Date of upcoming service                       |\n+| Mileage till Next Service | service-mileage     | Number:Length | Mileage till upcoming service                  |\n+| Check Control             | check-control       | String        | Presence of active warning messages            |\n+| Charging Status           | charge              | String        | Only available for phev, bev_rex and bev       |\n+| Last Status Timestamp     | last-update         | DateTime      | Date and time of last status update            |\n+\n+Overall Door Status values\n+\n+* _Closed_ - all doors closed\n+* _Open_ - at least one door is open\n+* _Undef_ - no door data delivered at all\n+\n+Overall Windows Status values\n+\n+* _Closed_ - all windows closed\n+* _Open_ - at least one window is completely open\n+* _Intermediate_ - at least one window is partially open\n+* _Undef_ - no window data delivered at all\n+\n+Check Control values\n+\n+* _Active_ - at least one warning message is active\n+* _Not Active_ - no warning message is active\n+* _Undef_ - no data for warnings delivered\n+\n+Charging Status values\n+\n+* _Charging_\n+* _Error_\n+* _Finished Fully Charged_\n+* _Finished Not Full_\n+* _Invalid_\n+* _Not Charging_\n+* _Charging Goal reached_\n+* _Waiting For Charging_\n+\n+#### Services\n+\n+Group for all upcoming services with description, service date and/or service mileage.\n+If more than one service is scheduled in the future the channel _name_ contains all future services as options.\n+\n+* Channel Group ID is **service**\n+* Available for all vehicles\n+* Read/Write access\n+\n+| Channel Label                  | Channel ID          | Type           | Access     |\n+|--------------------------------|---------------------|----------------|------------|\n+| Service Name                   | name                | String         | Read/Write |\n+| Service Details                | details             | String         | Read       |\n+| Service Date                   | date                | Number         | Read       |\n+| Mileage till Service           | mileage             | Number:Length  | Read       |\n+\n+#### Check Control\n+\n+Group for all current active CheckControl messages.\n+If more than one message is active the channel _name_ contains all active messages as options.\n+\n+* Channel Group ID is **check**\n+* Available for all vehicles\n+* Read/Write access\n+\n+| Channel Label                   | Channel ID          | Type           | Access     |\n+|---------------------------------|---------------------|----------------|------------|\n+| CheckControl Description        | name                | String         | Read/Write |\n+| CheckControl Details            | details             | String         | Read       |\n+| Mileage Occurrence              | mileage             | Number:Length  | Read       |\n+\n+#### Doors Details\n+\n+Detailed status of all doors and windows.\n+\n+* Channel Group ID is **doors**\n+* Available for all vehicles if corresponding sensors are built-in \n+* Read-only values\n+ \n+| Channel Label              | Channel ID              | Type          | \n+|----------------------------|-------------------------|---------------|\n+| Driver Door                | driver-front            | String        |\n+| Driver Door Rear           | driver-rear             | String        |\n+| Passenger Door             | passenger-front         | String        |\n+| Passenger Door Rear        | passenger-rear          | String        |\n+| Trunk                      | trunk                   | String        |\n+| Hood                       | hood                    | String        |\n+| Driver Window              | win-driver-front        | String        |\n+| Driver Rear Window         | win-driver-rear         | String        |\n+| Passenger Window           | win-passenger-front     | String        |\n+| Passenger Rear Window      | win-passenger-rear      | String        |\n+| Rear Window                | win-rear                | String        |\n+| Sunroof                    | sunroof                 | String        |\n+\n+Possible states\n+\n+* _Undef_ - no status data available\n+* _Invalid_ - this door / window isn't applicable for this vehicle\n+* _Closed_ - the door / window is closed\n+* _Open_ - the door / window is open\n+* _Intermediate_ - window in intermediate position, not applicable for doors\n+\n+#### Range Data\n+\n+Based on vehicle type some channels are present or not. \n+Conventional fuel vehicles don't provide *Electric Range* and battery electric vehicles don't show *Fuel Range*.\n+Hybrid vehicles have both and in addition *Hybrid Range*.\n+See description [Range vs Range Radius](#range-vs-range-radius) to get more information.\n+\n+* Channel Group ID is **range**\n+* Availability according to table\n+* Read-only values\n+\n+| Channel Label         | Channel ID            | Type                 | conv | phev | bev_rex | bev |\n+|-----------------------|-----------------------|----------------------|------|------|---------|-----|\n+| Mileage               | mileage               | Number:Length        |  X   |  X   |    X    |  X  |\n+| Fuel Range            | range-fuel            | Number:Length        |  X   |  X   |    X    |     |\n+| Battery Range         | range-electric        | Number:Length        |      |  X   |    X    |  X  | \n+| Hybrid Range          | range-hybrid          | Number:Length        |      |  X   |    X    |     | \n+| Battery Charge Level  | soc                   | Number:Dimensionless |      |  X   |    X    |  X  |\n+| Remaining Fuel        | remaining-fuel        | Number:Volume        |  X   |  X   |    X    |     | \n+| Fuel Range Radius     | range-radius-fuel     | Number:Length        |  X   |  X   |    X    |     | \n+| Electric Range Radius | range-radius-electric | Number:Length        |      |  X   |    X    |  X  | \n+| Hybrid Range Radius   | range-radius-hybrid   | Number:Length        |      |  X   |    X    |     | \n+\n+\n+#### Charge Profile\n+\n+Charging options with date and time for preferred time windows and charging modes.\n+\n+* Channel Group ID is **charge**\n+* Available for electric and hybrid vehicles\n+* Read/Write access for UI. Use [Charge Profile Actions](#charge-profile-action) in rules\n+* There are 3 timers available. Replace *X* with number 1,2 or 3 to target the correct timer\n+\n+| Channel Label                         | Channel Group ID | Channel ID                | Type     | \n+|---------------------------------------|------------------|---------------------------|----------| \n+| Charging Mode for Profile             | charge           | profile-mode              | String   | \n+| Charging Preferences for Profile      | charge           | profile-prefs             | String   | \n+| Charging Window Start Time            | charge           | window-start              | DateTime | \n+| Charging Window Start Time Hour       | charge           | window-start-hour         | Number   | \n+| Charging Window Start Time Minute     | charge           | window-start-minute       | Number   | \n+| Charging Window End Time              | charge           | window-end                | DateTime | \n+| Charging Window End Time Hour         | charge           | window-end-hour           | Number   | \n+| Charging Window End Time Minute       | charge           | window-end-minute         | Number   | \n+| Air Conditioning at Departure Time    | charge           | profile-climate           | Switch   | \n+| Timer *X*: Enabled                    | charge           | timer*X*-enabled          | Switch   | \n+| Timer *X*: Departure Time             | charge           | timer*X*-departure        | DateTime | \n+| Timer *X*: Departure Time Hour        | charge           | timer*X*-departure-hour   | Number   | \n+| Timer *X*: Departure Time Minute      | charge           | timer*X*-departure-minute | Number   | \n+| Timer *X*: Monday                     | charge           | timer*X*-day-mon          | Switch   | \n+| Timer *X*: Tuesday                    | charge           | timer*X*-day-tue          | Switch   | \n+| Timer *X*: Wednesday                  | charge           | timer*X*-day-wed          | Switch   | \n+| Timer *X*: Thursday                   | charge           | timer*X*-day-thu          | Switch   | \n+| Timer *X*: Friday                     | charge           | timer*X*-day-fri          | Switch   | \n+| Timer *X*: Saturday                   | charge           | timer*X*-day-sat          | Switch   | \n+| Timer *X*: Sunday                     | charge           | timer*X*-day-sun          | Switch   | \n+| Override Timer: Enabled               | charge           | override-enabled          | Switch   | \n+| Override Timer: Departure Time        | charge           | override-departure        | DateTime | \n+| Override Timer: Departure Time Hour   | charge           | override-departure-hour   | Number   | \n+| Override Timer: Departure Time Minute | charge           | override-departure-minute | Number   | \n+\n+The channel _profile-mode_ supports\n+\n+* *IMMEDIATE_CHARGING*\n+* *DELAYED_CHARGING*\n+\n+The channel _profile-prefs_ supports\n+\n+* *NO_PRESELECTION*\n+* *CHARGING_WINDOW*\n+\n+#### Location\n+\n+GPS location and heading of the vehicle.\n+\n+* Channel Group ID is **location**\n+* Available for all vehicles with built-in GPS sensor. Function can be enabled/disabled in the head unit\n+* Read-only values\n+\n+| Channel Label   | Channel ID          | Type         | \n+|-----------------|---------------------|--------------|\n+| GPS Coordinates | gps                 | Location     | \n+| Heading         | heading             | Number:Angle | \n+\n+#### Last Trip\n+\n+Statistic values of duration, distance and consumption of the last trip.\n+\n+* Channel Group ID is **last-trip**\n+* Available if *Statistics* is present in *Services Supported*. See [Vehicle Properties](#properties) for further details\n+* Read-only values\n+* Depending on units configuration in [Thing Configuration](#thing-configuration) average values are given for 100 kilometers or miles\n+\n+| Channel Label                           | Channel ID                   | Type          |\n+|-----------------------------------------|------------------------------|---------------|\n+| Last Trip Date                          | date                         | DateTime      |\n+| Last Trip Duration                      | duration                     | Number:Time   |\n+| Last Trip Distance                      | distance                     | Number:Length |\n+| Distance since Charge                   | distance-since-charging      | Number:Length |\n+| Avg. Power Consumption                  | avg-consumption              | Number:Power  |\n+| Avg. Power Recuperation                 | avg-recuperation             | Number:Power  |\n+| Avg. Combined Consumption               | avg-combined-consumption     | Number:Volume |\n+\n+\n+#### Lifetime Statistics\n+\n+Providing lifetime consumption values.\n+\n+* Channel Group ID is **lifetime**\n+* Available if *Statistics* is present in *Services Supported*. See [Vehicle Properties](#properties) for further details\n+* Read-only values\n+* Depending on units configuration in [Thing Configuration](#thing-configuration) average values are given for 100 kilometers or miles\n+\n+| Channel Label                           | Channel ID                   | Type          | \n+|-----------------------------------------|------------------------------|---------------|\n+| Total Electric Distance                 | total-driven-distance        | Number:Length |\n+| Longest 1-Charge Distance               | single-longest-distance      | Number:Length |\n+| Avg. Power Consumption                  | avg-consumption              | Number:Power  |\n+| Avg. Power Recuperation                 | avg-recuperation             | Number:Power  |\n+| Avg. Combined Consumption               | avg-combined-consumption     | Number:Volume |\n+\n+\n+#### Remote Services\n+\n+Remote control of the vehicle. \n+Send a *command* to the vehicle and the *state* is reporting the execution progress.\n+Only one command can be executed each time.\n+Parallel execution isn't supported.\n+\n+* Channel Group ID is **remote**\n+* Available for all commands mentioned in *Services Activated*. See [Vehicle Properties](#properties) for further details\n+* Read/Write access\n+\n+\n+| Channel Label           | Channel ID          | Type    | Access |\n+|-------------------------|---------------------|---------|--------|\n+| Remote Service Command  | command             | String  | Write  |\n+| Service Execution State | state               | String  | Read   |\n+\n+The channel _command_ provides options\n+\n+* _Flash Lights_\n+* _Vehicle Finder_\n+* _Door Lock_\n+* _Door Unlock_\n+* _Horn Blow_\n+* _Climate Control_\n+* _Start Charging_\n+* _Send Charging Profile_\n+\n+The channel _state_ shows the progress of the command execution in the following order\n+\n+1) _Initiated_ \n+2) _Pending_\n+3) _Delivered_\n+4) _Executed_\n+\n+#### Destinations\n+\n+Shows the last destinations stored in the navigation system.\n+If several last destinations are stored in the navigation system the channel _name_ contains all addresses as options.\n+\n+* Channel Group ID is **destination**\n+* Available if *LastDestinations* is present in *Services Supported*. Check [Vehicle Properties](#properties) for further details\n+* Read/Write access\n+\n+\n+| Channel Label        | Channel ID    | Type      | Access      |\n+|----------------------|---------------|-----------|-------------|\n+| Name                 | name          | String    | Read/Write  |\n+| GPS Coordinates      | gps           | Location  | Read        |\n+\n+\n+\n+#### Image\n+\n+Image representation of the vehicle. Size and viewport are writable and can be \n+The possible values are the same mentioned in [Thing Configuration](#thing-configuration).\n+\n+* Channel Group ID is **image**\n+* Available for all vehicles\n+* Read/Write access\n+\n+| Channel Label              | Channel ID          | Type   |  Access  |\n+|----------------------------|---------------------|--------|----------|\n+| Rendered Vehicle Image     | png                 | Image  | Read     |\n+| Image Viewport             | view                | String | Write    |\n+| Image Picture Size         | size                | Number | Write    |\n+\n+## Rule Actions\n+\n+## Charge Profile Action\n+\n+The Charge Profile is accessible and modifiable in rules via action. \n+Get the corresponding action from your car using the Thing ID\n+\n+* bmwconnecteddrive - Binding ID, don't change!\n+* bev_rex - [Thing UID](#things) of your car\n+* user - Thing ID of the [Bridge](#bridge)\n+* i3 - Thing ID of your car\n+\n+```\n+  val profile = getActions(\"chargeprofile\", \"bmwconnecteddrive:bev_rex:user:i3\")\n+```\n+\n+Like in the Charge Profile Channels 3 Timers are provided. Replace *X* with 1, 2 or 3 to address the right timer.\n+\n+| Function                              | Parameters       | Returns                   | Description                                                | \n+|---------------------------------------|------------------|---------------------------|------------------------------------------------------------| \n+| getClimatizationEnabled               | void             | Boolean                   | Returns the enabled state of climatization                 | \n+| setClimatizationEnabled               | Boolean          | void                      | Sets the enabled state of climatization                    | \n+| getChargingMode                       | void             | String                    | Gets the charging-mode, see valid options below            | \n+| setChargingMode                       | String           | void                      | Sets the charging-mode, see valid options below            | \n+| getPreferredWindowStart               | void             | LocalTime                 | Returns the preferred charging-window start time           | \n+| setPreferredWindowStart               | LocalTime        | void                      | Sets the preferred charging-window start time              | \n+| getPreferredWindowEnd                 | void             | LocalTime                 | Returns the preferred charging-window end time             | \n+| setPreferredWindowEnd                 | LocalTime        | void                      | Sets the preferred charging-window end time                | \n+| getTimer*X*Enabled                    | void             | Boolean                   | Returns the enabled state of timer*X*                      | \n+| setTimer*X*Enabled                    | Boolean          | void                      | Returns the enabled state of timer*X*                      | \n+| getTimer*X*Departure                  | void             | LocalTime                 | Returns the departure time of timer*X*                     | \n+| setTimer*X*Departure                  | LocalTime        | void                      | Sets the timer*X* departure time                           | \n+| getTimer*X*Days                       | void             | Set<DayOfWeek>            | Returns the days of week timer*X* is enabled for           | \n+| setTimer*X*Days                       | Set<DayOfWeek>   | void                      | sets the days of week timer*X* is enabled for              | \n+| getOverrideTimerEnabled               | void             | Boolean                   | Returns the enabled state of override timer                | \n+| setOverrideTimerEnabled               | Boolean          | void                      | Sets the enabled state of override timer                   | \n+| getOverrideTimerDeparture             | void             | LocalTime                 | Returns the departure time of override timer               | \n+| setOverrideTimerDeparture             | LocalTime        | void                      | Sets the override timer departure time                     | \n+| getOverrideTimerDays                  | void             | Set<DayOfWeek>            | Returns the days of week the overrideTimer is enabled for  | \n+| setOverrideTimerDays                  | Set<DayOfWeek>   | void                      | Sets the days of week the overrideTimer is enabled for     | \n+| cancel                                | void             | void                      | Sends the charging profile to the vehicle                  | \n+| send                                  | void             | void                      | Cancel current edit of charging profile                    | \n+\n+Values for valid charging mode get/set\n+\n+* *IMMEDIATE_CHARGING*\n+* *DELAYED_CHARGING*\n+\n+\n+## Further Descriptions\n+\n+### Dynamic Data\n+\n+<img align=\"right\" src=\"./doc/ServiceOptions.png\" width=\"400\" height=\"350\"/>\n+\n+There are 3 occurrences of dynamic data delivered\n+\n+* Upcoming Services delivered in group [Services](#services)\n+* Check Control Messages delivered in group [Check Control](#check-control)\n+* Last Destinations delivered in group [Destinations](#destinations)\n+\n+The channel id _name_ shows the first element as default. \n+All other possibilities are attached as options. \n+The picture on the right shows the _Service Name_ item and all four possible options. \n+Select the desired service and the corresponding _Service Date & Milage_ will be shown.  \n+\n+### TroubleShooting\n+\n+BMW has a high range of vehicles supported by ConnectedDrive.\n+In case of any issues with this binding help to resolve it! \n+Please perform the following steps:\n+\n+* Can you [log into ConnectedDrive](https://www.bmw-connecteddrive.com/country-region-select/country-region-selection.html) with your credentials? Please note this isn't the BMW Customer portal - it's the ConnectedDrive portal\n+* Is the vehicle listed in your account? There's a one-to-one relation from user to vehicle\n+\n+If the access to the portal is working and the vehicle is listed some debug data is needed in order to identify the issue. \n+\n+#### Generate Debug Fingerprint\n+\n+If you checked the above pre-conditions you need to get the debug fingerprint from the logs.\n+First [enable debug logging](https://www.openhab.org/docs/administration/logging.html#defining-what-to-log) for the binding.\n+\n+```\n+log:set DEBUG org.openhab.binding.bmwconnecteddrive\n+```\n+\n+The debug fingerprint is generated immediately after the vehicle thing is initialized the first time, e.g. after openHAB startup. \n+To force a new fingerprint disable the thing shortly and enable it again. \n+Personal data is eliminated from the log entries so it should be possible to share them in public.\n+Data like\n+\n+* Dealer Properties\n+* Vehicle Identification Number (VIN)\n+* Location latitude / longitude \n+\n+are anonymized.\n+You'll find the fingerprint in the logs with the command\n+\n+```\n+grep \"BMW ConnectedDrive Binding\" openhab.log\n+```\n+\n+After the corresponding fingerprint is generated please [follow the instructions to raise an issue](https://community.openhab.org/t/how-to-file-an-issue/68464) and attach the fingerprint data!\n+Your feedback is highly appreciated!\n+\n+\n+### Range vs Range Radius\n+\n+<img align=\"right\" src=\"./doc/range-radius.png\" width=\"400\" height=\"350\"/>\n+\n+You will observe differences in the vehicle range and range radius values. \n+While range is indicating the possible distance to be driven on roads the range radius indicates the reachable range on the map.\n+\n+The right picture shows the distance between Kassel and Frankfurt in Germany. \n+While the air-line distance is ~145 kilometer the route distance is ~192 kilometer.\n+So range value is the normal remaining range while the range radius values can be used e.g. on [Mapview](https://www.openhab.org/docs/configuration/sitemaps.html#element-type-mapview) to indicate the reachable range on map.\n+Please note this is just an indicator of the effective range.\n+Especially for electric vehicles it depends on many factors like driving style and usage of electric consumers. \n+\n+## Full Example\n+\n+The example is based on a BMW i3 with range extender (REX). \n+Exchange the three configuration parameters in the Things section\n+\n+* YOUR_USERNAME - with your ConnectedDrive login username\n+* YOUR_PASSWORD - with your ConnectedDrive password credentials\n+* VEHICLE_VIN - the vehicle identification number\n+\n+In addition search for all occurrences of *i3* and replace it with your Vehicle Identification like *x3* or *535d* and you're ready to go!\n+\n+### Things File\n+\n+```\n+Bridge bmwconnecteddrive:account:user   \"BMW ConnectedDrive Account\" [userName=\"YOUR_USERNAME\",password=\"YOUR_PASSWORD\",region=\"ROW\"] {\n+         Thing bev_rex i3       \"BMW i3 94h REX\"                [ vin=\"VEHICLE_VIN\",units=\"AUTODETECT\",imageSize=600,imageViewport=\"FRONT\",refreshInterval=5]\n+}\n+```\n+\n+### Items File\n+\n+```\n+Number:Length           i3Mileage                 \"Odometer [%d %unit%]\"                        <line>          (i3)        {channel=\"bmwconnecteddrive:bev_rex:user:i3:range#mileage\" }                                                                           \n+Number:Length           i3Range                   \"Range [%d %unit%]\"                           <motion>        (i3)        {channel=\"bmwconnecteddrive:bev_rex:user:i3:range#hybrid\"}\n+Number:Length           i3RangeElectric           \"Electric Range [%d %unit%]\"                  <motion>        (i3,long)   {channel=\"bmwconnecteddrive:bev_rex:user:i3:range#electric\"}   \n+Number:Length           i3RangeFuel               \"Fuel Range [%d %unit%]\"                      <motion>        (i3)        {channel=\"bmwconnecteddrive:bev_rex:user:i3:range#fuel\"}\n+Number:Dimensionless    i3BatterySoc              \"Battery Charge [%.1f %%]\"                    <battery>       (i3,long)   {channel=\"bmwconnecteddrive:bev_rex:user:i3:range#soc\"}\n+Number:Volume           i3Fuel                    \"Fuel [%.1f %unit%]\"                          <oil>           (i3)        {channel=\"bmwconnecteddrive:bev_rex:user:i3:range#remaining-fuel\"}\n+Number:Length           i3RadiusElectric          \"Electric Radius [%d %unit%]\"                 <zoom>          (i3)        {channel=\"bmwconnecteddrive:bev_rex:user:i3:range#radius-electric\" }\n+Number:Length           i3RadiusHybrid            \"Hybrid Radius [%d %unit%]\"                   <zoom>          (i3)        {channel=\"bmwconnecteddrive:bev_rex:user:i3:range#radius-hybrid\" }\n+\n+String                  i3DoorStatus              \"Door Status [%s]\"                            <lock>          (i3)        {channel=\"bmwconnecteddrive:bev_rex:user:i3:status#doors\" }\n+String                  i3WindowStatus            \"Window Status [%s]\"                          <lock>          (i3)        {channel=\"bmwconnecteddrive:bev_rex:user:i3:status#windows\" }\n+String                  i3LockStatus              \"Lock Status [%s]\"                            <lock>          (i3)        {channel=\"bmwconnecteddrive:bev_rex:user:i3:status#lock\" }\n+DateTime                i3NextServiceDate         \"Next Service Date [%1$tb %1$tY]\"             <calendar>      (i3)        {channel=\"bmwconnecteddrive:bev_rex:user:i3:status#service-date\" }\n+String                  i3NextServiceMileage      \"Next Service Mileage [%d %unit%]\"            <line>          (i3)        {channel=\"bmwconnecteddrive:bev_rex:user:i3:status#service-mileage\" }\n+String                  i3CheckControl            \"Check Control [%s]\"                          <error>         (i3)        {channel=\"bmwconnecteddrive:bev_rex:user:i3:status#check-control\" }\n+String                  i3ChargingStatus          \"Charging [%s]\"                               <energy>        (i3)        {channel=\"bmwconnecteddrive:bev_rex:user:i3:status#charge\" } \n+DateTime                i3LastUpdate              \"Update [%1$tA, %1$td.%1$tm. %1$tH:%1$tM]\"    <calendar>      (i3)        {channel=\"bmwconnecteddrive:bev_rex:user:i3:status#last-update\"}\n+\n+DateTime                i3TripDateTime            \"Trip Date [%1$tA, %1$td.%1$tm. %1$tH:%1$tM]\" <calendar>      (i3)        {channel=\"bmwconnecteddrive:bev_rex:user:i3:last-trip#date\"}\n+Number:Time             i3TripDuration            \"Trip Duration [%d %unit%]\"                   <time>          (i3)        {channel=\"bmwconnecteddrive:bev_rex:user:i3:last-trip#duration\"}\n+Number:Length           i3TripDistance            \"Distance [%d %unit%]\"                        <line>          (i3)        {channel=\"bmwconnecteddrive:bev_rex:user:i3:last-trip#distance\" }                                                                           \n+Number:Length           i3TripDistanceSinceCharge \"Distance since last Charge [%d %unit%]\"      <line>          (i3,long)   {channel=\"bmwconnecteddrive:bev_rex:user:i3:last-trip#distance-since-charging\" }                                                                           \n+Number:Energy           i3AvgTripConsumption      \"Average Consumption [%.1f %unit%]\"           <energy>        (i3)        {channel=\"bmwconnecteddrive:bev_rex:user:i3:last-trip#avg-consumption\" }                                                                           \n+Number:Volume           i3AvgTripCombined         \"Average Combined Consumption [%.1f %unit%]\"  <oil>           (i3)        {channel=\"bmwconnecteddrive:bev_rex:user:i3:last-trip#avg-combined-consumption\" }                                                                           \n+Number:Energy           i3AvgTripRecuperation     \"Average Recuperation [%.1f %unit%]\"          <energy>        (i3)        {channel=\"bmwconnecteddrive:bev_rex:user:i3:last-trip#avg-recuperation\" }                                                                           \n+\n+Number:Length           i3TotalElectric           \"Electric Distance Driven [%d %unit%]\"        <line>          (i3)        {channel=\"bmwconnecteddrive:bev_rex:user:i3:lifetime#total-driven-distance\" }                                                                           \n+Number:Length           i3LongestEVTrip           \"Longest Electric Trip [%d %unit%]\"           <line>          (i3)        {channel=\"bmwconnecteddrive:bev_rex:user:i3:lifetime#single-longest-distance\" }                                                                           \n+Number:Energy           i3AvgConsumption          \"Average Consumption [%.1f %unit%]\"           <energy>        (i3)        {channel=\"bmwconnecteddrive:bev_rex:user:i3:lifetime#avg-consumption\" }                                                                           \n+Number:Volume           i3AvgCombined             \"Average Combined Consumption [%.1f %unit%]\"  <oil>           (i3)        {channel=\"bmwconnecteddrive:bev_rex:user:i3:lifetime#avg-combined-consumption\" }                                                                           \n+Number:Energy           i3AvgRecuperation         \"Average Recuperation [%.1f %unit%]\"          <energy>        (i3)        {channel=\"bmwconnecteddrive:bev_rex:user:i3:lifetime#avg-recuperation\" }  \n+\n+Location                i3Location                \"Location  [%s]\"                              <zoom>          (i3)        {channel=\"bmwconnecteddrive:bev_rex:user:i3:location#gps\" }                                                                           \n+Number:Angle            i3Heading                 \"Heading [%.1f %unit%]\"                       <zoom>          (i3)        {channel=\"bmwconnecteddrive:bev_rex:user:i3:location#heading\" }  \n+\n+String                  i3RemoteCommand           \"Command [%s]\"                                <switch>        (i3)        {channel=\"bmwconnecteddrive:bev_rex:user:i3:remote#command\" } \n+String                  i3RemoteState             \"Remote Execution State [%s]\"                 <status>        (i3)        {channel=\"bmwconnecteddrive:bev_rex:user:i3:remote#state\" } \n+\n+String                  i3DriverDoor              \"Driver Door [%s]\"                            <lock>          (i3)        {channel=\"bmwconnecteddrive:bev_rex:user:i3:doors#driver-front\" }\n+String                  i3DriverDoorRear          \"Driver Door Rear [%s]\"                       <lock>          (i3)        {channel=\"bmwconnecteddrive:bev_rex:user:i3:doors#driver-rear\" }\n+String                  i3PassengerDoor           \"Passenger Door [%s]\"                         <lock>          (i3)        {channel=\"bmwconnecteddrive:bev_rex:user:i3:doors#passenger-front\" }\n+String                  i3PassengerDoorRear       \"Passenger Door Rear [%s]\"                    <lock>          (i3)        {channel=\"bmwconnecteddrive:bev_rex:user:i3:doors#passenger-rear\" }\n+String                  i3Hood                    \"Hood [%s]\"                                   <lock>          (i3)        {channel=\"bmwconnecteddrive:bev_rex:user:i3:doors#hood\" }\n+String                  i3Trunk                   \"Trunk [%s]\"                                  <lock>          (i3)        {channel=\"bmwconnecteddrive:bev_rex:user:i3:doors#trunk\" }\n+String                  i3DriverWindow            \"Driver Window [%s]\"                          <lock>          (i3)        {channel=\"bmwconnecteddrive:bev_rex:user:i3:doors#win-driver-front\" }\n+String                  i3DriverWindowRear        \"Driver Window Rear [%s]\"                     <lock>          (i3)        {channel=\"bmwconnecteddrive:bev_rex:user:i3:doors#win-driver-rear\" }\n+String                  i3PassengerWindow         \"Passenger Window [%s]\"                       <lock>          (i3)        {channel=\"bmwconnecteddrive:bev_rex:user:i3:doors#win-passenger-front\" }\n+String                  i3PassengerWindowRear     \"Passenger Window Rear [%s]\"                  <lock>          (i3)        {channel=\"bmwconnecteddrive:bev_rex:user:i3:doors#win-passenger-rear\" }\n+String                  i3RearWindow              \"Rear Window [%s]\"                            <lock>          (i3)        {channel=\"bmwconnecteddrive:bev_rex:user:i3:doors#win-rear\" }\n+String                  i3Sunroof                 \"Sunroof [%s]\"                                <lock>          (i3)        {channel=\"bmwconnecteddrive:bev_rex:user:i3:doors#sunroof\" }\n+\n+String                  i3ServiceName             \"Service Name [%s]\"                           <text>          (i3)        {channel=\"bmwconnecteddrive:bev_rex:user:i3:service#name\" }\n+String                  i3ServiceDetails          \"Service Details [%s]\"                        <text>          (i3)        {channel=\"bmwconnecteddrive:bev_rex:user:i3:service#details\" }\n+Number:Length           i3ServiceMileage          \"Service Mileage [%d %unit%]\"                 <line>          (i3)        {channel=\"bmwconnecteddrive:bev_rex:user:i3:service#mileage\" }\n+DateTime                i3ServiceDate             \"Service Date [%1$tb %1$tY]\"                  <calendar>      (i3)        {channel=\"bmwconnecteddrive:bev_rex:user:i3:service#date\" }\n+\n+String                  i3CCName                  \"CheckControl Name [%s]\"                      <text>          (i3)        {channel=\"bmwconnecteddrive:bev_rex:user:i3:check#name\" }\n+String                  i3CCDetails               \"CheckControl Details [%s]\"                   <text>          (i3)        {channel=\"bmwconnecteddrive:bev_rex:user:i3:check#details\" }\n+Number:Length           i3CCMileage               \"CheckControl Mileage [%d %unit%]\"            <line>          (i3)        {channel=\"bmwconnecteddrive:bev_rex:user:i3:check#mileage\" }\n+\n+String                  i3DestName                \"Destination [%s]\"                            <house>         (i3)        {channel=\"bmwconnecteddrive:bev_rex:user:i3:destination#name\" } \n+Location                i3DestLocation            \"GPS [%s]\"                                    <zoom>          (i3)        {channel=\"bmwconnecteddrive:bev_rex:user:i3:destination#gps\" }                                                                           \n+ \n+Switch                  i3ChargeProfileClimate    \"Charge Profile Climatization\"                <temperature>   (i3)        {channel=\"bmwconnecteddrive:bev_rex:user:i3:charge#profile-climate\" }  \n+String                  i3ChargeProfileMode       \"Charge Profile Mode [%s]\"                    <energy>        (i3)        {channel=\"bmwconnecteddrive:bev_rex:user:i3:charge#profile-mode\" } \n+DateTime                i3ChargeWindowStart       \"Charge Window Start [%1$tH:%1$tM]\"           <time>          (i3)        {channel=\"bmwconnecteddrive:bev_rex:user:i3:charge#window-start\" } \n+Number                  i3ChargeWindowStartHour   \"Charge Window Start Hour [%d]\"               <time>          (i3)        {channel=\"bmwconnecteddrive:bev_rex:user:i3:charge#window-start-hour\" } \n+Number                  i3ChargeWindowStartMinute \"Charge Window Start Minute [%d]\"             <time>          (i3)        {channel=\"bmwconnecteddrive:bev_rex:user:i3:charge#window-start-minute\" } \n+DateTime                i3ChargeWindowEnd         \"Charge Window End [%1$tH:%1$tM]\"             <time>          (i3)        {channel=\"bmwconnecteddrive:bev_rex:user:i3:charge#window-end\" } \n+Number                  i3ChargeWindowEndHour     \"Charge Window End Hour [%d]\"                 <time>          (i3)        {channel=\"bmwconnecteddrive:bev_rex:user:i3:charge#window-end-hour\" } \n+Number                  i3ChargeWindowEndMinute   \"Charge Window End Minute [%d]\"               <time>          (i3)        {channel=\"bmwconnecteddrive:bev_rex:user:i3:charge#window-end-minute\" } \n+DateTime                i3Timer1Departure         \"Timer 1 Departure [%1$tH:%1$tM]\"             <time>          (i3)        {channel=\"bmwconnecteddrive:bev_rex:user:i3:charge#timer1-departure\" } \n+Number                  i3Timer1DepartureHour     \"Timer 1 Departure Hour [%d]\"                 <time>          (i3)        {channel=\"bmwconnecteddrive:bev_rex:user:i3:charge#timer1-departure-hour\" } \n+Number                  i3Timer1DepartureMinute   \"Timer 1 Departure Minute [%d]\"               <time>          (i3)        {channel=\"bmwconnecteddrive:bev_rex:user:i3:charge#timer1-departure-minute\" } \n+String                  i3Timer1Days              \"Timer 1 Days [%s]\"                           <calendar>      (i3)        {channel=\"bmwconnecteddrive:bev_rex:user:i3:charge#timer1-days\" } \n+Switch                  i3Timer1DayMon            \"Timer 1 Monday\"                              <calendar>      (i3)        {channel=\"bmwconnecteddrive:bev_rex:user:i3:charge#timer1-day-mon\" } \n+Switch                  i3Timer1DayTue            \"Timer 1 Tuesday\"                             <calendar>      (i3)        {channel=\"bmwconnecteddrive:bev_rex:user:i3:charge#timer1-day-tue\" } \n+Switch                  i3Timer1DayWed            \"Timer 1 Wednesday\"                           <calendar>      (i3)        {channel=\"bmwconnecteddrive:bev_rex:user:i3:charge#timer1-day-wed\" } \n+Switch                  i3Timer1DayThu            \"Timer 1 Thursday\"                            <calendar>      (i3)        {channel=\"bmwconnecteddrive:bev_rex:user:i3:charge#timer1-day-thu\" } \n+Switch                  i3Timer1DayFri            \"Timer 1 Friday\"                              <calendar>      (i3)        {channel=\"bmwconnecteddrive:bev_rex:user:i3:charge#timer1-day-fri\" } \n+Switch                  i3Timer1DaySat            \"Timer 1 Saturday\"                            <calendar>      (i3)        {channel=\"bmwconnecteddrive:bev_rex:user:i3:charge#timer1-day-sat\" } \n+Switch                  i3Timer1DaySun            \"Timer 1 Sunday\"                              <calendar>      (i3)        {channel=\"bmwconnecteddrive:bev_rex:user:i3:charge#timer1-day-sun\" } \n+Switch                  i3Timer1Enabled           \"Timer 1 Enabled\"                             <switch>        (i3)        {channel=\"bmwconnecteddrive:bev_rex:user:i3:charge#timer1-enabled\" }  \n+DateTime                i3Timer2Departure         \"Timer 2 Departure [%1$tH:%1$tM]\"             <time>          (i3)        {channel=\"bmwconnecteddrive:bev_rex:user:i3:charge#timer2-departure\" } \n+Number                  i3Timer2DepartureHour     \"Timer 2 Departure Hour [%d]\"                 <time>          (i3)        {channel=\"bmwconnecteddrive:bev_rex:user:i3:charge#timer2-departure-hour\" } \n+Number                  i3Timer2DepartureMinute   \"Timer 2 Departure Minute [%d]\"               <time>          (i3)        {channel=\"bmwconnecteddrive:bev_rex:user:i3:charge#timer2-departure-minute\" } \n+String                  i3Timer2Days              \"Timer 2 Days [%s]\"                           <calendar>      (i3)        {channel=\"bmwconnecteddrive:bev_rex:user:i3:charge#timer2-days\" } \n+Switch                  i3Timer2DayMon            \"Timer 2 Monday\"                              <calendar>      (i3)        {channel=\"bmwconnecteddrive:bev_rex:user:i3:charge#timer2-day-mon\" } \n+Switch                  i3Timer2DayTue            \"Timer 2 Tuesday\"                             <calendar>      (i3)        {channel=\"bmwconnecteddrive:bev_rex:user:i3:charge#timer2-day-tue\" } \n+Switch                  i3Timer2DayWed            \"Timer 2 Wednesday\"                           <calendar>      (i3)        {channel=\"bmwconnecteddrive:bev_rex:user:i3:charge#timer2-day-wed\" } \n+Switch                  i3Timer2DayThu            \"Timer 2 Thursday\"                            <calendar>      (i3)        {channel=\"bmwconnecteddrive:bev_rex:user:i3:charge#timer2-day-thu\" } \n+Switch                  i3Timer2DayFri            \"Timer 2 Friday\"                              <calendar>      (i3)        {channel=\"bmwconnecteddrive:bev_rex:user:i3:charge#timer2-day-fri\" } \n+Switch                  i3Timer2DaySat            \"Timer 2 Saturday\"                            <calendar>      (i3)        {channel=\"bmwconnecteddrive:bev_rex:user:i3:charge#timer2-day-sat\" } \n+Switch                  i3Timer2DaySun            \"Timer 2 Sunday\"                              <calendar>      (i3)        {channel=\"bmwconnecteddrive:bev_rex:user:i3:charge#timer2-day-sun\" } \n+Switch                  i3Timer2Enabled           \"Timer 2 Enabled\"                             <switch>        (i3)        {channel=\"bmwconnecteddrive:bev_rex:user:i3:charge#timer2-enabled\" }  \n+DateTime                i3Timer3Departure         \"Timer 3 Departure [%1$tH:%1$tM]\"             <time>          (i3)        {channel=\"bmwconnecteddrive:bev_rex:user:i3:charge#timer3-departure\" } \n+Number                  i3Timer3DepartureHour     \"Timer 3 Departure Hour [%d]\"                 <time>          (i3)        {channel=\"bmwconnecteddrive:bev_rex:user:i3:charge#timer3-departure-hour\" } \n+Number                  i3Timer3DepartureMinute   \"Timer 3 Departure Minute [%d]\"               <time>          (i3)        {channel=\"bmwconnecteddrive:bev_rex:user:i3:charge#timer3-departure-minute\" } \n+String                  i3Timer3Days              \"Timer 3 Days [%s]\"                           <calendar>      (i3)        {channel=\"bmwconnecteddrive:bev_rex:user:i3:charge#timer3-days\" } \n+Switch                  i3Timer3DayMon            \"Timer 3 Monday\"                              <calendar>      (i3)        {channel=\"bmwconnecteddrive:bev_rex:user:i3:charge#timer3-day-mon\" } \n+Switch                  i3Timer3DayTue            \"Timer 3 Tuesday\"                             <calendar>      (i3)        {channel=\"bmwconnecteddrive:bev_rex:user:i3:charge#timer3-day-tue\" } \n+Switch                  i3Timer3DayWed            \"Timer 3 Wednesday\"                           <calendar>      (i3)        {channel=\"bmwconnecteddrive:bev_rex:user:i3:charge#timer3-day-wed\" } \n+Switch                  i3Timer3DayThu            \"Timer 3 Thursday\"                            <calendar>      (i3)        {channel=\"bmwconnecteddrive:bev_rex:user:i3:charge#timer3-day-thu\" } \n+Switch                  i3Timer3DayFri            \"Timer 3 Friday\"                              <calendar>      (i3)        {channel=\"bmwconnecteddrive:bev_rex:user:i3:charge#timer3-day-fri\" } \n+Switch                  i3Timer3DaySat            \"Timer 3 Saturday\"                            <calendar>      (i3)        {channel=\"bmwconnecteddrive:bev_rex:user:i3:charge#timer3-day-sat\" } \n+Switch                  i3Timer3DaySun            \"Timer 3 Sunday\"                              <calendar>      (i3)        {channel=\"bmwconnecteddrive:bev_rex:user:i3:charge#timer3-day-sun\" } \n+Switch                  i3Timer3Enabled           \"Timer 3 Enabled\"                             <switch>        (i3)        {channel=\"bmwconnecteddrive:bev_rex:user:i3:charge#timer3-enabled\" }\n+Switch                  i3OverrideEnabled         \"Override Timer Enabled\"                      <switch>        (i3)        {channel=\"bmwconnecteddrive:bev_rex:user:i3:charge#override-enabled\"}\n+DateTime                i3OverrideDeparture       \"Override Timer Departure [%1$tH:%1$tM]\"      <time>          (i3)        {channel=\"bmwconnecteddrive:bev_rex:user:i3:charge#override-departure\" } \n+Number                  i3OverrideDepartureHour   \"Override Timer Departure Hour [%d]\"          <time>          (i3)        {channel=\"bmwconnecteddrive:bev_rex:user:i3:charge#override-departure-hour\" } \n+Number                  i3OverrideDepartureMinute \"Override Timer Departure Minute [%d]\"        <time>          (i3)        {channel=\"bmwconnecteddrive:bev_rex:user:i3:charge#override-departure-minute\" } \n+\n+Image                   i3Image                   \"Image\"                                                       (i3)        {channel=\"bmwconnecteddrive:bev_rex:user:i3:image#png\" }  \n+String                  i3ImageViewport           \"Image Viewport [%s]\"                         <zoom>          (i3)        {channel=\"bmwconnecteddrive:bev_rex:user:i3:image#view\" }  \n+Number                  i3ImageSize               \"Image Size [%d]\"                             <zoom>          (i3)        {channel=\"bmwconnecteddrive:bev_rex:user:i3:image#size\" }  \n+```\n+\n+### Sitemap File\n+\n+```\n+sitemap BMW label=\"BMW\" {\n+  Frame label=\"BMW i3\" {\n+    Image  item=i3Image  \n+                       \n+  } \n+  Frame label=\"Range\" {\n+    Text    item=i3Mileage           \n+    Text    item=i3Range             \n+    Text    item=i3RangeElectric     \n+    Text    item=i3RangeFuel         \n+    Text    item=i3BatterySoc        \n+    Text    item=i3Fuel              \n+    Text    item=i3RadiusElectric       \n+    Text    item=i3RadiusHybrid         \n+  }\n+  Frame label=\"Status\" {\n+    Text    item=i3DoorStatus           \n+    Text    item=i3WindowStatus         \n+    Text    item=i3LockStatus           \n+    Text    item=i3NextServiceDate              \n+    Text    item=i3NextServiceMileage       \n+    Text    item=i3CheckControl         \n+    Text    item=i3ChargingStatus           \n+    Text    item=i3LastUpdate               \n+  }\n+  Frame label=\"Remote Services\" {\n+    Selection item=i3RemoteCommand              \n+    Text      item=i3RemoteState              \n+  }\n+  Frame label=\"Last Trip\" {\n+    Text    item=i3TripDateTime            \n+    Text    item=i3TripDuration            \n+    Text    item=i3TripDistance            \n+    Text    item=i3TripDistanceSinceCharge \n+    Text    item=i3AvgTripConsumption      \n+    Text    item=i3AvgTripRecuperation     \n+    Text    item=i3AvgTripCombined     \n+  }\n+  Frame label=\"Lifetime\" {\n+    Text    item=i3TotalElectric  \n+    Text    item=i3LongestEVTrip      \n+    Text    item=i3AvgConsumption     \n+    Text    item=i3AvgRecuperation          \n+    Text    item=i3AvgCombined          \n+  }\n+  Frame label=\"Services\" {\n+    Text    item=i3ServiceName          \n+    Text    item=i3ServiceMileage          \n+    Text    item=i3ServiceDate          \n+  }\n+  Frame label=\"CheckControl\" {\n+    Text    item=i3CCName          \n+    Text    item=i3CCMileage          \n+  }\n+  Frame label=\"Door Details\" {\n+    Text    item=i3DriverDoor visibility=[i3DriverDoor!=\"INVALID\"]\n+    Text    item=i3DriverDoorRear visibility=[i3DriverDoorRear!=\"INVALID\"]  \n+    Text    item=i3PassengerDoor visibility=[i3PassengerDoor!=\"INVALID\"]\n+    Text    item=i3PassengerDoorRear visibility=[i3PassengerDoorRear!=\"INVALID\"]\n+    Text    item=i3Hood visibility=[i3Hood!=\"INVALID\"]\n+    Text    item=i3Trunk visibility=[i3Trunk!=\"INVALID\"]\n+    Text    item=i3DriverWindow visibility=[i3DriverWindow!=\"INVALID\"]\n+    Text    item=i3DriverWindowRear visibility=[i3DriverWindowRear!=\"INVALID\"]\n+    Text    item=i3PassengerWindow visibility=[i3PassengerWindow!=\"INVALID\"]\n+    Text    item=i3PassengerWindowRear visibility=[i3PassengerWindowRear!=\"INVALID\"]\n+    Text    item=i3RearWindow visibility=[i3RearWindow!=\"INVALID\"]\n+    Text    item=i3Sunroof visibility=[i3Sunroof!=\"INVALID\"]\n+  }\n+  Frame label=\"Location\" {\n+    Text    item=i3Location          \n+    Text    item=i3Heading             \n+  }\n+  Frame label=\"Charge Profile\" {    \n+    Switch    item=i3ChargeProfileClimate     \n+    Selection item=i3ChargeProfileMode        \n+    Text      item=i3ChargeWindowStart        \n+    Setpoint  item=i3ChargeWindowStartHour maxValue=23 step=1 icon=\"time\"\n+    Setpoint  item=i3ChargeWindowStartMinute maxValue=55 step=5 icon=\"time\"\n+    Text      item=i3ChargeWindowEnd          \n+    Setpoint  item=i3ChargeWindowEndHour maxValue=23 step=1 icon=\"time\"\n+    Setpoint  item=i3ChargeWindowEndMinute maxValue=55 step=5 icon=\"time\"\n+    Text      item=i3Timer1Departure          \n+    Setpoint  item=i3Timer1DepartureHour maxValue=23 step=1 icon=\"time\"\n+    Setpoint  item=i3Timer1DepartureMinute maxValue=55 step=5 icon=\"time\"\n+    Text      item=i3Timer1Days               \n+    Switch    item=i3Timer1DayMon            \n+    Switch    item=i3Timer1DayTue            \n+    Switch    item=i3Timer1DayWed            \n+    Switch    item=i3Timer1DayThu            \n+    Switch    item=i3Timer1DayFri            \n+    Switch    item=i3Timer1DaySat            \n+    Switch    item=i3Timer1DaySun            \n+    Switch    item=i3Timer1Enabled            \n+    Text      item=i3Timer2Departure          \n+    Setpoint  item=i3Timer2DepartureHour maxValue=23 step=1 icon=\"time\"\n+    Setpoint  item=i3Timer2DepartureMinute maxValue=55 step=5 icon=\"time\"\n+    Text      item=i3Timer2Days               \n+    Switch    item=i3Timer2DayMon            \n+    Switch    item=i3Timer2DayTue            \n+    Switch    item=i3Timer2DayWed            \n+    Switch    item=i3Timer2DayThu            \n+    Switch    item=i3Timer2DayFri            \n+    Switch    item=i3Timer2DaySat            \n+    Switch    item=i3Timer2DaySun            \n+    Switch    item=i3Timer2Enabled            \n+    Text      item=i3Timer3Departure          \n+    Setpoint  item=i3Timer3DepartureHour maxValue=23 step=1 icon=\"time\"\n+    Setpoint  item=i3Timer3DepartureMinute maxValue=55 step=5 icon=\"time\"\n+    Text      item=i3Timer3Days               \n+    Switch    item=i3Timer3DayMon            \n+    Switch    item=i3Timer3DayTue            \n+    Switch    item=i3Timer3DayWed            \n+    Switch    item=i3Timer3DayThu            \n+    Switch    item=i3Timer3DayFri            \n+    Switch    item=i3Timer3DaySat            \n+    Switch    item=i3Timer3DaySun            \n+    Switch    item=i3Timer3Enabled            \n+    Switch    item=i3OverrideEnabled            \n+    Text      item=i3OverrideDeparture          \n+    Setpoint  item=i3OverrideDepartureHour maxValue=23 step=1 icon=\"time\"\n+    Setpoint  item=i3OverrideDepartureMinute maxValue=55 step=5 icon=\"time\"\n+  } \n+  Frame label=\"Last Destinations\" {    \n+    Text  item=i3DestName                 \n+    Text  item=i3DestLocation                                                                                   \n+  }  \n+  Frame label=\"Image Properties\" {\n+    Text    item=i3ImageViewport\n+    Text    item=i3ImageSize \n+  } \n+}\n+```\n+\n+### Action example\n+\n+```\n+  val profile = getActions(\"chargeprofile\", \"bmwconnecteddrive:bev_rex:user:i3\")\n+  val now = ZonedDateTime.now.toLocalTime\n+  profile.setChargingMode(\"DELAYED_CHARGING\")\n+  profile.setTimer1Departure(now.minusHours(2))\n+  profile.setTimer1Days(java.util.Set())\n+  profile.setTimer1Enabled(true)\n+  profile.setTimer2Enabled(false)\n+  profile.setTimer3Enabled(false)\n+  profile.setPreferredWindowStart(now.minusHours(6))\n+  profile.setPreferredWindowEnd(now.minusHours(2))\n+  profile.send()", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5Nzk1MDEzNA=="}, "originalCommit": {"oid": "48af48c82562d006b6f2aa35922270f181c885ed"}, "originalPosition": 842}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5ODI3NTIwOA==", "bodyText": "I think your current implementation is reasonable under these circumstances.", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r598275208", "createdAt": "2021-03-21T12:53:55Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/README.md", "diffHunk": "@@ -0,0 +1,849 @@\n+# BMW ConnectedDrive Binding\n+\n+<img align=\"right\" src=\"./doc/bmw-connected.png\" width=\"150\" height=\"150\"/>\n+\n+The binding provides a connection between [BMW's ConnectedDrive Portal](https://www.bmw-connecteddrive.com/country-region-select/country-region-selection.html) and openHAB.\n+All vehicles connected to an account will be detected by the discovery with the correct type \n+\n+* Conventional Fuel Vehicle\n+* Plugin-Hybrid Electrical Vehicle \n+* Battery Electric Vehicle with Range Extender\n+* Battery Electric Vehicle \n+\n+In addition properties are attached with information and services provided by this vehicle.\n+The provided data depends on \n+\n+1. the [Thing Type](#things) and \n+2. the [Properties](#properties) mentioned in Services\n+\n+Different channel groups are clustering all informations.\n+Check for each group if it's supported for this Vehicle.\n+\n+Please note **this isn't a real-time binding**. \n+If a door is opened the state isn't transmitted and changed immediately. \n+This isn't a flaw in the binding itself because the state in BMW's own ConnectedDrive App is also updated with some delay. \n+\n+## Supported Things\n+\n+### Bridge\n+\n+The bridge establishes the connection between BMW's ConnectedDrive Portal and openHAB.\n+\n+| Name                       | Bridge Type ID | Description                                                |\n+|----------------------------|----------------|------------------------------------------------------------|\n+| BMW ConnectedDrive Account | account        | Access to BMW ConnectedDrive Portal for a specific user    |\n+\n+\n+### Things\n+\n+Four different vehicle types are provided. \n+They differ in the supported channel groups & channels. \n+Conventional Fuel Vehicles have no _Charging Profile_, Electric Vehicles don't provide a _Fuel Range_. \n+For hybrid vehicles in addition to _Fuel and Electric Range_ the _Hybrid Range_ is shown.\n+ \n+| Name                                | Thing Type ID | Supported Channel Groups                               |\n+|-------------------------------------|---------------|--------------------------------------------------------|\n+| BMW Electric Vehicle                | bev           | status, range, location, service, check, charge, image |\n+| BMW Electric Vehicle with REX       | bev_rex       | status, range, location, service, check, charge, image |\n+| BMW Plug-In-Hybrid Electric Vehicle | phev          | status, range, location, service, check, charge, image |\n+| BMW Conventional Vehicle            | conv          | status, range, location, service, check, image         |\n+\n+ \n+#### Properties\n+\n+<img align=\"right\" src=\"./doc/properties.png\" width=\"500\" height=\"225\"/>\n+\n+For each vehicle properties are available. \n+Basically 3 types of information are registered as properties\n+\n+* Informations regarding your dealer with address and phone number\n+* Which services are available / not available\n+* Vehicle properties like color, model type, drive train and construction year\n+\n+In the right picture can see in *Services Activated* e.g. the *DoorLock* and *DoorUnlock* services are mentioned. \n+This ensures channel group [Remote Services](#remote-services) is supporting door lock and unlock remote control.\n+\n+In  *Services Supported* the entry *LastDestination* is mentioned.\n+So it's valid to connect channel group [Last Destinations](#destinations) in order to display and select the last navigation destinations.\n+\n+| Property Key       | Property Value      |  Supported Channel Groups    |\n+|--------------------|---------------------|------------------------------|\n+| servicesSupported  | Statistics          | last-trip, lifetime          |\n+| servicesSupported  | LastDestinations    | destinations                 |\n+| servicesActivated  | _list of services_  | remote                       |\n+\n+\n+## Discovery\n+\n+Auto discovery is starting after the bridge towards BMW's ConnectedDrive is created. \n+A list of your registered vehicles is queried and all found things are added in the inbox.\n+Unique identifier is the *Vehicle Identification Number* (VIN). \n+If a thing is already declared in a  _.things_ configuration, discovery won't highlight it again.\n+Properties will be attached to predefined vehicles if the VIN is matching.\n+\n+## Configuration\n+\n+### Bridge Configuration\n+\n+| Parameter       | Type    | Description                                                        |           \n+|-----------------|---------|--------------------------------------------------------------------|\n+| userName        | text    | BMW ConnectedDrive Username                                       |\n+| password        | text    | BMW ConnectedDrive Password                                       |\n+| region          | text    | Select region in order to connect to the appropriate BMW server.   |\n+\n+The region Configuration has 3 different options\n+\n+* _NORTH_AMERICA_\n+* _CHINA_\n+* _ROW_  (Rest of World)\n+\n+### Thing Configuration\n+\n+Same configuration is needed for all things\n+\n+| Parameter       | Type    | Description                           |           \n+|-----------------|---------|---------------------------------------|\n+| vin             | text    | Vehicle Identification Number (VIN)   |\n+| refreshInterval | integer | Refresh Interval in Minutes           |\n+| units           | text    | Unit Selection. See below.            |\n+| imageSize       | integer | Image Size                            |\n+| imageViewport   | text    | Image Viewport                        |\n+\n+The unit configuration has 3 options\n+\n+* _AUTODETECT_ selects miles for US & UK, kilometer otherwise\n+* _METRIC_ selects directly kilometers\n+* _IMPERIAL_ selects directly miles\n+\n+The _imageVieport_ allows to show the vehicle from different angels.\n+Possible options are \n+\n+* _FRONT_\n+* _REAR_\n+* _SIDE_\n+* _DASHBOARD_\n+* _DRIVERDOOR_\n+\n+## Channels\n+\n+There are many channels available for each vehicle. \n+For better overview they are clustered in different channel groups.\n+They differ for each vehicle type, build-in sensors and activated services.\n+\n+\n+### Thing Channel Groups \n+\n+#### Vehicle Status\n+\n+Reflects overall status of the vehicle.\n+\n+* Channel Group ID is **status**\n+* Available for all vehicles\n+* Read-only values\n+\n+| Channel Label             | Channel ID          | Type          | Description                                    |\n+|---------------------------|---------------------|---------------|------------------------------------------------|\n+| Overall Door Status       | doors               | String        | Combined status for all doors                  |\n+| Overall Window Status     | windows             | String        | Combined status for all windows                |\n+| Doors Locked              | lock                | String        | Status if doors are locked or unlocked         |\n+| Next Service Date         | service-date        | DateTime      | Date of upcoming service                       |\n+| Mileage till Next Service | service-mileage     | Number:Length | Mileage till upcoming service                  |\n+| Check Control             | check-control       | String        | Presence of active warning messages            |\n+| Charging Status           | charge              | String        | Only available for phev, bev_rex and bev       |\n+| Last Status Timestamp     | last-update         | DateTime      | Date and time of last status update            |\n+\n+Overall Door Status values\n+\n+* _Closed_ - all doors closed\n+* _Open_ - at least one door is open\n+* _Undef_ - no door data delivered at all\n+\n+Overall Windows Status values\n+\n+* _Closed_ - all windows closed\n+* _Open_ - at least one window is completely open\n+* _Intermediate_ - at least one window is partially open\n+* _Undef_ - no window data delivered at all\n+\n+Check Control values\n+\n+* _Active_ - at least one warning message is active\n+* _Not Active_ - no warning message is active\n+* _Undef_ - no data for warnings delivered\n+\n+Charging Status values\n+\n+* _Charging_\n+* _Error_\n+* _Finished Fully Charged_\n+* _Finished Not Full_\n+* _Invalid_\n+* _Not Charging_\n+* _Charging Goal reached_\n+* _Waiting For Charging_\n+\n+#### Services\n+\n+Group for all upcoming services with description, service date and/or service mileage.\n+If more than one service is scheduled in the future the channel _name_ contains all future services as options.\n+\n+* Channel Group ID is **service**\n+* Available for all vehicles\n+* Read/Write access\n+\n+| Channel Label                  | Channel ID          | Type           | Access     |\n+|--------------------------------|---------------------|----------------|------------|\n+| Service Name                   | name                | String         | Read/Write |\n+| Service Details                | details             | String         | Read       |\n+| Service Date                   | date                | Number         | Read       |\n+| Mileage till Service           | mileage             | Number:Length  | Read       |\n+\n+#### Check Control\n+\n+Group for all current active CheckControl messages.\n+If more than one message is active the channel _name_ contains all active messages as options.\n+\n+* Channel Group ID is **check**\n+* Available for all vehicles\n+* Read/Write access\n+\n+| Channel Label                   | Channel ID          | Type           | Access     |\n+|---------------------------------|---------------------|----------------|------------|\n+| CheckControl Description        | name                | String         | Read/Write |\n+| CheckControl Details            | details             | String         | Read       |\n+| Mileage Occurrence              | mileage             | Number:Length  | Read       |\n+\n+#### Doors Details\n+\n+Detailed status of all doors and windows.\n+\n+* Channel Group ID is **doors**\n+* Available for all vehicles if corresponding sensors are built-in \n+* Read-only values\n+ \n+| Channel Label              | Channel ID              | Type          | \n+|----------------------------|-------------------------|---------------|\n+| Driver Door                | driver-front            | String        |\n+| Driver Door Rear           | driver-rear             | String        |\n+| Passenger Door             | passenger-front         | String        |\n+| Passenger Door Rear        | passenger-rear          | String        |\n+| Trunk                      | trunk                   | String        |\n+| Hood                       | hood                    | String        |\n+| Driver Window              | win-driver-front        | String        |\n+| Driver Rear Window         | win-driver-rear         | String        |\n+| Passenger Window           | win-passenger-front     | String        |\n+| Passenger Rear Window      | win-passenger-rear      | String        |\n+| Rear Window                | win-rear                | String        |\n+| Sunroof                    | sunroof                 | String        |\n+\n+Possible states\n+\n+* _Undef_ - no status data available\n+* _Invalid_ - this door / window isn't applicable for this vehicle\n+* _Closed_ - the door / window is closed\n+* _Open_ - the door / window is open\n+* _Intermediate_ - window in intermediate position, not applicable for doors\n+\n+#### Range Data\n+\n+Based on vehicle type some channels are present or not. \n+Conventional fuel vehicles don't provide *Electric Range* and battery electric vehicles don't show *Fuel Range*.\n+Hybrid vehicles have both and in addition *Hybrid Range*.\n+See description [Range vs Range Radius](#range-vs-range-radius) to get more information.\n+\n+* Channel Group ID is **range**\n+* Availability according to table\n+* Read-only values\n+\n+| Channel Label         | Channel ID            | Type                 | conv | phev | bev_rex | bev |\n+|-----------------------|-----------------------|----------------------|------|------|---------|-----|\n+| Mileage               | mileage               | Number:Length        |  X   |  X   |    X    |  X  |\n+| Fuel Range            | range-fuel            | Number:Length        |  X   |  X   |    X    |     |\n+| Battery Range         | range-electric        | Number:Length        |      |  X   |    X    |  X  | \n+| Hybrid Range          | range-hybrid          | Number:Length        |      |  X   |    X    |     | \n+| Battery Charge Level  | soc                   | Number:Dimensionless |      |  X   |    X    |  X  |\n+| Remaining Fuel        | remaining-fuel        | Number:Volume        |  X   |  X   |    X    |     | \n+| Fuel Range Radius     | range-radius-fuel     | Number:Length        |  X   |  X   |    X    |     | \n+| Electric Range Radius | range-radius-electric | Number:Length        |      |  X   |    X    |  X  | \n+| Hybrid Range Radius   | range-radius-hybrid   | Number:Length        |      |  X   |    X    |     | \n+\n+\n+#### Charge Profile\n+\n+Charging options with date and time for preferred time windows and charging modes.\n+\n+* Channel Group ID is **charge**\n+* Available for electric and hybrid vehicles\n+* Read/Write access for UI. Use [Charge Profile Actions](#charge-profile-action) in rules\n+* There are 3 timers available. Replace *X* with number 1,2 or 3 to target the correct timer\n+\n+| Channel Label                         | Channel Group ID | Channel ID                | Type     | \n+|---------------------------------------|------------------|---------------------------|----------| \n+| Charging Mode for Profile             | charge           | profile-mode              | String   | \n+| Charging Preferences for Profile      | charge           | profile-prefs             | String   | \n+| Charging Window Start Time            | charge           | window-start              | DateTime | \n+| Charging Window Start Time Hour       | charge           | window-start-hour         | Number   | \n+| Charging Window Start Time Minute     | charge           | window-start-minute       | Number   | \n+| Charging Window End Time              | charge           | window-end                | DateTime | \n+| Charging Window End Time Hour         | charge           | window-end-hour           | Number   | \n+| Charging Window End Time Minute       | charge           | window-end-minute         | Number   | \n+| Air Conditioning at Departure Time    | charge           | profile-climate           | Switch   | \n+| Timer *X*: Enabled                    | charge           | timer*X*-enabled          | Switch   | \n+| Timer *X*: Departure Time             | charge           | timer*X*-departure        | DateTime | \n+| Timer *X*: Departure Time Hour        | charge           | timer*X*-departure-hour   | Number   | \n+| Timer *X*: Departure Time Minute      | charge           | timer*X*-departure-minute | Number   | \n+| Timer *X*: Monday                     | charge           | timer*X*-day-mon          | Switch   | \n+| Timer *X*: Tuesday                    | charge           | timer*X*-day-tue          | Switch   | \n+| Timer *X*: Wednesday                  | charge           | timer*X*-day-wed          | Switch   | \n+| Timer *X*: Thursday                   | charge           | timer*X*-day-thu          | Switch   | \n+| Timer *X*: Friday                     | charge           | timer*X*-day-fri          | Switch   | \n+| Timer *X*: Saturday                   | charge           | timer*X*-day-sat          | Switch   | \n+| Timer *X*: Sunday                     | charge           | timer*X*-day-sun          | Switch   | \n+| Override Timer: Enabled               | charge           | override-enabled          | Switch   | \n+| Override Timer: Departure Time        | charge           | override-departure        | DateTime | \n+| Override Timer: Departure Time Hour   | charge           | override-departure-hour   | Number   | \n+| Override Timer: Departure Time Minute | charge           | override-departure-minute | Number   | \n+\n+The channel _profile-mode_ supports\n+\n+* *IMMEDIATE_CHARGING*\n+* *DELAYED_CHARGING*\n+\n+The channel _profile-prefs_ supports\n+\n+* *NO_PRESELECTION*\n+* *CHARGING_WINDOW*\n+\n+#### Location\n+\n+GPS location and heading of the vehicle.\n+\n+* Channel Group ID is **location**\n+* Available for all vehicles with built-in GPS sensor. Function can be enabled/disabled in the head unit\n+* Read-only values\n+\n+| Channel Label   | Channel ID          | Type         | \n+|-----------------|---------------------|--------------|\n+| GPS Coordinates | gps                 | Location     | \n+| Heading         | heading             | Number:Angle | \n+\n+#### Last Trip\n+\n+Statistic values of duration, distance and consumption of the last trip.\n+\n+* Channel Group ID is **last-trip**\n+* Available if *Statistics* is present in *Services Supported*. See [Vehicle Properties](#properties) for further details\n+* Read-only values\n+* Depending on units configuration in [Thing Configuration](#thing-configuration) average values are given for 100 kilometers or miles\n+\n+| Channel Label                           | Channel ID                   | Type          |\n+|-----------------------------------------|------------------------------|---------------|\n+| Last Trip Date                          | date                         | DateTime      |\n+| Last Trip Duration                      | duration                     | Number:Time   |\n+| Last Trip Distance                      | distance                     | Number:Length |\n+| Distance since Charge                   | distance-since-charging      | Number:Length |\n+| Avg. Power Consumption                  | avg-consumption              | Number:Power  |\n+| Avg. Power Recuperation                 | avg-recuperation             | Number:Power  |\n+| Avg. Combined Consumption               | avg-combined-consumption     | Number:Volume |\n+\n+\n+#### Lifetime Statistics\n+\n+Providing lifetime consumption values.\n+\n+* Channel Group ID is **lifetime**\n+* Available if *Statistics* is present in *Services Supported*. See [Vehicle Properties](#properties) for further details\n+* Read-only values\n+* Depending on units configuration in [Thing Configuration](#thing-configuration) average values are given for 100 kilometers or miles\n+\n+| Channel Label                           | Channel ID                   | Type          | \n+|-----------------------------------------|------------------------------|---------------|\n+| Total Electric Distance                 | total-driven-distance        | Number:Length |\n+| Longest 1-Charge Distance               | single-longest-distance      | Number:Length |\n+| Avg. Power Consumption                  | avg-consumption              | Number:Power  |\n+| Avg. Power Recuperation                 | avg-recuperation             | Number:Power  |\n+| Avg. Combined Consumption               | avg-combined-consumption     | Number:Volume |\n+\n+\n+#### Remote Services\n+\n+Remote control of the vehicle. \n+Send a *command* to the vehicle and the *state* is reporting the execution progress.\n+Only one command can be executed each time.\n+Parallel execution isn't supported.\n+\n+* Channel Group ID is **remote**\n+* Available for all commands mentioned in *Services Activated*. See [Vehicle Properties](#properties) for further details\n+* Read/Write access\n+\n+\n+| Channel Label           | Channel ID          | Type    | Access |\n+|-------------------------|---------------------|---------|--------|\n+| Remote Service Command  | command             | String  | Write  |\n+| Service Execution State | state               | String  | Read   |\n+\n+The channel _command_ provides options\n+\n+* _Flash Lights_\n+* _Vehicle Finder_\n+* _Door Lock_\n+* _Door Unlock_\n+* _Horn Blow_\n+* _Climate Control_\n+* _Start Charging_\n+* _Send Charging Profile_\n+\n+The channel _state_ shows the progress of the command execution in the following order\n+\n+1) _Initiated_ \n+2) _Pending_\n+3) _Delivered_\n+4) _Executed_\n+\n+#### Destinations\n+\n+Shows the last destinations stored in the navigation system.\n+If several last destinations are stored in the navigation system the channel _name_ contains all addresses as options.\n+\n+* Channel Group ID is **destination**\n+* Available if *LastDestinations* is present in *Services Supported*. Check [Vehicle Properties](#properties) for further details\n+* Read/Write access\n+\n+\n+| Channel Label        | Channel ID    | Type      | Access      |\n+|----------------------|---------------|-----------|-------------|\n+| Name                 | name          | String    | Read/Write  |\n+| GPS Coordinates      | gps           | Location  | Read        |\n+\n+\n+\n+#### Image\n+\n+Image representation of the vehicle. Size and viewport are writable and can be \n+The possible values are the same mentioned in [Thing Configuration](#thing-configuration).\n+\n+* Channel Group ID is **image**\n+* Available for all vehicles\n+* Read/Write access\n+\n+| Channel Label              | Channel ID          | Type   |  Access  |\n+|----------------------------|---------------------|--------|----------|\n+| Rendered Vehicle Image     | png                 | Image  | Read     |\n+| Image Viewport             | view                | String | Write    |\n+| Image Picture Size         | size                | Number | Write    |\n+\n+## Rule Actions\n+\n+## Charge Profile Action\n+\n+The Charge Profile is accessible and modifiable in rules via action. \n+Get the corresponding action from your car using the Thing ID\n+\n+* bmwconnecteddrive - Binding ID, don't change!\n+* bev_rex - [Thing UID](#things) of your car\n+* user - Thing ID of the [Bridge](#bridge)\n+* i3 - Thing ID of your car\n+\n+```\n+  val profile = getActions(\"chargeprofile\", \"bmwconnecteddrive:bev_rex:user:i3\")\n+```\n+\n+Like in the Charge Profile Channels 3 Timers are provided. Replace *X* with 1, 2 or 3 to address the right timer.\n+\n+| Function                              | Parameters       | Returns                   | Description                                                | \n+|---------------------------------------|------------------|---------------------------|------------------------------------------------------------| \n+| getClimatizationEnabled               | void             | Boolean                   | Returns the enabled state of climatization                 | \n+| setClimatizationEnabled               | Boolean          | void                      | Sets the enabled state of climatization                    | \n+| getChargingMode                       | void             | String                    | Gets the charging-mode, see valid options below            | \n+| setChargingMode                       | String           | void                      | Sets the charging-mode, see valid options below            | \n+| getPreferredWindowStart               | void             | LocalTime                 | Returns the preferred charging-window start time           | \n+| setPreferredWindowStart               | LocalTime        | void                      | Sets the preferred charging-window start time              | \n+| getPreferredWindowEnd                 | void             | LocalTime                 | Returns the preferred charging-window end time             | \n+| setPreferredWindowEnd                 | LocalTime        | void                      | Sets the preferred charging-window end time                | \n+| getTimer*X*Enabled                    | void             | Boolean                   | Returns the enabled state of timer*X*                      | \n+| setTimer*X*Enabled                    | Boolean          | void                      | Returns the enabled state of timer*X*                      | \n+| getTimer*X*Departure                  | void             | LocalTime                 | Returns the departure time of timer*X*                     | \n+| setTimer*X*Departure                  | LocalTime        | void                      | Sets the timer*X* departure time                           | \n+| getTimer*X*Days                       | void             | Set<DayOfWeek>            | Returns the days of week timer*X* is enabled for           | \n+| setTimer*X*Days                       | Set<DayOfWeek>   | void                      | sets the days of week timer*X* is enabled for              | \n+| getOverrideTimerEnabled               | void             | Boolean                   | Returns the enabled state of override timer                | \n+| setOverrideTimerEnabled               | Boolean          | void                      | Sets the enabled state of override timer                   | \n+| getOverrideTimerDeparture             | void             | LocalTime                 | Returns the departure time of override timer               | \n+| setOverrideTimerDeparture             | LocalTime        | void                      | Sets the override timer departure time                     | \n+| getOverrideTimerDays                  | void             | Set<DayOfWeek>            | Returns the days of week the overrideTimer is enabled for  | \n+| setOverrideTimerDays                  | Set<DayOfWeek>   | void                      | Sets the days of week the overrideTimer is enabled for     | \n+| cancel                                | void             | void                      | Sends the charging profile to the vehicle                  | \n+| send                                  | void             | void                      | Cancel current edit of charging profile                    | \n+\n+Values for valid charging mode get/set\n+\n+* *IMMEDIATE_CHARGING*\n+* *DELAYED_CHARGING*\n+\n+\n+## Further Descriptions\n+\n+### Dynamic Data\n+\n+<img align=\"right\" src=\"./doc/ServiceOptions.png\" width=\"400\" height=\"350\"/>\n+\n+There are 3 occurrences of dynamic data delivered\n+\n+* Upcoming Services delivered in group [Services](#services)\n+* Check Control Messages delivered in group [Check Control](#check-control)\n+* Last Destinations delivered in group [Destinations](#destinations)\n+\n+The channel id _name_ shows the first element as default. \n+All other possibilities are attached as options. \n+The picture on the right shows the _Service Name_ item and all four possible options. \n+Select the desired service and the corresponding _Service Date & Milage_ will be shown.  \n+\n+### TroubleShooting\n+\n+BMW has a high range of vehicles supported by ConnectedDrive.\n+In case of any issues with this binding help to resolve it! \n+Please perform the following steps:\n+\n+* Can you [log into ConnectedDrive](https://www.bmw-connecteddrive.com/country-region-select/country-region-selection.html) with your credentials? Please note this isn't the BMW Customer portal - it's the ConnectedDrive portal\n+* Is the vehicle listed in your account? There's a one-to-one relation from user to vehicle\n+\n+If the access to the portal is working and the vehicle is listed some debug data is needed in order to identify the issue. \n+\n+#### Generate Debug Fingerprint\n+\n+If you checked the above pre-conditions you need to get the debug fingerprint from the logs.\n+First [enable debug logging](https://www.openhab.org/docs/administration/logging.html#defining-what-to-log) for the binding.\n+\n+```\n+log:set DEBUG org.openhab.binding.bmwconnecteddrive\n+```\n+\n+The debug fingerprint is generated immediately after the vehicle thing is initialized the first time, e.g. after openHAB startup. \n+To force a new fingerprint disable the thing shortly and enable it again. \n+Personal data is eliminated from the log entries so it should be possible to share them in public.\n+Data like\n+\n+* Dealer Properties\n+* Vehicle Identification Number (VIN)\n+* Location latitude / longitude \n+\n+are anonymized.\n+You'll find the fingerprint in the logs with the command\n+\n+```\n+grep \"BMW ConnectedDrive Binding\" openhab.log\n+```\n+\n+After the corresponding fingerprint is generated please [follow the instructions to raise an issue](https://community.openhab.org/t/how-to-file-an-issue/68464) and attach the fingerprint data!\n+Your feedback is highly appreciated!\n+\n+\n+### Range vs Range Radius\n+\n+<img align=\"right\" src=\"./doc/range-radius.png\" width=\"400\" height=\"350\"/>\n+\n+You will observe differences in the vehicle range and range radius values. \n+While range is indicating the possible distance to be driven on roads the range radius indicates the reachable range on the map.\n+\n+The right picture shows the distance between Kassel and Frankfurt in Germany. \n+While the air-line distance is ~145 kilometer the route distance is ~192 kilometer.\n+So range value is the normal remaining range while the range radius values can be used e.g. on [Mapview](https://www.openhab.org/docs/configuration/sitemaps.html#element-type-mapview) to indicate the reachable range on map.\n+Please note this is just an indicator of the effective range.\n+Especially for electric vehicles it depends on many factors like driving style and usage of electric consumers. \n+\n+## Full Example\n+\n+The example is based on a BMW i3 with range extender (REX). \n+Exchange the three configuration parameters in the Things section\n+\n+* YOUR_USERNAME - with your ConnectedDrive login username\n+* YOUR_PASSWORD - with your ConnectedDrive password credentials\n+* VEHICLE_VIN - the vehicle identification number\n+\n+In addition search for all occurrences of *i3* and replace it with your Vehicle Identification like *x3* or *535d* and you're ready to go!\n+\n+### Things File\n+\n+```\n+Bridge bmwconnecteddrive:account:user   \"BMW ConnectedDrive Account\" [userName=\"YOUR_USERNAME\",password=\"YOUR_PASSWORD\",region=\"ROW\"] {\n+         Thing bev_rex i3       \"BMW i3 94h REX\"                [ vin=\"VEHICLE_VIN\",units=\"AUTODETECT\",imageSize=600,imageViewport=\"FRONT\",refreshInterval=5]\n+}\n+```\n+\n+### Items File\n+\n+```\n+Number:Length           i3Mileage                 \"Odometer [%d %unit%]\"                        <line>          (i3)        {channel=\"bmwconnecteddrive:bev_rex:user:i3:range#mileage\" }                                                                           \n+Number:Length           i3Range                   \"Range [%d %unit%]\"                           <motion>        (i3)        {channel=\"bmwconnecteddrive:bev_rex:user:i3:range#hybrid\"}\n+Number:Length           i3RangeElectric           \"Electric Range [%d %unit%]\"                  <motion>        (i3,long)   {channel=\"bmwconnecteddrive:bev_rex:user:i3:range#electric\"}   \n+Number:Length           i3RangeFuel               \"Fuel Range [%d %unit%]\"                      <motion>        (i3)        {channel=\"bmwconnecteddrive:bev_rex:user:i3:range#fuel\"}\n+Number:Dimensionless    i3BatterySoc              \"Battery Charge [%.1f %%]\"                    <battery>       (i3,long)   {channel=\"bmwconnecteddrive:bev_rex:user:i3:range#soc\"}\n+Number:Volume           i3Fuel                    \"Fuel [%.1f %unit%]\"                          <oil>           (i3)        {channel=\"bmwconnecteddrive:bev_rex:user:i3:range#remaining-fuel\"}\n+Number:Length           i3RadiusElectric          \"Electric Radius [%d %unit%]\"                 <zoom>          (i3)        {channel=\"bmwconnecteddrive:bev_rex:user:i3:range#radius-electric\" }\n+Number:Length           i3RadiusHybrid            \"Hybrid Radius [%d %unit%]\"                   <zoom>          (i3)        {channel=\"bmwconnecteddrive:bev_rex:user:i3:range#radius-hybrid\" }\n+\n+String                  i3DoorStatus              \"Door Status [%s]\"                            <lock>          (i3)        {channel=\"bmwconnecteddrive:bev_rex:user:i3:status#doors\" }\n+String                  i3WindowStatus            \"Window Status [%s]\"                          <lock>          (i3)        {channel=\"bmwconnecteddrive:bev_rex:user:i3:status#windows\" }\n+String                  i3LockStatus              \"Lock Status [%s]\"                            <lock>          (i3)        {channel=\"bmwconnecteddrive:bev_rex:user:i3:status#lock\" }\n+DateTime                i3NextServiceDate         \"Next Service Date [%1$tb %1$tY]\"             <calendar>      (i3)        {channel=\"bmwconnecteddrive:bev_rex:user:i3:status#service-date\" }\n+String                  i3NextServiceMileage      \"Next Service Mileage [%d %unit%]\"            <line>          (i3)        {channel=\"bmwconnecteddrive:bev_rex:user:i3:status#service-mileage\" }\n+String                  i3CheckControl            \"Check Control [%s]\"                          <error>         (i3)        {channel=\"bmwconnecteddrive:bev_rex:user:i3:status#check-control\" }\n+String                  i3ChargingStatus          \"Charging [%s]\"                               <energy>        (i3)        {channel=\"bmwconnecteddrive:bev_rex:user:i3:status#charge\" } \n+DateTime                i3LastUpdate              \"Update [%1$tA, %1$td.%1$tm. %1$tH:%1$tM]\"    <calendar>      (i3)        {channel=\"bmwconnecteddrive:bev_rex:user:i3:status#last-update\"}\n+\n+DateTime                i3TripDateTime            \"Trip Date [%1$tA, %1$td.%1$tm. %1$tH:%1$tM]\" <calendar>      (i3)        {channel=\"bmwconnecteddrive:bev_rex:user:i3:last-trip#date\"}\n+Number:Time             i3TripDuration            \"Trip Duration [%d %unit%]\"                   <time>          (i3)        {channel=\"bmwconnecteddrive:bev_rex:user:i3:last-trip#duration\"}\n+Number:Length           i3TripDistance            \"Distance [%d %unit%]\"                        <line>          (i3)        {channel=\"bmwconnecteddrive:bev_rex:user:i3:last-trip#distance\" }                                                                           \n+Number:Length           i3TripDistanceSinceCharge \"Distance since last Charge [%d %unit%]\"      <line>          (i3,long)   {channel=\"bmwconnecteddrive:bev_rex:user:i3:last-trip#distance-since-charging\" }                                                                           \n+Number:Energy           i3AvgTripConsumption      \"Average Consumption [%.1f %unit%]\"           <energy>        (i3)        {channel=\"bmwconnecteddrive:bev_rex:user:i3:last-trip#avg-consumption\" }                                                                           \n+Number:Volume           i3AvgTripCombined         \"Average Combined Consumption [%.1f %unit%]\"  <oil>           (i3)        {channel=\"bmwconnecteddrive:bev_rex:user:i3:last-trip#avg-combined-consumption\" }                                                                           \n+Number:Energy           i3AvgTripRecuperation     \"Average Recuperation [%.1f %unit%]\"          <energy>        (i3)        {channel=\"bmwconnecteddrive:bev_rex:user:i3:last-trip#avg-recuperation\" }                                                                           \n+\n+Number:Length           i3TotalElectric           \"Electric Distance Driven [%d %unit%]\"        <line>          (i3)        {channel=\"bmwconnecteddrive:bev_rex:user:i3:lifetime#total-driven-distance\" }                                                                           \n+Number:Length           i3LongestEVTrip           \"Longest Electric Trip [%d %unit%]\"           <line>          (i3)        {channel=\"bmwconnecteddrive:bev_rex:user:i3:lifetime#single-longest-distance\" }                                                                           \n+Number:Energy           i3AvgConsumption          \"Average Consumption [%.1f %unit%]\"           <energy>        (i3)        {channel=\"bmwconnecteddrive:bev_rex:user:i3:lifetime#avg-consumption\" }                                                                           \n+Number:Volume           i3AvgCombined             \"Average Combined Consumption [%.1f %unit%]\"  <oil>           (i3)        {channel=\"bmwconnecteddrive:bev_rex:user:i3:lifetime#avg-combined-consumption\" }                                                                           \n+Number:Energy           i3AvgRecuperation         \"Average Recuperation [%.1f %unit%]\"          <energy>        (i3)        {channel=\"bmwconnecteddrive:bev_rex:user:i3:lifetime#avg-recuperation\" }  \n+\n+Location                i3Location                \"Location  [%s]\"                              <zoom>          (i3)        {channel=\"bmwconnecteddrive:bev_rex:user:i3:location#gps\" }                                                                           \n+Number:Angle            i3Heading                 \"Heading [%.1f %unit%]\"                       <zoom>          (i3)        {channel=\"bmwconnecteddrive:bev_rex:user:i3:location#heading\" }  \n+\n+String                  i3RemoteCommand           \"Command [%s]\"                                <switch>        (i3)        {channel=\"bmwconnecteddrive:bev_rex:user:i3:remote#command\" } \n+String                  i3RemoteState             \"Remote Execution State [%s]\"                 <status>        (i3)        {channel=\"bmwconnecteddrive:bev_rex:user:i3:remote#state\" } \n+\n+String                  i3DriverDoor              \"Driver Door [%s]\"                            <lock>          (i3)        {channel=\"bmwconnecteddrive:bev_rex:user:i3:doors#driver-front\" }\n+String                  i3DriverDoorRear          \"Driver Door Rear [%s]\"                       <lock>          (i3)        {channel=\"bmwconnecteddrive:bev_rex:user:i3:doors#driver-rear\" }\n+String                  i3PassengerDoor           \"Passenger Door [%s]\"                         <lock>          (i3)        {channel=\"bmwconnecteddrive:bev_rex:user:i3:doors#passenger-front\" }\n+String                  i3PassengerDoorRear       \"Passenger Door Rear [%s]\"                    <lock>          (i3)        {channel=\"bmwconnecteddrive:bev_rex:user:i3:doors#passenger-rear\" }\n+String                  i3Hood                    \"Hood [%s]\"                                   <lock>          (i3)        {channel=\"bmwconnecteddrive:bev_rex:user:i3:doors#hood\" }\n+String                  i3Trunk                   \"Trunk [%s]\"                                  <lock>          (i3)        {channel=\"bmwconnecteddrive:bev_rex:user:i3:doors#trunk\" }\n+String                  i3DriverWindow            \"Driver Window [%s]\"                          <lock>          (i3)        {channel=\"bmwconnecteddrive:bev_rex:user:i3:doors#win-driver-front\" }\n+String                  i3DriverWindowRear        \"Driver Window Rear [%s]\"                     <lock>          (i3)        {channel=\"bmwconnecteddrive:bev_rex:user:i3:doors#win-driver-rear\" }\n+String                  i3PassengerWindow         \"Passenger Window [%s]\"                       <lock>          (i3)        {channel=\"bmwconnecteddrive:bev_rex:user:i3:doors#win-passenger-front\" }\n+String                  i3PassengerWindowRear     \"Passenger Window Rear [%s]\"                  <lock>          (i3)        {channel=\"bmwconnecteddrive:bev_rex:user:i3:doors#win-passenger-rear\" }\n+String                  i3RearWindow              \"Rear Window [%s]\"                            <lock>          (i3)        {channel=\"bmwconnecteddrive:bev_rex:user:i3:doors#win-rear\" }\n+String                  i3Sunroof                 \"Sunroof [%s]\"                                <lock>          (i3)        {channel=\"bmwconnecteddrive:bev_rex:user:i3:doors#sunroof\" }\n+\n+String                  i3ServiceName             \"Service Name [%s]\"                           <text>          (i3)        {channel=\"bmwconnecteddrive:bev_rex:user:i3:service#name\" }\n+String                  i3ServiceDetails          \"Service Details [%s]\"                        <text>          (i3)        {channel=\"bmwconnecteddrive:bev_rex:user:i3:service#details\" }\n+Number:Length           i3ServiceMileage          \"Service Mileage [%d %unit%]\"                 <line>          (i3)        {channel=\"bmwconnecteddrive:bev_rex:user:i3:service#mileage\" }\n+DateTime                i3ServiceDate             \"Service Date [%1$tb %1$tY]\"                  <calendar>      (i3)        {channel=\"bmwconnecteddrive:bev_rex:user:i3:service#date\" }\n+\n+String                  i3CCName                  \"CheckControl Name [%s]\"                      <text>          (i3)        {channel=\"bmwconnecteddrive:bev_rex:user:i3:check#name\" }\n+String                  i3CCDetails               \"CheckControl Details [%s]\"                   <text>          (i3)        {channel=\"bmwconnecteddrive:bev_rex:user:i3:check#details\" }\n+Number:Length           i3CCMileage               \"CheckControl Mileage [%d %unit%]\"            <line>          (i3)        {channel=\"bmwconnecteddrive:bev_rex:user:i3:check#mileage\" }\n+\n+String                  i3DestName                \"Destination [%s]\"                            <house>         (i3)        {channel=\"bmwconnecteddrive:bev_rex:user:i3:destination#name\" } \n+Location                i3DestLocation            \"GPS [%s]\"                                    <zoom>          (i3)        {channel=\"bmwconnecteddrive:bev_rex:user:i3:destination#gps\" }                                                                           \n+ \n+Switch                  i3ChargeProfileClimate    \"Charge Profile Climatization\"                <temperature>   (i3)        {channel=\"bmwconnecteddrive:bev_rex:user:i3:charge#profile-climate\" }  \n+String                  i3ChargeProfileMode       \"Charge Profile Mode [%s]\"                    <energy>        (i3)        {channel=\"bmwconnecteddrive:bev_rex:user:i3:charge#profile-mode\" } \n+DateTime                i3ChargeWindowStart       \"Charge Window Start [%1$tH:%1$tM]\"           <time>          (i3)        {channel=\"bmwconnecteddrive:bev_rex:user:i3:charge#window-start\" } \n+Number                  i3ChargeWindowStartHour   \"Charge Window Start Hour [%d]\"               <time>          (i3)        {channel=\"bmwconnecteddrive:bev_rex:user:i3:charge#window-start-hour\" } \n+Number                  i3ChargeWindowStartMinute \"Charge Window Start Minute [%d]\"             <time>          (i3)        {channel=\"bmwconnecteddrive:bev_rex:user:i3:charge#window-start-minute\" } \n+DateTime                i3ChargeWindowEnd         \"Charge Window End [%1$tH:%1$tM]\"             <time>          (i3)        {channel=\"bmwconnecteddrive:bev_rex:user:i3:charge#window-end\" } \n+Number                  i3ChargeWindowEndHour     \"Charge Window End Hour [%d]\"                 <time>          (i3)        {channel=\"bmwconnecteddrive:bev_rex:user:i3:charge#window-end-hour\" } \n+Number                  i3ChargeWindowEndMinute   \"Charge Window End Minute [%d]\"               <time>          (i3)        {channel=\"bmwconnecteddrive:bev_rex:user:i3:charge#window-end-minute\" } \n+DateTime                i3Timer1Departure         \"Timer 1 Departure [%1$tH:%1$tM]\"             <time>          (i3)        {channel=\"bmwconnecteddrive:bev_rex:user:i3:charge#timer1-departure\" } \n+Number                  i3Timer1DepartureHour     \"Timer 1 Departure Hour [%d]\"                 <time>          (i3)        {channel=\"bmwconnecteddrive:bev_rex:user:i3:charge#timer1-departure-hour\" } \n+Number                  i3Timer1DepartureMinute   \"Timer 1 Departure Minute [%d]\"               <time>          (i3)        {channel=\"bmwconnecteddrive:bev_rex:user:i3:charge#timer1-departure-minute\" } \n+String                  i3Timer1Days              \"Timer 1 Days [%s]\"                           <calendar>      (i3)        {channel=\"bmwconnecteddrive:bev_rex:user:i3:charge#timer1-days\" } \n+Switch                  i3Timer1DayMon            \"Timer 1 Monday\"                              <calendar>      (i3)        {channel=\"bmwconnecteddrive:bev_rex:user:i3:charge#timer1-day-mon\" } \n+Switch                  i3Timer1DayTue            \"Timer 1 Tuesday\"                             <calendar>      (i3)        {channel=\"bmwconnecteddrive:bev_rex:user:i3:charge#timer1-day-tue\" } \n+Switch                  i3Timer1DayWed            \"Timer 1 Wednesday\"                           <calendar>      (i3)        {channel=\"bmwconnecteddrive:bev_rex:user:i3:charge#timer1-day-wed\" } \n+Switch                  i3Timer1DayThu            \"Timer 1 Thursday\"                            <calendar>      (i3)        {channel=\"bmwconnecteddrive:bev_rex:user:i3:charge#timer1-day-thu\" } \n+Switch                  i3Timer1DayFri            \"Timer 1 Friday\"                              <calendar>      (i3)        {channel=\"bmwconnecteddrive:bev_rex:user:i3:charge#timer1-day-fri\" } \n+Switch                  i3Timer1DaySat            \"Timer 1 Saturday\"                            <calendar>      (i3)        {channel=\"bmwconnecteddrive:bev_rex:user:i3:charge#timer1-day-sat\" } \n+Switch                  i3Timer1DaySun            \"Timer 1 Sunday\"                              <calendar>      (i3)        {channel=\"bmwconnecteddrive:bev_rex:user:i3:charge#timer1-day-sun\" } \n+Switch                  i3Timer1Enabled           \"Timer 1 Enabled\"                             <switch>        (i3)        {channel=\"bmwconnecteddrive:bev_rex:user:i3:charge#timer1-enabled\" }  \n+DateTime                i3Timer2Departure         \"Timer 2 Departure [%1$tH:%1$tM]\"             <time>          (i3)        {channel=\"bmwconnecteddrive:bev_rex:user:i3:charge#timer2-departure\" } \n+Number                  i3Timer2DepartureHour     \"Timer 2 Departure Hour [%d]\"                 <time>          (i3)        {channel=\"bmwconnecteddrive:bev_rex:user:i3:charge#timer2-departure-hour\" } \n+Number                  i3Timer2DepartureMinute   \"Timer 2 Departure Minute [%d]\"               <time>          (i3)        {channel=\"bmwconnecteddrive:bev_rex:user:i3:charge#timer2-departure-minute\" } \n+String                  i3Timer2Days              \"Timer 2 Days [%s]\"                           <calendar>      (i3)        {channel=\"bmwconnecteddrive:bev_rex:user:i3:charge#timer2-days\" } \n+Switch                  i3Timer2DayMon            \"Timer 2 Monday\"                              <calendar>      (i3)        {channel=\"bmwconnecteddrive:bev_rex:user:i3:charge#timer2-day-mon\" } \n+Switch                  i3Timer2DayTue            \"Timer 2 Tuesday\"                             <calendar>      (i3)        {channel=\"bmwconnecteddrive:bev_rex:user:i3:charge#timer2-day-tue\" } \n+Switch                  i3Timer2DayWed            \"Timer 2 Wednesday\"                           <calendar>      (i3)        {channel=\"bmwconnecteddrive:bev_rex:user:i3:charge#timer2-day-wed\" } \n+Switch                  i3Timer2DayThu            \"Timer 2 Thursday\"                            <calendar>      (i3)        {channel=\"bmwconnecteddrive:bev_rex:user:i3:charge#timer2-day-thu\" } \n+Switch                  i3Timer2DayFri            \"Timer 2 Friday\"                              <calendar>      (i3)        {channel=\"bmwconnecteddrive:bev_rex:user:i3:charge#timer2-day-fri\" } \n+Switch                  i3Timer2DaySat            \"Timer 2 Saturday\"                            <calendar>      (i3)        {channel=\"bmwconnecteddrive:bev_rex:user:i3:charge#timer2-day-sat\" } \n+Switch                  i3Timer2DaySun            \"Timer 2 Sunday\"                              <calendar>      (i3)        {channel=\"bmwconnecteddrive:bev_rex:user:i3:charge#timer2-day-sun\" } \n+Switch                  i3Timer2Enabled           \"Timer 2 Enabled\"                             <switch>        (i3)        {channel=\"bmwconnecteddrive:bev_rex:user:i3:charge#timer2-enabled\" }  \n+DateTime                i3Timer3Departure         \"Timer 3 Departure [%1$tH:%1$tM]\"             <time>          (i3)        {channel=\"bmwconnecteddrive:bev_rex:user:i3:charge#timer3-departure\" } \n+Number                  i3Timer3DepartureHour     \"Timer 3 Departure Hour [%d]\"                 <time>          (i3)        {channel=\"bmwconnecteddrive:bev_rex:user:i3:charge#timer3-departure-hour\" } \n+Number                  i3Timer3DepartureMinute   \"Timer 3 Departure Minute [%d]\"               <time>          (i3)        {channel=\"bmwconnecteddrive:bev_rex:user:i3:charge#timer3-departure-minute\" } \n+String                  i3Timer3Days              \"Timer 3 Days [%s]\"                           <calendar>      (i3)        {channel=\"bmwconnecteddrive:bev_rex:user:i3:charge#timer3-days\" } \n+Switch                  i3Timer3DayMon            \"Timer 3 Monday\"                              <calendar>      (i3)        {channel=\"bmwconnecteddrive:bev_rex:user:i3:charge#timer3-day-mon\" } \n+Switch                  i3Timer3DayTue            \"Timer 3 Tuesday\"                             <calendar>      (i3)        {channel=\"bmwconnecteddrive:bev_rex:user:i3:charge#timer3-day-tue\" } \n+Switch                  i3Timer3DayWed            \"Timer 3 Wednesday\"                           <calendar>      (i3)        {channel=\"bmwconnecteddrive:bev_rex:user:i3:charge#timer3-day-wed\" } \n+Switch                  i3Timer3DayThu            \"Timer 3 Thursday\"                            <calendar>      (i3)        {channel=\"bmwconnecteddrive:bev_rex:user:i3:charge#timer3-day-thu\" } \n+Switch                  i3Timer3DayFri            \"Timer 3 Friday\"                              <calendar>      (i3)        {channel=\"bmwconnecteddrive:bev_rex:user:i3:charge#timer3-day-fri\" } \n+Switch                  i3Timer3DaySat            \"Timer 3 Saturday\"                            <calendar>      (i3)        {channel=\"bmwconnecteddrive:bev_rex:user:i3:charge#timer3-day-sat\" } \n+Switch                  i3Timer3DaySun            \"Timer 3 Sunday\"                              <calendar>      (i3)        {channel=\"bmwconnecteddrive:bev_rex:user:i3:charge#timer3-day-sun\" } \n+Switch                  i3Timer3Enabled           \"Timer 3 Enabled\"                             <switch>        (i3)        {channel=\"bmwconnecteddrive:bev_rex:user:i3:charge#timer3-enabled\" }\n+Switch                  i3OverrideEnabled         \"Override Timer Enabled\"                      <switch>        (i3)        {channel=\"bmwconnecteddrive:bev_rex:user:i3:charge#override-enabled\"}\n+DateTime                i3OverrideDeparture       \"Override Timer Departure [%1$tH:%1$tM]\"      <time>          (i3)        {channel=\"bmwconnecteddrive:bev_rex:user:i3:charge#override-departure\" } \n+Number                  i3OverrideDepartureHour   \"Override Timer Departure Hour [%d]\"          <time>          (i3)        {channel=\"bmwconnecteddrive:bev_rex:user:i3:charge#override-departure-hour\" } \n+Number                  i3OverrideDepartureMinute \"Override Timer Departure Minute [%d]\"        <time>          (i3)        {channel=\"bmwconnecteddrive:bev_rex:user:i3:charge#override-departure-minute\" } \n+\n+Image                   i3Image                   \"Image\"                                                       (i3)        {channel=\"bmwconnecteddrive:bev_rex:user:i3:image#png\" }  \n+String                  i3ImageViewport           \"Image Viewport [%s]\"                         <zoom>          (i3)        {channel=\"bmwconnecteddrive:bev_rex:user:i3:image#view\" }  \n+Number                  i3ImageSize               \"Image Size [%d]\"                             <zoom>          (i3)        {channel=\"bmwconnecteddrive:bev_rex:user:i3:image#size\" }  \n+```\n+\n+### Sitemap File\n+\n+```\n+sitemap BMW label=\"BMW\" {\n+  Frame label=\"BMW i3\" {\n+    Image  item=i3Image  \n+                       \n+  } \n+  Frame label=\"Range\" {\n+    Text    item=i3Mileage           \n+    Text    item=i3Range             \n+    Text    item=i3RangeElectric     \n+    Text    item=i3RangeFuel         \n+    Text    item=i3BatterySoc        \n+    Text    item=i3Fuel              \n+    Text    item=i3RadiusElectric       \n+    Text    item=i3RadiusHybrid         \n+  }\n+  Frame label=\"Status\" {\n+    Text    item=i3DoorStatus           \n+    Text    item=i3WindowStatus         \n+    Text    item=i3LockStatus           \n+    Text    item=i3NextServiceDate              \n+    Text    item=i3NextServiceMileage       \n+    Text    item=i3CheckControl         \n+    Text    item=i3ChargingStatus           \n+    Text    item=i3LastUpdate               \n+  }\n+  Frame label=\"Remote Services\" {\n+    Selection item=i3RemoteCommand              \n+    Text      item=i3RemoteState              \n+  }\n+  Frame label=\"Last Trip\" {\n+    Text    item=i3TripDateTime            \n+    Text    item=i3TripDuration            \n+    Text    item=i3TripDistance            \n+    Text    item=i3TripDistanceSinceCharge \n+    Text    item=i3AvgTripConsumption      \n+    Text    item=i3AvgTripRecuperation     \n+    Text    item=i3AvgTripCombined     \n+  }\n+  Frame label=\"Lifetime\" {\n+    Text    item=i3TotalElectric  \n+    Text    item=i3LongestEVTrip      \n+    Text    item=i3AvgConsumption     \n+    Text    item=i3AvgRecuperation          \n+    Text    item=i3AvgCombined          \n+  }\n+  Frame label=\"Services\" {\n+    Text    item=i3ServiceName          \n+    Text    item=i3ServiceMileage          \n+    Text    item=i3ServiceDate          \n+  }\n+  Frame label=\"CheckControl\" {\n+    Text    item=i3CCName          \n+    Text    item=i3CCMileage          \n+  }\n+  Frame label=\"Door Details\" {\n+    Text    item=i3DriverDoor visibility=[i3DriverDoor!=\"INVALID\"]\n+    Text    item=i3DriverDoorRear visibility=[i3DriverDoorRear!=\"INVALID\"]  \n+    Text    item=i3PassengerDoor visibility=[i3PassengerDoor!=\"INVALID\"]\n+    Text    item=i3PassengerDoorRear visibility=[i3PassengerDoorRear!=\"INVALID\"]\n+    Text    item=i3Hood visibility=[i3Hood!=\"INVALID\"]\n+    Text    item=i3Trunk visibility=[i3Trunk!=\"INVALID\"]\n+    Text    item=i3DriverWindow visibility=[i3DriverWindow!=\"INVALID\"]\n+    Text    item=i3DriverWindowRear visibility=[i3DriverWindowRear!=\"INVALID\"]\n+    Text    item=i3PassengerWindow visibility=[i3PassengerWindow!=\"INVALID\"]\n+    Text    item=i3PassengerWindowRear visibility=[i3PassengerWindowRear!=\"INVALID\"]\n+    Text    item=i3RearWindow visibility=[i3RearWindow!=\"INVALID\"]\n+    Text    item=i3Sunroof visibility=[i3Sunroof!=\"INVALID\"]\n+  }\n+  Frame label=\"Location\" {\n+    Text    item=i3Location          \n+    Text    item=i3Heading             \n+  }\n+  Frame label=\"Charge Profile\" {    \n+    Switch    item=i3ChargeProfileClimate     \n+    Selection item=i3ChargeProfileMode        \n+    Text      item=i3ChargeWindowStart        \n+    Setpoint  item=i3ChargeWindowStartHour maxValue=23 step=1 icon=\"time\"\n+    Setpoint  item=i3ChargeWindowStartMinute maxValue=55 step=5 icon=\"time\"\n+    Text      item=i3ChargeWindowEnd          \n+    Setpoint  item=i3ChargeWindowEndHour maxValue=23 step=1 icon=\"time\"\n+    Setpoint  item=i3ChargeWindowEndMinute maxValue=55 step=5 icon=\"time\"\n+    Text      item=i3Timer1Departure          \n+    Setpoint  item=i3Timer1DepartureHour maxValue=23 step=1 icon=\"time\"\n+    Setpoint  item=i3Timer1DepartureMinute maxValue=55 step=5 icon=\"time\"\n+    Text      item=i3Timer1Days               \n+    Switch    item=i3Timer1DayMon            \n+    Switch    item=i3Timer1DayTue            \n+    Switch    item=i3Timer1DayWed            \n+    Switch    item=i3Timer1DayThu            \n+    Switch    item=i3Timer1DayFri            \n+    Switch    item=i3Timer1DaySat            \n+    Switch    item=i3Timer1DaySun            \n+    Switch    item=i3Timer1Enabled            \n+    Text      item=i3Timer2Departure          \n+    Setpoint  item=i3Timer2DepartureHour maxValue=23 step=1 icon=\"time\"\n+    Setpoint  item=i3Timer2DepartureMinute maxValue=55 step=5 icon=\"time\"\n+    Text      item=i3Timer2Days               \n+    Switch    item=i3Timer2DayMon            \n+    Switch    item=i3Timer2DayTue            \n+    Switch    item=i3Timer2DayWed            \n+    Switch    item=i3Timer2DayThu            \n+    Switch    item=i3Timer2DayFri            \n+    Switch    item=i3Timer2DaySat            \n+    Switch    item=i3Timer2DaySun            \n+    Switch    item=i3Timer2Enabled            \n+    Text      item=i3Timer3Departure          \n+    Setpoint  item=i3Timer3DepartureHour maxValue=23 step=1 icon=\"time\"\n+    Setpoint  item=i3Timer3DepartureMinute maxValue=55 step=5 icon=\"time\"\n+    Text      item=i3Timer3Days               \n+    Switch    item=i3Timer3DayMon            \n+    Switch    item=i3Timer3DayTue            \n+    Switch    item=i3Timer3DayWed            \n+    Switch    item=i3Timer3DayThu            \n+    Switch    item=i3Timer3DayFri            \n+    Switch    item=i3Timer3DaySat            \n+    Switch    item=i3Timer3DaySun            \n+    Switch    item=i3Timer3Enabled            \n+    Switch    item=i3OverrideEnabled            \n+    Text      item=i3OverrideDeparture          \n+    Setpoint  item=i3OverrideDepartureHour maxValue=23 step=1 icon=\"time\"\n+    Setpoint  item=i3OverrideDepartureMinute maxValue=55 step=5 icon=\"time\"\n+  } \n+  Frame label=\"Last Destinations\" {    \n+    Text  item=i3DestName                 \n+    Text  item=i3DestLocation                                                                                   \n+  }  \n+  Frame label=\"Image Properties\" {\n+    Text    item=i3ImageViewport\n+    Text    item=i3ImageSize \n+  } \n+}\n+```\n+\n+### Action example\n+\n+```\n+  val profile = getActions(\"chargeprofile\", \"bmwconnecteddrive:bev_rex:user:i3\")\n+  val now = ZonedDateTime.now.toLocalTime\n+  profile.setChargingMode(\"DELAYED_CHARGING\")\n+  profile.setTimer1Departure(now.minusHours(2))\n+  profile.setTimer1Days(java.util.Set())\n+  profile.setTimer1Enabled(true)\n+  profile.setTimer2Enabled(false)\n+  profile.setTimer3Enabled(false)\n+  profile.setPreferredWindowStart(now.minusHours(6))\n+  profile.setPreferredWindowEnd(now.minusHours(2))\n+  profile.send()", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5Nzk1MDEzNA=="}, "originalCommit": {"oid": "48af48c82562d006b6f2aa35922270f181c885ed"}, "originalPosition": 842}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzgwMjkwMTMxOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/VehicleHandler.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0yNVQyMjozMDoxNFrOI9_2-w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0yOFQxNjo1MToxM1rOI--QHg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMTg4MDMxNQ==", "bodyText": "I get a compile-error here - method 'setThingStatus' being unknown.\nfixed in weymann#12", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r601880315", "createdAt": "2021-03-25T22:30:14Z", "author": {"login": "ntruchsess"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/VehicleHandler.java", "diffHunk": "@@ -0,0 +1,796 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bmwconnecteddrive.internal.handler;\n+\n+import static org.openhab.binding.bmwconnecteddrive.internal.ConnectedDriveConstants.*;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.bmwconnecteddrive.internal.VehicleConfiguration;\n+import org.openhab.binding.bmwconnecteddrive.internal.action.ChargeProfileActions;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.DestinationContainer;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.NetworkError;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.compat.VehicleAttributesContainer;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.statistics.AllTrips;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.statistics.AllTripsContainer;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.statistics.LastTrip;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.statistics.LastTripContainer;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.status.VehicleStatus;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.status.VehicleStatusContainer;\n+import org.openhab.binding.bmwconnecteddrive.internal.handler.RemoteServiceHandler.ExecutionState;\n+import org.openhab.binding.bmwconnecteddrive.internal.handler.RemoteServiceHandler.RemoteService;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileUtils;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileUtils.ChargeKeyDay;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileUtils.ChargeKeyHour;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileWrapper;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileWrapper.ProfileKey;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Constants;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Converter;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ImageProperties;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.RemoteServiceUtils;\n+import org.openhab.core.io.net.http.HttpUtil;\n+import org.openhab.core.library.types.DecimalType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.RawType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BridgeHandler;\n+import org.openhab.core.thing.binding.ThingHandlerService;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+\n+import com.google.gson.JsonSyntaxException;\n+\n+/**\n+ * The {@link VehicleHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Bernd Weymann - Initial contribution\n+ * @author Norbert Truchsess - edit & send charge profile\n+ */\n+@NonNullByDefault\n+public class VehicleHandler extends VehicleChannelHandler {\n+    private boolean legacyMode = false; // switch to legacy API in case of 404 Errors\n+\n+    private Optional<ConnectedDriveProxy> proxy = Optional.empty();\n+    private Optional<RemoteServiceHandler> remote = Optional.empty();\n+    private Optional<VehicleConfiguration> configuration = Optional.empty();\n+    private Optional<ConnectedDriveBridgeHandler> bridgeHandler = Optional.empty();\n+    private Optional<ScheduledFuture<?>> refreshJob = Optional.empty();\n+    private Optional<ScheduledFuture<?>> editTimeout = Optional.empty();\n+    private Optional<List<ResponseCallback>> callbackCounter = Optional.empty();\n+\n+    private ImageProperties imageProperties = new ImageProperties();\n+    VehicleStatusCallback vehicleStatusCallback = new VehicleStatusCallback();\n+    StringResponseCallback oldVehicleStatusCallback = new LegacyVehicleStatusCallback();\n+    StringResponseCallback lastTripCallback = new LastTripCallback();\n+    StringResponseCallback allTripsCallback = new AllTripsCallback();\n+    StringResponseCallback chargeProfileCallback = new ChargeProfilesCallback();\n+    StringResponseCallback rangeMapCallback = new RangeMapCallback();\n+    DestinationsCallback destinationCallback = new DestinationsCallback();\n+    ByteResponseCallback imageCallback = new ImageCallback();\n+\n+    private Optional<ChargeProfileWrapper> chargeProfileEdit = Optional.empty();\n+    private Optional<String> chargeProfileSent = Optional.empty();\n+\n+    public VehicleHandler(Thing thing, BMWConnectedDriveOptionProvider op, String type, boolean imperial) {\n+        super(thing, op, type, imperial);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        String group = channelUID.getGroupId();\n+\n+        // Refresh of Channels with cached values\n+        if (command instanceof RefreshType) {\n+            if (CHANNEL_GROUP_LAST_TRIP.equals(group)) {\n+                lastTripCache.ifPresent(lastTrip -> lastTripCallback.onResponse(lastTrip));\n+            } else if (CHANNEL_GROUP_LIFETIME.equals(group)) {\n+                allTripsCache.ifPresent(allTrips -> allTripsCallback.onResponse(allTrips));\n+            } else if (CHANNEL_GROUP_DESTINATION.equals(group)) {\n+                destinationCache.ifPresent(destination -> destinationCallback.onResponse(destination));\n+            } else if (CHANNEL_GROUP_STATUS.equals(group)) {\n+                vehicleStatusCache.ifPresent(vehicleStatus -> vehicleStatusCallback.onResponse(vehicleStatus));\n+            } else if (CHANNEL_GROUP_CHARGE.equals(group)) {\n+                chargeProfileEdit.ifPresentOrElse(this::updateChargeProfile,\n+                        () -> chargeProfileCache.ifPresent(this::updateChargeProfileFromContent));\n+            } else if (CHANNEL_GROUP_VEHICLE_IMAGE.equals(group)) {\n+                imageCache.ifPresent(image -> imageCallback.onResponse(image));\n+            }\n+            // Check for Channel Group and corresponding Actions\n+        } else if (CHANNEL_GROUP_REMOTE.equals(group)) {\n+            // Executing Remote Services\n+            if (command instanceof StringType) {\n+                String serviceCommand = ((StringType) command).toFullString();\n+                remote.ifPresent(remot -> {\n+                    switch (serviceCommand) {\n+                        case REMOTE_SERVICE_LIGHT_FLASH:\n+                        case REMOTE_SERVICE_AIR_CONDITIONING:\n+                        case REMOTE_SERVICE_DOOR_LOCK:\n+                        case REMOTE_SERVICE_DOOR_UNLOCK:\n+                        case REMOTE_SERVICE_HORN:\n+                        case REMOTE_SERVICE_VEHICLE_FINDER:\n+                        case REMOTE_SERVICE_CHARGE_NOW:\n+                            RemoteServiceUtils.getRemoteService(serviceCommand)\n+                                    .ifPresentOrElse(service -> remot.execute(service), () -> {\n+                                        logger.debug(\"Remote service execution {} unknown\", serviceCommand);\n+                                    });\n+                            break;\n+                        case REMOTE_SERVICE_CHARGING_CONTROL:\n+                            sendChargeProfile(chargeProfileEdit);\n+                            break;\n+                        default:\n+                            logger.debug(\"Remote service execution {} unknown\", serviceCommand);\n+                            break;\n+                    }\n+                });\n+            }\n+        } else if (CHANNEL_GROUP_VEHICLE_IMAGE.equals(group)) {\n+            // Image Change\n+            configuration.ifPresent(config -> {\n+                if (command instanceof StringType) {\n+                    if (channelUID.getIdWithoutGroup().equals(IMAGE_VIEWPORT)) {\n+                        String newViewport = command.toString();\n+                        synchronized (imageProperties) {\n+                            if (!imageProperties.viewport.equals(newViewport)) {\n+                                imageProperties = new ImageProperties(newViewport, imageProperties.size);\n+                                imageCache = Optional.empty();\n+                                proxy.ifPresent(prox -> prox.requestImage(config, imageProperties, imageCallback));\n+                            }\n+                        }\n+                        updateChannel(CHANNEL_GROUP_VEHICLE_IMAGE, IMAGE_VIEWPORT, StringType.valueOf(newViewport));\n+                    }\n+                }\n+                if (command instanceof DecimalType) {\n+                    if (command instanceof DecimalType) {\n+                        int newImageSize = ((DecimalType) command).intValue();\n+                        if (channelUID.getIdWithoutGroup().equals(IMAGE_SIZE)) {\n+                            synchronized (imageProperties) {\n+                                if (imageProperties.size != newImageSize) {\n+                                    imageProperties = new ImageProperties(imageProperties.viewport, newImageSize);\n+                                    imageCache = Optional.empty();\n+                                    proxy.ifPresent(prox -> prox.requestImage(config, imageProperties, imageCallback));\n+                                }\n+                            }\n+                        }\n+                        updateChannel(CHANNEL_GROUP_VEHICLE_IMAGE, IMAGE_SIZE, new DecimalType(newImageSize));\n+                    }\n+                }\n+            });\n+        } else if (CHANNEL_GROUP_DESTINATION.equals(group)) {\n+            if (command instanceof StringType) {\n+                int index = Converter.getIndex(command.toFullString());\n+                if (index != -1) {\n+                    selectDestination(index);\n+                } else {\n+                    logger.debug(\"Cannot select Destination index {}\", command.toFullString());\n+                }\n+            }\n+        } else if (CHANNEL_GROUP_SERVICE.equals(group)) {\n+            if (command instanceof StringType) {\n+                int index = Converter.getIndex(command.toFullString());\n+                if (index != -1) {\n+                    selectService(index);\n+                } else {\n+                    logger.debug(\"Cannot select Service index {}\", command.toFullString());\n+                }\n+            }\n+        } else if (CHANNEL_GROUP_CHECK_CONTROL.equals(group)) {\n+            if (command instanceof StringType) {\n+                int index = Converter.getIndex(command.toFullString());\n+                if (index != -1) {\n+                    selectCheckControl(index);\n+                } else {\n+                    logger.debug(\"Cannot select CheckControl index {}\", command.toFullString());\n+                }\n+            }\n+        } else if (CHANNEL_GROUP_CHARGE.equals(group)) {\n+            handleChargeProfileCommand(channelUID, command);\n+        }\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        callbackCounter = Optional.of(new ArrayList<ResponseCallback>());\n+        updateStatus(ThingStatus.UNKNOWN);\n+        final VehicleConfiguration config = getConfigAs(VehicleConfiguration.class);\n+        configuration = Optional.of(config);\n+        scheduler.execute(() -> {\n+            Bridge bridge = getBridge();\n+            if (bridge != null) {\n+                BridgeHandler handler = bridge.getHandler();\n+                if (handler != null) {\n+                    bridgeHandler = Optional.of(((ConnectedDriveBridgeHandler) handler));\n+                    proxy = ((ConnectedDriveBridgeHandler) handler).getProxy();\n+                    remote = proxy.map(prox -> prox.getRemoteServiceHandler(this));\n+                } else {\n+                    logger.debug(\"Bridge Handler null\");\n+                }\n+            } else {\n+                logger.debug(\"Bridge null\");\n+            }\n+\n+            // get Image after init with config values\n+            synchronized (imageProperties) {\n+                imageProperties = new ImageProperties(config.imageViewport, config.imageSize);\n+            }\n+            updateChannel(CHANNEL_GROUP_VEHICLE_IMAGE, IMAGE_VIEWPORT, StringType.valueOf((config.imageViewport)));\n+            updateChannel(CHANNEL_GROUP_VEHICLE_IMAGE, IMAGE_SIZE, new DecimalType((config.imageSize)));\n+\n+            // check imperial setting is different to AutoDetect\n+            if (!UNITS_AUTODETECT.equals(config.units)) {\n+                imperial = UNITS_IMPERIAL.equals(config.units);\n+            }\n+\n+            // start update schedule\n+            startSchedule(config.refreshInterval);\n+        });\n+    }\n+\n+    private void startSchedule(int interval) {\n+        refreshJob.ifPresentOrElse(job -> {\n+            if (job.isCancelled()) {\n+                refreshJob = Optional\n+                        .of(scheduler.scheduleWithFixedDelay(this::getData, 0, interval, TimeUnit.MINUTES));\n+            } // else - scheduler is already running!\n+        }, () -> {\n+            refreshJob = Optional.of(scheduler.scheduleWithFixedDelay(this::getData, 0, interval, TimeUnit.MINUTES));\n+        });\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        refreshJob.ifPresent(job -> job.cancel(true));\n+        editTimeout.ifPresent(job -> job.cancel(true));\n+        remote.ifPresent(RemoteServiceHandler::cancel);\n+    }\n+\n+    public void getData() {\n+        proxy.ifPresentOrElse(prox -> {\n+            configuration.ifPresentOrElse(config -> {\n+                if (!legacyMode) {\n+                    prox.requestVehcileStatus(config, vehicleStatusCallback);\n+                } else {\n+                    prox.requestLegacyVehcileStatus(config, oldVehicleStatusCallback);\n+                }\n+                addCallback(vehicleStatusCallback);\n+                if (isSupported(Constants.STATISTICS)) {\n+                    prox.requestLastTrip(config, lastTripCallback);\n+                    prox.requestAllTrips(config, allTripsCallback);\n+                    addCallback(lastTripCallback);\n+                    addCallback(allTripsCallback);\n+                }\n+                if (isSupported(Constants.LAST_DESTINATIONS)) {\n+                    prox.requestDestinations(config, destinationCallback);\n+                    addCallback(destinationCallback);\n+                }\n+                if (isElectric) {\n+                    prox.requestChargingProfile(config, chargeProfileCallback);\n+                    addCallback(chargeProfileCallback);\n+                }\n+                synchronized (imageProperties) {\n+                    if (!imageCache.isPresent() && !imageProperties.failLimitReached()) {\n+                        prox.requestImage(config, imageProperties, imageCallback);\n+                        addCallback(imageCallback);\n+                    }\n+                }\n+            }, () -> {\n+                logger.warn(\"ConnectedDrive Configuration isn't present\");\n+            });\n+        }, () -> {\n+            logger.warn(\"ConnectedDrive Proxy isn't present\");\n+        });\n+    }\n+\n+    private synchronized void addCallback(ResponseCallback rc) {\n+        callbackCounter.ifPresent(counter -> counter.add(rc));\n+    }\n+\n+    private synchronized void removeCallback(ResponseCallback rc) {\n+        callbackCounter.ifPresent(counter -> {\n+            counter.remove(rc);\n+            // all necessary callbacks received => print and set to empty\n+            if (counter.isEmpty()) {\n+                logFingerPrint();\n+                callbackCounter = Optional.empty();\n+            }\n+        });\n+    }\n+\n+    private void logFingerPrint() {\n+        final String vin = configuration.map(config -> config.vin).orElse(\"\");\n+        logger.debug(\"###### Vehicle Troubleshoot Fingerprint Data - BEGIN ######\");\n+        logger.debug(\"### Discovery Result ###\");\n+        bridgeHandler.ifPresent(handler -> {\n+            logger.debug(\"{}\", handler.getDiscoveryFingerprint());\n+        });\n+        vehicleStatusCache.ifPresentOrElse(vehicleStatus -> {\n+            logger.debug(\"### Vehicle Status ###\");\n+\n+            // Anonymous data for VIN and Position\n+            try {\n+                VehicleStatusContainer container = Converter.getGson().fromJson(vehicleStatus,\n+                        VehicleStatusContainer.class);\n+                if (container != null) {\n+                    VehicleStatus status = container.vehicleStatus;\n+                    if (status != null) {\n+                        status.vin = Constants.ANONYMOUS;\n+                        if (status.position != null) {\n+                            status.position.lat = -1;\n+                            status.position.lon = -1;\n+                            status.position.heading = -1;\n+                        }\n+                    }\n+                }\n+                logger.debug(\"{}\", Converter.getGson().toJson(container));\n+            } catch (JsonSyntaxException jse) {\n+                logger.debug(\"{}\", jse.getMessage());\n+            }\n+        }, () -> {\n+            logger.debug(\"### Vehicle Status Empty ###\");\n+        });\n+        lastTripCache.ifPresentOrElse(lastTrip -> {\n+            logger.debug(\"### Last Trip ###\");\n+            logger.debug(\"{}\", lastTrip.replaceAll(vin, Constants.ANONYMOUS));\n+        }, () -> {\n+            logger.debug(\"### Last Trip Empty ###\");\n+        });\n+        allTripsCache.ifPresentOrElse(allTrips -> {\n+            logger.debug(\"### All Trips ###\");\n+            logger.debug(\"{}\", allTrips.replaceAll(vin, Constants.ANONYMOUS));\n+        }, () -> {\n+            logger.debug(\"### All Trips Empty ###\");\n+        });\n+        if (isElectric) {\n+            chargeProfileCache.ifPresentOrElse(chargeProfile -> {\n+                logger.debug(\"### Charge Profile ###\");\n+                logger.debug(\"{}\", chargeProfile.replaceAll(vin, Constants.ANONYMOUS));\n+            }, () -> {\n+                logger.debug(\"### Charge Profile Empty ###\");\n+            });\n+        }\n+        destinationCache.ifPresentOrElse(destination -> {\n+            logger.debug(\"### Charge Profile ###\");\n+            try {\n+                DestinationContainer container = Converter.getGson().fromJson(destination, DestinationContainer.class);\n+                if (container != null) {\n+                    if (container.destinations != null) {\n+                        container.destinations.forEach(entry -> {\n+                            entry.lat = 0;\n+                            entry.lon = 0;\n+                            entry.city = Constants.ANONYMOUS;\n+                            entry.street = Constants.ANONYMOUS;\n+                            entry.streetNumber = Constants.ANONYMOUS;\n+                            entry.country = Constants.ANONYMOUS;\n+                        });\n+                        logger.debug(\"{}\", Converter.getGson().toJson(container));\n+                    }\n+                } else {\n+                    logger.debug(\"### Destinations Empty ###\");\n+                }\n+            } catch (JsonSyntaxException jse) {\n+                logger.debug(\"{}\", jse.getMessage());\n+            }\n+        }, () -> {\n+            logger.debug(\"### Charge Profile Empty ###\");\n+        });\n+        rangeMapCache.ifPresentOrElse(rangeMap -> {\n+            logger.debug(\"### Range Map ###\");\n+            logger.debug(\"{}\", rangeMap.replaceAll(vin, Constants.ANONYMOUS));\n+        }, () -> {\n+            logger.debug(\"### Range Map Empty ###\");\n+        });\n+        logger.debug(\"###### Vehicle Troubleshoot Fingerprint Data - END ######\");\n+    }\n+\n+    /**\n+     * Don't stress ConnectedDrive with unnecessary requests. One call at the beginning is done to check the response.\n+     * After cache has e.g. a proper error response it will be shown in the fingerprint\n+     *\n+     * @return\n+     */\n+    private boolean isSupported(String service) {\n+        final String services = thing.getProperties().get(Constants.SERVICES_SUPPORTED);\n+        if (services != null) {\n+            if (services.contains(service)) {\n+                return true;\n+            }\n+        }\n+        // if cache is empty give it a try one time to collected Troubleshoot data\n+        return lastTripCache.isEmpty() || allTripsCache.isEmpty() || destinationCache.isEmpty();\n+    }\n+\n+    public void updateRemoteExecutionStatus(@Nullable String service, @Nullable String status) {\n+        if (RemoteService.CHARGING_CONTROL.toString().equals(service)\n+                && ExecutionState.EXECUTED.name().equals(status)) {\n+            saveChargeProfileSent();\n+        }\n+        updateChannel(CHANNEL_GROUP_REMOTE, REMOTE_STATE, StringType\n+                .valueOf(Converter.toTitleCase((service == null ? \"-\" : service) + Constants.SPACE + status)));\n+    }\n+\n+    public Optional<VehicleConfiguration> getConfiguration() {\n+        return configuration;\n+    }\n+\n+    public ScheduledExecutorService getScheduler() {\n+        return scheduler;\n+    }\n+\n+    /**\n+     * Callbacks for ConnectedDrive Portal\n+     *\n+     * @author Bernd Weymann\n+     *\n+     */\n+    public class ChargeProfilesCallback implements StringResponseCallback {\n+        @Override\n+        public void onResponse(@Nullable String content) {\n+            if (content != null) {\n+                chargeProfileCache = Optional.of(content);\n+                if (chargeProfileEdit.isEmpty()) {\n+                    updateChargeProfileFromContent(content);\n+                }\n+            }\n+            removeCallback(this);\n+        }\n+\n+        /**\n+         * Store Error Report in cache variable. Via Fingerprint Channel error is logged and Issue can be raised\n+         */\n+        @Override\n+        public void onError(NetworkError error) {\n+            logger.debug(\"{}\", error.toString());\n+            chargeProfileCache = Optional.of(Converter.getGson().toJson(error));\n+            removeCallback(this);\n+        }\n+    }\n+\n+    public class RangeMapCallback implements StringResponseCallback {\n+        @Override\n+        public void onResponse(@Nullable String content) {\n+            rangeMapCache = Optional.ofNullable(content);\n+            removeCallback(this);\n+        }\n+\n+        /**\n+         * Store Error Report in cache variable. Via Fingerprint Channel error is logged and Issue can be raised\n+         */\n+        @Override\n+        public void onError(NetworkError error) {\n+            logger.debug(\"{}\", error.toString());\n+            rangeMapCache = Optional.of(Converter.getGson().toJson(error));\n+            removeCallback(this);\n+        }\n+    }\n+\n+    public class DestinationsCallback implements StringResponseCallback {\n+\n+        @Override\n+        public void onResponse(@Nullable String content) {\n+            destinationCache = Optional.ofNullable(content);\n+            if (content != null) {\n+                try {\n+                    DestinationContainer dc = Converter.getGson().fromJson(content, DestinationContainer.class);\n+                    if (dc != null && dc.destinations != null) {\n+                        updateDestinations(dc.destinations);\n+                    }\n+                } catch (JsonSyntaxException jse) {\n+                    logger.debug(\"{}\", jse.getMessage());\n+                }\n+            }\n+            removeCallback(this);\n+        }\n+\n+        /**\n+         * Store Error Report in cache variable. Via Fingerprint Channel error is logged and Issue can be raised\n+         */\n+        @Override\n+        public void onError(NetworkError error) {\n+            logger.debug(\"{}\", error.toString());\n+            destinationCache = Optional.of(Converter.getGson().toJson(error));\n+            removeCallback(this);\n+        }\n+    }\n+\n+    public class ImageCallback implements ByteResponseCallback {\n+        @Override\n+        public void onResponse(byte[] content) {\n+            if (content.length > 0) {\n+                imageCache = Optional.of(content);\n+                String contentType = HttpUtil.guessContentTypeFromData(content);\n+                updateChannel(CHANNEL_GROUP_VEHICLE_IMAGE, IMAGE_FORMAT, new RawType(content, contentType));\n+            } else {\n+                synchronized (imageProperties) {\n+                    imageProperties.failed();\n+                }\n+            }\n+            removeCallback(this);\n+        }\n+\n+        /**\n+         * Store Error Report in cache variable. Via Fingerprint Channel error is logged and Issue can be raised\n+         */\n+        @Override\n+        public void onError(NetworkError error) {\n+            logger.debug(\"{}\", error.toString());\n+            synchronized (imageProperties) {\n+                imageProperties.failed();\n+            }\n+            removeCallback(this);\n+        }\n+    }\n+\n+    public class AllTripsCallback implements StringResponseCallback {\n+        @Override\n+        public void onResponse(@Nullable String content) {\n+            if (content != null) {\n+                allTripsCache = Optional.of(content);\n+                try {\n+                    AllTripsContainer atc = Converter.getGson().fromJson(content, AllTripsContainer.class);\n+                    if (atc != null) {\n+                        AllTrips at = atc.allTrips;\n+                        if (at != null) {\n+                            updateAllTrips(at);\n+                        }\n+                    }\n+                } catch (JsonSyntaxException jse) {\n+                    logger.debug(\"{}\", jse.getMessage());\n+                }\n+            }\n+            removeCallback(this);\n+        }\n+\n+        /**\n+         * Store Error Report in cache variable. Via Fingerprint Channel error is logged and Issue can be raised\n+         */\n+        @Override\n+        public void onError(NetworkError error) {\n+            logger.debug(\"{}\", error.toString());\n+            allTripsCache = Optional.of(Converter.getGson().toJson(error));\n+            removeCallback(this);\n+        }\n+    }\n+\n+    public class LastTripCallback implements StringResponseCallback {\n+        @Override\n+        public void onResponse(@Nullable String content) {\n+            if (content != null) {\n+                lastTripCache = Optional.of(content);\n+                try {\n+                    LastTripContainer lt = Converter.getGson().fromJson(content, LastTripContainer.class);\n+                    if (lt != null) {\n+                        LastTrip trip = lt.lastTrip;\n+                        if (trip != null) {\n+                            updateLastTrip(trip);\n+                        }\n+                    }\n+                } catch (JsonSyntaxException jse) {\n+                    logger.debug(\"{}\", jse.getMessage());\n+                }\n+            }\n+            removeCallback(this);\n+        }\n+\n+        /**\n+         * Store Error Report in cache variable. Via Fingerprint Channel error is logged and Issue can be raised\n+         */\n+        @Override\n+        public void onError(NetworkError error) {\n+            logger.debug(\"{}\", error.toString());\n+            lastTripCache = Optional.of(Converter.getGson().toJson(error));\n+            removeCallback(this);\n+        }\n+    }\n+\n+    /**\n+     * The VehicleStatus is supported by all Vehicle Types so it's used to reflect the Thing Status\n+     */\n+    public class VehicleStatusCallback implements StringResponseCallback {\n+        private ThingStatus thingStatus = ThingStatus.UNKNOWN;\n+\n+        @Override\n+        public void onResponse(@Nullable String content) {\n+            if (content != null) {\n+                updateStatus(ThingStatus.ONLINE);\n+                vehicleStatusCache = Optional.of(content);\n+                try {\n+                    VehicleStatusContainer status = Converter.getGson().fromJson(content, VehicleStatusContainer.class);\n+                    if (status != null) {\n+                        VehicleStatus vStatus = status.vehicleStatus;\n+                        if (vStatus == null) {\n+                            return;\n+                        }\n+                        updateVehicleStatus(vStatus);\n+                        updateCheckControls(vStatus.checkControlMessages);\n+                        updateServices(vStatus.cbsData);\n+                        updatePosition(vStatus.position);\n+                    }\n+                } catch (JsonSyntaxException jse) {\n+                    logger.debug(\"{}\", jse.getMessage());\n+                }\n+            }\n+            removeCallback(this);\n+        }\n+\n+        @Override\n+        public void onError(NetworkError error) {\n+            logger.debug(\"{}\", error.toString());\n+            if (error.status == 404) {\n+                legacyMode = true;\n+                logger.debug(\"VehicleStatus not found - switch to legacy API\");\n+                proxy.get().requestLegacyVehcileStatus(configuration.get(), oldVehicleStatusCallback);\n+            }\n+            vehicleStatusCache = Optional.of(Converter.getGson().toJson(error));\n+            setThingStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, error.reason);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5a568b041a01f7b8cd6e1290a8d969c40369480a"}, "originalPosition": 648}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMjgxMjYyNA==", "bodyText": "Last 3 builds are working fine - perhaps rebase with the newest baseline missing with the latest review changes?", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r602812624", "createdAt": "2021-03-28T01:07:12Z", "author": {"login": "weymann"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/VehicleHandler.java", "diffHunk": "@@ -0,0 +1,796 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bmwconnecteddrive.internal.handler;\n+\n+import static org.openhab.binding.bmwconnecteddrive.internal.ConnectedDriveConstants.*;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.bmwconnecteddrive.internal.VehicleConfiguration;\n+import org.openhab.binding.bmwconnecteddrive.internal.action.ChargeProfileActions;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.DestinationContainer;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.NetworkError;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.compat.VehicleAttributesContainer;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.statistics.AllTrips;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.statistics.AllTripsContainer;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.statistics.LastTrip;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.statistics.LastTripContainer;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.status.VehicleStatus;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.status.VehicleStatusContainer;\n+import org.openhab.binding.bmwconnecteddrive.internal.handler.RemoteServiceHandler.ExecutionState;\n+import org.openhab.binding.bmwconnecteddrive.internal.handler.RemoteServiceHandler.RemoteService;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileUtils;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileUtils.ChargeKeyDay;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileUtils.ChargeKeyHour;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileWrapper;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileWrapper.ProfileKey;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Constants;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Converter;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ImageProperties;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.RemoteServiceUtils;\n+import org.openhab.core.io.net.http.HttpUtil;\n+import org.openhab.core.library.types.DecimalType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.RawType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BridgeHandler;\n+import org.openhab.core.thing.binding.ThingHandlerService;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+\n+import com.google.gson.JsonSyntaxException;\n+\n+/**\n+ * The {@link VehicleHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Bernd Weymann - Initial contribution\n+ * @author Norbert Truchsess - edit & send charge profile\n+ */\n+@NonNullByDefault\n+public class VehicleHandler extends VehicleChannelHandler {\n+    private boolean legacyMode = false; // switch to legacy API in case of 404 Errors\n+\n+    private Optional<ConnectedDriveProxy> proxy = Optional.empty();\n+    private Optional<RemoteServiceHandler> remote = Optional.empty();\n+    private Optional<VehicleConfiguration> configuration = Optional.empty();\n+    private Optional<ConnectedDriveBridgeHandler> bridgeHandler = Optional.empty();\n+    private Optional<ScheduledFuture<?>> refreshJob = Optional.empty();\n+    private Optional<ScheduledFuture<?>> editTimeout = Optional.empty();\n+    private Optional<List<ResponseCallback>> callbackCounter = Optional.empty();\n+\n+    private ImageProperties imageProperties = new ImageProperties();\n+    VehicleStatusCallback vehicleStatusCallback = new VehicleStatusCallback();\n+    StringResponseCallback oldVehicleStatusCallback = new LegacyVehicleStatusCallback();\n+    StringResponseCallback lastTripCallback = new LastTripCallback();\n+    StringResponseCallback allTripsCallback = new AllTripsCallback();\n+    StringResponseCallback chargeProfileCallback = new ChargeProfilesCallback();\n+    StringResponseCallback rangeMapCallback = new RangeMapCallback();\n+    DestinationsCallback destinationCallback = new DestinationsCallback();\n+    ByteResponseCallback imageCallback = new ImageCallback();\n+\n+    private Optional<ChargeProfileWrapper> chargeProfileEdit = Optional.empty();\n+    private Optional<String> chargeProfileSent = Optional.empty();\n+\n+    public VehicleHandler(Thing thing, BMWConnectedDriveOptionProvider op, String type, boolean imperial) {\n+        super(thing, op, type, imperial);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        String group = channelUID.getGroupId();\n+\n+        // Refresh of Channels with cached values\n+        if (command instanceof RefreshType) {\n+            if (CHANNEL_GROUP_LAST_TRIP.equals(group)) {\n+                lastTripCache.ifPresent(lastTrip -> lastTripCallback.onResponse(lastTrip));\n+            } else if (CHANNEL_GROUP_LIFETIME.equals(group)) {\n+                allTripsCache.ifPresent(allTrips -> allTripsCallback.onResponse(allTrips));\n+            } else if (CHANNEL_GROUP_DESTINATION.equals(group)) {\n+                destinationCache.ifPresent(destination -> destinationCallback.onResponse(destination));\n+            } else if (CHANNEL_GROUP_STATUS.equals(group)) {\n+                vehicleStatusCache.ifPresent(vehicleStatus -> vehicleStatusCallback.onResponse(vehicleStatus));\n+            } else if (CHANNEL_GROUP_CHARGE.equals(group)) {\n+                chargeProfileEdit.ifPresentOrElse(this::updateChargeProfile,\n+                        () -> chargeProfileCache.ifPresent(this::updateChargeProfileFromContent));\n+            } else if (CHANNEL_GROUP_VEHICLE_IMAGE.equals(group)) {\n+                imageCache.ifPresent(image -> imageCallback.onResponse(image));\n+            }\n+            // Check for Channel Group and corresponding Actions\n+        } else if (CHANNEL_GROUP_REMOTE.equals(group)) {\n+            // Executing Remote Services\n+            if (command instanceof StringType) {\n+                String serviceCommand = ((StringType) command).toFullString();\n+                remote.ifPresent(remot -> {\n+                    switch (serviceCommand) {\n+                        case REMOTE_SERVICE_LIGHT_FLASH:\n+                        case REMOTE_SERVICE_AIR_CONDITIONING:\n+                        case REMOTE_SERVICE_DOOR_LOCK:\n+                        case REMOTE_SERVICE_DOOR_UNLOCK:\n+                        case REMOTE_SERVICE_HORN:\n+                        case REMOTE_SERVICE_VEHICLE_FINDER:\n+                        case REMOTE_SERVICE_CHARGE_NOW:\n+                            RemoteServiceUtils.getRemoteService(serviceCommand)\n+                                    .ifPresentOrElse(service -> remot.execute(service), () -> {\n+                                        logger.debug(\"Remote service execution {} unknown\", serviceCommand);\n+                                    });\n+                            break;\n+                        case REMOTE_SERVICE_CHARGING_CONTROL:\n+                            sendChargeProfile(chargeProfileEdit);\n+                            break;\n+                        default:\n+                            logger.debug(\"Remote service execution {} unknown\", serviceCommand);\n+                            break;\n+                    }\n+                });\n+            }\n+        } else if (CHANNEL_GROUP_VEHICLE_IMAGE.equals(group)) {\n+            // Image Change\n+            configuration.ifPresent(config -> {\n+                if (command instanceof StringType) {\n+                    if (channelUID.getIdWithoutGroup().equals(IMAGE_VIEWPORT)) {\n+                        String newViewport = command.toString();\n+                        synchronized (imageProperties) {\n+                            if (!imageProperties.viewport.equals(newViewport)) {\n+                                imageProperties = new ImageProperties(newViewport, imageProperties.size);\n+                                imageCache = Optional.empty();\n+                                proxy.ifPresent(prox -> prox.requestImage(config, imageProperties, imageCallback));\n+                            }\n+                        }\n+                        updateChannel(CHANNEL_GROUP_VEHICLE_IMAGE, IMAGE_VIEWPORT, StringType.valueOf(newViewport));\n+                    }\n+                }\n+                if (command instanceof DecimalType) {\n+                    if (command instanceof DecimalType) {\n+                        int newImageSize = ((DecimalType) command).intValue();\n+                        if (channelUID.getIdWithoutGroup().equals(IMAGE_SIZE)) {\n+                            synchronized (imageProperties) {\n+                                if (imageProperties.size != newImageSize) {\n+                                    imageProperties = new ImageProperties(imageProperties.viewport, newImageSize);\n+                                    imageCache = Optional.empty();\n+                                    proxy.ifPresent(prox -> prox.requestImage(config, imageProperties, imageCallback));\n+                                }\n+                            }\n+                        }\n+                        updateChannel(CHANNEL_GROUP_VEHICLE_IMAGE, IMAGE_SIZE, new DecimalType(newImageSize));\n+                    }\n+                }\n+            });\n+        } else if (CHANNEL_GROUP_DESTINATION.equals(group)) {\n+            if (command instanceof StringType) {\n+                int index = Converter.getIndex(command.toFullString());\n+                if (index != -1) {\n+                    selectDestination(index);\n+                } else {\n+                    logger.debug(\"Cannot select Destination index {}\", command.toFullString());\n+                }\n+            }\n+        } else if (CHANNEL_GROUP_SERVICE.equals(group)) {\n+            if (command instanceof StringType) {\n+                int index = Converter.getIndex(command.toFullString());\n+                if (index != -1) {\n+                    selectService(index);\n+                } else {\n+                    logger.debug(\"Cannot select Service index {}\", command.toFullString());\n+                }\n+            }\n+        } else if (CHANNEL_GROUP_CHECK_CONTROL.equals(group)) {\n+            if (command instanceof StringType) {\n+                int index = Converter.getIndex(command.toFullString());\n+                if (index != -1) {\n+                    selectCheckControl(index);\n+                } else {\n+                    logger.debug(\"Cannot select CheckControl index {}\", command.toFullString());\n+                }\n+            }\n+        } else if (CHANNEL_GROUP_CHARGE.equals(group)) {\n+            handleChargeProfileCommand(channelUID, command);\n+        }\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        callbackCounter = Optional.of(new ArrayList<ResponseCallback>());\n+        updateStatus(ThingStatus.UNKNOWN);\n+        final VehicleConfiguration config = getConfigAs(VehicleConfiguration.class);\n+        configuration = Optional.of(config);\n+        scheduler.execute(() -> {\n+            Bridge bridge = getBridge();\n+            if (bridge != null) {\n+                BridgeHandler handler = bridge.getHandler();\n+                if (handler != null) {\n+                    bridgeHandler = Optional.of(((ConnectedDriveBridgeHandler) handler));\n+                    proxy = ((ConnectedDriveBridgeHandler) handler).getProxy();\n+                    remote = proxy.map(prox -> prox.getRemoteServiceHandler(this));\n+                } else {\n+                    logger.debug(\"Bridge Handler null\");\n+                }\n+            } else {\n+                logger.debug(\"Bridge null\");\n+            }\n+\n+            // get Image after init with config values\n+            synchronized (imageProperties) {\n+                imageProperties = new ImageProperties(config.imageViewport, config.imageSize);\n+            }\n+            updateChannel(CHANNEL_GROUP_VEHICLE_IMAGE, IMAGE_VIEWPORT, StringType.valueOf((config.imageViewport)));\n+            updateChannel(CHANNEL_GROUP_VEHICLE_IMAGE, IMAGE_SIZE, new DecimalType((config.imageSize)));\n+\n+            // check imperial setting is different to AutoDetect\n+            if (!UNITS_AUTODETECT.equals(config.units)) {\n+                imperial = UNITS_IMPERIAL.equals(config.units);\n+            }\n+\n+            // start update schedule\n+            startSchedule(config.refreshInterval);\n+        });\n+    }\n+\n+    private void startSchedule(int interval) {\n+        refreshJob.ifPresentOrElse(job -> {\n+            if (job.isCancelled()) {\n+                refreshJob = Optional\n+                        .of(scheduler.scheduleWithFixedDelay(this::getData, 0, interval, TimeUnit.MINUTES));\n+            } // else - scheduler is already running!\n+        }, () -> {\n+            refreshJob = Optional.of(scheduler.scheduleWithFixedDelay(this::getData, 0, interval, TimeUnit.MINUTES));\n+        });\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        refreshJob.ifPresent(job -> job.cancel(true));\n+        editTimeout.ifPresent(job -> job.cancel(true));\n+        remote.ifPresent(RemoteServiceHandler::cancel);\n+    }\n+\n+    public void getData() {\n+        proxy.ifPresentOrElse(prox -> {\n+            configuration.ifPresentOrElse(config -> {\n+                if (!legacyMode) {\n+                    prox.requestVehcileStatus(config, vehicleStatusCallback);\n+                } else {\n+                    prox.requestLegacyVehcileStatus(config, oldVehicleStatusCallback);\n+                }\n+                addCallback(vehicleStatusCallback);\n+                if (isSupported(Constants.STATISTICS)) {\n+                    prox.requestLastTrip(config, lastTripCallback);\n+                    prox.requestAllTrips(config, allTripsCallback);\n+                    addCallback(lastTripCallback);\n+                    addCallback(allTripsCallback);\n+                }\n+                if (isSupported(Constants.LAST_DESTINATIONS)) {\n+                    prox.requestDestinations(config, destinationCallback);\n+                    addCallback(destinationCallback);\n+                }\n+                if (isElectric) {\n+                    prox.requestChargingProfile(config, chargeProfileCallback);\n+                    addCallback(chargeProfileCallback);\n+                }\n+                synchronized (imageProperties) {\n+                    if (!imageCache.isPresent() && !imageProperties.failLimitReached()) {\n+                        prox.requestImage(config, imageProperties, imageCallback);\n+                        addCallback(imageCallback);\n+                    }\n+                }\n+            }, () -> {\n+                logger.warn(\"ConnectedDrive Configuration isn't present\");\n+            });\n+        }, () -> {\n+            logger.warn(\"ConnectedDrive Proxy isn't present\");\n+        });\n+    }\n+\n+    private synchronized void addCallback(ResponseCallback rc) {\n+        callbackCounter.ifPresent(counter -> counter.add(rc));\n+    }\n+\n+    private synchronized void removeCallback(ResponseCallback rc) {\n+        callbackCounter.ifPresent(counter -> {\n+            counter.remove(rc);\n+            // all necessary callbacks received => print and set to empty\n+            if (counter.isEmpty()) {\n+                logFingerPrint();\n+                callbackCounter = Optional.empty();\n+            }\n+        });\n+    }\n+\n+    private void logFingerPrint() {\n+        final String vin = configuration.map(config -> config.vin).orElse(\"\");\n+        logger.debug(\"###### Vehicle Troubleshoot Fingerprint Data - BEGIN ######\");\n+        logger.debug(\"### Discovery Result ###\");\n+        bridgeHandler.ifPresent(handler -> {\n+            logger.debug(\"{}\", handler.getDiscoveryFingerprint());\n+        });\n+        vehicleStatusCache.ifPresentOrElse(vehicleStatus -> {\n+            logger.debug(\"### Vehicle Status ###\");\n+\n+            // Anonymous data for VIN and Position\n+            try {\n+                VehicleStatusContainer container = Converter.getGson().fromJson(vehicleStatus,\n+                        VehicleStatusContainer.class);\n+                if (container != null) {\n+                    VehicleStatus status = container.vehicleStatus;\n+                    if (status != null) {\n+                        status.vin = Constants.ANONYMOUS;\n+                        if (status.position != null) {\n+                            status.position.lat = -1;\n+                            status.position.lon = -1;\n+                            status.position.heading = -1;\n+                        }\n+                    }\n+                }\n+                logger.debug(\"{}\", Converter.getGson().toJson(container));\n+            } catch (JsonSyntaxException jse) {\n+                logger.debug(\"{}\", jse.getMessage());\n+            }\n+        }, () -> {\n+            logger.debug(\"### Vehicle Status Empty ###\");\n+        });\n+        lastTripCache.ifPresentOrElse(lastTrip -> {\n+            logger.debug(\"### Last Trip ###\");\n+            logger.debug(\"{}\", lastTrip.replaceAll(vin, Constants.ANONYMOUS));\n+        }, () -> {\n+            logger.debug(\"### Last Trip Empty ###\");\n+        });\n+        allTripsCache.ifPresentOrElse(allTrips -> {\n+            logger.debug(\"### All Trips ###\");\n+            logger.debug(\"{}\", allTrips.replaceAll(vin, Constants.ANONYMOUS));\n+        }, () -> {\n+            logger.debug(\"### All Trips Empty ###\");\n+        });\n+        if (isElectric) {\n+            chargeProfileCache.ifPresentOrElse(chargeProfile -> {\n+                logger.debug(\"### Charge Profile ###\");\n+                logger.debug(\"{}\", chargeProfile.replaceAll(vin, Constants.ANONYMOUS));\n+            }, () -> {\n+                logger.debug(\"### Charge Profile Empty ###\");\n+            });\n+        }\n+        destinationCache.ifPresentOrElse(destination -> {\n+            logger.debug(\"### Charge Profile ###\");\n+            try {\n+                DestinationContainer container = Converter.getGson().fromJson(destination, DestinationContainer.class);\n+                if (container != null) {\n+                    if (container.destinations != null) {\n+                        container.destinations.forEach(entry -> {\n+                            entry.lat = 0;\n+                            entry.lon = 0;\n+                            entry.city = Constants.ANONYMOUS;\n+                            entry.street = Constants.ANONYMOUS;\n+                            entry.streetNumber = Constants.ANONYMOUS;\n+                            entry.country = Constants.ANONYMOUS;\n+                        });\n+                        logger.debug(\"{}\", Converter.getGson().toJson(container));\n+                    }\n+                } else {\n+                    logger.debug(\"### Destinations Empty ###\");\n+                }\n+            } catch (JsonSyntaxException jse) {\n+                logger.debug(\"{}\", jse.getMessage());\n+            }\n+        }, () -> {\n+            logger.debug(\"### Charge Profile Empty ###\");\n+        });\n+        rangeMapCache.ifPresentOrElse(rangeMap -> {\n+            logger.debug(\"### Range Map ###\");\n+            logger.debug(\"{}\", rangeMap.replaceAll(vin, Constants.ANONYMOUS));\n+        }, () -> {\n+            logger.debug(\"### Range Map Empty ###\");\n+        });\n+        logger.debug(\"###### Vehicle Troubleshoot Fingerprint Data - END ######\");\n+    }\n+\n+    /**\n+     * Don't stress ConnectedDrive with unnecessary requests. One call at the beginning is done to check the response.\n+     * After cache has e.g. a proper error response it will be shown in the fingerprint\n+     *\n+     * @return\n+     */\n+    private boolean isSupported(String service) {\n+        final String services = thing.getProperties().get(Constants.SERVICES_SUPPORTED);\n+        if (services != null) {\n+            if (services.contains(service)) {\n+                return true;\n+            }\n+        }\n+        // if cache is empty give it a try one time to collected Troubleshoot data\n+        return lastTripCache.isEmpty() || allTripsCache.isEmpty() || destinationCache.isEmpty();\n+    }\n+\n+    public void updateRemoteExecutionStatus(@Nullable String service, @Nullable String status) {\n+        if (RemoteService.CHARGING_CONTROL.toString().equals(service)\n+                && ExecutionState.EXECUTED.name().equals(status)) {\n+            saveChargeProfileSent();\n+        }\n+        updateChannel(CHANNEL_GROUP_REMOTE, REMOTE_STATE, StringType\n+                .valueOf(Converter.toTitleCase((service == null ? \"-\" : service) + Constants.SPACE + status)));\n+    }\n+\n+    public Optional<VehicleConfiguration> getConfiguration() {\n+        return configuration;\n+    }\n+\n+    public ScheduledExecutorService getScheduler() {\n+        return scheduler;\n+    }\n+\n+    /**\n+     * Callbacks for ConnectedDrive Portal\n+     *\n+     * @author Bernd Weymann\n+     *\n+     */\n+    public class ChargeProfilesCallback implements StringResponseCallback {\n+        @Override\n+        public void onResponse(@Nullable String content) {\n+            if (content != null) {\n+                chargeProfileCache = Optional.of(content);\n+                if (chargeProfileEdit.isEmpty()) {\n+                    updateChargeProfileFromContent(content);\n+                }\n+            }\n+            removeCallback(this);\n+        }\n+\n+        /**\n+         * Store Error Report in cache variable. Via Fingerprint Channel error is logged and Issue can be raised\n+         */\n+        @Override\n+        public void onError(NetworkError error) {\n+            logger.debug(\"{}\", error.toString());\n+            chargeProfileCache = Optional.of(Converter.getGson().toJson(error));\n+            removeCallback(this);\n+        }\n+    }\n+\n+    public class RangeMapCallback implements StringResponseCallback {\n+        @Override\n+        public void onResponse(@Nullable String content) {\n+            rangeMapCache = Optional.ofNullable(content);\n+            removeCallback(this);\n+        }\n+\n+        /**\n+         * Store Error Report in cache variable. Via Fingerprint Channel error is logged and Issue can be raised\n+         */\n+        @Override\n+        public void onError(NetworkError error) {\n+            logger.debug(\"{}\", error.toString());\n+            rangeMapCache = Optional.of(Converter.getGson().toJson(error));\n+            removeCallback(this);\n+        }\n+    }\n+\n+    public class DestinationsCallback implements StringResponseCallback {\n+\n+        @Override\n+        public void onResponse(@Nullable String content) {\n+            destinationCache = Optional.ofNullable(content);\n+            if (content != null) {\n+                try {\n+                    DestinationContainer dc = Converter.getGson().fromJson(content, DestinationContainer.class);\n+                    if (dc != null && dc.destinations != null) {\n+                        updateDestinations(dc.destinations);\n+                    }\n+                } catch (JsonSyntaxException jse) {\n+                    logger.debug(\"{}\", jse.getMessage());\n+                }\n+            }\n+            removeCallback(this);\n+        }\n+\n+        /**\n+         * Store Error Report in cache variable. Via Fingerprint Channel error is logged and Issue can be raised\n+         */\n+        @Override\n+        public void onError(NetworkError error) {\n+            logger.debug(\"{}\", error.toString());\n+            destinationCache = Optional.of(Converter.getGson().toJson(error));\n+            removeCallback(this);\n+        }\n+    }\n+\n+    public class ImageCallback implements ByteResponseCallback {\n+        @Override\n+        public void onResponse(byte[] content) {\n+            if (content.length > 0) {\n+                imageCache = Optional.of(content);\n+                String contentType = HttpUtil.guessContentTypeFromData(content);\n+                updateChannel(CHANNEL_GROUP_VEHICLE_IMAGE, IMAGE_FORMAT, new RawType(content, contentType));\n+            } else {\n+                synchronized (imageProperties) {\n+                    imageProperties.failed();\n+                }\n+            }\n+            removeCallback(this);\n+        }\n+\n+        /**\n+         * Store Error Report in cache variable. Via Fingerprint Channel error is logged and Issue can be raised\n+         */\n+        @Override\n+        public void onError(NetworkError error) {\n+            logger.debug(\"{}\", error.toString());\n+            synchronized (imageProperties) {\n+                imageProperties.failed();\n+            }\n+            removeCallback(this);\n+        }\n+    }\n+\n+    public class AllTripsCallback implements StringResponseCallback {\n+        @Override\n+        public void onResponse(@Nullable String content) {\n+            if (content != null) {\n+                allTripsCache = Optional.of(content);\n+                try {\n+                    AllTripsContainer atc = Converter.getGson().fromJson(content, AllTripsContainer.class);\n+                    if (atc != null) {\n+                        AllTrips at = atc.allTrips;\n+                        if (at != null) {\n+                            updateAllTrips(at);\n+                        }\n+                    }\n+                } catch (JsonSyntaxException jse) {\n+                    logger.debug(\"{}\", jse.getMessage());\n+                }\n+            }\n+            removeCallback(this);\n+        }\n+\n+        /**\n+         * Store Error Report in cache variable. Via Fingerprint Channel error is logged and Issue can be raised\n+         */\n+        @Override\n+        public void onError(NetworkError error) {\n+            logger.debug(\"{}\", error.toString());\n+            allTripsCache = Optional.of(Converter.getGson().toJson(error));\n+            removeCallback(this);\n+        }\n+    }\n+\n+    public class LastTripCallback implements StringResponseCallback {\n+        @Override\n+        public void onResponse(@Nullable String content) {\n+            if (content != null) {\n+                lastTripCache = Optional.of(content);\n+                try {\n+                    LastTripContainer lt = Converter.getGson().fromJson(content, LastTripContainer.class);\n+                    if (lt != null) {\n+                        LastTrip trip = lt.lastTrip;\n+                        if (trip != null) {\n+                            updateLastTrip(trip);\n+                        }\n+                    }\n+                } catch (JsonSyntaxException jse) {\n+                    logger.debug(\"{}\", jse.getMessage());\n+                }\n+            }\n+            removeCallback(this);\n+        }\n+\n+        /**\n+         * Store Error Report in cache variable. Via Fingerprint Channel error is logged and Issue can be raised\n+         */\n+        @Override\n+        public void onError(NetworkError error) {\n+            logger.debug(\"{}\", error.toString());\n+            lastTripCache = Optional.of(Converter.getGson().toJson(error));\n+            removeCallback(this);\n+        }\n+    }\n+\n+    /**\n+     * The VehicleStatus is supported by all Vehicle Types so it's used to reflect the Thing Status\n+     */\n+    public class VehicleStatusCallback implements StringResponseCallback {\n+        private ThingStatus thingStatus = ThingStatus.UNKNOWN;\n+\n+        @Override\n+        public void onResponse(@Nullable String content) {\n+            if (content != null) {\n+                updateStatus(ThingStatus.ONLINE);\n+                vehicleStatusCache = Optional.of(content);\n+                try {\n+                    VehicleStatusContainer status = Converter.getGson().fromJson(content, VehicleStatusContainer.class);\n+                    if (status != null) {\n+                        VehicleStatus vStatus = status.vehicleStatus;\n+                        if (vStatus == null) {\n+                            return;\n+                        }\n+                        updateVehicleStatus(vStatus);\n+                        updateCheckControls(vStatus.checkControlMessages);\n+                        updateServices(vStatus.cbsData);\n+                        updatePosition(vStatus.position);\n+                    }\n+                } catch (JsonSyntaxException jse) {\n+                    logger.debug(\"{}\", jse.getMessage());\n+                }\n+            }\n+            removeCallback(this);\n+        }\n+\n+        @Override\n+        public void onError(NetworkError error) {\n+            logger.debug(\"{}\", error.toString());\n+            if (error.status == 404) {\n+                legacyMode = true;\n+                logger.debug(\"VehicleStatus not found - switch to legacy API\");\n+                proxy.get().requestLegacyVehcileStatus(configuration.get(), oldVehicleStatusCallback);\n+            }\n+            vehicleStatusCache = Optional.of(Converter.getGson().toJson(error));\n+            setThingStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, error.reason);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMTg4MDMxNQ=="}, "originalCommit": {"oid": "5a568b041a01f7b8cd6e1290a8d969c40369480a"}, "originalPosition": 648}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMjg2MTQxNg==", "bodyText": "in weymann@5a568b0 you did delete method 'setThingStatus' which caused the compile-error (being resoleved in weymann@3eb30f7).\nI just tried to compile in between.", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r602861416", "createdAt": "2021-03-28T10:30:17Z", "author": {"login": "ntruchsess"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/VehicleHandler.java", "diffHunk": "@@ -0,0 +1,796 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bmwconnecteddrive.internal.handler;\n+\n+import static org.openhab.binding.bmwconnecteddrive.internal.ConnectedDriveConstants.*;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.bmwconnecteddrive.internal.VehicleConfiguration;\n+import org.openhab.binding.bmwconnecteddrive.internal.action.ChargeProfileActions;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.DestinationContainer;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.NetworkError;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.compat.VehicleAttributesContainer;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.statistics.AllTrips;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.statistics.AllTripsContainer;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.statistics.LastTrip;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.statistics.LastTripContainer;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.status.VehicleStatus;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.status.VehicleStatusContainer;\n+import org.openhab.binding.bmwconnecteddrive.internal.handler.RemoteServiceHandler.ExecutionState;\n+import org.openhab.binding.bmwconnecteddrive.internal.handler.RemoteServiceHandler.RemoteService;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileUtils;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileUtils.ChargeKeyDay;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileUtils.ChargeKeyHour;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileWrapper;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileWrapper.ProfileKey;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Constants;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Converter;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ImageProperties;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.RemoteServiceUtils;\n+import org.openhab.core.io.net.http.HttpUtil;\n+import org.openhab.core.library.types.DecimalType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.RawType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BridgeHandler;\n+import org.openhab.core.thing.binding.ThingHandlerService;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+\n+import com.google.gson.JsonSyntaxException;\n+\n+/**\n+ * The {@link VehicleHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Bernd Weymann - Initial contribution\n+ * @author Norbert Truchsess - edit & send charge profile\n+ */\n+@NonNullByDefault\n+public class VehicleHandler extends VehicleChannelHandler {\n+    private boolean legacyMode = false; // switch to legacy API in case of 404 Errors\n+\n+    private Optional<ConnectedDriveProxy> proxy = Optional.empty();\n+    private Optional<RemoteServiceHandler> remote = Optional.empty();\n+    private Optional<VehicleConfiguration> configuration = Optional.empty();\n+    private Optional<ConnectedDriveBridgeHandler> bridgeHandler = Optional.empty();\n+    private Optional<ScheduledFuture<?>> refreshJob = Optional.empty();\n+    private Optional<ScheduledFuture<?>> editTimeout = Optional.empty();\n+    private Optional<List<ResponseCallback>> callbackCounter = Optional.empty();\n+\n+    private ImageProperties imageProperties = new ImageProperties();\n+    VehicleStatusCallback vehicleStatusCallback = new VehicleStatusCallback();\n+    StringResponseCallback oldVehicleStatusCallback = new LegacyVehicleStatusCallback();\n+    StringResponseCallback lastTripCallback = new LastTripCallback();\n+    StringResponseCallback allTripsCallback = new AllTripsCallback();\n+    StringResponseCallback chargeProfileCallback = new ChargeProfilesCallback();\n+    StringResponseCallback rangeMapCallback = new RangeMapCallback();\n+    DestinationsCallback destinationCallback = new DestinationsCallback();\n+    ByteResponseCallback imageCallback = new ImageCallback();\n+\n+    private Optional<ChargeProfileWrapper> chargeProfileEdit = Optional.empty();\n+    private Optional<String> chargeProfileSent = Optional.empty();\n+\n+    public VehicleHandler(Thing thing, BMWConnectedDriveOptionProvider op, String type, boolean imperial) {\n+        super(thing, op, type, imperial);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        String group = channelUID.getGroupId();\n+\n+        // Refresh of Channels with cached values\n+        if (command instanceof RefreshType) {\n+            if (CHANNEL_GROUP_LAST_TRIP.equals(group)) {\n+                lastTripCache.ifPresent(lastTrip -> lastTripCallback.onResponse(lastTrip));\n+            } else if (CHANNEL_GROUP_LIFETIME.equals(group)) {\n+                allTripsCache.ifPresent(allTrips -> allTripsCallback.onResponse(allTrips));\n+            } else if (CHANNEL_GROUP_DESTINATION.equals(group)) {\n+                destinationCache.ifPresent(destination -> destinationCallback.onResponse(destination));\n+            } else if (CHANNEL_GROUP_STATUS.equals(group)) {\n+                vehicleStatusCache.ifPresent(vehicleStatus -> vehicleStatusCallback.onResponse(vehicleStatus));\n+            } else if (CHANNEL_GROUP_CHARGE.equals(group)) {\n+                chargeProfileEdit.ifPresentOrElse(this::updateChargeProfile,\n+                        () -> chargeProfileCache.ifPresent(this::updateChargeProfileFromContent));\n+            } else if (CHANNEL_GROUP_VEHICLE_IMAGE.equals(group)) {\n+                imageCache.ifPresent(image -> imageCallback.onResponse(image));\n+            }\n+            // Check for Channel Group and corresponding Actions\n+        } else if (CHANNEL_GROUP_REMOTE.equals(group)) {\n+            // Executing Remote Services\n+            if (command instanceof StringType) {\n+                String serviceCommand = ((StringType) command).toFullString();\n+                remote.ifPresent(remot -> {\n+                    switch (serviceCommand) {\n+                        case REMOTE_SERVICE_LIGHT_FLASH:\n+                        case REMOTE_SERVICE_AIR_CONDITIONING:\n+                        case REMOTE_SERVICE_DOOR_LOCK:\n+                        case REMOTE_SERVICE_DOOR_UNLOCK:\n+                        case REMOTE_SERVICE_HORN:\n+                        case REMOTE_SERVICE_VEHICLE_FINDER:\n+                        case REMOTE_SERVICE_CHARGE_NOW:\n+                            RemoteServiceUtils.getRemoteService(serviceCommand)\n+                                    .ifPresentOrElse(service -> remot.execute(service), () -> {\n+                                        logger.debug(\"Remote service execution {} unknown\", serviceCommand);\n+                                    });\n+                            break;\n+                        case REMOTE_SERVICE_CHARGING_CONTROL:\n+                            sendChargeProfile(chargeProfileEdit);\n+                            break;\n+                        default:\n+                            logger.debug(\"Remote service execution {} unknown\", serviceCommand);\n+                            break;\n+                    }\n+                });\n+            }\n+        } else if (CHANNEL_GROUP_VEHICLE_IMAGE.equals(group)) {\n+            // Image Change\n+            configuration.ifPresent(config -> {\n+                if (command instanceof StringType) {\n+                    if (channelUID.getIdWithoutGroup().equals(IMAGE_VIEWPORT)) {\n+                        String newViewport = command.toString();\n+                        synchronized (imageProperties) {\n+                            if (!imageProperties.viewport.equals(newViewport)) {\n+                                imageProperties = new ImageProperties(newViewport, imageProperties.size);\n+                                imageCache = Optional.empty();\n+                                proxy.ifPresent(prox -> prox.requestImage(config, imageProperties, imageCallback));\n+                            }\n+                        }\n+                        updateChannel(CHANNEL_GROUP_VEHICLE_IMAGE, IMAGE_VIEWPORT, StringType.valueOf(newViewport));\n+                    }\n+                }\n+                if (command instanceof DecimalType) {\n+                    if (command instanceof DecimalType) {\n+                        int newImageSize = ((DecimalType) command).intValue();\n+                        if (channelUID.getIdWithoutGroup().equals(IMAGE_SIZE)) {\n+                            synchronized (imageProperties) {\n+                                if (imageProperties.size != newImageSize) {\n+                                    imageProperties = new ImageProperties(imageProperties.viewport, newImageSize);\n+                                    imageCache = Optional.empty();\n+                                    proxy.ifPresent(prox -> prox.requestImage(config, imageProperties, imageCallback));\n+                                }\n+                            }\n+                        }\n+                        updateChannel(CHANNEL_GROUP_VEHICLE_IMAGE, IMAGE_SIZE, new DecimalType(newImageSize));\n+                    }\n+                }\n+            });\n+        } else if (CHANNEL_GROUP_DESTINATION.equals(group)) {\n+            if (command instanceof StringType) {\n+                int index = Converter.getIndex(command.toFullString());\n+                if (index != -1) {\n+                    selectDestination(index);\n+                } else {\n+                    logger.debug(\"Cannot select Destination index {}\", command.toFullString());\n+                }\n+            }\n+        } else if (CHANNEL_GROUP_SERVICE.equals(group)) {\n+            if (command instanceof StringType) {\n+                int index = Converter.getIndex(command.toFullString());\n+                if (index != -1) {\n+                    selectService(index);\n+                } else {\n+                    logger.debug(\"Cannot select Service index {}\", command.toFullString());\n+                }\n+            }\n+        } else if (CHANNEL_GROUP_CHECK_CONTROL.equals(group)) {\n+            if (command instanceof StringType) {\n+                int index = Converter.getIndex(command.toFullString());\n+                if (index != -1) {\n+                    selectCheckControl(index);\n+                } else {\n+                    logger.debug(\"Cannot select CheckControl index {}\", command.toFullString());\n+                }\n+            }\n+        } else if (CHANNEL_GROUP_CHARGE.equals(group)) {\n+            handleChargeProfileCommand(channelUID, command);\n+        }\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        callbackCounter = Optional.of(new ArrayList<ResponseCallback>());\n+        updateStatus(ThingStatus.UNKNOWN);\n+        final VehicleConfiguration config = getConfigAs(VehicleConfiguration.class);\n+        configuration = Optional.of(config);\n+        scheduler.execute(() -> {\n+            Bridge bridge = getBridge();\n+            if (bridge != null) {\n+                BridgeHandler handler = bridge.getHandler();\n+                if (handler != null) {\n+                    bridgeHandler = Optional.of(((ConnectedDriveBridgeHandler) handler));\n+                    proxy = ((ConnectedDriveBridgeHandler) handler).getProxy();\n+                    remote = proxy.map(prox -> prox.getRemoteServiceHandler(this));\n+                } else {\n+                    logger.debug(\"Bridge Handler null\");\n+                }\n+            } else {\n+                logger.debug(\"Bridge null\");\n+            }\n+\n+            // get Image after init with config values\n+            synchronized (imageProperties) {\n+                imageProperties = new ImageProperties(config.imageViewport, config.imageSize);\n+            }\n+            updateChannel(CHANNEL_GROUP_VEHICLE_IMAGE, IMAGE_VIEWPORT, StringType.valueOf((config.imageViewport)));\n+            updateChannel(CHANNEL_GROUP_VEHICLE_IMAGE, IMAGE_SIZE, new DecimalType((config.imageSize)));\n+\n+            // check imperial setting is different to AutoDetect\n+            if (!UNITS_AUTODETECT.equals(config.units)) {\n+                imperial = UNITS_IMPERIAL.equals(config.units);\n+            }\n+\n+            // start update schedule\n+            startSchedule(config.refreshInterval);\n+        });\n+    }\n+\n+    private void startSchedule(int interval) {\n+        refreshJob.ifPresentOrElse(job -> {\n+            if (job.isCancelled()) {\n+                refreshJob = Optional\n+                        .of(scheduler.scheduleWithFixedDelay(this::getData, 0, interval, TimeUnit.MINUTES));\n+            } // else - scheduler is already running!\n+        }, () -> {\n+            refreshJob = Optional.of(scheduler.scheduleWithFixedDelay(this::getData, 0, interval, TimeUnit.MINUTES));\n+        });\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        refreshJob.ifPresent(job -> job.cancel(true));\n+        editTimeout.ifPresent(job -> job.cancel(true));\n+        remote.ifPresent(RemoteServiceHandler::cancel);\n+    }\n+\n+    public void getData() {\n+        proxy.ifPresentOrElse(prox -> {\n+            configuration.ifPresentOrElse(config -> {\n+                if (!legacyMode) {\n+                    prox.requestVehcileStatus(config, vehicleStatusCallback);\n+                } else {\n+                    prox.requestLegacyVehcileStatus(config, oldVehicleStatusCallback);\n+                }\n+                addCallback(vehicleStatusCallback);\n+                if (isSupported(Constants.STATISTICS)) {\n+                    prox.requestLastTrip(config, lastTripCallback);\n+                    prox.requestAllTrips(config, allTripsCallback);\n+                    addCallback(lastTripCallback);\n+                    addCallback(allTripsCallback);\n+                }\n+                if (isSupported(Constants.LAST_DESTINATIONS)) {\n+                    prox.requestDestinations(config, destinationCallback);\n+                    addCallback(destinationCallback);\n+                }\n+                if (isElectric) {\n+                    prox.requestChargingProfile(config, chargeProfileCallback);\n+                    addCallback(chargeProfileCallback);\n+                }\n+                synchronized (imageProperties) {\n+                    if (!imageCache.isPresent() && !imageProperties.failLimitReached()) {\n+                        prox.requestImage(config, imageProperties, imageCallback);\n+                        addCallback(imageCallback);\n+                    }\n+                }\n+            }, () -> {\n+                logger.warn(\"ConnectedDrive Configuration isn't present\");\n+            });\n+        }, () -> {\n+            logger.warn(\"ConnectedDrive Proxy isn't present\");\n+        });\n+    }\n+\n+    private synchronized void addCallback(ResponseCallback rc) {\n+        callbackCounter.ifPresent(counter -> counter.add(rc));\n+    }\n+\n+    private synchronized void removeCallback(ResponseCallback rc) {\n+        callbackCounter.ifPresent(counter -> {\n+            counter.remove(rc);\n+            // all necessary callbacks received => print and set to empty\n+            if (counter.isEmpty()) {\n+                logFingerPrint();\n+                callbackCounter = Optional.empty();\n+            }\n+        });\n+    }\n+\n+    private void logFingerPrint() {\n+        final String vin = configuration.map(config -> config.vin).orElse(\"\");\n+        logger.debug(\"###### Vehicle Troubleshoot Fingerprint Data - BEGIN ######\");\n+        logger.debug(\"### Discovery Result ###\");\n+        bridgeHandler.ifPresent(handler -> {\n+            logger.debug(\"{}\", handler.getDiscoveryFingerprint());\n+        });\n+        vehicleStatusCache.ifPresentOrElse(vehicleStatus -> {\n+            logger.debug(\"### Vehicle Status ###\");\n+\n+            // Anonymous data for VIN and Position\n+            try {\n+                VehicleStatusContainer container = Converter.getGson().fromJson(vehicleStatus,\n+                        VehicleStatusContainer.class);\n+                if (container != null) {\n+                    VehicleStatus status = container.vehicleStatus;\n+                    if (status != null) {\n+                        status.vin = Constants.ANONYMOUS;\n+                        if (status.position != null) {\n+                            status.position.lat = -1;\n+                            status.position.lon = -1;\n+                            status.position.heading = -1;\n+                        }\n+                    }\n+                }\n+                logger.debug(\"{}\", Converter.getGson().toJson(container));\n+            } catch (JsonSyntaxException jse) {\n+                logger.debug(\"{}\", jse.getMessage());\n+            }\n+        }, () -> {\n+            logger.debug(\"### Vehicle Status Empty ###\");\n+        });\n+        lastTripCache.ifPresentOrElse(lastTrip -> {\n+            logger.debug(\"### Last Trip ###\");\n+            logger.debug(\"{}\", lastTrip.replaceAll(vin, Constants.ANONYMOUS));\n+        }, () -> {\n+            logger.debug(\"### Last Trip Empty ###\");\n+        });\n+        allTripsCache.ifPresentOrElse(allTrips -> {\n+            logger.debug(\"### All Trips ###\");\n+            logger.debug(\"{}\", allTrips.replaceAll(vin, Constants.ANONYMOUS));\n+        }, () -> {\n+            logger.debug(\"### All Trips Empty ###\");\n+        });\n+        if (isElectric) {\n+            chargeProfileCache.ifPresentOrElse(chargeProfile -> {\n+                logger.debug(\"### Charge Profile ###\");\n+                logger.debug(\"{}\", chargeProfile.replaceAll(vin, Constants.ANONYMOUS));\n+            }, () -> {\n+                logger.debug(\"### Charge Profile Empty ###\");\n+            });\n+        }\n+        destinationCache.ifPresentOrElse(destination -> {\n+            logger.debug(\"### Charge Profile ###\");\n+            try {\n+                DestinationContainer container = Converter.getGson().fromJson(destination, DestinationContainer.class);\n+                if (container != null) {\n+                    if (container.destinations != null) {\n+                        container.destinations.forEach(entry -> {\n+                            entry.lat = 0;\n+                            entry.lon = 0;\n+                            entry.city = Constants.ANONYMOUS;\n+                            entry.street = Constants.ANONYMOUS;\n+                            entry.streetNumber = Constants.ANONYMOUS;\n+                            entry.country = Constants.ANONYMOUS;\n+                        });\n+                        logger.debug(\"{}\", Converter.getGson().toJson(container));\n+                    }\n+                } else {\n+                    logger.debug(\"### Destinations Empty ###\");\n+                }\n+            } catch (JsonSyntaxException jse) {\n+                logger.debug(\"{}\", jse.getMessage());\n+            }\n+        }, () -> {\n+            logger.debug(\"### Charge Profile Empty ###\");\n+        });\n+        rangeMapCache.ifPresentOrElse(rangeMap -> {\n+            logger.debug(\"### Range Map ###\");\n+            logger.debug(\"{}\", rangeMap.replaceAll(vin, Constants.ANONYMOUS));\n+        }, () -> {\n+            logger.debug(\"### Range Map Empty ###\");\n+        });\n+        logger.debug(\"###### Vehicle Troubleshoot Fingerprint Data - END ######\");\n+    }\n+\n+    /**\n+     * Don't stress ConnectedDrive with unnecessary requests. One call at the beginning is done to check the response.\n+     * After cache has e.g. a proper error response it will be shown in the fingerprint\n+     *\n+     * @return\n+     */\n+    private boolean isSupported(String service) {\n+        final String services = thing.getProperties().get(Constants.SERVICES_SUPPORTED);\n+        if (services != null) {\n+            if (services.contains(service)) {\n+                return true;\n+            }\n+        }\n+        // if cache is empty give it a try one time to collected Troubleshoot data\n+        return lastTripCache.isEmpty() || allTripsCache.isEmpty() || destinationCache.isEmpty();\n+    }\n+\n+    public void updateRemoteExecutionStatus(@Nullable String service, @Nullable String status) {\n+        if (RemoteService.CHARGING_CONTROL.toString().equals(service)\n+                && ExecutionState.EXECUTED.name().equals(status)) {\n+            saveChargeProfileSent();\n+        }\n+        updateChannel(CHANNEL_GROUP_REMOTE, REMOTE_STATE, StringType\n+                .valueOf(Converter.toTitleCase((service == null ? \"-\" : service) + Constants.SPACE + status)));\n+    }\n+\n+    public Optional<VehicleConfiguration> getConfiguration() {\n+        return configuration;\n+    }\n+\n+    public ScheduledExecutorService getScheduler() {\n+        return scheduler;\n+    }\n+\n+    /**\n+     * Callbacks for ConnectedDrive Portal\n+     *\n+     * @author Bernd Weymann\n+     *\n+     */\n+    public class ChargeProfilesCallback implements StringResponseCallback {\n+        @Override\n+        public void onResponse(@Nullable String content) {\n+            if (content != null) {\n+                chargeProfileCache = Optional.of(content);\n+                if (chargeProfileEdit.isEmpty()) {\n+                    updateChargeProfileFromContent(content);\n+                }\n+            }\n+            removeCallback(this);\n+        }\n+\n+        /**\n+         * Store Error Report in cache variable. Via Fingerprint Channel error is logged and Issue can be raised\n+         */\n+        @Override\n+        public void onError(NetworkError error) {\n+            logger.debug(\"{}\", error.toString());\n+            chargeProfileCache = Optional.of(Converter.getGson().toJson(error));\n+            removeCallback(this);\n+        }\n+    }\n+\n+    public class RangeMapCallback implements StringResponseCallback {\n+        @Override\n+        public void onResponse(@Nullable String content) {\n+            rangeMapCache = Optional.ofNullable(content);\n+            removeCallback(this);\n+        }\n+\n+        /**\n+         * Store Error Report in cache variable. Via Fingerprint Channel error is logged and Issue can be raised\n+         */\n+        @Override\n+        public void onError(NetworkError error) {\n+            logger.debug(\"{}\", error.toString());\n+            rangeMapCache = Optional.of(Converter.getGson().toJson(error));\n+            removeCallback(this);\n+        }\n+    }\n+\n+    public class DestinationsCallback implements StringResponseCallback {\n+\n+        @Override\n+        public void onResponse(@Nullable String content) {\n+            destinationCache = Optional.ofNullable(content);\n+            if (content != null) {\n+                try {\n+                    DestinationContainer dc = Converter.getGson().fromJson(content, DestinationContainer.class);\n+                    if (dc != null && dc.destinations != null) {\n+                        updateDestinations(dc.destinations);\n+                    }\n+                } catch (JsonSyntaxException jse) {\n+                    logger.debug(\"{}\", jse.getMessage());\n+                }\n+            }\n+            removeCallback(this);\n+        }\n+\n+        /**\n+         * Store Error Report in cache variable. Via Fingerprint Channel error is logged and Issue can be raised\n+         */\n+        @Override\n+        public void onError(NetworkError error) {\n+            logger.debug(\"{}\", error.toString());\n+            destinationCache = Optional.of(Converter.getGson().toJson(error));\n+            removeCallback(this);\n+        }\n+    }\n+\n+    public class ImageCallback implements ByteResponseCallback {\n+        @Override\n+        public void onResponse(byte[] content) {\n+            if (content.length > 0) {\n+                imageCache = Optional.of(content);\n+                String contentType = HttpUtil.guessContentTypeFromData(content);\n+                updateChannel(CHANNEL_GROUP_VEHICLE_IMAGE, IMAGE_FORMAT, new RawType(content, contentType));\n+            } else {\n+                synchronized (imageProperties) {\n+                    imageProperties.failed();\n+                }\n+            }\n+            removeCallback(this);\n+        }\n+\n+        /**\n+         * Store Error Report in cache variable. Via Fingerprint Channel error is logged and Issue can be raised\n+         */\n+        @Override\n+        public void onError(NetworkError error) {\n+            logger.debug(\"{}\", error.toString());\n+            synchronized (imageProperties) {\n+                imageProperties.failed();\n+            }\n+            removeCallback(this);\n+        }\n+    }\n+\n+    public class AllTripsCallback implements StringResponseCallback {\n+        @Override\n+        public void onResponse(@Nullable String content) {\n+            if (content != null) {\n+                allTripsCache = Optional.of(content);\n+                try {\n+                    AllTripsContainer atc = Converter.getGson().fromJson(content, AllTripsContainer.class);\n+                    if (atc != null) {\n+                        AllTrips at = atc.allTrips;\n+                        if (at != null) {\n+                            updateAllTrips(at);\n+                        }\n+                    }\n+                } catch (JsonSyntaxException jse) {\n+                    logger.debug(\"{}\", jse.getMessage());\n+                }\n+            }\n+            removeCallback(this);\n+        }\n+\n+        /**\n+         * Store Error Report in cache variable. Via Fingerprint Channel error is logged and Issue can be raised\n+         */\n+        @Override\n+        public void onError(NetworkError error) {\n+            logger.debug(\"{}\", error.toString());\n+            allTripsCache = Optional.of(Converter.getGson().toJson(error));\n+            removeCallback(this);\n+        }\n+    }\n+\n+    public class LastTripCallback implements StringResponseCallback {\n+        @Override\n+        public void onResponse(@Nullable String content) {\n+            if (content != null) {\n+                lastTripCache = Optional.of(content);\n+                try {\n+                    LastTripContainer lt = Converter.getGson().fromJson(content, LastTripContainer.class);\n+                    if (lt != null) {\n+                        LastTrip trip = lt.lastTrip;\n+                        if (trip != null) {\n+                            updateLastTrip(trip);\n+                        }\n+                    }\n+                } catch (JsonSyntaxException jse) {\n+                    logger.debug(\"{}\", jse.getMessage());\n+                }\n+            }\n+            removeCallback(this);\n+        }\n+\n+        /**\n+         * Store Error Report in cache variable. Via Fingerprint Channel error is logged and Issue can be raised\n+         */\n+        @Override\n+        public void onError(NetworkError error) {\n+            logger.debug(\"{}\", error.toString());\n+            lastTripCache = Optional.of(Converter.getGson().toJson(error));\n+            removeCallback(this);\n+        }\n+    }\n+\n+    /**\n+     * The VehicleStatus is supported by all Vehicle Types so it's used to reflect the Thing Status\n+     */\n+    public class VehicleStatusCallback implements StringResponseCallback {\n+        private ThingStatus thingStatus = ThingStatus.UNKNOWN;\n+\n+        @Override\n+        public void onResponse(@Nullable String content) {\n+            if (content != null) {\n+                updateStatus(ThingStatus.ONLINE);\n+                vehicleStatusCache = Optional.of(content);\n+                try {\n+                    VehicleStatusContainer status = Converter.getGson().fromJson(content, VehicleStatusContainer.class);\n+                    if (status != null) {\n+                        VehicleStatus vStatus = status.vehicleStatus;\n+                        if (vStatus == null) {\n+                            return;\n+                        }\n+                        updateVehicleStatus(vStatus);\n+                        updateCheckControls(vStatus.checkControlMessages);\n+                        updateServices(vStatus.cbsData);\n+                        updatePosition(vStatus.position);\n+                    }\n+                } catch (JsonSyntaxException jse) {\n+                    logger.debug(\"{}\", jse.getMessage());\n+                }\n+            }\n+            removeCallback(this);\n+        }\n+\n+        @Override\n+        public void onError(NetworkError error) {\n+            logger.debug(\"{}\", error.toString());\n+            if (error.status == 404) {\n+                legacyMode = true;\n+                logger.debug(\"VehicleStatus not found - switch to legacy API\");\n+                proxy.get().requestLegacyVehcileStatus(configuration.get(), oldVehicleStatusCallback);\n+            }\n+            vehicleStatusCache = Optional.of(Converter.getGson().toJson(error));\n+            setThingStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, error.reason);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMTg4MDMxNQ=="}, "originalCommit": {"oid": "5a568b041a01f7b8cd6e1290a8d969c40369480a"}, "originalPosition": 648}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMjkwMjU1OA==", "bodyText": "ok, so resolved", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r602902558", "createdAt": "2021-03-28T16:51:13Z", "author": {"login": "weymann"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/VehicleHandler.java", "diffHunk": "@@ -0,0 +1,796 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bmwconnecteddrive.internal.handler;\n+\n+import static org.openhab.binding.bmwconnecteddrive.internal.ConnectedDriveConstants.*;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.bmwconnecteddrive.internal.VehicleConfiguration;\n+import org.openhab.binding.bmwconnecteddrive.internal.action.ChargeProfileActions;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.DestinationContainer;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.NetworkError;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.compat.VehicleAttributesContainer;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.statistics.AllTrips;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.statistics.AllTripsContainer;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.statistics.LastTrip;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.statistics.LastTripContainer;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.status.VehicleStatus;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.status.VehicleStatusContainer;\n+import org.openhab.binding.bmwconnecteddrive.internal.handler.RemoteServiceHandler.ExecutionState;\n+import org.openhab.binding.bmwconnecteddrive.internal.handler.RemoteServiceHandler.RemoteService;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileUtils;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileUtils.ChargeKeyDay;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileUtils.ChargeKeyHour;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileWrapper;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileWrapper.ProfileKey;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Constants;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Converter;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ImageProperties;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.RemoteServiceUtils;\n+import org.openhab.core.io.net.http.HttpUtil;\n+import org.openhab.core.library.types.DecimalType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.RawType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BridgeHandler;\n+import org.openhab.core.thing.binding.ThingHandlerService;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+\n+import com.google.gson.JsonSyntaxException;\n+\n+/**\n+ * The {@link VehicleHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Bernd Weymann - Initial contribution\n+ * @author Norbert Truchsess - edit & send charge profile\n+ */\n+@NonNullByDefault\n+public class VehicleHandler extends VehicleChannelHandler {\n+    private boolean legacyMode = false; // switch to legacy API in case of 404 Errors\n+\n+    private Optional<ConnectedDriveProxy> proxy = Optional.empty();\n+    private Optional<RemoteServiceHandler> remote = Optional.empty();\n+    private Optional<VehicleConfiguration> configuration = Optional.empty();\n+    private Optional<ConnectedDriveBridgeHandler> bridgeHandler = Optional.empty();\n+    private Optional<ScheduledFuture<?>> refreshJob = Optional.empty();\n+    private Optional<ScheduledFuture<?>> editTimeout = Optional.empty();\n+    private Optional<List<ResponseCallback>> callbackCounter = Optional.empty();\n+\n+    private ImageProperties imageProperties = new ImageProperties();\n+    VehicleStatusCallback vehicleStatusCallback = new VehicleStatusCallback();\n+    StringResponseCallback oldVehicleStatusCallback = new LegacyVehicleStatusCallback();\n+    StringResponseCallback lastTripCallback = new LastTripCallback();\n+    StringResponseCallback allTripsCallback = new AllTripsCallback();\n+    StringResponseCallback chargeProfileCallback = new ChargeProfilesCallback();\n+    StringResponseCallback rangeMapCallback = new RangeMapCallback();\n+    DestinationsCallback destinationCallback = new DestinationsCallback();\n+    ByteResponseCallback imageCallback = new ImageCallback();\n+\n+    private Optional<ChargeProfileWrapper> chargeProfileEdit = Optional.empty();\n+    private Optional<String> chargeProfileSent = Optional.empty();\n+\n+    public VehicleHandler(Thing thing, BMWConnectedDriveOptionProvider op, String type, boolean imperial) {\n+        super(thing, op, type, imperial);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        String group = channelUID.getGroupId();\n+\n+        // Refresh of Channels with cached values\n+        if (command instanceof RefreshType) {\n+            if (CHANNEL_GROUP_LAST_TRIP.equals(group)) {\n+                lastTripCache.ifPresent(lastTrip -> lastTripCallback.onResponse(lastTrip));\n+            } else if (CHANNEL_GROUP_LIFETIME.equals(group)) {\n+                allTripsCache.ifPresent(allTrips -> allTripsCallback.onResponse(allTrips));\n+            } else if (CHANNEL_GROUP_DESTINATION.equals(group)) {\n+                destinationCache.ifPresent(destination -> destinationCallback.onResponse(destination));\n+            } else if (CHANNEL_GROUP_STATUS.equals(group)) {\n+                vehicleStatusCache.ifPresent(vehicleStatus -> vehicleStatusCallback.onResponse(vehicleStatus));\n+            } else if (CHANNEL_GROUP_CHARGE.equals(group)) {\n+                chargeProfileEdit.ifPresentOrElse(this::updateChargeProfile,\n+                        () -> chargeProfileCache.ifPresent(this::updateChargeProfileFromContent));\n+            } else if (CHANNEL_GROUP_VEHICLE_IMAGE.equals(group)) {\n+                imageCache.ifPresent(image -> imageCallback.onResponse(image));\n+            }\n+            // Check for Channel Group and corresponding Actions\n+        } else if (CHANNEL_GROUP_REMOTE.equals(group)) {\n+            // Executing Remote Services\n+            if (command instanceof StringType) {\n+                String serviceCommand = ((StringType) command).toFullString();\n+                remote.ifPresent(remot -> {\n+                    switch (serviceCommand) {\n+                        case REMOTE_SERVICE_LIGHT_FLASH:\n+                        case REMOTE_SERVICE_AIR_CONDITIONING:\n+                        case REMOTE_SERVICE_DOOR_LOCK:\n+                        case REMOTE_SERVICE_DOOR_UNLOCK:\n+                        case REMOTE_SERVICE_HORN:\n+                        case REMOTE_SERVICE_VEHICLE_FINDER:\n+                        case REMOTE_SERVICE_CHARGE_NOW:\n+                            RemoteServiceUtils.getRemoteService(serviceCommand)\n+                                    .ifPresentOrElse(service -> remot.execute(service), () -> {\n+                                        logger.debug(\"Remote service execution {} unknown\", serviceCommand);\n+                                    });\n+                            break;\n+                        case REMOTE_SERVICE_CHARGING_CONTROL:\n+                            sendChargeProfile(chargeProfileEdit);\n+                            break;\n+                        default:\n+                            logger.debug(\"Remote service execution {} unknown\", serviceCommand);\n+                            break;\n+                    }\n+                });\n+            }\n+        } else if (CHANNEL_GROUP_VEHICLE_IMAGE.equals(group)) {\n+            // Image Change\n+            configuration.ifPresent(config -> {\n+                if (command instanceof StringType) {\n+                    if (channelUID.getIdWithoutGroup().equals(IMAGE_VIEWPORT)) {\n+                        String newViewport = command.toString();\n+                        synchronized (imageProperties) {\n+                            if (!imageProperties.viewport.equals(newViewport)) {\n+                                imageProperties = new ImageProperties(newViewport, imageProperties.size);\n+                                imageCache = Optional.empty();\n+                                proxy.ifPresent(prox -> prox.requestImage(config, imageProperties, imageCallback));\n+                            }\n+                        }\n+                        updateChannel(CHANNEL_GROUP_VEHICLE_IMAGE, IMAGE_VIEWPORT, StringType.valueOf(newViewport));\n+                    }\n+                }\n+                if (command instanceof DecimalType) {\n+                    if (command instanceof DecimalType) {\n+                        int newImageSize = ((DecimalType) command).intValue();\n+                        if (channelUID.getIdWithoutGroup().equals(IMAGE_SIZE)) {\n+                            synchronized (imageProperties) {\n+                                if (imageProperties.size != newImageSize) {\n+                                    imageProperties = new ImageProperties(imageProperties.viewport, newImageSize);\n+                                    imageCache = Optional.empty();\n+                                    proxy.ifPresent(prox -> prox.requestImage(config, imageProperties, imageCallback));\n+                                }\n+                            }\n+                        }\n+                        updateChannel(CHANNEL_GROUP_VEHICLE_IMAGE, IMAGE_SIZE, new DecimalType(newImageSize));\n+                    }\n+                }\n+            });\n+        } else if (CHANNEL_GROUP_DESTINATION.equals(group)) {\n+            if (command instanceof StringType) {\n+                int index = Converter.getIndex(command.toFullString());\n+                if (index != -1) {\n+                    selectDestination(index);\n+                } else {\n+                    logger.debug(\"Cannot select Destination index {}\", command.toFullString());\n+                }\n+            }\n+        } else if (CHANNEL_GROUP_SERVICE.equals(group)) {\n+            if (command instanceof StringType) {\n+                int index = Converter.getIndex(command.toFullString());\n+                if (index != -1) {\n+                    selectService(index);\n+                } else {\n+                    logger.debug(\"Cannot select Service index {}\", command.toFullString());\n+                }\n+            }\n+        } else if (CHANNEL_GROUP_CHECK_CONTROL.equals(group)) {\n+            if (command instanceof StringType) {\n+                int index = Converter.getIndex(command.toFullString());\n+                if (index != -1) {\n+                    selectCheckControl(index);\n+                } else {\n+                    logger.debug(\"Cannot select CheckControl index {}\", command.toFullString());\n+                }\n+            }\n+        } else if (CHANNEL_GROUP_CHARGE.equals(group)) {\n+            handleChargeProfileCommand(channelUID, command);\n+        }\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        callbackCounter = Optional.of(new ArrayList<ResponseCallback>());\n+        updateStatus(ThingStatus.UNKNOWN);\n+        final VehicleConfiguration config = getConfigAs(VehicleConfiguration.class);\n+        configuration = Optional.of(config);\n+        scheduler.execute(() -> {\n+            Bridge bridge = getBridge();\n+            if (bridge != null) {\n+                BridgeHandler handler = bridge.getHandler();\n+                if (handler != null) {\n+                    bridgeHandler = Optional.of(((ConnectedDriveBridgeHandler) handler));\n+                    proxy = ((ConnectedDriveBridgeHandler) handler).getProxy();\n+                    remote = proxy.map(prox -> prox.getRemoteServiceHandler(this));\n+                } else {\n+                    logger.debug(\"Bridge Handler null\");\n+                }\n+            } else {\n+                logger.debug(\"Bridge null\");\n+            }\n+\n+            // get Image after init with config values\n+            synchronized (imageProperties) {\n+                imageProperties = new ImageProperties(config.imageViewport, config.imageSize);\n+            }\n+            updateChannel(CHANNEL_GROUP_VEHICLE_IMAGE, IMAGE_VIEWPORT, StringType.valueOf((config.imageViewport)));\n+            updateChannel(CHANNEL_GROUP_VEHICLE_IMAGE, IMAGE_SIZE, new DecimalType((config.imageSize)));\n+\n+            // check imperial setting is different to AutoDetect\n+            if (!UNITS_AUTODETECT.equals(config.units)) {\n+                imperial = UNITS_IMPERIAL.equals(config.units);\n+            }\n+\n+            // start update schedule\n+            startSchedule(config.refreshInterval);\n+        });\n+    }\n+\n+    private void startSchedule(int interval) {\n+        refreshJob.ifPresentOrElse(job -> {\n+            if (job.isCancelled()) {\n+                refreshJob = Optional\n+                        .of(scheduler.scheduleWithFixedDelay(this::getData, 0, interval, TimeUnit.MINUTES));\n+            } // else - scheduler is already running!\n+        }, () -> {\n+            refreshJob = Optional.of(scheduler.scheduleWithFixedDelay(this::getData, 0, interval, TimeUnit.MINUTES));\n+        });\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        refreshJob.ifPresent(job -> job.cancel(true));\n+        editTimeout.ifPresent(job -> job.cancel(true));\n+        remote.ifPresent(RemoteServiceHandler::cancel);\n+    }\n+\n+    public void getData() {\n+        proxy.ifPresentOrElse(prox -> {\n+            configuration.ifPresentOrElse(config -> {\n+                if (!legacyMode) {\n+                    prox.requestVehcileStatus(config, vehicleStatusCallback);\n+                } else {\n+                    prox.requestLegacyVehcileStatus(config, oldVehicleStatusCallback);\n+                }\n+                addCallback(vehicleStatusCallback);\n+                if (isSupported(Constants.STATISTICS)) {\n+                    prox.requestLastTrip(config, lastTripCallback);\n+                    prox.requestAllTrips(config, allTripsCallback);\n+                    addCallback(lastTripCallback);\n+                    addCallback(allTripsCallback);\n+                }\n+                if (isSupported(Constants.LAST_DESTINATIONS)) {\n+                    prox.requestDestinations(config, destinationCallback);\n+                    addCallback(destinationCallback);\n+                }\n+                if (isElectric) {\n+                    prox.requestChargingProfile(config, chargeProfileCallback);\n+                    addCallback(chargeProfileCallback);\n+                }\n+                synchronized (imageProperties) {\n+                    if (!imageCache.isPresent() && !imageProperties.failLimitReached()) {\n+                        prox.requestImage(config, imageProperties, imageCallback);\n+                        addCallback(imageCallback);\n+                    }\n+                }\n+            }, () -> {\n+                logger.warn(\"ConnectedDrive Configuration isn't present\");\n+            });\n+        }, () -> {\n+            logger.warn(\"ConnectedDrive Proxy isn't present\");\n+        });\n+    }\n+\n+    private synchronized void addCallback(ResponseCallback rc) {\n+        callbackCounter.ifPresent(counter -> counter.add(rc));\n+    }\n+\n+    private synchronized void removeCallback(ResponseCallback rc) {\n+        callbackCounter.ifPresent(counter -> {\n+            counter.remove(rc);\n+            // all necessary callbacks received => print and set to empty\n+            if (counter.isEmpty()) {\n+                logFingerPrint();\n+                callbackCounter = Optional.empty();\n+            }\n+        });\n+    }\n+\n+    private void logFingerPrint() {\n+        final String vin = configuration.map(config -> config.vin).orElse(\"\");\n+        logger.debug(\"###### Vehicle Troubleshoot Fingerprint Data - BEGIN ######\");\n+        logger.debug(\"### Discovery Result ###\");\n+        bridgeHandler.ifPresent(handler -> {\n+            logger.debug(\"{}\", handler.getDiscoveryFingerprint());\n+        });\n+        vehicleStatusCache.ifPresentOrElse(vehicleStatus -> {\n+            logger.debug(\"### Vehicle Status ###\");\n+\n+            // Anonymous data for VIN and Position\n+            try {\n+                VehicleStatusContainer container = Converter.getGson().fromJson(vehicleStatus,\n+                        VehicleStatusContainer.class);\n+                if (container != null) {\n+                    VehicleStatus status = container.vehicleStatus;\n+                    if (status != null) {\n+                        status.vin = Constants.ANONYMOUS;\n+                        if (status.position != null) {\n+                            status.position.lat = -1;\n+                            status.position.lon = -1;\n+                            status.position.heading = -1;\n+                        }\n+                    }\n+                }\n+                logger.debug(\"{}\", Converter.getGson().toJson(container));\n+            } catch (JsonSyntaxException jse) {\n+                logger.debug(\"{}\", jse.getMessage());\n+            }\n+        }, () -> {\n+            logger.debug(\"### Vehicle Status Empty ###\");\n+        });\n+        lastTripCache.ifPresentOrElse(lastTrip -> {\n+            logger.debug(\"### Last Trip ###\");\n+            logger.debug(\"{}\", lastTrip.replaceAll(vin, Constants.ANONYMOUS));\n+        }, () -> {\n+            logger.debug(\"### Last Trip Empty ###\");\n+        });\n+        allTripsCache.ifPresentOrElse(allTrips -> {\n+            logger.debug(\"### All Trips ###\");\n+            logger.debug(\"{}\", allTrips.replaceAll(vin, Constants.ANONYMOUS));\n+        }, () -> {\n+            logger.debug(\"### All Trips Empty ###\");\n+        });\n+        if (isElectric) {\n+            chargeProfileCache.ifPresentOrElse(chargeProfile -> {\n+                logger.debug(\"### Charge Profile ###\");\n+                logger.debug(\"{}\", chargeProfile.replaceAll(vin, Constants.ANONYMOUS));\n+            }, () -> {\n+                logger.debug(\"### Charge Profile Empty ###\");\n+            });\n+        }\n+        destinationCache.ifPresentOrElse(destination -> {\n+            logger.debug(\"### Charge Profile ###\");\n+            try {\n+                DestinationContainer container = Converter.getGson().fromJson(destination, DestinationContainer.class);\n+                if (container != null) {\n+                    if (container.destinations != null) {\n+                        container.destinations.forEach(entry -> {\n+                            entry.lat = 0;\n+                            entry.lon = 0;\n+                            entry.city = Constants.ANONYMOUS;\n+                            entry.street = Constants.ANONYMOUS;\n+                            entry.streetNumber = Constants.ANONYMOUS;\n+                            entry.country = Constants.ANONYMOUS;\n+                        });\n+                        logger.debug(\"{}\", Converter.getGson().toJson(container));\n+                    }\n+                } else {\n+                    logger.debug(\"### Destinations Empty ###\");\n+                }\n+            } catch (JsonSyntaxException jse) {\n+                logger.debug(\"{}\", jse.getMessage());\n+            }\n+        }, () -> {\n+            logger.debug(\"### Charge Profile Empty ###\");\n+        });\n+        rangeMapCache.ifPresentOrElse(rangeMap -> {\n+            logger.debug(\"### Range Map ###\");\n+            logger.debug(\"{}\", rangeMap.replaceAll(vin, Constants.ANONYMOUS));\n+        }, () -> {\n+            logger.debug(\"### Range Map Empty ###\");\n+        });\n+        logger.debug(\"###### Vehicle Troubleshoot Fingerprint Data - END ######\");\n+    }\n+\n+    /**\n+     * Don't stress ConnectedDrive with unnecessary requests. One call at the beginning is done to check the response.\n+     * After cache has e.g. a proper error response it will be shown in the fingerprint\n+     *\n+     * @return\n+     */\n+    private boolean isSupported(String service) {\n+        final String services = thing.getProperties().get(Constants.SERVICES_SUPPORTED);\n+        if (services != null) {\n+            if (services.contains(service)) {\n+                return true;\n+            }\n+        }\n+        // if cache is empty give it a try one time to collected Troubleshoot data\n+        return lastTripCache.isEmpty() || allTripsCache.isEmpty() || destinationCache.isEmpty();\n+    }\n+\n+    public void updateRemoteExecutionStatus(@Nullable String service, @Nullable String status) {\n+        if (RemoteService.CHARGING_CONTROL.toString().equals(service)\n+                && ExecutionState.EXECUTED.name().equals(status)) {\n+            saveChargeProfileSent();\n+        }\n+        updateChannel(CHANNEL_GROUP_REMOTE, REMOTE_STATE, StringType\n+                .valueOf(Converter.toTitleCase((service == null ? \"-\" : service) + Constants.SPACE + status)));\n+    }\n+\n+    public Optional<VehicleConfiguration> getConfiguration() {\n+        return configuration;\n+    }\n+\n+    public ScheduledExecutorService getScheduler() {\n+        return scheduler;\n+    }\n+\n+    /**\n+     * Callbacks for ConnectedDrive Portal\n+     *\n+     * @author Bernd Weymann\n+     *\n+     */\n+    public class ChargeProfilesCallback implements StringResponseCallback {\n+        @Override\n+        public void onResponse(@Nullable String content) {\n+            if (content != null) {\n+                chargeProfileCache = Optional.of(content);\n+                if (chargeProfileEdit.isEmpty()) {\n+                    updateChargeProfileFromContent(content);\n+                }\n+            }\n+            removeCallback(this);\n+        }\n+\n+        /**\n+         * Store Error Report in cache variable. Via Fingerprint Channel error is logged and Issue can be raised\n+         */\n+        @Override\n+        public void onError(NetworkError error) {\n+            logger.debug(\"{}\", error.toString());\n+            chargeProfileCache = Optional.of(Converter.getGson().toJson(error));\n+            removeCallback(this);\n+        }\n+    }\n+\n+    public class RangeMapCallback implements StringResponseCallback {\n+        @Override\n+        public void onResponse(@Nullable String content) {\n+            rangeMapCache = Optional.ofNullable(content);\n+            removeCallback(this);\n+        }\n+\n+        /**\n+         * Store Error Report in cache variable. Via Fingerprint Channel error is logged and Issue can be raised\n+         */\n+        @Override\n+        public void onError(NetworkError error) {\n+            logger.debug(\"{}\", error.toString());\n+            rangeMapCache = Optional.of(Converter.getGson().toJson(error));\n+            removeCallback(this);\n+        }\n+    }\n+\n+    public class DestinationsCallback implements StringResponseCallback {\n+\n+        @Override\n+        public void onResponse(@Nullable String content) {\n+            destinationCache = Optional.ofNullable(content);\n+            if (content != null) {\n+                try {\n+                    DestinationContainer dc = Converter.getGson().fromJson(content, DestinationContainer.class);\n+                    if (dc != null && dc.destinations != null) {\n+                        updateDestinations(dc.destinations);\n+                    }\n+                } catch (JsonSyntaxException jse) {\n+                    logger.debug(\"{}\", jse.getMessage());\n+                }\n+            }\n+            removeCallback(this);\n+        }\n+\n+        /**\n+         * Store Error Report in cache variable. Via Fingerprint Channel error is logged and Issue can be raised\n+         */\n+        @Override\n+        public void onError(NetworkError error) {\n+            logger.debug(\"{}\", error.toString());\n+            destinationCache = Optional.of(Converter.getGson().toJson(error));\n+            removeCallback(this);\n+        }\n+    }\n+\n+    public class ImageCallback implements ByteResponseCallback {\n+        @Override\n+        public void onResponse(byte[] content) {\n+            if (content.length > 0) {\n+                imageCache = Optional.of(content);\n+                String contentType = HttpUtil.guessContentTypeFromData(content);\n+                updateChannel(CHANNEL_GROUP_VEHICLE_IMAGE, IMAGE_FORMAT, new RawType(content, contentType));\n+            } else {\n+                synchronized (imageProperties) {\n+                    imageProperties.failed();\n+                }\n+            }\n+            removeCallback(this);\n+        }\n+\n+        /**\n+         * Store Error Report in cache variable. Via Fingerprint Channel error is logged and Issue can be raised\n+         */\n+        @Override\n+        public void onError(NetworkError error) {\n+            logger.debug(\"{}\", error.toString());\n+            synchronized (imageProperties) {\n+                imageProperties.failed();\n+            }\n+            removeCallback(this);\n+        }\n+    }\n+\n+    public class AllTripsCallback implements StringResponseCallback {\n+        @Override\n+        public void onResponse(@Nullable String content) {\n+            if (content != null) {\n+                allTripsCache = Optional.of(content);\n+                try {\n+                    AllTripsContainer atc = Converter.getGson().fromJson(content, AllTripsContainer.class);\n+                    if (atc != null) {\n+                        AllTrips at = atc.allTrips;\n+                        if (at != null) {\n+                            updateAllTrips(at);\n+                        }\n+                    }\n+                } catch (JsonSyntaxException jse) {\n+                    logger.debug(\"{}\", jse.getMessage());\n+                }\n+            }\n+            removeCallback(this);\n+        }\n+\n+        /**\n+         * Store Error Report in cache variable. Via Fingerprint Channel error is logged and Issue can be raised\n+         */\n+        @Override\n+        public void onError(NetworkError error) {\n+            logger.debug(\"{}\", error.toString());\n+            allTripsCache = Optional.of(Converter.getGson().toJson(error));\n+            removeCallback(this);\n+        }\n+    }\n+\n+    public class LastTripCallback implements StringResponseCallback {\n+        @Override\n+        public void onResponse(@Nullable String content) {\n+            if (content != null) {\n+                lastTripCache = Optional.of(content);\n+                try {\n+                    LastTripContainer lt = Converter.getGson().fromJson(content, LastTripContainer.class);\n+                    if (lt != null) {\n+                        LastTrip trip = lt.lastTrip;\n+                        if (trip != null) {\n+                            updateLastTrip(trip);\n+                        }\n+                    }\n+                } catch (JsonSyntaxException jse) {\n+                    logger.debug(\"{}\", jse.getMessage());\n+                }\n+            }\n+            removeCallback(this);\n+        }\n+\n+        /**\n+         * Store Error Report in cache variable. Via Fingerprint Channel error is logged and Issue can be raised\n+         */\n+        @Override\n+        public void onError(NetworkError error) {\n+            logger.debug(\"{}\", error.toString());\n+            lastTripCache = Optional.of(Converter.getGson().toJson(error));\n+            removeCallback(this);\n+        }\n+    }\n+\n+    /**\n+     * The VehicleStatus is supported by all Vehicle Types so it's used to reflect the Thing Status\n+     */\n+    public class VehicleStatusCallback implements StringResponseCallback {\n+        private ThingStatus thingStatus = ThingStatus.UNKNOWN;\n+\n+        @Override\n+        public void onResponse(@Nullable String content) {\n+            if (content != null) {\n+                updateStatus(ThingStatus.ONLINE);\n+                vehicleStatusCache = Optional.of(content);\n+                try {\n+                    VehicleStatusContainer status = Converter.getGson().fromJson(content, VehicleStatusContainer.class);\n+                    if (status != null) {\n+                        VehicleStatus vStatus = status.vehicleStatus;\n+                        if (vStatus == null) {\n+                            return;\n+                        }\n+                        updateVehicleStatus(vStatus);\n+                        updateCheckControls(vStatus.checkControlMessages);\n+                        updateServices(vStatus.cbsData);\n+                        updatePosition(vStatus.position);\n+                    }\n+                } catch (JsonSyntaxException jse) {\n+                    logger.debug(\"{}\", jse.getMessage());\n+                }\n+            }\n+            removeCallback(this);\n+        }\n+\n+        @Override\n+        public void onError(NetworkError error) {\n+            logger.debug(\"{}\", error.toString());\n+            if (error.status == 404) {\n+                legacyMode = true;\n+                logger.debug(\"VehicleStatus not found - switch to legacy API\");\n+                proxy.get().requestLegacyVehcileStatus(configuration.get(), oldVehicleStatusCallback);\n+            }\n+            vehicleStatusCache = Optional.of(Converter.getGson().toJson(error));\n+            setThingStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, error.reason);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMTg4MDMxNQ=="}, "originalCommit": {"oid": "5a568b041a01f7b8cd6e1290a8d969c40369480a"}, "originalPosition": 648}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzk0NjMyMzIyOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.bmwconnecteddrive/README.md", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNC0yOVQxNTozNTowNlrOJSTHjg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNS0wMVQxMjoxODoyNlrOJTklyw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYyMzE2NzM3NA==", "bodyText": "I've learned that the binding logo is added automatically, so you can remove it here. See here how to add a logo https://deploy-preview-1540--openhab-docs-preview.netlify.app/docs/developer/bindings/#add-your-binding-s-logo-to-the-openhab-website", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r623167374", "createdAt": "2021-04-29T15:35:06Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/README.md", "diffHunk": "@@ -0,0 +1,966 @@\n+# BMW ConnectedDrive Binding\n+\n+<img align=\"right\" src=\"./doc/bmw-connected.png\" width=\"150\" height=\"150\"/>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dd50d7ed5c3ab1aed876bc8eb1b303e87bc1a728"}, "originalPosition": 3}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYyNDUwMjIxOQ==", "bodyText": "Picture removed from repo & readme. I'll add to the picture repo after Pull Request is merged.", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r624502219", "createdAt": "2021-05-01T12:18:26Z", "author": {"login": "weymann"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/README.md", "diffHunk": "@@ -0,0 +1,966 @@\n+# BMW ConnectedDrive Binding\n+\n+<img align=\"right\" src=\"./doc/bmw-connected.png\" width=\"150\" height=\"150\"/>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYyMzE2NzM3NA=="}, "originalCommit": {"oid": "dd50d7ed5c3ab1aed876bc8eb1b303e87bc1a728"}, "originalPosition": 3}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzk0NjQ4OTAyOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/resources/OH-INF/binding/binding.xml", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNC0yOVQxNjowNjozOVrOJSUtrA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNS0wMVQxMjoxODo0NFrOJTkl-A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYyMzE5MzUxNg==", "bodyText": "The author tag is deprecated and should therefore be removed. See openhab/openhab-core#1844.", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r623193516", "createdAt": "2021-04-29T16:06:39Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/resources/OH-INF/binding/binding.xml", "diffHunk": "@@ -0,0 +1,10 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<binding:binding id=\"bmwconnecteddrive\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:binding=\"https://openhab.org/schemas/binding/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/binding/v1.0.0 https://openhab.org/schemas/binding-1.0.0.xsd\">\n+\n+\t<name>BMW ConnectedDrive</name>\n+\t<description>Provides access to your Vehicle Data via BMW Connected Drive Portal</description>\n+\t<author>Bernd Weymann</author>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dd50d7ed5c3ab1aed876bc8eb1b303e87bc1a728"}, "originalPosition": 8}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYyNDUwMjI2NA==", "bodyText": "removed", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r624502264", "createdAt": "2021-05-01T12:18:44Z", "author": {"login": "weymann"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/resources/OH-INF/binding/binding.xml", "diffHunk": "@@ -0,0 +1,10 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<binding:binding id=\"bmwconnecteddrive\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:binding=\"https://openhab.org/schemas/binding/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/binding/v1.0.0 https://openhab.org/schemas/binding-1.0.0.xsd\">\n+\n+\t<name>BMW ConnectedDrive</name>\n+\t<description>Provides access to your Vehicle Data via BMW Connected Drive Portal</description>\n+\t<author>Bernd Weymann</author>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYyMzE5MzUxNg=="}, "originalCommit": {"oid": "dd50d7ed5c3ab1aed876bc8eb1b303e87bc1a728"}, "originalPosition": 8}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEzNzYwMTUyOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.bmwconnecteddrive/.classpath", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wN1QxNTowNjowNlrOHd4Byw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMlQxMTo1MjoyNVrOH32Wjg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTA4ODcxNQ==", "bodyText": "This file is generated automatically by maven and should be removed from the PR.", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r501088715", "createdAt": "2020-10-07T15:06:06Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/.classpath", "diffHunk": "@@ -0,0 +1,38 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e0bfe93e13df4a3c5de5f8819b94ebf795664904"}, "originalPosition": 1}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODMyNDIzOA==", "bodyText": "done", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r528324238", "createdAt": "2020-11-22T11:52:25Z", "author": {"login": "weymann"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/.classpath", "diffHunk": "@@ -0,0 +1,38 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTA4ODcxNQ=="}, "originalCommit": {"oid": "e0bfe93e13df4a3c5de5f8819b94ebf795664904"}, "originalPosition": 1}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEzNzYwMjcxOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.bmwconnecteddrive/.project", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wN1QxNTowNjoxOVrOHd4CjA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMlQxMTo1MjozN1rOH32WqQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTA4ODkwOA==", "bodyText": "This file is generated automatically by maven and should be removed from the PR.", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r501088908", "createdAt": "2020-10-07T15:06:19Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/.project", "diffHunk": "@@ -0,0 +1,23 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e0bfe93e13df4a3c5de5f8819b94ebf795664904"}, "originalPosition": 1}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODMyNDI2NQ==", "bodyText": "done", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r528324265", "createdAt": "2020-11-22T11:52:37Z", "author": {"login": "weymann"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/.project", "diffHunk": "@@ -0,0 +1,23 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTA4ODkwOA=="}, "originalCommit": {"oid": "e0bfe93e13df4a3c5de5f8819b94ebf795664904"}, "originalPosition": 1}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEzNzYwNDg0OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.bmwconnecteddrive/README.md", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wN1QxNTowNjo0OFrOHd4D5w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yN1QxNToyODo0MVrOILsAQw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTA4OTI1NQ==", "bodyText": "Please check the capitalization in the whole readme.\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            The Binding provides a Connection between [BMWs ConnectedDrive Portal](https://www.bmw-connecteddrive.com/country-region-select/country-region-selection.html) and openHAB.\n          \n          \n            \n            The binding provides a connection between [BMW's ConnectedDrive Portal](https://www.bmw-connecteddrive.com/country-region-select/country-region-selection.html) and openHAB.", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r501089255", "createdAt": "2020-10-07T15:06:48Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/README.md", "diffHunk": "@@ -0,0 +1,862 @@\n+# BMW ConnectedDrive Binding\n+\n+<img align=\"right\" src=\"./doc/bmw-connected.png\" width=\"150\" height=\"150\"/>\n+\n+The Binding provides a Connection between [BMWs ConnectedDrive Portal](https://www.bmw-connecteddrive.com/country-region-select/country-region-selection.html) and openHAB.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e0bfe93e13df4a3c5de5f8819b94ebf795664904"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTEyNjIxMQ==", "bodyText": "I checked the mentioned issues and also tried to harmonize the readme to present a more consistent look.", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r549126211", "createdAt": "2020-12-27T15:28:41Z", "author": {"login": "weymann"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/README.md", "diffHunk": "@@ -0,0 +1,862 @@\n+# BMW ConnectedDrive Binding\n+\n+<img align=\"right\" src=\"./doc/bmw-connected.png\" width=\"150\" height=\"150\"/>\n+\n+The Binding provides a Connection between [BMWs ConnectedDrive Portal](https://www.bmw-connecteddrive.com/country-region-select/country-region-selection.html) and openHAB.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTA4OTI1NQ=="}, "originalCommit": {"oid": "e0bfe93e13df4a3c5de5f8819b94ebf795664904"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEzNzYxOTExOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.bmwconnecteddrive/README.md", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wN1QxNToxMDowMFrOHd4NCw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yM1QyMzozNjo1NVrOH4jn6g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTA5MTU5NQ==", "bodyText": "Thing Type IDs should start with lower case.", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r501091595", "createdAt": "2020-10-07T15:10:00Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/README.md", "diffHunk": "@@ -0,0 +1,862 @@\n+# BMW ConnectedDrive Binding\n+\n+<img align=\"right\" src=\"./doc/bmw-connected.png\" width=\"150\" height=\"150\"/>\n+\n+The Binding provides a Connection between [BMWs ConnectedDrive Portal](https://www.bmw-connecteddrive.com/country-region-select/country-region-selection.html) and openHAB.\n+All Vehicles connected to an Account will be detected by the Discovery with the correct type \n+\n+* Conventional Fuel Vehicle\n+* Plugin-Hybrid Electrical Vehicle \n+* Battery Electric Vehicle with Range Extender\n+* Battery Electric Vehicle \n+\n+In addition Properties are attached with Information and Services provided by this Vehicle.\n+The provided data depends on \n+\n+1. the [Type](#Things) and \n+2. the Services mentioned in [Properties](#properties)\n+\n+Different Channel Groups are clustering all informations.\n+Check for each Group if it's supported for this Vehicle.\n+\n+Please note **this isn't a real-time Binding**. \n+If the Door is opened the state isn't transmitted and changed immediately. \n+This isn't a flaw in the Binding itself because the state in BMWs own ConnectedDrive App is also updated with some delay. \n+\n+## Supported Things\n+\n+### Bridge\n+\n+The Bridge establishes the Connection between BMW ConnectedDrive Portal and openHAB.\n+\n+| Name                       | Bridge Type ID | Description                                                |\n+|----------------------------|----------------|------------------------------------------------------------|\n+| BMW ConnectedDrive Account | account        | Access to BMW ConnectedDrive Portal for a specific user    |\n+\n+\n+### Things\n+\n+Four different Vehicle Types are provided. \n+They differ in the supported Channel Groups & Channels. \n+Conventional Fuel Vehicles have no _Charging Profile_, Electric Vehicles don't provide a _Fuel Range_. \n+For Hybrid Vehicles in addition to _Fuel and Electric Range_ the _Hybrid Range_ is shown.\n+ \n+| Name                                | Thing Type ID | Supported Channel Groups                                             |\n+|-------------------------------------|---------------|----------------------------------------------------------------------|\n+| BMW Electric Vehicle                | BEV           | status, range, location, service, check, charge, image, troubleshoot |\n+| BMW Electric Vehicle with REX       | BEV_REX       | status, range, location, service, check, charge, image, troubleshoot |\n+| BMW Plug-In-Hybrid Electric Vehicle | PHEV          | status, range, location, service, check, charge, image, troubleshoot |\n+| BMW Conventional Vehicle            | CONV          | status, range, location, service, check, image, troubleshoot         |", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e0bfe93e13df4a3c5de5f8819b94ebf795664904"}, "originalPosition": 49}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTA2NTk2Mg==", "bodyText": "Corrected", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r529065962", "createdAt": "2020-11-23T23:36:55Z", "author": {"login": "weymann"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/README.md", "diffHunk": "@@ -0,0 +1,862 @@\n+# BMW ConnectedDrive Binding\n+\n+<img align=\"right\" src=\"./doc/bmw-connected.png\" width=\"150\" height=\"150\"/>\n+\n+The Binding provides a Connection between [BMWs ConnectedDrive Portal](https://www.bmw-connecteddrive.com/country-region-select/country-region-selection.html) and openHAB.\n+All Vehicles connected to an Account will be detected by the Discovery with the correct type \n+\n+* Conventional Fuel Vehicle\n+* Plugin-Hybrid Electrical Vehicle \n+* Battery Electric Vehicle with Range Extender\n+* Battery Electric Vehicle \n+\n+In addition Properties are attached with Information and Services provided by this Vehicle.\n+The provided data depends on \n+\n+1. the [Type](#Things) and \n+2. the Services mentioned in [Properties](#properties)\n+\n+Different Channel Groups are clustering all informations.\n+Check for each Group if it's supported for this Vehicle.\n+\n+Please note **this isn't a real-time Binding**. \n+If the Door is opened the state isn't transmitted and changed immediately. \n+This isn't a flaw in the Binding itself because the state in BMWs own ConnectedDrive App is also updated with some delay. \n+\n+## Supported Things\n+\n+### Bridge\n+\n+The Bridge establishes the Connection between BMW ConnectedDrive Portal and openHAB.\n+\n+| Name                       | Bridge Type ID | Description                                                |\n+|----------------------------|----------------|------------------------------------------------------------|\n+| BMW ConnectedDrive Account | account        | Access to BMW ConnectedDrive Portal for a specific user    |\n+\n+\n+### Things\n+\n+Four different Vehicle Types are provided. \n+They differ in the supported Channel Groups & Channels. \n+Conventional Fuel Vehicles have no _Charging Profile_, Electric Vehicles don't provide a _Fuel Range_. \n+For Hybrid Vehicles in addition to _Fuel and Electric Range_ the _Hybrid Range_ is shown.\n+ \n+| Name                                | Thing Type ID | Supported Channel Groups                                             |\n+|-------------------------------------|---------------|----------------------------------------------------------------------|\n+| BMW Electric Vehicle                | BEV           | status, range, location, service, check, charge, image, troubleshoot |\n+| BMW Electric Vehicle with REX       | BEV_REX       | status, range, location, service, check, charge, image, troubleshoot |\n+| BMW Plug-In-Hybrid Electric Vehicle | PHEV          | status, range, location, service, check, charge, image, troubleshoot |\n+| BMW Conventional Vehicle            | CONV          | status, range, location, service, check, image, troubleshoot         |", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTA5MTU5NQ=="}, "originalCommit": {"oid": "e0bfe93e13df4a3c5de5f8819b94ebf795664904"}, "originalPosition": 49}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEzNzYzMDMxOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.bmwconnecteddrive/README.md", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wN1QxNToxMjoxOFrOHd4UKg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMlQxMzoyNTo0MFrOH33CCg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTA5MzQxOA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            | units           | text    | Unit Selection                        |\n          \n          \n            \n            | units           | text    | Unit Selection. See below.                        |", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r501093418", "createdAt": "2020-10-07T15:12:18Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/README.md", "diffHunk": "@@ -0,0 +1,862 @@\n+# BMW ConnectedDrive Binding\n+\n+<img align=\"right\" src=\"./doc/bmw-connected.png\" width=\"150\" height=\"150\"/>\n+\n+The Binding provides a Connection between [BMWs ConnectedDrive Portal](https://www.bmw-connecteddrive.com/country-region-select/country-region-selection.html) and openHAB.\n+All Vehicles connected to an Account will be detected by the Discovery with the correct type \n+\n+* Conventional Fuel Vehicle\n+* Plugin-Hybrid Electrical Vehicle \n+* Battery Electric Vehicle with Range Extender\n+* Battery Electric Vehicle \n+\n+In addition Properties are attached with Information and Services provided by this Vehicle.\n+The provided data depends on \n+\n+1. the [Type](#Things) and \n+2. the Services mentioned in [Properties](#properties)\n+\n+Different Channel Groups are clustering all informations.\n+Check for each Group if it's supported for this Vehicle.\n+\n+Please note **this isn't a real-time Binding**. \n+If the Door is opened the state isn't transmitted and changed immediately. \n+This isn't a flaw in the Binding itself because the state in BMWs own ConnectedDrive App is also updated with some delay. \n+\n+## Supported Things\n+\n+### Bridge\n+\n+The Bridge establishes the Connection between BMW ConnectedDrive Portal and openHAB.\n+\n+| Name                       | Bridge Type ID | Description                                                |\n+|----------------------------|----------------|------------------------------------------------------------|\n+| BMW ConnectedDrive Account | account        | Access to BMW ConnectedDrive Portal for a specific user    |\n+\n+\n+### Things\n+\n+Four different Vehicle Types are provided. \n+They differ in the supported Channel Groups & Channels. \n+Conventional Fuel Vehicles have no _Charging Profile_, Electric Vehicles don't provide a _Fuel Range_. \n+For Hybrid Vehicles in addition to _Fuel and Electric Range_ the _Hybrid Range_ is shown.\n+ \n+| Name                                | Thing Type ID | Supported Channel Groups                                             |\n+|-------------------------------------|---------------|----------------------------------------------------------------------|\n+| BMW Electric Vehicle                | BEV           | status, range, location, service, check, charge, image, troubleshoot |\n+| BMW Electric Vehicle with REX       | BEV_REX       | status, range, location, service, check, charge, image, troubleshoot |\n+| BMW Plug-In-Hybrid Electric Vehicle | PHEV          | status, range, location, service, check, charge, image, troubleshoot |\n+| BMW Conventional Vehicle            | CONV          | status, range, location, service, check, image, troubleshoot         |\n+\n+ \n+#### Properties\n+\n+<img align=\"right\" src=\"./doc/properties.png\" width=\"500\" height=\"600\"/>\n+\n+For each Vehicle Properties are available. \n+Basically 3 Types of Information are registered as Properties\n+\n+* Informations regarding your Dealer with Address and Phone Number\n+* Which services are available / not available\n+* Vehicle Properties like Color, Model Type, Drive Train and Construction Year\n+\n+In the right picture  can see in *Services Activated* e.g. the *DoorLock* and *DoorUnlock* Services are mentioned. \n+This ensures [Channel Group _Remote Services_](#remote-services) is supporting Door lock and Door unlock.\n+\n+In  *Services Supported* the entry *LastDestination* is mentioned.\n+So it's valid to connect Channel Group [Last Destinations](#destinations) in order to display the last 3 Navigation Destinations.\n+\n+| Property Key       | Property Value      |  Supported Channel Groups    |\n+|--------------------|---------------------|------------------------------|\n+| Services Supported | Statistics          | last-trip, lifetime          |\n+| Services Supported | LastDestinations    | destinations                 |\n+| Services Activated | list of services    | remote                       |\n+\n+\n+## Discovery\n+\n+Auto Discovery is starting after creation of the Bridge towards BMW ConnectedDrive. \n+A list of your registered Vehicles is queried and all found Vehicles are added in Inbox.\n+Unique Identifier is the *Vehicle Identification Number* (VIN). \n+If a Thing is already declared in a  *.things configuration* Discovery won't highlight it again.\n+Properties will be attached to predefined Vehicles if the VIN is matching.\n+\n+## Configuration\n+\n+### Bridge\n+\n+| Parameter       | Type    | Description                                                             |           \n+|-----------------|---------|-------------------------------------------------------------------------|\n+| userName        | text    | BMW Connected Drive Username                  |\n+| password        | text    | BMW Connected Drive Password                  |\n+| region          | text    | Select Region in order to connect to the appropriate BMW Server.   |\n+\n+The region Configuration has 3 different possibilities\n+\n+* _NORTH_AMERICA_\n+* _CHINA_\n+* _ROW_ for Rest of World\n+\n+### Thing\n+\n+Same Configuration is needed for all Things\n+\n+| Parameter       | Type    | Description                           |           \n+|-----------------|---------|---------------------------------------|\n+| vin             | text    | Vehicle Identification Number (VIN)   |\n+| refreshInterval | integer | Refresh Interval in Minutes           |\n+| units           | text    | Unit Selection                        |", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e0bfe93e13df4a3c5de5f8819b94ebf795664904"}, "originalPosition": 108}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODMzNTM3MA==", "bodyText": "done", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r528335370", "createdAt": "2020-11-22T13:25:40Z", "author": {"login": "weymann"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/README.md", "diffHunk": "@@ -0,0 +1,862 @@\n+# BMW ConnectedDrive Binding\n+\n+<img align=\"right\" src=\"./doc/bmw-connected.png\" width=\"150\" height=\"150\"/>\n+\n+The Binding provides a Connection between [BMWs ConnectedDrive Portal](https://www.bmw-connecteddrive.com/country-region-select/country-region-selection.html) and openHAB.\n+All Vehicles connected to an Account will be detected by the Discovery with the correct type \n+\n+* Conventional Fuel Vehicle\n+* Plugin-Hybrid Electrical Vehicle \n+* Battery Electric Vehicle with Range Extender\n+* Battery Electric Vehicle \n+\n+In addition Properties are attached with Information and Services provided by this Vehicle.\n+The provided data depends on \n+\n+1. the [Type](#Things) and \n+2. the Services mentioned in [Properties](#properties)\n+\n+Different Channel Groups are clustering all informations.\n+Check for each Group if it's supported for this Vehicle.\n+\n+Please note **this isn't a real-time Binding**. \n+If the Door is opened the state isn't transmitted and changed immediately. \n+This isn't a flaw in the Binding itself because the state in BMWs own ConnectedDrive App is also updated with some delay. \n+\n+## Supported Things\n+\n+### Bridge\n+\n+The Bridge establishes the Connection between BMW ConnectedDrive Portal and openHAB.\n+\n+| Name                       | Bridge Type ID | Description                                                |\n+|----------------------------|----------------|------------------------------------------------------------|\n+| BMW ConnectedDrive Account | account        | Access to BMW ConnectedDrive Portal for a specific user    |\n+\n+\n+### Things\n+\n+Four different Vehicle Types are provided. \n+They differ in the supported Channel Groups & Channels. \n+Conventional Fuel Vehicles have no _Charging Profile_, Electric Vehicles don't provide a _Fuel Range_. \n+For Hybrid Vehicles in addition to _Fuel and Electric Range_ the _Hybrid Range_ is shown.\n+ \n+| Name                                | Thing Type ID | Supported Channel Groups                                             |\n+|-------------------------------------|---------------|----------------------------------------------------------------------|\n+| BMW Electric Vehicle                | BEV           | status, range, location, service, check, charge, image, troubleshoot |\n+| BMW Electric Vehicle with REX       | BEV_REX       | status, range, location, service, check, charge, image, troubleshoot |\n+| BMW Plug-In-Hybrid Electric Vehicle | PHEV          | status, range, location, service, check, charge, image, troubleshoot |\n+| BMW Conventional Vehicle            | CONV          | status, range, location, service, check, image, troubleshoot         |\n+\n+ \n+#### Properties\n+\n+<img align=\"right\" src=\"./doc/properties.png\" width=\"500\" height=\"600\"/>\n+\n+For each Vehicle Properties are available. \n+Basically 3 Types of Information are registered as Properties\n+\n+* Informations regarding your Dealer with Address and Phone Number\n+* Which services are available / not available\n+* Vehicle Properties like Color, Model Type, Drive Train and Construction Year\n+\n+In the right picture  can see in *Services Activated* e.g. the *DoorLock* and *DoorUnlock* Services are mentioned. \n+This ensures [Channel Group _Remote Services_](#remote-services) is supporting Door lock and Door unlock.\n+\n+In  *Services Supported* the entry *LastDestination* is mentioned.\n+So it's valid to connect Channel Group [Last Destinations](#destinations) in order to display the last 3 Navigation Destinations.\n+\n+| Property Key       | Property Value      |  Supported Channel Groups    |\n+|--------------------|---------------------|------------------------------|\n+| Services Supported | Statistics          | last-trip, lifetime          |\n+| Services Supported | LastDestinations    | destinations                 |\n+| Services Activated | list of services    | remote                       |\n+\n+\n+## Discovery\n+\n+Auto Discovery is starting after creation of the Bridge towards BMW ConnectedDrive. \n+A list of your registered Vehicles is queried and all found Vehicles are added in Inbox.\n+Unique Identifier is the *Vehicle Identification Number* (VIN). \n+If a Thing is already declared in a  *.things configuration* Discovery won't highlight it again.\n+Properties will be attached to predefined Vehicles if the VIN is matching.\n+\n+## Configuration\n+\n+### Bridge\n+\n+| Parameter       | Type    | Description                                                             |           \n+|-----------------|---------|-------------------------------------------------------------------------|\n+| userName        | text    | BMW Connected Drive Username                  |\n+| password        | text    | BMW Connected Drive Password                  |\n+| region          | text    | Select Region in order to connect to the appropriate BMW Server.   |\n+\n+The region Configuration has 3 different possibilities\n+\n+* _NORTH_AMERICA_\n+* _CHINA_\n+* _ROW_ for Rest of World\n+\n+### Thing\n+\n+Same Configuration is needed for all Things\n+\n+| Parameter       | Type    | Description                           |           \n+|-----------------|---------|---------------------------------------|\n+| vin             | text    | Vehicle Identification Number (VIN)   |\n+| refreshInterval | integer | Refresh Interval in Minutes           |\n+| units           | text    | Unit Selection                        |", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTA5MzQxOA=="}, "originalCommit": {"oid": "e0bfe93e13df4a3c5de5f8819b94ebf795664904"}, "originalPosition": 108}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEzNzY0NjYxOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.bmwconnecteddrive/README.md", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wN1QxNToxNTo1MVrOHd4esA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yN1QxNTozMjowOFrOILsBbQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTA5NjExMg==", "bodyText": "Is there a reason why you don't log any error by default? Actually, logging should be configured in the framework config.", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r501096112", "createdAt": "2020-10-07T15:15:51Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/README.md", "diffHunk": "@@ -0,0 +1,862 @@\n+# BMW ConnectedDrive Binding\n+\n+<img align=\"right\" src=\"./doc/bmw-connected.png\" width=\"150\" height=\"150\"/>\n+\n+The Binding provides a Connection between [BMWs ConnectedDrive Portal](https://www.bmw-connecteddrive.com/country-region-select/country-region-selection.html) and openHAB.\n+All Vehicles connected to an Account will be detected by the Discovery with the correct type \n+\n+* Conventional Fuel Vehicle\n+* Plugin-Hybrid Electrical Vehicle \n+* Battery Electric Vehicle with Range Extender\n+* Battery Electric Vehicle \n+\n+In addition Properties are attached with Information and Services provided by this Vehicle.\n+The provided data depends on \n+\n+1. the [Type](#Things) and \n+2. the Services mentioned in [Properties](#properties)\n+\n+Different Channel Groups are clustering all informations.\n+Check for each Group if it's supported for this Vehicle.\n+\n+Please note **this isn't a real-time Binding**. \n+If the Door is opened the state isn't transmitted and changed immediately. \n+This isn't a flaw in the Binding itself because the state in BMWs own ConnectedDrive App is also updated with some delay. \n+\n+## Supported Things\n+\n+### Bridge\n+\n+The Bridge establishes the Connection between BMW ConnectedDrive Portal and openHAB.\n+\n+| Name                       | Bridge Type ID | Description                                                |\n+|----------------------------|----------------|------------------------------------------------------------|\n+| BMW ConnectedDrive Account | account        | Access to BMW ConnectedDrive Portal for a specific user    |\n+\n+\n+### Things\n+\n+Four different Vehicle Types are provided. \n+They differ in the supported Channel Groups & Channels. \n+Conventional Fuel Vehicles have no _Charging Profile_, Electric Vehicles don't provide a _Fuel Range_. \n+For Hybrid Vehicles in addition to _Fuel and Electric Range_ the _Hybrid Range_ is shown.\n+ \n+| Name                                | Thing Type ID | Supported Channel Groups                                             |\n+|-------------------------------------|---------------|----------------------------------------------------------------------|\n+| BMW Electric Vehicle                | BEV           | status, range, location, service, check, charge, image, troubleshoot |\n+| BMW Electric Vehicle with REX       | BEV_REX       | status, range, location, service, check, charge, image, troubleshoot |\n+| BMW Plug-In-Hybrid Electric Vehicle | PHEV          | status, range, location, service, check, charge, image, troubleshoot |\n+| BMW Conventional Vehicle            | CONV          | status, range, location, service, check, image, troubleshoot         |\n+\n+ \n+#### Properties\n+\n+<img align=\"right\" src=\"./doc/properties.png\" width=\"500\" height=\"600\"/>\n+\n+For each Vehicle Properties are available. \n+Basically 3 Types of Information are registered as Properties\n+\n+* Informations regarding your Dealer with Address and Phone Number\n+* Which services are available / not available\n+* Vehicle Properties like Color, Model Type, Drive Train and Construction Year\n+\n+In the right picture  can see in *Services Activated* e.g. the *DoorLock* and *DoorUnlock* Services are mentioned. \n+This ensures [Channel Group _Remote Services_](#remote-services) is supporting Door lock and Door unlock.\n+\n+In  *Services Supported* the entry *LastDestination* is mentioned.\n+So it's valid to connect Channel Group [Last Destinations](#destinations) in order to display the last 3 Navigation Destinations.\n+\n+| Property Key       | Property Value      |  Supported Channel Groups    |\n+|--------------------|---------------------|------------------------------|\n+| Services Supported | Statistics          | last-trip, lifetime          |\n+| Services Supported | LastDestinations    | destinations                 |\n+| Services Activated | list of services    | remote                       |\n+\n+\n+## Discovery\n+\n+Auto Discovery is starting after creation of the Bridge towards BMW ConnectedDrive. \n+A list of your registered Vehicles is queried and all found Vehicles are added in Inbox.\n+Unique Identifier is the *Vehicle Identification Number* (VIN). \n+If a Thing is already declared in a  *.things configuration* Discovery won't highlight it again.\n+Properties will be attached to predefined Vehicles if the VIN is matching.\n+\n+## Configuration\n+\n+### Bridge\n+\n+| Parameter       | Type    | Description                                                             |           \n+|-----------------|---------|-------------------------------------------------------------------------|\n+| userName        | text    | BMW Connected Drive Username                  |\n+| password        | text    | BMW Connected Drive Password                  |\n+| region          | text    | Select Region in order to connect to the appropriate BMW Server.   |\n+\n+The region Configuration has 3 different possibilities\n+\n+* _NORTH_AMERICA_\n+* _CHINA_\n+* _ROW_ for Rest of World\n+\n+### Thing\n+\n+Same Configuration is needed for all Things\n+\n+| Parameter       | Type    | Description                           |           \n+|-----------------|---------|---------------------------------------|\n+| vin             | text    | Vehicle Identification Number (VIN)   |\n+| refreshInterval | integer | Refresh Interval in Minutes           |\n+| units           | text    | Unit Selection                        |\n+| imageSize       | integer | Image Size                            |\n+| imageViewport   | text    | Image Viewport                        |\n+\n+The units can be configured in 3 ways\n+\n+* _AUTODETECT_ selects Miles for US & UK, Kilometer otherwise\n+* _METRIC_ selects directly Kilometers\n+* _IMPERIAL_ selects directly Miles\n+\n+The imageVieport allows to show the Vehicle from different angels.\n+Possible values are \n+\n+* FRONT\n+* REAR\n+* SIDE\n+* DASHBOARD\n+* DRIVERDOOR\n+\n+## Channels\n+\n+There are many Channels available for each Vehicle. \n+For better overview they are clustered in different Channel Groups.\n+The Channel Groups are different for the Vehicle Types, on the build-in Sensors of the Vehicle and the activated Services.\n+\n+### Bridge Channels\n+\n+If the Vehicle isn't found in the Discovery force a log of Fingerprint Data which helps to analyze the problem.\n+Please check [TroubleShooting Section](#TroubleShooting) for further advice.\n+\n+| Channel Label         | Channel ID            | Type   | Description                                       |\n+|-----------------------|-----------------------|--------|---------------------------------------------------|\n+| Discovery Fingerprint | discovery-fingerprint | Switch | Forcing a log entry to analyze Discovery Problems |", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e0bfe93e13df4a3c5de5f8819b94ebf795664904"}, "originalPosition": 140}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODMzOTIzMQ==", "bodyText": "Logging repeatedly some errors e.g. when retrieving wrong information is not wanted. So I took over the fingerprint concept from BimmerConnected. With this it can be checked if it's a server issue, authorization issue or a logical problem in the code. In the latter case unit test will be expanded with the new data.", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r528339231", "createdAt": "2020-11-22T13:56:07Z", "author": {"login": "weymann"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/README.md", "diffHunk": "@@ -0,0 +1,862 @@\n+# BMW ConnectedDrive Binding\n+\n+<img align=\"right\" src=\"./doc/bmw-connected.png\" width=\"150\" height=\"150\"/>\n+\n+The Binding provides a Connection between [BMWs ConnectedDrive Portal](https://www.bmw-connecteddrive.com/country-region-select/country-region-selection.html) and openHAB.\n+All Vehicles connected to an Account will be detected by the Discovery with the correct type \n+\n+* Conventional Fuel Vehicle\n+* Plugin-Hybrid Electrical Vehicle \n+* Battery Electric Vehicle with Range Extender\n+* Battery Electric Vehicle \n+\n+In addition Properties are attached with Information and Services provided by this Vehicle.\n+The provided data depends on \n+\n+1. the [Type](#Things) and \n+2. the Services mentioned in [Properties](#properties)\n+\n+Different Channel Groups are clustering all informations.\n+Check for each Group if it's supported for this Vehicle.\n+\n+Please note **this isn't a real-time Binding**. \n+If the Door is opened the state isn't transmitted and changed immediately. \n+This isn't a flaw in the Binding itself because the state in BMWs own ConnectedDrive App is also updated with some delay. \n+\n+## Supported Things\n+\n+### Bridge\n+\n+The Bridge establishes the Connection between BMW ConnectedDrive Portal and openHAB.\n+\n+| Name                       | Bridge Type ID | Description                                                |\n+|----------------------------|----------------|------------------------------------------------------------|\n+| BMW ConnectedDrive Account | account        | Access to BMW ConnectedDrive Portal for a specific user    |\n+\n+\n+### Things\n+\n+Four different Vehicle Types are provided. \n+They differ in the supported Channel Groups & Channels. \n+Conventional Fuel Vehicles have no _Charging Profile_, Electric Vehicles don't provide a _Fuel Range_. \n+For Hybrid Vehicles in addition to _Fuel and Electric Range_ the _Hybrid Range_ is shown.\n+ \n+| Name                                | Thing Type ID | Supported Channel Groups                                             |\n+|-------------------------------------|---------------|----------------------------------------------------------------------|\n+| BMW Electric Vehicle                | BEV           | status, range, location, service, check, charge, image, troubleshoot |\n+| BMW Electric Vehicle with REX       | BEV_REX       | status, range, location, service, check, charge, image, troubleshoot |\n+| BMW Plug-In-Hybrid Electric Vehicle | PHEV          | status, range, location, service, check, charge, image, troubleshoot |\n+| BMW Conventional Vehicle            | CONV          | status, range, location, service, check, image, troubleshoot         |\n+\n+ \n+#### Properties\n+\n+<img align=\"right\" src=\"./doc/properties.png\" width=\"500\" height=\"600\"/>\n+\n+For each Vehicle Properties are available. \n+Basically 3 Types of Information are registered as Properties\n+\n+* Informations regarding your Dealer with Address and Phone Number\n+* Which services are available / not available\n+* Vehicle Properties like Color, Model Type, Drive Train and Construction Year\n+\n+In the right picture  can see in *Services Activated* e.g. the *DoorLock* and *DoorUnlock* Services are mentioned. \n+This ensures [Channel Group _Remote Services_](#remote-services) is supporting Door lock and Door unlock.\n+\n+In  *Services Supported* the entry *LastDestination* is mentioned.\n+So it's valid to connect Channel Group [Last Destinations](#destinations) in order to display the last 3 Navigation Destinations.\n+\n+| Property Key       | Property Value      |  Supported Channel Groups    |\n+|--------------------|---------------------|------------------------------|\n+| Services Supported | Statistics          | last-trip, lifetime          |\n+| Services Supported | LastDestinations    | destinations                 |\n+| Services Activated | list of services    | remote                       |\n+\n+\n+## Discovery\n+\n+Auto Discovery is starting after creation of the Bridge towards BMW ConnectedDrive. \n+A list of your registered Vehicles is queried and all found Vehicles are added in Inbox.\n+Unique Identifier is the *Vehicle Identification Number* (VIN). \n+If a Thing is already declared in a  *.things configuration* Discovery won't highlight it again.\n+Properties will be attached to predefined Vehicles if the VIN is matching.\n+\n+## Configuration\n+\n+### Bridge\n+\n+| Parameter       | Type    | Description                                                             |           \n+|-----------------|---------|-------------------------------------------------------------------------|\n+| userName        | text    | BMW Connected Drive Username                  |\n+| password        | text    | BMW Connected Drive Password                  |\n+| region          | text    | Select Region in order to connect to the appropriate BMW Server.   |\n+\n+The region Configuration has 3 different possibilities\n+\n+* _NORTH_AMERICA_\n+* _CHINA_\n+* _ROW_ for Rest of World\n+\n+### Thing\n+\n+Same Configuration is needed for all Things\n+\n+| Parameter       | Type    | Description                           |           \n+|-----------------|---------|---------------------------------------|\n+| vin             | text    | Vehicle Identification Number (VIN)   |\n+| refreshInterval | integer | Refresh Interval in Minutes           |\n+| units           | text    | Unit Selection                        |\n+| imageSize       | integer | Image Size                            |\n+| imageViewport   | text    | Image Viewport                        |\n+\n+The units can be configured in 3 ways\n+\n+* _AUTODETECT_ selects Miles for US & UK, Kilometer otherwise\n+* _METRIC_ selects directly Kilometers\n+* _IMPERIAL_ selects directly Miles\n+\n+The imageVieport allows to show the Vehicle from different angels.\n+Possible values are \n+\n+* FRONT\n+* REAR\n+* SIDE\n+* DASHBOARD\n+* DRIVERDOOR\n+\n+## Channels\n+\n+There are many Channels available for each Vehicle. \n+For better overview they are clustered in different Channel Groups.\n+The Channel Groups are different for the Vehicle Types, on the build-in Sensors of the Vehicle and the activated Services.\n+\n+### Bridge Channels\n+\n+If the Vehicle isn't found in the Discovery force a log of Fingerprint Data which helps to analyze the problem.\n+Please check [TroubleShooting Section](#TroubleShooting) for further advice.\n+\n+| Channel Label         | Channel ID            | Type   | Description                                       |\n+|-----------------------|-----------------------|--------|---------------------------------------------------|\n+| Discovery Fingerprint | discovery-fingerprint | Switch | Forcing a log entry to analyze Discovery Problems |", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTA5NjExMg=="}, "originalCommit": {"oid": "e0bfe93e13df4a3c5de5f8819b94ebf795664904"}, "originalPosition": 140}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTg0MTA5NA==", "bodyText": "Still, I agree with @fwolter that there should not be channels to adapt logging behavior.\nIf the user wants to debug some issues, he should switch the binding to debug logging and find in there what he needs.", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r529841094", "createdAt": "2020-11-24T19:55:59Z", "author": {"login": "kaikreuzer"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/README.md", "diffHunk": "@@ -0,0 +1,862 @@\n+# BMW ConnectedDrive Binding\n+\n+<img align=\"right\" src=\"./doc/bmw-connected.png\" width=\"150\" height=\"150\"/>\n+\n+The Binding provides a Connection between [BMWs ConnectedDrive Portal](https://www.bmw-connecteddrive.com/country-region-select/country-region-selection.html) and openHAB.\n+All Vehicles connected to an Account will be detected by the Discovery with the correct type \n+\n+* Conventional Fuel Vehicle\n+* Plugin-Hybrid Electrical Vehicle \n+* Battery Electric Vehicle with Range Extender\n+* Battery Electric Vehicle \n+\n+In addition Properties are attached with Information and Services provided by this Vehicle.\n+The provided data depends on \n+\n+1. the [Type](#Things) and \n+2. the Services mentioned in [Properties](#properties)\n+\n+Different Channel Groups are clustering all informations.\n+Check for each Group if it's supported for this Vehicle.\n+\n+Please note **this isn't a real-time Binding**. \n+If the Door is opened the state isn't transmitted and changed immediately. \n+This isn't a flaw in the Binding itself because the state in BMWs own ConnectedDrive App is also updated with some delay. \n+\n+## Supported Things\n+\n+### Bridge\n+\n+The Bridge establishes the Connection between BMW ConnectedDrive Portal and openHAB.\n+\n+| Name                       | Bridge Type ID | Description                                                |\n+|----------------------------|----------------|------------------------------------------------------------|\n+| BMW ConnectedDrive Account | account        | Access to BMW ConnectedDrive Portal for a specific user    |\n+\n+\n+### Things\n+\n+Four different Vehicle Types are provided. \n+They differ in the supported Channel Groups & Channels. \n+Conventional Fuel Vehicles have no _Charging Profile_, Electric Vehicles don't provide a _Fuel Range_. \n+For Hybrid Vehicles in addition to _Fuel and Electric Range_ the _Hybrid Range_ is shown.\n+ \n+| Name                                | Thing Type ID | Supported Channel Groups                                             |\n+|-------------------------------------|---------------|----------------------------------------------------------------------|\n+| BMW Electric Vehicle                | BEV           | status, range, location, service, check, charge, image, troubleshoot |\n+| BMW Electric Vehicle with REX       | BEV_REX       | status, range, location, service, check, charge, image, troubleshoot |\n+| BMW Plug-In-Hybrid Electric Vehicle | PHEV          | status, range, location, service, check, charge, image, troubleshoot |\n+| BMW Conventional Vehicle            | CONV          | status, range, location, service, check, image, troubleshoot         |\n+\n+ \n+#### Properties\n+\n+<img align=\"right\" src=\"./doc/properties.png\" width=\"500\" height=\"600\"/>\n+\n+For each Vehicle Properties are available. \n+Basically 3 Types of Information are registered as Properties\n+\n+* Informations regarding your Dealer with Address and Phone Number\n+* Which services are available / not available\n+* Vehicle Properties like Color, Model Type, Drive Train and Construction Year\n+\n+In the right picture  can see in *Services Activated* e.g. the *DoorLock* and *DoorUnlock* Services are mentioned. \n+This ensures [Channel Group _Remote Services_](#remote-services) is supporting Door lock and Door unlock.\n+\n+In  *Services Supported* the entry *LastDestination* is mentioned.\n+So it's valid to connect Channel Group [Last Destinations](#destinations) in order to display the last 3 Navigation Destinations.\n+\n+| Property Key       | Property Value      |  Supported Channel Groups    |\n+|--------------------|---------------------|------------------------------|\n+| Services Supported | Statistics          | last-trip, lifetime          |\n+| Services Supported | LastDestinations    | destinations                 |\n+| Services Activated | list of services    | remote                       |\n+\n+\n+## Discovery\n+\n+Auto Discovery is starting after creation of the Bridge towards BMW ConnectedDrive. \n+A list of your registered Vehicles is queried and all found Vehicles are added in Inbox.\n+Unique Identifier is the *Vehicle Identification Number* (VIN). \n+If a Thing is already declared in a  *.things configuration* Discovery won't highlight it again.\n+Properties will be attached to predefined Vehicles if the VIN is matching.\n+\n+## Configuration\n+\n+### Bridge\n+\n+| Parameter       | Type    | Description                                                             |           \n+|-----------------|---------|-------------------------------------------------------------------------|\n+| userName        | text    | BMW Connected Drive Username                  |\n+| password        | text    | BMW Connected Drive Password                  |\n+| region          | text    | Select Region in order to connect to the appropriate BMW Server.   |\n+\n+The region Configuration has 3 different possibilities\n+\n+* _NORTH_AMERICA_\n+* _CHINA_\n+* _ROW_ for Rest of World\n+\n+### Thing\n+\n+Same Configuration is needed for all Things\n+\n+| Parameter       | Type    | Description                           |           \n+|-----------------|---------|---------------------------------------|\n+| vin             | text    | Vehicle Identification Number (VIN)   |\n+| refreshInterval | integer | Refresh Interval in Minutes           |\n+| units           | text    | Unit Selection                        |\n+| imageSize       | integer | Image Size                            |\n+| imageViewport   | text    | Image Viewport                        |\n+\n+The units can be configured in 3 ways\n+\n+* _AUTODETECT_ selects Miles for US & UK, Kilometer otherwise\n+* _METRIC_ selects directly Kilometers\n+* _IMPERIAL_ selects directly Miles\n+\n+The imageVieport allows to show the Vehicle from different angels.\n+Possible values are \n+\n+* FRONT\n+* REAR\n+* SIDE\n+* DASHBOARD\n+* DRIVERDOOR\n+\n+## Channels\n+\n+There are many Channels available for each Vehicle. \n+For better overview they are clustered in different Channel Groups.\n+The Channel Groups are different for the Vehicle Types, on the build-in Sensors of the Vehicle and the activated Services.\n+\n+### Bridge Channels\n+\n+If the Vehicle isn't found in the Discovery force a log of Fingerprint Data which helps to analyze the problem.\n+Please check [TroubleShooting Section](#TroubleShooting) for further advice.\n+\n+| Channel Label         | Channel ID            | Type   | Description                                       |\n+|-----------------------|-----------------------|--------|---------------------------------------------------|\n+| Discovery Fingerprint | discovery-fingerprint | Switch | Forcing a log entry to analyze Discovery Problems |", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTA5NjExMg=="}, "originalCommit": {"oid": "e0bfe93e13df4a3c5de5f8819b94ebf795664904"}, "originalPosition": 140}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTEyNjUwOQ==", "bodyText": "Fingerprint is now logged every time on startup / thing initialization instead of user command.", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r549126509", "createdAt": "2020-12-27T15:32:08Z", "author": {"login": "weymann"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/README.md", "diffHunk": "@@ -0,0 +1,862 @@\n+# BMW ConnectedDrive Binding\n+\n+<img align=\"right\" src=\"./doc/bmw-connected.png\" width=\"150\" height=\"150\"/>\n+\n+The Binding provides a Connection between [BMWs ConnectedDrive Portal](https://www.bmw-connecteddrive.com/country-region-select/country-region-selection.html) and openHAB.\n+All Vehicles connected to an Account will be detected by the Discovery with the correct type \n+\n+* Conventional Fuel Vehicle\n+* Plugin-Hybrid Electrical Vehicle \n+* Battery Electric Vehicle with Range Extender\n+* Battery Electric Vehicle \n+\n+In addition Properties are attached with Information and Services provided by this Vehicle.\n+The provided data depends on \n+\n+1. the [Type](#Things) and \n+2. the Services mentioned in [Properties](#properties)\n+\n+Different Channel Groups are clustering all informations.\n+Check for each Group if it's supported for this Vehicle.\n+\n+Please note **this isn't a real-time Binding**. \n+If the Door is opened the state isn't transmitted and changed immediately. \n+This isn't a flaw in the Binding itself because the state in BMWs own ConnectedDrive App is also updated with some delay. \n+\n+## Supported Things\n+\n+### Bridge\n+\n+The Bridge establishes the Connection between BMW ConnectedDrive Portal and openHAB.\n+\n+| Name                       | Bridge Type ID | Description                                                |\n+|----------------------------|----------------|------------------------------------------------------------|\n+| BMW ConnectedDrive Account | account        | Access to BMW ConnectedDrive Portal for a specific user    |\n+\n+\n+### Things\n+\n+Four different Vehicle Types are provided. \n+They differ in the supported Channel Groups & Channels. \n+Conventional Fuel Vehicles have no _Charging Profile_, Electric Vehicles don't provide a _Fuel Range_. \n+For Hybrid Vehicles in addition to _Fuel and Electric Range_ the _Hybrid Range_ is shown.\n+ \n+| Name                                | Thing Type ID | Supported Channel Groups                                             |\n+|-------------------------------------|---------------|----------------------------------------------------------------------|\n+| BMW Electric Vehicle                | BEV           | status, range, location, service, check, charge, image, troubleshoot |\n+| BMW Electric Vehicle with REX       | BEV_REX       | status, range, location, service, check, charge, image, troubleshoot |\n+| BMW Plug-In-Hybrid Electric Vehicle | PHEV          | status, range, location, service, check, charge, image, troubleshoot |\n+| BMW Conventional Vehicle            | CONV          | status, range, location, service, check, image, troubleshoot         |\n+\n+ \n+#### Properties\n+\n+<img align=\"right\" src=\"./doc/properties.png\" width=\"500\" height=\"600\"/>\n+\n+For each Vehicle Properties are available. \n+Basically 3 Types of Information are registered as Properties\n+\n+* Informations regarding your Dealer with Address and Phone Number\n+* Which services are available / not available\n+* Vehicle Properties like Color, Model Type, Drive Train and Construction Year\n+\n+In the right picture  can see in *Services Activated* e.g. the *DoorLock* and *DoorUnlock* Services are mentioned. \n+This ensures [Channel Group _Remote Services_](#remote-services) is supporting Door lock and Door unlock.\n+\n+In  *Services Supported* the entry *LastDestination* is mentioned.\n+So it's valid to connect Channel Group [Last Destinations](#destinations) in order to display the last 3 Navigation Destinations.\n+\n+| Property Key       | Property Value      |  Supported Channel Groups    |\n+|--------------------|---------------------|------------------------------|\n+| Services Supported | Statistics          | last-trip, lifetime          |\n+| Services Supported | LastDestinations    | destinations                 |\n+| Services Activated | list of services    | remote                       |\n+\n+\n+## Discovery\n+\n+Auto Discovery is starting after creation of the Bridge towards BMW ConnectedDrive. \n+A list of your registered Vehicles is queried and all found Vehicles are added in Inbox.\n+Unique Identifier is the *Vehicle Identification Number* (VIN). \n+If a Thing is already declared in a  *.things configuration* Discovery won't highlight it again.\n+Properties will be attached to predefined Vehicles if the VIN is matching.\n+\n+## Configuration\n+\n+### Bridge\n+\n+| Parameter       | Type    | Description                                                             |           \n+|-----------------|---------|-------------------------------------------------------------------------|\n+| userName        | text    | BMW Connected Drive Username                  |\n+| password        | text    | BMW Connected Drive Password                  |\n+| region          | text    | Select Region in order to connect to the appropriate BMW Server.   |\n+\n+The region Configuration has 3 different possibilities\n+\n+* _NORTH_AMERICA_\n+* _CHINA_\n+* _ROW_ for Rest of World\n+\n+### Thing\n+\n+Same Configuration is needed for all Things\n+\n+| Parameter       | Type    | Description                           |           \n+|-----------------|---------|---------------------------------------|\n+| vin             | text    | Vehicle Identification Number (VIN)   |\n+| refreshInterval | integer | Refresh Interval in Minutes           |\n+| units           | text    | Unit Selection                        |\n+| imageSize       | integer | Image Size                            |\n+| imageViewport   | text    | Image Viewport                        |\n+\n+The units can be configured in 3 ways\n+\n+* _AUTODETECT_ selects Miles for US & UK, Kilometer otherwise\n+* _METRIC_ selects directly Kilometers\n+* _IMPERIAL_ selects directly Miles\n+\n+The imageVieport allows to show the Vehicle from different angels.\n+Possible values are \n+\n+* FRONT\n+* REAR\n+* SIDE\n+* DASHBOARD\n+* DRIVERDOOR\n+\n+## Channels\n+\n+There are many Channels available for each Vehicle. \n+For better overview they are clustered in different Channel Groups.\n+The Channel Groups are different for the Vehicle Types, on the build-in Sensors of the Vehicle and the activated Services.\n+\n+### Bridge Channels\n+\n+If the Vehicle isn't found in the Discovery force a log of Fingerprint Data which helps to analyze the problem.\n+Please check [TroubleShooting Section](#TroubleShooting) for further advice.\n+\n+| Channel Label         | Channel ID            | Type   | Description                                       |\n+|-----------------------|-----------------------|--------|---------------------------------------------------|\n+| Discovery Fingerprint | discovery-fingerprint | Switch | Forcing a log entry to analyze Discovery Problems |", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTA5NjExMg=="}, "originalCommit": {"oid": "e0bfe93e13df4a3c5de5f8819b94ebf795664904"}, "originalPosition": 140}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEzNzY1Mjg5OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.bmwconnecteddrive/README.md", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wN1QxNToxNzoxMlrOHd4ing==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yN1QwMjo0NDozMFrOILnuyA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTA5NzExOA==", "bodyText": "To be more concise, you could remove the Channel Group ID column and mention it above the table.", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r501097118", "createdAt": "2020-10-07T15:17:12Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/README.md", "diffHunk": "@@ -0,0 +1,862 @@\n+# BMW ConnectedDrive Binding\n+\n+<img align=\"right\" src=\"./doc/bmw-connected.png\" width=\"150\" height=\"150\"/>\n+\n+The Binding provides a Connection between [BMWs ConnectedDrive Portal](https://www.bmw-connecteddrive.com/country-region-select/country-region-selection.html) and openHAB.\n+All Vehicles connected to an Account will be detected by the Discovery with the correct type \n+\n+* Conventional Fuel Vehicle\n+* Plugin-Hybrid Electrical Vehicle \n+* Battery Electric Vehicle with Range Extender\n+* Battery Electric Vehicle \n+\n+In addition Properties are attached with Information and Services provided by this Vehicle.\n+The provided data depends on \n+\n+1. the [Type](#Things) and \n+2. the Services mentioned in [Properties](#properties)\n+\n+Different Channel Groups are clustering all informations.\n+Check for each Group if it's supported for this Vehicle.\n+\n+Please note **this isn't a real-time Binding**. \n+If the Door is opened the state isn't transmitted and changed immediately. \n+This isn't a flaw in the Binding itself because the state in BMWs own ConnectedDrive App is also updated with some delay. \n+\n+## Supported Things\n+\n+### Bridge\n+\n+The Bridge establishes the Connection between BMW ConnectedDrive Portal and openHAB.\n+\n+| Name                       | Bridge Type ID | Description                                                |\n+|----------------------------|----------------|------------------------------------------------------------|\n+| BMW ConnectedDrive Account | account        | Access to BMW ConnectedDrive Portal for a specific user    |\n+\n+\n+### Things\n+\n+Four different Vehicle Types are provided. \n+They differ in the supported Channel Groups & Channels. \n+Conventional Fuel Vehicles have no _Charging Profile_, Electric Vehicles don't provide a _Fuel Range_. \n+For Hybrid Vehicles in addition to _Fuel and Electric Range_ the _Hybrid Range_ is shown.\n+ \n+| Name                                | Thing Type ID | Supported Channel Groups                                             |\n+|-------------------------------------|---------------|----------------------------------------------------------------------|\n+| BMW Electric Vehicle                | BEV           | status, range, location, service, check, charge, image, troubleshoot |\n+| BMW Electric Vehicle with REX       | BEV_REX       | status, range, location, service, check, charge, image, troubleshoot |\n+| BMW Plug-In-Hybrid Electric Vehicle | PHEV          | status, range, location, service, check, charge, image, troubleshoot |\n+| BMW Conventional Vehicle            | CONV          | status, range, location, service, check, image, troubleshoot         |\n+\n+ \n+#### Properties\n+\n+<img align=\"right\" src=\"./doc/properties.png\" width=\"500\" height=\"600\"/>\n+\n+For each Vehicle Properties are available. \n+Basically 3 Types of Information are registered as Properties\n+\n+* Informations regarding your Dealer with Address and Phone Number\n+* Which services are available / not available\n+* Vehicle Properties like Color, Model Type, Drive Train and Construction Year\n+\n+In the right picture  can see in *Services Activated* e.g. the *DoorLock* and *DoorUnlock* Services are mentioned. \n+This ensures [Channel Group _Remote Services_](#remote-services) is supporting Door lock and Door unlock.\n+\n+In  *Services Supported* the entry *LastDestination* is mentioned.\n+So it's valid to connect Channel Group [Last Destinations](#destinations) in order to display the last 3 Navigation Destinations.\n+\n+| Property Key       | Property Value      |  Supported Channel Groups    |\n+|--------------------|---------------------|------------------------------|\n+| Services Supported | Statistics          | last-trip, lifetime          |\n+| Services Supported | LastDestinations    | destinations                 |\n+| Services Activated | list of services    | remote                       |\n+\n+\n+## Discovery\n+\n+Auto Discovery is starting after creation of the Bridge towards BMW ConnectedDrive. \n+A list of your registered Vehicles is queried and all found Vehicles are added in Inbox.\n+Unique Identifier is the *Vehicle Identification Number* (VIN). \n+If a Thing is already declared in a  *.things configuration* Discovery won't highlight it again.\n+Properties will be attached to predefined Vehicles if the VIN is matching.\n+\n+## Configuration\n+\n+### Bridge\n+\n+| Parameter       | Type    | Description                                                             |           \n+|-----------------|---------|-------------------------------------------------------------------------|\n+| userName        | text    | BMW Connected Drive Username                  |\n+| password        | text    | BMW Connected Drive Password                  |\n+| region          | text    | Select Region in order to connect to the appropriate BMW Server.   |\n+\n+The region Configuration has 3 different possibilities\n+\n+* _NORTH_AMERICA_\n+* _CHINA_\n+* _ROW_ for Rest of World\n+\n+### Thing\n+\n+Same Configuration is needed for all Things\n+\n+| Parameter       | Type    | Description                           |           \n+|-----------------|---------|---------------------------------------|\n+| vin             | text    | Vehicle Identification Number (VIN)   |\n+| refreshInterval | integer | Refresh Interval in Minutes           |\n+| units           | text    | Unit Selection                        |\n+| imageSize       | integer | Image Size                            |\n+| imageViewport   | text    | Image Viewport                        |\n+\n+The units can be configured in 3 ways\n+\n+* _AUTODETECT_ selects Miles for US & UK, Kilometer otherwise\n+* _METRIC_ selects directly Kilometers\n+* _IMPERIAL_ selects directly Miles\n+\n+The imageVieport allows to show the Vehicle from different angels.\n+Possible values are \n+\n+* FRONT\n+* REAR\n+* SIDE\n+* DASHBOARD\n+* DRIVERDOOR\n+\n+## Channels\n+\n+There are many Channels available for each Vehicle. \n+For better overview they are clustered in different Channel Groups.\n+The Channel Groups are different for the Vehicle Types, on the build-in Sensors of the Vehicle and the activated Services.\n+\n+### Bridge Channels\n+\n+If the Vehicle isn't found in the Discovery force a log of Fingerprint Data which helps to analyze the problem.\n+Please check [TroubleShooting Section](#TroubleShooting) for further advice.\n+\n+| Channel Label         | Channel ID            | Type   | Description                                       |\n+|-----------------------|-----------------------|--------|---------------------------------------------------|\n+| Discovery Fingerprint | discovery-fingerprint | Switch | Forcing a log entry to analyze Discovery Problems |\n+\n+### Thing Channel Groups \n+\n+#### Vehicle Status\n+\n+Reflects Status of the Vehicle.\n+Available for all Vehicles, Read-only.\n+\n+| Channel Label             | Channel Group ID | Channel ID          | Type          | Description                                                                       |", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e0bfe93e13df4a3c5de5f8819b94ebf795664904"}, "originalPosition": 149}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTA1NjIwMA==", "bodyText": "Done for all tables", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r549056200", "createdAt": "2020-12-27T02:44:30Z", "author": {"login": "weymann"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/README.md", "diffHunk": "@@ -0,0 +1,862 @@\n+# BMW ConnectedDrive Binding\n+\n+<img align=\"right\" src=\"./doc/bmw-connected.png\" width=\"150\" height=\"150\"/>\n+\n+The Binding provides a Connection between [BMWs ConnectedDrive Portal](https://www.bmw-connecteddrive.com/country-region-select/country-region-selection.html) and openHAB.\n+All Vehicles connected to an Account will be detected by the Discovery with the correct type \n+\n+* Conventional Fuel Vehicle\n+* Plugin-Hybrid Electrical Vehicle \n+* Battery Electric Vehicle with Range Extender\n+* Battery Electric Vehicle \n+\n+In addition Properties are attached with Information and Services provided by this Vehicle.\n+The provided data depends on \n+\n+1. the [Type](#Things) and \n+2. the Services mentioned in [Properties](#properties)\n+\n+Different Channel Groups are clustering all informations.\n+Check for each Group if it's supported for this Vehicle.\n+\n+Please note **this isn't a real-time Binding**. \n+If the Door is opened the state isn't transmitted and changed immediately. \n+This isn't a flaw in the Binding itself because the state in BMWs own ConnectedDrive App is also updated with some delay. \n+\n+## Supported Things\n+\n+### Bridge\n+\n+The Bridge establishes the Connection between BMW ConnectedDrive Portal and openHAB.\n+\n+| Name                       | Bridge Type ID | Description                                                |\n+|----------------------------|----------------|------------------------------------------------------------|\n+| BMW ConnectedDrive Account | account        | Access to BMW ConnectedDrive Portal for a specific user    |\n+\n+\n+### Things\n+\n+Four different Vehicle Types are provided. \n+They differ in the supported Channel Groups & Channels. \n+Conventional Fuel Vehicles have no _Charging Profile_, Electric Vehicles don't provide a _Fuel Range_. \n+For Hybrid Vehicles in addition to _Fuel and Electric Range_ the _Hybrid Range_ is shown.\n+ \n+| Name                                | Thing Type ID | Supported Channel Groups                                             |\n+|-------------------------------------|---------------|----------------------------------------------------------------------|\n+| BMW Electric Vehicle                | BEV           | status, range, location, service, check, charge, image, troubleshoot |\n+| BMW Electric Vehicle with REX       | BEV_REX       | status, range, location, service, check, charge, image, troubleshoot |\n+| BMW Plug-In-Hybrid Electric Vehicle | PHEV          | status, range, location, service, check, charge, image, troubleshoot |\n+| BMW Conventional Vehicle            | CONV          | status, range, location, service, check, image, troubleshoot         |\n+\n+ \n+#### Properties\n+\n+<img align=\"right\" src=\"./doc/properties.png\" width=\"500\" height=\"600\"/>\n+\n+For each Vehicle Properties are available. \n+Basically 3 Types of Information are registered as Properties\n+\n+* Informations regarding your Dealer with Address and Phone Number\n+* Which services are available / not available\n+* Vehicle Properties like Color, Model Type, Drive Train and Construction Year\n+\n+In the right picture  can see in *Services Activated* e.g. the *DoorLock* and *DoorUnlock* Services are mentioned. \n+This ensures [Channel Group _Remote Services_](#remote-services) is supporting Door lock and Door unlock.\n+\n+In  *Services Supported* the entry *LastDestination* is mentioned.\n+So it's valid to connect Channel Group [Last Destinations](#destinations) in order to display the last 3 Navigation Destinations.\n+\n+| Property Key       | Property Value      |  Supported Channel Groups    |\n+|--------------------|---------------------|------------------------------|\n+| Services Supported | Statistics          | last-trip, lifetime          |\n+| Services Supported | LastDestinations    | destinations                 |\n+| Services Activated | list of services    | remote                       |\n+\n+\n+## Discovery\n+\n+Auto Discovery is starting after creation of the Bridge towards BMW ConnectedDrive. \n+A list of your registered Vehicles is queried and all found Vehicles are added in Inbox.\n+Unique Identifier is the *Vehicle Identification Number* (VIN). \n+If a Thing is already declared in a  *.things configuration* Discovery won't highlight it again.\n+Properties will be attached to predefined Vehicles if the VIN is matching.\n+\n+## Configuration\n+\n+### Bridge\n+\n+| Parameter       | Type    | Description                                                             |           \n+|-----------------|---------|-------------------------------------------------------------------------|\n+| userName        | text    | BMW Connected Drive Username                  |\n+| password        | text    | BMW Connected Drive Password                  |\n+| region          | text    | Select Region in order to connect to the appropriate BMW Server.   |\n+\n+The region Configuration has 3 different possibilities\n+\n+* _NORTH_AMERICA_\n+* _CHINA_\n+* _ROW_ for Rest of World\n+\n+### Thing\n+\n+Same Configuration is needed for all Things\n+\n+| Parameter       | Type    | Description                           |           \n+|-----------------|---------|---------------------------------------|\n+| vin             | text    | Vehicle Identification Number (VIN)   |\n+| refreshInterval | integer | Refresh Interval in Minutes           |\n+| units           | text    | Unit Selection                        |\n+| imageSize       | integer | Image Size                            |\n+| imageViewport   | text    | Image Viewport                        |\n+\n+The units can be configured in 3 ways\n+\n+* _AUTODETECT_ selects Miles for US & UK, Kilometer otherwise\n+* _METRIC_ selects directly Kilometers\n+* _IMPERIAL_ selects directly Miles\n+\n+The imageVieport allows to show the Vehicle from different angels.\n+Possible values are \n+\n+* FRONT\n+* REAR\n+* SIDE\n+* DASHBOARD\n+* DRIVERDOOR\n+\n+## Channels\n+\n+There are many Channels available for each Vehicle. \n+For better overview they are clustered in different Channel Groups.\n+The Channel Groups are different for the Vehicle Types, on the build-in Sensors of the Vehicle and the activated Services.\n+\n+### Bridge Channels\n+\n+If the Vehicle isn't found in the Discovery force a log of Fingerprint Data which helps to analyze the problem.\n+Please check [TroubleShooting Section](#TroubleShooting) for further advice.\n+\n+| Channel Label         | Channel ID            | Type   | Description                                       |\n+|-----------------------|-----------------------|--------|---------------------------------------------------|\n+| Discovery Fingerprint | discovery-fingerprint | Switch | Forcing a log entry to analyze Discovery Problems |\n+\n+### Thing Channel Groups \n+\n+#### Vehicle Status\n+\n+Reflects Status of the Vehicle.\n+Available for all Vehicles, Read-only.\n+\n+| Channel Label             | Channel Group ID | Channel ID          | Type          | Description                                                                       |", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTA5NzExOA=="}, "originalCommit": {"oid": "e0bfe93e13df4a3c5de5f8819b94ebf795664904"}, "originalPosition": 149}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEzNzY3MDAwOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.bmwconnecteddrive/README.md", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wN1QxNToyMDo0NVrOHd4tVg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yN1QwMjo0NDowMlrOILnupQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTA5OTg2Mg==", "bodyText": "Can you mention the possible values?", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r501099862", "createdAt": "2020-10-07T15:20:45Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/README.md", "diffHunk": "@@ -0,0 +1,862 @@\n+# BMW ConnectedDrive Binding\n+\n+<img align=\"right\" src=\"./doc/bmw-connected.png\" width=\"150\" height=\"150\"/>\n+\n+The Binding provides a Connection between [BMWs ConnectedDrive Portal](https://www.bmw-connecteddrive.com/country-region-select/country-region-selection.html) and openHAB.\n+All Vehicles connected to an Account will be detected by the Discovery with the correct type \n+\n+* Conventional Fuel Vehicle\n+* Plugin-Hybrid Electrical Vehicle \n+* Battery Electric Vehicle with Range Extender\n+* Battery Electric Vehicle \n+\n+In addition Properties are attached with Information and Services provided by this Vehicle.\n+The provided data depends on \n+\n+1. the [Type](#Things) and \n+2. the Services mentioned in [Properties](#properties)\n+\n+Different Channel Groups are clustering all informations.\n+Check for each Group if it's supported for this Vehicle.\n+\n+Please note **this isn't a real-time Binding**. \n+If the Door is opened the state isn't transmitted and changed immediately. \n+This isn't a flaw in the Binding itself because the state in BMWs own ConnectedDrive App is also updated with some delay. \n+\n+## Supported Things\n+\n+### Bridge\n+\n+The Bridge establishes the Connection between BMW ConnectedDrive Portal and openHAB.\n+\n+| Name                       | Bridge Type ID | Description                                                |\n+|----------------------------|----------------|------------------------------------------------------------|\n+| BMW ConnectedDrive Account | account        | Access to BMW ConnectedDrive Portal for a specific user    |\n+\n+\n+### Things\n+\n+Four different Vehicle Types are provided. \n+They differ in the supported Channel Groups & Channels. \n+Conventional Fuel Vehicles have no _Charging Profile_, Electric Vehicles don't provide a _Fuel Range_. \n+For Hybrid Vehicles in addition to _Fuel and Electric Range_ the _Hybrid Range_ is shown.\n+ \n+| Name                                | Thing Type ID | Supported Channel Groups                                             |\n+|-------------------------------------|---------------|----------------------------------------------------------------------|\n+| BMW Electric Vehicle                | BEV           | status, range, location, service, check, charge, image, troubleshoot |\n+| BMW Electric Vehicle with REX       | BEV_REX       | status, range, location, service, check, charge, image, troubleshoot |\n+| BMW Plug-In-Hybrid Electric Vehicle | PHEV          | status, range, location, service, check, charge, image, troubleshoot |\n+| BMW Conventional Vehicle            | CONV          | status, range, location, service, check, image, troubleshoot         |\n+\n+ \n+#### Properties\n+\n+<img align=\"right\" src=\"./doc/properties.png\" width=\"500\" height=\"600\"/>\n+\n+For each Vehicle Properties are available. \n+Basically 3 Types of Information are registered as Properties\n+\n+* Informations regarding your Dealer with Address and Phone Number\n+* Which services are available / not available\n+* Vehicle Properties like Color, Model Type, Drive Train and Construction Year\n+\n+In the right picture  can see in *Services Activated* e.g. the *DoorLock* and *DoorUnlock* Services are mentioned. \n+This ensures [Channel Group _Remote Services_](#remote-services) is supporting Door lock and Door unlock.\n+\n+In  *Services Supported* the entry *LastDestination* is mentioned.\n+So it's valid to connect Channel Group [Last Destinations](#destinations) in order to display the last 3 Navigation Destinations.\n+\n+| Property Key       | Property Value      |  Supported Channel Groups    |\n+|--------------------|---------------------|------------------------------|\n+| Services Supported | Statistics          | last-trip, lifetime          |\n+| Services Supported | LastDestinations    | destinations                 |\n+| Services Activated | list of services    | remote                       |\n+\n+\n+## Discovery\n+\n+Auto Discovery is starting after creation of the Bridge towards BMW ConnectedDrive. \n+A list of your registered Vehicles is queried and all found Vehicles are added in Inbox.\n+Unique Identifier is the *Vehicle Identification Number* (VIN). \n+If a Thing is already declared in a  *.things configuration* Discovery won't highlight it again.\n+Properties will be attached to predefined Vehicles if the VIN is matching.\n+\n+## Configuration\n+\n+### Bridge\n+\n+| Parameter       | Type    | Description                                                             |           \n+|-----------------|---------|-------------------------------------------------------------------------|\n+| userName        | text    | BMW Connected Drive Username                  |\n+| password        | text    | BMW Connected Drive Password                  |\n+| region          | text    | Select Region in order to connect to the appropriate BMW Server.   |\n+\n+The region Configuration has 3 different possibilities\n+\n+* _NORTH_AMERICA_\n+* _CHINA_\n+* _ROW_ for Rest of World\n+\n+### Thing\n+\n+Same Configuration is needed for all Things\n+\n+| Parameter       | Type    | Description                           |           \n+|-----------------|---------|---------------------------------------|\n+| vin             | text    | Vehicle Identification Number (VIN)   |\n+| refreshInterval | integer | Refresh Interval in Minutes           |\n+| units           | text    | Unit Selection                        |\n+| imageSize       | integer | Image Size                            |\n+| imageViewport   | text    | Image Viewport                        |\n+\n+The units can be configured in 3 ways\n+\n+* _AUTODETECT_ selects Miles for US & UK, Kilometer otherwise\n+* _METRIC_ selects directly Kilometers\n+* _IMPERIAL_ selects directly Miles\n+\n+The imageVieport allows to show the Vehicle from different angels.\n+Possible values are \n+\n+* FRONT\n+* REAR\n+* SIDE\n+* DASHBOARD\n+* DRIVERDOOR\n+\n+## Channels\n+\n+There are many Channels available for each Vehicle. \n+For better overview they are clustered in different Channel Groups.\n+The Channel Groups are different for the Vehicle Types, on the build-in Sensors of the Vehicle and the activated Services.\n+\n+### Bridge Channels\n+\n+If the Vehicle isn't found in the Discovery force a log of Fingerprint Data which helps to analyze the problem.\n+Please check [TroubleShooting Section](#TroubleShooting) for further advice.\n+\n+| Channel Label         | Channel ID            | Type   | Description                                       |\n+|-----------------------|-----------------------|--------|---------------------------------------------------|\n+| Discovery Fingerprint | discovery-fingerprint | Switch | Forcing a log entry to analyze Discovery Problems |\n+\n+### Thing Channel Groups \n+\n+#### Vehicle Status\n+\n+Reflects Status of the Vehicle.\n+Available for all Vehicles, Read-only.\n+\n+| Channel Label             | Channel Group ID | Channel ID          | Type          | Description                                                                       |\n+|---------------------------|------------------|---------------------|---------------|-----------------------------------------------------------------------------------|\n+| Overall Door Status       | status           | doors               | String        | **Closed** if all closed otherwise **Open**. **Unknown** if no data is delivered  |\n+| Overall Window Status     | status           | windows             | String        | **Closed** if all closed otherwise **Open** or **Intermediate**. **Unknown** if no data is delivered   |\n+| Doors Locked              | status           | lock                | String        | Status if Doors are locked or unlocked                                            |\n+| Next Service Date         | status           | service-date        | DateTime      | Date of Upcoming Service                                                          |\n+| Mileage till Next Service | status           | service-mileage     | Number:Length | Mileage till Upcoming Service                                                     |\n+| Check Control             | status           | check-control       | String        | Indicator if CheckControl is **Active** or **Not Active**. **Unknown** if no data is delivered         |\n+| Charging Status           | status           | charge              | String        | Only available for PHEV, BEV_REX and BEV                                          |", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e0bfe93e13df4a3c5de5f8819b94ebf795664904"}, "originalPosition": 157}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTA1NjE2NQ==", "bodyText": "Yes, I moved them now out of the description and placed the values below the table. This is now consistent with all Channel Group description.", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r549056165", "createdAt": "2020-12-27T02:44:02Z", "author": {"login": "weymann"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/README.md", "diffHunk": "@@ -0,0 +1,862 @@\n+# BMW ConnectedDrive Binding\n+\n+<img align=\"right\" src=\"./doc/bmw-connected.png\" width=\"150\" height=\"150\"/>\n+\n+The Binding provides a Connection between [BMWs ConnectedDrive Portal](https://www.bmw-connecteddrive.com/country-region-select/country-region-selection.html) and openHAB.\n+All Vehicles connected to an Account will be detected by the Discovery with the correct type \n+\n+* Conventional Fuel Vehicle\n+* Plugin-Hybrid Electrical Vehicle \n+* Battery Electric Vehicle with Range Extender\n+* Battery Electric Vehicle \n+\n+In addition Properties are attached with Information and Services provided by this Vehicle.\n+The provided data depends on \n+\n+1. the [Type](#Things) and \n+2. the Services mentioned in [Properties](#properties)\n+\n+Different Channel Groups are clustering all informations.\n+Check for each Group if it's supported for this Vehicle.\n+\n+Please note **this isn't a real-time Binding**. \n+If the Door is opened the state isn't transmitted and changed immediately. \n+This isn't a flaw in the Binding itself because the state in BMWs own ConnectedDrive App is also updated with some delay. \n+\n+## Supported Things\n+\n+### Bridge\n+\n+The Bridge establishes the Connection between BMW ConnectedDrive Portal and openHAB.\n+\n+| Name                       | Bridge Type ID | Description                                                |\n+|----------------------------|----------------|------------------------------------------------------------|\n+| BMW ConnectedDrive Account | account        | Access to BMW ConnectedDrive Portal for a specific user    |\n+\n+\n+### Things\n+\n+Four different Vehicle Types are provided. \n+They differ in the supported Channel Groups & Channels. \n+Conventional Fuel Vehicles have no _Charging Profile_, Electric Vehicles don't provide a _Fuel Range_. \n+For Hybrid Vehicles in addition to _Fuel and Electric Range_ the _Hybrid Range_ is shown.\n+ \n+| Name                                | Thing Type ID | Supported Channel Groups                                             |\n+|-------------------------------------|---------------|----------------------------------------------------------------------|\n+| BMW Electric Vehicle                | BEV           | status, range, location, service, check, charge, image, troubleshoot |\n+| BMW Electric Vehicle with REX       | BEV_REX       | status, range, location, service, check, charge, image, troubleshoot |\n+| BMW Plug-In-Hybrid Electric Vehicle | PHEV          | status, range, location, service, check, charge, image, troubleshoot |\n+| BMW Conventional Vehicle            | CONV          | status, range, location, service, check, image, troubleshoot         |\n+\n+ \n+#### Properties\n+\n+<img align=\"right\" src=\"./doc/properties.png\" width=\"500\" height=\"600\"/>\n+\n+For each Vehicle Properties are available. \n+Basically 3 Types of Information are registered as Properties\n+\n+* Informations regarding your Dealer with Address and Phone Number\n+* Which services are available / not available\n+* Vehicle Properties like Color, Model Type, Drive Train and Construction Year\n+\n+In the right picture  can see in *Services Activated* e.g. the *DoorLock* and *DoorUnlock* Services are mentioned. \n+This ensures [Channel Group _Remote Services_](#remote-services) is supporting Door lock and Door unlock.\n+\n+In  *Services Supported* the entry *LastDestination* is mentioned.\n+So it's valid to connect Channel Group [Last Destinations](#destinations) in order to display the last 3 Navigation Destinations.\n+\n+| Property Key       | Property Value      |  Supported Channel Groups    |\n+|--------------------|---------------------|------------------------------|\n+| Services Supported | Statistics          | last-trip, lifetime          |\n+| Services Supported | LastDestinations    | destinations                 |\n+| Services Activated | list of services    | remote                       |\n+\n+\n+## Discovery\n+\n+Auto Discovery is starting after creation of the Bridge towards BMW ConnectedDrive. \n+A list of your registered Vehicles is queried and all found Vehicles are added in Inbox.\n+Unique Identifier is the *Vehicle Identification Number* (VIN). \n+If a Thing is already declared in a  *.things configuration* Discovery won't highlight it again.\n+Properties will be attached to predefined Vehicles if the VIN is matching.\n+\n+## Configuration\n+\n+### Bridge\n+\n+| Parameter       | Type    | Description                                                             |           \n+|-----------------|---------|-------------------------------------------------------------------------|\n+| userName        | text    | BMW Connected Drive Username                  |\n+| password        | text    | BMW Connected Drive Password                  |\n+| region          | text    | Select Region in order to connect to the appropriate BMW Server.   |\n+\n+The region Configuration has 3 different possibilities\n+\n+* _NORTH_AMERICA_\n+* _CHINA_\n+* _ROW_ for Rest of World\n+\n+### Thing\n+\n+Same Configuration is needed for all Things\n+\n+| Parameter       | Type    | Description                           |           \n+|-----------------|---------|---------------------------------------|\n+| vin             | text    | Vehicle Identification Number (VIN)   |\n+| refreshInterval | integer | Refresh Interval in Minutes           |\n+| units           | text    | Unit Selection                        |\n+| imageSize       | integer | Image Size                            |\n+| imageViewport   | text    | Image Viewport                        |\n+\n+The units can be configured in 3 ways\n+\n+* _AUTODETECT_ selects Miles for US & UK, Kilometer otherwise\n+* _METRIC_ selects directly Kilometers\n+* _IMPERIAL_ selects directly Miles\n+\n+The imageVieport allows to show the Vehicle from different angels.\n+Possible values are \n+\n+* FRONT\n+* REAR\n+* SIDE\n+* DASHBOARD\n+* DRIVERDOOR\n+\n+## Channels\n+\n+There are many Channels available for each Vehicle. \n+For better overview they are clustered in different Channel Groups.\n+The Channel Groups are different for the Vehicle Types, on the build-in Sensors of the Vehicle and the activated Services.\n+\n+### Bridge Channels\n+\n+If the Vehicle isn't found in the Discovery force a log of Fingerprint Data which helps to analyze the problem.\n+Please check [TroubleShooting Section](#TroubleShooting) for further advice.\n+\n+| Channel Label         | Channel ID            | Type   | Description                                       |\n+|-----------------------|-----------------------|--------|---------------------------------------------------|\n+| Discovery Fingerprint | discovery-fingerprint | Switch | Forcing a log entry to analyze Discovery Problems |\n+\n+### Thing Channel Groups \n+\n+#### Vehicle Status\n+\n+Reflects Status of the Vehicle.\n+Available for all Vehicles, Read-only.\n+\n+| Channel Label             | Channel Group ID | Channel ID          | Type          | Description                                                                       |\n+|---------------------------|------------------|---------------------|---------------|-----------------------------------------------------------------------------------|\n+| Overall Door Status       | status           | doors               | String        | **Closed** if all closed otherwise **Open**. **Unknown** if no data is delivered  |\n+| Overall Window Status     | status           | windows             | String        | **Closed** if all closed otherwise **Open** or **Intermediate**. **Unknown** if no data is delivered   |\n+| Doors Locked              | status           | lock                | String        | Status if Doors are locked or unlocked                                            |\n+| Next Service Date         | status           | service-date        | DateTime      | Date of Upcoming Service                                                          |\n+| Mileage till Next Service | status           | service-mileage     | Number:Length | Mileage till Upcoming Service                                                     |\n+| Check Control             | status           | check-control       | String        | Indicator if CheckControl is **Active** or **Not Active**. **Unknown** if no data is delivered         |\n+| Charging Status           | status           | charge              | String        | Only available for PHEV, BEV_REX and BEV                                          |", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTA5OTg2Mg=="}, "originalCommit": {"oid": "e0bfe93e13df4a3c5de5f8819b94ebf795664904"}, "originalPosition": 157}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEzNzc5NTU1OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.bmwconnecteddrive/README.md", "isResolved": true, "comments": {"totalCount": 17, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wN1QxNTo0NzowMFrOHd56_w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNC0wN1QyMToyNjo1OFrOJE3VEw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTExOTc0Mw==", "bodyText": "I think I know what your intention with the List Interface is. Easily browsing through the items in the UI. The problem is, that you are implementing an UI feature in the data model. Also, your approach makes it hard to use the values in rules, as the the rule needs to control the index. But this has influence to the view in the UI.\nI see that you put a lot of effort into this feature, but this way doesn't feel right...\nThe intented approach of handling list data are dynamic Channels. Bindings can create and delete Channels on demand. In your case you would have for example service#date-1, service#date-2 and so on.", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r501119743", "createdAt": "2020-10-07T15:47:00Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/README.md", "diffHunk": "@@ -0,0 +1,862 @@\n+# BMW ConnectedDrive Binding\n+\n+<img align=\"right\" src=\"./doc/bmw-connected.png\" width=\"150\" height=\"150\"/>\n+\n+The Binding provides a Connection between [BMWs ConnectedDrive Portal](https://www.bmw-connecteddrive.com/country-region-select/country-region-selection.html) and openHAB.\n+All Vehicles connected to an Account will be detected by the Discovery with the correct type \n+\n+* Conventional Fuel Vehicle\n+* Plugin-Hybrid Electrical Vehicle \n+* Battery Electric Vehicle with Range Extender\n+* Battery Electric Vehicle \n+\n+In addition Properties are attached with Information and Services provided by this Vehicle.\n+The provided data depends on \n+\n+1. the [Type](#Things) and \n+2. the Services mentioned in [Properties](#properties)\n+\n+Different Channel Groups are clustering all informations.\n+Check for each Group if it's supported for this Vehicle.\n+\n+Please note **this isn't a real-time Binding**. \n+If the Door is opened the state isn't transmitted and changed immediately. \n+This isn't a flaw in the Binding itself because the state in BMWs own ConnectedDrive App is also updated with some delay. \n+\n+## Supported Things\n+\n+### Bridge\n+\n+The Bridge establishes the Connection between BMW ConnectedDrive Portal and openHAB.\n+\n+| Name                       | Bridge Type ID | Description                                                |\n+|----------------------------|----------------|------------------------------------------------------------|\n+| BMW ConnectedDrive Account | account        | Access to BMW ConnectedDrive Portal for a specific user    |\n+\n+\n+### Things\n+\n+Four different Vehicle Types are provided. \n+They differ in the supported Channel Groups & Channels. \n+Conventional Fuel Vehicles have no _Charging Profile_, Electric Vehicles don't provide a _Fuel Range_. \n+For Hybrid Vehicles in addition to _Fuel and Electric Range_ the _Hybrid Range_ is shown.\n+ \n+| Name                                | Thing Type ID | Supported Channel Groups                                             |\n+|-------------------------------------|---------------|----------------------------------------------------------------------|\n+| BMW Electric Vehicle                | BEV           | status, range, location, service, check, charge, image, troubleshoot |\n+| BMW Electric Vehicle with REX       | BEV_REX       | status, range, location, service, check, charge, image, troubleshoot |\n+| BMW Plug-In-Hybrid Electric Vehicle | PHEV          | status, range, location, service, check, charge, image, troubleshoot |\n+| BMW Conventional Vehicle            | CONV          | status, range, location, service, check, image, troubleshoot         |\n+\n+ \n+#### Properties\n+\n+<img align=\"right\" src=\"./doc/properties.png\" width=\"500\" height=\"600\"/>\n+\n+For each Vehicle Properties are available. \n+Basically 3 Types of Information are registered as Properties\n+\n+* Informations regarding your Dealer with Address and Phone Number\n+* Which services are available / not available\n+* Vehicle Properties like Color, Model Type, Drive Train and Construction Year\n+\n+In the right picture  can see in *Services Activated* e.g. the *DoorLock* and *DoorUnlock* Services are mentioned. \n+This ensures [Channel Group _Remote Services_](#remote-services) is supporting Door lock and Door unlock.\n+\n+In  *Services Supported* the entry *LastDestination* is mentioned.\n+So it's valid to connect Channel Group [Last Destinations](#destinations) in order to display the last 3 Navigation Destinations.\n+\n+| Property Key       | Property Value      |  Supported Channel Groups    |\n+|--------------------|---------------------|------------------------------|\n+| Services Supported | Statistics          | last-trip, lifetime          |\n+| Services Supported | LastDestinations    | destinations                 |\n+| Services Activated | list of services    | remote                       |\n+\n+\n+## Discovery\n+\n+Auto Discovery is starting after creation of the Bridge towards BMW ConnectedDrive. \n+A list of your registered Vehicles is queried and all found Vehicles are added in Inbox.\n+Unique Identifier is the *Vehicle Identification Number* (VIN). \n+If a Thing is already declared in a  *.things configuration* Discovery won't highlight it again.\n+Properties will be attached to predefined Vehicles if the VIN is matching.\n+\n+## Configuration\n+\n+### Bridge\n+\n+| Parameter       | Type    | Description                                                             |           \n+|-----------------|---------|-------------------------------------------------------------------------|\n+| userName        | text    | BMW Connected Drive Username                  |\n+| password        | text    | BMW Connected Drive Password                  |\n+| region          | text    | Select Region in order to connect to the appropriate BMW Server.   |\n+\n+The region Configuration has 3 different possibilities\n+\n+* _NORTH_AMERICA_\n+* _CHINA_\n+* _ROW_ for Rest of World\n+\n+### Thing\n+\n+Same Configuration is needed for all Things\n+\n+| Parameter       | Type    | Description                           |           \n+|-----------------|---------|---------------------------------------|\n+| vin             | text    | Vehicle Identification Number (VIN)   |\n+| refreshInterval | integer | Refresh Interval in Minutes           |\n+| units           | text    | Unit Selection                        |\n+| imageSize       | integer | Image Size                            |\n+| imageViewport   | text    | Image Viewport                        |\n+\n+The units can be configured in 3 ways\n+\n+* _AUTODETECT_ selects Miles for US & UK, Kilometer otherwise\n+* _METRIC_ selects directly Kilometers\n+* _IMPERIAL_ selects directly Miles\n+\n+The imageVieport allows to show the Vehicle from different angels.\n+Possible values are \n+\n+* FRONT\n+* REAR\n+* SIDE\n+* DASHBOARD\n+* DRIVERDOOR\n+\n+## Channels\n+\n+There are many Channels available for each Vehicle. \n+For better overview they are clustered in different Channel Groups.\n+The Channel Groups are different for the Vehicle Types, on the build-in Sensors of the Vehicle and the activated Services.\n+\n+### Bridge Channels\n+\n+If the Vehicle isn't found in the Discovery force a log of Fingerprint Data which helps to analyze the problem.\n+Please check [TroubleShooting Section](#TroubleShooting) for further advice.\n+\n+| Channel Label         | Channel ID            | Type   | Description                                       |\n+|-----------------------|-----------------------|--------|---------------------------------------------------|\n+| Discovery Fingerprint | discovery-fingerprint | Switch | Forcing a log entry to analyze Discovery Problems |\n+\n+### Thing Channel Groups \n+\n+#### Vehicle Status\n+\n+Reflects Status of the Vehicle.\n+Available for all Vehicles, Read-only.\n+\n+| Channel Label             | Channel Group ID | Channel ID          | Type          | Description                                                                       |\n+|---------------------------|------------------|---------------------|---------------|-----------------------------------------------------------------------------------|\n+| Overall Door Status       | status           | doors               | String        | **Closed** if all closed otherwise **Open**. **Unknown** if no data is delivered  |\n+| Overall Window Status     | status           | windows             | String        | **Closed** if all closed otherwise **Open** or **Intermediate**. **Unknown** if no data is delivered   |\n+| Doors Locked              | status           | lock                | String        | Status if Doors are locked or unlocked                                            |\n+| Next Service Date         | status           | service-date        | DateTime      | Date of Upcoming Service                                                          |\n+| Mileage till Next Service | status           | service-mileage     | Number:Length | Mileage till Upcoming Service                                                     |\n+| Check Control             | status           | check-control       | String        | Indicator if CheckControl is **Active** or **Not Active**. **Unknown** if no data is delivered         |\n+| Charging Status           | status           | charge              | String        | Only available for PHEV, BEV_REX and BEV                                          |\n+| Last Status Timestamp     | status           | last-update         | DateTime      | Date and Time of last status update.                                              |\n+\n+See [further details for DateTime](#last-status-update-timestamp) in case of wrong timestamp values\n+\n+#### Services\n+\n+Group for all upcoming Services with Description, Service Date and / or Service Mileage\n+It's designed as [List Interface](#list-interface) so all upcoming Services can be checked.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e0bfe93e13df4a3c5de5f8819b94ebf795664904"}, "originalPosition": 165}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODQxNDA3Mw==", "bodyText": "The concept used is the Sliding Window. Window size is 1 so only one value is shown in UI. It's common in Automotive products e.g. showing contact list or music tracks on the infotainment display with e.g. 5 entries visible. Currently there's no default UI widget which applies to this Interface - unfortunately I didn't found any good UI list representation so far.\nFor Rules I don't get the problem. If a rule selects a track on a music player the actual track number & description, track time, cover art, and so on changes in UI. Same as selecting another CheckControl Message.\nThe intended approach isn't clear to me how to solve some basic use cases. Perhaps I'm missing something:\nIn principle the car is ok and doesn't show any CheckControl message. If e.g. the wiper fluid runs dry a corresponding message is raised. I'll create a new channel and update the data - from binding view I'm fine! But no item is attached to observe changes in rules or in UI. Same happens if another message is raised on top. Here I'm stucked!\nI don't think this problem applies especially to this binding. I see a more general flaw handling dynamic content. Or I didn't understood the whole story so far.", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r528414073", "createdAt": "2020-11-22T22:24:11Z", "author": {"login": "weymann"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/README.md", "diffHunk": "@@ -0,0 +1,862 @@\n+# BMW ConnectedDrive Binding\n+\n+<img align=\"right\" src=\"./doc/bmw-connected.png\" width=\"150\" height=\"150\"/>\n+\n+The Binding provides a Connection between [BMWs ConnectedDrive Portal](https://www.bmw-connecteddrive.com/country-region-select/country-region-selection.html) and openHAB.\n+All Vehicles connected to an Account will be detected by the Discovery with the correct type \n+\n+* Conventional Fuel Vehicle\n+* Plugin-Hybrid Electrical Vehicle \n+* Battery Electric Vehicle with Range Extender\n+* Battery Electric Vehicle \n+\n+In addition Properties are attached with Information and Services provided by this Vehicle.\n+The provided data depends on \n+\n+1. the [Type](#Things) and \n+2. the Services mentioned in [Properties](#properties)\n+\n+Different Channel Groups are clustering all informations.\n+Check for each Group if it's supported for this Vehicle.\n+\n+Please note **this isn't a real-time Binding**. \n+If the Door is opened the state isn't transmitted and changed immediately. \n+This isn't a flaw in the Binding itself because the state in BMWs own ConnectedDrive App is also updated with some delay. \n+\n+## Supported Things\n+\n+### Bridge\n+\n+The Bridge establishes the Connection between BMW ConnectedDrive Portal and openHAB.\n+\n+| Name                       | Bridge Type ID | Description                                                |\n+|----------------------------|----------------|------------------------------------------------------------|\n+| BMW ConnectedDrive Account | account        | Access to BMW ConnectedDrive Portal for a specific user    |\n+\n+\n+### Things\n+\n+Four different Vehicle Types are provided. \n+They differ in the supported Channel Groups & Channels. \n+Conventional Fuel Vehicles have no _Charging Profile_, Electric Vehicles don't provide a _Fuel Range_. \n+For Hybrid Vehicles in addition to _Fuel and Electric Range_ the _Hybrid Range_ is shown.\n+ \n+| Name                                | Thing Type ID | Supported Channel Groups                                             |\n+|-------------------------------------|---------------|----------------------------------------------------------------------|\n+| BMW Electric Vehicle                | BEV           | status, range, location, service, check, charge, image, troubleshoot |\n+| BMW Electric Vehicle with REX       | BEV_REX       | status, range, location, service, check, charge, image, troubleshoot |\n+| BMW Plug-In-Hybrid Electric Vehicle | PHEV          | status, range, location, service, check, charge, image, troubleshoot |\n+| BMW Conventional Vehicle            | CONV          | status, range, location, service, check, image, troubleshoot         |\n+\n+ \n+#### Properties\n+\n+<img align=\"right\" src=\"./doc/properties.png\" width=\"500\" height=\"600\"/>\n+\n+For each Vehicle Properties are available. \n+Basically 3 Types of Information are registered as Properties\n+\n+* Informations regarding your Dealer with Address and Phone Number\n+* Which services are available / not available\n+* Vehicle Properties like Color, Model Type, Drive Train and Construction Year\n+\n+In the right picture  can see in *Services Activated* e.g. the *DoorLock* and *DoorUnlock* Services are mentioned. \n+This ensures [Channel Group _Remote Services_](#remote-services) is supporting Door lock and Door unlock.\n+\n+In  *Services Supported* the entry *LastDestination* is mentioned.\n+So it's valid to connect Channel Group [Last Destinations](#destinations) in order to display the last 3 Navigation Destinations.\n+\n+| Property Key       | Property Value      |  Supported Channel Groups    |\n+|--------------------|---------------------|------------------------------|\n+| Services Supported | Statistics          | last-trip, lifetime          |\n+| Services Supported | LastDestinations    | destinations                 |\n+| Services Activated | list of services    | remote                       |\n+\n+\n+## Discovery\n+\n+Auto Discovery is starting after creation of the Bridge towards BMW ConnectedDrive. \n+A list of your registered Vehicles is queried and all found Vehicles are added in Inbox.\n+Unique Identifier is the *Vehicle Identification Number* (VIN). \n+If a Thing is already declared in a  *.things configuration* Discovery won't highlight it again.\n+Properties will be attached to predefined Vehicles if the VIN is matching.\n+\n+## Configuration\n+\n+### Bridge\n+\n+| Parameter       | Type    | Description                                                             |           \n+|-----------------|---------|-------------------------------------------------------------------------|\n+| userName        | text    | BMW Connected Drive Username                  |\n+| password        | text    | BMW Connected Drive Password                  |\n+| region          | text    | Select Region in order to connect to the appropriate BMW Server.   |\n+\n+The region Configuration has 3 different possibilities\n+\n+* _NORTH_AMERICA_\n+* _CHINA_\n+* _ROW_ for Rest of World\n+\n+### Thing\n+\n+Same Configuration is needed for all Things\n+\n+| Parameter       | Type    | Description                           |           \n+|-----------------|---------|---------------------------------------|\n+| vin             | text    | Vehicle Identification Number (VIN)   |\n+| refreshInterval | integer | Refresh Interval in Minutes           |\n+| units           | text    | Unit Selection                        |\n+| imageSize       | integer | Image Size                            |\n+| imageViewport   | text    | Image Viewport                        |\n+\n+The units can be configured in 3 ways\n+\n+* _AUTODETECT_ selects Miles for US & UK, Kilometer otherwise\n+* _METRIC_ selects directly Kilometers\n+* _IMPERIAL_ selects directly Miles\n+\n+The imageVieport allows to show the Vehicle from different angels.\n+Possible values are \n+\n+* FRONT\n+* REAR\n+* SIDE\n+* DASHBOARD\n+* DRIVERDOOR\n+\n+## Channels\n+\n+There are many Channels available for each Vehicle. \n+For better overview they are clustered in different Channel Groups.\n+The Channel Groups are different for the Vehicle Types, on the build-in Sensors of the Vehicle and the activated Services.\n+\n+### Bridge Channels\n+\n+If the Vehicle isn't found in the Discovery force a log of Fingerprint Data which helps to analyze the problem.\n+Please check [TroubleShooting Section](#TroubleShooting) for further advice.\n+\n+| Channel Label         | Channel ID            | Type   | Description                                       |\n+|-----------------------|-----------------------|--------|---------------------------------------------------|\n+| Discovery Fingerprint | discovery-fingerprint | Switch | Forcing a log entry to analyze Discovery Problems |\n+\n+### Thing Channel Groups \n+\n+#### Vehicle Status\n+\n+Reflects Status of the Vehicle.\n+Available for all Vehicles, Read-only.\n+\n+| Channel Label             | Channel Group ID | Channel ID          | Type          | Description                                                                       |\n+|---------------------------|------------------|---------------------|---------------|-----------------------------------------------------------------------------------|\n+| Overall Door Status       | status           | doors               | String        | **Closed** if all closed otherwise **Open**. **Unknown** if no data is delivered  |\n+| Overall Window Status     | status           | windows             | String        | **Closed** if all closed otherwise **Open** or **Intermediate**. **Unknown** if no data is delivered   |\n+| Doors Locked              | status           | lock                | String        | Status if Doors are locked or unlocked                                            |\n+| Next Service Date         | status           | service-date        | DateTime      | Date of Upcoming Service                                                          |\n+| Mileage till Next Service | status           | service-mileage     | Number:Length | Mileage till Upcoming Service                                                     |\n+| Check Control             | status           | check-control       | String        | Indicator if CheckControl is **Active** or **Not Active**. **Unknown** if no data is delivered         |\n+| Charging Status           | status           | charge              | String        | Only available for PHEV, BEV_REX and BEV                                          |\n+| Last Status Timestamp     | status           | last-update         | DateTime      | Date and Time of last status update.                                              |\n+\n+See [further details for DateTime](#last-status-update-timestamp) in case of wrong timestamp values\n+\n+#### Services\n+\n+Group for all upcoming Services with Description, Service Date and / or Service Mileage\n+It's designed as [List Interface](#list-interface) so all upcoming Services can be checked.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTExOTc0Mw=="}, "originalCommit": {"oid": "e0bfe93e13df4a3c5de5f8819b94ebf795664904"}, "originalPosition": 165}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTg1MDQ2Ng==", "bodyText": "@weymann I understand your issue here, but I also agree with @fwolter that this is mixing in UI/navigation functionality, which does not belong into a binding.\nA binding should provide information from the remote device as distinct channels to consume - the information should not change based on where the user just navigates such a list (what happens if two users do that at the same time?). So @fwolter's suggestion with multiple channels would fit better to the general concept of how to model things in a binding. But you definitely have a point that those dynamic channels would be rather useless as there won't be any items attached to them.\nThe best suggestion I can give is to resort to Thing actions: Those are to be used when requests/commands need parameters or when the result is a complex data type that cannot be mapped to a single item type.\nYou could create a Service getService(int index) method that could be used within rules. If the user wants to have such information in the UI, he can implement what he needs (maybe he wants only the dates of the 3 next services displayed) and fill appropriate items with that.\nFurthermore, it would allow full access to the list from rules, which makes it a much more flexible solution.", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r529850466", "createdAt": "2020-11-24T20:14:05Z", "author": {"login": "kaikreuzer"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/README.md", "diffHunk": "@@ -0,0 +1,862 @@\n+# BMW ConnectedDrive Binding\n+\n+<img align=\"right\" src=\"./doc/bmw-connected.png\" width=\"150\" height=\"150\"/>\n+\n+The Binding provides a Connection between [BMWs ConnectedDrive Portal](https://www.bmw-connecteddrive.com/country-region-select/country-region-selection.html) and openHAB.\n+All Vehicles connected to an Account will be detected by the Discovery with the correct type \n+\n+* Conventional Fuel Vehicle\n+* Plugin-Hybrid Electrical Vehicle \n+* Battery Electric Vehicle with Range Extender\n+* Battery Electric Vehicle \n+\n+In addition Properties are attached with Information and Services provided by this Vehicle.\n+The provided data depends on \n+\n+1. the [Type](#Things) and \n+2. the Services mentioned in [Properties](#properties)\n+\n+Different Channel Groups are clustering all informations.\n+Check for each Group if it's supported for this Vehicle.\n+\n+Please note **this isn't a real-time Binding**. \n+If the Door is opened the state isn't transmitted and changed immediately. \n+This isn't a flaw in the Binding itself because the state in BMWs own ConnectedDrive App is also updated with some delay. \n+\n+## Supported Things\n+\n+### Bridge\n+\n+The Bridge establishes the Connection between BMW ConnectedDrive Portal and openHAB.\n+\n+| Name                       | Bridge Type ID | Description                                                |\n+|----------------------------|----------------|------------------------------------------------------------|\n+| BMW ConnectedDrive Account | account        | Access to BMW ConnectedDrive Portal for a specific user    |\n+\n+\n+### Things\n+\n+Four different Vehicle Types are provided. \n+They differ in the supported Channel Groups & Channels. \n+Conventional Fuel Vehicles have no _Charging Profile_, Electric Vehicles don't provide a _Fuel Range_. \n+For Hybrid Vehicles in addition to _Fuel and Electric Range_ the _Hybrid Range_ is shown.\n+ \n+| Name                                | Thing Type ID | Supported Channel Groups                                             |\n+|-------------------------------------|---------------|----------------------------------------------------------------------|\n+| BMW Electric Vehicle                | BEV           | status, range, location, service, check, charge, image, troubleshoot |\n+| BMW Electric Vehicle with REX       | BEV_REX       | status, range, location, service, check, charge, image, troubleshoot |\n+| BMW Plug-In-Hybrid Electric Vehicle | PHEV          | status, range, location, service, check, charge, image, troubleshoot |\n+| BMW Conventional Vehicle            | CONV          | status, range, location, service, check, image, troubleshoot         |\n+\n+ \n+#### Properties\n+\n+<img align=\"right\" src=\"./doc/properties.png\" width=\"500\" height=\"600\"/>\n+\n+For each Vehicle Properties are available. \n+Basically 3 Types of Information are registered as Properties\n+\n+* Informations regarding your Dealer with Address and Phone Number\n+* Which services are available / not available\n+* Vehicle Properties like Color, Model Type, Drive Train and Construction Year\n+\n+In the right picture  can see in *Services Activated* e.g. the *DoorLock* and *DoorUnlock* Services are mentioned. \n+This ensures [Channel Group _Remote Services_](#remote-services) is supporting Door lock and Door unlock.\n+\n+In  *Services Supported* the entry *LastDestination* is mentioned.\n+So it's valid to connect Channel Group [Last Destinations](#destinations) in order to display the last 3 Navigation Destinations.\n+\n+| Property Key       | Property Value      |  Supported Channel Groups    |\n+|--------------------|---------------------|------------------------------|\n+| Services Supported | Statistics          | last-trip, lifetime          |\n+| Services Supported | LastDestinations    | destinations                 |\n+| Services Activated | list of services    | remote                       |\n+\n+\n+## Discovery\n+\n+Auto Discovery is starting after creation of the Bridge towards BMW ConnectedDrive. \n+A list of your registered Vehicles is queried and all found Vehicles are added in Inbox.\n+Unique Identifier is the *Vehicle Identification Number* (VIN). \n+If a Thing is already declared in a  *.things configuration* Discovery won't highlight it again.\n+Properties will be attached to predefined Vehicles if the VIN is matching.\n+\n+## Configuration\n+\n+### Bridge\n+\n+| Parameter       | Type    | Description                                                             |           \n+|-----------------|---------|-------------------------------------------------------------------------|\n+| userName        | text    | BMW Connected Drive Username                  |\n+| password        | text    | BMW Connected Drive Password                  |\n+| region          | text    | Select Region in order to connect to the appropriate BMW Server.   |\n+\n+The region Configuration has 3 different possibilities\n+\n+* _NORTH_AMERICA_\n+* _CHINA_\n+* _ROW_ for Rest of World\n+\n+### Thing\n+\n+Same Configuration is needed for all Things\n+\n+| Parameter       | Type    | Description                           |           \n+|-----------------|---------|---------------------------------------|\n+| vin             | text    | Vehicle Identification Number (VIN)   |\n+| refreshInterval | integer | Refresh Interval in Minutes           |\n+| units           | text    | Unit Selection                        |\n+| imageSize       | integer | Image Size                            |\n+| imageViewport   | text    | Image Viewport                        |\n+\n+The units can be configured in 3 ways\n+\n+* _AUTODETECT_ selects Miles for US & UK, Kilometer otherwise\n+* _METRIC_ selects directly Kilometers\n+* _IMPERIAL_ selects directly Miles\n+\n+The imageVieport allows to show the Vehicle from different angels.\n+Possible values are \n+\n+* FRONT\n+* REAR\n+* SIDE\n+* DASHBOARD\n+* DRIVERDOOR\n+\n+## Channels\n+\n+There are many Channels available for each Vehicle. \n+For better overview they are clustered in different Channel Groups.\n+The Channel Groups are different for the Vehicle Types, on the build-in Sensors of the Vehicle and the activated Services.\n+\n+### Bridge Channels\n+\n+If the Vehicle isn't found in the Discovery force a log of Fingerprint Data which helps to analyze the problem.\n+Please check [TroubleShooting Section](#TroubleShooting) for further advice.\n+\n+| Channel Label         | Channel ID            | Type   | Description                                       |\n+|-----------------------|-----------------------|--------|---------------------------------------------------|\n+| Discovery Fingerprint | discovery-fingerprint | Switch | Forcing a log entry to analyze Discovery Problems |\n+\n+### Thing Channel Groups \n+\n+#### Vehicle Status\n+\n+Reflects Status of the Vehicle.\n+Available for all Vehicles, Read-only.\n+\n+| Channel Label             | Channel Group ID | Channel ID          | Type          | Description                                                                       |\n+|---------------------------|------------------|---------------------|---------------|-----------------------------------------------------------------------------------|\n+| Overall Door Status       | status           | doors               | String        | **Closed** if all closed otherwise **Open**. **Unknown** if no data is delivered  |\n+| Overall Window Status     | status           | windows             | String        | **Closed** if all closed otherwise **Open** or **Intermediate**. **Unknown** if no data is delivered   |\n+| Doors Locked              | status           | lock                | String        | Status if Doors are locked or unlocked                                            |\n+| Next Service Date         | status           | service-date        | DateTime      | Date of Upcoming Service                                                          |\n+| Mileage till Next Service | status           | service-mileage     | Number:Length | Mileage till Upcoming Service                                                     |\n+| Check Control             | status           | check-control       | String        | Indicator if CheckControl is **Active** or **Not Active**. **Unknown** if no data is delivered         |\n+| Charging Status           | status           | charge              | String        | Only available for PHEV, BEV_REX and BEV                                          |\n+| Last Status Timestamp     | status           | last-update         | DateTime      | Date and Time of last status update.                                              |\n+\n+See [further details for DateTime](#last-status-update-timestamp) in case of wrong timestamp values\n+\n+#### Services\n+\n+Group for all upcoming Services with Description, Service Date and / or Service Mileage\n+It's designed as [List Interface](#list-interface) so all upcoming Services can be checked.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTExOTc0Mw=="}, "originalCommit": {"oid": "e0bfe93e13df4a3c5de5f8819b94ebf795664904"}, "originalPosition": 165}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTEyOTA1Nw==", "bodyText": "The goal was simply to present the user all possible values. If there are 3 warnings it has to be possible to select them all. Bindings which I personally use I see different approaches solving (likely) the same list problem\n\ncaldav binding is using eventNr in config to get the next n appointments\nopenweathermap binding is using channel groups to list the weatherforcast data. For 3-hour forecast these are 40 Channel Groups with each 19 Channel Id's and sums up to 760 items!\n\nI'm going now with the solution from LG webOS: A String stores the current selected TV-Channel and all other possibilities are attached as options using the BaseDynamicStateDescriptionProvider. I've seen in OH3 these options are provided in th UI so for me it should do the trick for now.", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r549129057", "createdAt": "2020-12-27T15:56:16Z", "author": {"login": "weymann"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/README.md", "diffHunk": "@@ -0,0 +1,862 @@\n+# BMW ConnectedDrive Binding\n+\n+<img align=\"right\" src=\"./doc/bmw-connected.png\" width=\"150\" height=\"150\"/>\n+\n+The Binding provides a Connection between [BMWs ConnectedDrive Portal](https://www.bmw-connecteddrive.com/country-region-select/country-region-selection.html) and openHAB.\n+All Vehicles connected to an Account will be detected by the Discovery with the correct type \n+\n+* Conventional Fuel Vehicle\n+* Plugin-Hybrid Electrical Vehicle \n+* Battery Electric Vehicle with Range Extender\n+* Battery Electric Vehicle \n+\n+In addition Properties are attached with Information and Services provided by this Vehicle.\n+The provided data depends on \n+\n+1. the [Type](#Things) and \n+2. the Services mentioned in [Properties](#properties)\n+\n+Different Channel Groups are clustering all informations.\n+Check for each Group if it's supported for this Vehicle.\n+\n+Please note **this isn't a real-time Binding**. \n+If the Door is opened the state isn't transmitted and changed immediately. \n+This isn't a flaw in the Binding itself because the state in BMWs own ConnectedDrive App is also updated with some delay. \n+\n+## Supported Things\n+\n+### Bridge\n+\n+The Bridge establishes the Connection between BMW ConnectedDrive Portal and openHAB.\n+\n+| Name                       | Bridge Type ID | Description                                                |\n+|----------------------------|----------------|------------------------------------------------------------|\n+| BMW ConnectedDrive Account | account        | Access to BMW ConnectedDrive Portal for a specific user    |\n+\n+\n+### Things\n+\n+Four different Vehicle Types are provided. \n+They differ in the supported Channel Groups & Channels. \n+Conventional Fuel Vehicles have no _Charging Profile_, Electric Vehicles don't provide a _Fuel Range_. \n+For Hybrid Vehicles in addition to _Fuel and Electric Range_ the _Hybrid Range_ is shown.\n+ \n+| Name                                | Thing Type ID | Supported Channel Groups                                             |\n+|-------------------------------------|---------------|----------------------------------------------------------------------|\n+| BMW Electric Vehicle                | BEV           | status, range, location, service, check, charge, image, troubleshoot |\n+| BMW Electric Vehicle with REX       | BEV_REX       | status, range, location, service, check, charge, image, troubleshoot |\n+| BMW Plug-In-Hybrid Electric Vehicle | PHEV          | status, range, location, service, check, charge, image, troubleshoot |\n+| BMW Conventional Vehicle            | CONV          | status, range, location, service, check, image, troubleshoot         |\n+\n+ \n+#### Properties\n+\n+<img align=\"right\" src=\"./doc/properties.png\" width=\"500\" height=\"600\"/>\n+\n+For each Vehicle Properties are available. \n+Basically 3 Types of Information are registered as Properties\n+\n+* Informations regarding your Dealer with Address and Phone Number\n+* Which services are available / not available\n+* Vehicle Properties like Color, Model Type, Drive Train and Construction Year\n+\n+In the right picture  can see in *Services Activated* e.g. the *DoorLock* and *DoorUnlock* Services are mentioned. \n+This ensures [Channel Group _Remote Services_](#remote-services) is supporting Door lock and Door unlock.\n+\n+In  *Services Supported* the entry *LastDestination* is mentioned.\n+So it's valid to connect Channel Group [Last Destinations](#destinations) in order to display the last 3 Navigation Destinations.\n+\n+| Property Key       | Property Value      |  Supported Channel Groups    |\n+|--------------------|---------------------|------------------------------|\n+| Services Supported | Statistics          | last-trip, lifetime          |\n+| Services Supported | LastDestinations    | destinations                 |\n+| Services Activated | list of services    | remote                       |\n+\n+\n+## Discovery\n+\n+Auto Discovery is starting after creation of the Bridge towards BMW ConnectedDrive. \n+A list of your registered Vehicles is queried and all found Vehicles are added in Inbox.\n+Unique Identifier is the *Vehicle Identification Number* (VIN). \n+If a Thing is already declared in a  *.things configuration* Discovery won't highlight it again.\n+Properties will be attached to predefined Vehicles if the VIN is matching.\n+\n+## Configuration\n+\n+### Bridge\n+\n+| Parameter       | Type    | Description                                                             |           \n+|-----------------|---------|-------------------------------------------------------------------------|\n+| userName        | text    | BMW Connected Drive Username                  |\n+| password        | text    | BMW Connected Drive Password                  |\n+| region          | text    | Select Region in order to connect to the appropriate BMW Server.   |\n+\n+The region Configuration has 3 different possibilities\n+\n+* _NORTH_AMERICA_\n+* _CHINA_\n+* _ROW_ for Rest of World\n+\n+### Thing\n+\n+Same Configuration is needed for all Things\n+\n+| Parameter       | Type    | Description                           |           \n+|-----------------|---------|---------------------------------------|\n+| vin             | text    | Vehicle Identification Number (VIN)   |\n+| refreshInterval | integer | Refresh Interval in Minutes           |\n+| units           | text    | Unit Selection                        |\n+| imageSize       | integer | Image Size                            |\n+| imageViewport   | text    | Image Viewport                        |\n+\n+The units can be configured in 3 ways\n+\n+* _AUTODETECT_ selects Miles for US & UK, Kilometer otherwise\n+* _METRIC_ selects directly Kilometers\n+* _IMPERIAL_ selects directly Miles\n+\n+The imageVieport allows to show the Vehicle from different angels.\n+Possible values are \n+\n+* FRONT\n+* REAR\n+* SIDE\n+* DASHBOARD\n+* DRIVERDOOR\n+\n+## Channels\n+\n+There are many Channels available for each Vehicle. \n+For better overview they are clustered in different Channel Groups.\n+The Channel Groups are different for the Vehicle Types, on the build-in Sensors of the Vehicle and the activated Services.\n+\n+### Bridge Channels\n+\n+If the Vehicle isn't found in the Discovery force a log of Fingerprint Data which helps to analyze the problem.\n+Please check [TroubleShooting Section](#TroubleShooting) for further advice.\n+\n+| Channel Label         | Channel ID            | Type   | Description                                       |\n+|-----------------------|-----------------------|--------|---------------------------------------------------|\n+| Discovery Fingerprint | discovery-fingerprint | Switch | Forcing a log entry to analyze Discovery Problems |\n+\n+### Thing Channel Groups \n+\n+#### Vehicle Status\n+\n+Reflects Status of the Vehicle.\n+Available for all Vehicles, Read-only.\n+\n+| Channel Label             | Channel Group ID | Channel ID          | Type          | Description                                                                       |\n+|---------------------------|------------------|---------------------|---------------|-----------------------------------------------------------------------------------|\n+| Overall Door Status       | status           | doors               | String        | **Closed** if all closed otherwise **Open**. **Unknown** if no data is delivered  |\n+| Overall Window Status     | status           | windows             | String        | **Closed** if all closed otherwise **Open** or **Intermediate**. **Unknown** if no data is delivered   |\n+| Doors Locked              | status           | lock                | String        | Status if Doors are locked or unlocked                                            |\n+| Next Service Date         | status           | service-date        | DateTime      | Date of Upcoming Service                                                          |\n+| Mileage till Next Service | status           | service-mileage     | Number:Length | Mileage till Upcoming Service                                                     |\n+| Check Control             | status           | check-control       | String        | Indicator if CheckControl is **Active** or **Not Active**. **Unknown** if no data is delivered         |\n+| Charging Status           | status           | charge              | String        | Only available for PHEV, BEV_REX and BEV                                          |\n+| Last Status Timestamp     | status           | last-update         | DateTime      | Date and Time of last status update.                                              |\n+\n+See [further details for DateTime](#last-status-update-timestamp) in case of wrong timestamp values\n+\n+#### Services\n+\n+Group for all upcoming Services with Description, Service Date and / or Service Mileage\n+It's designed as [List Interface](#list-interface) so all upcoming Services can be checked.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTExOTc0Mw=="}, "originalCommit": {"oid": "e0bfe93e13df4a3c5de5f8819b94ebf795664904"}, "originalPosition": 165}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTg5MDYyNg==", "bodyText": "The new solution you came up with is a bit of an improvement, but has quite the same flaws as the last: The user writes to a Channel which causes other Channels to change, but that doesn't actually change any state of the Thing. Channels are bound to a Thing, e.g. if you change the program on a TV, the state of the Thing is actually changed and thus the Channels.\nDid you take a look into Thing Actions as @kaikreuzer suggested?", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r549890626", "createdAt": "2020-12-29T23:53:44Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/README.md", "diffHunk": "@@ -0,0 +1,862 @@\n+# BMW ConnectedDrive Binding\n+\n+<img align=\"right\" src=\"./doc/bmw-connected.png\" width=\"150\" height=\"150\"/>\n+\n+The Binding provides a Connection between [BMWs ConnectedDrive Portal](https://www.bmw-connecteddrive.com/country-region-select/country-region-selection.html) and openHAB.\n+All Vehicles connected to an Account will be detected by the Discovery with the correct type \n+\n+* Conventional Fuel Vehicle\n+* Plugin-Hybrid Electrical Vehicle \n+* Battery Electric Vehicle with Range Extender\n+* Battery Electric Vehicle \n+\n+In addition Properties are attached with Information and Services provided by this Vehicle.\n+The provided data depends on \n+\n+1. the [Type](#Things) and \n+2. the Services mentioned in [Properties](#properties)\n+\n+Different Channel Groups are clustering all informations.\n+Check for each Group if it's supported for this Vehicle.\n+\n+Please note **this isn't a real-time Binding**. \n+If the Door is opened the state isn't transmitted and changed immediately. \n+This isn't a flaw in the Binding itself because the state in BMWs own ConnectedDrive App is also updated with some delay. \n+\n+## Supported Things\n+\n+### Bridge\n+\n+The Bridge establishes the Connection between BMW ConnectedDrive Portal and openHAB.\n+\n+| Name                       | Bridge Type ID | Description                                                |\n+|----------------------------|----------------|------------------------------------------------------------|\n+| BMW ConnectedDrive Account | account        | Access to BMW ConnectedDrive Portal for a specific user    |\n+\n+\n+### Things\n+\n+Four different Vehicle Types are provided. \n+They differ in the supported Channel Groups & Channels. \n+Conventional Fuel Vehicles have no _Charging Profile_, Electric Vehicles don't provide a _Fuel Range_. \n+For Hybrid Vehicles in addition to _Fuel and Electric Range_ the _Hybrid Range_ is shown.\n+ \n+| Name                                | Thing Type ID | Supported Channel Groups                                             |\n+|-------------------------------------|---------------|----------------------------------------------------------------------|\n+| BMW Electric Vehicle                | BEV           | status, range, location, service, check, charge, image, troubleshoot |\n+| BMW Electric Vehicle with REX       | BEV_REX       | status, range, location, service, check, charge, image, troubleshoot |\n+| BMW Plug-In-Hybrid Electric Vehicle | PHEV          | status, range, location, service, check, charge, image, troubleshoot |\n+| BMW Conventional Vehicle            | CONV          | status, range, location, service, check, image, troubleshoot         |\n+\n+ \n+#### Properties\n+\n+<img align=\"right\" src=\"./doc/properties.png\" width=\"500\" height=\"600\"/>\n+\n+For each Vehicle Properties are available. \n+Basically 3 Types of Information are registered as Properties\n+\n+* Informations regarding your Dealer with Address and Phone Number\n+* Which services are available / not available\n+* Vehicle Properties like Color, Model Type, Drive Train and Construction Year\n+\n+In the right picture  can see in *Services Activated* e.g. the *DoorLock* and *DoorUnlock* Services are mentioned. \n+This ensures [Channel Group _Remote Services_](#remote-services) is supporting Door lock and Door unlock.\n+\n+In  *Services Supported* the entry *LastDestination* is mentioned.\n+So it's valid to connect Channel Group [Last Destinations](#destinations) in order to display the last 3 Navigation Destinations.\n+\n+| Property Key       | Property Value      |  Supported Channel Groups    |\n+|--------------------|---------------------|------------------------------|\n+| Services Supported | Statistics          | last-trip, lifetime          |\n+| Services Supported | LastDestinations    | destinations                 |\n+| Services Activated | list of services    | remote                       |\n+\n+\n+## Discovery\n+\n+Auto Discovery is starting after creation of the Bridge towards BMW ConnectedDrive. \n+A list of your registered Vehicles is queried and all found Vehicles are added in Inbox.\n+Unique Identifier is the *Vehicle Identification Number* (VIN). \n+If a Thing is already declared in a  *.things configuration* Discovery won't highlight it again.\n+Properties will be attached to predefined Vehicles if the VIN is matching.\n+\n+## Configuration\n+\n+### Bridge\n+\n+| Parameter       | Type    | Description                                                             |           \n+|-----------------|---------|-------------------------------------------------------------------------|\n+| userName        | text    | BMW Connected Drive Username                  |\n+| password        | text    | BMW Connected Drive Password                  |\n+| region          | text    | Select Region in order to connect to the appropriate BMW Server.   |\n+\n+The region Configuration has 3 different possibilities\n+\n+* _NORTH_AMERICA_\n+* _CHINA_\n+* _ROW_ for Rest of World\n+\n+### Thing\n+\n+Same Configuration is needed for all Things\n+\n+| Parameter       | Type    | Description                           |           \n+|-----------------|---------|---------------------------------------|\n+| vin             | text    | Vehicle Identification Number (VIN)   |\n+| refreshInterval | integer | Refresh Interval in Minutes           |\n+| units           | text    | Unit Selection                        |\n+| imageSize       | integer | Image Size                            |\n+| imageViewport   | text    | Image Viewport                        |\n+\n+The units can be configured in 3 ways\n+\n+* _AUTODETECT_ selects Miles for US & UK, Kilometer otherwise\n+* _METRIC_ selects directly Kilometers\n+* _IMPERIAL_ selects directly Miles\n+\n+The imageVieport allows to show the Vehicle from different angels.\n+Possible values are \n+\n+* FRONT\n+* REAR\n+* SIDE\n+* DASHBOARD\n+* DRIVERDOOR\n+\n+## Channels\n+\n+There are many Channels available for each Vehicle. \n+For better overview they are clustered in different Channel Groups.\n+The Channel Groups are different for the Vehicle Types, on the build-in Sensors of the Vehicle and the activated Services.\n+\n+### Bridge Channels\n+\n+If the Vehicle isn't found in the Discovery force a log of Fingerprint Data which helps to analyze the problem.\n+Please check [TroubleShooting Section](#TroubleShooting) for further advice.\n+\n+| Channel Label         | Channel ID            | Type   | Description                                       |\n+|-----------------------|-----------------------|--------|---------------------------------------------------|\n+| Discovery Fingerprint | discovery-fingerprint | Switch | Forcing a log entry to analyze Discovery Problems |\n+\n+### Thing Channel Groups \n+\n+#### Vehicle Status\n+\n+Reflects Status of the Vehicle.\n+Available for all Vehicles, Read-only.\n+\n+| Channel Label             | Channel Group ID | Channel ID          | Type          | Description                                                                       |\n+|---------------------------|------------------|---------------------|---------------|-----------------------------------------------------------------------------------|\n+| Overall Door Status       | status           | doors               | String        | **Closed** if all closed otherwise **Open**. **Unknown** if no data is delivered  |\n+| Overall Window Status     | status           | windows             | String        | **Closed** if all closed otherwise **Open** or **Intermediate**. **Unknown** if no data is delivered   |\n+| Doors Locked              | status           | lock                | String        | Status if Doors are locked or unlocked                                            |\n+| Next Service Date         | status           | service-date        | DateTime      | Date of Upcoming Service                                                          |\n+| Mileage till Next Service | status           | service-mileage     | Number:Length | Mileage till Upcoming Service                                                     |\n+| Check Control             | status           | check-control       | String        | Indicator if CheckControl is **Active** or **Not Active**. **Unknown** if no data is delivered         |\n+| Charging Status           | status           | charge              | String        | Only available for PHEV, BEV_REX and BEV                                          |\n+| Last Status Timestamp     | status           | last-update         | DateTime      | Date and Time of last status update.                                              |\n+\n+See [further details for DateTime](#last-status-update-timestamp) in case of wrong timestamp values\n+\n+#### Services\n+\n+Group for all upcoming Services with Description, Service Date and / or Service Mileage\n+It's designed as [List Interface](#list-interface) so all upcoming Services can be checked.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTExOTc0Mw=="}, "originalCommit": {"oid": "e0bfe93e13df4a3c5de5f8819b94ebf795664904"}, "originalPosition": 165}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDg4OTI4MA==", "bodyText": "Yes, I've taken a look into the Action suggestion. With this the complete list can be delivered and checked in rules. Then the user can decide what to do and introduce n-items to be shown in the UI. This seems to me like another implementation option like creating dynamic channels - it's just shifted to the user.\nHonestly I don't think the item update without state change is a real flaw. Even in rules you're able to update items with postUpdate without changing device state. So hopefully this isn't forbidden in the binding.\nThe only flaw I see is the parallel usage if several users/rules are sending commands. But this problem is already present in other locations. I've air conditioning via MELCloud. The operationMode channel is providing the same interface - String with options.\nAssume the temperature is 21 C and\n\nMy wife wants to Heat\nI want to Cool\nRule wants to Dry - humidity too high\n\nIf this happens in parallel simply the last one wins. So either me, my wife or even both of us are wondering why the state isn't the desired one. Of course this is a different use case with real device control instead of browsing but the underlying problem is the same.", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r550889280", "createdAt": "2021-01-02T14:57:00Z", "author": {"login": "weymann"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/README.md", "diffHunk": "@@ -0,0 +1,862 @@\n+# BMW ConnectedDrive Binding\n+\n+<img align=\"right\" src=\"./doc/bmw-connected.png\" width=\"150\" height=\"150\"/>\n+\n+The Binding provides a Connection between [BMWs ConnectedDrive Portal](https://www.bmw-connecteddrive.com/country-region-select/country-region-selection.html) and openHAB.\n+All Vehicles connected to an Account will be detected by the Discovery with the correct type \n+\n+* Conventional Fuel Vehicle\n+* Plugin-Hybrid Electrical Vehicle \n+* Battery Electric Vehicle with Range Extender\n+* Battery Electric Vehicle \n+\n+In addition Properties are attached with Information and Services provided by this Vehicle.\n+The provided data depends on \n+\n+1. the [Type](#Things) and \n+2. the Services mentioned in [Properties](#properties)\n+\n+Different Channel Groups are clustering all informations.\n+Check for each Group if it's supported for this Vehicle.\n+\n+Please note **this isn't a real-time Binding**. \n+If the Door is opened the state isn't transmitted and changed immediately. \n+This isn't a flaw in the Binding itself because the state in BMWs own ConnectedDrive App is also updated with some delay. \n+\n+## Supported Things\n+\n+### Bridge\n+\n+The Bridge establishes the Connection between BMW ConnectedDrive Portal and openHAB.\n+\n+| Name                       | Bridge Type ID | Description                                                |\n+|----------------------------|----------------|------------------------------------------------------------|\n+| BMW ConnectedDrive Account | account        | Access to BMW ConnectedDrive Portal for a specific user    |\n+\n+\n+### Things\n+\n+Four different Vehicle Types are provided. \n+They differ in the supported Channel Groups & Channels. \n+Conventional Fuel Vehicles have no _Charging Profile_, Electric Vehicles don't provide a _Fuel Range_. \n+For Hybrid Vehicles in addition to _Fuel and Electric Range_ the _Hybrid Range_ is shown.\n+ \n+| Name                                | Thing Type ID | Supported Channel Groups                                             |\n+|-------------------------------------|---------------|----------------------------------------------------------------------|\n+| BMW Electric Vehicle                | BEV           | status, range, location, service, check, charge, image, troubleshoot |\n+| BMW Electric Vehicle with REX       | BEV_REX       | status, range, location, service, check, charge, image, troubleshoot |\n+| BMW Plug-In-Hybrid Electric Vehicle | PHEV          | status, range, location, service, check, charge, image, troubleshoot |\n+| BMW Conventional Vehicle            | CONV          | status, range, location, service, check, image, troubleshoot         |\n+\n+ \n+#### Properties\n+\n+<img align=\"right\" src=\"./doc/properties.png\" width=\"500\" height=\"600\"/>\n+\n+For each Vehicle Properties are available. \n+Basically 3 Types of Information are registered as Properties\n+\n+* Informations regarding your Dealer with Address and Phone Number\n+* Which services are available / not available\n+* Vehicle Properties like Color, Model Type, Drive Train and Construction Year\n+\n+In the right picture  can see in *Services Activated* e.g. the *DoorLock* and *DoorUnlock* Services are mentioned. \n+This ensures [Channel Group _Remote Services_](#remote-services) is supporting Door lock and Door unlock.\n+\n+In  *Services Supported* the entry *LastDestination* is mentioned.\n+So it's valid to connect Channel Group [Last Destinations](#destinations) in order to display the last 3 Navigation Destinations.\n+\n+| Property Key       | Property Value      |  Supported Channel Groups    |\n+|--------------------|---------------------|------------------------------|\n+| Services Supported | Statistics          | last-trip, lifetime          |\n+| Services Supported | LastDestinations    | destinations                 |\n+| Services Activated | list of services    | remote                       |\n+\n+\n+## Discovery\n+\n+Auto Discovery is starting after creation of the Bridge towards BMW ConnectedDrive. \n+A list of your registered Vehicles is queried and all found Vehicles are added in Inbox.\n+Unique Identifier is the *Vehicle Identification Number* (VIN). \n+If a Thing is already declared in a  *.things configuration* Discovery won't highlight it again.\n+Properties will be attached to predefined Vehicles if the VIN is matching.\n+\n+## Configuration\n+\n+### Bridge\n+\n+| Parameter       | Type    | Description                                                             |           \n+|-----------------|---------|-------------------------------------------------------------------------|\n+| userName        | text    | BMW Connected Drive Username                  |\n+| password        | text    | BMW Connected Drive Password                  |\n+| region          | text    | Select Region in order to connect to the appropriate BMW Server.   |\n+\n+The region Configuration has 3 different possibilities\n+\n+* _NORTH_AMERICA_\n+* _CHINA_\n+* _ROW_ for Rest of World\n+\n+### Thing\n+\n+Same Configuration is needed for all Things\n+\n+| Parameter       | Type    | Description                           |           \n+|-----------------|---------|---------------------------------------|\n+| vin             | text    | Vehicle Identification Number (VIN)   |\n+| refreshInterval | integer | Refresh Interval in Minutes           |\n+| units           | text    | Unit Selection                        |\n+| imageSize       | integer | Image Size                            |\n+| imageViewport   | text    | Image Viewport                        |\n+\n+The units can be configured in 3 ways\n+\n+* _AUTODETECT_ selects Miles for US & UK, Kilometer otherwise\n+* _METRIC_ selects directly Kilometers\n+* _IMPERIAL_ selects directly Miles\n+\n+The imageVieport allows to show the Vehicle from different angels.\n+Possible values are \n+\n+* FRONT\n+* REAR\n+* SIDE\n+* DASHBOARD\n+* DRIVERDOOR\n+\n+## Channels\n+\n+There are many Channels available for each Vehicle. \n+For better overview they are clustered in different Channel Groups.\n+The Channel Groups are different for the Vehicle Types, on the build-in Sensors of the Vehicle and the activated Services.\n+\n+### Bridge Channels\n+\n+If the Vehicle isn't found in the Discovery force a log of Fingerprint Data which helps to analyze the problem.\n+Please check [TroubleShooting Section](#TroubleShooting) for further advice.\n+\n+| Channel Label         | Channel ID            | Type   | Description                                       |\n+|-----------------------|-----------------------|--------|---------------------------------------------------|\n+| Discovery Fingerprint | discovery-fingerprint | Switch | Forcing a log entry to analyze Discovery Problems |\n+\n+### Thing Channel Groups \n+\n+#### Vehicle Status\n+\n+Reflects Status of the Vehicle.\n+Available for all Vehicles, Read-only.\n+\n+| Channel Label             | Channel Group ID | Channel ID          | Type          | Description                                                                       |\n+|---------------------------|------------------|---------------------|---------------|-----------------------------------------------------------------------------------|\n+| Overall Door Status       | status           | doors               | String        | **Closed** if all closed otherwise **Open**. **Unknown** if no data is delivered  |\n+| Overall Window Status     | status           | windows             | String        | **Closed** if all closed otherwise **Open** or **Intermediate**. **Unknown** if no data is delivered   |\n+| Doors Locked              | status           | lock                | String        | Status if Doors are locked or unlocked                                            |\n+| Next Service Date         | status           | service-date        | DateTime      | Date of Upcoming Service                                                          |\n+| Mileage till Next Service | status           | service-mileage     | Number:Length | Mileage till Upcoming Service                                                     |\n+| Check Control             | status           | check-control       | String        | Indicator if CheckControl is **Active** or **Not Active**. **Unknown** if no data is delivered         |\n+| Charging Status           | status           | charge              | String        | Only available for PHEV, BEV_REX and BEV                                          |\n+| Last Status Timestamp     | status           | last-update         | DateTime      | Date and Time of last status update.                                              |\n+\n+See [further details for DateTime](#last-status-update-timestamp) in case of wrong timestamp values\n+\n+#### Services\n+\n+Group for all upcoming Services with Description, Service Date and / or Service Mileage\n+It's designed as [List Interface](#list-interface) so all upcoming Services can be checked.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTExOTc0Mw=="}, "originalCommit": {"oid": "e0bfe93e13df4a3c5de5f8819b94ebf795664904"}, "originalPosition": 165}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDk5NjgwNQ==", "bodyText": "This is a tough topic, because the UI doesn't support to show lists (in fact it's a table) and the question is now to apply a hack or let the user deal with it.\nWhat about this? Taking the upcoming services as an example. Combine the events in one String Channel:\nServiceName1: ServiceDate1/MileageTillService1, ServiceName2: ServiceDate2/MileageTillService2, ...\nIf no services are upcoming the Channel would be e.g. \"No services upcoming\".", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r550996805", "createdAt": "2021-01-03T12:03:52Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/README.md", "diffHunk": "@@ -0,0 +1,862 @@\n+# BMW ConnectedDrive Binding\n+\n+<img align=\"right\" src=\"./doc/bmw-connected.png\" width=\"150\" height=\"150\"/>\n+\n+The Binding provides a Connection between [BMWs ConnectedDrive Portal](https://www.bmw-connecteddrive.com/country-region-select/country-region-selection.html) and openHAB.\n+All Vehicles connected to an Account will be detected by the Discovery with the correct type \n+\n+* Conventional Fuel Vehicle\n+* Plugin-Hybrid Electrical Vehicle \n+* Battery Electric Vehicle with Range Extender\n+* Battery Electric Vehicle \n+\n+In addition Properties are attached with Information and Services provided by this Vehicle.\n+The provided data depends on \n+\n+1. the [Type](#Things) and \n+2. the Services mentioned in [Properties](#properties)\n+\n+Different Channel Groups are clustering all informations.\n+Check for each Group if it's supported for this Vehicle.\n+\n+Please note **this isn't a real-time Binding**. \n+If the Door is opened the state isn't transmitted and changed immediately. \n+This isn't a flaw in the Binding itself because the state in BMWs own ConnectedDrive App is also updated with some delay. \n+\n+## Supported Things\n+\n+### Bridge\n+\n+The Bridge establishes the Connection between BMW ConnectedDrive Portal and openHAB.\n+\n+| Name                       | Bridge Type ID | Description                                                |\n+|----------------------------|----------------|------------------------------------------------------------|\n+| BMW ConnectedDrive Account | account        | Access to BMW ConnectedDrive Portal for a specific user    |\n+\n+\n+### Things\n+\n+Four different Vehicle Types are provided. \n+They differ in the supported Channel Groups & Channels. \n+Conventional Fuel Vehicles have no _Charging Profile_, Electric Vehicles don't provide a _Fuel Range_. \n+For Hybrid Vehicles in addition to _Fuel and Electric Range_ the _Hybrid Range_ is shown.\n+ \n+| Name                                | Thing Type ID | Supported Channel Groups                                             |\n+|-------------------------------------|---------------|----------------------------------------------------------------------|\n+| BMW Electric Vehicle                | BEV           | status, range, location, service, check, charge, image, troubleshoot |\n+| BMW Electric Vehicle with REX       | BEV_REX       | status, range, location, service, check, charge, image, troubleshoot |\n+| BMW Plug-In-Hybrid Electric Vehicle | PHEV          | status, range, location, service, check, charge, image, troubleshoot |\n+| BMW Conventional Vehicle            | CONV          | status, range, location, service, check, image, troubleshoot         |\n+\n+ \n+#### Properties\n+\n+<img align=\"right\" src=\"./doc/properties.png\" width=\"500\" height=\"600\"/>\n+\n+For each Vehicle Properties are available. \n+Basically 3 Types of Information are registered as Properties\n+\n+* Informations regarding your Dealer with Address and Phone Number\n+* Which services are available / not available\n+* Vehicle Properties like Color, Model Type, Drive Train and Construction Year\n+\n+In the right picture  can see in *Services Activated* e.g. the *DoorLock* and *DoorUnlock* Services are mentioned. \n+This ensures [Channel Group _Remote Services_](#remote-services) is supporting Door lock and Door unlock.\n+\n+In  *Services Supported* the entry *LastDestination* is mentioned.\n+So it's valid to connect Channel Group [Last Destinations](#destinations) in order to display the last 3 Navigation Destinations.\n+\n+| Property Key       | Property Value      |  Supported Channel Groups    |\n+|--------------------|---------------------|------------------------------|\n+| Services Supported | Statistics          | last-trip, lifetime          |\n+| Services Supported | LastDestinations    | destinations                 |\n+| Services Activated | list of services    | remote                       |\n+\n+\n+## Discovery\n+\n+Auto Discovery is starting after creation of the Bridge towards BMW ConnectedDrive. \n+A list of your registered Vehicles is queried and all found Vehicles are added in Inbox.\n+Unique Identifier is the *Vehicle Identification Number* (VIN). \n+If a Thing is already declared in a  *.things configuration* Discovery won't highlight it again.\n+Properties will be attached to predefined Vehicles if the VIN is matching.\n+\n+## Configuration\n+\n+### Bridge\n+\n+| Parameter       | Type    | Description                                                             |           \n+|-----------------|---------|-------------------------------------------------------------------------|\n+| userName        | text    | BMW Connected Drive Username                  |\n+| password        | text    | BMW Connected Drive Password                  |\n+| region          | text    | Select Region in order to connect to the appropriate BMW Server.   |\n+\n+The region Configuration has 3 different possibilities\n+\n+* _NORTH_AMERICA_\n+* _CHINA_\n+* _ROW_ for Rest of World\n+\n+### Thing\n+\n+Same Configuration is needed for all Things\n+\n+| Parameter       | Type    | Description                           |           \n+|-----------------|---------|---------------------------------------|\n+| vin             | text    | Vehicle Identification Number (VIN)   |\n+| refreshInterval | integer | Refresh Interval in Minutes           |\n+| units           | text    | Unit Selection                        |\n+| imageSize       | integer | Image Size                            |\n+| imageViewport   | text    | Image Viewport                        |\n+\n+The units can be configured in 3 ways\n+\n+* _AUTODETECT_ selects Miles for US & UK, Kilometer otherwise\n+* _METRIC_ selects directly Kilometers\n+* _IMPERIAL_ selects directly Miles\n+\n+The imageVieport allows to show the Vehicle from different angels.\n+Possible values are \n+\n+* FRONT\n+* REAR\n+* SIDE\n+* DASHBOARD\n+* DRIVERDOOR\n+\n+## Channels\n+\n+There are many Channels available for each Vehicle. \n+For better overview they are clustered in different Channel Groups.\n+The Channel Groups are different for the Vehicle Types, on the build-in Sensors of the Vehicle and the activated Services.\n+\n+### Bridge Channels\n+\n+If the Vehicle isn't found in the Discovery force a log of Fingerprint Data which helps to analyze the problem.\n+Please check [TroubleShooting Section](#TroubleShooting) for further advice.\n+\n+| Channel Label         | Channel ID            | Type   | Description                                       |\n+|-----------------------|-----------------------|--------|---------------------------------------------------|\n+| Discovery Fingerprint | discovery-fingerprint | Switch | Forcing a log entry to analyze Discovery Problems |\n+\n+### Thing Channel Groups \n+\n+#### Vehicle Status\n+\n+Reflects Status of the Vehicle.\n+Available for all Vehicles, Read-only.\n+\n+| Channel Label             | Channel Group ID | Channel ID          | Type          | Description                                                                       |\n+|---------------------------|------------------|---------------------|---------------|-----------------------------------------------------------------------------------|\n+| Overall Door Status       | status           | doors               | String        | **Closed** if all closed otherwise **Open**. **Unknown** if no data is delivered  |\n+| Overall Window Status     | status           | windows             | String        | **Closed** if all closed otherwise **Open** or **Intermediate**. **Unknown** if no data is delivered   |\n+| Doors Locked              | status           | lock                | String        | Status if Doors are locked or unlocked                                            |\n+| Next Service Date         | status           | service-date        | DateTime      | Date of Upcoming Service                                                          |\n+| Mileage till Next Service | status           | service-mileage     | Number:Length | Mileage till Upcoming Service                                                     |\n+| Check Control             | status           | check-control       | String        | Indicator if CheckControl is **Active** or **Not Active**. **Unknown** if no data is delivered         |\n+| Charging Status           | status           | charge              | String        | Only available for PHEV, BEV_REX and BEV                                          |\n+| Last Status Timestamp     | status           | last-update         | DateTime      | Date and Time of last status update.                                              |\n+\n+See [further details for DateTime](#last-status-update-timestamp) in case of wrong timestamp values\n+\n+#### Services\n+\n+Group for all upcoming Services with Description, Service Date and / or Service Mileage\n+It's designed as [List Interface](#list-interface) so all upcoming Services can be checked.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTExOTc0Mw=="}, "originalCommit": {"oid": "e0bfe93e13df4a3c5de5f8819b94ebf795664904"}, "originalPosition": 165}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjMxMDU0Nw==", "bodyText": "For sure it's a tough topic, but it's worth discussing it :)\nI still don't think it's a hack. If we look simply at the user interface it's the same as the LGWebOS binding where I get the idea from. You select a new TV-channel and corresponding channels are changing. Under the \"technical hood\" there's a real TV state change, for BMW it's just browsing.\nAllow me to present one use case:\nIt's the Habpanel with Destination Selection Item and OpenStreetMap Widget. The binding with the current pushed implementation is used.\n\nSelect a different destination address\nThe item with GPS coordinates changes\nThe new coordinates will be shown as new marker in the map\n\n\n  \n    \n    \n\n    0110-0450.mp4\n    \n  \n\n  \n\n  \n\n\nNo rules needed\nJust used the standard Selection widget\nAll last destinations are present in the UI and can be selected\nRules\nSetting my OH3 environment I just found out that you can get all data in rules with\nitem.stateDescription.options\n\nThis is exactly what @kaikreuzer mentioned in his first suggestion, to make all data accessible in rules. So basically you can access everything in rules without interacting with the UI! This wasn't clear to me before.\nFinally ...\nI found the binding with exactly the same problem. It's the carnet binding and unfortunately you're one of the reviewers :)\nThey provide last destinations - same as this binding. Check readme  how it's implemented:\n\nIn thing configuration you need to configure how many shall be available 0-5\nFor each entry a new ChannelGroup destinationx is introduced\nEach group contains 8 Channels\n\nSo up to 40 Channels are provided for the last destinations. Don't misunderstand me, the solution isn't wrong! Nevertheless setup isn't really easy, maybe there are more last destinations available or even less than you configured.", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r552310547", "createdAt": "2021-01-06T01:20:32Z", "author": {"login": "weymann"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/README.md", "diffHunk": "@@ -0,0 +1,862 @@\n+# BMW ConnectedDrive Binding\n+\n+<img align=\"right\" src=\"./doc/bmw-connected.png\" width=\"150\" height=\"150\"/>\n+\n+The Binding provides a Connection between [BMWs ConnectedDrive Portal](https://www.bmw-connecteddrive.com/country-region-select/country-region-selection.html) and openHAB.\n+All Vehicles connected to an Account will be detected by the Discovery with the correct type \n+\n+* Conventional Fuel Vehicle\n+* Plugin-Hybrid Electrical Vehicle \n+* Battery Electric Vehicle with Range Extender\n+* Battery Electric Vehicle \n+\n+In addition Properties are attached with Information and Services provided by this Vehicle.\n+The provided data depends on \n+\n+1. the [Type](#Things) and \n+2. the Services mentioned in [Properties](#properties)\n+\n+Different Channel Groups are clustering all informations.\n+Check for each Group if it's supported for this Vehicle.\n+\n+Please note **this isn't a real-time Binding**. \n+If the Door is opened the state isn't transmitted and changed immediately. \n+This isn't a flaw in the Binding itself because the state in BMWs own ConnectedDrive App is also updated with some delay. \n+\n+## Supported Things\n+\n+### Bridge\n+\n+The Bridge establishes the Connection between BMW ConnectedDrive Portal and openHAB.\n+\n+| Name                       | Bridge Type ID | Description                                                |\n+|----------------------------|----------------|------------------------------------------------------------|\n+| BMW ConnectedDrive Account | account        | Access to BMW ConnectedDrive Portal for a specific user    |\n+\n+\n+### Things\n+\n+Four different Vehicle Types are provided. \n+They differ in the supported Channel Groups & Channels. \n+Conventional Fuel Vehicles have no _Charging Profile_, Electric Vehicles don't provide a _Fuel Range_. \n+For Hybrid Vehicles in addition to _Fuel and Electric Range_ the _Hybrid Range_ is shown.\n+ \n+| Name                                | Thing Type ID | Supported Channel Groups                                             |\n+|-------------------------------------|---------------|----------------------------------------------------------------------|\n+| BMW Electric Vehicle                | BEV           | status, range, location, service, check, charge, image, troubleshoot |\n+| BMW Electric Vehicle with REX       | BEV_REX       | status, range, location, service, check, charge, image, troubleshoot |\n+| BMW Plug-In-Hybrid Electric Vehicle | PHEV          | status, range, location, service, check, charge, image, troubleshoot |\n+| BMW Conventional Vehicle            | CONV          | status, range, location, service, check, image, troubleshoot         |\n+\n+ \n+#### Properties\n+\n+<img align=\"right\" src=\"./doc/properties.png\" width=\"500\" height=\"600\"/>\n+\n+For each Vehicle Properties are available. \n+Basically 3 Types of Information are registered as Properties\n+\n+* Informations regarding your Dealer with Address and Phone Number\n+* Which services are available / not available\n+* Vehicle Properties like Color, Model Type, Drive Train and Construction Year\n+\n+In the right picture  can see in *Services Activated* e.g. the *DoorLock* and *DoorUnlock* Services are mentioned. \n+This ensures [Channel Group _Remote Services_](#remote-services) is supporting Door lock and Door unlock.\n+\n+In  *Services Supported* the entry *LastDestination* is mentioned.\n+So it's valid to connect Channel Group [Last Destinations](#destinations) in order to display the last 3 Navigation Destinations.\n+\n+| Property Key       | Property Value      |  Supported Channel Groups    |\n+|--------------------|---------------------|------------------------------|\n+| Services Supported | Statistics          | last-trip, lifetime          |\n+| Services Supported | LastDestinations    | destinations                 |\n+| Services Activated | list of services    | remote                       |\n+\n+\n+## Discovery\n+\n+Auto Discovery is starting after creation of the Bridge towards BMW ConnectedDrive. \n+A list of your registered Vehicles is queried and all found Vehicles are added in Inbox.\n+Unique Identifier is the *Vehicle Identification Number* (VIN). \n+If a Thing is already declared in a  *.things configuration* Discovery won't highlight it again.\n+Properties will be attached to predefined Vehicles if the VIN is matching.\n+\n+## Configuration\n+\n+### Bridge\n+\n+| Parameter       | Type    | Description                                                             |           \n+|-----------------|---------|-------------------------------------------------------------------------|\n+| userName        | text    | BMW Connected Drive Username                  |\n+| password        | text    | BMW Connected Drive Password                  |\n+| region          | text    | Select Region in order to connect to the appropriate BMW Server.   |\n+\n+The region Configuration has 3 different possibilities\n+\n+* _NORTH_AMERICA_\n+* _CHINA_\n+* _ROW_ for Rest of World\n+\n+### Thing\n+\n+Same Configuration is needed for all Things\n+\n+| Parameter       | Type    | Description                           |           \n+|-----------------|---------|---------------------------------------|\n+| vin             | text    | Vehicle Identification Number (VIN)   |\n+| refreshInterval | integer | Refresh Interval in Minutes           |\n+| units           | text    | Unit Selection                        |\n+| imageSize       | integer | Image Size                            |\n+| imageViewport   | text    | Image Viewport                        |\n+\n+The units can be configured in 3 ways\n+\n+* _AUTODETECT_ selects Miles for US & UK, Kilometer otherwise\n+* _METRIC_ selects directly Kilometers\n+* _IMPERIAL_ selects directly Miles\n+\n+The imageVieport allows to show the Vehicle from different angels.\n+Possible values are \n+\n+* FRONT\n+* REAR\n+* SIDE\n+* DASHBOARD\n+* DRIVERDOOR\n+\n+## Channels\n+\n+There are many Channels available for each Vehicle. \n+For better overview they are clustered in different Channel Groups.\n+The Channel Groups are different for the Vehicle Types, on the build-in Sensors of the Vehicle and the activated Services.\n+\n+### Bridge Channels\n+\n+If the Vehicle isn't found in the Discovery force a log of Fingerprint Data which helps to analyze the problem.\n+Please check [TroubleShooting Section](#TroubleShooting) for further advice.\n+\n+| Channel Label         | Channel ID            | Type   | Description                                       |\n+|-----------------------|-----------------------|--------|---------------------------------------------------|\n+| Discovery Fingerprint | discovery-fingerprint | Switch | Forcing a log entry to analyze Discovery Problems |\n+\n+### Thing Channel Groups \n+\n+#### Vehicle Status\n+\n+Reflects Status of the Vehicle.\n+Available for all Vehicles, Read-only.\n+\n+| Channel Label             | Channel Group ID | Channel ID          | Type          | Description                                                                       |\n+|---------------------------|------------------|---------------------|---------------|-----------------------------------------------------------------------------------|\n+| Overall Door Status       | status           | doors               | String        | **Closed** if all closed otherwise **Open**. **Unknown** if no data is delivered  |\n+| Overall Window Status     | status           | windows             | String        | **Closed** if all closed otherwise **Open** or **Intermediate**. **Unknown** if no data is delivered   |\n+| Doors Locked              | status           | lock                | String        | Status if Doors are locked or unlocked                                            |\n+| Next Service Date         | status           | service-date        | DateTime      | Date of Upcoming Service                                                          |\n+| Mileage till Next Service | status           | service-mileage     | Number:Length | Mileage till Upcoming Service                                                     |\n+| Check Control             | status           | check-control       | String        | Indicator if CheckControl is **Active** or **Not Active**. **Unknown** if no data is delivered         |\n+| Charging Status           | status           | charge              | String        | Only available for PHEV, BEV_REX and BEV                                          |\n+| Last Status Timestamp     | status           | last-update         | DateTime      | Date and Time of last status update.                                              |\n+\n+See [further details for DateTime](#last-status-update-timestamp) in case of wrong timestamp values\n+\n+#### Services\n+\n+Group for all upcoming Services with Description, Service Date and / or Service Mileage\n+It's designed as [List Interface](#list-interface) so all upcoming Services can be checked.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTExOTc0Mw=="}, "originalCommit": {"oid": "e0bfe93e13df4a3c5de5f8819b94ebf795664904"}, "originalPosition": 165}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjkzODYxNw==", "bodyText": "Maybe @markus7017 can give a short impression how he uses the num-options of his binding in the UI.", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r552938617", "createdAt": "2021-01-06T20:10:16Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/README.md", "diffHunk": "@@ -0,0 +1,862 @@\n+# BMW ConnectedDrive Binding\n+\n+<img align=\"right\" src=\"./doc/bmw-connected.png\" width=\"150\" height=\"150\"/>\n+\n+The Binding provides a Connection between [BMWs ConnectedDrive Portal](https://www.bmw-connecteddrive.com/country-region-select/country-region-selection.html) and openHAB.\n+All Vehicles connected to an Account will be detected by the Discovery with the correct type \n+\n+* Conventional Fuel Vehicle\n+* Plugin-Hybrid Electrical Vehicle \n+* Battery Electric Vehicle with Range Extender\n+* Battery Electric Vehicle \n+\n+In addition Properties are attached with Information and Services provided by this Vehicle.\n+The provided data depends on \n+\n+1. the [Type](#Things) and \n+2. the Services mentioned in [Properties](#properties)\n+\n+Different Channel Groups are clustering all informations.\n+Check for each Group if it's supported for this Vehicle.\n+\n+Please note **this isn't a real-time Binding**. \n+If the Door is opened the state isn't transmitted and changed immediately. \n+This isn't a flaw in the Binding itself because the state in BMWs own ConnectedDrive App is also updated with some delay. \n+\n+## Supported Things\n+\n+### Bridge\n+\n+The Bridge establishes the Connection between BMW ConnectedDrive Portal and openHAB.\n+\n+| Name                       | Bridge Type ID | Description                                                |\n+|----------------------------|----------------|------------------------------------------------------------|\n+| BMW ConnectedDrive Account | account        | Access to BMW ConnectedDrive Portal for a specific user    |\n+\n+\n+### Things\n+\n+Four different Vehicle Types are provided. \n+They differ in the supported Channel Groups & Channels. \n+Conventional Fuel Vehicles have no _Charging Profile_, Electric Vehicles don't provide a _Fuel Range_. \n+For Hybrid Vehicles in addition to _Fuel and Electric Range_ the _Hybrid Range_ is shown.\n+ \n+| Name                                | Thing Type ID | Supported Channel Groups                                             |\n+|-------------------------------------|---------------|----------------------------------------------------------------------|\n+| BMW Electric Vehicle                | BEV           | status, range, location, service, check, charge, image, troubleshoot |\n+| BMW Electric Vehicle with REX       | BEV_REX       | status, range, location, service, check, charge, image, troubleshoot |\n+| BMW Plug-In-Hybrid Electric Vehicle | PHEV          | status, range, location, service, check, charge, image, troubleshoot |\n+| BMW Conventional Vehicle            | CONV          | status, range, location, service, check, image, troubleshoot         |\n+\n+ \n+#### Properties\n+\n+<img align=\"right\" src=\"./doc/properties.png\" width=\"500\" height=\"600\"/>\n+\n+For each Vehicle Properties are available. \n+Basically 3 Types of Information are registered as Properties\n+\n+* Informations regarding your Dealer with Address and Phone Number\n+* Which services are available / not available\n+* Vehicle Properties like Color, Model Type, Drive Train and Construction Year\n+\n+In the right picture  can see in *Services Activated* e.g. the *DoorLock* and *DoorUnlock* Services are mentioned. \n+This ensures [Channel Group _Remote Services_](#remote-services) is supporting Door lock and Door unlock.\n+\n+In  *Services Supported* the entry *LastDestination* is mentioned.\n+So it's valid to connect Channel Group [Last Destinations](#destinations) in order to display the last 3 Navigation Destinations.\n+\n+| Property Key       | Property Value      |  Supported Channel Groups    |\n+|--------------------|---------------------|------------------------------|\n+| Services Supported | Statistics          | last-trip, lifetime          |\n+| Services Supported | LastDestinations    | destinations                 |\n+| Services Activated | list of services    | remote                       |\n+\n+\n+## Discovery\n+\n+Auto Discovery is starting after creation of the Bridge towards BMW ConnectedDrive. \n+A list of your registered Vehicles is queried and all found Vehicles are added in Inbox.\n+Unique Identifier is the *Vehicle Identification Number* (VIN). \n+If a Thing is already declared in a  *.things configuration* Discovery won't highlight it again.\n+Properties will be attached to predefined Vehicles if the VIN is matching.\n+\n+## Configuration\n+\n+### Bridge\n+\n+| Parameter       | Type    | Description                                                             |           \n+|-----------------|---------|-------------------------------------------------------------------------|\n+| userName        | text    | BMW Connected Drive Username                  |\n+| password        | text    | BMW Connected Drive Password                  |\n+| region          | text    | Select Region in order to connect to the appropriate BMW Server.   |\n+\n+The region Configuration has 3 different possibilities\n+\n+* _NORTH_AMERICA_\n+* _CHINA_\n+* _ROW_ for Rest of World\n+\n+### Thing\n+\n+Same Configuration is needed for all Things\n+\n+| Parameter       | Type    | Description                           |           \n+|-----------------|---------|---------------------------------------|\n+| vin             | text    | Vehicle Identification Number (VIN)   |\n+| refreshInterval | integer | Refresh Interval in Minutes           |\n+| units           | text    | Unit Selection                        |\n+| imageSize       | integer | Image Size                            |\n+| imageViewport   | text    | Image Viewport                        |\n+\n+The units can be configured in 3 ways\n+\n+* _AUTODETECT_ selects Miles for US & UK, Kilometer otherwise\n+* _METRIC_ selects directly Kilometers\n+* _IMPERIAL_ selects directly Miles\n+\n+The imageVieport allows to show the Vehicle from different angels.\n+Possible values are \n+\n+* FRONT\n+* REAR\n+* SIDE\n+* DASHBOARD\n+* DRIVERDOOR\n+\n+## Channels\n+\n+There are many Channels available for each Vehicle. \n+For better overview they are clustered in different Channel Groups.\n+The Channel Groups are different for the Vehicle Types, on the build-in Sensors of the Vehicle and the activated Services.\n+\n+### Bridge Channels\n+\n+If the Vehicle isn't found in the Discovery force a log of Fingerprint Data which helps to analyze the problem.\n+Please check [TroubleShooting Section](#TroubleShooting) for further advice.\n+\n+| Channel Label         | Channel ID            | Type   | Description                                       |\n+|-----------------------|-----------------------|--------|---------------------------------------------------|\n+| Discovery Fingerprint | discovery-fingerprint | Switch | Forcing a log entry to analyze Discovery Problems |\n+\n+### Thing Channel Groups \n+\n+#### Vehicle Status\n+\n+Reflects Status of the Vehicle.\n+Available for all Vehicles, Read-only.\n+\n+| Channel Label             | Channel Group ID | Channel ID          | Type          | Description                                                                       |\n+|---------------------------|------------------|---------------------|---------------|-----------------------------------------------------------------------------------|\n+| Overall Door Status       | status           | doors               | String        | **Closed** if all closed otherwise **Open**. **Unknown** if no data is delivered  |\n+| Overall Window Status     | status           | windows             | String        | **Closed** if all closed otherwise **Open** or **Intermediate**. **Unknown** if no data is delivered   |\n+| Doors Locked              | status           | lock                | String        | Status if Doors are locked or unlocked                                            |\n+| Next Service Date         | status           | service-date        | DateTime      | Date of Upcoming Service                                                          |\n+| Mileage till Next Service | status           | service-mileage     | Number:Length | Mileage till Upcoming Service                                                     |\n+| Check Control             | status           | check-control       | String        | Indicator if CheckControl is **Active** or **Not Active**. **Unknown** if no data is delivered         |\n+| Charging Status           | status           | charge              | String        | Only available for PHEV, BEV_REX and BEV                                          |\n+| Last Status Timestamp     | status           | last-update         | DateTime      | Date and Time of last status update.                                              |\n+\n+See [further details for DateTime](#last-status-update-timestamp) in case of wrong timestamp values\n+\n+#### Services\n+\n+Group for all upcoming Services with Description, Service Date and / or Service Mileage\n+It's designed as [List Interface](#list-interface) so all upcoming Services can be checked.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTExOTc0Mw=="}, "originalCommit": {"oid": "e0bfe93e13df4a3c5de5f8819b94ebf795664904"}, "originalPosition": 165}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MDA0MjM2Mw==", "bodyText": "Can you comment on my proposal?\n\nCombine the events in one String Channel:\nServiceName1: ServiceDate1/MileageTillService1, ServiceName2: ServiceDate2/MileageTillService2, ...\nIf no services are upcoming the Channel would be e.g. \"No services upcoming\".", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r560042363", "createdAt": "2021-01-19T09:43:43Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/README.md", "diffHunk": "@@ -0,0 +1,862 @@\n+# BMW ConnectedDrive Binding\n+\n+<img align=\"right\" src=\"./doc/bmw-connected.png\" width=\"150\" height=\"150\"/>\n+\n+The Binding provides a Connection between [BMWs ConnectedDrive Portal](https://www.bmw-connecteddrive.com/country-region-select/country-region-selection.html) and openHAB.\n+All Vehicles connected to an Account will be detected by the Discovery with the correct type \n+\n+* Conventional Fuel Vehicle\n+* Plugin-Hybrid Electrical Vehicle \n+* Battery Electric Vehicle with Range Extender\n+* Battery Electric Vehicle \n+\n+In addition Properties are attached with Information and Services provided by this Vehicle.\n+The provided data depends on \n+\n+1. the [Type](#Things) and \n+2. the Services mentioned in [Properties](#properties)\n+\n+Different Channel Groups are clustering all informations.\n+Check for each Group if it's supported for this Vehicle.\n+\n+Please note **this isn't a real-time Binding**. \n+If the Door is opened the state isn't transmitted and changed immediately. \n+This isn't a flaw in the Binding itself because the state in BMWs own ConnectedDrive App is also updated with some delay. \n+\n+## Supported Things\n+\n+### Bridge\n+\n+The Bridge establishes the Connection between BMW ConnectedDrive Portal and openHAB.\n+\n+| Name                       | Bridge Type ID | Description                                                |\n+|----------------------------|----------------|------------------------------------------------------------|\n+| BMW ConnectedDrive Account | account        | Access to BMW ConnectedDrive Portal for a specific user    |\n+\n+\n+### Things\n+\n+Four different Vehicle Types are provided. \n+They differ in the supported Channel Groups & Channels. \n+Conventional Fuel Vehicles have no _Charging Profile_, Electric Vehicles don't provide a _Fuel Range_. \n+For Hybrid Vehicles in addition to _Fuel and Electric Range_ the _Hybrid Range_ is shown.\n+ \n+| Name                                | Thing Type ID | Supported Channel Groups                                             |\n+|-------------------------------------|---------------|----------------------------------------------------------------------|\n+| BMW Electric Vehicle                | BEV           | status, range, location, service, check, charge, image, troubleshoot |\n+| BMW Electric Vehicle with REX       | BEV_REX       | status, range, location, service, check, charge, image, troubleshoot |\n+| BMW Plug-In-Hybrid Electric Vehicle | PHEV          | status, range, location, service, check, charge, image, troubleshoot |\n+| BMW Conventional Vehicle            | CONV          | status, range, location, service, check, image, troubleshoot         |\n+\n+ \n+#### Properties\n+\n+<img align=\"right\" src=\"./doc/properties.png\" width=\"500\" height=\"600\"/>\n+\n+For each Vehicle Properties are available. \n+Basically 3 Types of Information are registered as Properties\n+\n+* Informations regarding your Dealer with Address and Phone Number\n+* Which services are available / not available\n+* Vehicle Properties like Color, Model Type, Drive Train and Construction Year\n+\n+In the right picture  can see in *Services Activated* e.g. the *DoorLock* and *DoorUnlock* Services are mentioned. \n+This ensures [Channel Group _Remote Services_](#remote-services) is supporting Door lock and Door unlock.\n+\n+In  *Services Supported* the entry *LastDestination* is mentioned.\n+So it's valid to connect Channel Group [Last Destinations](#destinations) in order to display the last 3 Navigation Destinations.\n+\n+| Property Key       | Property Value      |  Supported Channel Groups    |\n+|--------------------|---------------------|------------------------------|\n+| Services Supported | Statistics          | last-trip, lifetime          |\n+| Services Supported | LastDestinations    | destinations                 |\n+| Services Activated | list of services    | remote                       |\n+\n+\n+## Discovery\n+\n+Auto Discovery is starting after creation of the Bridge towards BMW ConnectedDrive. \n+A list of your registered Vehicles is queried and all found Vehicles are added in Inbox.\n+Unique Identifier is the *Vehicle Identification Number* (VIN). \n+If a Thing is already declared in a  *.things configuration* Discovery won't highlight it again.\n+Properties will be attached to predefined Vehicles if the VIN is matching.\n+\n+## Configuration\n+\n+### Bridge\n+\n+| Parameter       | Type    | Description                                                             |           \n+|-----------------|---------|-------------------------------------------------------------------------|\n+| userName        | text    | BMW Connected Drive Username                  |\n+| password        | text    | BMW Connected Drive Password                  |\n+| region          | text    | Select Region in order to connect to the appropriate BMW Server.   |\n+\n+The region Configuration has 3 different possibilities\n+\n+* _NORTH_AMERICA_\n+* _CHINA_\n+* _ROW_ for Rest of World\n+\n+### Thing\n+\n+Same Configuration is needed for all Things\n+\n+| Parameter       | Type    | Description                           |           \n+|-----------------|---------|---------------------------------------|\n+| vin             | text    | Vehicle Identification Number (VIN)   |\n+| refreshInterval | integer | Refresh Interval in Minutes           |\n+| units           | text    | Unit Selection                        |\n+| imageSize       | integer | Image Size                            |\n+| imageViewport   | text    | Image Viewport                        |\n+\n+The units can be configured in 3 ways\n+\n+* _AUTODETECT_ selects Miles for US & UK, Kilometer otherwise\n+* _METRIC_ selects directly Kilometers\n+* _IMPERIAL_ selects directly Miles\n+\n+The imageVieport allows to show the Vehicle from different angels.\n+Possible values are \n+\n+* FRONT\n+* REAR\n+* SIDE\n+* DASHBOARD\n+* DRIVERDOOR\n+\n+## Channels\n+\n+There are many Channels available for each Vehicle. \n+For better overview they are clustered in different Channel Groups.\n+The Channel Groups are different for the Vehicle Types, on the build-in Sensors of the Vehicle and the activated Services.\n+\n+### Bridge Channels\n+\n+If the Vehicle isn't found in the Discovery force a log of Fingerprint Data which helps to analyze the problem.\n+Please check [TroubleShooting Section](#TroubleShooting) for further advice.\n+\n+| Channel Label         | Channel ID            | Type   | Description                                       |\n+|-----------------------|-----------------------|--------|---------------------------------------------------|\n+| Discovery Fingerprint | discovery-fingerprint | Switch | Forcing a log entry to analyze Discovery Problems |\n+\n+### Thing Channel Groups \n+\n+#### Vehicle Status\n+\n+Reflects Status of the Vehicle.\n+Available for all Vehicles, Read-only.\n+\n+| Channel Label             | Channel Group ID | Channel ID          | Type          | Description                                                                       |\n+|---------------------------|------------------|---------------------|---------------|-----------------------------------------------------------------------------------|\n+| Overall Door Status       | status           | doors               | String        | **Closed** if all closed otherwise **Open**. **Unknown** if no data is delivered  |\n+| Overall Window Status     | status           | windows             | String        | **Closed** if all closed otherwise **Open** or **Intermediate**. **Unknown** if no data is delivered   |\n+| Doors Locked              | status           | lock                | String        | Status if Doors are locked or unlocked                                            |\n+| Next Service Date         | status           | service-date        | DateTime      | Date of Upcoming Service                                                          |\n+| Mileage till Next Service | status           | service-mileage     | Number:Length | Mileage till Upcoming Service                                                     |\n+| Check Control             | status           | check-control       | String        | Indicator if CheckControl is **Active** or **Not Active**. **Unknown** if no data is delivered         |\n+| Charging Status           | status           | charge              | String        | Only available for PHEV, BEV_REX and BEV                                          |\n+| Last Status Timestamp     | status           | last-update         | DateTime      | Date and Time of last status update.                                              |\n+\n+See [further details for DateTime](#last-status-update-timestamp) in case of wrong timestamp values\n+\n+#### Services\n+\n+Group for all upcoming Services with Description, Service Date and / or Service Mileage\n+It's designed as [List Interface](#list-interface) so all upcoming Services can be checked.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTExOTc0Mw=="}, "originalCommit": {"oid": "e0bfe93e13df4a3c5de5f8819b94ebf795664904"}, "originalPosition": 165}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MzMxMDI4Ng==", "bodyText": "For sure it's possible doing it that way. It's also possible to write in the json directly. With this the a parser is needed e.g. to get next service date or mileage in an own value.\nBut I don't know which problem will be solved with this pattern.  As I stated in my previous comment: I don't see a hack anymore.", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r563310286", "createdAt": "2021-01-24T15:41:37Z", "author": {"login": "weymann"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/README.md", "diffHunk": "@@ -0,0 +1,862 @@\n+# BMW ConnectedDrive Binding\n+\n+<img align=\"right\" src=\"./doc/bmw-connected.png\" width=\"150\" height=\"150\"/>\n+\n+The Binding provides a Connection between [BMWs ConnectedDrive Portal](https://www.bmw-connecteddrive.com/country-region-select/country-region-selection.html) and openHAB.\n+All Vehicles connected to an Account will be detected by the Discovery with the correct type \n+\n+* Conventional Fuel Vehicle\n+* Plugin-Hybrid Electrical Vehicle \n+* Battery Electric Vehicle with Range Extender\n+* Battery Electric Vehicle \n+\n+In addition Properties are attached with Information and Services provided by this Vehicle.\n+The provided data depends on \n+\n+1. the [Type](#Things) and \n+2. the Services mentioned in [Properties](#properties)\n+\n+Different Channel Groups are clustering all informations.\n+Check for each Group if it's supported for this Vehicle.\n+\n+Please note **this isn't a real-time Binding**. \n+If the Door is opened the state isn't transmitted and changed immediately. \n+This isn't a flaw in the Binding itself because the state in BMWs own ConnectedDrive App is also updated with some delay. \n+\n+## Supported Things\n+\n+### Bridge\n+\n+The Bridge establishes the Connection between BMW ConnectedDrive Portal and openHAB.\n+\n+| Name                       | Bridge Type ID | Description                                                |\n+|----------------------------|----------------|------------------------------------------------------------|\n+| BMW ConnectedDrive Account | account        | Access to BMW ConnectedDrive Portal for a specific user    |\n+\n+\n+### Things\n+\n+Four different Vehicle Types are provided. \n+They differ in the supported Channel Groups & Channels. \n+Conventional Fuel Vehicles have no _Charging Profile_, Electric Vehicles don't provide a _Fuel Range_. \n+For Hybrid Vehicles in addition to _Fuel and Electric Range_ the _Hybrid Range_ is shown.\n+ \n+| Name                                | Thing Type ID | Supported Channel Groups                                             |\n+|-------------------------------------|---------------|----------------------------------------------------------------------|\n+| BMW Electric Vehicle                | BEV           | status, range, location, service, check, charge, image, troubleshoot |\n+| BMW Electric Vehicle with REX       | BEV_REX       | status, range, location, service, check, charge, image, troubleshoot |\n+| BMW Plug-In-Hybrid Electric Vehicle | PHEV          | status, range, location, service, check, charge, image, troubleshoot |\n+| BMW Conventional Vehicle            | CONV          | status, range, location, service, check, image, troubleshoot         |\n+\n+ \n+#### Properties\n+\n+<img align=\"right\" src=\"./doc/properties.png\" width=\"500\" height=\"600\"/>\n+\n+For each Vehicle Properties are available. \n+Basically 3 Types of Information are registered as Properties\n+\n+* Informations regarding your Dealer with Address and Phone Number\n+* Which services are available / not available\n+* Vehicle Properties like Color, Model Type, Drive Train and Construction Year\n+\n+In the right picture  can see in *Services Activated* e.g. the *DoorLock* and *DoorUnlock* Services are mentioned. \n+This ensures [Channel Group _Remote Services_](#remote-services) is supporting Door lock and Door unlock.\n+\n+In  *Services Supported* the entry *LastDestination* is mentioned.\n+So it's valid to connect Channel Group [Last Destinations](#destinations) in order to display the last 3 Navigation Destinations.\n+\n+| Property Key       | Property Value      |  Supported Channel Groups    |\n+|--------------------|---------------------|------------------------------|\n+| Services Supported | Statistics          | last-trip, lifetime          |\n+| Services Supported | LastDestinations    | destinations                 |\n+| Services Activated | list of services    | remote                       |\n+\n+\n+## Discovery\n+\n+Auto Discovery is starting after creation of the Bridge towards BMW ConnectedDrive. \n+A list of your registered Vehicles is queried and all found Vehicles are added in Inbox.\n+Unique Identifier is the *Vehicle Identification Number* (VIN). \n+If a Thing is already declared in a  *.things configuration* Discovery won't highlight it again.\n+Properties will be attached to predefined Vehicles if the VIN is matching.\n+\n+## Configuration\n+\n+### Bridge\n+\n+| Parameter       | Type    | Description                                                             |           \n+|-----------------|---------|-------------------------------------------------------------------------|\n+| userName        | text    | BMW Connected Drive Username                  |\n+| password        | text    | BMW Connected Drive Password                  |\n+| region          | text    | Select Region in order to connect to the appropriate BMW Server.   |\n+\n+The region Configuration has 3 different possibilities\n+\n+* _NORTH_AMERICA_\n+* _CHINA_\n+* _ROW_ for Rest of World\n+\n+### Thing\n+\n+Same Configuration is needed for all Things\n+\n+| Parameter       | Type    | Description                           |           \n+|-----------------|---------|---------------------------------------|\n+| vin             | text    | Vehicle Identification Number (VIN)   |\n+| refreshInterval | integer | Refresh Interval in Minutes           |\n+| units           | text    | Unit Selection                        |\n+| imageSize       | integer | Image Size                            |\n+| imageViewport   | text    | Image Viewport                        |\n+\n+The units can be configured in 3 ways\n+\n+* _AUTODETECT_ selects Miles for US & UK, Kilometer otherwise\n+* _METRIC_ selects directly Kilometers\n+* _IMPERIAL_ selects directly Miles\n+\n+The imageVieport allows to show the Vehicle from different angels.\n+Possible values are \n+\n+* FRONT\n+* REAR\n+* SIDE\n+* DASHBOARD\n+* DRIVERDOOR\n+\n+## Channels\n+\n+There are many Channels available for each Vehicle. \n+For better overview they are clustered in different Channel Groups.\n+The Channel Groups are different for the Vehicle Types, on the build-in Sensors of the Vehicle and the activated Services.\n+\n+### Bridge Channels\n+\n+If the Vehicle isn't found in the Discovery force a log of Fingerprint Data which helps to analyze the problem.\n+Please check [TroubleShooting Section](#TroubleShooting) for further advice.\n+\n+| Channel Label         | Channel ID            | Type   | Description                                       |\n+|-----------------------|-----------------------|--------|---------------------------------------------------|\n+| Discovery Fingerprint | discovery-fingerprint | Switch | Forcing a log entry to analyze Discovery Problems |\n+\n+### Thing Channel Groups \n+\n+#### Vehicle Status\n+\n+Reflects Status of the Vehicle.\n+Available for all Vehicles, Read-only.\n+\n+| Channel Label             | Channel Group ID | Channel ID          | Type          | Description                                                                       |\n+|---------------------------|------------------|---------------------|---------------|-----------------------------------------------------------------------------------|\n+| Overall Door Status       | status           | doors               | String        | **Closed** if all closed otherwise **Open**. **Unknown** if no data is delivered  |\n+| Overall Window Status     | status           | windows             | String        | **Closed** if all closed otherwise **Open** or **Intermediate**. **Unknown** if no data is delivered   |\n+| Doors Locked              | status           | lock                | String        | Status if Doors are locked or unlocked                                            |\n+| Next Service Date         | status           | service-date        | DateTime      | Date of Upcoming Service                                                          |\n+| Mileage till Next Service | status           | service-mileage     | Number:Length | Mileage till Upcoming Service                                                     |\n+| Check Control             | status           | check-control       | String        | Indicator if CheckControl is **Active** or **Not Active**. **Unknown** if no data is delivered         |\n+| Charging Status           | status           | charge              | String        | Only available for PHEV, BEV_REX and BEV                                          |\n+| Last Status Timestamp     | status           | last-update         | DateTime      | Date and Time of last status update.                                              |\n+\n+See [further details for DateTime](#last-status-update-timestamp) in case of wrong timestamp values\n+\n+#### Services\n+\n+Group for all upcoming Services with Description, Service Date and / or Service Mileage\n+It's designed as [List Interface](#list-interface) so all upcoming Services can be checked.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTExOTc0Mw=="}, "originalCommit": {"oid": "e0bfe93e13df4a3c5de5f8819b94ebf795664904"}, "originalPosition": 165}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MzMxNDA3MA==", "bodyText": "The usability of your current implementation as shown in the video looks good, but the original problem remains.\n\nIf we look simply at the user interface it's the same as the LGWebOS binding where I get the idea from. You select a new TV-channel and corresponding channels are changing. Under the \"technical hood\" there's a real TV state change, for BMW it's just browsing.\n\nYour last sentence describes the problem I see very well. In your example, switching of the TV channel changes an actual state of the Thing, but browsing through the services doesn't change the Thing's state.\nIf two users browse through the services, they would interfere each other as they change the state simultaneously. That issue exists with all Things, but in this case the user doesn't expect an interference as he/she is only browsing through a list in the UI.\nI don't think you need a parser if you provide the servies via an Action for machine reading and a human readable string for the presentation in the UI.", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r563314070", "createdAt": "2021-01-24T16:10:15Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/README.md", "diffHunk": "@@ -0,0 +1,862 @@\n+# BMW ConnectedDrive Binding\n+\n+<img align=\"right\" src=\"./doc/bmw-connected.png\" width=\"150\" height=\"150\"/>\n+\n+The Binding provides a Connection between [BMWs ConnectedDrive Portal](https://www.bmw-connecteddrive.com/country-region-select/country-region-selection.html) and openHAB.\n+All Vehicles connected to an Account will be detected by the Discovery with the correct type \n+\n+* Conventional Fuel Vehicle\n+* Plugin-Hybrid Electrical Vehicle \n+* Battery Electric Vehicle with Range Extender\n+* Battery Electric Vehicle \n+\n+In addition Properties are attached with Information and Services provided by this Vehicle.\n+The provided data depends on \n+\n+1. the [Type](#Things) and \n+2. the Services mentioned in [Properties](#properties)\n+\n+Different Channel Groups are clustering all informations.\n+Check for each Group if it's supported for this Vehicle.\n+\n+Please note **this isn't a real-time Binding**. \n+If the Door is opened the state isn't transmitted and changed immediately. \n+This isn't a flaw in the Binding itself because the state in BMWs own ConnectedDrive App is also updated with some delay. \n+\n+## Supported Things\n+\n+### Bridge\n+\n+The Bridge establishes the Connection between BMW ConnectedDrive Portal and openHAB.\n+\n+| Name                       | Bridge Type ID | Description                                                |\n+|----------------------------|----------------|------------------------------------------------------------|\n+| BMW ConnectedDrive Account | account        | Access to BMW ConnectedDrive Portal for a specific user    |\n+\n+\n+### Things\n+\n+Four different Vehicle Types are provided. \n+They differ in the supported Channel Groups & Channels. \n+Conventional Fuel Vehicles have no _Charging Profile_, Electric Vehicles don't provide a _Fuel Range_. \n+For Hybrid Vehicles in addition to _Fuel and Electric Range_ the _Hybrid Range_ is shown.\n+ \n+| Name                                | Thing Type ID | Supported Channel Groups                                             |\n+|-------------------------------------|---------------|----------------------------------------------------------------------|\n+| BMW Electric Vehicle                | BEV           | status, range, location, service, check, charge, image, troubleshoot |\n+| BMW Electric Vehicle with REX       | BEV_REX       | status, range, location, service, check, charge, image, troubleshoot |\n+| BMW Plug-In-Hybrid Electric Vehicle | PHEV          | status, range, location, service, check, charge, image, troubleshoot |\n+| BMW Conventional Vehicle            | CONV          | status, range, location, service, check, image, troubleshoot         |\n+\n+ \n+#### Properties\n+\n+<img align=\"right\" src=\"./doc/properties.png\" width=\"500\" height=\"600\"/>\n+\n+For each Vehicle Properties are available. \n+Basically 3 Types of Information are registered as Properties\n+\n+* Informations regarding your Dealer with Address and Phone Number\n+* Which services are available / not available\n+* Vehicle Properties like Color, Model Type, Drive Train and Construction Year\n+\n+In the right picture  can see in *Services Activated* e.g. the *DoorLock* and *DoorUnlock* Services are mentioned. \n+This ensures [Channel Group _Remote Services_](#remote-services) is supporting Door lock and Door unlock.\n+\n+In  *Services Supported* the entry *LastDestination* is mentioned.\n+So it's valid to connect Channel Group [Last Destinations](#destinations) in order to display the last 3 Navigation Destinations.\n+\n+| Property Key       | Property Value      |  Supported Channel Groups    |\n+|--------------------|---------------------|------------------------------|\n+| Services Supported | Statistics          | last-trip, lifetime          |\n+| Services Supported | LastDestinations    | destinations                 |\n+| Services Activated | list of services    | remote                       |\n+\n+\n+## Discovery\n+\n+Auto Discovery is starting after creation of the Bridge towards BMW ConnectedDrive. \n+A list of your registered Vehicles is queried and all found Vehicles are added in Inbox.\n+Unique Identifier is the *Vehicle Identification Number* (VIN). \n+If a Thing is already declared in a  *.things configuration* Discovery won't highlight it again.\n+Properties will be attached to predefined Vehicles if the VIN is matching.\n+\n+## Configuration\n+\n+### Bridge\n+\n+| Parameter       | Type    | Description                                                             |           \n+|-----------------|---------|-------------------------------------------------------------------------|\n+| userName        | text    | BMW Connected Drive Username                  |\n+| password        | text    | BMW Connected Drive Password                  |\n+| region          | text    | Select Region in order to connect to the appropriate BMW Server.   |\n+\n+The region Configuration has 3 different possibilities\n+\n+* _NORTH_AMERICA_\n+* _CHINA_\n+* _ROW_ for Rest of World\n+\n+### Thing\n+\n+Same Configuration is needed for all Things\n+\n+| Parameter       | Type    | Description                           |           \n+|-----------------|---------|---------------------------------------|\n+| vin             | text    | Vehicle Identification Number (VIN)   |\n+| refreshInterval | integer | Refresh Interval in Minutes           |\n+| units           | text    | Unit Selection                        |\n+| imageSize       | integer | Image Size                            |\n+| imageViewport   | text    | Image Viewport                        |\n+\n+The units can be configured in 3 ways\n+\n+* _AUTODETECT_ selects Miles for US & UK, Kilometer otherwise\n+* _METRIC_ selects directly Kilometers\n+* _IMPERIAL_ selects directly Miles\n+\n+The imageVieport allows to show the Vehicle from different angels.\n+Possible values are \n+\n+* FRONT\n+* REAR\n+* SIDE\n+* DASHBOARD\n+* DRIVERDOOR\n+\n+## Channels\n+\n+There are many Channels available for each Vehicle. \n+For better overview they are clustered in different Channel Groups.\n+The Channel Groups are different for the Vehicle Types, on the build-in Sensors of the Vehicle and the activated Services.\n+\n+### Bridge Channels\n+\n+If the Vehicle isn't found in the Discovery force a log of Fingerprint Data which helps to analyze the problem.\n+Please check [TroubleShooting Section](#TroubleShooting) for further advice.\n+\n+| Channel Label         | Channel ID            | Type   | Description                                       |\n+|-----------------------|-----------------------|--------|---------------------------------------------------|\n+| Discovery Fingerprint | discovery-fingerprint | Switch | Forcing a log entry to analyze Discovery Problems |\n+\n+### Thing Channel Groups \n+\n+#### Vehicle Status\n+\n+Reflects Status of the Vehicle.\n+Available for all Vehicles, Read-only.\n+\n+| Channel Label             | Channel Group ID | Channel ID          | Type          | Description                                                                       |\n+|---------------------------|------------------|---------------------|---------------|-----------------------------------------------------------------------------------|\n+| Overall Door Status       | status           | doors               | String        | **Closed** if all closed otherwise **Open**. **Unknown** if no data is delivered  |\n+| Overall Window Status     | status           | windows             | String        | **Closed** if all closed otherwise **Open** or **Intermediate**. **Unknown** if no data is delivered   |\n+| Doors Locked              | status           | lock                | String        | Status if Doors are locked or unlocked                                            |\n+| Next Service Date         | status           | service-date        | DateTime      | Date of Upcoming Service                                                          |\n+| Mileage till Next Service | status           | service-mileage     | Number:Length | Mileage till Upcoming Service                                                     |\n+| Check Control             | status           | check-control       | String        | Indicator if CheckControl is **Active** or **Not Active**. **Unknown** if no data is delivered         |\n+| Charging Status           | status           | charge              | String        | Only available for PHEV, BEV_REX and BEV                                          |\n+| Last Status Timestamp     | status           | last-update         | DateTime      | Date and Time of last status update.                                              |\n+\n+See [further details for DateTime](#last-status-update-timestamp) in case of wrong timestamp values\n+\n+#### Services\n+\n+Group for all upcoming Services with Description, Service Date and / or Service Mileage\n+It's designed as [List Interface](#list-interface) so all upcoming Services can be checked.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTExOTc0Mw=="}, "originalCommit": {"oid": "e0bfe93e13df4a3c5de5f8819b94ebf795664904"}, "originalPosition": 165}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NDA0MDMxNA==", "bodyText": "I fully agree. That's the only remaining problem.\n\nThat issue exists with all Things, but in this case the user doesn't expect an interference as he/she is only browsing through a list in the UI.\n\nPlease take a minute to think about it  ... this is the only impact! The binding doesn't crash, no data is inconsistent and no functional issues. It's only two users in the same household who may observe this in rare occasions.\nFor me it's valid to take this constraint and mention it e.g. in readme instead of  creating a complete different concept with list in one String for UI and Actions for rules which makes provide the shown Map use case impossible / more difficult.", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r574040314", "createdAt": "2021-02-10T20:10:35Z", "author": {"login": "weymann"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/README.md", "diffHunk": "@@ -0,0 +1,862 @@\n+# BMW ConnectedDrive Binding\n+\n+<img align=\"right\" src=\"./doc/bmw-connected.png\" width=\"150\" height=\"150\"/>\n+\n+The Binding provides a Connection between [BMWs ConnectedDrive Portal](https://www.bmw-connecteddrive.com/country-region-select/country-region-selection.html) and openHAB.\n+All Vehicles connected to an Account will be detected by the Discovery with the correct type \n+\n+* Conventional Fuel Vehicle\n+* Plugin-Hybrid Electrical Vehicle \n+* Battery Electric Vehicle with Range Extender\n+* Battery Electric Vehicle \n+\n+In addition Properties are attached with Information and Services provided by this Vehicle.\n+The provided data depends on \n+\n+1. the [Type](#Things) and \n+2. the Services mentioned in [Properties](#properties)\n+\n+Different Channel Groups are clustering all informations.\n+Check for each Group if it's supported for this Vehicle.\n+\n+Please note **this isn't a real-time Binding**. \n+If the Door is opened the state isn't transmitted and changed immediately. \n+This isn't a flaw in the Binding itself because the state in BMWs own ConnectedDrive App is also updated with some delay. \n+\n+## Supported Things\n+\n+### Bridge\n+\n+The Bridge establishes the Connection between BMW ConnectedDrive Portal and openHAB.\n+\n+| Name                       | Bridge Type ID | Description                                                |\n+|----------------------------|----------------|------------------------------------------------------------|\n+| BMW ConnectedDrive Account | account        | Access to BMW ConnectedDrive Portal for a specific user    |\n+\n+\n+### Things\n+\n+Four different Vehicle Types are provided. \n+They differ in the supported Channel Groups & Channels. \n+Conventional Fuel Vehicles have no _Charging Profile_, Electric Vehicles don't provide a _Fuel Range_. \n+For Hybrid Vehicles in addition to _Fuel and Electric Range_ the _Hybrid Range_ is shown.\n+ \n+| Name                                | Thing Type ID | Supported Channel Groups                                             |\n+|-------------------------------------|---------------|----------------------------------------------------------------------|\n+| BMW Electric Vehicle                | BEV           | status, range, location, service, check, charge, image, troubleshoot |\n+| BMW Electric Vehicle with REX       | BEV_REX       | status, range, location, service, check, charge, image, troubleshoot |\n+| BMW Plug-In-Hybrid Electric Vehicle | PHEV          | status, range, location, service, check, charge, image, troubleshoot |\n+| BMW Conventional Vehicle            | CONV          | status, range, location, service, check, image, troubleshoot         |\n+\n+ \n+#### Properties\n+\n+<img align=\"right\" src=\"./doc/properties.png\" width=\"500\" height=\"600\"/>\n+\n+For each Vehicle Properties are available. \n+Basically 3 Types of Information are registered as Properties\n+\n+* Informations regarding your Dealer with Address and Phone Number\n+* Which services are available / not available\n+* Vehicle Properties like Color, Model Type, Drive Train and Construction Year\n+\n+In the right picture  can see in *Services Activated* e.g. the *DoorLock* and *DoorUnlock* Services are mentioned. \n+This ensures [Channel Group _Remote Services_](#remote-services) is supporting Door lock and Door unlock.\n+\n+In  *Services Supported* the entry *LastDestination* is mentioned.\n+So it's valid to connect Channel Group [Last Destinations](#destinations) in order to display the last 3 Navigation Destinations.\n+\n+| Property Key       | Property Value      |  Supported Channel Groups    |\n+|--------------------|---------------------|------------------------------|\n+| Services Supported | Statistics          | last-trip, lifetime          |\n+| Services Supported | LastDestinations    | destinations                 |\n+| Services Activated | list of services    | remote                       |\n+\n+\n+## Discovery\n+\n+Auto Discovery is starting after creation of the Bridge towards BMW ConnectedDrive. \n+A list of your registered Vehicles is queried and all found Vehicles are added in Inbox.\n+Unique Identifier is the *Vehicle Identification Number* (VIN). \n+If a Thing is already declared in a  *.things configuration* Discovery won't highlight it again.\n+Properties will be attached to predefined Vehicles if the VIN is matching.\n+\n+## Configuration\n+\n+### Bridge\n+\n+| Parameter       | Type    | Description                                                             |           \n+|-----------------|---------|-------------------------------------------------------------------------|\n+| userName        | text    | BMW Connected Drive Username                  |\n+| password        | text    | BMW Connected Drive Password                  |\n+| region          | text    | Select Region in order to connect to the appropriate BMW Server.   |\n+\n+The region Configuration has 3 different possibilities\n+\n+* _NORTH_AMERICA_\n+* _CHINA_\n+* _ROW_ for Rest of World\n+\n+### Thing\n+\n+Same Configuration is needed for all Things\n+\n+| Parameter       | Type    | Description                           |           \n+|-----------------|---------|---------------------------------------|\n+| vin             | text    | Vehicle Identification Number (VIN)   |\n+| refreshInterval | integer | Refresh Interval in Minutes           |\n+| units           | text    | Unit Selection                        |\n+| imageSize       | integer | Image Size                            |\n+| imageViewport   | text    | Image Viewport                        |\n+\n+The units can be configured in 3 ways\n+\n+* _AUTODETECT_ selects Miles for US & UK, Kilometer otherwise\n+* _METRIC_ selects directly Kilometers\n+* _IMPERIAL_ selects directly Miles\n+\n+The imageVieport allows to show the Vehicle from different angels.\n+Possible values are \n+\n+* FRONT\n+* REAR\n+* SIDE\n+* DASHBOARD\n+* DRIVERDOOR\n+\n+## Channels\n+\n+There are many Channels available for each Vehicle. \n+For better overview they are clustered in different Channel Groups.\n+The Channel Groups are different for the Vehicle Types, on the build-in Sensors of the Vehicle and the activated Services.\n+\n+### Bridge Channels\n+\n+If the Vehicle isn't found in the Discovery force a log of Fingerprint Data which helps to analyze the problem.\n+Please check [TroubleShooting Section](#TroubleShooting) for further advice.\n+\n+| Channel Label         | Channel ID            | Type   | Description                                       |\n+|-----------------------|-----------------------|--------|---------------------------------------------------|\n+| Discovery Fingerprint | discovery-fingerprint | Switch | Forcing a log entry to analyze Discovery Problems |\n+\n+### Thing Channel Groups \n+\n+#### Vehicle Status\n+\n+Reflects Status of the Vehicle.\n+Available for all Vehicles, Read-only.\n+\n+| Channel Label             | Channel Group ID | Channel ID          | Type          | Description                                                                       |\n+|---------------------------|------------------|---------------------|---------------|-----------------------------------------------------------------------------------|\n+| Overall Door Status       | status           | doors               | String        | **Closed** if all closed otherwise **Open**. **Unknown** if no data is delivered  |\n+| Overall Window Status     | status           | windows             | String        | **Closed** if all closed otherwise **Open** or **Intermediate**. **Unknown** if no data is delivered   |\n+| Doors Locked              | status           | lock                | String        | Status if Doors are locked or unlocked                                            |\n+| Next Service Date         | status           | service-date        | DateTime      | Date of Upcoming Service                                                          |\n+| Mileage till Next Service | status           | service-mileage     | Number:Length | Mileage till Upcoming Service                                                     |\n+| Check Control             | status           | check-control       | String        | Indicator if CheckControl is **Active** or **Not Active**. **Unknown** if no data is delivered         |\n+| Charging Status           | status           | charge              | String        | Only available for PHEV, BEV_REX and BEV                                          |\n+| Last Status Timestamp     | status           | last-update         | DateTime      | Date and Time of last status update.                                              |\n+\n+See [further details for DateTime](#last-status-update-timestamp) in case of wrong timestamp values\n+\n+#### Services\n+\n+Group for all upcoming Services with Description, Service Date and / or Service Mileage\n+It's designed as [List Interface](#list-interface) so all upcoming Services can be checked.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTExOTc0Mw=="}, "originalCommit": {"oid": "e0bfe93e13df4a3c5de5f8819b94ebf795664904"}, "originalPosition": 165}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NTY1NDY4MA==", "bodyText": "@openhab/add-ons-maintainers Could please anybody join this discussion? We're some kind of stuck here and need some other opinion.", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r575654680", "createdAt": "2021-02-13T11:12:02Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/README.md", "diffHunk": "@@ -0,0 +1,862 @@\n+# BMW ConnectedDrive Binding\n+\n+<img align=\"right\" src=\"./doc/bmw-connected.png\" width=\"150\" height=\"150\"/>\n+\n+The Binding provides a Connection between [BMWs ConnectedDrive Portal](https://www.bmw-connecteddrive.com/country-region-select/country-region-selection.html) and openHAB.\n+All Vehicles connected to an Account will be detected by the Discovery with the correct type \n+\n+* Conventional Fuel Vehicle\n+* Plugin-Hybrid Electrical Vehicle \n+* Battery Electric Vehicle with Range Extender\n+* Battery Electric Vehicle \n+\n+In addition Properties are attached with Information and Services provided by this Vehicle.\n+The provided data depends on \n+\n+1. the [Type](#Things) and \n+2. the Services mentioned in [Properties](#properties)\n+\n+Different Channel Groups are clustering all informations.\n+Check for each Group if it's supported for this Vehicle.\n+\n+Please note **this isn't a real-time Binding**. \n+If the Door is opened the state isn't transmitted and changed immediately. \n+This isn't a flaw in the Binding itself because the state in BMWs own ConnectedDrive App is also updated with some delay. \n+\n+## Supported Things\n+\n+### Bridge\n+\n+The Bridge establishes the Connection between BMW ConnectedDrive Portal and openHAB.\n+\n+| Name                       | Bridge Type ID | Description                                                |\n+|----------------------------|----------------|------------------------------------------------------------|\n+| BMW ConnectedDrive Account | account        | Access to BMW ConnectedDrive Portal for a specific user    |\n+\n+\n+### Things\n+\n+Four different Vehicle Types are provided. \n+They differ in the supported Channel Groups & Channels. \n+Conventional Fuel Vehicles have no _Charging Profile_, Electric Vehicles don't provide a _Fuel Range_. \n+For Hybrid Vehicles in addition to _Fuel and Electric Range_ the _Hybrid Range_ is shown.\n+ \n+| Name                                | Thing Type ID | Supported Channel Groups                                             |\n+|-------------------------------------|---------------|----------------------------------------------------------------------|\n+| BMW Electric Vehicle                | BEV           | status, range, location, service, check, charge, image, troubleshoot |\n+| BMW Electric Vehicle with REX       | BEV_REX       | status, range, location, service, check, charge, image, troubleshoot |\n+| BMW Plug-In-Hybrid Electric Vehicle | PHEV          | status, range, location, service, check, charge, image, troubleshoot |\n+| BMW Conventional Vehicle            | CONV          | status, range, location, service, check, image, troubleshoot         |\n+\n+ \n+#### Properties\n+\n+<img align=\"right\" src=\"./doc/properties.png\" width=\"500\" height=\"600\"/>\n+\n+For each Vehicle Properties are available. \n+Basically 3 Types of Information are registered as Properties\n+\n+* Informations regarding your Dealer with Address and Phone Number\n+* Which services are available / not available\n+* Vehicle Properties like Color, Model Type, Drive Train and Construction Year\n+\n+In the right picture  can see in *Services Activated* e.g. the *DoorLock* and *DoorUnlock* Services are mentioned. \n+This ensures [Channel Group _Remote Services_](#remote-services) is supporting Door lock and Door unlock.\n+\n+In  *Services Supported* the entry *LastDestination* is mentioned.\n+So it's valid to connect Channel Group [Last Destinations](#destinations) in order to display the last 3 Navigation Destinations.\n+\n+| Property Key       | Property Value      |  Supported Channel Groups    |\n+|--------------------|---------------------|------------------------------|\n+| Services Supported | Statistics          | last-trip, lifetime          |\n+| Services Supported | LastDestinations    | destinations                 |\n+| Services Activated | list of services    | remote                       |\n+\n+\n+## Discovery\n+\n+Auto Discovery is starting after creation of the Bridge towards BMW ConnectedDrive. \n+A list of your registered Vehicles is queried and all found Vehicles are added in Inbox.\n+Unique Identifier is the *Vehicle Identification Number* (VIN). \n+If a Thing is already declared in a  *.things configuration* Discovery won't highlight it again.\n+Properties will be attached to predefined Vehicles if the VIN is matching.\n+\n+## Configuration\n+\n+### Bridge\n+\n+| Parameter       | Type    | Description                                                             |           \n+|-----------------|---------|-------------------------------------------------------------------------|\n+| userName        | text    | BMW Connected Drive Username                  |\n+| password        | text    | BMW Connected Drive Password                  |\n+| region          | text    | Select Region in order to connect to the appropriate BMW Server.   |\n+\n+The region Configuration has 3 different possibilities\n+\n+* _NORTH_AMERICA_\n+* _CHINA_\n+* _ROW_ for Rest of World\n+\n+### Thing\n+\n+Same Configuration is needed for all Things\n+\n+| Parameter       | Type    | Description                           |           \n+|-----------------|---------|---------------------------------------|\n+| vin             | text    | Vehicle Identification Number (VIN)   |\n+| refreshInterval | integer | Refresh Interval in Minutes           |\n+| units           | text    | Unit Selection                        |\n+| imageSize       | integer | Image Size                            |\n+| imageViewport   | text    | Image Viewport                        |\n+\n+The units can be configured in 3 ways\n+\n+* _AUTODETECT_ selects Miles for US & UK, Kilometer otherwise\n+* _METRIC_ selects directly Kilometers\n+* _IMPERIAL_ selects directly Miles\n+\n+The imageVieport allows to show the Vehicle from different angels.\n+Possible values are \n+\n+* FRONT\n+* REAR\n+* SIDE\n+* DASHBOARD\n+* DRIVERDOOR\n+\n+## Channels\n+\n+There are many Channels available for each Vehicle. \n+For better overview they are clustered in different Channel Groups.\n+The Channel Groups are different for the Vehicle Types, on the build-in Sensors of the Vehicle and the activated Services.\n+\n+### Bridge Channels\n+\n+If the Vehicle isn't found in the Discovery force a log of Fingerprint Data which helps to analyze the problem.\n+Please check [TroubleShooting Section](#TroubleShooting) for further advice.\n+\n+| Channel Label         | Channel ID            | Type   | Description                                       |\n+|-----------------------|-----------------------|--------|---------------------------------------------------|\n+| Discovery Fingerprint | discovery-fingerprint | Switch | Forcing a log entry to analyze Discovery Problems |\n+\n+### Thing Channel Groups \n+\n+#### Vehicle Status\n+\n+Reflects Status of the Vehicle.\n+Available for all Vehicles, Read-only.\n+\n+| Channel Label             | Channel Group ID | Channel ID          | Type          | Description                                                                       |\n+|---------------------------|------------------|---------------------|---------------|-----------------------------------------------------------------------------------|\n+| Overall Door Status       | status           | doors               | String        | **Closed** if all closed otherwise **Open**. **Unknown** if no data is delivered  |\n+| Overall Window Status     | status           | windows             | String        | **Closed** if all closed otherwise **Open** or **Intermediate**. **Unknown** if no data is delivered   |\n+| Doors Locked              | status           | lock                | String        | Status if Doors are locked or unlocked                                            |\n+| Next Service Date         | status           | service-date        | DateTime      | Date of Upcoming Service                                                          |\n+| Mileage till Next Service | status           | service-mileage     | Number:Length | Mileage till Upcoming Service                                                     |\n+| Check Control             | status           | check-control       | String        | Indicator if CheckControl is **Active** or **Not Active**. **Unknown** if no data is delivered         |\n+| Charging Status           | status           | charge              | String        | Only available for PHEV, BEV_REX and BEV                                          |\n+| Last Status Timestamp     | status           | last-update         | DateTime      | Date and Time of last status update.                                              |\n+\n+See [further details for DateTime](#last-status-update-timestamp) in case of wrong timestamp values\n+\n+#### Services\n+\n+Group for all upcoming Services with Description, Service Date and / or Service Mileage\n+It's designed as [List Interface](#list-interface) so all upcoming Services can be checked.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTExOTc0Mw=="}, "originalCommit": {"oid": "e0bfe93e13df4a3c5de5f8819b94ebf795664904"}, "originalPosition": 165}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4NjU5NzMxNQ==", "bodyText": "I don't want to block any progress, so I'm okay with sticking to the current solution.", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r586597315", "createdAt": "2021-03-03T16:56:19Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/README.md", "diffHunk": "@@ -0,0 +1,862 @@\n+# BMW ConnectedDrive Binding\n+\n+<img align=\"right\" src=\"./doc/bmw-connected.png\" width=\"150\" height=\"150\"/>\n+\n+The Binding provides a Connection between [BMWs ConnectedDrive Portal](https://www.bmw-connecteddrive.com/country-region-select/country-region-selection.html) and openHAB.\n+All Vehicles connected to an Account will be detected by the Discovery with the correct type \n+\n+* Conventional Fuel Vehicle\n+* Plugin-Hybrid Electrical Vehicle \n+* Battery Electric Vehicle with Range Extender\n+* Battery Electric Vehicle \n+\n+In addition Properties are attached with Information and Services provided by this Vehicle.\n+The provided data depends on \n+\n+1. the [Type](#Things) and \n+2. the Services mentioned in [Properties](#properties)\n+\n+Different Channel Groups are clustering all informations.\n+Check for each Group if it's supported for this Vehicle.\n+\n+Please note **this isn't a real-time Binding**. \n+If the Door is opened the state isn't transmitted and changed immediately. \n+This isn't a flaw in the Binding itself because the state in BMWs own ConnectedDrive App is also updated with some delay. \n+\n+## Supported Things\n+\n+### Bridge\n+\n+The Bridge establishes the Connection between BMW ConnectedDrive Portal and openHAB.\n+\n+| Name                       | Bridge Type ID | Description                                                |\n+|----------------------------|----------------|------------------------------------------------------------|\n+| BMW ConnectedDrive Account | account        | Access to BMW ConnectedDrive Portal for a specific user    |\n+\n+\n+### Things\n+\n+Four different Vehicle Types are provided. \n+They differ in the supported Channel Groups & Channels. \n+Conventional Fuel Vehicles have no _Charging Profile_, Electric Vehicles don't provide a _Fuel Range_. \n+For Hybrid Vehicles in addition to _Fuel and Electric Range_ the _Hybrid Range_ is shown.\n+ \n+| Name                                | Thing Type ID | Supported Channel Groups                                             |\n+|-------------------------------------|---------------|----------------------------------------------------------------------|\n+| BMW Electric Vehicle                | BEV           | status, range, location, service, check, charge, image, troubleshoot |\n+| BMW Electric Vehicle with REX       | BEV_REX       | status, range, location, service, check, charge, image, troubleshoot |\n+| BMW Plug-In-Hybrid Electric Vehicle | PHEV          | status, range, location, service, check, charge, image, troubleshoot |\n+| BMW Conventional Vehicle            | CONV          | status, range, location, service, check, image, troubleshoot         |\n+\n+ \n+#### Properties\n+\n+<img align=\"right\" src=\"./doc/properties.png\" width=\"500\" height=\"600\"/>\n+\n+For each Vehicle Properties are available. \n+Basically 3 Types of Information are registered as Properties\n+\n+* Informations regarding your Dealer with Address and Phone Number\n+* Which services are available / not available\n+* Vehicle Properties like Color, Model Type, Drive Train and Construction Year\n+\n+In the right picture  can see in *Services Activated* e.g. the *DoorLock* and *DoorUnlock* Services are mentioned. \n+This ensures [Channel Group _Remote Services_](#remote-services) is supporting Door lock and Door unlock.\n+\n+In  *Services Supported* the entry *LastDestination* is mentioned.\n+So it's valid to connect Channel Group [Last Destinations](#destinations) in order to display the last 3 Navigation Destinations.\n+\n+| Property Key       | Property Value      |  Supported Channel Groups    |\n+|--------------------|---------------------|------------------------------|\n+| Services Supported | Statistics          | last-trip, lifetime          |\n+| Services Supported | LastDestinations    | destinations                 |\n+| Services Activated | list of services    | remote                       |\n+\n+\n+## Discovery\n+\n+Auto Discovery is starting after creation of the Bridge towards BMW ConnectedDrive. \n+A list of your registered Vehicles is queried and all found Vehicles are added in Inbox.\n+Unique Identifier is the *Vehicle Identification Number* (VIN). \n+If a Thing is already declared in a  *.things configuration* Discovery won't highlight it again.\n+Properties will be attached to predefined Vehicles if the VIN is matching.\n+\n+## Configuration\n+\n+### Bridge\n+\n+| Parameter       | Type    | Description                                                             |           \n+|-----------------|---------|-------------------------------------------------------------------------|\n+| userName        | text    | BMW Connected Drive Username                  |\n+| password        | text    | BMW Connected Drive Password                  |\n+| region          | text    | Select Region in order to connect to the appropriate BMW Server.   |\n+\n+The region Configuration has 3 different possibilities\n+\n+* _NORTH_AMERICA_\n+* _CHINA_\n+* _ROW_ for Rest of World\n+\n+### Thing\n+\n+Same Configuration is needed for all Things\n+\n+| Parameter       | Type    | Description                           |           \n+|-----------------|---------|---------------------------------------|\n+| vin             | text    | Vehicle Identification Number (VIN)   |\n+| refreshInterval | integer | Refresh Interval in Minutes           |\n+| units           | text    | Unit Selection                        |\n+| imageSize       | integer | Image Size                            |\n+| imageViewport   | text    | Image Viewport                        |\n+\n+The units can be configured in 3 ways\n+\n+* _AUTODETECT_ selects Miles for US & UK, Kilometer otherwise\n+* _METRIC_ selects directly Kilometers\n+* _IMPERIAL_ selects directly Miles\n+\n+The imageVieport allows to show the Vehicle from different angels.\n+Possible values are \n+\n+* FRONT\n+* REAR\n+* SIDE\n+* DASHBOARD\n+* DRIVERDOOR\n+\n+## Channels\n+\n+There are many Channels available for each Vehicle. \n+For better overview they are clustered in different Channel Groups.\n+The Channel Groups are different for the Vehicle Types, on the build-in Sensors of the Vehicle and the activated Services.\n+\n+### Bridge Channels\n+\n+If the Vehicle isn't found in the Discovery force a log of Fingerprint Data which helps to analyze the problem.\n+Please check [TroubleShooting Section](#TroubleShooting) for further advice.\n+\n+| Channel Label         | Channel ID            | Type   | Description                                       |\n+|-----------------------|-----------------------|--------|---------------------------------------------------|\n+| Discovery Fingerprint | discovery-fingerprint | Switch | Forcing a log entry to analyze Discovery Problems |\n+\n+### Thing Channel Groups \n+\n+#### Vehicle Status\n+\n+Reflects Status of the Vehicle.\n+Available for all Vehicles, Read-only.\n+\n+| Channel Label             | Channel Group ID | Channel ID          | Type          | Description                                                                       |\n+|---------------------------|------------------|---------------------|---------------|-----------------------------------------------------------------------------------|\n+| Overall Door Status       | status           | doors               | String        | **Closed** if all closed otherwise **Open**. **Unknown** if no data is delivered  |\n+| Overall Window Status     | status           | windows             | String        | **Closed** if all closed otherwise **Open** or **Intermediate**. **Unknown** if no data is delivered   |\n+| Doors Locked              | status           | lock                | String        | Status if Doors are locked or unlocked                                            |\n+| Next Service Date         | status           | service-date        | DateTime      | Date of Upcoming Service                                                          |\n+| Mileage till Next Service | status           | service-mileage     | Number:Length | Mileage till Upcoming Service                                                     |\n+| Check Control             | status           | check-control       | String        | Indicator if CheckControl is **Active** or **Not Active**. **Unknown** if no data is delivered         |\n+| Charging Status           | status           | charge              | String        | Only available for PHEV, BEV_REX and BEV                                          |\n+| Last Status Timestamp     | status           | last-update         | DateTime      | Date and Time of last status update.                                              |\n+\n+See [further details for DateTime](#last-status-update-timestamp) in case of wrong timestamp values\n+\n+#### Services\n+\n+Group for all upcoming Services with Description, Service Date and / or Service Mileage\n+It's designed as [List Interface](#list-interface) so all upcoming Services can be checked.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTExOTc0Mw=="}, "originalCommit": {"oid": "e0bfe93e13df4a3c5de5f8819b94ebf795664904"}, "originalPosition": 165}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4OTA1MzY4OA==", "bodyText": "I still don't think it's a hack. If we look simply at the user interface it's the same as the LGWebOS binding where I get the idea from.\n\nThis only proves that there's also a hack in the LGWebOS binding and that once hacks are allowed to pass reviews, they tend to proliferate as people refer to them and take it as an example. \ud83d\ude0e\n\nFor me it's valid to take this constraint and mention it e.g. in readme instead of creating a complete different concept\n\nI have to admit that there isn't a straight-forward way to do it in place and it is unlikely that the efforts will be spent anytime soon. So I agree with you: Let us consider it a \"rare exceptional use case\" that slightly misuses current concepts in order to make it work for the user and not block your tremendous work and progress on this binding.", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r589053688", "createdAt": "2021-03-07T16:24:17Z", "author": {"login": "kaikreuzer"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/README.md", "diffHunk": "@@ -0,0 +1,862 @@\n+# BMW ConnectedDrive Binding\n+\n+<img align=\"right\" src=\"./doc/bmw-connected.png\" width=\"150\" height=\"150\"/>\n+\n+The Binding provides a Connection between [BMWs ConnectedDrive Portal](https://www.bmw-connecteddrive.com/country-region-select/country-region-selection.html) and openHAB.\n+All Vehicles connected to an Account will be detected by the Discovery with the correct type \n+\n+* Conventional Fuel Vehicle\n+* Plugin-Hybrid Electrical Vehicle \n+* Battery Electric Vehicle with Range Extender\n+* Battery Electric Vehicle \n+\n+In addition Properties are attached with Information and Services provided by this Vehicle.\n+The provided data depends on \n+\n+1. the [Type](#Things) and \n+2. the Services mentioned in [Properties](#properties)\n+\n+Different Channel Groups are clustering all informations.\n+Check for each Group if it's supported for this Vehicle.\n+\n+Please note **this isn't a real-time Binding**. \n+If the Door is opened the state isn't transmitted and changed immediately. \n+This isn't a flaw in the Binding itself because the state in BMWs own ConnectedDrive App is also updated with some delay. \n+\n+## Supported Things\n+\n+### Bridge\n+\n+The Bridge establishes the Connection between BMW ConnectedDrive Portal and openHAB.\n+\n+| Name                       | Bridge Type ID | Description                                                |\n+|----------------------------|----------------|------------------------------------------------------------|\n+| BMW ConnectedDrive Account | account        | Access to BMW ConnectedDrive Portal for a specific user    |\n+\n+\n+### Things\n+\n+Four different Vehicle Types are provided. \n+They differ in the supported Channel Groups & Channels. \n+Conventional Fuel Vehicles have no _Charging Profile_, Electric Vehicles don't provide a _Fuel Range_. \n+For Hybrid Vehicles in addition to _Fuel and Electric Range_ the _Hybrid Range_ is shown.\n+ \n+| Name                                | Thing Type ID | Supported Channel Groups                                             |\n+|-------------------------------------|---------------|----------------------------------------------------------------------|\n+| BMW Electric Vehicle                | BEV           | status, range, location, service, check, charge, image, troubleshoot |\n+| BMW Electric Vehicle with REX       | BEV_REX       | status, range, location, service, check, charge, image, troubleshoot |\n+| BMW Plug-In-Hybrid Electric Vehicle | PHEV          | status, range, location, service, check, charge, image, troubleshoot |\n+| BMW Conventional Vehicle            | CONV          | status, range, location, service, check, image, troubleshoot         |\n+\n+ \n+#### Properties\n+\n+<img align=\"right\" src=\"./doc/properties.png\" width=\"500\" height=\"600\"/>\n+\n+For each Vehicle Properties are available. \n+Basically 3 Types of Information are registered as Properties\n+\n+* Informations regarding your Dealer with Address and Phone Number\n+* Which services are available / not available\n+* Vehicle Properties like Color, Model Type, Drive Train and Construction Year\n+\n+In the right picture  can see in *Services Activated* e.g. the *DoorLock* and *DoorUnlock* Services are mentioned. \n+This ensures [Channel Group _Remote Services_](#remote-services) is supporting Door lock and Door unlock.\n+\n+In  *Services Supported* the entry *LastDestination* is mentioned.\n+So it's valid to connect Channel Group [Last Destinations](#destinations) in order to display the last 3 Navigation Destinations.\n+\n+| Property Key       | Property Value      |  Supported Channel Groups    |\n+|--------------------|---------------------|------------------------------|\n+| Services Supported | Statistics          | last-trip, lifetime          |\n+| Services Supported | LastDestinations    | destinations                 |\n+| Services Activated | list of services    | remote                       |\n+\n+\n+## Discovery\n+\n+Auto Discovery is starting after creation of the Bridge towards BMW ConnectedDrive. \n+A list of your registered Vehicles is queried and all found Vehicles are added in Inbox.\n+Unique Identifier is the *Vehicle Identification Number* (VIN). \n+If a Thing is already declared in a  *.things configuration* Discovery won't highlight it again.\n+Properties will be attached to predefined Vehicles if the VIN is matching.\n+\n+## Configuration\n+\n+### Bridge\n+\n+| Parameter       | Type    | Description                                                             |           \n+|-----------------|---------|-------------------------------------------------------------------------|\n+| userName        | text    | BMW Connected Drive Username                  |\n+| password        | text    | BMW Connected Drive Password                  |\n+| region          | text    | Select Region in order to connect to the appropriate BMW Server.   |\n+\n+The region Configuration has 3 different possibilities\n+\n+* _NORTH_AMERICA_\n+* _CHINA_\n+* _ROW_ for Rest of World\n+\n+### Thing\n+\n+Same Configuration is needed for all Things\n+\n+| Parameter       | Type    | Description                           |           \n+|-----------------|---------|---------------------------------------|\n+| vin             | text    | Vehicle Identification Number (VIN)   |\n+| refreshInterval | integer | Refresh Interval in Minutes           |\n+| units           | text    | Unit Selection                        |\n+| imageSize       | integer | Image Size                            |\n+| imageViewport   | text    | Image Viewport                        |\n+\n+The units can be configured in 3 ways\n+\n+* _AUTODETECT_ selects Miles for US & UK, Kilometer otherwise\n+* _METRIC_ selects directly Kilometers\n+* _IMPERIAL_ selects directly Miles\n+\n+The imageVieport allows to show the Vehicle from different angels.\n+Possible values are \n+\n+* FRONT\n+* REAR\n+* SIDE\n+* DASHBOARD\n+* DRIVERDOOR\n+\n+## Channels\n+\n+There are many Channels available for each Vehicle. \n+For better overview they are clustered in different Channel Groups.\n+The Channel Groups are different for the Vehicle Types, on the build-in Sensors of the Vehicle and the activated Services.\n+\n+### Bridge Channels\n+\n+If the Vehicle isn't found in the Discovery force a log of Fingerprint Data which helps to analyze the problem.\n+Please check [TroubleShooting Section](#TroubleShooting) for further advice.\n+\n+| Channel Label         | Channel ID            | Type   | Description                                       |\n+|-----------------------|-----------------------|--------|---------------------------------------------------|\n+| Discovery Fingerprint | discovery-fingerprint | Switch | Forcing a log entry to analyze Discovery Problems |\n+\n+### Thing Channel Groups \n+\n+#### Vehicle Status\n+\n+Reflects Status of the Vehicle.\n+Available for all Vehicles, Read-only.\n+\n+| Channel Label             | Channel Group ID | Channel ID          | Type          | Description                                                                       |\n+|---------------------------|------------------|---------------------|---------------|-----------------------------------------------------------------------------------|\n+| Overall Door Status       | status           | doors               | String        | **Closed** if all closed otherwise **Open**. **Unknown** if no data is delivered  |\n+| Overall Window Status     | status           | windows             | String        | **Closed** if all closed otherwise **Open** or **Intermediate**. **Unknown** if no data is delivered   |\n+| Doors Locked              | status           | lock                | String        | Status if Doors are locked or unlocked                                            |\n+| Next Service Date         | status           | service-date        | DateTime      | Date of Upcoming Service                                                          |\n+| Mileage till Next Service | status           | service-mileage     | Number:Length | Mileage till Upcoming Service                                                     |\n+| Check Control             | status           | check-control       | String        | Indicator if CheckControl is **Active** or **Not Active**. **Unknown** if no data is delivered         |\n+| Charging Status           | status           | charge              | String        | Only available for PHEV, BEV_REX and BEV                                          |\n+| Last Status Timestamp     | status           | last-update         | DateTime      | Date and Time of last status update.                                              |\n+\n+See [further details for DateTime](#last-status-update-timestamp) in case of wrong timestamp values\n+\n+#### Services\n+\n+Group for all upcoming Services with Description, Service Date and / or Service Mileage\n+It's designed as [List Interface](#list-interface) so all upcoming Services can be checked.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTExOTc0Mw=="}, "originalCommit": {"oid": "e0bfe93e13df4a3c5de5f8819b94ebf795664904"}, "originalPosition": 165}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwOTA4MDU5NQ==", "bodyText": "I did investigate a bit more and found the oh-repeater component that allows to display dynamic tables based on item's stateOptions. I'll build a prototype to check out how this can be used as an alternative to the current concept that does not rely on dynamic dependency of channel-states being used as ui-behavioral element.", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r609080595", "createdAt": "2021-04-07T21:26:58Z", "author": {"login": "ntruchsess"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/README.md", "diffHunk": "@@ -0,0 +1,862 @@\n+# BMW ConnectedDrive Binding\n+\n+<img align=\"right\" src=\"./doc/bmw-connected.png\" width=\"150\" height=\"150\"/>\n+\n+The Binding provides a Connection between [BMWs ConnectedDrive Portal](https://www.bmw-connecteddrive.com/country-region-select/country-region-selection.html) and openHAB.\n+All Vehicles connected to an Account will be detected by the Discovery with the correct type \n+\n+* Conventional Fuel Vehicle\n+* Plugin-Hybrid Electrical Vehicle \n+* Battery Electric Vehicle with Range Extender\n+* Battery Electric Vehicle \n+\n+In addition Properties are attached with Information and Services provided by this Vehicle.\n+The provided data depends on \n+\n+1. the [Type](#Things) and \n+2. the Services mentioned in [Properties](#properties)\n+\n+Different Channel Groups are clustering all informations.\n+Check for each Group if it's supported for this Vehicle.\n+\n+Please note **this isn't a real-time Binding**. \n+If the Door is opened the state isn't transmitted and changed immediately. \n+This isn't a flaw in the Binding itself because the state in BMWs own ConnectedDrive App is also updated with some delay. \n+\n+## Supported Things\n+\n+### Bridge\n+\n+The Bridge establishes the Connection between BMW ConnectedDrive Portal and openHAB.\n+\n+| Name                       | Bridge Type ID | Description                                                |\n+|----------------------------|----------------|------------------------------------------------------------|\n+| BMW ConnectedDrive Account | account        | Access to BMW ConnectedDrive Portal for a specific user    |\n+\n+\n+### Things\n+\n+Four different Vehicle Types are provided. \n+They differ in the supported Channel Groups & Channels. \n+Conventional Fuel Vehicles have no _Charging Profile_, Electric Vehicles don't provide a _Fuel Range_. \n+For Hybrid Vehicles in addition to _Fuel and Electric Range_ the _Hybrid Range_ is shown.\n+ \n+| Name                                | Thing Type ID | Supported Channel Groups                                             |\n+|-------------------------------------|---------------|----------------------------------------------------------------------|\n+| BMW Electric Vehicle                | BEV           | status, range, location, service, check, charge, image, troubleshoot |\n+| BMW Electric Vehicle with REX       | BEV_REX       | status, range, location, service, check, charge, image, troubleshoot |\n+| BMW Plug-In-Hybrid Electric Vehicle | PHEV          | status, range, location, service, check, charge, image, troubleshoot |\n+| BMW Conventional Vehicle            | CONV          | status, range, location, service, check, image, troubleshoot         |\n+\n+ \n+#### Properties\n+\n+<img align=\"right\" src=\"./doc/properties.png\" width=\"500\" height=\"600\"/>\n+\n+For each Vehicle Properties are available. \n+Basically 3 Types of Information are registered as Properties\n+\n+* Informations regarding your Dealer with Address and Phone Number\n+* Which services are available / not available\n+* Vehicle Properties like Color, Model Type, Drive Train and Construction Year\n+\n+In the right picture  can see in *Services Activated* e.g. the *DoorLock* and *DoorUnlock* Services are mentioned. \n+This ensures [Channel Group _Remote Services_](#remote-services) is supporting Door lock and Door unlock.\n+\n+In  *Services Supported* the entry *LastDestination* is mentioned.\n+So it's valid to connect Channel Group [Last Destinations](#destinations) in order to display the last 3 Navigation Destinations.\n+\n+| Property Key       | Property Value      |  Supported Channel Groups    |\n+|--------------------|---------------------|------------------------------|\n+| Services Supported | Statistics          | last-trip, lifetime          |\n+| Services Supported | LastDestinations    | destinations                 |\n+| Services Activated | list of services    | remote                       |\n+\n+\n+## Discovery\n+\n+Auto Discovery is starting after creation of the Bridge towards BMW ConnectedDrive. \n+A list of your registered Vehicles is queried and all found Vehicles are added in Inbox.\n+Unique Identifier is the *Vehicle Identification Number* (VIN). \n+If a Thing is already declared in a  *.things configuration* Discovery won't highlight it again.\n+Properties will be attached to predefined Vehicles if the VIN is matching.\n+\n+## Configuration\n+\n+### Bridge\n+\n+| Parameter       | Type    | Description                                                             |           \n+|-----------------|---------|-------------------------------------------------------------------------|\n+| userName        | text    | BMW Connected Drive Username                  |\n+| password        | text    | BMW Connected Drive Password                  |\n+| region          | text    | Select Region in order to connect to the appropriate BMW Server.   |\n+\n+The region Configuration has 3 different possibilities\n+\n+* _NORTH_AMERICA_\n+* _CHINA_\n+* _ROW_ for Rest of World\n+\n+### Thing\n+\n+Same Configuration is needed for all Things\n+\n+| Parameter       | Type    | Description                           |           \n+|-----------------|---------|---------------------------------------|\n+| vin             | text    | Vehicle Identification Number (VIN)   |\n+| refreshInterval | integer | Refresh Interval in Minutes           |\n+| units           | text    | Unit Selection                        |\n+| imageSize       | integer | Image Size                            |\n+| imageViewport   | text    | Image Viewport                        |\n+\n+The units can be configured in 3 ways\n+\n+* _AUTODETECT_ selects Miles for US & UK, Kilometer otherwise\n+* _METRIC_ selects directly Kilometers\n+* _IMPERIAL_ selects directly Miles\n+\n+The imageVieport allows to show the Vehicle from different angels.\n+Possible values are \n+\n+* FRONT\n+* REAR\n+* SIDE\n+* DASHBOARD\n+* DRIVERDOOR\n+\n+## Channels\n+\n+There are many Channels available for each Vehicle. \n+For better overview they are clustered in different Channel Groups.\n+The Channel Groups are different for the Vehicle Types, on the build-in Sensors of the Vehicle and the activated Services.\n+\n+### Bridge Channels\n+\n+If the Vehicle isn't found in the Discovery force a log of Fingerprint Data which helps to analyze the problem.\n+Please check [TroubleShooting Section](#TroubleShooting) for further advice.\n+\n+| Channel Label         | Channel ID            | Type   | Description                                       |\n+|-----------------------|-----------------------|--------|---------------------------------------------------|\n+| Discovery Fingerprint | discovery-fingerprint | Switch | Forcing a log entry to analyze Discovery Problems |\n+\n+### Thing Channel Groups \n+\n+#### Vehicle Status\n+\n+Reflects Status of the Vehicle.\n+Available for all Vehicles, Read-only.\n+\n+| Channel Label             | Channel Group ID | Channel ID          | Type          | Description                                                                       |\n+|---------------------------|------------------|---------------------|---------------|-----------------------------------------------------------------------------------|\n+| Overall Door Status       | status           | doors               | String        | **Closed** if all closed otherwise **Open**. **Unknown** if no data is delivered  |\n+| Overall Window Status     | status           | windows             | String        | **Closed** if all closed otherwise **Open** or **Intermediate**. **Unknown** if no data is delivered   |\n+| Doors Locked              | status           | lock                | String        | Status if Doors are locked or unlocked                                            |\n+| Next Service Date         | status           | service-date        | DateTime      | Date of Upcoming Service                                                          |\n+| Mileage till Next Service | status           | service-mileage     | Number:Length | Mileage till Upcoming Service                                                     |\n+| Check Control             | status           | check-control       | String        | Indicator if CheckControl is **Active** or **Not Active**. **Unknown** if no data is delivered         |\n+| Charging Status           | status           | charge              | String        | Only available for PHEV, BEV_REX and BEV                                          |\n+| Last Status Timestamp     | status           | last-update         | DateTime      | Date and Time of last status update.                                              |\n+\n+See [further details for DateTime](#last-status-update-timestamp) in case of wrong timestamp values\n+\n+#### Services\n+\n+Group for all upcoming Services with Description, Service Date and / or Service Mileage\n+It's designed as [List Interface](#list-interface) so all upcoming Services can be checked.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTExOTc0Mw=="}, "originalCommit": {"oid": "e0bfe93e13df4a3c5de5f8819b94ebf795664904"}, "originalPosition": 165}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEzNzgyMzcwOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.bmwconnecteddrive/README.md", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wN1QxNTo1MzoyOVrOHd6Mpw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yNFQxNDoyNToxM1rOILIesw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTEyNDI2Mw==", "bodyText": "You could use the Channel Type Location.", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r501124263", "createdAt": "2020-10-07T15:53:29Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/README.md", "diffHunk": "@@ -0,0 +1,862 @@\n+# BMW ConnectedDrive Binding\n+\n+<img align=\"right\" src=\"./doc/bmw-connected.png\" width=\"150\" height=\"150\"/>\n+\n+The Binding provides a Connection between [BMWs ConnectedDrive Portal](https://www.bmw-connecteddrive.com/country-region-select/country-region-selection.html) and openHAB.\n+All Vehicles connected to an Account will be detected by the Discovery with the correct type \n+\n+* Conventional Fuel Vehicle\n+* Plugin-Hybrid Electrical Vehicle \n+* Battery Electric Vehicle with Range Extender\n+* Battery Electric Vehicle \n+\n+In addition Properties are attached with Information and Services provided by this Vehicle.\n+The provided data depends on \n+\n+1. the [Type](#Things) and \n+2. the Services mentioned in [Properties](#properties)\n+\n+Different Channel Groups are clustering all informations.\n+Check for each Group if it's supported for this Vehicle.\n+\n+Please note **this isn't a real-time Binding**. \n+If the Door is opened the state isn't transmitted and changed immediately. \n+This isn't a flaw in the Binding itself because the state in BMWs own ConnectedDrive App is also updated with some delay. \n+\n+## Supported Things\n+\n+### Bridge\n+\n+The Bridge establishes the Connection between BMW ConnectedDrive Portal and openHAB.\n+\n+| Name                       | Bridge Type ID | Description                                                |\n+|----------------------------|----------------|------------------------------------------------------------|\n+| BMW ConnectedDrive Account | account        | Access to BMW ConnectedDrive Portal for a specific user    |\n+\n+\n+### Things\n+\n+Four different Vehicle Types are provided. \n+They differ in the supported Channel Groups & Channels. \n+Conventional Fuel Vehicles have no _Charging Profile_, Electric Vehicles don't provide a _Fuel Range_. \n+For Hybrid Vehicles in addition to _Fuel and Electric Range_ the _Hybrid Range_ is shown.\n+ \n+| Name                                | Thing Type ID | Supported Channel Groups                                             |\n+|-------------------------------------|---------------|----------------------------------------------------------------------|\n+| BMW Electric Vehicle                | BEV           | status, range, location, service, check, charge, image, troubleshoot |\n+| BMW Electric Vehicle with REX       | BEV_REX       | status, range, location, service, check, charge, image, troubleshoot |\n+| BMW Plug-In-Hybrid Electric Vehicle | PHEV          | status, range, location, service, check, charge, image, troubleshoot |\n+| BMW Conventional Vehicle            | CONV          | status, range, location, service, check, image, troubleshoot         |\n+\n+ \n+#### Properties\n+\n+<img align=\"right\" src=\"./doc/properties.png\" width=\"500\" height=\"600\"/>\n+\n+For each Vehicle Properties are available. \n+Basically 3 Types of Information are registered as Properties\n+\n+* Informations regarding your Dealer with Address and Phone Number\n+* Which services are available / not available\n+* Vehicle Properties like Color, Model Type, Drive Train and Construction Year\n+\n+In the right picture  can see in *Services Activated* e.g. the *DoorLock* and *DoorUnlock* Services are mentioned. \n+This ensures [Channel Group _Remote Services_](#remote-services) is supporting Door lock and Door unlock.\n+\n+In  *Services Supported* the entry *LastDestination* is mentioned.\n+So it's valid to connect Channel Group [Last Destinations](#destinations) in order to display the last 3 Navigation Destinations.\n+\n+| Property Key       | Property Value      |  Supported Channel Groups    |\n+|--------------------|---------------------|------------------------------|\n+| Services Supported | Statistics          | last-trip, lifetime          |\n+| Services Supported | LastDestinations    | destinations                 |\n+| Services Activated | list of services    | remote                       |\n+\n+\n+## Discovery\n+\n+Auto Discovery is starting after creation of the Bridge towards BMW ConnectedDrive. \n+A list of your registered Vehicles is queried and all found Vehicles are added in Inbox.\n+Unique Identifier is the *Vehicle Identification Number* (VIN). \n+If a Thing is already declared in a  *.things configuration* Discovery won't highlight it again.\n+Properties will be attached to predefined Vehicles if the VIN is matching.\n+\n+## Configuration\n+\n+### Bridge\n+\n+| Parameter       | Type    | Description                                                             |           \n+|-----------------|---------|-------------------------------------------------------------------------|\n+| userName        | text    | BMW Connected Drive Username                  |\n+| password        | text    | BMW Connected Drive Password                  |\n+| region          | text    | Select Region in order to connect to the appropriate BMW Server.   |\n+\n+The region Configuration has 3 different possibilities\n+\n+* _NORTH_AMERICA_\n+* _CHINA_\n+* _ROW_ for Rest of World\n+\n+### Thing\n+\n+Same Configuration is needed for all Things\n+\n+| Parameter       | Type    | Description                           |           \n+|-----------------|---------|---------------------------------------|\n+| vin             | text    | Vehicle Identification Number (VIN)   |\n+| refreshInterval | integer | Refresh Interval in Minutes           |\n+| units           | text    | Unit Selection                        |\n+| imageSize       | integer | Image Size                            |\n+| imageViewport   | text    | Image Viewport                        |\n+\n+The units can be configured in 3 ways\n+\n+* _AUTODETECT_ selects Miles for US & UK, Kilometer otherwise\n+* _METRIC_ selects directly Kilometers\n+* _IMPERIAL_ selects directly Miles\n+\n+The imageVieport allows to show the Vehicle from different angels.\n+Possible values are \n+\n+* FRONT\n+* REAR\n+* SIDE\n+* DASHBOARD\n+* DRIVERDOOR\n+\n+## Channels\n+\n+There are many Channels available for each Vehicle. \n+For better overview they are clustered in different Channel Groups.\n+The Channel Groups are different for the Vehicle Types, on the build-in Sensors of the Vehicle and the activated Services.\n+\n+### Bridge Channels\n+\n+If the Vehicle isn't found in the Discovery force a log of Fingerprint Data which helps to analyze the problem.\n+Please check [TroubleShooting Section](#TroubleShooting) for further advice.\n+\n+| Channel Label         | Channel ID            | Type   | Description                                       |\n+|-----------------------|-----------------------|--------|---------------------------------------------------|\n+| Discovery Fingerprint | discovery-fingerprint | Switch | Forcing a log entry to analyze Discovery Problems |\n+\n+### Thing Channel Groups \n+\n+#### Vehicle Status\n+\n+Reflects Status of the Vehicle.\n+Available for all Vehicles, Read-only.\n+\n+| Channel Label             | Channel Group ID | Channel ID          | Type          | Description                                                                       |\n+|---------------------------|------------------|---------------------|---------------|-----------------------------------------------------------------------------------|\n+| Overall Door Status       | status           | doors               | String        | **Closed** if all closed otherwise **Open**. **Unknown** if no data is delivered  |\n+| Overall Window Status     | status           | windows             | String        | **Closed** if all closed otherwise **Open** or **Intermediate**. **Unknown** if no data is delivered   |\n+| Doors Locked              | status           | lock                | String        | Status if Doors are locked or unlocked                                            |\n+| Next Service Date         | status           | service-date        | DateTime      | Date of Upcoming Service                                                          |\n+| Mileage till Next Service | status           | service-mileage     | Number:Length | Mileage till Upcoming Service                                                     |\n+| Check Control             | status           | check-control       | String        | Indicator if CheckControl is **Active** or **Not Active**. **Unknown** if no data is delivered         |\n+| Charging Status           | status           | charge              | String        | Only available for PHEV, BEV_REX and BEV                                          |\n+| Last Status Timestamp     | status           | last-update         | DateTime      | Date and Time of last status update.                                              |\n+\n+See [further details for DateTime](#last-status-update-timestamp) in case of wrong timestamp values\n+\n+#### Services\n+\n+Group for all upcoming Services with Description, Service Date and / or Service Mileage\n+It's designed as [List Interface](#list-interface) so all upcoming Services can be checked.\n+\n+| Channel Label                  | Channel Group ID | Channel ID          | Type           | \n+|--------------------------------|------------------|---------------------|----------------|\n+| Service Name                   | service          | name                | String         |\n+| Service Date                   | service          | date                | Number         |\n+| Mileage till Service           | service          | mileage             | Number:Length  |\n+| Number of Scheduled Services   | service          | size                | String         |\n+| Current Selected Service Index | service          | index               | Number         |\n+| Select next Service            | service          | next                | Switch         |\n+\n+#### Check Control\n+\n+Group for all current active CheckControl Messages.\n+It's designed as [List Interface](#list-interface) to show all active Messages.\n+\n+| Channel Label                   | Channel Group ID | Channel ID          | Type           | \n+|---------------------------------|------------------|---------------------|----------------|\n+| CheckControl Description        | check            | name                | String         |\n+| CheckControl Mileage Occurrence | check            | mileage             | Number:Length  |\n+| Active CheckControl Messages    | check            | size                | String         |\n+| Selected CheckControl Message   | check            | index               | Number         |\n+| Next CheckControl Message       | check            | next                | Switch         |\n+\n+#### Doors Details\n+\n+Detailed Status of all Doors and Windows\n+Available for all Vehicles, Read-only. \n+\n+| Channel Label              | Channel Group ID | Channel ID              | Type          | \n+|----------------------------|------------------|-------------------------|---------------|\n+| Driver Door                | doors            | driver-front            | String        |\n+| Driver Door Rear           | doors            | driver-rear             | String        |\n+| Passenger Door             | doors            | passenger-front         | String        |\n+| Passenger Door Rear        | doors            | passenger-rear          | String        |\n+| Trunk                      | doors            | trunk                   | String        |\n+| Hood                       | doors            | hood                    | String        |\n+| Driver Door Window         | doors            | window-driver-front     | String        |\n+| Driver Door Rear Window    | doors            | window-driver-rear      | String        |\n+| Passenger Door Window      | doors            | window-passenger-front  | String        |\n+| Passenger Door Rear Window | doors            | window-passenger-rear   | String        |\n+| Rear Window                | doors            | window-rear             | String        |\n+| Sunroof                    | doors            | sunroof                 | String        |\n+\n+Following Strings will be delivered\n+\n+* UNKNOWN - no status data available\n+* INVALID - this item isn't applicable for this Vehicle\n+* CLOSED - the Door / Window is closed\n+* OPEN - the Door / Window is open\n+* INTERMEDIATE - Window in intermediate position, not applicable for Doors\n+\n+#### Range Data\n+\n+Based on Vehicle Type (Thing Type ID) some Channels are presented or not. \n+Conventional Fuel Vehicles don't provide *Electric Range* and Battery Electric Vehicles don't show *Range Fuel*.\n+Hybrid Vehicles have both and in addition *Hybrid Range*.\n+These are Read-only values.\n+\n+| Channel Label         | Channel Group ID | Channel ID            | Type                 | CONV | PHEV | BEV_REX | BEV |\n+|-----------------------|------------------|-----------------------|----------------------|------|------|---------|-----|\n+| Mileage               | range            | mileage               | Number:Length        |  X   |  X   |    X    |  X  |\n+| Fuel Range            | range            | range-fuel            | Number:Length        |  X   |  X   |    X    |     |\n+| Battery Range         | range            | range-electric        | Number:Length        |      |  X   |    X    |  X  | \n+| Hybrid Range          | range            | range-hybrid          | Number:Length        |      |  X   |    X    |     | \n+| Battery Charge Level  | range            | soc                   | Number:Dimensionless |      |  X   |    X    |  X  |\n+| Remaining Fuel        | range            | remaining-fuel        | Number:Volume        |  X   |  X   |    X    |     | \n+| Fuel Range Radius     | range            | range-radius-fuel     | Number:Length        |  X   |  X   |    X    |     | \n+| Electric Range Radius | range            | range-radius-electric | Number:Length        |      |  X   |    X    |  X  | \n+| Hybrid Range Radius   | range            | range-radius-hybrid   | Number:Length        |      |  X   |    X    |     | \n+\n+See Description [Range vs Range Radius](#range-vs-range-radius) to get more information\n+\n+#### Charge Profile\n+\n+Valid for Electric and Hybrid Vehicles\n+These are Read-only values.\n+\n+| Channel Label                      | Channel Group ID | Channel ID          | Type   | \n+|------------------------------------|------------------|---------------------|--------|\n+| Air Conditioning at Departure Time | charge           | profile-climate     | Switch | \n+| Charging Mode for Profile          | charge           | profile-mode        | String | \n+| Charging Window Start Time         | charge           | window-start        | String | \n+| Charging Window End Time           | charge           | window-end          | String | \n+| Timer 1: Departure Time            | charge           | timer1-departure    | String | \n+| Timer 1: Scheduled Days            | charge           | timer1-days         | String | \n+| Timer 1: Enabled                   | charge           | timer1-enabled      | Switch | \n+| Timer 2: Departure Time            | charge           | timer2-departure    | String | \n+| Timer 2: Scheduled Days            | charge           | timer2-days         | String | \n+| Timer 2: Enabled                   | charge           | timer2-enabled      | Switch | \n+| Timer 3: Departure Time            | charge           | timer3-departure    | String | \n+| Timer 3: Scheduled Days            | charge           | timer3-days         | String | \n+| Timer 3: Enabled                   | charge           | timer3-enabled      | Switch | \n+\n+\n+#### Location\n+\n+Available for all Vehicles.\n+These are Read-only values.\n+\n+| Channel Label  | Channel Group ID | Channel ID          | Type         | \n+|----------------|------------------|---------------------|--------------|\n+| Latitude       | location         | latitude            | Number       | \n+| Longitude      | location         | longitude           | Number       |", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e0bfe93e13df4a3c5de5f8819b94ebf795664904"}, "originalPosition": 268}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTcyMjc3Nw==", "bodyText": "Yes, I missed this type. Change applied.", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r529722777", "createdAt": "2020-11-24T16:45:12Z", "author": {"login": "weymann"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/README.md", "diffHunk": "@@ -0,0 +1,862 @@\n+# BMW ConnectedDrive Binding\n+\n+<img align=\"right\" src=\"./doc/bmw-connected.png\" width=\"150\" height=\"150\"/>\n+\n+The Binding provides a Connection between [BMWs ConnectedDrive Portal](https://www.bmw-connecteddrive.com/country-region-select/country-region-selection.html) and openHAB.\n+All Vehicles connected to an Account will be detected by the Discovery with the correct type \n+\n+* Conventional Fuel Vehicle\n+* Plugin-Hybrid Electrical Vehicle \n+* Battery Electric Vehicle with Range Extender\n+* Battery Electric Vehicle \n+\n+In addition Properties are attached with Information and Services provided by this Vehicle.\n+The provided data depends on \n+\n+1. the [Type](#Things) and \n+2. the Services mentioned in [Properties](#properties)\n+\n+Different Channel Groups are clustering all informations.\n+Check for each Group if it's supported for this Vehicle.\n+\n+Please note **this isn't a real-time Binding**. \n+If the Door is opened the state isn't transmitted and changed immediately. \n+This isn't a flaw in the Binding itself because the state in BMWs own ConnectedDrive App is also updated with some delay. \n+\n+## Supported Things\n+\n+### Bridge\n+\n+The Bridge establishes the Connection between BMW ConnectedDrive Portal and openHAB.\n+\n+| Name                       | Bridge Type ID | Description                                                |\n+|----------------------------|----------------|------------------------------------------------------------|\n+| BMW ConnectedDrive Account | account        | Access to BMW ConnectedDrive Portal for a specific user    |\n+\n+\n+### Things\n+\n+Four different Vehicle Types are provided. \n+They differ in the supported Channel Groups & Channels. \n+Conventional Fuel Vehicles have no _Charging Profile_, Electric Vehicles don't provide a _Fuel Range_. \n+For Hybrid Vehicles in addition to _Fuel and Electric Range_ the _Hybrid Range_ is shown.\n+ \n+| Name                                | Thing Type ID | Supported Channel Groups                                             |\n+|-------------------------------------|---------------|----------------------------------------------------------------------|\n+| BMW Electric Vehicle                | BEV           | status, range, location, service, check, charge, image, troubleshoot |\n+| BMW Electric Vehicle with REX       | BEV_REX       | status, range, location, service, check, charge, image, troubleshoot |\n+| BMW Plug-In-Hybrid Electric Vehicle | PHEV          | status, range, location, service, check, charge, image, troubleshoot |\n+| BMW Conventional Vehicle            | CONV          | status, range, location, service, check, image, troubleshoot         |\n+\n+ \n+#### Properties\n+\n+<img align=\"right\" src=\"./doc/properties.png\" width=\"500\" height=\"600\"/>\n+\n+For each Vehicle Properties are available. \n+Basically 3 Types of Information are registered as Properties\n+\n+* Informations regarding your Dealer with Address and Phone Number\n+* Which services are available / not available\n+* Vehicle Properties like Color, Model Type, Drive Train and Construction Year\n+\n+In the right picture  can see in *Services Activated* e.g. the *DoorLock* and *DoorUnlock* Services are mentioned. \n+This ensures [Channel Group _Remote Services_](#remote-services) is supporting Door lock and Door unlock.\n+\n+In  *Services Supported* the entry *LastDestination* is mentioned.\n+So it's valid to connect Channel Group [Last Destinations](#destinations) in order to display the last 3 Navigation Destinations.\n+\n+| Property Key       | Property Value      |  Supported Channel Groups    |\n+|--------------------|---------------------|------------------------------|\n+| Services Supported | Statistics          | last-trip, lifetime          |\n+| Services Supported | LastDestinations    | destinations                 |\n+| Services Activated | list of services    | remote                       |\n+\n+\n+## Discovery\n+\n+Auto Discovery is starting after creation of the Bridge towards BMW ConnectedDrive. \n+A list of your registered Vehicles is queried and all found Vehicles are added in Inbox.\n+Unique Identifier is the *Vehicle Identification Number* (VIN). \n+If a Thing is already declared in a  *.things configuration* Discovery won't highlight it again.\n+Properties will be attached to predefined Vehicles if the VIN is matching.\n+\n+## Configuration\n+\n+### Bridge\n+\n+| Parameter       | Type    | Description                                                             |           \n+|-----------------|---------|-------------------------------------------------------------------------|\n+| userName        | text    | BMW Connected Drive Username                  |\n+| password        | text    | BMW Connected Drive Password                  |\n+| region          | text    | Select Region in order to connect to the appropriate BMW Server.   |\n+\n+The region Configuration has 3 different possibilities\n+\n+* _NORTH_AMERICA_\n+* _CHINA_\n+* _ROW_ for Rest of World\n+\n+### Thing\n+\n+Same Configuration is needed for all Things\n+\n+| Parameter       | Type    | Description                           |           \n+|-----------------|---------|---------------------------------------|\n+| vin             | text    | Vehicle Identification Number (VIN)   |\n+| refreshInterval | integer | Refresh Interval in Minutes           |\n+| units           | text    | Unit Selection                        |\n+| imageSize       | integer | Image Size                            |\n+| imageViewport   | text    | Image Viewport                        |\n+\n+The units can be configured in 3 ways\n+\n+* _AUTODETECT_ selects Miles for US & UK, Kilometer otherwise\n+* _METRIC_ selects directly Kilometers\n+* _IMPERIAL_ selects directly Miles\n+\n+The imageVieport allows to show the Vehicle from different angels.\n+Possible values are \n+\n+* FRONT\n+* REAR\n+* SIDE\n+* DASHBOARD\n+* DRIVERDOOR\n+\n+## Channels\n+\n+There are many Channels available for each Vehicle. \n+For better overview they are clustered in different Channel Groups.\n+The Channel Groups are different for the Vehicle Types, on the build-in Sensors of the Vehicle and the activated Services.\n+\n+### Bridge Channels\n+\n+If the Vehicle isn't found in the Discovery force a log of Fingerprint Data which helps to analyze the problem.\n+Please check [TroubleShooting Section](#TroubleShooting) for further advice.\n+\n+| Channel Label         | Channel ID            | Type   | Description                                       |\n+|-----------------------|-----------------------|--------|---------------------------------------------------|\n+| Discovery Fingerprint | discovery-fingerprint | Switch | Forcing a log entry to analyze Discovery Problems |\n+\n+### Thing Channel Groups \n+\n+#### Vehicle Status\n+\n+Reflects Status of the Vehicle.\n+Available for all Vehicles, Read-only.\n+\n+| Channel Label             | Channel Group ID | Channel ID          | Type          | Description                                                                       |\n+|---------------------------|------------------|---------------------|---------------|-----------------------------------------------------------------------------------|\n+| Overall Door Status       | status           | doors               | String        | **Closed** if all closed otherwise **Open**. **Unknown** if no data is delivered  |\n+| Overall Window Status     | status           | windows             | String        | **Closed** if all closed otherwise **Open** or **Intermediate**. **Unknown** if no data is delivered   |\n+| Doors Locked              | status           | lock                | String        | Status if Doors are locked or unlocked                                            |\n+| Next Service Date         | status           | service-date        | DateTime      | Date of Upcoming Service                                                          |\n+| Mileage till Next Service | status           | service-mileage     | Number:Length | Mileage till Upcoming Service                                                     |\n+| Check Control             | status           | check-control       | String        | Indicator if CheckControl is **Active** or **Not Active**. **Unknown** if no data is delivered         |\n+| Charging Status           | status           | charge              | String        | Only available for PHEV, BEV_REX and BEV                                          |\n+| Last Status Timestamp     | status           | last-update         | DateTime      | Date and Time of last status update.                                              |\n+\n+See [further details for DateTime](#last-status-update-timestamp) in case of wrong timestamp values\n+\n+#### Services\n+\n+Group for all upcoming Services with Description, Service Date and / or Service Mileage\n+It's designed as [List Interface](#list-interface) so all upcoming Services can be checked.\n+\n+| Channel Label                  | Channel Group ID | Channel ID          | Type           | \n+|--------------------------------|------------------|---------------------|----------------|\n+| Service Name                   | service          | name                | String         |\n+| Service Date                   | service          | date                | Number         |\n+| Mileage till Service           | service          | mileage             | Number:Length  |\n+| Number of Scheduled Services   | service          | size                | String         |\n+| Current Selected Service Index | service          | index               | Number         |\n+| Select next Service            | service          | next                | Switch         |\n+\n+#### Check Control\n+\n+Group for all current active CheckControl Messages.\n+It's designed as [List Interface](#list-interface) to show all active Messages.\n+\n+| Channel Label                   | Channel Group ID | Channel ID          | Type           | \n+|---------------------------------|------------------|---------------------|----------------|\n+| CheckControl Description        | check            | name                | String         |\n+| CheckControl Mileage Occurrence | check            | mileage             | Number:Length  |\n+| Active CheckControl Messages    | check            | size                | String         |\n+| Selected CheckControl Message   | check            | index               | Number         |\n+| Next CheckControl Message       | check            | next                | Switch         |\n+\n+#### Doors Details\n+\n+Detailed Status of all Doors and Windows\n+Available for all Vehicles, Read-only. \n+\n+| Channel Label              | Channel Group ID | Channel ID              | Type          | \n+|----------------------------|------------------|-------------------------|---------------|\n+| Driver Door                | doors            | driver-front            | String        |\n+| Driver Door Rear           | doors            | driver-rear             | String        |\n+| Passenger Door             | doors            | passenger-front         | String        |\n+| Passenger Door Rear        | doors            | passenger-rear          | String        |\n+| Trunk                      | doors            | trunk                   | String        |\n+| Hood                       | doors            | hood                    | String        |\n+| Driver Door Window         | doors            | window-driver-front     | String        |\n+| Driver Door Rear Window    | doors            | window-driver-rear      | String        |\n+| Passenger Door Window      | doors            | window-passenger-front  | String        |\n+| Passenger Door Rear Window | doors            | window-passenger-rear   | String        |\n+| Rear Window                | doors            | window-rear             | String        |\n+| Sunroof                    | doors            | sunroof                 | String        |\n+\n+Following Strings will be delivered\n+\n+* UNKNOWN - no status data available\n+* INVALID - this item isn't applicable for this Vehicle\n+* CLOSED - the Door / Window is closed\n+* OPEN - the Door / Window is open\n+* INTERMEDIATE - Window in intermediate position, not applicable for Doors\n+\n+#### Range Data\n+\n+Based on Vehicle Type (Thing Type ID) some Channels are presented or not. \n+Conventional Fuel Vehicles don't provide *Electric Range* and Battery Electric Vehicles don't show *Range Fuel*.\n+Hybrid Vehicles have both and in addition *Hybrid Range*.\n+These are Read-only values.\n+\n+| Channel Label         | Channel Group ID | Channel ID            | Type                 | CONV | PHEV | BEV_REX | BEV |\n+|-----------------------|------------------|-----------------------|----------------------|------|------|---------|-----|\n+| Mileage               | range            | mileage               | Number:Length        |  X   |  X   |    X    |  X  |\n+| Fuel Range            | range            | range-fuel            | Number:Length        |  X   |  X   |    X    |     |\n+| Battery Range         | range            | range-electric        | Number:Length        |      |  X   |    X    |  X  | \n+| Hybrid Range          | range            | range-hybrid          | Number:Length        |      |  X   |    X    |     | \n+| Battery Charge Level  | range            | soc                   | Number:Dimensionless |      |  X   |    X    |  X  |\n+| Remaining Fuel        | range            | remaining-fuel        | Number:Volume        |  X   |  X   |    X    |     | \n+| Fuel Range Radius     | range            | range-radius-fuel     | Number:Length        |  X   |  X   |    X    |     | \n+| Electric Range Radius | range            | range-radius-electric | Number:Length        |      |  X   |    X    |  X  | \n+| Hybrid Range Radius   | range            | range-radius-hybrid   | Number:Length        |      |  X   |    X    |     | \n+\n+See Description [Range vs Range Radius](#range-vs-range-radius) to get more information\n+\n+#### Charge Profile\n+\n+Valid for Electric and Hybrid Vehicles\n+These are Read-only values.\n+\n+| Channel Label                      | Channel Group ID | Channel ID          | Type   | \n+|------------------------------------|------------------|---------------------|--------|\n+| Air Conditioning at Departure Time | charge           | profile-climate     | Switch | \n+| Charging Mode for Profile          | charge           | profile-mode        | String | \n+| Charging Window Start Time         | charge           | window-start        | String | \n+| Charging Window End Time           | charge           | window-end          | String | \n+| Timer 1: Departure Time            | charge           | timer1-departure    | String | \n+| Timer 1: Scheduled Days            | charge           | timer1-days         | String | \n+| Timer 1: Enabled                   | charge           | timer1-enabled      | Switch | \n+| Timer 2: Departure Time            | charge           | timer2-departure    | String | \n+| Timer 2: Scheduled Days            | charge           | timer2-days         | String | \n+| Timer 2: Enabled                   | charge           | timer2-enabled      | Switch | \n+| Timer 3: Departure Time            | charge           | timer3-departure    | String | \n+| Timer 3: Scheduled Days            | charge           | timer3-days         | String | \n+| Timer 3: Enabled                   | charge           | timer3-enabled      | Switch | \n+\n+\n+#### Location\n+\n+Available for all Vehicles.\n+These are Read-only values.\n+\n+| Channel Label  | Channel Group ID | Channel ID          | Type         | \n+|----------------|------------------|---------------------|--------------|\n+| Latitude       | location         | latitude            | Number       | \n+| Longitude      | location         | longitude           | Number       |", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTEyNDI2Mw=="}, "originalCommit": {"oid": "e0bfe93e13df4a3c5de5f8819b94ebf795664904"}, "originalPosition": 268}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTg1MzI0OQ==", "bodyText": "But the readme still talks about \"number\" types here?", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r529853249", "createdAt": "2020-11-24T20:18:59Z", "author": {"login": "kaikreuzer"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/README.md", "diffHunk": "@@ -0,0 +1,862 @@\n+# BMW ConnectedDrive Binding\n+\n+<img align=\"right\" src=\"./doc/bmw-connected.png\" width=\"150\" height=\"150\"/>\n+\n+The Binding provides a Connection between [BMWs ConnectedDrive Portal](https://www.bmw-connecteddrive.com/country-region-select/country-region-selection.html) and openHAB.\n+All Vehicles connected to an Account will be detected by the Discovery with the correct type \n+\n+* Conventional Fuel Vehicle\n+* Plugin-Hybrid Electrical Vehicle \n+* Battery Electric Vehicle with Range Extender\n+* Battery Electric Vehicle \n+\n+In addition Properties are attached with Information and Services provided by this Vehicle.\n+The provided data depends on \n+\n+1. the [Type](#Things) and \n+2. the Services mentioned in [Properties](#properties)\n+\n+Different Channel Groups are clustering all informations.\n+Check for each Group if it's supported for this Vehicle.\n+\n+Please note **this isn't a real-time Binding**. \n+If the Door is opened the state isn't transmitted and changed immediately. \n+This isn't a flaw in the Binding itself because the state in BMWs own ConnectedDrive App is also updated with some delay. \n+\n+## Supported Things\n+\n+### Bridge\n+\n+The Bridge establishes the Connection between BMW ConnectedDrive Portal and openHAB.\n+\n+| Name                       | Bridge Type ID | Description                                                |\n+|----------------------------|----------------|------------------------------------------------------------|\n+| BMW ConnectedDrive Account | account        | Access to BMW ConnectedDrive Portal for a specific user    |\n+\n+\n+### Things\n+\n+Four different Vehicle Types are provided. \n+They differ in the supported Channel Groups & Channels. \n+Conventional Fuel Vehicles have no _Charging Profile_, Electric Vehicles don't provide a _Fuel Range_. \n+For Hybrid Vehicles in addition to _Fuel and Electric Range_ the _Hybrid Range_ is shown.\n+ \n+| Name                                | Thing Type ID | Supported Channel Groups                                             |\n+|-------------------------------------|---------------|----------------------------------------------------------------------|\n+| BMW Electric Vehicle                | BEV           | status, range, location, service, check, charge, image, troubleshoot |\n+| BMW Electric Vehicle with REX       | BEV_REX       | status, range, location, service, check, charge, image, troubleshoot |\n+| BMW Plug-In-Hybrid Electric Vehicle | PHEV          | status, range, location, service, check, charge, image, troubleshoot |\n+| BMW Conventional Vehicle            | CONV          | status, range, location, service, check, image, troubleshoot         |\n+\n+ \n+#### Properties\n+\n+<img align=\"right\" src=\"./doc/properties.png\" width=\"500\" height=\"600\"/>\n+\n+For each Vehicle Properties are available. \n+Basically 3 Types of Information are registered as Properties\n+\n+* Informations regarding your Dealer with Address and Phone Number\n+* Which services are available / not available\n+* Vehicle Properties like Color, Model Type, Drive Train and Construction Year\n+\n+In the right picture  can see in *Services Activated* e.g. the *DoorLock* and *DoorUnlock* Services are mentioned. \n+This ensures [Channel Group _Remote Services_](#remote-services) is supporting Door lock and Door unlock.\n+\n+In  *Services Supported* the entry *LastDestination* is mentioned.\n+So it's valid to connect Channel Group [Last Destinations](#destinations) in order to display the last 3 Navigation Destinations.\n+\n+| Property Key       | Property Value      |  Supported Channel Groups    |\n+|--------------------|---------------------|------------------------------|\n+| Services Supported | Statistics          | last-trip, lifetime          |\n+| Services Supported | LastDestinations    | destinations                 |\n+| Services Activated | list of services    | remote                       |\n+\n+\n+## Discovery\n+\n+Auto Discovery is starting after creation of the Bridge towards BMW ConnectedDrive. \n+A list of your registered Vehicles is queried and all found Vehicles are added in Inbox.\n+Unique Identifier is the *Vehicle Identification Number* (VIN). \n+If a Thing is already declared in a  *.things configuration* Discovery won't highlight it again.\n+Properties will be attached to predefined Vehicles if the VIN is matching.\n+\n+## Configuration\n+\n+### Bridge\n+\n+| Parameter       | Type    | Description                                                             |           \n+|-----------------|---------|-------------------------------------------------------------------------|\n+| userName        | text    | BMW Connected Drive Username                  |\n+| password        | text    | BMW Connected Drive Password                  |\n+| region          | text    | Select Region in order to connect to the appropriate BMW Server.   |\n+\n+The region Configuration has 3 different possibilities\n+\n+* _NORTH_AMERICA_\n+* _CHINA_\n+* _ROW_ for Rest of World\n+\n+### Thing\n+\n+Same Configuration is needed for all Things\n+\n+| Parameter       | Type    | Description                           |           \n+|-----------------|---------|---------------------------------------|\n+| vin             | text    | Vehicle Identification Number (VIN)   |\n+| refreshInterval | integer | Refresh Interval in Minutes           |\n+| units           | text    | Unit Selection                        |\n+| imageSize       | integer | Image Size                            |\n+| imageViewport   | text    | Image Viewport                        |\n+\n+The units can be configured in 3 ways\n+\n+* _AUTODETECT_ selects Miles for US & UK, Kilometer otherwise\n+* _METRIC_ selects directly Kilometers\n+* _IMPERIAL_ selects directly Miles\n+\n+The imageVieport allows to show the Vehicle from different angels.\n+Possible values are \n+\n+* FRONT\n+* REAR\n+* SIDE\n+* DASHBOARD\n+* DRIVERDOOR\n+\n+## Channels\n+\n+There are many Channels available for each Vehicle. \n+For better overview they are clustered in different Channel Groups.\n+The Channel Groups are different for the Vehicle Types, on the build-in Sensors of the Vehicle and the activated Services.\n+\n+### Bridge Channels\n+\n+If the Vehicle isn't found in the Discovery force a log of Fingerprint Data which helps to analyze the problem.\n+Please check [TroubleShooting Section](#TroubleShooting) for further advice.\n+\n+| Channel Label         | Channel ID            | Type   | Description                                       |\n+|-----------------------|-----------------------|--------|---------------------------------------------------|\n+| Discovery Fingerprint | discovery-fingerprint | Switch | Forcing a log entry to analyze Discovery Problems |\n+\n+### Thing Channel Groups \n+\n+#### Vehicle Status\n+\n+Reflects Status of the Vehicle.\n+Available for all Vehicles, Read-only.\n+\n+| Channel Label             | Channel Group ID | Channel ID          | Type          | Description                                                                       |\n+|---------------------------|------------------|---------------------|---------------|-----------------------------------------------------------------------------------|\n+| Overall Door Status       | status           | doors               | String        | **Closed** if all closed otherwise **Open**. **Unknown** if no data is delivered  |\n+| Overall Window Status     | status           | windows             | String        | **Closed** if all closed otherwise **Open** or **Intermediate**. **Unknown** if no data is delivered   |\n+| Doors Locked              | status           | lock                | String        | Status if Doors are locked or unlocked                                            |\n+| Next Service Date         | status           | service-date        | DateTime      | Date of Upcoming Service                                                          |\n+| Mileage till Next Service | status           | service-mileage     | Number:Length | Mileage till Upcoming Service                                                     |\n+| Check Control             | status           | check-control       | String        | Indicator if CheckControl is **Active** or **Not Active**. **Unknown** if no data is delivered         |\n+| Charging Status           | status           | charge              | String        | Only available for PHEV, BEV_REX and BEV                                          |\n+| Last Status Timestamp     | status           | last-update         | DateTime      | Date and Time of last status update.                                              |\n+\n+See [further details for DateTime](#last-status-update-timestamp) in case of wrong timestamp values\n+\n+#### Services\n+\n+Group for all upcoming Services with Description, Service Date and / or Service Mileage\n+It's designed as [List Interface](#list-interface) so all upcoming Services can be checked.\n+\n+| Channel Label                  | Channel Group ID | Channel ID          | Type           | \n+|--------------------------------|------------------|---------------------|----------------|\n+| Service Name                   | service          | name                | String         |\n+| Service Date                   | service          | date                | Number         |\n+| Mileage till Service           | service          | mileage             | Number:Length  |\n+| Number of Scheduled Services   | service          | size                | String         |\n+| Current Selected Service Index | service          | index               | Number         |\n+| Select next Service            | service          | next                | Switch         |\n+\n+#### Check Control\n+\n+Group for all current active CheckControl Messages.\n+It's designed as [List Interface](#list-interface) to show all active Messages.\n+\n+| Channel Label                   | Channel Group ID | Channel ID          | Type           | \n+|---------------------------------|------------------|---------------------|----------------|\n+| CheckControl Description        | check            | name                | String         |\n+| CheckControl Mileage Occurrence | check            | mileage             | Number:Length  |\n+| Active CheckControl Messages    | check            | size                | String         |\n+| Selected CheckControl Message   | check            | index               | Number         |\n+| Next CheckControl Message       | check            | next                | Switch         |\n+\n+#### Doors Details\n+\n+Detailed Status of all Doors and Windows\n+Available for all Vehicles, Read-only. \n+\n+| Channel Label              | Channel Group ID | Channel ID              | Type          | \n+|----------------------------|------------------|-------------------------|---------------|\n+| Driver Door                | doors            | driver-front            | String        |\n+| Driver Door Rear           | doors            | driver-rear             | String        |\n+| Passenger Door             | doors            | passenger-front         | String        |\n+| Passenger Door Rear        | doors            | passenger-rear          | String        |\n+| Trunk                      | doors            | trunk                   | String        |\n+| Hood                       | doors            | hood                    | String        |\n+| Driver Door Window         | doors            | window-driver-front     | String        |\n+| Driver Door Rear Window    | doors            | window-driver-rear      | String        |\n+| Passenger Door Window      | doors            | window-passenger-front  | String        |\n+| Passenger Door Rear Window | doors            | window-passenger-rear   | String        |\n+| Rear Window                | doors            | window-rear             | String        |\n+| Sunroof                    | doors            | sunroof                 | String        |\n+\n+Following Strings will be delivered\n+\n+* UNKNOWN - no status data available\n+* INVALID - this item isn't applicable for this Vehicle\n+* CLOSED - the Door / Window is closed\n+* OPEN - the Door / Window is open\n+* INTERMEDIATE - Window in intermediate position, not applicable for Doors\n+\n+#### Range Data\n+\n+Based on Vehicle Type (Thing Type ID) some Channels are presented or not. \n+Conventional Fuel Vehicles don't provide *Electric Range* and Battery Electric Vehicles don't show *Range Fuel*.\n+Hybrid Vehicles have both and in addition *Hybrid Range*.\n+These are Read-only values.\n+\n+| Channel Label         | Channel Group ID | Channel ID            | Type                 | CONV | PHEV | BEV_REX | BEV |\n+|-----------------------|------------------|-----------------------|----------------------|------|------|---------|-----|\n+| Mileage               | range            | mileage               | Number:Length        |  X   |  X   |    X    |  X  |\n+| Fuel Range            | range            | range-fuel            | Number:Length        |  X   |  X   |    X    |     |\n+| Battery Range         | range            | range-electric        | Number:Length        |      |  X   |    X    |  X  | \n+| Hybrid Range          | range            | range-hybrid          | Number:Length        |      |  X   |    X    |     | \n+| Battery Charge Level  | range            | soc                   | Number:Dimensionless |      |  X   |    X    |  X  |\n+| Remaining Fuel        | range            | remaining-fuel        | Number:Volume        |  X   |  X   |    X    |     | \n+| Fuel Range Radius     | range            | range-radius-fuel     | Number:Length        |  X   |  X   |    X    |     | \n+| Electric Range Radius | range            | range-radius-electric | Number:Length        |      |  X   |    X    |  X  | \n+| Hybrid Range Radius   | range            | range-radius-hybrid   | Number:Length        |      |  X   |    X    |     | \n+\n+See Description [Range vs Range Radius](#range-vs-range-radius) to get more information\n+\n+#### Charge Profile\n+\n+Valid for Electric and Hybrid Vehicles\n+These are Read-only values.\n+\n+| Channel Label                      | Channel Group ID | Channel ID          | Type   | \n+|------------------------------------|------------------|---------------------|--------|\n+| Air Conditioning at Departure Time | charge           | profile-climate     | Switch | \n+| Charging Mode for Profile          | charge           | profile-mode        | String | \n+| Charging Window Start Time         | charge           | window-start        | String | \n+| Charging Window End Time           | charge           | window-end          | String | \n+| Timer 1: Departure Time            | charge           | timer1-departure    | String | \n+| Timer 1: Scheduled Days            | charge           | timer1-days         | String | \n+| Timer 1: Enabled                   | charge           | timer1-enabled      | Switch | \n+| Timer 2: Departure Time            | charge           | timer2-departure    | String | \n+| Timer 2: Scheduled Days            | charge           | timer2-days         | String | \n+| Timer 2: Enabled                   | charge           | timer2-enabled      | Switch | \n+| Timer 3: Departure Time            | charge           | timer3-departure    | String | \n+| Timer 3: Scheduled Days            | charge           | timer3-days         | String | \n+| Timer 3: Enabled                   | charge           | timer3-enabled      | Switch | \n+\n+\n+#### Location\n+\n+Available for all Vehicles.\n+These are Read-only values.\n+\n+| Channel Label  | Channel Group ID | Channel ID          | Type         | \n+|----------------|------------------|---------------------|--------------|\n+| Latitude       | location         | latitude            | Number       | \n+| Longitude      | location         | longitude           | Number       |", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTEyNDI2Mw=="}, "originalCommit": {"oid": "e0bfe93e13df4a3c5de5f8819b94ebf795664904"}, "originalPosition": 268}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODU0NDE3OQ==", "bodyText": "Commit is done, push still pending.", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r548544179", "createdAt": "2020-12-24T14:25:13Z", "author": {"login": "weymann"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/README.md", "diffHunk": "@@ -0,0 +1,862 @@\n+# BMW ConnectedDrive Binding\n+\n+<img align=\"right\" src=\"./doc/bmw-connected.png\" width=\"150\" height=\"150\"/>\n+\n+The Binding provides a Connection between [BMWs ConnectedDrive Portal](https://www.bmw-connecteddrive.com/country-region-select/country-region-selection.html) and openHAB.\n+All Vehicles connected to an Account will be detected by the Discovery with the correct type \n+\n+* Conventional Fuel Vehicle\n+* Plugin-Hybrid Electrical Vehicle \n+* Battery Electric Vehicle with Range Extender\n+* Battery Electric Vehicle \n+\n+In addition Properties are attached with Information and Services provided by this Vehicle.\n+The provided data depends on \n+\n+1. the [Type](#Things) and \n+2. the Services mentioned in [Properties](#properties)\n+\n+Different Channel Groups are clustering all informations.\n+Check for each Group if it's supported for this Vehicle.\n+\n+Please note **this isn't a real-time Binding**. \n+If the Door is opened the state isn't transmitted and changed immediately. \n+This isn't a flaw in the Binding itself because the state in BMWs own ConnectedDrive App is also updated with some delay. \n+\n+## Supported Things\n+\n+### Bridge\n+\n+The Bridge establishes the Connection between BMW ConnectedDrive Portal and openHAB.\n+\n+| Name                       | Bridge Type ID | Description                                                |\n+|----------------------------|----------------|------------------------------------------------------------|\n+| BMW ConnectedDrive Account | account        | Access to BMW ConnectedDrive Portal for a specific user    |\n+\n+\n+### Things\n+\n+Four different Vehicle Types are provided. \n+They differ in the supported Channel Groups & Channels. \n+Conventional Fuel Vehicles have no _Charging Profile_, Electric Vehicles don't provide a _Fuel Range_. \n+For Hybrid Vehicles in addition to _Fuel and Electric Range_ the _Hybrid Range_ is shown.\n+ \n+| Name                                | Thing Type ID | Supported Channel Groups                                             |\n+|-------------------------------------|---------------|----------------------------------------------------------------------|\n+| BMW Electric Vehicle                | BEV           | status, range, location, service, check, charge, image, troubleshoot |\n+| BMW Electric Vehicle with REX       | BEV_REX       | status, range, location, service, check, charge, image, troubleshoot |\n+| BMW Plug-In-Hybrid Electric Vehicle | PHEV          | status, range, location, service, check, charge, image, troubleshoot |\n+| BMW Conventional Vehicle            | CONV          | status, range, location, service, check, image, troubleshoot         |\n+\n+ \n+#### Properties\n+\n+<img align=\"right\" src=\"./doc/properties.png\" width=\"500\" height=\"600\"/>\n+\n+For each Vehicle Properties are available. \n+Basically 3 Types of Information are registered as Properties\n+\n+* Informations regarding your Dealer with Address and Phone Number\n+* Which services are available / not available\n+* Vehicle Properties like Color, Model Type, Drive Train and Construction Year\n+\n+In the right picture  can see in *Services Activated* e.g. the *DoorLock* and *DoorUnlock* Services are mentioned. \n+This ensures [Channel Group _Remote Services_](#remote-services) is supporting Door lock and Door unlock.\n+\n+In  *Services Supported* the entry *LastDestination* is mentioned.\n+So it's valid to connect Channel Group [Last Destinations](#destinations) in order to display the last 3 Navigation Destinations.\n+\n+| Property Key       | Property Value      |  Supported Channel Groups    |\n+|--------------------|---------------------|------------------------------|\n+| Services Supported | Statistics          | last-trip, lifetime          |\n+| Services Supported | LastDestinations    | destinations                 |\n+| Services Activated | list of services    | remote                       |\n+\n+\n+## Discovery\n+\n+Auto Discovery is starting after creation of the Bridge towards BMW ConnectedDrive. \n+A list of your registered Vehicles is queried and all found Vehicles are added in Inbox.\n+Unique Identifier is the *Vehicle Identification Number* (VIN). \n+If a Thing is already declared in a  *.things configuration* Discovery won't highlight it again.\n+Properties will be attached to predefined Vehicles if the VIN is matching.\n+\n+## Configuration\n+\n+### Bridge\n+\n+| Parameter       | Type    | Description                                                             |           \n+|-----------------|---------|-------------------------------------------------------------------------|\n+| userName        | text    | BMW Connected Drive Username                  |\n+| password        | text    | BMW Connected Drive Password                  |\n+| region          | text    | Select Region in order to connect to the appropriate BMW Server.   |\n+\n+The region Configuration has 3 different possibilities\n+\n+* _NORTH_AMERICA_\n+* _CHINA_\n+* _ROW_ for Rest of World\n+\n+### Thing\n+\n+Same Configuration is needed for all Things\n+\n+| Parameter       | Type    | Description                           |           \n+|-----------------|---------|---------------------------------------|\n+| vin             | text    | Vehicle Identification Number (VIN)   |\n+| refreshInterval | integer | Refresh Interval in Minutes           |\n+| units           | text    | Unit Selection                        |\n+| imageSize       | integer | Image Size                            |\n+| imageViewport   | text    | Image Viewport                        |\n+\n+The units can be configured in 3 ways\n+\n+* _AUTODETECT_ selects Miles for US & UK, Kilometer otherwise\n+* _METRIC_ selects directly Kilometers\n+* _IMPERIAL_ selects directly Miles\n+\n+The imageVieport allows to show the Vehicle from different angels.\n+Possible values are \n+\n+* FRONT\n+* REAR\n+* SIDE\n+* DASHBOARD\n+* DRIVERDOOR\n+\n+## Channels\n+\n+There are many Channels available for each Vehicle. \n+For better overview they are clustered in different Channel Groups.\n+The Channel Groups are different for the Vehicle Types, on the build-in Sensors of the Vehicle and the activated Services.\n+\n+### Bridge Channels\n+\n+If the Vehicle isn't found in the Discovery force a log of Fingerprint Data which helps to analyze the problem.\n+Please check [TroubleShooting Section](#TroubleShooting) for further advice.\n+\n+| Channel Label         | Channel ID            | Type   | Description                                       |\n+|-----------------------|-----------------------|--------|---------------------------------------------------|\n+| Discovery Fingerprint | discovery-fingerprint | Switch | Forcing a log entry to analyze Discovery Problems |\n+\n+### Thing Channel Groups \n+\n+#### Vehicle Status\n+\n+Reflects Status of the Vehicle.\n+Available for all Vehicles, Read-only.\n+\n+| Channel Label             | Channel Group ID | Channel ID          | Type          | Description                                                                       |\n+|---------------------------|------------------|---------------------|---------------|-----------------------------------------------------------------------------------|\n+| Overall Door Status       | status           | doors               | String        | **Closed** if all closed otherwise **Open**. **Unknown** if no data is delivered  |\n+| Overall Window Status     | status           | windows             | String        | **Closed** if all closed otherwise **Open** or **Intermediate**. **Unknown** if no data is delivered   |\n+| Doors Locked              | status           | lock                | String        | Status if Doors are locked or unlocked                                            |\n+| Next Service Date         | status           | service-date        | DateTime      | Date of Upcoming Service                                                          |\n+| Mileage till Next Service | status           | service-mileage     | Number:Length | Mileage till Upcoming Service                                                     |\n+| Check Control             | status           | check-control       | String        | Indicator if CheckControl is **Active** or **Not Active**. **Unknown** if no data is delivered         |\n+| Charging Status           | status           | charge              | String        | Only available for PHEV, BEV_REX and BEV                                          |\n+| Last Status Timestamp     | status           | last-update         | DateTime      | Date and Time of last status update.                                              |\n+\n+See [further details for DateTime](#last-status-update-timestamp) in case of wrong timestamp values\n+\n+#### Services\n+\n+Group for all upcoming Services with Description, Service Date and / or Service Mileage\n+It's designed as [List Interface](#list-interface) so all upcoming Services can be checked.\n+\n+| Channel Label                  | Channel Group ID | Channel ID          | Type           | \n+|--------------------------------|------------------|---------------------|----------------|\n+| Service Name                   | service          | name                | String         |\n+| Service Date                   | service          | date                | Number         |\n+| Mileage till Service           | service          | mileage             | Number:Length  |\n+| Number of Scheduled Services   | service          | size                | String         |\n+| Current Selected Service Index | service          | index               | Number         |\n+| Select next Service            | service          | next                | Switch         |\n+\n+#### Check Control\n+\n+Group for all current active CheckControl Messages.\n+It's designed as [List Interface](#list-interface) to show all active Messages.\n+\n+| Channel Label                   | Channel Group ID | Channel ID          | Type           | \n+|---------------------------------|------------------|---------------------|----------------|\n+| CheckControl Description        | check            | name                | String         |\n+| CheckControl Mileage Occurrence | check            | mileage             | Number:Length  |\n+| Active CheckControl Messages    | check            | size                | String         |\n+| Selected CheckControl Message   | check            | index               | Number         |\n+| Next CheckControl Message       | check            | next                | Switch         |\n+\n+#### Doors Details\n+\n+Detailed Status of all Doors and Windows\n+Available for all Vehicles, Read-only. \n+\n+| Channel Label              | Channel Group ID | Channel ID              | Type          | \n+|----------------------------|------------------|-------------------------|---------------|\n+| Driver Door                | doors            | driver-front            | String        |\n+| Driver Door Rear           | doors            | driver-rear             | String        |\n+| Passenger Door             | doors            | passenger-front         | String        |\n+| Passenger Door Rear        | doors            | passenger-rear          | String        |\n+| Trunk                      | doors            | trunk                   | String        |\n+| Hood                       | doors            | hood                    | String        |\n+| Driver Door Window         | doors            | window-driver-front     | String        |\n+| Driver Door Rear Window    | doors            | window-driver-rear      | String        |\n+| Passenger Door Window      | doors            | window-passenger-front  | String        |\n+| Passenger Door Rear Window | doors            | window-passenger-rear   | String        |\n+| Rear Window                | doors            | window-rear             | String        |\n+| Sunroof                    | doors            | sunroof                 | String        |\n+\n+Following Strings will be delivered\n+\n+* UNKNOWN - no status data available\n+* INVALID - this item isn't applicable for this Vehicle\n+* CLOSED - the Door / Window is closed\n+* OPEN - the Door / Window is open\n+* INTERMEDIATE - Window in intermediate position, not applicable for Doors\n+\n+#### Range Data\n+\n+Based on Vehicle Type (Thing Type ID) some Channels are presented or not. \n+Conventional Fuel Vehicles don't provide *Electric Range* and Battery Electric Vehicles don't show *Range Fuel*.\n+Hybrid Vehicles have both and in addition *Hybrid Range*.\n+These are Read-only values.\n+\n+| Channel Label         | Channel Group ID | Channel ID            | Type                 | CONV | PHEV | BEV_REX | BEV |\n+|-----------------------|------------------|-----------------------|----------------------|------|------|---------|-----|\n+| Mileage               | range            | mileage               | Number:Length        |  X   |  X   |    X    |  X  |\n+| Fuel Range            | range            | range-fuel            | Number:Length        |  X   |  X   |    X    |     |\n+| Battery Range         | range            | range-electric        | Number:Length        |      |  X   |    X    |  X  | \n+| Hybrid Range          | range            | range-hybrid          | Number:Length        |      |  X   |    X    |     | \n+| Battery Charge Level  | range            | soc                   | Number:Dimensionless |      |  X   |    X    |  X  |\n+| Remaining Fuel        | range            | remaining-fuel        | Number:Volume        |  X   |  X   |    X    |     | \n+| Fuel Range Radius     | range            | range-radius-fuel     | Number:Length        |  X   |  X   |    X    |     | \n+| Electric Range Radius | range            | range-radius-electric | Number:Length        |      |  X   |    X    |  X  | \n+| Hybrid Range Radius   | range            | range-radius-hybrid   | Number:Length        |      |  X   |    X    |     | \n+\n+See Description [Range vs Range Radius](#range-vs-range-radius) to get more information\n+\n+#### Charge Profile\n+\n+Valid for Electric and Hybrid Vehicles\n+These are Read-only values.\n+\n+| Channel Label                      | Channel Group ID | Channel ID          | Type   | \n+|------------------------------------|------------------|---------------------|--------|\n+| Air Conditioning at Departure Time | charge           | profile-climate     | Switch | \n+| Charging Mode for Profile          | charge           | profile-mode        | String | \n+| Charging Window Start Time         | charge           | window-start        | String | \n+| Charging Window End Time           | charge           | window-end          | String | \n+| Timer 1: Departure Time            | charge           | timer1-departure    | String | \n+| Timer 1: Scheduled Days            | charge           | timer1-days         | String | \n+| Timer 1: Enabled                   | charge           | timer1-enabled      | Switch | \n+| Timer 2: Departure Time            | charge           | timer2-departure    | String | \n+| Timer 2: Scheduled Days            | charge           | timer2-days         | String | \n+| Timer 2: Enabled                   | charge           | timer2-enabled      | Switch | \n+| Timer 3: Departure Time            | charge           | timer3-departure    | String | \n+| Timer 3: Scheduled Days            | charge           | timer3-days         | String | \n+| Timer 3: Enabled                   | charge           | timer3-enabled      | Switch | \n+\n+\n+#### Location\n+\n+Available for all Vehicles.\n+These are Read-only values.\n+\n+| Channel Label  | Channel Group ID | Channel ID          | Type         | \n+|----------------|------------------|---------------------|--------------|\n+| Latitude       | location         | latitude            | Number       | \n+| Longitude      | location         | longitude           | Number       |", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTEyNDI2Mw=="}, "originalCommit": {"oid": "e0bfe93e13df4a3c5de5f8819b94ebf795664904"}, "originalPosition": 268}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEzNzg0MjQwOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.bmwconnecteddrive/README.md", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wN1QxNTo1NzozMVrOHd6Yfw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yN1QxNTo1NzowNFrOILsL1w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTEyNzI5NQ==", "bodyText": "You could use the Channel Command Description and combine these commands into a single Channel.", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r501127295", "createdAt": "2020-10-07T15:57:31Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/README.md", "diffHunk": "@@ -0,0 +1,862 @@\n+# BMW ConnectedDrive Binding\n+\n+<img align=\"right\" src=\"./doc/bmw-connected.png\" width=\"150\" height=\"150\"/>\n+\n+The Binding provides a Connection between [BMWs ConnectedDrive Portal](https://www.bmw-connecteddrive.com/country-region-select/country-region-selection.html) and openHAB.\n+All Vehicles connected to an Account will be detected by the Discovery with the correct type \n+\n+* Conventional Fuel Vehicle\n+* Plugin-Hybrid Electrical Vehicle \n+* Battery Electric Vehicle with Range Extender\n+* Battery Electric Vehicle \n+\n+In addition Properties are attached with Information and Services provided by this Vehicle.\n+The provided data depends on \n+\n+1. the [Type](#Things) and \n+2. the Services mentioned in [Properties](#properties)\n+\n+Different Channel Groups are clustering all informations.\n+Check for each Group if it's supported for this Vehicle.\n+\n+Please note **this isn't a real-time Binding**. \n+If the Door is opened the state isn't transmitted and changed immediately. \n+This isn't a flaw in the Binding itself because the state in BMWs own ConnectedDrive App is also updated with some delay. \n+\n+## Supported Things\n+\n+### Bridge\n+\n+The Bridge establishes the Connection between BMW ConnectedDrive Portal and openHAB.\n+\n+| Name                       | Bridge Type ID | Description                                                |\n+|----------------------------|----------------|------------------------------------------------------------|\n+| BMW ConnectedDrive Account | account        | Access to BMW ConnectedDrive Portal for a specific user    |\n+\n+\n+### Things\n+\n+Four different Vehicle Types are provided. \n+They differ in the supported Channel Groups & Channels. \n+Conventional Fuel Vehicles have no _Charging Profile_, Electric Vehicles don't provide a _Fuel Range_. \n+For Hybrid Vehicles in addition to _Fuel and Electric Range_ the _Hybrid Range_ is shown.\n+ \n+| Name                                | Thing Type ID | Supported Channel Groups                                             |\n+|-------------------------------------|---------------|----------------------------------------------------------------------|\n+| BMW Electric Vehicle                | BEV           | status, range, location, service, check, charge, image, troubleshoot |\n+| BMW Electric Vehicle with REX       | BEV_REX       | status, range, location, service, check, charge, image, troubleshoot |\n+| BMW Plug-In-Hybrid Electric Vehicle | PHEV          | status, range, location, service, check, charge, image, troubleshoot |\n+| BMW Conventional Vehicle            | CONV          | status, range, location, service, check, image, troubleshoot         |\n+\n+ \n+#### Properties\n+\n+<img align=\"right\" src=\"./doc/properties.png\" width=\"500\" height=\"600\"/>\n+\n+For each Vehicle Properties are available. \n+Basically 3 Types of Information are registered as Properties\n+\n+* Informations regarding your Dealer with Address and Phone Number\n+* Which services are available / not available\n+* Vehicle Properties like Color, Model Type, Drive Train and Construction Year\n+\n+In the right picture  can see in *Services Activated* e.g. the *DoorLock* and *DoorUnlock* Services are mentioned. \n+This ensures [Channel Group _Remote Services_](#remote-services) is supporting Door lock and Door unlock.\n+\n+In  *Services Supported* the entry *LastDestination* is mentioned.\n+So it's valid to connect Channel Group [Last Destinations](#destinations) in order to display the last 3 Navigation Destinations.\n+\n+| Property Key       | Property Value      |  Supported Channel Groups    |\n+|--------------------|---------------------|------------------------------|\n+| Services Supported | Statistics          | last-trip, lifetime          |\n+| Services Supported | LastDestinations    | destinations                 |\n+| Services Activated | list of services    | remote                       |\n+\n+\n+## Discovery\n+\n+Auto Discovery is starting after creation of the Bridge towards BMW ConnectedDrive. \n+A list of your registered Vehicles is queried and all found Vehicles are added in Inbox.\n+Unique Identifier is the *Vehicle Identification Number* (VIN). \n+If a Thing is already declared in a  *.things configuration* Discovery won't highlight it again.\n+Properties will be attached to predefined Vehicles if the VIN is matching.\n+\n+## Configuration\n+\n+### Bridge\n+\n+| Parameter       | Type    | Description                                                             |           \n+|-----------------|---------|-------------------------------------------------------------------------|\n+| userName        | text    | BMW Connected Drive Username                  |\n+| password        | text    | BMW Connected Drive Password                  |\n+| region          | text    | Select Region in order to connect to the appropriate BMW Server.   |\n+\n+The region Configuration has 3 different possibilities\n+\n+* _NORTH_AMERICA_\n+* _CHINA_\n+* _ROW_ for Rest of World\n+\n+### Thing\n+\n+Same Configuration is needed for all Things\n+\n+| Parameter       | Type    | Description                           |           \n+|-----------------|---------|---------------------------------------|\n+| vin             | text    | Vehicle Identification Number (VIN)   |\n+| refreshInterval | integer | Refresh Interval in Minutes           |\n+| units           | text    | Unit Selection                        |\n+| imageSize       | integer | Image Size                            |\n+| imageViewport   | text    | Image Viewport                        |\n+\n+The units can be configured in 3 ways\n+\n+* _AUTODETECT_ selects Miles for US & UK, Kilometer otherwise\n+* _METRIC_ selects directly Kilometers\n+* _IMPERIAL_ selects directly Miles\n+\n+The imageVieport allows to show the Vehicle from different angels.\n+Possible values are \n+\n+* FRONT\n+* REAR\n+* SIDE\n+* DASHBOARD\n+* DRIVERDOOR\n+\n+## Channels\n+\n+There are many Channels available for each Vehicle. \n+For better overview they are clustered in different Channel Groups.\n+The Channel Groups are different for the Vehicle Types, on the build-in Sensors of the Vehicle and the activated Services.\n+\n+### Bridge Channels\n+\n+If the Vehicle isn't found in the Discovery force a log of Fingerprint Data which helps to analyze the problem.\n+Please check [TroubleShooting Section](#TroubleShooting) for further advice.\n+\n+| Channel Label         | Channel ID            | Type   | Description                                       |\n+|-----------------------|-----------------------|--------|---------------------------------------------------|\n+| Discovery Fingerprint | discovery-fingerprint | Switch | Forcing a log entry to analyze Discovery Problems |\n+\n+### Thing Channel Groups \n+\n+#### Vehicle Status\n+\n+Reflects Status of the Vehicle.\n+Available for all Vehicles, Read-only.\n+\n+| Channel Label             | Channel Group ID | Channel ID          | Type          | Description                                                                       |\n+|---------------------------|------------------|---------------------|---------------|-----------------------------------------------------------------------------------|\n+| Overall Door Status       | status           | doors               | String        | **Closed** if all closed otherwise **Open**. **Unknown** if no data is delivered  |\n+| Overall Window Status     | status           | windows             | String        | **Closed** if all closed otherwise **Open** or **Intermediate**. **Unknown** if no data is delivered   |\n+| Doors Locked              | status           | lock                | String        | Status if Doors are locked or unlocked                                            |\n+| Next Service Date         | status           | service-date        | DateTime      | Date of Upcoming Service                                                          |\n+| Mileage till Next Service | status           | service-mileage     | Number:Length | Mileage till Upcoming Service                                                     |\n+| Check Control             | status           | check-control       | String        | Indicator if CheckControl is **Active** or **Not Active**. **Unknown** if no data is delivered         |\n+| Charging Status           | status           | charge              | String        | Only available for PHEV, BEV_REX and BEV                                          |\n+| Last Status Timestamp     | status           | last-update         | DateTime      | Date and Time of last status update.                                              |\n+\n+See [further details for DateTime](#last-status-update-timestamp) in case of wrong timestamp values\n+\n+#### Services\n+\n+Group for all upcoming Services with Description, Service Date and / or Service Mileage\n+It's designed as [List Interface](#list-interface) so all upcoming Services can be checked.\n+\n+| Channel Label                  | Channel Group ID | Channel ID          | Type           | \n+|--------------------------------|------------------|---------------------|----------------|\n+| Service Name                   | service          | name                | String         |\n+| Service Date                   | service          | date                | Number         |\n+| Mileage till Service           | service          | mileage             | Number:Length  |\n+| Number of Scheduled Services   | service          | size                | String         |\n+| Current Selected Service Index | service          | index               | Number         |\n+| Select next Service            | service          | next                | Switch         |\n+\n+#### Check Control\n+\n+Group for all current active CheckControl Messages.\n+It's designed as [List Interface](#list-interface) to show all active Messages.\n+\n+| Channel Label                   | Channel Group ID | Channel ID          | Type           | \n+|---------------------------------|------------------|---------------------|----------------|\n+| CheckControl Description        | check            | name                | String         |\n+| CheckControl Mileage Occurrence | check            | mileage             | Number:Length  |\n+| Active CheckControl Messages    | check            | size                | String         |\n+| Selected CheckControl Message   | check            | index               | Number         |\n+| Next CheckControl Message       | check            | next                | Switch         |\n+\n+#### Doors Details\n+\n+Detailed Status of all Doors and Windows\n+Available for all Vehicles, Read-only. \n+\n+| Channel Label              | Channel Group ID | Channel ID              | Type          | \n+|----------------------------|------------------|-------------------------|---------------|\n+| Driver Door                | doors            | driver-front            | String        |\n+| Driver Door Rear           | doors            | driver-rear             | String        |\n+| Passenger Door             | doors            | passenger-front         | String        |\n+| Passenger Door Rear        | doors            | passenger-rear          | String        |\n+| Trunk                      | doors            | trunk                   | String        |\n+| Hood                       | doors            | hood                    | String        |\n+| Driver Door Window         | doors            | window-driver-front     | String        |\n+| Driver Door Rear Window    | doors            | window-driver-rear      | String        |\n+| Passenger Door Window      | doors            | window-passenger-front  | String        |\n+| Passenger Door Rear Window | doors            | window-passenger-rear   | String        |\n+| Rear Window                | doors            | window-rear             | String        |\n+| Sunroof                    | doors            | sunroof                 | String        |\n+\n+Following Strings will be delivered\n+\n+* UNKNOWN - no status data available\n+* INVALID - this item isn't applicable for this Vehicle\n+* CLOSED - the Door / Window is closed\n+* OPEN - the Door / Window is open\n+* INTERMEDIATE - Window in intermediate position, not applicable for Doors\n+\n+#### Range Data\n+\n+Based on Vehicle Type (Thing Type ID) some Channels are presented or not. \n+Conventional Fuel Vehicles don't provide *Electric Range* and Battery Electric Vehicles don't show *Range Fuel*.\n+Hybrid Vehicles have both and in addition *Hybrid Range*.\n+These are Read-only values.\n+\n+| Channel Label         | Channel Group ID | Channel ID            | Type                 | CONV | PHEV | BEV_REX | BEV |\n+|-----------------------|------------------|-----------------------|----------------------|------|------|---------|-----|\n+| Mileage               | range            | mileage               | Number:Length        |  X   |  X   |    X    |  X  |\n+| Fuel Range            | range            | range-fuel            | Number:Length        |  X   |  X   |    X    |     |\n+| Battery Range         | range            | range-electric        | Number:Length        |      |  X   |    X    |  X  | \n+| Hybrid Range          | range            | range-hybrid          | Number:Length        |      |  X   |    X    |     | \n+| Battery Charge Level  | range            | soc                   | Number:Dimensionless |      |  X   |    X    |  X  |\n+| Remaining Fuel        | range            | remaining-fuel        | Number:Volume        |  X   |  X   |    X    |     | \n+| Fuel Range Radius     | range            | range-radius-fuel     | Number:Length        |  X   |  X   |    X    |     | \n+| Electric Range Radius | range            | range-radius-electric | Number:Length        |      |  X   |    X    |  X  | \n+| Hybrid Range Radius   | range            | range-radius-hybrid   | Number:Length        |      |  X   |    X    |     | \n+\n+See Description [Range vs Range Radius](#range-vs-range-radius) to get more information\n+\n+#### Charge Profile\n+\n+Valid for Electric and Hybrid Vehicles\n+These are Read-only values.\n+\n+| Channel Label                      | Channel Group ID | Channel ID          | Type   | \n+|------------------------------------|------------------|---------------------|--------|\n+| Air Conditioning at Departure Time | charge           | profile-climate     | Switch | \n+| Charging Mode for Profile          | charge           | profile-mode        | String | \n+| Charging Window Start Time         | charge           | window-start        | String | \n+| Charging Window End Time           | charge           | window-end          | String | \n+| Timer 1: Departure Time            | charge           | timer1-departure    | String | \n+| Timer 1: Scheduled Days            | charge           | timer1-days         | String | \n+| Timer 1: Enabled                   | charge           | timer1-enabled      | Switch | \n+| Timer 2: Departure Time            | charge           | timer2-departure    | String | \n+| Timer 2: Scheduled Days            | charge           | timer2-days         | String | \n+| Timer 2: Enabled                   | charge           | timer2-enabled      | Switch | \n+| Timer 3: Departure Time            | charge           | timer3-departure    | String | \n+| Timer 3: Scheduled Days            | charge           | timer3-days         | String | \n+| Timer 3: Enabled                   | charge           | timer3-enabled      | Switch | \n+\n+\n+#### Location\n+\n+Available for all Vehicles.\n+These are Read-only values.\n+\n+| Channel Label  | Channel Group ID | Channel ID          | Type         | \n+|----------------|------------------|---------------------|--------------|\n+| Latitude       | location         | latitude            | Number       | \n+| Longitude      | location         | longitude           | Number       |\n+| Heading        | location         | heading             | Number:Angle | \n+\n+#### Last Trip\n+\n+Check [Vehicle Properties](#Properties) if *Statistics* is present in *Services Supported*\n+These are Read-only values.\n+\n+| Channel Label                           | Channel Group ID | Channel ID                   | Type          |\n+|-----------------------------------------|------------------|------------------------------|---------------|\n+| Last Trip Date                          | last-trip        | date                         | DateTime      |\n+| Last Trip Duration                      | last-trip        | duration                     | Number:Time   |\n+| Average Power Consumption per 100 km    | last-trip        | average-consumption          | Number:Power  |\n+| Average Combined Consumption per 100 km | last-trip        | average-combined-consumption | Number:Volume |\n+| Average Power Recuperation per 100 km   | last-trip        | average-recuperation         | Number:Power  |\n+| Last Trip Distance                      | last-trip        | distance                     | Number:Length |\n+| Distance since Last Charge              | last-trip        | distance-since-charging      | Number:Length |\n+\n+\n+#### Lifetime Statistics\n+\n+Check [Vehicle Properties](#Properties) if *Statistics* is present in *Services Supported*\n+These are Read-only values.\n+\n+| Channel Label                           | Channel Group ID | Channel ID                   | Type          | \n+|-----------------------------------------|------------------|------------------------------|---------------|\n+| Average Power Consumption per 100 km    | lifetime         | average-consumption          | Number:Power  |\n+| Average Power Recuperation per 100 km   | lifetime         | average-recuperation         | Number:Power  |\n+| Cumulated Electric Driven Distance      | lifetime         | cumulated-driven-distance    | Number:Length |\n+| Average Combined Consumption per 100 km | lifetime         | average-combined-consumption | Number:Volume |\n+| Longest Distance with one Charge        | lifetime         | single-longest-distance      | Number:Length |\n+\n+\n+#### Remote Services\n+\n+Check [Vehicle Properties](#Properties) *Services Activated* which Remote Services are available\n+Only one Remote Service can be executed each Time.\n+Parallel execution isn't supported.\n+The *Service Execution State* Channel is reporting the state.\n+State *Executed* is the final State when Execution is finished.\n+\n+| Channel Label           | Channel Group ID | Channel ID          | Type    | \n+|-------------------------|------------------|---------------------|---------|\n+| Activate Flash Lights   | remote           | light               | Switch  |\n+| Find Vehicle            | remote           | finder              | Switch  |\n+| Lock Doors              | remote           | lock                | Switch  |\n+| Unlock Doors            | remote           | unlock              | Switch  |\n+| Horn Blow               | remote           | horn                | Switch  |\n+| Active Air Conditioning | remote           | climate             | Switch  |\n+| Service Execution State | remote           | state               | STring  |", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e0bfe93e13df4a3c5de5f8819b94ebf795664904"}, "originalPosition": 317}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTEyOTE3NQ==", "bodyText": "I removed this in all tables and mention the Channel Group ID one time on top for all groups.", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r549129175", "createdAt": "2020-12-27T15:57:04Z", "author": {"login": "weymann"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/README.md", "diffHunk": "@@ -0,0 +1,862 @@\n+# BMW ConnectedDrive Binding\n+\n+<img align=\"right\" src=\"./doc/bmw-connected.png\" width=\"150\" height=\"150\"/>\n+\n+The Binding provides a Connection between [BMWs ConnectedDrive Portal](https://www.bmw-connecteddrive.com/country-region-select/country-region-selection.html) and openHAB.\n+All Vehicles connected to an Account will be detected by the Discovery with the correct type \n+\n+* Conventional Fuel Vehicle\n+* Plugin-Hybrid Electrical Vehicle \n+* Battery Electric Vehicle with Range Extender\n+* Battery Electric Vehicle \n+\n+In addition Properties are attached with Information and Services provided by this Vehicle.\n+The provided data depends on \n+\n+1. the [Type](#Things) and \n+2. the Services mentioned in [Properties](#properties)\n+\n+Different Channel Groups are clustering all informations.\n+Check for each Group if it's supported for this Vehicle.\n+\n+Please note **this isn't a real-time Binding**. \n+If the Door is opened the state isn't transmitted and changed immediately. \n+This isn't a flaw in the Binding itself because the state in BMWs own ConnectedDrive App is also updated with some delay. \n+\n+## Supported Things\n+\n+### Bridge\n+\n+The Bridge establishes the Connection between BMW ConnectedDrive Portal and openHAB.\n+\n+| Name                       | Bridge Type ID | Description                                                |\n+|----------------------------|----------------|------------------------------------------------------------|\n+| BMW ConnectedDrive Account | account        | Access to BMW ConnectedDrive Portal for a specific user    |\n+\n+\n+### Things\n+\n+Four different Vehicle Types are provided. \n+They differ in the supported Channel Groups & Channels. \n+Conventional Fuel Vehicles have no _Charging Profile_, Electric Vehicles don't provide a _Fuel Range_. \n+For Hybrid Vehicles in addition to _Fuel and Electric Range_ the _Hybrid Range_ is shown.\n+ \n+| Name                                | Thing Type ID | Supported Channel Groups                                             |\n+|-------------------------------------|---------------|----------------------------------------------------------------------|\n+| BMW Electric Vehicle                | BEV           | status, range, location, service, check, charge, image, troubleshoot |\n+| BMW Electric Vehicle with REX       | BEV_REX       | status, range, location, service, check, charge, image, troubleshoot |\n+| BMW Plug-In-Hybrid Electric Vehicle | PHEV          | status, range, location, service, check, charge, image, troubleshoot |\n+| BMW Conventional Vehicle            | CONV          | status, range, location, service, check, image, troubleshoot         |\n+\n+ \n+#### Properties\n+\n+<img align=\"right\" src=\"./doc/properties.png\" width=\"500\" height=\"600\"/>\n+\n+For each Vehicle Properties are available. \n+Basically 3 Types of Information are registered as Properties\n+\n+* Informations regarding your Dealer with Address and Phone Number\n+* Which services are available / not available\n+* Vehicle Properties like Color, Model Type, Drive Train and Construction Year\n+\n+In the right picture  can see in *Services Activated* e.g. the *DoorLock* and *DoorUnlock* Services are mentioned. \n+This ensures [Channel Group _Remote Services_](#remote-services) is supporting Door lock and Door unlock.\n+\n+In  *Services Supported* the entry *LastDestination* is mentioned.\n+So it's valid to connect Channel Group [Last Destinations](#destinations) in order to display the last 3 Navigation Destinations.\n+\n+| Property Key       | Property Value      |  Supported Channel Groups    |\n+|--------------------|---------------------|------------------------------|\n+| Services Supported | Statistics          | last-trip, lifetime          |\n+| Services Supported | LastDestinations    | destinations                 |\n+| Services Activated | list of services    | remote                       |\n+\n+\n+## Discovery\n+\n+Auto Discovery is starting after creation of the Bridge towards BMW ConnectedDrive. \n+A list of your registered Vehicles is queried and all found Vehicles are added in Inbox.\n+Unique Identifier is the *Vehicle Identification Number* (VIN). \n+If a Thing is already declared in a  *.things configuration* Discovery won't highlight it again.\n+Properties will be attached to predefined Vehicles if the VIN is matching.\n+\n+## Configuration\n+\n+### Bridge\n+\n+| Parameter       | Type    | Description                                                             |           \n+|-----------------|---------|-------------------------------------------------------------------------|\n+| userName        | text    | BMW Connected Drive Username                  |\n+| password        | text    | BMW Connected Drive Password                  |\n+| region          | text    | Select Region in order to connect to the appropriate BMW Server.   |\n+\n+The region Configuration has 3 different possibilities\n+\n+* _NORTH_AMERICA_\n+* _CHINA_\n+* _ROW_ for Rest of World\n+\n+### Thing\n+\n+Same Configuration is needed for all Things\n+\n+| Parameter       | Type    | Description                           |           \n+|-----------------|---------|---------------------------------------|\n+| vin             | text    | Vehicle Identification Number (VIN)   |\n+| refreshInterval | integer | Refresh Interval in Minutes           |\n+| units           | text    | Unit Selection                        |\n+| imageSize       | integer | Image Size                            |\n+| imageViewport   | text    | Image Viewport                        |\n+\n+The units can be configured in 3 ways\n+\n+* _AUTODETECT_ selects Miles for US & UK, Kilometer otherwise\n+* _METRIC_ selects directly Kilometers\n+* _IMPERIAL_ selects directly Miles\n+\n+The imageVieport allows to show the Vehicle from different angels.\n+Possible values are \n+\n+* FRONT\n+* REAR\n+* SIDE\n+* DASHBOARD\n+* DRIVERDOOR\n+\n+## Channels\n+\n+There are many Channels available for each Vehicle. \n+For better overview they are clustered in different Channel Groups.\n+The Channel Groups are different for the Vehicle Types, on the build-in Sensors of the Vehicle and the activated Services.\n+\n+### Bridge Channels\n+\n+If the Vehicle isn't found in the Discovery force a log of Fingerprint Data which helps to analyze the problem.\n+Please check [TroubleShooting Section](#TroubleShooting) for further advice.\n+\n+| Channel Label         | Channel ID            | Type   | Description                                       |\n+|-----------------------|-----------------------|--------|---------------------------------------------------|\n+| Discovery Fingerprint | discovery-fingerprint | Switch | Forcing a log entry to analyze Discovery Problems |\n+\n+### Thing Channel Groups \n+\n+#### Vehicle Status\n+\n+Reflects Status of the Vehicle.\n+Available for all Vehicles, Read-only.\n+\n+| Channel Label             | Channel Group ID | Channel ID          | Type          | Description                                                                       |\n+|---------------------------|------------------|---------------------|---------------|-----------------------------------------------------------------------------------|\n+| Overall Door Status       | status           | doors               | String        | **Closed** if all closed otherwise **Open**. **Unknown** if no data is delivered  |\n+| Overall Window Status     | status           | windows             | String        | **Closed** if all closed otherwise **Open** or **Intermediate**. **Unknown** if no data is delivered   |\n+| Doors Locked              | status           | lock                | String        | Status if Doors are locked or unlocked                                            |\n+| Next Service Date         | status           | service-date        | DateTime      | Date of Upcoming Service                                                          |\n+| Mileage till Next Service | status           | service-mileage     | Number:Length | Mileage till Upcoming Service                                                     |\n+| Check Control             | status           | check-control       | String        | Indicator if CheckControl is **Active** or **Not Active**. **Unknown** if no data is delivered         |\n+| Charging Status           | status           | charge              | String        | Only available for PHEV, BEV_REX and BEV                                          |\n+| Last Status Timestamp     | status           | last-update         | DateTime      | Date and Time of last status update.                                              |\n+\n+See [further details for DateTime](#last-status-update-timestamp) in case of wrong timestamp values\n+\n+#### Services\n+\n+Group for all upcoming Services with Description, Service Date and / or Service Mileage\n+It's designed as [List Interface](#list-interface) so all upcoming Services can be checked.\n+\n+| Channel Label                  | Channel Group ID | Channel ID          | Type           | \n+|--------------------------------|------------------|---------------------|----------------|\n+| Service Name                   | service          | name                | String         |\n+| Service Date                   | service          | date                | Number         |\n+| Mileage till Service           | service          | mileage             | Number:Length  |\n+| Number of Scheduled Services   | service          | size                | String         |\n+| Current Selected Service Index | service          | index               | Number         |\n+| Select next Service            | service          | next                | Switch         |\n+\n+#### Check Control\n+\n+Group for all current active CheckControl Messages.\n+It's designed as [List Interface](#list-interface) to show all active Messages.\n+\n+| Channel Label                   | Channel Group ID | Channel ID          | Type           | \n+|---------------------------------|------------------|---------------------|----------------|\n+| CheckControl Description        | check            | name                | String         |\n+| CheckControl Mileage Occurrence | check            | mileage             | Number:Length  |\n+| Active CheckControl Messages    | check            | size                | String         |\n+| Selected CheckControl Message   | check            | index               | Number         |\n+| Next CheckControl Message       | check            | next                | Switch         |\n+\n+#### Doors Details\n+\n+Detailed Status of all Doors and Windows\n+Available for all Vehicles, Read-only. \n+\n+| Channel Label              | Channel Group ID | Channel ID              | Type          | \n+|----------------------------|------------------|-------------------------|---------------|\n+| Driver Door                | doors            | driver-front            | String        |\n+| Driver Door Rear           | doors            | driver-rear             | String        |\n+| Passenger Door             | doors            | passenger-front         | String        |\n+| Passenger Door Rear        | doors            | passenger-rear          | String        |\n+| Trunk                      | doors            | trunk                   | String        |\n+| Hood                       | doors            | hood                    | String        |\n+| Driver Door Window         | doors            | window-driver-front     | String        |\n+| Driver Door Rear Window    | doors            | window-driver-rear      | String        |\n+| Passenger Door Window      | doors            | window-passenger-front  | String        |\n+| Passenger Door Rear Window | doors            | window-passenger-rear   | String        |\n+| Rear Window                | doors            | window-rear             | String        |\n+| Sunroof                    | doors            | sunroof                 | String        |\n+\n+Following Strings will be delivered\n+\n+* UNKNOWN - no status data available\n+* INVALID - this item isn't applicable for this Vehicle\n+* CLOSED - the Door / Window is closed\n+* OPEN - the Door / Window is open\n+* INTERMEDIATE - Window in intermediate position, not applicable for Doors\n+\n+#### Range Data\n+\n+Based on Vehicle Type (Thing Type ID) some Channels are presented or not. \n+Conventional Fuel Vehicles don't provide *Electric Range* and Battery Electric Vehicles don't show *Range Fuel*.\n+Hybrid Vehicles have both and in addition *Hybrid Range*.\n+These are Read-only values.\n+\n+| Channel Label         | Channel Group ID | Channel ID            | Type                 | CONV | PHEV | BEV_REX | BEV |\n+|-----------------------|------------------|-----------------------|----------------------|------|------|---------|-----|\n+| Mileage               | range            | mileage               | Number:Length        |  X   |  X   |    X    |  X  |\n+| Fuel Range            | range            | range-fuel            | Number:Length        |  X   |  X   |    X    |     |\n+| Battery Range         | range            | range-electric        | Number:Length        |      |  X   |    X    |  X  | \n+| Hybrid Range          | range            | range-hybrid          | Number:Length        |      |  X   |    X    |     | \n+| Battery Charge Level  | range            | soc                   | Number:Dimensionless |      |  X   |    X    |  X  |\n+| Remaining Fuel        | range            | remaining-fuel        | Number:Volume        |  X   |  X   |    X    |     | \n+| Fuel Range Radius     | range            | range-radius-fuel     | Number:Length        |  X   |  X   |    X    |     | \n+| Electric Range Radius | range            | range-radius-electric | Number:Length        |      |  X   |    X    |  X  | \n+| Hybrid Range Radius   | range            | range-radius-hybrid   | Number:Length        |      |  X   |    X    |     | \n+\n+See Description [Range vs Range Radius](#range-vs-range-radius) to get more information\n+\n+#### Charge Profile\n+\n+Valid for Electric and Hybrid Vehicles\n+These are Read-only values.\n+\n+| Channel Label                      | Channel Group ID | Channel ID          | Type   | \n+|------------------------------------|------------------|---------------------|--------|\n+| Air Conditioning at Departure Time | charge           | profile-climate     | Switch | \n+| Charging Mode for Profile          | charge           | profile-mode        | String | \n+| Charging Window Start Time         | charge           | window-start        | String | \n+| Charging Window End Time           | charge           | window-end          | String | \n+| Timer 1: Departure Time            | charge           | timer1-departure    | String | \n+| Timer 1: Scheduled Days            | charge           | timer1-days         | String | \n+| Timer 1: Enabled                   | charge           | timer1-enabled      | Switch | \n+| Timer 2: Departure Time            | charge           | timer2-departure    | String | \n+| Timer 2: Scheduled Days            | charge           | timer2-days         | String | \n+| Timer 2: Enabled                   | charge           | timer2-enabled      | Switch | \n+| Timer 3: Departure Time            | charge           | timer3-departure    | String | \n+| Timer 3: Scheduled Days            | charge           | timer3-days         | String | \n+| Timer 3: Enabled                   | charge           | timer3-enabled      | Switch | \n+\n+\n+#### Location\n+\n+Available for all Vehicles.\n+These are Read-only values.\n+\n+| Channel Label  | Channel Group ID | Channel ID          | Type         | \n+|----------------|------------------|---------------------|--------------|\n+| Latitude       | location         | latitude            | Number       | \n+| Longitude      | location         | longitude           | Number       |\n+| Heading        | location         | heading             | Number:Angle | \n+\n+#### Last Trip\n+\n+Check [Vehicle Properties](#Properties) if *Statistics* is present in *Services Supported*\n+These are Read-only values.\n+\n+| Channel Label                           | Channel Group ID | Channel ID                   | Type          |\n+|-----------------------------------------|------------------|------------------------------|---------------|\n+| Last Trip Date                          | last-trip        | date                         | DateTime      |\n+| Last Trip Duration                      | last-trip        | duration                     | Number:Time   |\n+| Average Power Consumption per 100 km    | last-trip        | average-consumption          | Number:Power  |\n+| Average Combined Consumption per 100 km | last-trip        | average-combined-consumption | Number:Volume |\n+| Average Power Recuperation per 100 km   | last-trip        | average-recuperation         | Number:Power  |\n+| Last Trip Distance                      | last-trip        | distance                     | Number:Length |\n+| Distance since Last Charge              | last-trip        | distance-since-charging      | Number:Length |\n+\n+\n+#### Lifetime Statistics\n+\n+Check [Vehicle Properties](#Properties) if *Statistics* is present in *Services Supported*\n+These are Read-only values.\n+\n+| Channel Label                           | Channel Group ID | Channel ID                   | Type          | \n+|-----------------------------------------|------------------|------------------------------|---------------|\n+| Average Power Consumption per 100 km    | lifetime         | average-consumption          | Number:Power  |\n+| Average Power Recuperation per 100 km   | lifetime         | average-recuperation         | Number:Power  |\n+| Cumulated Electric Driven Distance      | lifetime         | cumulated-driven-distance    | Number:Length |\n+| Average Combined Consumption per 100 km | lifetime         | average-combined-consumption | Number:Volume |\n+| Longest Distance with one Charge        | lifetime         | single-longest-distance      | Number:Length |\n+\n+\n+#### Remote Services\n+\n+Check [Vehicle Properties](#Properties) *Services Activated* which Remote Services are available\n+Only one Remote Service can be executed each Time.\n+Parallel execution isn't supported.\n+The *Service Execution State* Channel is reporting the state.\n+State *Executed* is the final State when Execution is finished.\n+\n+| Channel Label           | Channel Group ID | Channel ID          | Type    | \n+|-------------------------|------------------|---------------------|---------|\n+| Activate Flash Lights   | remote           | light               | Switch  |\n+| Find Vehicle            | remote           | finder              | Switch  |\n+| Lock Doors              | remote           | lock                | Switch  |\n+| Unlock Doors            | remote           | unlock              | Switch  |\n+| Horn Blow               | remote           | horn                | Switch  |\n+| Active Air Conditioning | remote           | climate             | Switch  |\n+| Service Execution State | remote           | state               | STring  |", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTEyNzI5NQ=="}, "originalCommit": {"oid": "e0bfe93e13df4a3c5de5f8819b94ebf795664904"}, "originalPosition": 317}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEzNzg0NDkzOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.bmwconnecteddrive/README.md", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wN1QxNTo1ODowNVrOHd6aLA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQxNjo0NTo0NFrOH5LvMw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTEyNzcyNA==", "bodyText": "See above. Location.", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r501127724", "createdAt": "2020-10-07T15:58:05Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/README.md", "diffHunk": "@@ -0,0 +1,862 @@\n+# BMW ConnectedDrive Binding\n+\n+<img align=\"right\" src=\"./doc/bmw-connected.png\" width=\"150\" height=\"150\"/>\n+\n+The Binding provides a Connection between [BMWs ConnectedDrive Portal](https://www.bmw-connecteddrive.com/country-region-select/country-region-selection.html) and openHAB.\n+All Vehicles connected to an Account will be detected by the Discovery with the correct type \n+\n+* Conventional Fuel Vehicle\n+* Plugin-Hybrid Electrical Vehicle \n+* Battery Electric Vehicle with Range Extender\n+* Battery Electric Vehicle \n+\n+In addition Properties are attached with Information and Services provided by this Vehicle.\n+The provided data depends on \n+\n+1. the [Type](#Things) and \n+2. the Services mentioned in [Properties](#properties)\n+\n+Different Channel Groups are clustering all informations.\n+Check for each Group if it's supported for this Vehicle.\n+\n+Please note **this isn't a real-time Binding**. \n+If the Door is opened the state isn't transmitted and changed immediately. \n+This isn't a flaw in the Binding itself because the state in BMWs own ConnectedDrive App is also updated with some delay. \n+\n+## Supported Things\n+\n+### Bridge\n+\n+The Bridge establishes the Connection between BMW ConnectedDrive Portal and openHAB.\n+\n+| Name                       | Bridge Type ID | Description                                                |\n+|----------------------------|----------------|------------------------------------------------------------|\n+| BMW ConnectedDrive Account | account        | Access to BMW ConnectedDrive Portal for a specific user    |\n+\n+\n+### Things\n+\n+Four different Vehicle Types are provided. \n+They differ in the supported Channel Groups & Channels. \n+Conventional Fuel Vehicles have no _Charging Profile_, Electric Vehicles don't provide a _Fuel Range_. \n+For Hybrid Vehicles in addition to _Fuel and Electric Range_ the _Hybrid Range_ is shown.\n+ \n+| Name                                | Thing Type ID | Supported Channel Groups                                             |\n+|-------------------------------------|---------------|----------------------------------------------------------------------|\n+| BMW Electric Vehicle                | BEV           | status, range, location, service, check, charge, image, troubleshoot |\n+| BMW Electric Vehicle with REX       | BEV_REX       | status, range, location, service, check, charge, image, troubleshoot |\n+| BMW Plug-In-Hybrid Electric Vehicle | PHEV          | status, range, location, service, check, charge, image, troubleshoot |\n+| BMW Conventional Vehicle            | CONV          | status, range, location, service, check, image, troubleshoot         |\n+\n+ \n+#### Properties\n+\n+<img align=\"right\" src=\"./doc/properties.png\" width=\"500\" height=\"600\"/>\n+\n+For each Vehicle Properties are available. \n+Basically 3 Types of Information are registered as Properties\n+\n+* Informations regarding your Dealer with Address and Phone Number\n+* Which services are available / not available\n+* Vehicle Properties like Color, Model Type, Drive Train and Construction Year\n+\n+In the right picture  can see in *Services Activated* e.g. the *DoorLock* and *DoorUnlock* Services are mentioned. \n+This ensures [Channel Group _Remote Services_](#remote-services) is supporting Door lock and Door unlock.\n+\n+In  *Services Supported* the entry *LastDestination* is mentioned.\n+So it's valid to connect Channel Group [Last Destinations](#destinations) in order to display the last 3 Navigation Destinations.\n+\n+| Property Key       | Property Value      |  Supported Channel Groups    |\n+|--------------------|---------------------|------------------------------|\n+| Services Supported | Statistics          | last-trip, lifetime          |\n+| Services Supported | LastDestinations    | destinations                 |\n+| Services Activated | list of services    | remote                       |\n+\n+\n+## Discovery\n+\n+Auto Discovery is starting after creation of the Bridge towards BMW ConnectedDrive. \n+A list of your registered Vehicles is queried and all found Vehicles are added in Inbox.\n+Unique Identifier is the *Vehicle Identification Number* (VIN). \n+If a Thing is already declared in a  *.things configuration* Discovery won't highlight it again.\n+Properties will be attached to predefined Vehicles if the VIN is matching.\n+\n+## Configuration\n+\n+### Bridge\n+\n+| Parameter       | Type    | Description                                                             |           \n+|-----------------|---------|-------------------------------------------------------------------------|\n+| userName        | text    | BMW Connected Drive Username                  |\n+| password        | text    | BMW Connected Drive Password                  |\n+| region          | text    | Select Region in order to connect to the appropriate BMW Server.   |\n+\n+The region Configuration has 3 different possibilities\n+\n+* _NORTH_AMERICA_\n+* _CHINA_\n+* _ROW_ for Rest of World\n+\n+### Thing\n+\n+Same Configuration is needed for all Things\n+\n+| Parameter       | Type    | Description                           |           \n+|-----------------|---------|---------------------------------------|\n+| vin             | text    | Vehicle Identification Number (VIN)   |\n+| refreshInterval | integer | Refresh Interval in Minutes           |\n+| units           | text    | Unit Selection                        |\n+| imageSize       | integer | Image Size                            |\n+| imageViewport   | text    | Image Viewport                        |\n+\n+The units can be configured in 3 ways\n+\n+* _AUTODETECT_ selects Miles for US & UK, Kilometer otherwise\n+* _METRIC_ selects directly Kilometers\n+* _IMPERIAL_ selects directly Miles\n+\n+The imageVieport allows to show the Vehicle from different angels.\n+Possible values are \n+\n+* FRONT\n+* REAR\n+* SIDE\n+* DASHBOARD\n+* DRIVERDOOR\n+\n+## Channels\n+\n+There are many Channels available for each Vehicle. \n+For better overview they are clustered in different Channel Groups.\n+The Channel Groups are different for the Vehicle Types, on the build-in Sensors of the Vehicle and the activated Services.\n+\n+### Bridge Channels\n+\n+If the Vehicle isn't found in the Discovery force a log of Fingerprint Data which helps to analyze the problem.\n+Please check [TroubleShooting Section](#TroubleShooting) for further advice.\n+\n+| Channel Label         | Channel ID            | Type   | Description                                       |\n+|-----------------------|-----------------------|--------|---------------------------------------------------|\n+| Discovery Fingerprint | discovery-fingerprint | Switch | Forcing a log entry to analyze Discovery Problems |\n+\n+### Thing Channel Groups \n+\n+#### Vehicle Status\n+\n+Reflects Status of the Vehicle.\n+Available for all Vehicles, Read-only.\n+\n+| Channel Label             | Channel Group ID | Channel ID          | Type          | Description                                                                       |\n+|---------------------------|------------------|---------------------|---------------|-----------------------------------------------------------------------------------|\n+| Overall Door Status       | status           | doors               | String        | **Closed** if all closed otherwise **Open**. **Unknown** if no data is delivered  |\n+| Overall Window Status     | status           | windows             | String        | **Closed** if all closed otherwise **Open** or **Intermediate**. **Unknown** if no data is delivered   |\n+| Doors Locked              | status           | lock                | String        | Status if Doors are locked or unlocked                                            |\n+| Next Service Date         | status           | service-date        | DateTime      | Date of Upcoming Service                                                          |\n+| Mileage till Next Service | status           | service-mileage     | Number:Length | Mileage till Upcoming Service                                                     |\n+| Check Control             | status           | check-control       | String        | Indicator if CheckControl is **Active** or **Not Active**. **Unknown** if no data is delivered         |\n+| Charging Status           | status           | charge              | String        | Only available for PHEV, BEV_REX and BEV                                          |\n+| Last Status Timestamp     | status           | last-update         | DateTime      | Date and Time of last status update.                                              |\n+\n+See [further details for DateTime](#last-status-update-timestamp) in case of wrong timestamp values\n+\n+#### Services\n+\n+Group for all upcoming Services with Description, Service Date and / or Service Mileage\n+It's designed as [List Interface](#list-interface) so all upcoming Services can be checked.\n+\n+| Channel Label                  | Channel Group ID | Channel ID          | Type           | \n+|--------------------------------|------------------|---------------------|----------------|\n+| Service Name                   | service          | name                | String         |\n+| Service Date                   | service          | date                | Number         |\n+| Mileage till Service           | service          | mileage             | Number:Length  |\n+| Number of Scheduled Services   | service          | size                | String         |\n+| Current Selected Service Index | service          | index               | Number         |\n+| Select next Service            | service          | next                | Switch         |\n+\n+#### Check Control\n+\n+Group for all current active CheckControl Messages.\n+It's designed as [List Interface](#list-interface) to show all active Messages.\n+\n+| Channel Label                   | Channel Group ID | Channel ID          | Type           | \n+|---------------------------------|------------------|---------------------|----------------|\n+| CheckControl Description        | check            | name                | String         |\n+| CheckControl Mileage Occurrence | check            | mileage             | Number:Length  |\n+| Active CheckControl Messages    | check            | size                | String         |\n+| Selected CheckControl Message   | check            | index               | Number         |\n+| Next CheckControl Message       | check            | next                | Switch         |\n+\n+#### Doors Details\n+\n+Detailed Status of all Doors and Windows\n+Available for all Vehicles, Read-only. \n+\n+| Channel Label              | Channel Group ID | Channel ID              | Type          | \n+|----------------------------|------------------|-------------------------|---------------|\n+| Driver Door                | doors            | driver-front            | String        |\n+| Driver Door Rear           | doors            | driver-rear             | String        |\n+| Passenger Door             | doors            | passenger-front         | String        |\n+| Passenger Door Rear        | doors            | passenger-rear          | String        |\n+| Trunk                      | doors            | trunk                   | String        |\n+| Hood                       | doors            | hood                    | String        |\n+| Driver Door Window         | doors            | window-driver-front     | String        |\n+| Driver Door Rear Window    | doors            | window-driver-rear      | String        |\n+| Passenger Door Window      | doors            | window-passenger-front  | String        |\n+| Passenger Door Rear Window | doors            | window-passenger-rear   | String        |\n+| Rear Window                | doors            | window-rear             | String        |\n+| Sunroof                    | doors            | sunroof                 | String        |\n+\n+Following Strings will be delivered\n+\n+* UNKNOWN - no status data available\n+* INVALID - this item isn't applicable for this Vehicle\n+* CLOSED - the Door / Window is closed\n+* OPEN - the Door / Window is open\n+* INTERMEDIATE - Window in intermediate position, not applicable for Doors\n+\n+#### Range Data\n+\n+Based on Vehicle Type (Thing Type ID) some Channels are presented or not. \n+Conventional Fuel Vehicles don't provide *Electric Range* and Battery Electric Vehicles don't show *Range Fuel*.\n+Hybrid Vehicles have both and in addition *Hybrid Range*.\n+These are Read-only values.\n+\n+| Channel Label         | Channel Group ID | Channel ID            | Type                 | CONV | PHEV | BEV_REX | BEV |\n+|-----------------------|------------------|-----------------------|----------------------|------|------|---------|-----|\n+| Mileage               | range            | mileage               | Number:Length        |  X   |  X   |    X    |  X  |\n+| Fuel Range            | range            | range-fuel            | Number:Length        |  X   |  X   |    X    |     |\n+| Battery Range         | range            | range-electric        | Number:Length        |      |  X   |    X    |  X  | \n+| Hybrid Range          | range            | range-hybrid          | Number:Length        |      |  X   |    X    |     | \n+| Battery Charge Level  | range            | soc                   | Number:Dimensionless |      |  X   |    X    |  X  |\n+| Remaining Fuel        | range            | remaining-fuel        | Number:Volume        |  X   |  X   |    X    |     | \n+| Fuel Range Radius     | range            | range-radius-fuel     | Number:Length        |  X   |  X   |    X    |     | \n+| Electric Range Radius | range            | range-radius-electric | Number:Length        |      |  X   |    X    |  X  | \n+| Hybrid Range Radius   | range            | range-radius-hybrid   | Number:Length        |      |  X   |    X    |     | \n+\n+See Description [Range vs Range Radius](#range-vs-range-radius) to get more information\n+\n+#### Charge Profile\n+\n+Valid for Electric and Hybrid Vehicles\n+These are Read-only values.\n+\n+| Channel Label                      | Channel Group ID | Channel ID          | Type   | \n+|------------------------------------|------------------|---------------------|--------|\n+| Air Conditioning at Departure Time | charge           | profile-climate     | Switch | \n+| Charging Mode for Profile          | charge           | profile-mode        | String | \n+| Charging Window Start Time         | charge           | window-start        | String | \n+| Charging Window End Time           | charge           | window-end          | String | \n+| Timer 1: Departure Time            | charge           | timer1-departure    | String | \n+| Timer 1: Scheduled Days            | charge           | timer1-days         | String | \n+| Timer 1: Enabled                   | charge           | timer1-enabled      | Switch | \n+| Timer 2: Departure Time            | charge           | timer2-departure    | String | \n+| Timer 2: Scheduled Days            | charge           | timer2-days         | String | \n+| Timer 2: Enabled                   | charge           | timer2-enabled      | Switch | \n+| Timer 3: Departure Time            | charge           | timer3-departure    | String | \n+| Timer 3: Scheduled Days            | charge           | timer3-days         | String | \n+| Timer 3: Enabled                   | charge           | timer3-enabled      | Switch | \n+\n+\n+#### Location\n+\n+Available for all Vehicles.\n+These are Read-only values.\n+\n+| Channel Label  | Channel Group ID | Channel ID          | Type         | \n+|----------------|------------------|---------------------|--------------|\n+| Latitude       | location         | latitude            | Number       | \n+| Longitude      | location         | longitude           | Number       |\n+| Heading        | location         | heading             | Number:Angle | \n+\n+#### Last Trip\n+\n+Check [Vehicle Properties](#Properties) if *Statistics* is present in *Services Supported*\n+These are Read-only values.\n+\n+| Channel Label                           | Channel Group ID | Channel ID                   | Type          |\n+|-----------------------------------------|------------------|------------------------------|---------------|\n+| Last Trip Date                          | last-trip        | date                         | DateTime      |\n+| Last Trip Duration                      | last-trip        | duration                     | Number:Time   |\n+| Average Power Consumption per 100 km    | last-trip        | average-consumption          | Number:Power  |\n+| Average Combined Consumption per 100 km | last-trip        | average-combined-consumption | Number:Volume |\n+| Average Power Recuperation per 100 km   | last-trip        | average-recuperation         | Number:Power  |\n+| Last Trip Distance                      | last-trip        | distance                     | Number:Length |\n+| Distance since Last Charge              | last-trip        | distance-since-charging      | Number:Length |\n+\n+\n+#### Lifetime Statistics\n+\n+Check [Vehicle Properties](#Properties) if *Statistics* is present in *Services Supported*\n+These are Read-only values.\n+\n+| Channel Label                           | Channel Group ID | Channel ID                   | Type          | \n+|-----------------------------------------|------------------|------------------------------|---------------|\n+| Average Power Consumption per 100 km    | lifetime         | average-consumption          | Number:Power  |\n+| Average Power Recuperation per 100 km   | lifetime         | average-recuperation         | Number:Power  |\n+| Cumulated Electric Driven Distance      | lifetime         | cumulated-driven-distance    | Number:Length |\n+| Average Combined Consumption per 100 km | lifetime         | average-combined-consumption | Number:Volume |\n+| Longest Distance with one Charge        | lifetime         | single-longest-distance      | Number:Length |\n+\n+\n+#### Remote Services\n+\n+Check [Vehicle Properties](#Properties) *Services Activated* which Remote Services are available\n+Only one Remote Service can be executed each Time.\n+Parallel execution isn't supported.\n+The *Service Execution State* Channel is reporting the state.\n+State *Executed* is the final State when Execution is finished.\n+\n+| Channel Label           | Channel Group ID | Channel ID          | Type    | \n+|-------------------------|------------------|---------------------|---------|\n+| Activate Flash Lights   | remote           | light               | Switch  |\n+| Find Vehicle            | remote           | finder              | Switch  |\n+| Lock Doors              | remote           | lock                | Switch  |\n+| Unlock Doors            | remote           | unlock              | Switch  |\n+| Horn Blow               | remote           | horn                | Switch  |\n+| Active Air Conditioning | remote           | climate             | Switch  |\n+| Service Execution State | remote           | state               | STring  |\n+\n+#### Destinations\n+\n+Check [Vehicle Properties](#Properties) if *LastDestinations* is present in *Services Supported*\n+It's designed as [List Interface](#list-interface) in order to have access to all stored Destinations.\n+\n+| Channel Label                    | Channel Group ID | Channel ID          | Type    | \n+|----------------------------------|------------------|---------------------|---------|\n+| Destination Name                 | destination      | name                | String  |\n+| Destination Latitude             | destination      | latitude            | Number  |\n+| Destination Longitude            | destination      | longitude           | Number  |", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e0bfe93e13df4a3c5de5f8819b94ebf795664904"}, "originalPosition": 328}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTcyMzE4Nw==", "bodyText": "Changed to Location.", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r529723187", "createdAt": "2020-11-24T16:45:44Z", "author": {"login": "weymann"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/README.md", "diffHunk": "@@ -0,0 +1,862 @@\n+# BMW ConnectedDrive Binding\n+\n+<img align=\"right\" src=\"./doc/bmw-connected.png\" width=\"150\" height=\"150\"/>\n+\n+The Binding provides a Connection between [BMWs ConnectedDrive Portal](https://www.bmw-connecteddrive.com/country-region-select/country-region-selection.html) and openHAB.\n+All Vehicles connected to an Account will be detected by the Discovery with the correct type \n+\n+* Conventional Fuel Vehicle\n+* Plugin-Hybrid Electrical Vehicle \n+* Battery Electric Vehicle with Range Extender\n+* Battery Electric Vehicle \n+\n+In addition Properties are attached with Information and Services provided by this Vehicle.\n+The provided data depends on \n+\n+1. the [Type](#Things) and \n+2. the Services mentioned in [Properties](#properties)\n+\n+Different Channel Groups are clustering all informations.\n+Check for each Group if it's supported for this Vehicle.\n+\n+Please note **this isn't a real-time Binding**. \n+If the Door is opened the state isn't transmitted and changed immediately. \n+This isn't a flaw in the Binding itself because the state in BMWs own ConnectedDrive App is also updated with some delay. \n+\n+## Supported Things\n+\n+### Bridge\n+\n+The Bridge establishes the Connection between BMW ConnectedDrive Portal and openHAB.\n+\n+| Name                       | Bridge Type ID | Description                                                |\n+|----------------------------|----------------|------------------------------------------------------------|\n+| BMW ConnectedDrive Account | account        | Access to BMW ConnectedDrive Portal for a specific user    |\n+\n+\n+### Things\n+\n+Four different Vehicle Types are provided. \n+They differ in the supported Channel Groups & Channels. \n+Conventional Fuel Vehicles have no _Charging Profile_, Electric Vehicles don't provide a _Fuel Range_. \n+For Hybrid Vehicles in addition to _Fuel and Electric Range_ the _Hybrid Range_ is shown.\n+ \n+| Name                                | Thing Type ID | Supported Channel Groups                                             |\n+|-------------------------------------|---------------|----------------------------------------------------------------------|\n+| BMW Electric Vehicle                | BEV           | status, range, location, service, check, charge, image, troubleshoot |\n+| BMW Electric Vehicle with REX       | BEV_REX       | status, range, location, service, check, charge, image, troubleshoot |\n+| BMW Plug-In-Hybrid Electric Vehicle | PHEV          | status, range, location, service, check, charge, image, troubleshoot |\n+| BMW Conventional Vehicle            | CONV          | status, range, location, service, check, image, troubleshoot         |\n+\n+ \n+#### Properties\n+\n+<img align=\"right\" src=\"./doc/properties.png\" width=\"500\" height=\"600\"/>\n+\n+For each Vehicle Properties are available. \n+Basically 3 Types of Information are registered as Properties\n+\n+* Informations regarding your Dealer with Address and Phone Number\n+* Which services are available / not available\n+* Vehicle Properties like Color, Model Type, Drive Train and Construction Year\n+\n+In the right picture  can see in *Services Activated* e.g. the *DoorLock* and *DoorUnlock* Services are mentioned. \n+This ensures [Channel Group _Remote Services_](#remote-services) is supporting Door lock and Door unlock.\n+\n+In  *Services Supported* the entry *LastDestination* is mentioned.\n+So it's valid to connect Channel Group [Last Destinations](#destinations) in order to display the last 3 Navigation Destinations.\n+\n+| Property Key       | Property Value      |  Supported Channel Groups    |\n+|--------------------|---------------------|------------------------------|\n+| Services Supported | Statistics          | last-trip, lifetime          |\n+| Services Supported | LastDestinations    | destinations                 |\n+| Services Activated | list of services    | remote                       |\n+\n+\n+## Discovery\n+\n+Auto Discovery is starting after creation of the Bridge towards BMW ConnectedDrive. \n+A list of your registered Vehicles is queried and all found Vehicles are added in Inbox.\n+Unique Identifier is the *Vehicle Identification Number* (VIN). \n+If a Thing is already declared in a  *.things configuration* Discovery won't highlight it again.\n+Properties will be attached to predefined Vehicles if the VIN is matching.\n+\n+## Configuration\n+\n+### Bridge\n+\n+| Parameter       | Type    | Description                                                             |           \n+|-----------------|---------|-------------------------------------------------------------------------|\n+| userName        | text    | BMW Connected Drive Username                  |\n+| password        | text    | BMW Connected Drive Password                  |\n+| region          | text    | Select Region in order to connect to the appropriate BMW Server.   |\n+\n+The region Configuration has 3 different possibilities\n+\n+* _NORTH_AMERICA_\n+* _CHINA_\n+* _ROW_ for Rest of World\n+\n+### Thing\n+\n+Same Configuration is needed for all Things\n+\n+| Parameter       | Type    | Description                           |           \n+|-----------------|---------|---------------------------------------|\n+| vin             | text    | Vehicle Identification Number (VIN)   |\n+| refreshInterval | integer | Refresh Interval in Minutes           |\n+| units           | text    | Unit Selection                        |\n+| imageSize       | integer | Image Size                            |\n+| imageViewport   | text    | Image Viewport                        |\n+\n+The units can be configured in 3 ways\n+\n+* _AUTODETECT_ selects Miles for US & UK, Kilometer otherwise\n+* _METRIC_ selects directly Kilometers\n+* _IMPERIAL_ selects directly Miles\n+\n+The imageVieport allows to show the Vehicle from different angels.\n+Possible values are \n+\n+* FRONT\n+* REAR\n+* SIDE\n+* DASHBOARD\n+* DRIVERDOOR\n+\n+## Channels\n+\n+There are many Channels available for each Vehicle. \n+For better overview they are clustered in different Channel Groups.\n+The Channel Groups are different for the Vehicle Types, on the build-in Sensors of the Vehicle and the activated Services.\n+\n+### Bridge Channels\n+\n+If the Vehicle isn't found in the Discovery force a log of Fingerprint Data which helps to analyze the problem.\n+Please check [TroubleShooting Section](#TroubleShooting) for further advice.\n+\n+| Channel Label         | Channel ID            | Type   | Description                                       |\n+|-----------------------|-----------------------|--------|---------------------------------------------------|\n+| Discovery Fingerprint | discovery-fingerprint | Switch | Forcing a log entry to analyze Discovery Problems |\n+\n+### Thing Channel Groups \n+\n+#### Vehicle Status\n+\n+Reflects Status of the Vehicle.\n+Available for all Vehicles, Read-only.\n+\n+| Channel Label             | Channel Group ID | Channel ID          | Type          | Description                                                                       |\n+|---------------------------|------------------|---------------------|---------------|-----------------------------------------------------------------------------------|\n+| Overall Door Status       | status           | doors               | String        | **Closed** if all closed otherwise **Open**. **Unknown** if no data is delivered  |\n+| Overall Window Status     | status           | windows             | String        | **Closed** if all closed otherwise **Open** or **Intermediate**. **Unknown** if no data is delivered   |\n+| Doors Locked              | status           | lock                | String        | Status if Doors are locked or unlocked                                            |\n+| Next Service Date         | status           | service-date        | DateTime      | Date of Upcoming Service                                                          |\n+| Mileage till Next Service | status           | service-mileage     | Number:Length | Mileage till Upcoming Service                                                     |\n+| Check Control             | status           | check-control       | String        | Indicator if CheckControl is **Active** or **Not Active**. **Unknown** if no data is delivered         |\n+| Charging Status           | status           | charge              | String        | Only available for PHEV, BEV_REX and BEV                                          |\n+| Last Status Timestamp     | status           | last-update         | DateTime      | Date and Time of last status update.                                              |\n+\n+See [further details for DateTime](#last-status-update-timestamp) in case of wrong timestamp values\n+\n+#### Services\n+\n+Group for all upcoming Services with Description, Service Date and / or Service Mileage\n+It's designed as [List Interface](#list-interface) so all upcoming Services can be checked.\n+\n+| Channel Label                  | Channel Group ID | Channel ID          | Type           | \n+|--------------------------------|------------------|---------------------|----------------|\n+| Service Name                   | service          | name                | String         |\n+| Service Date                   | service          | date                | Number         |\n+| Mileage till Service           | service          | mileage             | Number:Length  |\n+| Number of Scheduled Services   | service          | size                | String         |\n+| Current Selected Service Index | service          | index               | Number         |\n+| Select next Service            | service          | next                | Switch         |\n+\n+#### Check Control\n+\n+Group for all current active CheckControl Messages.\n+It's designed as [List Interface](#list-interface) to show all active Messages.\n+\n+| Channel Label                   | Channel Group ID | Channel ID          | Type           | \n+|---------------------------------|------------------|---------------------|----------------|\n+| CheckControl Description        | check            | name                | String         |\n+| CheckControl Mileage Occurrence | check            | mileage             | Number:Length  |\n+| Active CheckControl Messages    | check            | size                | String         |\n+| Selected CheckControl Message   | check            | index               | Number         |\n+| Next CheckControl Message       | check            | next                | Switch         |\n+\n+#### Doors Details\n+\n+Detailed Status of all Doors and Windows\n+Available for all Vehicles, Read-only. \n+\n+| Channel Label              | Channel Group ID | Channel ID              | Type          | \n+|----------------------------|------------------|-------------------------|---------------|\n+| Driver Door                | doors            | driver-front            | String        |\n+| Driver Door Rear           | doors            | driver-rear             | String        |\n+| Passenger Door             | doors            | passenger-front         | String        |\n+| Passenger Door Rear        | doors            | passenger-rear          | String        |\n+| Trunk                      | doors            | trunk                   | String        |\n+| Hood                       | doors            | hood                    | String        |\n+| Driver Door Window         | doors            | window-driver-front     | String        |\n+| Driver Door Rear Window    | doors            | window-driver-rear      | String        |\n+| Passenger Door Window      | doors            | window-passenger-front  | String        |\n+| Passenger Door Rear Window | doors            | window-passenger-rear   | String        |\n+| Rear Window                | doors            | window-rear             | String        |\n+| Sunroof                    | doors            | sunroof                 | String        |\n+\n+Following Strings will be delivered\n+\n+* UNKNOWN - no status data available\n+* INVALID - this item isn't applicable for this Vehicle\n+* CLOSED - the Door / Window is closed\n+* OPEN - the Door / Window is open\n+* INTERMEDIATE - Window in intermediate position, not applicable for Doors\n+\n+#### Range Data\n+\n+Based on Vehicle Type (Thing Type ID) some Channels are presented or not. \n+Conventional Fuel Vehicles don't provide *Electric Range* and Battery Electric Vehicles don't show *Range Fuel*.\n+Hybrid Vehicles have both and in addition *Hybrid Range*.\n+These are Read-only values.\n+\n+| Channel Label         | Channel Group ID | Channel ID            | Type                 | CONV | PHEV | BEV_REX | BEV |\n+|-----------------------|------------------|-----------------------|----------------------|------|------|---------|-----|\n+| Mileage               | range            | mileage               | Number:Length        |  X   |  X   |    X    |  X  |\n+| Fuel Range            | range            | range-fuel            | Number:Length        |  X   |  X   |    X    |     |\n+| Battery Range         | range            | range-electric        | Number:Length        |      |  X   |    X    |  X  | \n+| Hybrid Range          | range            | range-hybrid          | Number:Length        |      |  X   |    X    |     | \n+| Battery Charge Level  | range            | soc                   | Number:Dimensionless |      |  X   |    X    |  X  |\n+| Remaining Fuel        | range            | remaining-fuel        | Number:Volume        |  X   |  X   |    X    |     | \n+| Fuel Range Radius     | range            | range-radius-fuel     | Number:Length        |  X   |  X   |    X    |     | \n+| Electric Range Radius | range            | range-radius-electric | Number:Length        |      |  X   |    X    |  X  | \n+| Hybrid Range Radius   | range            | range-radius-hybrid   | Number:Length        |      |  X   |    X    |     | \n+\n+See Description [Range vs Range Radius](#range-vs-range-radius) to get more information\n+\n+#### Charge Profile\n+\n+Valid for Electric and Hybrid Vehicles\n+These are Read-only values.\n+\n+| Channel Label                      | Channel Group ID | Channel ID          | Type   | \n+|------------------------------------|------------------|---------------------|--------|\n+| Air Conditioning at Departure Time | charge           | profile-climate     | Switch | \n+| Charging Mode for Profile          | charge           | profile-mode        | String | \n+| Charging Window Start Time         | charge           | window-start        | String | \n+| Charging Window End Time           | charge           | window-end          | String | \n+| Timer 1: Departure Time            | charge           | timer1-departure    | String | \n+| Timer 1: Scheduled Days            | charge           | timer1-days         | String | \n+| Timer 1: Enabled                   | charge           | timer1-enabled      | Switch | \n+| Timer 2: Departure Time            | charge           | timer2-departure    | String | \n+| Timer 2: Scheduled Days            | charge           | timer2-days         | String | \n+| Timer 2: Enabled                   | charge           | timer2-enabled      | Switch | \n+| Timer 3: Departure Time            | charge           | timer3-departure    | String | \n+| Timer 3: Scheduled Days            | charge           | timer3-days         | String | \n+| Timer 3: Enabled                   | charge           | timer3-enabled      | Switch | \n+\n+\n+#### Location\n+\n+Available for all Vehicles.\n+These are Read-only values.\n+\n+| Channel Label  | Channel Group ID | Channel ID          | Type         | \n+|----------------|------------------|---------------------|--------------|\n+| Latitude       | location         | latitude            | Number       | \n+| Longitude      | location         | longitude           | Number       |\n+| Heading        | location         | heading             | Number:Angle | \n+\n+#### Last Trip\n+\n+Check [Vehicle Properties](#Properties) if *Statistics* is present in *Services Supported*\n+These are Read-only values.\n+\n+| Channel Label                           | Channel Group ID | Channel ID                   | Type          |\n+|-----------------------------------------|------------------|------------------------------|---------------|\n+| Last Trip Date                          | last-trip        | date                         | DateTime      |\n+| Last Trip Duration                      | last-trip        | duration                     | Number:Time   |\n+| Average Power Consumption per 100 km    | last-trip        | average-consumption          | Number:Power  |\n+| Average Combined Consumption per 100 km | last-trip        | average-combined-consumption | Number:Volume |\n+| Average Power Recuperation per 100 km   | last-trip        | average-recuperation         | Number:Power  |\n+| Last Trip Distance                      | last-trip        | distance                     | Number:Length |\n+| Distance since Last Charge              | last-trip        | distance-since-charging      | Number:Length |\n+\n+\n+#### Lifetime Statistics\n+\n+Check [Vehicle Properties](#Properties) if *Statistics* is present in *Services Supported*\n+These are Read-only values.\n+\n+| Channel Label                           | Channel Group ID | Channel ID                   | Type          | \n+|-----------------------------------------|------------------|------------------------------|---------------|\n+| Average Power Consumption per 100 km    | lifetime         | average-consumption          | Number:Power  |\n+| Average Power Recuperation per 100 km   | lifetime         | average-recuperation         | Number:Power  |\n+| Cumulated Electric Driven Distance      | lifetime         | cumulated-driven-distance    | Number:Length |\n+| Average Combined Consumption per 100 km | lifetime         | average-combined-consumption | Number:Volume |\n+| Longest Distance with one Charge        | lifetime         | single-longest-distance      | Number:Length |\n+\n+\n+#### Remote Services\n+\n+Check [Vehicle Properties](#Properties) *Services Activated* which Remote Services are available\n+Only one Remote Service can be executed each Time.\n+Parallel execution isn't supported.\n+The *Service Execution State* Channel is reporting the state.\n+State *Executed* is the final State when Execution is finished.\n+\n+| Channel Label           | Channel Group ID | Channel ID          | Type    | \n+|-------------------------|------------------|---------------------|---------|\n+| Activate Flash Lights   | remote           | light               | Switch  |\n+| Find Vehicle            | remote           | finder              | Switch  |\n+| Lock Doors              | remote           | lock                | Switch  |\n+| Unlock Doors            | remote           | unlock              | Switch  |\n+| Horn Blow               | remote           | horn                | Switch  |\n+| Active Air Conditioning | remote           | climate             | Switch  |\n+| Service Execution State | remote           | state               | STring  |\n+\n+#### Destinations\n+\n+Check [Vehicle Properties](#Properties) if *LastDestinations* is present in *Services Supported*\n+It's designed as [List Interface](#list-interface) in order to have access to all stored Destinations.\n+\n+| Channel Label                    | Channel Group ID | Channel ID          | Type    | \n+|----------------------------------|------------------|---------------------|---------|\n+| Destination Name                 | destination      | name                | String  |\n+| Destination Latitude             | destination      | latitude            | Number  |\n+| Destination Longitude            | destination      | longitude           | Number  |", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTEyNzcyNA=="}, "originalCommit": {"oid": "e0bfe93e13df4a3c5de5f8819b94ebf795664904"}, "originalPosition": 328}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEzNzg1MTQ4OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.bmwconnecteddrive/README.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wN1QxNTo1OTozMVrOHd6eWg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wN1QxNTo1OTozMVrOHd6eWg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTEyODc5NA==", "bodyText": "See above.", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r501128794", "createdAt": "2020-10-07T15:59:31Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/README.md", "diffHunk": "@@ -0,0 +1,862 @@\n+# BMW ConnectedDrive Binding\n+\n+<img align=\"right\" src=\"./doc/bmw-connected.png\" width=\"150\" height=\"150\"/>\n+\n+The Binding provides a Connection between [BMWs ConnectedDrive Portal](https://www.bmw-connecteddrive.com/country-region-select/country-region-selection.html) and openHAB.\n+All Vehicles connected to an Account will be detected by the Discovery with the correct type \n+\n+* Conventional Fuel Vehicle\n+* Plugin-Hybrid Electrical Vehicle \n+* Battery Electric Vehicle with Range Extender\n+* Battery Electric Vehicle \n+\n+In addition Properties are attached with Information and Services provided by this Vehicle.\n+The provided data depends on \n+\n+1. the [Type](#Things) and \n+2. the Services mentioned in [Properties](#properties)\n+\n+Different Channel Groups are clustering all informations.\n+Check for each Group if it's supported for this Vehicle.\n+\n+Please note **this isn't a real-time Binding**. \n+If the Door is opened the state isn't transmitted and changed immediately. \n+This isn't a flaw in the Binding itself because the state in BMWs own ConnectedDrive App is also updated with some delay. \n+\n+## Supported Things\n+\n+### Bridge\n+\n+The Bridge establishes the Connection between BMW ConnectedDrive Portal and openHAB.\n+\n+| Name                       | Bridge Type ID | Description                                                |\n+|----------------------------|----------------|------------------------------------------------------------|\n+| BMW ConnectedDrive Account | account        | Access to BMW ConnectedDrive Portal for a specific user    |\n+\n+\n+### Things\n+\n+Four different Vehicle Types are provided. \n+They differ in the supported Channel Groups & Channels. \n+Conventional Fuel Vehicles have no _Charging Profile_, Electric Vehicles don't provide a _Fuel Range_. \n+For Hybrid Vehicles in addition to _Fuel and Electric Range_ the _Hybrid Range_ is shown.\n+ \n+| Name                                | Thing Type ID | Supported Channel Groups                                             |\n+|-------------------------------------|---------------|----------------------------------------------------------------------|\n+| BMW Electric Vehicle                | BEV           | status, range, location, service, check, charge, image, troubleshoot |\n+| BMW Electric Vehicle with REX       | BEV_REX       | status, range, location, service, check, charge, image, troubleshoot |\n+| BMW Plug-In-Hybrid Electric Vehicle | PHEV          | status, range, location, service, check, charge, image, troubleshoot |\n+| BMW Conventional Vehicle            | CONV          | status, range, location, service, check, image, troubleshoot         |\n+\n+ \n+#### Properties\n+\n+<img align=\"right\" src=\"./doc/properties.png\" width=\"500\" height=\"600\"/>\n+\n+For each Vehicle Properties are available. \n+Basically 3 Types of Information are registered as Properties\n+\n+* Informations regarding your Dealer with Address and Phone Number\n+* Which services are available / not available\n+* Vehicle Properties like Color, Model Type, Drive Train and Construction Year\n+\n+In the right picture  can see in *Services Activated* e.g. the *DoorLock* and *DoorUnlock* Services are mentioned. \n+This ensures [Channel Group _Remote Services_](#remote-services) is supporting Door lock and Door unlock.\n+\n+In  *Services Supported* the entry *LastDestination* is mentioned.\n+So it's valid to connect Channel Group [Last Destinations](#destinations) in order to display the last 3 Navigation Destinations.\n+\n+| Property Key       | Property Value      |  Supported Channel Groups    |\n+|--------------------|---------------------|------------------------------|\n+| Services Supported | Statistics          | last-trip, lifetime          |\n+| Services Supported | LastDestinations    | destinations                 |\n+| Services Activated | list of services    | remote                       |\n+\n+\n+## Discovery\n+\n+Auto Discovery is starting after creation of the Bridge towards BMW ConnectedDrive. \n+A list of your registered Vehicles is queried and all found Vehicles are added in Inbox.\n+Unique Identifier is the *Vehicle Identification Number* (VIN). \n+If a Thing is already declared in a  *.things configuration* Discovery won't highlight it again.\n+Properties will be attached to predefined Vehicles if the VIN is matching.\n+\n+## Configuration\n+\n+### Bridge\n+\n+| Parameter       | Type    | Description                                                             |           \n+|-----------------|---------|-------------------------------------------------------------------------|\n+| userName        | text    | BMW Connected Drive Username                  |\n+| password        | text    | BMW Connected Drive Password                  |\n+| region          | text    | Select Region in order to connect to the appropriate BMW Server.   |\n+\n+The region Configuration has 3 different possibilities\n+\n+* _NORTH_AMERICA_\n+* _CHINA_\n+* _ROW_ for Rest of World\n+\n+### Thing\n+\n+Same Configuration is needed for all Things\n+\n+| Parameter       | Type    | Description                           |           \n+|-----------------|---------|---------------------------------------|\n+| vin             | text    | Vehicle Identification Number (VIN)   |\n+| refreshInterval | integer | Refresh Interval in Minutes           |\n+| units           | text    | Unit Selection                        |\n+| imageSize       | integer | Image Size                            |\n+| imageViewport   | text    | Image Viewport                        |\n+\n+The units can be configured in 3 ways\n+\n+* _AUTODETECT_ selects Miles for US & UK, Kilometer otherwise\n+* _METRIC_ selects directly Kilometers\n+* _IMPERIAL_ selects directly Miles\n+\n+The imageVieport allows to show the Vehicle from different angels.\n+Possible values are \n+\n+* FRONT\n+* REAR\n+* SIDE\n+* DASHBOARD\n+* DRIVERDOOR\n+\n+## Channels\n+\n+There are many Channels available for each Vehicle. \n+For better overview they are clustered in different Channel Groups.\n+The Channel Groups are different for the Vehicle Types, on the build-in Sensors of the Vehicle and the activated Services.\n+\n+### Bridge Channels\n+\n+If the Vehicle isn't found in the Discovery force a log of Fingerprint Data which helps to analyze the problem.\n+Please check [TroubleShooting Section](#TroubleShooting) for further advice.\n+\n+| Channel Label         | Channel ID            | Type   | Description                                       |\n+|-----------------------|-----------------------|--------|---------------------------------------------------|\n+| Discovery Fingerprint | discovery-fingerprint | Switch | Forcing a log entry to analyze Discovery Problems |\n+\n+### Thing Channel Groups \n+\n+#### Vehicle Status\n+\n+Reflects Status of the Vehicle.\n+Available for all Vehicles, Read-only.\n+\n+| Channel Label             | Channel Group ID | Channel ID          | Type          | Description                                                                       |\n+|---------------------------|------------------|---------------------|---------------|-----------------------------------------------------------------------------------|\n+| Overall Door Status       | status           | doors               | String        | **Closed** if all closed otherwise **Open**. **Unknown** if no data is delivered  |\n+| Overall Window Status     | status           | windows             | String        | **Closed** if all closed otherwise **Open** or **Intermediate**. **Unknown** if no data is delivered   |\n+| Doors Locked              | status           | lock                | String        | Status if Doors are locked or unlocked                                            |\n+| Next Service Date         | status           | service-date        | DateTime      | Date of Upcoming Service                                                          |\n+| Mileage till Next Service | status           | service-mileage     | Number:Length | Mileage till Upcoming Service                                                     |\n+| Check Control             | status           | check-control       | String        | Indicator if CheckControl is **Active** or **Not Active**. **Unknown** if no data is delivered         |\n+| Charging Status           | status           | charge              | String        | Only available for PHEV, BEV_REX and BEV                                          |\n+| Last Status Timestamp     | status           | last-update         | DateTime      | Date and Time of last status update.                                              |\n+\n+See [further details for DateTime](#last-status-update-timestamp) in case of wrong timestamp values\n+\n+#### Services\n+\n+Group for all upcoming Services with Description, Service Date and / or Service Mileage\n+It's designed as [List Interface](#list-interface) so all upcoming Services can be checked.\n+\n+| Channel Label                  | Channel Group ID | Channel ID          | Type           | \n+|--------------------------------|------------------|---------------------|----------------|\n+| Service Name                   | service          | name                | String         |\n+| Service Date                   | service          | date                | Number         |\n+| Mileage till Service           | service          | mileage             | Number:Length  |\n+| Number of Scheduled Services   | service          | size                | String         |\n+| Current Selected Service Index | service          | index               | Number         |\n+| Select next Service            | service          | next                | Switch         |\n+\n+#### Check Control\n+\n+Group for all current active CheckControl Messages.\n+It's designed as [List Interface](#list-interface) to show all active Messages.\n+\n+| Channel Label                   | Channel Group ID | Channel ID          | Type           | \n+|---------------------------------|------------------|---------------------|----------------|\n+| CheckControl Description        | check            | name                | String         |\n+| CheckControl Mileage Occurrence | check            | mileage             | Number:Length  |\n+| Active CheckControl Messages    | check            | size                | String         |\n+| Selected CheckControl Message   | check            | index               | Number         |\n+| Next CheckControl Message       | check            | next                | Switch         |\n+\n+#### Doors Details\n+\n+Detailed Status of all Doors and Windows\n+Available for all Vehicles, Read-only. \n+\n+| Channel Label              | Channel Group ID | Channel ID              | Type          | \n+|----------------------------|------------------|-------------------------|---------------|\n+| Driver Door                | doors            | driver-front            | String        |\n+| Driver Door Rear           | doors            | driver-rear             | String        |\n+| Passenger Door             | doors            | passenger-front         | String        |\n+| Passenger Door Rear        | doors            | passenger-rear          | String        |\n+| Trunk                      | doors            | trunk                   | String        |\n+| Hood                       | doors            | hood                    | String        |\n+| Driver Door Window         | doors            | window-driver-front     | String        |\n+| Driver Door Rear Window    | doors            | window-driver-rear      | String        |\n+| Passenger Door Window      | doors            | window-passenger-front  | String        |\n+| Passenger Door Rear Window | doors            | window-passenger-rear   | String        |\n+| Rear Window                | doors            | window-rear             | String        |\n+| Sunroof                    | doors            | sunroof                 | String        |\n+\n+Following Strings will be delivered\n+\n+* UNKNOWN - no status data available\n+* INVALID - this item isn't applicable for this Vehicle\n+* CLOSED - the Door / Window is closed\n+* OPEN - the Door / Window is open\n+* INTERMEDIATE - Window in intermediate position, not applicable for Doors\n+\n+#### Range Data\n+\n+Based on Vehicle Type (Thing Type ID) some Channels are presented or not. \n+Conventional Fuel Vehicles don't provide *Electric Range* and Battery Electric Vehicles don't show *Range Fuel*.\n+Hybrid Vehicles have both and in addition *Hybrid Range*.\n+These are Read-only values.\n+\n+| Channel Label         | Channel Group ID | Channel ID            | Type                 | CONV | PHEV | BEV_REX | BEV |\n+|-----------------------|------------------|-----------------------|----------------------|------|------|---------|-----|\n+| Mileage               | range            | mileage               | Number:Length        |  X   |  X   |    X    |  X  |\n+| Fuel Range            | range            | range-fuel            | Number:Length        |  X   |  X   |    X    |     |\n+| Battery Range         | range            | range-electric        | Number:Length        |      |  X   |    X    |  X  | \n+| Hybrid Range          | range            | range-hybrid          | Number:Length        |      |  X   |    X    |     | \n+| Battery Charge Level  | range            | soc                   | Number:Dimensionless |      |  X   |    X    |  X  |\n+| Remaining Fuel        | range            | remaining-fuel        | Number:Volume        |  X   |  X   |    X    |     | \n+| Fuel Range Radius     | range            | range-radius-fuel     | Number:Length        |  X   |  X   |    X    |     | \n+| Electric Range Radius | range            | range-radius-electric | Number:Length        |      |  X   |    X    |  X  | \n+| Hybrid Range Radius   | range            | range-radius-hybrid   | Number:Length        |      |  X   |    X    |     | \n+\n+See Description [Range vs Range Radius](#range-vs-range-radius) to get more information\n+\n+#### Charge Profile\n+\n+Valid for Electric and Hybrid Vehicles\n+These are Read-only values.\n+\n+| Channel Label                      | Channel Group ID | Channel ID          | Type   | \n+|------------------------------------|------------------|---------------------|--------|\n+| Air Conditioning at Departure Time | charge           | profile-climate     | Switch | \n+| Charging Mode for Profile          | charge           | profile-mode        | String | \n+| Charging Window Start Time         | charge           | window-start        | String | \n+| Charging Window End Time           | charge           | window-end          | String | \n+| Timer 1: Departure Time            | charge           | timer1-departure    | String | \n+| Timer 1: Scheduled Days            | charge           | timer1-days         | String | \n+| Timer 1: Enabled                   | charge           | timer1-enabled      | Switch | \n+| Timer 2: Departure Time            | charge           | timer2-departure    | String | \n+| Timer 2: Scheduled Days            | charge           | timer2-days         | String | \n+| Timer 2: Enabled                   | charge           | timer2-enabled      | Switch | \n+| Timer 3: Departure Time            | charge           | timer3-departure    | String | \n+| Timer 3: Scheduled Days            | charge           | timer3-days         | String | \n+| Timer 3: Enabled                   | charge           | timer3-enabled      | Switch | \n+\n+\n+#### Location\n+\n+Available for all Vehicles.\n+These are Read-only values.\n+\n+| Channel Label  | Channel Group ID | Channel ID          | Type         | \n+|----------------|------------------|---------------------|--------------|\n+| Latitude       | location         | latitude            | Number       | \n+| Longitude      | location         | longitude           | Number       |\n+| Heading        | location         | heading             | Number:Angle | \n+\n+#### Last Trip\n+\n+Check [Vehicle Properties](#Properties) if *Statistics* is present in *Services Supported*\n+These are Read-only values.\n+\n+| Channel Label                           | Channel Group ID | Channel ID                   | Type          |\n+|-----------------------------------------|------------------|------------------------------|---------------|\n+| Last Trip Date                          | last-trip        | date                         | DateTime      |\n+| Last Trip Duration                      | last-trip        | duration                     | Number:Time   |\n+| Average Power Consumption per 100 km    | last-trip        | average-consumption          | Number:Power  |\n+| Average Combined Consumption per 100 km | last-trip        | average-combined-consumption | Number:Volume |\n+| Average Power Recuperation per 100 km   | last-trip        | average-recuperation         | Number:Power  |\n+| Last Trip Distance                      | last-trip        | distance                     | Number:Length |\n+| Distance since Last Charge              | last-trip        | distance-since-charging      | Number:Length |\n+\n+\n+#### Lifetime Statistics\n+\n+Check [Vehicle Properties](#Properties) if *Statistics* is present in *Services Supported*\n+These are Read-only values.\n+\n+| Channel Label                           | Channel Group ID | Channel ID                   | Type          | \n+|-----------------------------------------|------------------|------------------------------|---------------|\n+| Average Power Consumption per 100 km    | lifetime         | average-consumption          | Number:Power  |\n+| Average Power Recuperation per 100 km   | lifetime         | average-recuperation         | Number:Power  |\n+| Cumulated Electric Driven Distance      | lifetime         | cumulated-driven-distance    | Number:Length |\n+| Average Combined Consumption per 100 km | lifetime         | average-combined-consumption | Number:Volume |\n+| Longest Distance with one Charge        | lifetime         | single-longest-distance      | Number:Length |\n+\n+\n+#### Remote Services\n+\n+Check [Vehicle Properties](#Properties) *Services Activated* which Remote Services are available\n+Only one Remote Service can be executed each Time.\n+Parallel execution isn't supported.\n+The *Service Execution State* Channel is reporting the state.\n+State *Executed* is the final State when Execution is finished.\n+\n+| Channel Label           | Channel Group ID | Channel ID          | Type    | \n+|-------------------------|------------------|---------------------|---------|\n+| Activate Flash Lights   | remote           | light               | Switch  |\n+| Find Vehicle            | remote           | finder              | Switch  |\n+| Lock Doors              | remote           | lock                | Switch  |\n+| Unlock Doors            | remote           | unlock              | Switch  |\n+| Horn Blow               | remote           | horn                | Switch  |\n+| Active Air Conditioning | remote           | climate             | Switch  |\n+| Service Execution State | remote           | state               | STring  |\n+\n+#### Destinations\n+\n+Check [Vehicle Properties](#Properties) if *LastDestinations* is present in *Services Supported*\n+It's designed as [List Interface](#list-interface) in order to have access to all stored Destinations.\n+\n+| Channel Label                    | Channel Group ID | Channel ID          | Type    | \n+|----------------------------------|------------------|---------------------|---------|\n+| Destination Name                 | destination      | name                | String  |\n+| Destination Latitude             | destination      | latitude            | Number  |\n+| Destination Longitude            | destination      | longitude           | Number  |\n+| Number of Available Destinations | destination      | size                | String  |\n+| Index of Selected Destination    | destination      | index               | Number  |\n+| Skip to Next Destination         | destination      | next                | Switch  |\n+\n+\n+#### Image\n+\n+Available for all Vehicles.\n+Picture can be modified regarding *Viewport* and *Size*.\n+See [Things Section](#thing) for Viewport possibilities and [Status Image](#status-image) for possible Use Cases.\n+\n+| Channel Label                 | Channel Group ID | Channel ID          | Type   | \n+|-------------------------------|------------------|---------------------|--------|\n+| Rendered Image of the Vehicle | image            | png                 | Image  |\n+| Image Viewport                | image            | view                | String |\n+| Image Picture Size            | image            | size                | Number |\n+\n+\n+#### Troubleshooting\n+\n+Available for all Vehicles!\n+Switch will log a *Vehicle Data Fingerprint* into the openHAB log.\n+Please check [TroubleShooting Section](#TroubleShooting) for further advice.\n+\n+| Channel Label                       | Channel Group ID | Channel ID          | Type   | Description                                       |\n+|-------------------------------------|------------------|---------------------|--------|---------------------------------------------------|\n+| Log Vehicle Fingerprint             | troubleshoot     | vehicle-fingerprint | Switch | Forces log entries in openHAB logger in order to raise issues |", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e0bfe93e13df4a3c5de5f8819b94ebf795664904"}, "originalPosition": 355}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEzNzg1NDg0OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.bmwconnecteddrive/README.md", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wN1QxNjowMDoxMlrOHd6gag==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yN1QxNTo1ODowMlrOILsMOQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTEyOTMyMg==", "bodyText": "Is there something missing?", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r501129322", "createdAt": "2020-10-07T16:00:12Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/README.md", "diffHunk": "@@ -0,0 +1,862 @@\n+# BMW ConnectedDrive Binding\n+\n+<img align=\"right\" src=\"./doc/bmw-connected.png\" width=\"150\" height=\"150\"/>\n+\n+The Binding provides a Connection between [BMWs ConnectedDrive Portal](https://www.bmw-connecteddrive.com/country-region-select/country-region-selection.html) and openHAB.\n+All Vehicles connected to an Account will be detected by the Discovery with the correct type \n+\n+* Conventional Fuel Vehicle\n+* Plugin-Hybrid Electrical Vehicle \n+* Battery Electric Vehicle with Range Extender\n+* Battery Electric Vehicle \n+\n+In addition Properties are attached with Information and Services provided by this Vehicle.\n+The provided data depends on \n+\n+1. the [Type](#Things) and \n+2. the Services mentioned in [Properties](#properties)\n+\n+Different Channel Groups are clustering all informations.\n+Check for each Group if it's supported for this Vehicle.\n+\n+Please note **this isn't a real-time Binding**. \n+If the Door is opened the state isn't transmitted and changed immediately. \n+This isn't a flaw in the Binding itself because the state in BMWs own ConnectedDrive App is also updated with some delay. \n+\n+## Supported Things\n+\n+### Bridge\n+\n+The Bridge establishes the Connection between BMW ConnectedDrive Portal and openHAB.\n+\n+| Name                       | Bridge Type ID | Description                                                |\n+|----------------------------|----------------|------------------------------------------------------------|\n+| BMW ConnectedDrive Account | account        | Access to BMW ConnectedDrive Portal for a specific user    |\n+\n+\n+### Things\n+\n+Four different Vehicle Types are provided. \n+They differ in the supported Channel Groups & Channels. \n+Conventional Fuel Vehicles have no _Charging Profile_, Electric Vehicles don't provide a _Fuel Range_. \n+For Hybrid Vehicles in addition to _Fuel and Electric Range_ the _Hybrid Range_ is shown.\n+ \n+| Name                                | Thing Type ID | Supported Channel Groups                                             |\n+|-------------------------------------|---------------|----------------------------------------------------------------------|\n+| BMW Electric Vehicle                | BEV           | status, range, location, service, check, charge, image, troubleshoot |\n+| BMW Electric Vehicle with REX       | BEV_REX       | status, range, location, service, check, charge, image, troubleshoot |\n+| BMW Plug-In-Hybrid Electric Vehicle | PHEV          | status, range, location, service, check, charge, image, troubleshoot |\n+| BMW Conventional Vehicle            | CONV          | status, range, location, service, check, image, troubleshoot         |\n+\n+ \n+#### Properties\n+\n+<img align=\"right\" src=\"./doc/properties.png\" width=\"500\" height=\"600\"/>\n+\n+For each Vehicle Properties are available. \n+Basically 3 Types of Information are registered as Properties\n+\n+* Informations regarding your Dealer with Address and Phone Number\n+* Which services are available / not available\n+* Vehicle Properties like Color, Model Type, Drive Train and Construction Year\n+\n+In the right picture  can see in *Services Activated* e.g. the *DoorLock* and *DoorUnlock* Services are mentioned. \n+This ensures [Channel Group _Remote Services_](#remote-services) is supporting Door lock and Door unlock.\n+\n+In  *Services Supported* the entry *LastDestination* is mentioned.\n+So it's valid to connect Channel Group [Last Destinations](#destinations) in order to display the last 3 Navigation Destinations.\n+\n+| Property Key       | Property Value      |  Supported Channel Groups    |\n+|--------------------|---------------------|------------------------------|\n+| Services Supported | Statistics          | last-trip, lifetime          |\n+| Services Supported | LastDestinations    | destinations                 |\n+| Services Activated | list of services    | remote                       |\n+\n+\n+## Discovery\n+\n+Auto Discovery is starting after creation of the Bridge towards BMW ConnectedDrive. \n+A list of your registered Vehicles is queried and all found Vehicles are added in Inbox.\n+Unique Identifier is the *Vehicle Identification Number* (VIN). \n+If a Thing is already declared in a  *.things configuration* Discovery won't highlight it again.\n+Properties will be attached to predefined Vehicles if the VIN is matching.\n+\n+## Configuration\n+\n+### Bridge\n+\n+| Parameter       | Type    | Description                                                             |           \n+|-----------------|---------|-------------------------------------------------------------------------|\n+| userName        | text    | BMW Connected Drive Username                  |\n+| password        | text    | BMW Connected Drive Password                  |\n+| region          | text    | Select Region in order to connect to the appropriate BMW Server.   |\n+\n+The region Configuration has 3 different possibilities\n+\n+* _NORTH_AMERICA_\n+* _CHINA_\n+* _ROW_ for Rest of World\n+\n+### Thing\n+\n+Same Configuration is needed for all Things\n+\n+| Parameter       | Type    | Description                           |           \n+|-----------------|---------|---------------------------------------|\n+| vin             | text    | Vehicle Identification Number (VIN)   |\n+| refreshInterval | integer | Refresh Interval in Minutes           |\n+| units           | text    | Unit Selection                        |\n+| imageSize       | integer | Image Size                            |\n+| imageViewport   | text    | Image Viewport                        |\n+\n+The units can be configured in 3 ways\n+\n+* _AUTODETECT_ selects Miles for US & UK, Kilometer otherwise\n+* _METRIC_ selects directly Kilometers\n+* _IMPERIAL_ selects directly Miles\n+\n+The imageVieport allows to show the Vehicle from different angels.\n+Possible values are \n+\n+* FRONT\n+* REAR\n+* SIDE\n+* DASHBOARD\n+* DRIVERDOOR\n+\n+## Channels\n+\n+There are many Channels available for each Vehicle. \n+For better overview they are clustered in different Channel Groups.\n+The Channel Groups are different for the Vehicle Types, on the build-in Sensors of the Vehicle and the activated Services.\n+\n+### Bridge Channels\n+\n+If the Vehicle isn't found in the Discovery force a log of Fingerprint Data which helps to analyze the problem.\n+Please check [TroubleShooting Section](#TroubleShooting) for further advice.\n+\n+| Channel Label         | Channel ID            | Type   | Description                                       |\n+|-----------------------|-----------------------|--------|---------------------------------------------------|\n+| Discovery Fingerprint | discovery-fingerprint | Switch | Forcing a log entry to analyze Discovery Problems |\n+\n+### Thing Channel Groups \n+\n+#### Vehicle Status\n+\n+Reflects Status of the Vehicle.\n+Available for all Vehicles, Read-only.\n+\n+| Channel Label             | Channel Group ID | Channel ID          | Type          | Description                                                                       |\n+|---------------------------|------------------|---------------------|---------------|-----------------------------------------------------------------------------------|\n+| Overall Door Status       | status           | doors               | String        | **Closed** if all closed otherwise **Open**. **Unknown** if no data is delivered  |\n+| Overall Window Status     | status           | windows             | String        | **Closed** if all closed otherwise **Open** or **Intermediate**. **Unknown** if no data is delivered   |\n+| Doors Locked              | status           | lock                | String        | Status if Doors are locked or unlocked                                            |\n+| Next Service Date         | status           | service-date        | DateTime      | Date of Upcoming Service                                                          |\n+| Mileage till Next Service | status           | service-mileage     | Number:Length | Mileage till Upcoming Service                                                     |\n+| Check Control             | status           | check-control       | String        | Indicator if CheckControl is **Active** or **Not Active**. **Unknown** if no data is delivered         |\n+| Charging Status           | status           | charge              | String        | Only available for PHEV, BEV_REX and BEV                                          |\n+| Last Status Timestamp     | status           | last-update         | DateTime      | Date and Time of last status update.                                              |\n+\n+See [further details for DateTime](#last-status-update-timestamp) in case of wrong timestamp values\n+\n+#### Services\n+\n+Group for all upcoming Services with Description, Service Date and / or Service Mileage\n+It's designed as [List Interface](#list-interface) so all upcoming Services can be checked.\n+\n+| Channel Label                  | Channel Group ID | Channel ID          | Type           | \n+|--------------------------------|------------------|---------------------|----------------|\n+| Service Name                   | service          | name                | String         |\n+| Service Date                   | service          | date                | Number         |\n+| Mileage till Service           | service          | mileage             | Number:Length  |\n+| Number of Scheduled Services   | service          | size                | String         |\n+| Current Selected Service Index | service          | index               | Number         |\n+| Select next Service            | service          | next                | Switch         |\n+\n+#### Check Control\n+\n+Group for all current active CheckControl Messages.\n+It's designed as [List Interface](#list-interface) to show all active Messages.\n+\n+| Channel Label                   | Channel Group ID | Channel ID          | Type           | \n+|---------------------------------|------------------|---------------------|----------------|\n+| CheckControl Description        | check            | name                | String         |\n+| CheckControl Mileage Occurrence | check            | mileage             | Number:Length  |\n+| Active CheckControl Messages    | check            | size                | String         |\n+| Selected CheckControl Message   | check            | index               | Number         |\n+| Next CheckControl Message       | check            | next                | Switch         |\n+\n+#### Doors Details\n+\n+Detailed Status of all Doors and Windows\n+Available for all Vehicles, Read-only. \n+\n+| Channel Label              | Channel Group ID | Channel ID              | Type          | \n+|----------------------------|------------------|-------------------------|---------------|\n+| Driver Door                | doors            | driver-front            | String        |\n+| Driver Door Rear           | doors            | driver-rear             | String        |\n+| Passenger Door             | doors            | passenger-front         | String        |\n+| Passenger Door Rear        | doors            | passenger-rear          | String        |\n+| Trunk                      | doors            | trunk                   | String        |\n+| Hood                       | doors            | hood                    | String        |\n+| Driver Door Window         | doors            | window-driver-front     | String        |\n+| Driver Door Rear Window    | doors            | window-driver-rear      | String        |\n+| Passenger Door Window      | doors            | window-passenger-front  | String        |\n+| Passenger Door Rear Window | doors            | window-passenger-rear   | String        |\n+| Rear Window                | doors            | window-rear             | String        |\n+| Sunroof                    | doors            | sunroof                 | String        |\n+\n+Following Strings will be delivered\n+\n+* UNKNOWN - no status data available\n+* INVALID - this item isn't applicable for this Vehicle\n+* CLOSED - the Door / Window is closed\n+* OPEN - the Door / Window is open\n+* INTERMEDIATE - Window in intermediate position, not applicable for Doors\n+\n+#### Range Data\n+\n+Based on Vehicle Type (Thing Type ID) some Channels are presented or not. \n+Conventional Fuel Vehicles don't provide *Electric Range* and Battery Electric Vehicles don't show *Range Fuel*.\n+Hybrid Vehicles have both and in addition *Hybrid Range*.\n+These are Read-only values.\n+\n+| Channel Label         | Channel Group ID | Channel ID            | Type                 | CONV | PHEV | BEV_REX | BEV |\n+|-----------------------|------------------|-----------------------|----------------------|------|------|---------|-----|\n+| Mileage               | range            | mileage               | Number:Length        |  X   |  X   |    X    |  X  |\n+| Fuel Range            | range            | range-fuel            | Number:Length        |  X   |  X   |    X    |     |\n+| Battery Range         | range            | range-electric        | Number:Length        |      |  X   |    X    |  X  | \n+| Hybrid Range          | range            | range-hybrid          | Number:Length        |      |  X   |    X    |     | \n+| Battery Charge Level  | range            | soc                   | Number:Dimensionless |      |  X   |    X    |  X  |\n+| Remaining Fuel        | range            | remaining-fuel        | Number:Volume        |  X   |  X   |    X    |     | \n+| Fuel Range Radius     | range            | range-radius-fuel     | Number:Length        |  X   |  X   |    X    |     | \n+| Electric Range Radius | range            | range-radius-electric | Number:Length        |      |  X   |    X    |  X  | \n+| Hybrid Range Radius   | range            | range-radius-hybrid   | Number:Length        |      |  X   |    X    |     | \n+\n+See Description [Range vs Range Radius](#range-vs-range-radius) to get more information\n+\n+#### Charge Profile\n+\n+Valid for Electric and Hybrid Vehicles\n+These are Read-only values.\n+\n+| Channel Label                      | Channel Group ID | Channel ID          | Type   | \n+|------------------------------------|------------------|---------------------|--------|\n+| Air Conditioning at Departure Time | charge           | profile-climate     | Switch | \n+| Charging Mode for Profile          | charge           | profile-mode        | String | \n+| Charging Window Start Time         | charge           | window-start        | String | \n+| Charging Window End Time           | charge           | window-end          | String | \n+| Timer 1: Departure Time            | charge           | timer1-departure    | String | \n+| Timer 1: Scheduled Days            | charge           | timer1-days         | String | \n+| Timer 1: Enabled                   | charge           | timer1-enabled      | Switch | \n+| Timer 2: Departure Time            | charge           | timer2-departure    | String | \n+| Timer 2: Scheduled Days            | charge           | timer2-days         | String | \n+| Timer 2: Enabled                   | charge           | timer2-enabled      | Switch | \n+| Timer 3: Departure Time            | charge           | timer3-departure    | String | \n+| Timer 3: Scheduled Days            | charge           | timer3-days         | String | \n+| Timer 3: Enabled                   | charge           | timer3-enabled      | Switch | \n+\n+\n+#### Location\n+\n+Available for all Vehicles.\n+These are Read-only values.\n+\n+| Channel Label  | Channel Group ID | Channel ID          | Type         | \n+|----------------|------------------|---------------------|--------------|\n+| Latitude       | location         | latitude            | Number       | \n+| Longitude      | location         | longitude           | Number       |\n+| Heading        | location         | heading             | Number:Angle | \n+\n+#### Last Trip\n+\n+Check [Vehicle Properties](#Properties) if *Statistics* is present in *Services Supported*\n+These are Read-only values.\n+\n+| Channel Label                           | Channel Group ID | Channel ID                   | Type          |\n+|-----------------------------------------|------------------|------------------------------|---------------|\n+| Last Trip Date                          | last-trip        | date                         | DateTime      |\n+| Last Trip Duration                      | last-trip        | duration                     | Number:Time   |\n+| Average Power Consumption per 100 km    | last-trip        | average-consumption          | Number:Power  |\n+| Average Combined Consumption per 100 km | last-trip        | average-combined-consumption | Number:Volume |\n+| Average Power Recuperation per 100 km   | last-trip        | average-recuperation         | Number:Power  |\n+| Last Trip Distance                      | last-trip        | distance                     | Number:Length |\n+| Distance since Last Charge              | last-trip        | distance-since-charging      | Number:Length |\n+\n+\n+#### Lifetime Statistics\n+\n+Check [Vehicle Properties](#Properties) if *Statistics* is present in *Services Supported*\n+These are Read-only values.\n+\n+| Channel Label                           | Channel Group ID | Channel ID                   | Type          | \n+|-----------------------------------------|------------------|------------------------------|---------------|\n+| Average Power Consumption per 100 km    | lifetime         | average-consumption          | Number:Power  |\n+| Average Power Recuperation per 100 km   | lifetime         | average-recuperation         | Number:Power  |\n+| Cumulated Electric Driven Distance      | lifetime         | cumulated-driven-distance    | Number:Length |\n+| Average Combined Consumption per 100 km | lifetime         | average-combined-consumption | Number:Volume |\n+| Longest Distance with one Charge        | lifetime         | single-longest-distance      | Number:Length |\n+\n+\n+#### Remote Services\n+\n+Check [Vehicle Properties](#Properties) *Services Activated* which Remote Services are available\n+Only one Remote Service can be executed each Time.\n+Parallel execution isn't supported.\n+The *Service Execution State* Channel is reporting the state.\n+State *Executed* is the final State when Execution is finished.\n+\n+| Channel Label           | Channel Group ID | Channel ID          | Type    | \n+|-------------------------|------------------|---------------------|---------|\n+| Activate Flash Lights   | remote           | light               | Switch  |\n+| Find Vehicle            | remote           | finder              | Switch  |\n+| Lock Doors              | remote           | lock                | Switch  |\n+| Unlock Doors            | remote           | unlock              | Switch  |\n+| Horn Blow               | remote           | horn                | Switch  |\n+| Active Air Conditioning | remote           | climate             | Switch  |\n+| Service Execution State | remote           | state               | STring  |\n+\n+#### Destinations\n+\n+Check [Vehicle Properties](#Properties) if *LastDestinations* is present in *Services Supported*\n+It's designed as [List Interface](#list-interface) in order to have access to all stored Destinations.\n+\n+| Channel Label                    | Channel Group ID | Channel ID          | Type    | \n+|----------------------------------|------------------|---------------------|---------|\n+| Destination Name                 | destination      | name                | String  |\n+| Destination Latitude             | destination      | latitude            | Number  |\n+| Destination Longitude            | destination      | longitude           | Number  |\n+| Number of Available Destinations | destination      | size                | String  |\n+| Index of Selected Destination    | destination      | index               | Number  |\n+| Skip to Next Destination         | destination      | next                | Switch  |\n+\n+\n+#### Image\n+\n+Available for all Vehicles.\n+Picture can be modified regarding *Viewport* and *Size*.\n+See [Things Section](#thing) for Viewport possibilities and [Status Image](#status-image) for possible Use Cases.\n+\n+| Channel Label                 | Channel Group ID | Channel ID          | Type   | \n+|-------------------------------|------------------|---------------------|--------|\n+| Rendered Image of the Vehicle | image            | png                 | Image  |\n+| Image Viewport                | image            | view                | String |\n+| Image Picture Size            | image            | size                | Number |\n+\n+\n+#### Troubleshooting\n+\n+Available for all Vehicles!\n+Switch will log a *Vehicle Data Fingerprint* into the openHAB log.\n+Please check [TroubleShooting Section](#TroubleShooting) for further advice.\n+\n+| Channel Label                       | Channel Group ID | Channel ID          | Type   | Description                                       |\n+|-------------------------------------|------------------|---------------------|--------|---------------------------------------------------|\n+| Log Vehicle Fingerprint             | troubleshoot     | vehicle-fingerprint | Switch | Forces log entries in openHAB logger in order to raise issues |\n+\n+## Further Descriptions\n+\n+### List Interface\n+\n+Currently there are 3 occurrences of dynamic data delivered as Lists\n+\n+* Upcoming Services\n+* Check Control Messages\n+* Last Destinations\n+\n+In order to provide all data the lists are organized the following way based on the Service Group example\n+\n+* **size** is the total length of the list. Read-only.\n+* **index** is the current selected index starting with 0 => list with size 10, valid index is between 0 - 9. If the index is set to _out of bounds_ it's set to first element. Read-write.\n+* **next** declares a switch for scrolling forward through the list in an endless way. Reaching end of list will start again from 0. Read-write.\n+* **name**, **mileage** and **date** declares the list item. It will change when setting new index or perform next. Read-only.\n+\n+### Range vs Range Radius\n+\n+<img align=\"right\" src=\"./doc/range-radius.png\" width=\"400\" height=\"350\"/>\n+\n+ will observe differences in the Vehicle Range and Range Radius values. ", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e0bfe93e13df4a3c5de5f8819b94ebf795664904"}, "originalPosition": 378}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTEyOTI3Mw==", "bodyText": "Corrected", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r549129273", "createdAt": "2020-12-27T15:58:02Z", "author": {"login": "weymann"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/README.md", "diffHunk": "@@ -0,0 +1,862 @@\n+# BMW ConnectedDrive Binding\n+\n+<img align=\"right\" src=\"./doc/bmw-connected.png\" width=\"150\" height=\"150\"/>\n+\n+The Binding provides a Connection between [BMWs ConnectedDrive Portal](https://www.bmw-connecteddrive.com/country-region-select/country-region-selection.html) and openHAB.\n+All Vehicles connected to an Account will be detected by the Discovery with the correct type \n+\n+* Conventional Fuel Vehicle\n+* Plugin-Hybrid Electrical Vehicle \n+* Battery Electric Vehicle with Range Extender\n+* Battery Electric Vehicle \n+\n+In addition Properties are attached with Information and Services provided by this Vehicle.\n+The provided data depends on \n+\n+1. the [Type](#Things) and \n+2. the Services mentioned in [Properties](#properties)\n+\n+Different Channel Groups are clustering all informations.\n+Check for each Group if it's supported for this Vehicle.\n+\n+Please note **this isn't a real-time Binding**. \n+If the Door is opened the state isn't transmitted and changed immediately. \n+This isn't a flaw in the Binding itself because the state in BMWs own ConnectedDrive App is also updated with some delay. \n+\n+## Supported Things\n+\n+### Bridge\n+\n+The Bridge establishes the Connection between BMW ConnectedDrive Portal and openHAB.\n+\n+| Name                       | Bridge Type ID | Description                                                |\n+|----------------------------|----------------|------------------------------------------------------------|\n+| BMW ConnectedDrive Account | account        | Access to BMW ConnectedDrive Portal for a specific user    |\n+\n+\n+### Things\n+\n+Four different Vehicle Types are provided. \n+They differ in the supported Channel Groups & Channels. \n+Conventional Fuel Vehicles have no _Charging Profile_, Electric Vehicles don't provide a _Fuel Range_. \n+For Hybrid Vehicles in addition to _Fuel and Electric Range_ the _Hybrid Range_ is shown.\n+ \n+| Name                                | Thing Type ID | Supported Channel Groups                                             |\n+|-------------------------------------|---------------|----------------------------------------------------------------------|\n+| BMW Electric Vehicle                | BEV           | status, range, location, service, check, charge, image, troubleshoot |\n+| BMW Electric Vehicle with REX       | BEV_REX       | status, range, location, service, check, charge, image, troubleshoot |\n+| BMW Plug-In-Hybrid Electric Vehicle | PHEV          | status, range, location, service, check, charge, image, troubleshoot |\n+| BMW Conventional Vehicle            | CONV          | status, range, location, service, check, image, troubleshoot         |\n+\n+ \n+#### Properties\n+\n+<img align=\"right\" src=\"./doc/properties.png\" width=\"500\" height=\"600\"/>\n+\n+For each Vehicle Properties are available. \n+Basically 3 Types of Information are registered as Properties\n+\n+* Informations regarding your Dealer with Address and Phone Number\n+* Which services are available / not available\n+* Vehicle Properties like Color, Model Type, Drive Train and Construction Year\n+\n+In the right picture  can see in *Services Activated* e.g. the *DoorLock* and *DoorUnlock* Services are mentioned. \n+This ensures [Channel Group _Remote Services_](#remote-services) is supporting Door lock and Door unlock.\n+\n+In  *Services Supported* the entry *LastDestination* is mentioned.\n+So it's valid to connect Channel Group [Last Destinations](#destinations) in order to display the last 3 Navigation Destinations.\n+\n+| Property Key       | Property Value      |  Supported Channel Groups    |\n+|--------------------|---------------------|------------------------------|\n+| Services Supported | Statistics          | last-trip, lifetime          |\n+| Services Supported | LastDestinations    | destinations                 |\n+| Services Activated | list of services    | remote                       |\n+\n+\n+## Discovery\n+\n+Auto Discovery is starting after creation of the Bridge towards BMW ConnectedDrive. \n+A list of your registered Vehicles is queried and all found Vehicles are added in Inbox.\n+Unique Identifier is the *Vehicle Identification Number* (VIN). \n+If a Thing is already declared in a  *.things configuration* Discovery won't highlight it again.\n+Properties will be attached to predefined Vehicles if the VIN is matching.\n+\n+## Configuration\n+\n+### Bridge\n+\n+| Parameter       | Type    | Description                                                             |           \n+|-----------------|---------|-------------------------------------------------------------------------|\n+| userName        | text    | BMW Connected Drive Username                  |\n+| password        | text    | BMW Connected Drive Password                  |\n+| region          | text    | Select Region in order to connect to the appropriate BMW Server.   |\n+\n+The region Configuration has 3 different possibilities\n+\n+* _NORTH_AMERICA_\n+* _CHINA_\n+* _ROW_ for Rest of World\n+\n+### Thing\n+\n+Same Configuration is needed for all Things\n+\n+| Parameter       | Type    | Description                           |           \n+|-----------------|---------|---------------------------------------|\n+| vin             | text    | Vehicle Identification Number (VIN)   |\n+| refreshInterval | integer | Refresh Interval in Minutes           |\n+| units           | text    | Unit Selection                        |\n+| imageSize       | integer | Image Size                            |\n+| imageViewport   | text    | Image Viewport                        |\n+\n+The units can be configured in 3 ways\n+\n+* _AUTODETECT_ selects Miles for US & UK, Kilometer otherwise\n+* _METRIC_ selects directly Kilometers\n+* _IMPERIAL_ selects directly Miles\n+\n+The imageVieport allows to show the Vehicle from different angels.\n+Possible values are \n+\n+* FRONT\n+* REAR\n+* SIDE\n+* DASHBOARD\n+* DRIVERDOOR\n+\n+## Channels\n+\n+There are many Channels available for each Vehicle. \n+For better overview they are clustered in different Channel Groups.\n+The Channel Groups are different for the Vehicle Types, on the build-in Sensors of the Vehicle and the activated Services.\n+\n+### Bridge Channels\n+\n+If the Vehicle isn't found in the Discovery force a log of Fingerprint Data which helps to analyze the problem.\n+Please check [TroubleShooting Section](#TroubleShooting) for further advice.\n+\n+| Channel Label         | Channel ID            | Type   | Description                                       |\n+|-----------------------|-----------------------|--------|---------------------------------------------------|\n+| Discovery Fingerprint | discovery-fingerprint | Switch | Forcing a log entry to analyze Discovery Problems |\n+\n+### Thing Channel Groups \n+\n+#### Vehicle Status\n+\n+Reflects Status of the Vehicle.\n+Available for all Vehicles, Read-only.\n+\n+| Channel Label             | Channel Group ID | Channel ID          | Type          | Description                                                                       |\n+|---------------------------|------------------|---------------------|---------------|-----------------------------------------------------------------------------------|\n+| Overall Door Status       | status           | doors               | String        | **Closed** if all closed otherwise **Open**. **Unknown** if no data is delivered  |\n+| Overall Window Status     | status           | windows             | String        | **Closed** if all closed otherwise **Open** or **Intermediate**. **Unknown** if no data is delivered   |\n+| Doors Locked              | status           | lock                | String        | Status if Doors are locked or unlocked                                            |\n+| Next Service Date         | status           | service-date        | DateTime      | Date of Upcoming Service                                                          |\n+| Mileage till Next Service | status           | service-mileage     | Number:Length | Mileage till Upcoming Service                                                     |\n+| Check Control             | status           | check-control       | String        | Indicator if CheckControl is **Active** or **Not Active**. **Unknown** if no data is delivered         |\n+| Charging Status           | status           | charge              | String        | Only available for PHEV, BEV_REX and BEV                                          |\n+| Last Status Timestamp     | status           | last-update         | DateTime      | Date and Time of last status update.                                              |\n+\n+See [further details for DateTime](#last-status-update-timestamp) in case of wrong timestamp values\n+\n+#### Services\n+\n+Group for all upcoming Services with Description, Service Date and / or Service Mileage\n+It's designed as [List Interface](#list-interface) so all upcoming Services can be checked.\n+\n+| Channel Label                  | Channel Group ID | Channel ID          | Type           | \n+|--------------------------------|------------------|---------------------|----------------|\n+| Service Name                   | service          | name                | String         |\n+| Service Date                   | service          | date                | Number         |\n+| Mileage till Service           | service          | mileage             | Number:Length  |\n+| Number of Scheduled Services   | service          | size                | String         |\n+| Current Selected Service Index | service          | index               | Number         |\n+| Select next Service            | service          | next                | Switch         |\n+\n+#### Check Control\n+\n+Group for all current active CheckControl Messages.\n+It's designed as [List Interface](#list-interface) to show all active Messages.\n+\n+| Channel Label                   | Channel Group ID | Channel ID          | Type           | \n+|---------------------------------|------------------|---------------------|----------------|\n+| CheckControl Description        | check            | name                | String         |\n+| CheckControl Mileage Occurrence | check            | mileage             | Number:Length  |\n+| Active CheckControl Messages    | check            | size                | String         |\n+| Selected CheckControl Message   | check            | index               | Number         |\n+| Next CheckControl Message       | check            | next                | Switch         |\n+\n+#### Doors Details\n+\n+Detailed Status of all Doors and Windows\n+Available for all Vehicles, Read-only. \n+\n+| Channel Label              | Channel Group ID | Channel ID              | Type          | \n+|----------------------------|------------------|-------------------------|---------------|\n+| Driver Door                | doors            | driver-front            | String        |\n+| Driver Door Rear           | doors            | driver-rear             | String        |\n+| Passenger Door             | doors            | passenger-front         | String        |\n+| Passenger Door Rear        | doors            | passenger-rear          | String        |\n+| Trunk                      | doors            | trunk                   | String        |\n+| Hood                       | doors            | hood                    | String        |\n+| Driver Door Window         | doors            | window-driver-front     | String        |\n+| Driver Door Rear Window    | doors            | window-driver-rear      | String        |\n+| Passenger Door Window      | doors            | window-passenger-front  | String        |\n+| Passenger Door Rear Window | doors            | window-passenger-rear   | String        |\n+| Rear Window                | doors            | window-rear             | String        |\n+| Sunroof                    | doors            | sunroof                 | String        |\n+\n+Following Strings will be delivered\n+\n+* UNKNOWN - no status data available\n+* INVALID - this item isn't applicable for this Vehicle\n+* CLOSED - the Door / Window is closed\n+* OPEN - the Door / Window is open\n+* INTERMEDIATE - Window in intermediate position, not applicable for Doors\n+\n+#### Range Data\n+\n+Based on Vehicle Type (Thing Type ID) some Channels are presented or not. \n+Conventional Fuel Vehicles don't provide *Electric Range* and Battery Electric Vehicles don't show *Range Fuel*.\n+Hybrid Vehicles have both and in addition *Hybrid Range*.\n+These are Read-only values.\n+\n+| Channel Label         | Channel Group ID | Channel ID            | Type                 | CONV | PHEV | BEV_REX | BEV |\n+|-----------------------|------------------|-----------------------|----------------------|------|------|---------|-----|\n+| Mileage               | range            | mileage               | Number:Length        |  X   |  X   |    X    |  X  |\n+| Fuel Range            | range            | range-fuel            | Number:Length        |  X   |  X   |    X    |     |\n+| Battery Range         | range            | range-electric        | Number:Length        |      |  X   |    X    |  X  | \n+| Hybrid Range          | range            | range-hybrid          | Number:Length        |      |  X   |    X    |     | \n+| Battery Charge Level  | range            | soc                   | Number:Dimensionless |      |  X   |    X    |  X  |\n+| Remaining Fuel        | range            | remaining-fuel        | Number:Volume        |  X   |  X   |    X    |     | \n+| Fuel Range Radius     | range            | range-radius-fuel     | Number:Length        |  X   |  X   |    X    |     | \n+| Electric Range Radius | range            | range-radius-electric | Number:Length        |      |  X   |    X    |  X  | \n+| Hybrid Range Radius   | range            | range-radius-hybrid   | Number:Length        |      |  X   |    X    |     | \n+\n+See Description [Range vs Range Radius](#range-vs-range-radius) to get more information\n+\n+#### Charge Profile\n+\n+Valid for Electric and Hybrid Vehicles\n+These are Read-only values.\n+\n+| Channel Label                      | Channel Group ID | Channel ID          | Type   | \n+|------------------------------------|------------------|---------------------|--------|\n+| Air Conditioning at Departure Time | charge           | profile-climate     | Switch | \n+| Charging Mode for Profile          | charge           | profile-mode        | String | \n+| Charging Window Start Time         | charge           | window-start        | String | \n+| Charging Window End Time           | charge           | window-end          | String | \n+| Timer 1: Departure Time            | charge           | timer1-departure    | String | \n+| Timer 1: Scheduled Days            | charge           | timer1-days         | String | \n+| Timer 1: Enabled                   | charge           | timer1-enabled      | Switch | \n+| Timer 2: Departure Time            | charge           | timer2-departure    | String | \n+| Timer 2: Scheduled Days            | charge           | timer2-days         | String | \n+| Timer 2: Enabled                   | charge           | timer2-enabled      | Switch | \n+| Timer 3: Departure Time            | charge           | timer3-departure    | String | \n+| Timer 3: Scheduled Days            | charge           | timer3-days         | String | \n+| Timer 3: Enabled                   | charge           | timer3-enabled      | Switch | \n+\n+\n+#### Location\n+\n+Available for all Vehicles.\n+These are Read-only values.\n+\n+| Channel Label  | Channel Group ID | Channel ID          | Type         | \n+|----------------|------------------|---------------------|--------------|\n+| Latitude       | location         | latitude            | Number       | \n+| Longitude      | location         | longitude           | Number       |\n+| Heading        | location         | heading             | Number:Angle | \n+\n+#### Last Trip\n+\n+Check [Vehicle Properties](#Properties) if *Statistics* is present in *Services Supported*\n+These are Read-only values.\n+\n+| Channel Label                           | Channel Group ID | Channel ID                   | Type          |\n+|-----------------------------------------|------------------|------------------------------|---------------|\n+| Last Trip Date                          | last-trip        | date                         | DateTime      |\n+| Last Trip Duration                      | last-trip        | duration                     | Number:Time   |\n+| Average Power Consumption per 100 km    | last-trip        | average-consumption          | Number:Power  |\n+| Average Combined Consumption per 100 km | last-trip        | average-combined-consumption | Number:Volume |\n+| Average Power Recuperation per 100 km   | last-trip        | average-recuperation         | Number:Power  |\n+| Last Trip Distance                      | last-trip        | distance                     | Number:Length |\n+| Distance since Last Charge              | last-trip        | distance-since-charging      | Number:Length |\n+\n+\n+#### Lifetime Statistics\n+\n+Check [Vehicle Properties](#Properties) if *Statistics* is present in *Services Supported*\n+These are Read-only values.\n+\n+| Channel Label                           | Channel Group ID | Channel ID                   | Type          | \n+|-----------------------------------------|------------------|------------------------------|---------------|\n+| Average Power Consumption per 100 km    | lifetime         | average-consumption          | Number:Power  |\n+| Average Power Recuperation per 100 km   | lifetime         | average-recuperation         | Number:Power  |\n+| Cumulated Electric Driven Distance      | lifetime         | cumulated-driven-distance    | Number:Length |\n+| Average Combined Consumption per 100 km | lifetime         | average-combined-consumption | Number:Volume |\n+| Longest Distance with one Charge        | lifetime         | single-longest-distance      | Number:Length |\n+\n+\n+#### Remote Services\n+\n+Check [Vehicle Properties](#Properties) *Services Activated* which Remote Services are available\n+Only one Remote Service can be executed each Time.\n+Parallel execution isn't supported.\n+The *Service Execution State* Channel is reporting the state.\n+State *Executed* is the final State when Execution is finished.\n+\n+| Channel Label           | Channel Group ID | Channel ID          | Type    | \n+|-------------------------|------------------|---------------------|---------|\n+| Activate Flash Lights   | remote           | light               | Switch  |\n+| Find Vehicle            | remote           | finder              | Switch  |\n+| Lock Doors              | remote           | lock                | Switch  |\n+| Unlock Doors            | remote           | unlock              | Switch  |\n+| Horn Blow               | remote           | horn                | Switch  |\n+| Active Air Conditioning | remote           | climate             | Switch  |\n+| Service Execution State | remote           | state               | STring  |\n+\n+#### Destinations\n+\n+Check [Vehicle Properties](#Properties) if *LastDestinations* is present in *Services Supported*\n+It's designed as [List Interface](#list-interface) in order to have access to all stored Destinations.\n+\n+| Channel Label                    | Channel Group ID | Channel ID          | Type    | \n+|----------------------------------|------------------|---------------------|---------|\n+| Destination Name                 | destination      | name                | String  |\n+| Destination Latitude             | destination      | latitude            | Number  |\n+| Destination Longitude            | destination      | longitude           | Number  |\n+| Number of Available Destinations | destination      | size                | String  |\n+| Index of Selected Destination    | destination      | index               | Number  |\n+| Skip to Next Destination         | destination      | next                | Switch  |\n+\n+\n+#### Image\n+\n+Available for all Vehicles.\n+Picture can be modified regarding *Viewport* and *Size*.\n+See [Things Section](#thing) for Viewport possibilities and [Status Image](#status-image) for possible Use Cases.\n+\n+| Channel Label                 | Channel Group ID | Channel ID          | Type   | \n+|-------------------------------|------------------|---------------------|--------|\n+| Rendered Image of the Vehicle | image            | png                 | Image  |\n+| Image Viewport                | image            | view                | String |\n+| Image Picture Size            | image            | size                | Number |\n+\n+\n+#### Troubleshooting\n+\n+Available for all Vehicles!\n+Switch will log a *Vehicle Data Fingerprint* into the openHAB log.\n+Please check [TroubleShooting Section](#TroubleShooting) for further advice.\n+\n+| Channel Label                       | Channel Group ID | Channel ID          | Type   | Description                                       |\n+|-------------------------------------|------------------|---------------------|--------|---------------------------------------------------|\n+| Log Vehicle Fingerprint             | troubleshoot     | vehicle-fingerprint | Switch | Forces log entries in openHAB logger in order to raise issues |\n+\n+## Further Descriptions\n+\n+### List Interface\n+\n+Currently there are 3 occurrences of dynamic data delivered as Lists\n+\n+* Upcoming Services\n+* Check Control Messages\n+* Last Destinations\n+\n+In order to provide all data the lists are organized the following way based on the Service Group example\n+\n+* **size** is the total length of the list. Read-only.\n+* **index** is the current selected index starting with 0 => list with size 10, valid index is between 0 - 9. If the index is set to _out of bounds_ it's set to first element. Read-write.\n+* **next** declares a switch for scrolling forward through the list in an endless way. Reaching end of list will start again from 0. Read-write.\n+* **name**, **mileage** and **date** declares the list item. It will change when setting new index or perform next. Read-only.\n+\n+### Range vs Range Radius\n+\n+<img align=\"right\" src=\"./doc/range-radius.png\" width=\"400\" height=\"350\"/>\n+\n+ will observe differences in the Vehicle Range and Range Radius values. ", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTEyOTMyMg=="}, "originalCommit": {"oid": "e0bfe93e13df4a3c5de5f8819b94ebf795664904"}, "originalPosition": 378}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEzNzg2OTAzOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.bmwconnecteddrive/README.md", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wN1QxNjowMzowMlrOHd6o-g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yOFQxMDoxNTowOFrOIL2JZQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTEzMTUxNA==", "bodyText": "Did you take into account, that the timezone can be configured within the framework, too? E.g. via PaperUI. You can retrieve the configured timezone by injecting this class: https://www.openhab.org/javadoc/v2.5/org/eclipse/smarthome/core/i18n/timezoneprovider", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r501131514", "createdAt": "2020-10-07T16:03:02Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/README.md", "diffHunk": "@@ -0,0 +1,862 @@\n+# BMW ConnectedDrive Binding\n+\n+<img align=\"right\" src=\"./doc/bmw-connected.png\" width=\"150\" height=\"150\"/>\n+\n+The Binding provides a Connection between [BMWs ConnectedDrive Portal](https://www.bmw-connecteddrive.com/country-region-select/country-region-selection.html) and openHAB.\n+All Vehicles connected to an Account will be detected by the Discovery with the correct type \n+\n+* Conventional Fuel Vehicle\n+* Plugin-Hybrid Electrical Vehicle \n+* Battery Electric Vehicle with Range Extender\n+* Battery Electric Vehicle \n+\n+In addition Properties are attached with Information and Services provided by this Vehicle.\n+The provided data depends on \n+\n+1. the [Type](#Things) and \n+2. the Services mentioned in [Properties](#properties)\n+\n+Different Channel Groups are clustering all informations.\n+Check for each Group if it's supported for this Vehicle.\n+\n+Please note **this isn't a real-time Binding**. \n+If the Door is opened the state isn't transmitted and changed immediately. \n+This isn't a flaw in the Binding itself because the state in BMWs own ConnectedDrive App is also updated with some delay. \n+\n+## Supported Things\n+\n+### Bridge\n+\n+The Bridge establishes the Connection between BMW ConnectedDrive Portal and openHAB.\n+\n+| Name                       | Bridge Type ID | Description                                                |\n+|----------------------------|----------------|------------------------------------------------------------|\n+| BMW ConnectedDrive Account | account        | Access to BMW ConnectedDrive Portal for a specific user    |\n+\n+\n+### Things\n+\n+Four different Vehicle Types are provided. \n+They differ in the supported Channel Groups & Channels. \n+Conventional Fuel Vehicles have no _Charging Profile_, Electric Vehicles don't provide a _Fuel Range_. \n+For Hybrid Vehicles in addition to _Fuel and Electric Range_ the _Hybrid Range_ is shown.\n+ \n+| Name                                | Thing Type ID | Supported Channel Groups                                             |\n+|-------------------------------------|---------------|----------------------------------------------------------------------|\n+| BMW Electric Vehicle                | BEV           | status, range, location, service, check, charge, image, troubleshoot |\n+| BMW Electric Vehicle with REX       | BEV_REX       | status, range, location, service, check, charge, image, troubleshoot |\n+| BMW Plug-In-Hybrid Electric Vehicle | PHEV          | status, range, location, service, check, charge, image, troubleshoot |\n+| BMW Conventional Vehicle            | CONV          | status, range, location, service, check, image, troubleshoot         |\n+\n+ \n+#### Properties\n+\n+<img align=\"right\" src=\"./doc/properties.png\" width=\"500\" height=\"600\"/>\n+\n+For each Vehicle Properties are available. \n+Basically 3 Types of Information are registered as Properties\n+\n+* Informations regarding your Dealer with Address and Phone Number\n+* Which services are available / not available\n+* Vehicle Properties like Color, Model Type, Drive Train and Construction Year\n+\n+In the right picture  can see in *Services Activated* e.g. the *DoorLock* and *DoorUnlock* Services are mentioned. \n+This ensures [Channel Group _Remote Services_](#remote-services) is supporting Door lock and Door unlock.\n+\n+In  *Services Supported* the entry *LastDestination* is mentioned.\n+So it's valid to connect Channel Group [Last Destinations](#destinations) in order to display the last 3 Navigation Destinations.\n+\n+| Property Key       | Property Value      |  Supported Channel Groups    |\n+|--------------------|---------------------|------------------------------|\n+| Services Supported | Statistics          | last-trip, lifetime          |\n+| Services Supported | LastDestinations    | destinations                 |\n+| Services Activated | list of services    | remote                       |\n+\n+\n+## Discovery\n+\n+Auto Discovery is starting after creation of the Bridge towards BMW ConnectedDrive. \n+A list of your registered Vehicles is queried and all found Vehicles are added in Inbox.\n+Unique Identifier is the *Vehicle Identification Number* (VIN). \n+If a Thing is already declared in a  *.things configuration* Discovery won't highlight it again.\n+Properties will be attached to predefined Vehicles if the VIN is matching.\n+\n+## Configuration\n+\n+### Bridge\n+\n+| Parameter       | Type    | Description                                                             |           \n+|-----------------|---------|-------------------------------------------------------------------------|\n+| userName        | text    | BMW Connected Drive Username                  |\n+| password        | text    | BMW Connected Drive Password                  |\n+| region          | text    | Select Region in order to connect to the appropriate BMW Server.   |\n+\n+The region Configuration has 3 different possibilities\n+\n+* _NORTH_AMERICA_\n+* _CHINA_\n+* _ROW_ for Rest of World\n+\n+### Thing\n+\n+Same Configuration is needed for all Things\n+\n+| Parameter       | Type    | Description                           |           \n+|-----------------|---------|---------------------------------------|\n+| vin             | text    | Vehicle Identification Number (VIN)   |\n+| refreshInterval | integer | Refresh Interval in Minutes           |\n+| units           | text    | Unit Selection                        |\n+| imageSize       | integer | Image Size                            |\n+| imageViewport   | text    | Image Viewport                        |\n+\n+The units can be configured in 3 ways\n+\n+* _AUTODETECT_ selects Miles for US & UK, Kilometer otherwise\n+* _METRIC_ selects directly Kilometers\n+* _IMPERIAL_ selects directly Miles\n+\n+The imageVieport allows to show the Vehicle from different angels.\n+Possible values are \n+\n+* FRONT\n+* REAR\n+* SIDE\n+* DASHBOARD\n+* DRIVERDOOR\n+\n+## Channels\n+\n+There are many Channels available for each Vehicle. \n+For better overview they are clustered in different Channel Groups.\n+The Channel Groups are different for the Vehicle Types, on the build-in Sensors of the Vehicle and the activated Services.\n+\n+### Bridge Channels\n+\n+If the Vehicle isn't found in the Discovery force a log of Fingerprint Data which helps to analyze the problem.\n+Please check [TroubleShooting Section](#TroubleShooting) for further advice.\n+\n+| Channel Label         | Channel ID            | Type   | Description                                       |\n+|-----------------------|-----------------------|--------|---------------------------------------------------|\n+| Discovery Fingerprint | discovery-fingerprint | Switch | Forcing a log entry to analyze Discovery Problems |\n+\n+### Thing Channel Groups \n+\n+#### Vehicle Status\n+\n+Reflects Status of the Vehicle.\n+Available for all Vehicles, Read-only.\n+\n+| Channel Label             | Channel Group ID | Channel ID          | Type          | Description                                                                       |\n+|---------------------------|------------------|---------------------|---------------|-----------------------------------------------------------------------------------|\n+| Overall Door Status       | status           | doors               | String        | **Closed** if all closed otherwise **Open**. **Unknown** if no data is delivered  |\n+| Overall Window Status     | status           | windows             | String        | **Closed** if all closed otherwise **Open** or **Intermediate**. **Unknown** if no data is delivered   |\n+| Doors Locked              | status           | lock                | String        | Status if Doors are locked or unlocked                                            |\n+| Next Service Date         | status           | service-date        | DateTime      | Date of Upcoming Service                                                          |\n+| Mileage till Next Service | status           | service-mileage     | Number:Length | Mileage till Upcoming Service                                                     |\n+| Check Control             | status           | check-control       | String        | Indicator if CheckControl is **Active** or **Not Active**. **Unknown** if no data is delivered         |\n+| Charging Status           | status           | charge              | String        | Only available for PHEV, BEV_REX and BEV                                          |\n+| Last Status Timestamp     | status           | last-update         | DateTime      | Date and Time of last status update.                                              |\n+\n+See [further details for DateTime](#last-status-update-timestamp) in case of wrong timestamp values\n+\n+#### Services\n+\n+Group for all upcoming Services with Description, Service Date and / or Service Mileage\n+It's designed as [List Interface](#list-interface) so all upcoming Services can be checked.\n+\n+| Channel Label                  | Channel Group ID | Channel ID          | Type           | \n+|--------------------------------|------------------|---------------------|----------------|\n+| Service Name                   | service          | name                | String         |\n+| Service Date                   | service          | date                | Number         |\n+| Mileage till Service           | service          | mileage             | Number:Length  |\n+| Number of Scheduled Services   | service          | size                | String         |\n+| Current Selected Service Index | service          | index               | Number         |\n+| Select next Service            | service          | next                | Switch         |\n+\n+#### Check Control\n+\n+Group for all current active CheckControl Messages.\n+It's designed as [List Interface](#list-interface) to show all active Messages.\n+\n+| Channel Label                   | Channel Group ID | Channel ID          | Type           | \n+|---------------------------------|------------------|---------------------|----------------|\n+| CheckControl Description        | check            | name                | String         |\n+| CheckControl Mileage Occurrence | check            | mileage             | Number:Length  |\n+| Active CheckControl Messages    | check            | size                | String         |\n+| Selected CheckControl Message   | check            | index               | Number         |\n+| Next CheckControl Message       | check            | next                | Switch         |\n+\n+#### Doors Details\n+\n+Detailed Status of all Doors and Windows\n+Available for all Vehicles, Read-only. \n+\n+| Channel Label              | Channel Group ID | Channel ID              | Type          | \n+|----------------------------|------------------|-------------------------|---------------|\n+| Driver Door                | doors            | driver-front            | String        |\n+| Driver Door Rear           | doors            | driver-rear             | String        |\n+| Passenger Door             | doors            | passenger-front         | String        |\n+| Passenger Door Rear        | doors            | passenger-rear          | String        |\n+| Trunk                      | doors            | trunk                   | String        |\n+| Hood                       | doors            | hood                    | String        |\n+| Driver Door Window         | doors            | window-driver-front     | String        |\n+| Driver Door Rear Window    | doors            | window-driver-rear      | String        |\n+| Passenger Door Window      | doors            | window-passenger-front  | String        |\n+| Passenger Door Rear Window | doors            | window-passenger-rear   | String        |\n+| Rear Window                | doors            | window-rear             | String        |\n+| Sunroof                    | doors            | sunroof                 | String        |\n+\n+Following Strings will be delivered\n+\n+* UNKNOWN - no status data available\n+* INVALID - this item isn't applicable for this Vehicle\n+* CLOSED - the Door / Window is closed\n+* OPEN - the Door / Window is open\n+* INTERMEDIATE - Window in intermediate position, not applicable for Doors\n+\n+#### Range Data\n+\n+Based on Vehicle Type (Thing Type ID) some Channels are presented or not. \n+Conventional Fuel Vehicles don't provide *Electric Range* and Battery Electric Vehicles don't show *Range Fuel*.\n+Hybrid Vehicles have both and in addition *Hybrid Range*.\n+These are Read-only values.\n+\n+| Channel Label         | Channel Group ID | Channel ID            | Type                 | CONV | PHEV | BEV_REX | BEV |\n+|-----------------------|------------------|-----------------------|----------------------|------|------|---------|-----|\n+| Mileage               | range            | mileage               | Number:Length        |  X   |  X   |    X    |  X  |\n+| Fuel Range            | range            | range-fuel            | Number:Length        |  X   |  X   |    X    |     |\n+| Battery Range         | range            | range-electric        | Number:Length        |      |  X   |    X    |  X  | \n+| Hybrid Range          | range            | range-hybrid          | Number:Length        |      |  X   |    X    |     | \n+| Battery Charge Level  | range            | soc                   | Number:Dimensionless |      |  X   |    X    |  X  |\n+| Remaining Fuel        | range            | remaining-fuel        | Number:Volume        |  X   |  X   |    X    |     | \n+| Fuel Range Radius     | range            | range-radius-fuel     | Number:Length        |  X   |  X   |    X    |     | \n+| Electric Range Radius | range            | range-radius-electric | Number:Length        |      |  X   |    X    |  X  | \n+| Hybrid Range Radius   | range            | range-radius-hybrid   | Number:Length        |      |  X   |    X    |     | \n+\n+See Description [Range vs Range Radius](#range-vs-range-radius) to get more information\n+\n+#### Charge Profile\n+\n+Valid for Electric and Hybrid Vehicles\n+These are Read-only values.\n+\n+| Channel Label                      | Channel Group ID | Channel ID          | Type   | \n+|------------------------------------|------------------|---------------------|--------|\n+| Air Conditioning at Departure Time | charge           | profile-climate     | Switch | \n+| Charging Mode for Profile          | charge           | profile-mode        | String | \n+| Charging Window Start Time         | charge           | window-start        | String | \n+| Charging Window End Time           | charge           | window-end          | String | \n+| Timer 1: Departure Time            | charge           | timer1-departure    | String | \n+| Timer 1: Scheduled Days            | charge           | timer1-days         | String | \n+| Timer 1: Enabled                   | charge           | timer1-enabled      | Switch | \n+| Timer 2: Departure Time            | charge           | timer2-departure    | String | \n+| Timer 2: Scheduled Days            | charge           | timer2-days         | String | \n+| Timer 2: Enabled                   | charge           | timer2-enabled      | Switch | \n+| Timer 3: Departure Time            | charge           | timer3-departure    | String | \n+| Timer 3: Scheduled Days            | charge           | timer3-days         | String | \n+| Timer 3: Enabled                   | charge           | timer3-enabled      | Switch | \n+\n+\n+#### Location\n+\n+Available for all Vehicles.\n+These are Read-only values.\n+\n+| Channel Label  | Channel Group ID | Channel ID          | Type         | \n+|----------------|------------------|---------------------|--------------|\n+| Latitude       | location         | latitude            | Number       | \n+| Longitude      | location         | longitude           | Number       |\n+| Heading        | location         | heading             | Number:Angle | \n+\n+#### Last Trip\n+\n+Check [Vehicle Properties](#Properties) if *Statistics* is present in *Services Supported*\n+These are Read-only values.\n+\n+| Channel Label                           | Channel Group ID | Channel ID                   | Type          |\n+|-----------------------------------------|------------------|------------------------------|---------------|\n+| Last Trip Date                          | last-trip        | date                         | DateTime      |\n+| Last Trip Duration                      | last-trip        | duration                     | Number:Time   |\n+| Average Power Consumption per 100 km    | last-trip        | average-consumption          | Number:Power  |\n+| Average Combined Consumption per 100 km | last-trip        | average-combined-consumption | Number:Volume |\n+| Average Power Recuperation per 100 km   | last-trip        | average-recuperation         | Number:Power  |\n+| Last Trip Distance                      | last-trip        | distance                     | Number:Length |\n+| Distance since Last Charge              | last-trip        | distance-since-charging      | Number:Length |\n+\n+\n+#### Lifetime Statistics\n+\n+Check [Vehicle Properties](#Properties) if *Statistics* is present in *Services Supported*\n+These are Read-only values.\n+\n+| Channel Label                           | Channel Group ID | Channel ID                   | Type          | \n+|-----------------------------------------|------------------|------------------------------|---------------|\n+| Average Power Consumption per 100 km    | lifetime         | average-consumption          | Number:Power  |\n+| Average Power Recuperation per 100 km   | lifetime         | average-recuperation         | Number:Power  |\n+| Cumulated Electric Driven Distance      | lifetime         | cumulated-driven-distance    | Number:Length |\n+| Average Combined Consumption per 100 km | lifetime         | average-combined-consumption | Number:Volume |\n+| Longest Distance with one Charge        | lifetime         | single-longest-distance      | Number:Length |\n+\n+\n+#### Remote Services\n+\n+Check [Vehicle Properties](#Properties) *Services Activated* which Remote Services are available\n+Only one Remote Service can be executed each Time.\n+Parallel execution isn't supported.\n+The *Service Execution State* Channel is reporting the state.\n+State *Executed* is the final State when Execution is finished.\n+\n+| Channel Label           | Channel Group ID | Channel ID          | Type    | \n+|-------------------------|------------------|---------------------|---------|\n+| Activate Flash Lights   | remote           | light               | Switch  |\n+| Find Vehicle            | remote           | finder              | Switch  |\n+| Lock Doors              | remote           | lock                | Switch  |\n+| Unlock Doors            | remote           | unlock              | Switch  |\n+| Horn Blow               | remote           | horn                | Switch  |\n+| Active Air Conditioning | remote           | climate             | Switch  |\n+| Service Execution State | remote           | state               | STring  |\n+\n+#### Destinations\n+\n+Check [Vehicle Properties](#Properties) if *LastDestinations* is present in *Services Supported*\n+It's designed as [List Interface](#list-interface) in order to have access to all stored Destinations.\n+\n+| Channel Label                    | Channel Group ID | Channel ID          | Type    | \n+|----------------------------------|------------------|---------------------|---------|\n+| Destination Name                 | destination      | name                | String  |\n+| Destination Latitude             | destination      | latitude            | Number  |\n+| Destination Longitude            | destination      | longitude           | Number  |\n+| Number of Available Destinations | destination      | size                | String  |\n+| Index of Selected Destination    | destination      | index               | Number  |\n+| Skip to Next Destination         | destination      | next                | Switch  |\n+\n+\n+#### Image\n+\n+Available for all Vehicles.\n+Picture can be modified regarding *Viewport* and *Size*.\n+See [Things Section](#thing) for Viewport possibilities and [Status Image](#status-image) for possible Use Cases.\n+\n+| Channel Label                 | Channel Group ID | Channel ID          | Type   | \n+|-------------------------------|------------------|---------------------|--------|\n+| Rendered Image of the Vehicle | image            | png                 | Image  |\n+| Image Viewport                | image            | view                | String |\n+| Image Picture Size            | image            | size                | Number |\n+\n+\n+#### Troubleshooting\n+\n+Available for all Vehicles!\n+Switch will log a *Vehicle Data Fingerprint* into the openHAB log.\n+Please check [TroubleShooting Section](#TroubleShooting) for further advice.\n+\n+| Channel Label                       | Channel Group ID | Channel ID          | Type   | Description                                       |\n+|-------------------------------------|------------------|---------------------|--------|---------------------------------------------------|\n+| Log Vehicle Fingerprint             | troubleshoot     | vehicle-fingerprint | Switch | Forces log entries in openHAB logger in order to raise issues |\n+\n+## Further Descriptions\n+\n+### List Interface\n+\n+Currently there are 3 occurrences of dynamic data delivered as Lists\n+\n+* Upcoming Services\n+* Check Control Messages\n+* Last Destinations\n+\n+In order to provide all data the lists are organized the following way based on the Service Group example\n+\n+* **size** is the total length of the list. Read-only.\n+* **index** is the current selected index starting with 0 => list with size 10, valid index is between 0 - 9. If the index is set to _out of bounds_ it's set to first element. Read-write.\n+* **next** declares a switch for scrolling forward through the list in an endless way. Reaching end of list will start again from 0. Read-write.\n+* **name**, **mileage** and **date** declares the list item. It will change when setting new index or perform next. Read-only.\n+\n+### Range vs Range Radius\n+\n+<img align=\"right\" src=\"./doc/range-radius.png\" width=\"400\" height=\"350\"/>\n+\n+ will observe differences in the Vehicle Range and Range Radius values. \n+While Range is indicating the possible distance to be driven on roads the range radius indicates the reachable range on the Map.\n+\n+The right picture shows the distance between Kassel and Frankfurt in Germany. \n+While the Air-line Distance is ~145 Kilometer the Route Distance is ~192 Kilometer.\n+So Range value is the normal remaining range.\n+See the Section [OpenStreetMap](#openstreetMap-widget) how the Range Radius is used to indicate the reachable Range on Map.\n+Please note this is just an indicator and the effective range, especially for Electric Vehicles, \n+depends on many factors like driving style and electric consumers. \n+ \n+### Last Status Update Timestamp\n+\n+A timestamp is showing the last Vehicle Status update. If this isn't shown correctly please check the date settings.\n+In case of Raspberry Pi execute *raspi-config*, select *Localization Options*, the *Change Time Zone*\n+Select your *Geographical Area* and afterwards the correct City.\n+One restart of openHAB service with *systemctl restart openhab2* is necessary in order to see the corrected Time Settings.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e0bfe93e13df4a3c5de5f8819b94ebf795664904"}, "originalPosition": 393}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTI5MjM4OQ==", "bodyText": "No, to be honest I didn't checked that. I added the code and you're right it's showing the same results. With this in mind I also deleted the section in readme. I think the topic is too generic to mention it in this specific binding.", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r549292389", "createdAt": "2020-12-28T10:15:08Z", "author": {"login": "weymann"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/README.md", "diffHunk": "@@ -0,0 +1,862 @@\n+# BMW ConnectedDrive Binding\n+\n+<img align=\"right\" src=\"./doc/bmw-connected.png\" width=\"150\" height=\"150\"/>\n+\n+The Binding provides a Connection between [BMWs ConnectedDrive Portal](https://www.bmw-connecteddrive.com/country-region-select/country-region-selection.html) and openHAB.\n+All Vehicles connected to an Account will be detected by the Discovery with the correct type \n+\n+* Conventional Fuel Vehicle\n+* Plugin-Hybrid Electrical Vehicle \n+* Battery Electric Vehicle with Range Extender\n+* Battery Electric Vehicle \n+\n+In addition Properties are attached with Information and Services provided by this Vehicle.\n+The provided data depends on \n+\n+1. the [Type](#Things) and \n+2. the Services mentioned in [Properties](#properties)\n+\n+Different Channel Groups are clustering all informations.\n+Check for each Group if it's supported for this Vehicle.\n+\n+Please note **this isn't a real-time Binding**. \n+If the Door is opened the state isn't transmitted and changed immediately. \n+This isn't a flaw in the Binding itself because the state in BMWs own ConnectedDrive App is also updated with some delay. \n+\n+## Supported Things\n+\n+### Bridge\n+\n+The Bridge establishes the Connection between BMW ConnectedDrive Portal and openHAB.\n+\n+| Name                       | Bridge Type ID | Description                                                |\n+|----------------------------|----------------|------------------------------------------------------------|\n+| BMW ConnectedDrive Account | account        | Access to BMW ConnectedDrive Portal for a specific user    |\n+\n+\n+### Things\n+\n+Four different Vehicle Types are provided. \n+They differ in the supported Channel Groups & Channels. \n+Conventional Fuel Vehicles have no _Charging Profile_, Electric Vehicles don't provide a _Fuel Range_. \n+For Hybrid Vehicles in addition to _Fuel and Electric Range_ the _Hybrid Range_ is shown.\n+ \n+| Name                                | Thing Type ID | Supported Channel Groups                                             |\n+|-------------------------------------|---------------|----------------------------------------------------------------------|\n+| BMW Electric Vehicle                | BEV           | status, range, location, service, check, charge, image, troubleshoot |\n+| BMW Electric Vehicle with REX       | BEV_REX       | status, range, location, service, check, charge, image, troubleshoot |\n+| BMW Plug-In-Hybrid Electric Vehicle | PHEV          | status, range, location, service, check, charge, image, troubleshoot |\n+| BMW Conventional Vehicle            | CONV          | status, range, location, service, check, image, troubleshoot         |\n+\n+ \n+#### Properties\n+\n+<img align=\"right\" src=\"./doc/properties.png\" width=\"500\" height=\"600\"/>\n+\n+For each Vehicle Properties are available. \n+Basically 3 Types of Information are registered as Properties\n+\n+* Informations regarding your Dealer with Address and Phone Number\n+* Which services are available / not available\n+* Vehicle Properties like Color, Model Type, Drive Train and Construction Year\n+\n+In the right picture  can see in *Services Activated* e.g. the *DoorLock* and *DoorUnlock* Services are mentioned. \n+This ensures [Channel Group _Remote Services_](#remote-services) is supporting Door lock and Door unlock.\n+\n+In  *Services Supported* the entry *LastDestination* is mentioned.\n+So it's valid to connect Channel Group [Last Destinations](#destinations) in order to display the last 3 Navigation Destinations.\n+\n+| Property Key       | Property Value      |  Supported Channel Groups    |\n+|--------------------|---------------------|------------------------------|\n+| Services Supported | Statistics          | last-trip, lifetime          |\n+| Services Supported | LastDestinations    | destinations                 |\n+| Services Activated | list of services    | remote                       |\n+\n+\n+## Discovery\n+\n+Auto Discovery is starting after creation of the Bridge towards BMW ConnectedDrive. \n+A list of your registered Vehicles is queried and all found Vehicles are added in Inbox.\n+Unique Identifier is the *Vehicle Identification Number* (VIN). \n+If a Thing is already declared in a  *.things configuration* Discovery won't highlight it again.\n+Properties will be attached to predefined Vehicles if the VIN is matching.\n+\n+## Configuration\n+\n+### Bridge\n+\n+| Parameter       | Type    | Description                                                             |           \n+|-----------------|---------|-------------------------------------------------------------------------|\n+| userName        | text    | BMW Connected Drive Username                  |\n+| password        | text    | BMW Connected Drive Password                  |\n+| region          | text    | Select Region in order to connect to the appropriate BMW Server.   |\n+\n+The region Configuration has 3 different possibilities\n+\n+* _NORTH_AMERICA_\n+* _CHINA_\n+* _ROW_ for Rest of World\n+\n+### Thing\n+\n+Same Configuration is needed for all Things\n+\n+| Parameter       | Type    | Description                           |           \n+|-----------------|---------|---------------------------------------|\n+| vin             | text    | Vehicle Identification Number (VIN)   |\n+| refreshInterval | integer | Refresh Interval in Minutes           |\n+| units           | text    | Unit Selection                        |\n+| imageSize       | integer | Image Size                            |\n+| imageViewport   | text    | Image Viewport                        |\n+\n+The units can be configured in 3 ways\n+\n+* _AUTODETECT_ selects Miles for US & UK, Kilometer otherwise\n+* _METRIC_ selects directly Kilometers\n+* _IMPERIAL_ selects directly Miles\n+\n+The imageVieport allows to show the Vehicle from different angels.\n+Possible values are \n+\n+* FRONT\n+* REAR\n+* SIDE\n+* DASHBOARD\n+* DRIVERDOOR\n+\n+## Channels\n+\n+There are many Channels available for each Vehicle. \n+For better overview they are clustered in different Channel Groups.\n+The Channel Groups are different for the Vehicle Types, on the build-in Sensors of the Vehicle and the activated Services.\n+\n+### Bridge Channels\n+\n+If the Vehicle isn't found in the Discovery force a log of Fingerprint Data which helps to analyze the problem.\n+Please check [TroubleShooting Section](#TroubleShooting) for further advice.\n+\n+| Channel Label         | Channel ID            | Type   | Description                                       |\n+|-----------------------|-----------------------|--------|---------------------------------------------------|\n+| Discovery Fingerprint | discovery-fingerprint | Switch | Forcing a log entry to analyze Discovery Problems |\n+\n+### Thing Channel Groups \n+\n+#### Vehicle Status\n+\n+Reflects Status of the Vehicle.\n+Available for all Vehicles, Read-only.\n+\n+| Channel Label             | Channel Group ID | Channel ID          | Type          | Description                                                                       |\n+|---------------------------|------------------|---------------------|---------------|-----------------------------------------------------------------------------------|\n+| Overall Door Status       | status           | doors               | String        | **Closed** if all closed otherwise **Open**. **Unknown** if no data is delivered  |\n+| Overall Window Status     | status           | windows             | String        | **Closed** if all closed otherwise **Open** or **Intermediate**. **Unknown** if no data is delivered   |\n+| Doors Locked              | status           | lock                | String        | Status if Doors are locked or unlocked                                            |\n+| Next Service Date         | status           | service-date        | DateTime      | Date of Upcoming Service                                                          |\n+| Mileage till Next Service | status           | service-mileage     | Number:Length | Mileage till Upcoming Service                                                     |\n+| Check Control             | status           | check-control       | String        | Indicator if CheckControl is **Active** or **Not Active**. **Unknown** if no data is delivered         |\n+| Charging Status           | status           | charge              | String        | Only available for PHEV, BEV_REX and BEV                                          |\n+| Last Status Timestamp     | status           | last-update         | DateTime      | Date and Time of last status update.                                              |\n+\n+See [further details for DateTime](#last-status-update-timestamp) in case of wrong timestamp values\n+\n+#### Services\n+\n+Group for all upcoming Services with Description, Service Date and / or Service Mileage\n+It's designed as [List Interface](#list-interface) so all upcoming Services can be checked.\n+\n+| Channel Label                  | Channel Group ID | Channel ID          | Type           | \n+|--------------------------------|------------------|---------------------|----------------|\n+| Service Name                   | service          | name                | String         |\n+| Service Date                   | service          | date                | Number         |\n+| Mileage till Service           | service          | mileage             | Number:Length  |\n+| Number of Scheduled Services   | service          | size                | String         |\n+| Current Selected Service Index | service          | index               | Number         |\n+| Select next Service            | service          | next                | Switch         |\n+\n+#### Check Control\n+\n+Group for all current active CheckControl Messages.\n+It's designed as [List Interface](#list-interface) to show all active Messages.\n+\n+| Channel Label                   | Channel Group ID | Channel ID          | Type           | \n+|---------------------------------|------------------|---------------------|----------------|\n+| CheckControl Description        | check            | name                | String         |\n+| CheckControl Mileage Occurrence | check            | mileage             | Number:Length  |\n+| Active CheckControl Messages    | check            | size                | String         |\n+| Selected CheckControl Message   | check            | index               | Number         |\n+| Next CheckControl Message       | check            | next                | Switch         |\n+\n+#### Doors Details\n+\n+Detailed Status of all Doors and Windows\n+Available for all Vehicles, Read-only. \n+\n+| Channel Label              | Channel Group ID | Channel ID              | Type          | \n+|----------------------------|------------------|-------------------------|---------------|\n+| Driver Door                | doors            | driver-front            | String        |\n+| Driver Door Rear           | doors            | driver-rear             | String        |\n+| Passenger Door             | doors            | passenger-front         | String        |\n+| Passenger Door Rear        | doors            | passenger-rear          | String        |\n+| Trunk                      | doors            | trunk                   | String        |\n+| Hood                       | doors            | hood                    | String        |\n+| Driver Door Window         | doors            | window-driver-front     | String        |\n+| Driver Door Rear Window    | doors            | window-driver-rear      | String        |\n+| Passenger Door Window      | doors            | window-passenger-front  | String        |\n+| Passenger Door Rear Window | doors            | window-passenger-rear   | String        |\n+| Rear Window                | doors            | window-rear             | String        |\n+| Sunroof                    | doors            | sunroof                 | String        |\n+\n+Following Strings will be delivered\n+\n+* UNKNOWN - no status data available\n+* INVALID - this item isn't applicable for this Vehicle\n+* CLOSED - the Door / Window is closed\n+* OPEN - the Door / Window is open\n+* INTERMEDIATE - Window in intermediate position, not applicable for Doors\n+\n+#### Range Data\n+\n+Based on Vehicle Type (Thing Type ID) some Channels are presented or not. \n+Conventional Fuel Vehicles don't provide *Electric Range* and Battery Electric Vehicles don't show *Range Fuel*.\n+Hybrid Vehicles have both and in addition *Hybrid Range*.\n+These are Read-only values.\n+\n+| Channel Label         | Channel Group ID | Channel ID            | Type                 | CONV | PHEV | BEV_REX | BEV |\n+|-----------------------|------------------|-----------------------|----------------------|------|------|---------|-----|\n+| Mileage               | range            | mileage               | Number:Length        |  X   |  X   |    X    |  X  |\n+| Fuel Range            | range            | range-fuel            | Number:Length        |  X   |  X   |    X    |     |\n+| Battery Range         | range            | range-electric        | Number:Length        |      |  X   |    X    |  X  | \n+| Hybrid Range          | range            | range-hybrid          | Number:Length        |      |  X   |    X    |     | \n+| Battery Charge Level  | range            | soc                   | Number:Dimensionless |      |  X   |    X    |  X  |\n+| Remaining Fuel        | range            | remaining-fuel        | Number:Volume        |  X   |  X   |    X    |     | \n+| Fuel Range Radius     | range            | range-radius-fuel     | Number:Length        |  X   |  X   |    X    |     | \n+| Electric Range Radius | range            | range-radius-electric | Number:Length        |      |  X   |    X    |  X  | \n+| Hybrid Range Radius   | range            | range-radius-hybrid   | Number:Length        |      |  X   |    X    |     | \n+\n+See Description [Range vs Range Radius](#range-vs-range-radius) to get more information\n+\n+#### Charge Profile\n+\n+Valid for Electric and Hybrid Vehicles\n+These are Read-only values.\n+\n+| Channel Label                      | Channel Group ID | Channel ID          | Type   | \n+|------------------------------------|------------------|---------------------|--------|\n+| Air Conditioning at Departure Time | charge           | profile-climate     | Switch | \n+| Charging Mode for Profile          | charge           | profile-mode        | String | \n+| Charging Window Start Time         | charge           | window-start        | String | \n+| Charging Window End Time           | charge           | window-end          | String | \n+| Timer 1: Departure Time            | charge           | timer1-departure    | String | \n+| Timer 1: Scheduled Days            | charge           | timer1-days         | String | \n+| Timer 1: Enabled                   | charge           | timer1-enabled      | Switch | \n+| Timer 2: Departure Time            | charge           | timer2-departure    | String | \n+| Timer 2: Scheduled Days            | charge           | timer2-days         | String | \n+| Timer 2: Enabled                   | charge           | timer2-enabled      | Switch | \n+| Timer 3: Departure Time            | charge           | timer3-departure    | String | \n+| Timer 3: Scheduled Days            | charge           | timer3-days         | String | \n+| Timer 3: Enabled                   | charge           | timer3-enabled      | Switch | \n+\n+\n+#### Location\n+\n+Available for all Vehicles.\n+These are Read-only values.\n+\n+| Channel Label  | Channel Group ID | Channel ID          | Type         | \n+|----------------|------------------|---------------------|--------------|\n+| Latitude       | location         | latitude            | Number       | \n+| Longitude      | location         | longitude           | Number       |\n+| Heading        | location         | heading             | Number:Angle | \n+\n+#### Last Trip\n+\n+Check [Vehicle Properties](#Properties) if *Statistics* is present in *Services Supported*\n+These are Read-only values.\n+\n+| Channel Label                           | Channel Group ID | Channel ID                   | Type          |\n+|-----------------------------------------|------------------|------------------------------|---------------|\n+| Last Trip Date                          | last-trip        | date                         | DateTime      |\n+| Last Trip Duration                      | last-trip        | duration                     | Number:Time   |\n+| Average Power Consumption per 100 km    | last-trip        | average-consumption          | Number:Power  |\n+| Average Combined Consumption per 100 km | last-trip        | average-combined-consumption | Number:Volume |\n+| Average Power Recuperation per 100 km   | last-trip        | average-recuperation         | Number:Power  |\n+| Last Trip Distance                      | last-trip        | distance                     | Number:Length |\n+| Distance since Last Charge              | last-trip        | distance-since-charging      | Number:Length |\n+\n+\n+#### Lifetime Statistics\n+\n+Check [Vehicle Properties](#Properties) if *Statistics* is present in *Services Supported*\n+These are Read-only values.\n+\n+| Channel Label                           | Channel Group ID | Channel ID                   | Type          | \n+|-----------------------------------------|------------------|------------------------------|---------------|\n+| Average Power Consumption per 100 km    | lifetime         | average-consumption          | Number:Power  |\n+| Average Power Recuperation per 100 km   | lifetime         | average-recuperation         | Number:Power  |\n+| Cumulated Electric Driven Distance      | lifetime         | cumulated-driven-distance    | Number:Length |\n+| Average Combined Consumption per 100 km | lifetime         | average-combined-consumption | Number:Volume |\n+| Longest Distance with one Charge        | lifetime         | single-longest-distance      | Number:Length |\n+\n+\n+#### Remote Services\n+\n+Check [Vehicle Properties](#Properties) *Services Activated* which Remote Services are available\n+Only one Remote Service can be executed each Time.\n+Parallel execution isn't supported.\n+The *Service Execution State* Channel is reporting the state.\n+State *Executed* is the final State when Execution is finished.\n+\n+| Channel Label           | Channel Group ID | Channel ID          | Type    | \n+|-------------------------|------------------|---------------------|---------|\n+| Activate Flash Lights   | remote           | light               | Switch  |\n+| Find Vehicle            | remote           | finder              | Switch  |\n+| Lock Doors              | remote           | lock                | Switch  |\n+| Unlock Doors            | remote           | unlock              | Switch  |\n+| Horn Blow               | remote           | horn                | Switch  |\n+| Active Air Conditioning | remote           | climate             | Switch  |\n+| Service Execution State | remote           | state               | STring  |\n+\n+#### Destinations\n+\n+Check [Vehicle Properties](#Properties) if *LastDestinations* is present in *Services Supported*\n+It's designed as [List Interface](#list-interface) in order to have access to all stored Destinations.\n+\n+| Channel Label                    | Channel Group ID | Channel ID          | Type    | \n+|----------------------------------|------------------|---------------------|---------|\n+| Destination Name                 | destination      | name                | String  |\n+| Destination Latitude             | destination      | latitude            | Number  |\n+| Destination Longitude            | destination      | longitude           | Number  |\n+| Number of Available Destinations | destination      | size                | String  |\n+| Index of Selected Destination    | destination      | index               | Number  |\n+| Skip to Next Destination         | destination      | next                | Switch  |\n+\n+\n+#### Image\n+\n+Available for all Vehicles.\n+Picture can be modified regarding *Viewport* and *Size*.\n+See [Things Section](#thing) for Viewport possibilities and [Status Image](#status-image) for possible Use Cases.\n+\n+| Channel Label                 | Channel Group ID | Channel ID          | Type   | \n+|-------------------------------|------------------|---------------------|--------|\n+| Rendered Image of the Vehicle | image            | png                 | Image  |\n+| Image Viewport                | image            | view                | String |\n+| Image Picture Size            | image            | size                | Number |\n+\n+\n+#### Troubleshooting\n+\n+Available for all Vehicles!\n+Switch will log a *Vehicle Data Fingerprint* into the openHAB log.\n+Please check [TroubleShooting Section](#TroubleShooting) for further advice.\n+\n+| Channel Label                       | Channel Group ID | Channel ID          | Type   | Description                                       |\n+|-------------------------------------|------------------|---------------------|--------|---------------------------------------------------|\n+| Log Vehicle Fingerprint             | troubleshoot     | vehicle-fingerprint | Switch | Forces log entries in openHAB logger in order to raise issues |\n+\n+## Further Descriptions\n+\n+### List Interface\n+\n+Currently there are 3 occurrences of dynamic data delivered as Lists\n+\n+* Upcoming Services\n+* Check Control Messages\n+* Last Destinations\n+\n+In order to provide all data the lists are organized the following way based on the Service Group example\n+\n+* **size** is the total length of the list. Read-only.\n+* **index** is the current selected index starting with 0 => list with size 10, valid index is between 0 - 9. If the index is set to _out of bounds_ it's set to first element. Read-write.\n+* **next** declares a switch for scrolling forward through the list in an endless way. Reaching end of list will start again from 0. Read-write.\n+* **name**, **mileage** and **date** declares the list item. It will change when setting new index or perform next. Read-only.\n+\n+### Range vs Range Radius\n+\n+<img align=\"right\" src=\"./doc/range-radius.png\" width=\"400\" height=\"350\"/>\n+\n+ will observe differences in the Vehicle Range and Range Radius values. \n+While Range is indicating the possible distance to be driven on roads the range radius indicates the reachable range on the Map.\n+\n+The right picture shows the distance between Kassel and Frankfurt in Germany. \n+While the Air-line Distance is ~145 Kilometer the Route Distance is ~192 Kilometer.\n+So Range value is the normal remaining range.\n+See the Section [OpenStreetMap](#openstreetMap-widget) how the Range Radius is used to indicate the reachable Range on Map.\n+Please note this is just an indicator and the effective range, especially for Electric Vehicles, \n+depends on many factors like driving style and electric consumers. \n+ \n+### Last Status Update Timestamp\n+\n+A timestamp is showing the last Vehicle Status update. If this isn't shown correctly please check the date settings.\n+In case of Raspberry Pi execute *raspi-config*, select *Localization Options*, the *Change Time Zone*\n+Select your *Geographical Area* and afterwards the correct City.\n+One restart of openHAB service with *systemctl restart openhab2* is necessary in order to see the corrected Time Settings.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTEzMTUxNA=="}, "originalCommit": {"oid": "e0bfe93e13df4a3c5de5f8819b94ebf795664904"}, "originalPosition": 393}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEzNzg5MDk5OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.bmwconnecteddrive/README.md", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wN1QxNjowNzo0NVrOHd62jw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yN1QwMjowMjoyOVrOILnjjw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTEzNDk5MQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            BMW has a high range of Vehicles supported by BMWs ConnectedDrive.\n          \n          \n            \n            BMW has a high range of Vehicles supported by BMW's ConnectedDrive.", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r501134991", "createdAt": "2020-10-07T16:07:45Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/README.md", "diffHunk": "@@ -0,0 +1,862 @@\n+# BMW ConnectedDrive Binding\n+\n+<img align=\"right\" src=\"./doc/bmw-connected.png\" width=\"150\" height=\"150\"/>\n+\n+The Binding provides a Connection between [BMWs ConnectedDrive Portal](https://www.bmw-connecteddrive.com/country-region-select/country-region-selection.html) and openHAB.\n+All Vehicles connected to an Account will be detected by the Discovery with the correct type \n+\n+* Conventional Fuel Vehicle\n+* Plugin-Hybrid Electrical Vehicle \n+* Battery Electric Vehicle with Range Extender\n+* Battery Electric Vehicle \n+\n+In addition Properties are attached with Information and Services provided by this Vehicle.\n+The provided data depends on \n+\n+1. the [Type](#Things) and \n+2. the Services mentioned in [Properties](#properties)\n+\n+Different Channel Groups are clustering all informations.\n+Check for each Group if it's supported for this Vehicle.\n+\n+Please note **this isn't a real-time Binding**. \n+If the Door is opened the state isn't transmitted and changed immediately. \n+This isn't a flaw in the Binding itself because the state in BMWs own ConnectedDrive App is also updated with some delay. \n+\n+## Supported Things\n+\n+### Bridge\n+\n+The Bridge establishes the Connection between BMW ConnectedDrive Portal and openHAB.\n+\n+| Name                       | Bridge Type ID | Description                                                |\n+|----------------------------|----------------|------------------------------------------------------------|\n+| BMW ConnectedDrive Account | account        | Access to BMW ConnectedDrive Portal for a specific user    |\n+\n+\n+### Things\n+\n+Four different Vehicle Types are provided. \n+They differ in the supported Channel Groups & Channels. \n+Conventional Fuel Vehicles have no _Charging Profile_, Electric Vehicles don't provide a _Fuel Range_. \n+For Hybrid Vehicles in addition to _Fuel and Electric Range_ the _Hybrid Range_ is shown.\n+ \n+| Name                                | Thing Type ID | Supported Channel Groups                                             |\n+|-------------------------------------|---------------|----------------------------------------------------------------------|\n+| BMW Electric Vehicle                | BEV           | status, range, location, service, check, charge, image, troubleshoot |\n+| BMW Electric Vehicle with REX       | BEV_REX       | status, range, location, service, check, charge, image, troubleshoot |\n+| BMW Plug-In-Hybrid Electric Vehicle | PHEV          | status, range, location, service, check, charge, image, troubleshoot |\n+| BMW Conventional Vehicle            | CONV          | status, range, location, service, check, image, troubleshoot         |\n+\n+ \n+#### Properties\n+\n+<img align=\"right\" src=\"./doc/properties.png\" width=\"500\" height=\"600\"/>\n+\n+For each Vehicle Properties are available. \n+Basically 3 Types of Information are registered as Properties\n+\n+* Informations regarding your Dealer with Address and Phone Number\n+* Which services are available / not available\n+* Vehicle Properties like Color, Model Type, Drive Train and Construction Year\n+\n+In the right picture  can see in *Services Activated* e.g. the *DoorLock* and *DoorUnlock* Services are mentioned. \n+This ensures [Channel Group _Remote Services_](#remote-services) is supporting Door lock and Door unlock.\n+\n+In  *Services Supported* the entry *LastDestination* is mentioned.\n+So it's valid to connect Channel Group [Last Destinations](#destinations) in order to display the last 3 Navigation Destinations.\n+\n+| Property Key       | Property Value      |  Supported Channel Groups    |\n+|--------------------|---------------------|------------------------------|\n+| Services Supported | Statistics          | last-trip, lifetime          |\n+| Services Supported | LastDestinations    | destinations                 |\n+| Services Activated | list of services    | remote                       |\n+\n+\n+## Discovery\n+\n+Auto Discovery is starting after creation of the Bridge towards BMW ConnectedDrive. \n+A list of your registered Vehicles is queried and all found Vehicles are added in Inbox.\n+Unique Identifier is the *Vehicle Identification Number* (VIN). \n+If a Thing is already declared in a  *.things configuration* Discovery won't highlight it again.\n+Properties will be attached to predefined Vehicles if the VIN is matching.\n+\n+## Configuration\n+\n+### Bridge\n+\n+| Parameter       | Type    | Description                                                             |           \n+|-----------------|---------|-------------------------------------------------------------------------|\n+| userName        | text    | BMW Connected Drive Username                  |\n+| password        | text    | BMW Connected Drive Password                  |\n+| region          | text    | Select Region in order to connect to the appropriate BMW Server.   |\n+\n+The region Configuration has 3 different possibilities\n+\n+* _NORTH_AMERICA_\n+* _CHINA_\n+* _ROW_ for Rest of World\n+\n+### Thing\n+\n+Same Configuration is needed for all Things\n+\n+| Parameter       | Type    | Description                           |           \n+|-----------------|---------|---------------------------------------|\n+| vin             | text    | Vehicle Identification Number (VIN)   |\n+| refreshInterval | integer | Refresh Interval in Minutes           |\n+| units           | text    | Unit Selection                        |\n+| imageSize       | integer | Image Size                            |\n+| imageViewport   | text    | Image Viewport                        |\n+\n+The units can be configured in 3 ways\n+\n+* _AUTODETECT_ selects Miles for US & UK, Kilometer otherwise\n+* _METRIC_ selects directly Kilometers\n+* _IMPERIAL_ selects directly Miles\n+\n+The imageVieport allows to show the Vehicle from different angels.\n+Possible values are \n+\n+* FRONT\n+* REAR\n+* SIDE\n+* DASHBOARD\n+* DRIVERDOOR\n+\n+## Channels\n+\n+There are many Channels available for each Vehicle. \n+For better overview they are clustered in different Channel Groups.\n+The Channel Groups are different for the Vehicle Types, on the build-in Sensors of the Vehicle and the activated Services.\n+\n+### Bridge Channels\n+\n+If the Vehicle isn't found in the Discovery force a log of Fingerprint Data which helps to analyze the problem.\n+Please check [TroubleShooting Section](#TroubleShooting) for further advice.\n+\n+| Channel Label         | Channel ID            | Type   | Description                                       |\n+|-----------------------|-----------------------|--------|---------------------------------------------------|\n+| Discovery Fingerprint | discovery-fingerprint | Switch | Forcing a log entry to analyze Discovery Problems |\n+\n+### Thing Channel Groups \n+\n+#### Vehicle Status\n+\n+Reflects Status of the Vehicle.\n+Available for all Vehicles, Read-only.\n+\n+| Channel Label             | Channel Group ID | Channel ID          | Type          | Description                                                                       |\n+|---------------------------|------------------|---------------------|---------------|-----------------------------------------------------------------------------------|\n+| Overall Door Status       | status           | doors               | String        | **Closed** if all closed otherwise **Open**. **Unknown** if no data is delivered  |\n+| Overall Window Status     | status           | windows             | String        | **Closed** if all closed otherwise **Open** or **Intermediate**. **Unknown** if no data is delivered   |\n+| Doors Locked              | status           | lock                | String        | Status if Doors are locked or unlocked                                            |\n+| Next Service Date         | status           | service-date        | DateTime      | Date of Upcoming Service                                                          |\n+| Mileage till Next Service | status           | service-mileage     | Number:Length | Mileage till Upcoming Service                                                     |\n+| Check Control             | status           | check-control       | String        | Indicator if CheckControl is **Active** or **Not Active**. **Unknown** if no data is delivered         |\n+| Charging Status           | status           | charge              | String        | Only available for PHEV, BEV_REX and BEV                                          |\n+| Last Status Timestamp     | status           | last-update         | DateTime      | Date and Time of last status update.                                              |\n+\n+See [further details for DateTime](#last-status-update-timestamp) in case of wrong timestamp values\n+\n+#### Services\n+\n+Group for all upcoming Services with Description, Service Date and / or Service Mileage\n+It's designed as [List Interface](#list-interface) so all upcoming Services can be checked.\n+\n+| Channel Label                  | Channel Group ID | Channel ID          | Type           | \n+|--------------------------------|------------------|---------------------|----------------|\n+| Service Name                   | service          | name                | String         |\n+| Service Date                   | service          | date                | Number         |\n+| Mileage till Service           | service          | mileage             | Number:Length  |\n+| Number of Scheduled Services   | service          | size                | String         |\n+| Current Selected Service Index | service          | index               | Number         |\n+| Select next Service            | service          | next                | Switch         |\n+\n+#### Check Control\n+\n+Group for all current active CheckControl Messages.\n+It's designed as [List Interface](#list-interface) to show all active Messages.\n+\n+| Channel Label                   | Channel Group ID | Channel ID          | Type           | \n+|---------------------------------|------------------|---------------------|----------------|\n+| CheckControl Description        | check            | name                | String         |\n+| CheckControl Mileage Occurrence | check            | mileage             | Number:Length  |\n+| Active CheckControl Messages    | check            | size                | String         |\n+| Selected CheckControl Message   | check            | index               | Number         |\n+| Next CheckControl Message       | check            | next                | Switch         |\n+\n+#### Doors Details\n+\n+Detailed Status of all Doors and Windows\n+Available for all Vehicles, Read-only. \n+\n+| Channel Label              | Channel Group ID | Channel ID              | Type          | \n+|----------------------------|------------------|-------------------------|---------------|\n+| Driver Door                | doors            | driver-front            | String        |\n+| Driver Door Rear           | doors            | driver-rear             | String        |\n+| Passenger Door             | doors            | passenger-front         | String        |\n+| Passenger Door Rear        | doors            | passenger-rear          | String        |\n+| Trunk                      | doors            | trunk                   | String        |\n+| Hood                       | doors            | hood                    | String        |\n+| Driver Door Window         | doors            | window-driver-front     | String        |\n+| Driver Door Rear Window    | doors            | window-driver-rear      | String        |\n+| Passenger Door Window      | doors            | window-passenger-front  | String        |\n+| Passenger Door Rear Window | doors            | window-passenger-rear   | String        |\n+| Rear Window                | doors            | window-rear             | String        |\n+| Sunroof                    | doors            | sunroof                 | String        |\n+\n+Following Strings will be delivered\n+\n+* UNKNOWN - no status data available\n+* INVALID - this item isn't applicable for this Vehicle\n+* CLOSED - the Door / Window is closed\n+* OPEN - the Door / Window is open\n+* INTERMEDIATE - Window in intermediate position, not applicable for Doors\n+\n+#### Range Data\n+\n+Based on Vehicle Type (Thing Type ID) some Channels are presented or not. \n+Conventional Fuel Vehicles don't provide *Electric Range* and Battery Electric Vehicles don't show *Range Fuel*.\n+Hybrid Vehicles have both and in addition *Hybrid Range*.\n+These are Read-only values.\n+\n+| Channel Label         | Channel Group ID | Channel ID            | Type                 | CONV | PHEV | BEV_REX | BEV |\n+|-----------------------|------------------|-----------------------|----------------------|------|------|---------|-----|\n+| Mileage               | range            | mileage               | Number:Length        |  X   |  X   |    X    |  X  |\n+| Fuel Range            | range            | range-fuel            | Number:Length        |  X   |  X   |    X    |     |\n+| Battery Range         | range            | range-electric        | Number:Length        |      |  X   |    X    |  X  | \n+| Hybrid Range          | range            | range-hybrid          | Number:Length        |      |  X   |    X    |     | \n+| Battery Charge Level  | range            | soc                   | Number:Dimensionless |      |  X   |    X    |  X  |\n+| Remaining Fuel        | range            | remaining-fuel        | Number:Volume        |  X   |  X   |    X    |     | \n+| Fuel Range Radius     | range            | range-radius-fuel     | Number:Length        |  X   |  X   |    X    |     | \n+| Electric Range Radius | range            | range-radius-electric | Number:Length        |      |  X   |    X    |  X  | \n+| Hybrid Range Radius   | range            | range-radius-hybrid   | Number:Length        |      |  X   |    X    |     | \n+\n+See Description [Range vs Range Radius](#range-vs-range-radius) to get more information\n+\n+#### Charge Profile\n+\n+Valid for Electric and Hybrid Vehicles\n+These are Read-only values.\n+\n+| Channel Label                      | Channel Group ID | Channel ID          | Type   | \n+|------------------------------------|------------------|---------------------|--------|\n+| Air Conditioning at Departure Time | charge           | profile-climate     | Switch | \n+| Charging Mode for Profile          | charge           | profile-mode        | String | \n+| Charging Window Start Time         | charge           | window-start        | String | \n+| Charging Window End Time           | charge           | window-end          | String | \n+| Timer 1: Departure Time            | charge           | timer1-departure    | String | \n+| Timer 1: Scheduled Days            | charge           | timer1-days         | String | \n+| Timer 1: Enabled                   | charge           | timer1-enabled      | Switch | \n+| Timer 2: Departure Time            | charge           | timer2-departure    | String | \n+| Timer 2: Scheduled Days            | charge           | timer2-days         | String | \n+| Timer 2: Enabled                   | charge           | timer2-enabled      | Switch | \n+| Timer 3: Departure Time            | charge           | timer3-departure    | String | \n+| Timer 3: Scheduled Days            | charge           | timer3-days         | String | \n+| Timer 3: Enabled                   | charge           | timer3-enabled      | Switch | \n+\n+\n+#### Location\n+\n+Available for all Vehicles.\n+These are Read-only values.\n+\n+| Channel Label  | Channel Group ID | Channel ID          | Type         | \n+|----------------|------------------|---------------------|--------------|\n+| Latitude       | location         | latitude            | Number       | \n+| Longitude      | location         | longitude           | Number       |\n+| Heading        | location         | heading             | Number:Angle | \n+\n+#### Last Trip\n+\n+Check [Vehicle Properties](#Properties) if *Statistics* is present in *Services Supported*\n+These are Read-only values.\n+\n+| Channel Label                           | Channel Group ID | Channel ID                   | Type          |\n+|-----------------------------------------|------------------|------------------------------|---------------|\n+| Last Trip Date                          | last-trip        | date                         | DateTime      |\n+| Last Trip Duration                      | last-trip        | duration                     | Number:Time   |\n+| Average Power Consumption per 100 km    | last-trip        | average-consumption          | Number:Power  |\n+| Average Combined Consumption per 100 km | last-trip        | average-combined-consumption | Number:Volume |\n+| Average Power Recuperation per 100 km   | last-trip        | average-recuperation         | Number:Power  |\n+| Last Trip Distance                      | last-trip        | distance                     | Number:Length |\n+| Distance since Last Charge              | last-trip        | distance-since-charging      | Number:Length |\n+\n+\n+#### Lifetime Statistics\n+\n+Check [Vehicle Properties](#Properties) if *Statistics* is present in *Services Supported*\n+These are Read-only values.\n+\n+| Channel Label                           | Channel Group ID | Channel ID                   | Type          | \n+|-----------------------------------------|------------------|------------------------------|---------------|\n+| Average Power Consumption per 100 km    | lifetime         | average-consumption          | Number:Power  |\n+| Average Power Recuperation per 100 km   | lifetime         | average-recuperation         | Number:Power  |\n+| Cumulated Electric Driven Distance      | lifetime         | cumulated-driven-distance    | Number:Length |\n+| Average Combined Consumption per 100 km | lifetime         | average-combined-consumption | Number:Volume |\n+| Longest Distance with one Charge        | lifetime         | single-longest-distance      | Number:Length |\n+\n+\n+#### Remote Services\n+\n+Check [Vehicle Properties](#Properties) *Services Activated* which Remote Services are available\n+Only one Remote Service can be executed each Time.\n+Parallel execution isn't supported.\n+The *Service Execution State* Channel is reporting the state.\n+State *Executed* is the final State when Execution is finished.\n+\n+| Channel Label           | Channel Group ID | Channel ID          | Type    | \n+|-------------------------|------------------|---------------------|---------|\n+| Activate Flash Lights   | remote           | light               | Switch  |\n+| Find Vehicle            | remote           | finder              | Switch  |\n+| Lock Doors              | remote           | lock                | Switch  |\n+| Unlock Doors            | remote           | unlock              | Switch  |\n+| Horn Blow               | remote           | horn                | Switch  |\n+| Active Air Conditioning | remote           | climate             | Switch  |\n+| Service Execution State | remote           | state               | STring  |\n+\n+#### Destinations\n+\n+Check [Vehicle Properties](#Properties) if *LastDestinations* is present in *Services Supported*\n+It's designed as [List Interface](#list-interface) in order to have access to all stored Destinations.\n+\n+| Channel Label                    | Channel Group ID | Channel ID          | Type    | \n+|----------------------------------|------------------|---------------------|---------|\n+| Destination Name                 | destination      | name                | String  |\n+| Destination Latitude             | destination      | latitude            | Number  |\n+| Destination Longitude            | destination      | longitude           | Number  |\n+| Number of Available Destinations | destination      | size                | String  |\n+| Index of Selected Destination    | destination      | index               | Number  |\n+| Skip to Next Destination         | destination      | next                | Switch  |\n+\n+\n+#### Image\n+\n+Available for all Vehicles.\n+Picture can be modified regarding *Viewport* and *Size*.\n+See [Things Section](#thing) for Viewport possibilities and [Status Image](#status-image) for possible Use Cases.\n+\n+| Channel Label                 | Channel Group ID | Channel ID          | Type   | \n+|-------------------------------|------------------|---------------------|--------|\n+| Rendered Image of the Vehicle | image            | png                 | Image  |\n+| Image Viewport                | image            | view                | String |\n+| Image Picture Size            | image            | size                | Number |\n+\n+\n+#### Troubleshooting\n+\n+Available for all Vehicles!\n+Switch will log a *Vehicle Data Fingerprint* into the openHAB log.\n+Please check [TroubleShooting Section](#TroubleShooting) for further advice.\n+\n+| Channel Label                       | Channel Group ID | Channel ID          | Type   | Description                                       |\n+|-------------------------------------|------------------|---------------------|--------|---------------------------------------------------|\n+| Log Vehicle Fingerprint             | troubleshoot     | vehicle-fingerprint | Switch | Forces log entries in openHAB logger in order to raise issues |\n+\n+## Further Descriptions\n+\n+### List Interface\n+\n+Currently there are 3 occurrences of dynamic data delivered as Lists\n+\n+* Upcoming Services\n+* Check Control Messages\n+* Last Destinations\n+\n+In order to provide all data the lists are organized the following way based on the Service Group example\n+\n+* **size** is the total length of the list. Read-only.\n+* **index** is the current selected index starting with 0 => list with size 10, valid index is between 0 - 9. If the index is set to _out of bounds_ it's set to first element. Read-write.\n+* **next** declares a switch for scrolling forward through the list in an endless way. Reaching end of list will start again from 0. Read-write.\n+* **name**, **mileage** and **date** declares the list item. It will change when setting new index or perform next. Read-only.\n+\n+### Range vs Range Radius\n+\n+<img align=\"right\" src=\"./doc/range-radius.png\" width=\"400\" height=\"350\"/>\n+\n+ will observe differences in the Vehicle Range and Range Radius values. \n+While Range is indicating the possible distance to be driven on roads the range radius indicates the reachable range on the Map.\n+\n+The right picture shows the distance between Kassel and Frankfurt in Germany. \n+While the Air-line Distance is ~145 Kilometer the Route Distance is ~192 Kilometer.\n+So Range value is the normal remaining range.\n+See the Section [OpenStreetMap](#openstreetMap-widget) how the Range Radius is used to indicate the reachable Range on Map.\n+Please note this is just an indicator and the effective range, especially for Electric Vehicles, \n+depends on many factors like driving style and electric consumers. \n+ \n+### Last Status Update Timestamp\n+\n+A timestamp is showing the last Vehicle Status update. If this isn't shown correctly please check the date settings.\n+In case of Raspberry Pi execute *raspi-config*, select *Localization Options*, the *Change Time Zone*\n+Select your *Geographical Area* and afterwards the correct City.\n+One restart of openHAB service with *systemctl restart openhab2* is necessary in order to see the corrected Time Settings.\n+ \n+Correct TimeZone is crucial for handling all Time information in openHAB and it's discussed many times in the Forum.\n+See [similar discussion in the openHAB Forum](https://community.openhab.org/t/solved-wrong-local-time-how-to-change/90938) which deals with the same problem.\n+\n+### TroubleShooting\n+\n+BMW has a high range of Vehicles supported by BMWs ConnectedDrive.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e0bfe93e13df4a3c5de5f8819b94ebf795664904"}, "originalPosition": 400}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTA1MzMyNw==", "bodyText": "Removed due to double occurrence of BMW in one sentence", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r549053327", "createdAt": "2020-12-27T02:02:29Z", "author": {"login": "weymann"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/README.md", "diffHunk": "@@ -0,0 +1,862 @@\n+# BMW ConnectedDrive Binding\n+\n+<img align=\"right\" src=\"./doc/bmw-connected.png\" width=\"150\" height=\"150\"/>\n+\n+The Binding provides a Connection between [BMWs ConnectedDrive Portal](https://www.bmw-connecteddrive.com/country-region-select/country-region-selection.html) and openHAB.\n+All Vehicles connected to an Account will be detected by the Discovery with the correct type \n+\n+* Conventional Fuel Vehicle\n+* Plugin-Hybrid Electrical Vehicle \n+* Battery Electric Vehicle with Range Extender\n+* Battery Electric Vehicle \n+\n+In addition Properties are attached with Information and Services provided by this Vehicle.\n+The provided data depends on \n+\n+1. the [Type](#Things) and \n+2. the Services mentioned in [Properties](#properties)\n+\n+Different Channel Groups are clustering all informations.\n+Check for each Group if it's supported for this Vehicle.\n+\n+Please note **this isn't a real-time Binding**. \n+If the Door is opened the state isn't transmitted and changed immediately. \n+This isn't a flaw in the Binding itself because the state in BMWs own ConnectedDrive App is also updated with some delay. \n+\n+## Supported Things\n+\n+### Bridge\n+\n+The Bridge establishes the Connection between BMW ConnectedDrive Portal and openHAB.\n+\n+| Name                       | Bridge Type ID | Description                                                |\n+|----------------------------|----------------|------------------------------------------------------------|\n+| BMW ConnectedDrive Account | account        | Access to BMW ConnectedDrive Portal for a specific user    |\n+\n+\n+### Things\n+\n+Four different Vehicle Types are provided. \n+They differ in the supported Channel Groups & Channels. \n+Conventional Fuel Vehicles have no _Charging Profile_, Electric Vehicles don't provide a _Fuel Range_. \n+For Hybrid Vehicles in addition to _Fuel and Electric Range_ the _Hybrid Range_ is shown.\n+ \n+| Name                                | Thing Type ID | Supported Channel Groups                                             |\n+|-------------------------------------|---------------|----------------------------------------------------------------------|\n+| BMW Electric Vehicle                | BEV           | status, range, location, service, check, charge, image, troubleshoot |\n+| BMW Electric Vehicle with REX       | BEV_REX       | status, range, location, service, check, charge, image, troubleshoot |\n+| BMW Plug-In-Hybrid Electric Vehicle | PHEV          | status, range, location, service, check, charge, image, troubleshoot |\n+| BMW Conventional Vehicle            | CONV          | status, range, location, service, check, image, troubleshoot         |\n+\n+ \n+#### Properties\n+\n+<img align=\"right\" src=\"./doc/properties.png\" width=\"500\" height=\"600\"/>\n+\n+For each Vehicle Properties are available. \n+Basically 3 Types of Information are registered as Properties\n+\n+* Informations regarding your Dealer with Address and Phone Number\n+* Which services are available / not available\n+* Vehicle Properties like Color, Model Type, Drive Train and Construction Year\n+\n+In the right picture  can see in *Services Activated* e.g. the *DoorLock* and *DoorUnlock* Services are mentioned. \n+This ensures [Channel Group _Remote Services_](#remote-services) is supporting Door lock and Door unlock.\n+\n+In  *Services Supported* the entry *LastDestination* is mentioned.\n+So it's valid to connect Channel Group [Last Destinations](#destinations) in order to display the last 3 Navigation Destinations.\n+\n+| Property Key       | Property Value      |  Supported Channel Groups    |\n+|--------------------|---------------------|------------------------------|\n+| Services Supported | Statistics          | last-trip, lifetime          |\n+| Services Supported | LastDestinations    | destinations                 |\n+| Services Activated | list of services    | remote                       |\n+\n+\n+## Discovery\n+\n+Auto Discovery is starting after creation of the Bridge towards BMW ConnectedDrive. \n+A list of your registered Vehicles is queried and all found Vehicles are added in Inbox.\n+Unique Identifier is the *Vehicle Identification Number* (VIN). \n+If a Thing is already declared in a  *.things configuration* Discovery won't highlight it again.\n+Properties will be attached to predefined Vehicles if the VIN is matching.\n+\n+## Configuration\n+\n+### Bridge\n+\n+| Parameter       | Type    | Description                                                             |           \n+|-----------------|---------|-------------------------------------------------------------------------|\n+| userName        | text    | BMW Connected Drive Username                  |\n+| password        | text    | BMW Connected Drive Password                  |\n+| region          | text    | Select Region in order to connect to the appropriate BMW Server.   |\n+\n+The region Configuration has 3 different possibilities\n+\n+* _NORTH_AMERICA_\n+* _CHINA_\n+* _ROW_ for Rest of World\n+\n+### Thing\n+\n+Same Configuration is needed for all Things\n+\n+| Parameter       | Type    | Description                           |           \n+|-----------------|---------|---------------------------------------|\n+| vin             | text    | Vehicle Identification Number (VIN)   |\n+| refreshInterval | integer | Refresh Interval in Minutes           |\n+| units           | text    | Unit Selection                        |\n+| imageSize       | integer | Image Size                            |\n+| imageViewport   | text    | Image Viewport                        |\n+\n+The units can be configured in 3 ways\n+\n+* _AUTODETECT_ selects Miles for US & UK, Kilometer otherwise\n+* _METRIC_ selects directly Kilometers\n+* _IMPERIAL_ selects directly Miles\n+\n+The imageVieport allows to show the Vehicle from different angels.\n+Possible values are \n+\n+* FRONT\n+* REAR\n+* SIDE\n+* DASHBOARD\n+* DRIVERDOOR\n+\n+## Channels\n+\n+There are many Channels available for each Vehicle. \n+For better overview they are clustered in different Channel Groups.\n+The Channel Groups are different for the Vehicle Types, on the build-in Sensors of the Vehicle and the activated Services.\n+\n+### Bridge Channels\n+\n+If the Vehicle isn't found in the Discovery force a log of Fingerprint Data which helps to analyze the problem.\n+Please check [TroubleShooting Section](#TroubleShooting) for further advice.\n+\n+| Channel Label         | Channel ID            | Type   | Description                                       |\n+|-----------------------|-----------------------|--------|---------------------------------------------------|\n+| Discovery Fingerprint | discovery-fingerprint | Switch | Forcing a log entry to analyze Discovery Problems |\n+\n+### Thing Channel Groups \n+\n+#### Vehicle Status\n+\n+Reflects Status of the Vehicle.\n+Available for all Vehicles, Read-only.\n+\n+| Channel Label             | Channel Group ID | Channel ID          | Type          | Description                                                                       |\n+|---------------------------|------------------|---------------------|---------------|-----------------------------------------------------------------------------------|\n+| Overall Door Status       | status           | doors               | String        | **Closed** if all closed otherwise **Open**. **Unknown** if no data is delivered  |\n+| Overall Window Status     | status           | windows             | String        | **Closed** if all closed otherwise **Open** or **Intermediate**. **Unknown** if no data is delivered   |\n+| Doors Locked              | status           | lock                | String        | Status if Doors are locked or unlocked                                            |\n+| Next Service Date         | status           | service-date        | DateTime      | Date of Upcoming Service                                                          |\n+| Mileage till Next Service | status           | service-mileage     | Number:Length | Mileage till Upcoming Service                                                     |\n+| Check Control             | status           | check-control       | String        | Indicator if CheckControl is **Active** or **Not Active**. **Unknown** if no data is delivered         |\n+| Charging Status           | status           | charge              | String        | Only available for PHEV, BEV_REX and BEV                                          |\n+| Last Status Timestamp     | status           | last-update         | DateTime      | Date and Time of last status update.                                              |\n+\n+See [further details for DateTime](#last-status-update-timestamp) in case of wrong timestamp values\n+\n+#### Services\n+\n+Group for all upcoming Services with Description, Service Date and / or Service Mileage\n+It's designed as [List Interface](#list-interface) so all upcoming Services can be checked.\n+\n+| Channel Label                  | Channel Group ID | Channel ID          | Type           | \n+|--------------------------------|------------------|---------------------|----------------|\n+| Service Name                   | service          | name                | String         |\n+| Service Date                   | service          | date                | Number         |\n+| Mileage till Service           | service          | mileage             | Number:Length  |\n+| Number of Scheduled Services   | service          | size                | String         |\n+| Current Selected Service Index | service          | index               | Number         |\n+| Select next Service            | service          | next                | Switch         |\n+\n+#### Check Control\n+\n+Group for all current active CheckControl Messages.\n+It's designed as [List Interface](#list-interface) to show all active Messages.\n+\n+| Channel Label                   | Channel Group ID | Channel ID          | Type           | \n+|---------------------------------|------------------|---------------------|----------------|\n+| CheckControl Description        | check            | name                | String         |\n+| CheckControl Mileage Occurrence | check            | mileage             | Number:Length  |\n+| Active CheckControl Messages    | check            | size                | String         |\n+| Selected CheckControl Message   | check            | index               | Number         |\n+| Next CheckControl Message       | check            | next                | Switch         |\n+\n+#### Doors Details\n+\n+Detailed Status of all Doors and Windows\n+Available for all Vehicles, Read-only. \n+\n+| Channel Label              | Channel Group ID | Channel ID              | Type          | \n+|----------------------------|------------------|-------------------------|---------------|\n+| Driver Door                | doors            | driver-front            | String        |\n+| Driver Door Rear           | doors            | driver-rear             | String        |\n+| Passenger Door             | doors            | passenger-front         | String        |\n+| Passenger Door Rear        | doors            | passenger-rear          | String        |\n+| Trunk                      | doors            | trunk                   | String        |\n+| Hood                       | doors            | hood                    | String        |\n+| Driver Door Window         | doors            | window-driver-front     | String        |\n+| Driver Door Rear Window    | doors            | window-driver-rear      | String        |\n+| Passenger Door Window      | doors            | window-passenger-front  | String        |\n+| Passenger Door Rear Window | doors            | window-passenger-rear   | String        |\n+| Rear Window                | doors            | window-rear             | String        |\n+| Sunroof                    | doors            | sunroof                 | String        |\n+\n+Following Strings will be delivered\n+\n+* UNKNOWN - no status data available\n+* INVALID - this item isn't applicable for this Vehicle\n+* CLOSED - the Door / Window is closed\n+* OPEN - the Door / Window is open\n+* INTERMEDIATE - Window in intermediate position, not applicable for Doors\n+\n+#### Range Data\n+\n+Based on Vehicle Type (Thing Type ID) some Channels are presented or not. \n+Conventional Fuel Vehicles don't provide *Electric Range* and Battery Electric Vehicles don't show *Range Fuel*.\n+Hybrid Vehicles have both and in addition *Hybrid Range*.\n+These are Read-only values.\n+\n+| Channel Label         | Channel Group ID | Channel ID            | Type                 | CONV | PHEV | BEV_REX | BEV |\n+|-----------------------|------------------|-----------------------|----------------------|------|------|---------|-----|\n+| Mileage               | range            | mileage               | Number:Length        |  X   |  X   |    X    |  X  |\n+| Fuel Range            | range            | range-fuel            | Number:Length        |  X   |  X   |    X    |     |\n+| Battery Range         | range            | range-electric        | Number:Length        |      |  X   |    X    |  X  | \n+| Hybrid Range          | range            | range-hybrid          | Number:Length        |      |  X   |    X    |     | \n+| Battery Charge Level  | range            | soc                   | Number:Dimensionless |      |  X   |    X    |  X  |\n+| Remaining Fuel        | range            | remaining-fuel        | Number:Volume        |  X   |  X   |    X    |     | \n+| Fuel Range Radius     | range            | range-radius-fuel     | Number:Length        |  X   |  X   |    X    |     | \n+| Electric Range Radius | range            | range-radius-electric | Number:Length        |      |  X   |    X    |  X  | \n+| Hybrid Range Radius   | range            | range-radius-hybrid   | Number:Length        |      |  X   |    X    |     | \n+\n+See Description [Range vs Range Radius](#range-vs-range-radius) to get more information\n+\n+#### Charge Profile\n+\n+Valid for Electric and Hybrid Vehicles\n+These are Read-only values.\n+\n+| Channel Label                      | Channel Group ID | Channel ID          | Type   | \n+|------------------------------------|------------------|---------------------|--------|\n+| Air Conditioning at Departure Time | charge           | profile-climate     | Switch | \n+| Charging Mode for Profile          | charge           | profile-mode        | String | \n+| Charging Window Start Time         | charge           | window-start        | String | \n+| Charging Window End Time           | charge           | window-end          | String | \n+| Timer 1: Departure Time            | charge           | timer1-departure    | String | \n+| Timer 1: Scheduled Days            | charge           | timer1-days         | String | \n+| Timer 1: Enabled                   | charge           | timer1-enabled      | Switch | \n+| Timer 2: Departure Time            | charge           | timer2-departure    | String | \n+| Timer 2: Scheduled Days            | charge           | timer2-days         | String | \n+| Timer 2: Enabled                   | charge           | timer2-enabled      | Switch | \n+| Timer 3: Departure Time            | charge           | timer3-departure    | String | \n+| Timer 3: Scheduled Days            | charge           | timer3-days         | String | \n+| Timer 3: Enabled                   | charge           | timer3-enabled      | Switch | \n+\n+\n+#### Location\n+\n+Available for all Vehicles.\n+These are Read-only values.\n+\n+| Channel Label  | Channel Group ID | Channel ID          | Type         | \n+|----------------|------------------|---------------------|--------------|\n+| Latitude       | location         | latitude            | Number       | \n+| Longitude      | location         | longitude           | Number       |\n+| Heading        | location         | heading             | Number:Angle | \n+\n+#### Last Trip\n+\n+Check [Vehicle Properties](#Properties) if *Statistics* is present in *Services Supported*\n+These are Read-only values.\n+\n+| Channel Label                           | Channel Group ID | Channel ID                   | Type          |\n+|-----------------------------------------|------------------|------------------------------|---------------|\n+| Last Trip Date                          | last-trip        | date                         | DateTime      |\n+| Last Trip Duration                      | last-trip        | duration                     | Number:Time   |\n+| Average Power Consumption per 100 km    | last-trip        | average-consumption          | Number:Power  |\n+| Average Combined Consumption per 100 km | last-trip        | average-combined-consumption | Number:Volume |\n+| Average Power Recuperation per 100 km   | last-trip        | average-recuperation         | Number:Power  |\n+| Last Trip Distance                      | last-trip        | distance                     | Number:Length |\n+| Distance since Last Charge              | last-trip        | distance-since-charging      | Number:Length |\n+\n+\n+#### Lifetime Statistics\n+\n+Check [Vehicle Properties](#Properties) if *Statistics* is present in *Services Supported*\n+These are Read-only values.\n+\n+| Channel Label                           | Channel Group ID | Channel ID                   | Type          | \n+|-----------------------------------------|------------------|------------------------------|---------------|\n+| Average Power Consumption per 100 km    | lifetime         | average-consumption          | Number:Power  |\n+| Average Power Recuperation per 100 km   | lifetime         | average-recuperation         | Number:Power  |\n+| Cumulated Electric Driven Distance      | lifetime         | cumulated-driven-distance    | Number:Length |\n+| Average Combined Consumption per 100 km | lifetime         | average-combined-consumption | Number:Volume |\n+| Longest Distance with one Charge        | lifetime         | single-longest-distance      | Number:Length |\n+\n+\n+#### Remote Services\n+\n+Check [Vehicle Properties](#Properties) *Services Activated* which Remote Services are available\n+Only one Remote Service can be executed each Time.\n+Parallel execution isn't supported.\n+The *Service Execution State* Channel is reporting the state.\n+State *Executed* is the final State when Execution is finished.\n+\n+| Channel Label           | Channel Group ID | Channel ID          | Type    | \n+|-------------------------|------------------|---------------------|---------|\n+| Activate Flash Lights   | remote           | light               | Switch  |\n+| Find Vehicle            | remote           | finder              | Switch  |\n+| Lock Doors              | remote           | lock                | Switch  |\n+| Unlock Doors            | remote           | unlock              | Switch  |\n+| Horn Blow               | remote           | horn                | Switch  |\n+| Active Air Conditioning | remote           | climate             | Switch  |\n+| Service Execution State | remote           | state               | STring  |\n+\n+#### Destinations\n+\n+Check [Vehicle Properties](#Properties) if *LastDestinations* is present in *Services Supported*\n+It's designed as [List Interface](#list-interface) in order to have access to all stored Destinations.\n+\n+| Channel Label                    | Channel Group ID | Channel ID          | Type    | \n+|----------------------------------|------------------|---------------------|---------|\n+| Destination Name                 | destination      | name                | String  |\n+| Destination Latitude             | destination      | latitude            | Number  |\n+| Destination Longitude            | destination      | longitude           | Number  |\n+| Number of Available Destinations | destination      | size                | String  |\n+| Index of Selected Destination    | destination      | index               | Number  |\n+| Skip to Next Destination         | destination      | next                | Switch  |\n+\n+\n+#### Image\n+\n+Available for all Vehicles.\n+Picture can be modified regarding *Viewport* and *Size*.\n+See [Things Section](#thing) for Viewport possibilities and [Status Image](#status-image) for possible Use Cases.\n+\n+| Channel Label                 | Channel Group ID | Channel ID          | Type   | \n+|-------------------------------|------------------|---------------------|--------|\n+| Rendered Image of the Vehicle | image            | png                 | Image  |\n+| Image Viewport                | image            | view                | String |\n+| Image Picture Size            | image            | size                | Number |\n+\n+\n+#### Troubleshooting\n+\n+Available for all Vehicles!\n+Switch will log a *Vehicle Data Fingerprint* into the openHAB log.\n+Please check [TroubleShooting Section](#TroubleShooting) for further advice.\n+\n+| Channel Label                       | Channel Group ID | Channel ID          | Type   | Description                                       |\n+|-------------------------------------|------------------|---------------------|--------|---------------------------------------------------|\n+| Log Vehicle Fingerprint             | troubleshoot     | vehicle-fingerprint | Switch | Forces log entries in openHAB logger in order to raise issues |\n+\n+## Further Descriptions\n+\n+### List Interface\n+\n+Currently there are 3 occurrences of dynamic data delivered as Lists\n+\n+* Upcoming Services\n+* Check Control Messages\n+* Last Destinations\n+\n+In order to provide all data the lists are organized the following way based on the Service Group example\n+\n+* **size** is the total length of the list. Read-only.\n+* **index** is the current selected index starting with 0 => list with size 10, valid index is between 0 - 9. If the index is set to _out of bounds_ it's set to first element. Read-write.\n+* **next** declares a switch for scrolling forward through the list in an endless way. Reaching end of list will start again from 0. Read-write.\n+* **name**, **mileage** and **date** declares the list item. It will change when setting new index or perform next. Read-only.\n+\n+### Range vs Range Radius\n+\n+<img align=\"right\" src=\"./doc/range-radius.png\" width=\"400\" height=\"350\"/>\n+\n+ will observe differences in the Vehicle Range and Range Radius values. \n+While Range is indicating the possible distance to be driven on roads the range radius indicates the reachable range on the Map.\n+\n+The right picture shows the distance between Kassel and Frankfurt in Germany. \n+While the Air-line Distance is ~145 Kilometer the Route Distance is ~192 Kilometer.\n+So Range value is the normal remaining range.\n+See the Section [OpenStreetMap](#openstreetMap-widget) how the Range Radius is used to indicate the reachable Range on Map.\n+Please note this is just an indicator and the effective range, especially for Electric Vehicles, \n+depends on many factors like driving style and electric consumers. \n+ \n+### Last Status Update Timestamp\n+\n+A timestamp is showing the last Vehicle Status update. If this isn't shown correctly please check the date settings.\n+In case of Raspberry Pi execute *raspi-config*, select *Localization Options*, the *Change Time Zone*\n+Select your *Geographical Area* and afterwards the correct City.\n+One restart of openHAB service with *systemctl restart openhab2* is necessary in order to see the corrected Time Settings.\n+ \n+Correct TimeZone is crucial for handling all Time information in openHAB and it's discussed many times in the Forum.\n+See [similar discussion in the openHAB Forum](https://community.openhab.org/t/solved-wrong-local-time-how-to-change/90938) which deals with the same problem.\n+\n+### TroubleShooting\n+\n+BMW has a high range of Vehicles supported by BMWs ConnectedDrive.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTEzNDk5MQ=="}, "originalCommit": {"oid": "e0bfe93e13df4a3c5de5f8819b94ebf795664904"}, "originalPosition": 400}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEzNzg5MzI5OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.bmwconnecteddrive/README.md", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wN1QxNjowODoxMlrOHd636g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yN1QwMjowMToxMVrOILnjOg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTEzNTMzOA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            * Can you login [into ConnectedDrive](https://www.bmw-connecteddrive.com/country-region-select/country-region-selection.html) with your Credentials? _Please note this isn't the BMW Customer Portal - it's the ConnectedDrive Portal_\n          \n          \n            \n            * Can you log [into ConnectedDrive](https://www.bmw-connecteddrive.com/country-region-select/country-region-selection.html) with your Credentials? _Please note this isn't the BMW Customer Portal - it's the ConnectedDrive Portal_", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r501135338", "createdAt": "2020-10-07T16:08:12Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/README.md", "diffHunk": "@@ -0,0 +1,862 @@\n+# BMW ConnectedDrive Binding\n+\n+<img align=\"right\" src=\"./doc/bmw-connected.png\" width=\"150\" height=\"150\"/>\n+\n+The Binding provides a Connection between [BMWs ConnectedDrive Portal](https://www.bmw-connecteddrive.com/country-region-select/country-region-selection.html) and openHAB.\n+All Vehicles connected to an Account will be detected by the Discovery with the correct type \n+\n+* Conventional Fuel Vehicle\n+* Plugin-Hybrid Electrical Vehicle \n+* Battery Electric Vehicle with Range Extender\n+* Battery Electric Vehicle \n+\n+In addition Properties are attached with Information and Services provided by this Vehicle.\n+The provided data depends on \n+\n+1. the [Type](#Things) and \n+2. the Services mentioned in [Properties](#properties)\n+\n+Different Channel Groups are clustering all informations.\n+Check for each Group if it's supported for this Vehicle.\n+\n+Please note **this isn't a real-time Binding**. \n+If the Door is opened the state isn't transmitted and changed immediately. \n+This isn't a flaw in the Binding itself because the state in BMWs own ConnectedDrive App is also updated with some delay. \n+\n+## Supported Things\n+\n+### Bridge\n+\n+The Bridge establishes the Connection between BMW ConnectedDrive Portal and openHAB.\n+\n+| Name                       | Bridge Type ID | Description                                                |\n+|----------------------------|----------------|------------------------------------------------------------|\n+| BMW ConnectedDrive Account | account        | Access to BMW ConnectedDrive Portal for a specific user    |\n+\n+\n+### Things\n+\n+Four different Vehicle Types are provided. \n+They differ in the supported Channel Groups & Channels. \n+Conventional Fuel Vehicles have no _Charging Profile_, Electric Vehicles don't provide a _Fuel Range_. \n+For Hybrid Vehicles in addition to _Fuel and Electric Range_ the _Hybrid Range_ is shown.\n+ \n+| Name                                | Thing Type ID | Supported Channel Groups                                             |\n+|-------------------------------------|---------------|----------------------------------------------------------------------|\n+| BMW Electric Vehicle                | BEV           | status, range, location, service, check, charge, image, troubleshoot |\n+| BMW Electric Vehicle with REX       | BEV_REX       | status, range, location, service, check, charge, image, troubleshoot |\n+| BMW Plug-In-Hybrid Electric Vehicle | PHEV          | status, range, location, service, check, charge, image, troubleshoot |\n+| BMW Conventional Vehicle            | CONV          | status, range, location, service, check, image, troubleshoot         |\n+\n+ \n+#### Properties\n+\n+<img align=\"right\" src=\"./doc/properties.png\" width=\"500\" height=\"600\"/>\n+\n+For each Vehicle Properties are available. \n+Basically 3 Types of Information are registered as Properties\n+\n+* Informations regarding your Dealer with Address and Phone Number\n+* Which services are available / not available\n+* Vehicle Properties like Color, Model Type, Drive Train and Construction Year\n+\n+In the right picture  can see in *Services Activated* e.g. the *DoorLock* and *DoorUnlock* Services are mentioned. \n+This ensures [Channel Group _Remote Services_](#remote-services) is supporting Door lock and Door unlock.\n+\n+In  *Services Supported* the entry *LastDestination* is mentioned.\n+So it's valid to connect Channel Group [Last Destinations](#destinations) in order to display the last 3 Navigation Destinations.\n+\n+| Property Key       | Property Value      |  Supported Channel Groups    |\n+|--------------------|---------------------|------------------------------|\n+| Services Supported | Statistics          | last-trip, lifetime          |\n+| Services Supported | LastDestinations    | destinations                 |\n+| Services Activated | list of services    | remote                       |\n+\n+\n+## Discovery\n+\n+Auto Discovery is starting after creation of the Bridge towards BMW ConnectedDrive. \n+A list of your registered Vehicles is queried and all found Vehicles are added in Inbox.\n+Unique Identifier is the *Vehicle Identification Number* (VIN). \n+If a Thing is already declared in a  *.things configuration* Discovery won't highlight it again.\n+Properties will be attached to predefined Vehicles if the VIN is matching.\n+\n+## Configuration\n+\n+### Bridge\n+\n+| Parameter       | Type    | Description                                                             |           \n+|-----------------|---------|-------------------------------------------------------------------------|\n+| userName        | text    | BMW Connected Drive Username                  |\n+| password        | text    | BMW Connected Drive Password                  |\n+| region          | text    | Select Region in order to connect to the appropriate BMW Server.   |\n+\n+The region Configuration has 3 different possibilities\n+\n+* _NORTH_AMERICA_\n+* _CHINA_\n+* _ROW_ for Rest of World\n+\n+### Thing\n+\n+Same Configuration is needed for all Things\n+\n+| Parameter       | Type    | Description                           |           \n+|-----------------|---------|---------------------------------------|\n+| vin             | text    | Vehicle Identification Number (VIN)   |\n+| refreshInterval | integer | Refresh Interval in Minutes           |\n+| units           | text    | Unit Selection                        |\n+| imageSize       | integer | Image Size                            |\n+| imageViewport   | text    | Image Viewport                        |\n+\n+The units can be configured in 3 ways\n+\n+* _AUTODETECT_ selects Miles for US & UK, Kilometer otherwise\n+* _METRIC_ selects directly Kilometers\n+* _IMPERIAL_ selects directly Miles\n+\n+The imageVieport allows to show the Vehicle from different angels.\n+Possible values are \n+\n+* FRONT\n+* REAR\n+* SIDE\n+* DASHBOARD\n+* DRIVERDOOR\n+\n+## Channels\n+\n+There are many Channels available for each Vehicle. \n+For better overview they are clustered in different Channel Groups.\n+The Channel Groups are different for the Vehicle Types, on the build-in Sensors of the Vehicle and the activated Services.\n+\n+### Bridge Channels\n+\n+If the Vehicle isn't found in the Discovery force a log of Fingerprint Data which helps to analyze the problem.\n+Please check [TroubleShooting Section](#TroubleShooting) for further advice.\n+\n+| Channel Label         | Channel ID            | Type   | Description                                       |\n+|-----------------------|-----------------------|--------|---------------------------------------------------|\n+| Discovery Fingerprint | discovery-fingerprint | Switch | Forcing a log entry to analyze Discovery Problems |\n+\n+### Thing Channel Groups \n+\n+#### Vehicle Status\n+\n+Reflects Status of the Vehicle.\n+Available for all Vehicles, Read-only.\n+\n+| Channel Label             | Channel Group ID | Channel ID          | Type          | Description                                                                       |\n+|---------------------------|------------------|---------------------|---------------|-----------------------------------------------------------------------------------|\n+| Overall Door Status       | status           | doors               | String        | **Closed** if all closed otherwise **Open**. **Unknown** if no data is delivered  |\n+| Overall Window Status     | status           | windows             | String        | **Closed** if all closed otherwise **Open** or **Intermediate**. **Unknown** if no data is delivered   |\n+| Doors Locked              | status           | lock                | String        | Status if Doors are locked or unlocked                                            |\n+| Next Service Date         | status           | service-date        | DateTime      | Date of Upcoming Service                                                          |\n+| Mileage till Next Service | status           | service-mileage     | Number:Length | Mileage till Upcoming Service                                                     |\n+| Check Control             | status           | check-control       | String        | Indicator if CheckControl is **Active** or **Not Active**. **Unknown** if no data is delivered         |\n+| Charging Status           | status           | charge              | String        | Only available for PHEV, BEV_REX and BEV                                          |\n+| Last Status Timestamp     | status           | last-update         | DateTime      | Date and Time of last status update.                                              |\n+\n+See [further details for DateTime](#last-status-update-timestamp) in case of wrong timestamp values\n+\n+#### Services\n+\n+Group for all upcoming Services with Description, Service Date and / or Service Mileage\n+It's designed as [List Interface](#list-interface) so all upcoming Services can be checked.\n+\n+| Channel Label                  | Channel Group ID | Channel ID          | Type           | \n+|--------------------------------|------------------|---------------------|----------------|\n+| Service Name                   | service          | name                | String         |\n+| Service Date                   | service          | date                | Number         |\n+| Mileage till Service           | service          | mileage             | Number:Length  |\n+| Number of Scheduled Services   | service          | size                | String         |\n+| Current Selected Service Index | service          | index               | Number         |\n+| Select next Service            | service          | next                | Switch         |\n+\n+#### Check Control\n+\n+Group for all current active CheckControl Messages.\n+It's designed as [List Interface](#list-interface) to show all active Messages.\n+\n+| Channel Label                   | Channel Group ID | Channel ID          | Type           | \n+|---------------------------------|------------------|---------------------|----------------|\n+| CheckControl Description        | check            | name                | String         |\n+| CheckControl Mileage Occurrence | check            | mileage             | Number:Length  |\n+| Active CheckControl Messages    | check            | size                | String         |\n+| Selected CheckControl Message   | check            | index               | Number         |\n+| Next CheckControl Message       | check            | next                | Switch         |\n+\n+#### Doors Details\n+\n+Detailed Status of all Doors and Windows\n+Available for all Vehicles, Read-only. \n+\n+| Channel Label              | Channel Group ID | Channel ID              | Type          | \n+|----------------------------|------------------|-------------------------|---------------|\n+| Driver Door                | doors            | driver-front            | String        |\n+| Driver Door Rear           | doors            | driver-rear             | String        |\n+| Passenger Door             | doors            | passenger-front         | String        |\n+| Passenger Door Rear        | doors            | passenger-rear          | String        |\n+| Trunk                      | doors            | trunk                   | String        |\n+| Hood                       | doors            | hood                    | String        |\n+| Driver Door Window         | doors            | window-driver-front     | String        |\n+| Driver Door Rear Window    | doors            | window-driver-rear      | String        |\n+| Passenger Door Window      | doors            | window-passenger-front  | String        |\n+| Passenger Door Rear Window | doors            | window-passenger-rear   | String        |\n+| Rear Window                | doors            | window-rear             | String        |\n+| Sunroof                    | doors            | sunroof                 | String        |\n+\n+Following Strings will be delivered\n+\n+* UNKNOWN - no status data available\n+* INVALID - this item isn't applicable for this Vehicle\n+* CLOSED - the Door / Window is closed\n+* OPEN - the Door / Window is open\n+* INTERMEDIATE - Window in intermediate position, not applicable for Doors\n+\n+#### Range Data\n+\n+Based on Vehicle Type (Thing Type ID) some Channels are presented or not. \n+Conventional Fuel Vehicles don't provide *Electric Range* and Battery Electric Vehicles don't show *Range Fuel*.\n+Hybrid Vehicles have both and in addition *Hybrid Range*.\n+These are Read-only values.\n+\n+| Channel Label         | Channel Group ID | Channel ID            | Type                 | CONV | PHEV | BEV_REX | BEV |\n+|-----------------------|------------------|-----------------------|----------------------|------|------|---------|-----|\n+| Mileage               | range            | mileage               | Number:Length        |  X   |  X   |    X    |  X  |\n+| Fuel Range            | range            | range-fuel            | Number:Length        |  X   |  X   |    X    |     |\n+| Battery Range         | range            | range-electric        | Number:Length        |      |  X   |    X    |  X  | \n+| Hybrid Range          | range            | range-hybrid          | Number:Length        |      |  X   |    X    |     | \n+| Battery Charge Level  | range            | soc                   | Number:Dimensionless |      |  X   |    X    |  X  |\n+| Remaining Fuel        | range            | remaining-fuel        | Number:Volume        |  X   |  X   |    X    |     | \n+| Fuel Range Radius     | range            | range-radius-fuel     | Number:Length        |  X   |  X   |    X    |     | \n+| Electric Range Radius | range            | range-radius-electric | Number:Length        |      |  X   |    X    |  X  | \n+| Hybrid Range Radius   | range            | range-radius-hybrid   | Number:Length        |      |  X   |    X    |     | \n+\n+See Description [Range vs Range Radius](#range-vs-range-radius) to get more information\n+\n+#### Charge Profile\n+\n+Valid for Electric and Hybrid Vehicles\n+These are Read-only values.\n+\n+| Channel Label                      | Channel Group ID | Channel ID          | Type   | \n+|------------------------------------|------------------|---------------------|--------|\n+| Air Conditioning at Departure Time | charge           | profile-climate     | Switch | \n+| Charging Mode for Profile          | charge           | profile-mode        | String | \n+| Charging Window Start Time         | charge           | window-start        | String | \n+| Charging Window End Time           | charge           | window-end          | String | \n+| Timer 1: Departure Time            | charge           | timer1-departure    | String | \n+| Timer 1: Scheduled Days            | charge           | timer1-days         | String | \n+| Timer 1: Enabled                   | charge           | timer1-enabled      | Switch | \n+| Timer 2: Departure Time            | charge           | timer2-departure    | String | \n+| Timer 2: Scheduled Days            | charge           | timer2-days         | String | \n+| Timer 2: Enabled                   | charge           | timer2-enabled      | Switch | \n+| Timer 3: Departure Time            | charge           | timer3-departure    | String | \n+| Timer 3: Scheduled Days            | charge           | timer3-days         | String | \n+| Timer 3: Enabled                   | charge           | timer3-enabled      | Switch | \n+\n+\n+#### Location\n+\n+Available for all Vehicles.\n+These are Read-only values.\n+\n+| Channel Label  | Channel Group ID | Channel ID          | Type         | \n+|----------------|------------------|---------------------|--------------|\n+| Latitude       | location         | latitude            | Number       | \n+| Longitude      | location         | longitude           | Number       |\n+| Heading        | location         | heading             | Number:Angle | \n+\n+#### Last Trip\n+\n+Check [Vehicle Properties](#Properties) if *Statistics* is present in *Services Supported*\n+These are Read-only values.\n+\n+| Channel Label                           | Channel Group ID | Channel ID                   | Type          |\n+|-----------------------------------------|------------------|------------------------------|---------------|\n+| Last Trip Date                          | last-trip        | date                         | DateTime      |\n+| Last Trip Duration                      | last-trip        | duration                     | Number:Time   |\n+| Average Power Consumption per 100 km    | last-trip        | average-consumption          | Number:Power  |\n+| Average Combined Consumption per 100 km | last-trip        | average-combined-consumption | Number:Volume |\n+| Average Power Recuperation per 100 km   | last-trip        | average-recuperation         | Number:Power  |\n+| Last Trip Distance                      | last-trip        | distance                     | Number:Length |\n+| Distance since Last Charge              | last-trip        | distance-since-charging      | Number:Length |\n+\n+\n+#### Lifetime Statistics\n+\n+Check [Vehicle Properties](#Properties) if *Statistics* is present in *Services Supported*\n+These are Read-only values.\n+\n+| Channel Label                           | Channel Group ID | Channel ID                   | Type          | \n+|-----------------------------------------|------------------|------------------------------|---------------|\n+| Average Power Consumption per 100 km    | lifetime         | average-consumption          | Number:Power  |\n+| Average Power Recuperation per 100 km   | lifetime         | average-recuperation         | Number:Power  |\n+| Cumulated Electric Driven Distance      | lifetime         | cumulated-driven-distance    | Number:Length |\n+| Average Combined Consumption per 100 km | lifetime         | average-combined-consumption | Number:Volume |\n+| Longest Distance with one Charge        | lifetime         | single-longest-distance      | Number:Length |\n+\n+\n+#### Remote Services\n+\n+Check [Vehicle Properties](#Properties) *Services Activated* which Remote Services are available\n+Only one Remote Service can be executed each Time.\n+Parallel execution isn't supported.\n+The *Service Execution State* Channel is reporting the state.\n+State *Executed* is the final State when Execution is finished.\n+\n+| Channel Label           | Channel Group ID | Channel ID          | Type    | \n+|-------------------------|------------------|---------------------|---------|\n+| Activate Flash Lights   | remote           | light               | Switch  |\n+| Find Vehicle            | remote           | finder              | Switch  |\n+| Lock Doors              | remote           | lock                | Switch  |\n+| Unlock Doors            | remote           | unlock              | Switch  |\n+| Horn Blow               | remote           | horn                | Switch  |\n+| Active Air Conditioning | remote           | climate             | Switch  |\n+| Service Execution State | remote           | state               | STring  |\n+\n+#### Destinations\n+\n+Check [Vehicle Properties](#Properties) if *LastDestinations* is present in *Services Supported*\n+It's designed as [List Interface](#list-interface) in order to have access to all stored Destinations.\n+\n+| Channel Label                    | Channel Group ID | Channel ID          | Type    | \n+|----------------------------------|------------------|---------------------|---------|\n+| Destination Name                 | destination      | name                | String  |\n+| Destination Latitude             | destination      | latitude            | Number  |\n+| Destination Longitude            | destination      | longitude           | Number  |\n+| Number of Available Destinations | destination      | size                | String  |\n+| Index of Selected Destination    | destination      | index               | Number  |\n+| Skip to Next Destination         | destination      | next                | Switch  |\n+\n+\n+#### Image\n+\n+Available for all Vehicles.\n+Picture can be modified regarding *Viewport* and *Size*.\n+See [Things Section](#thing) for Viewport possibilities and [Status Image](#status-image) for possible Use Cases.\n+\n+| Channel Label                 | Channel Group ID | Channel ID          | Type   | \n+|-------------------------------|------------------|---------------------|--------|\n+| Rendered Image of the Vehicle | image            | png                 | Image  |\n+| Image Viewport                | image            | view                | String |\n+| Image Picture Size            | image            | size                | Number |\n+\n+\n+#### Troubleshooting\n+\n+Available for all Vehicles!\n+Switch will log a *Vehicle Data Fingerprint* into the openHAB log.\n+Please check [TroubleShooting Section](#TroubleShooting) for further advice.\n+\n+| Channel Label                       | Channel Group ID | Channel ID          | Type   | Description                                       |\n+|-------------------------------------|------------------|---------------------|--------|---------------------------------------------------|\n+| Log Vehicle Fingerprint             | troubleshoot     | vehicle-fingerprint | Switch | Forces log entries in openHAB logger in order to raise issues |\n+\n+## Further Descriptions\n+\n+### List Interface\n+\n+Currently there are 3 occurrences of dynamic data delivered as Lists\n+\n+* Upcoming Services\n+* Check Control Messages\n+* Last Destinations\n+\n+In order to provide all data the lists are organized the following way based on the Service Group example\n+\n+* **size** is the total length of the list. Read-only.\n+* **index** is the current selected index starting with 0 => list with size 10, valid index is between 0 - 9. If the index is set to _out of bounds_ it's set to first element. Read-write.\n+* **next** declares a switch for scrolling forward through the list in an endless way. Reaching end of list will start again from 0. Read-write.\n+* **name**, **mileage** and **date** declares the list item. It will change when setting new index or perform next. Read-only.\n+\n+### Range vs Range Radius\n+\n+<img align=\"right\" src=\"./doc/range-radius.png\" width=\"400\" height=\"350\"/>\n+\n+ will observe differences in the Vehicle Range and Range Radius values. \n+While Range is indicating the possible distance to be driven on roads the range radius indicates the reachable range on the Map.\n+\n+The right picture shows the distance between Kassel and Frankfurt in Germany. \n+While the Air-line Distance is ~145 Kilometer the Route Distance is ~192 Kilometer.\n+So Range value is the normal remaining range.\n+See the Section [OpenStreetMap](#openstreetMap-widget) how the Range Radius is used to indicate the reachable Range on Map.\n+Please note this is just an indicator and the effective range, especially for Electric Vehicles, \n+depends on many factors like driving style and electric consumers. \n+ \n+### Last Status Update Timestamp\n+\n+A timestamp is showing the last Vehicle Status update. If this isn't shown correctly please check the date settings.\n+In case of Raspberry Pi execute *raspi-config*, select *Localization Options*, the *Change Time Zone*\n+Select your *Geographical Area* and afterwards the correct City.\n+One restart of openHAB service with *systemctl restart openhab2* is necessary in order to see the corrected Time Settings.\n+ \n+Correct TimeZone is crucial for handling all Time information in openHAB and it's discussed many times in the Forum.\n+See [similar discussion in the openHAB Forum](https://community.openhab.org/t/solved-wrong-local-time-how-to-change/90938) which deals with the same problem.\n+\n+### TroubleShooting\n+\n+BMW has a high range of Vehicles supported by BMWs ConnectedDrive.\n+In case of any issues with this Binding please help to resolve it! \n+Please perform the following Steps:\n+\n+* Can you login [into ConnectedDrive](https://www.bmw-connecteddrive.com/country-region-select/country-region-selection.html) with your Credentials? _Please note this isn't the BMW Customer Portal - it's the ConnectedDrive Portal_", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e0bfe93e13df4a3c5de5f8819b94ebf795664904"}, "originalPosition": 404}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTA1MzI0Mg==", "bodyText": "Corrected", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r549053242", "createdAt": "2020-12-27T02:01:11Z", "author": {"login": "weymann"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/README.md", "diffHunk": "@@ -0,0 +1,862 @@\n+# BMW ConnectedDrive Binding\n+\n+<img align=\"right\" src=\"./doc/bmw-connected.png\" width=\"150\" height=\"150\"/>\n+\n+The Binding provides a Connection between [BMWs ConnectedDrive Portal](https://www.bmw-connecteddrive.com/country-region-select/country-region-selection.html) and openHAB.\n+All Vehicles connected to an Account will be detected by the Discovery with the correct type \n+\n+* Conventional Fuel Vehicle\n+* Plugin-Hybrid Electrical Vehicle \n+* Battery Electric Vehicle with Range Extender\n+* Battery Electric Vehicle \n+\n+In addition Properties are attached with Information and Services provided by this Vehicle.\n+The provided data depends on \n+\n+1. the [Type](#Things) and \n+2. the Services mentioned in [Properties](#properties)\n+\n+Different Channel Groups are clustering all informations.\n+Check for each Group if it's supported for this Vehicle.\n+\n+Please note **this isn't a real-time Binding**. \n+If the Door is opened the state isn't transmitted and changed immediately. \n+This isn't a flaw in the Binding itself because the state in BMWs own ConnectedDrive App is also updated with some delay. \n+\n+## Supported Things\n+\n+### Bridge\n+\n+The Bridge establishes the Connection between BMW ConnectedDrive Portal and openHAB.\n+\n+| Name                       | Bridge Type ID | Description                                                |\n+|----------------------------|----------------|------------------------------------------------------------|\n+| BMW ConnectedDrive Account | account        | Access to BMW ConnectedDrive Portal for a specific user    |\n+\n+\n+### Things\n+\n+Four different Vehicle Types are provided. \n+They differ in the supported Channel Groups & Channels. \n+Conventional Fuel Vehicles have no _Charging Profile_, Electric Vehicles don't provide a _Fuel Range_. \n+For Hybrid Vehicles in addition to _Fuel and Electric Range_ the _Hybrid Range_ is shown.\n+ \n+| Name                                | Thing Type ID | Supported Channel Groups                                             |\n+|-------------------------------------|---------------|----------------------------------------------------------------------|\n+| BMW Electric Vehicle                | BEV           | status, range, location, service, check, charge, image, troubleshoot |\n+| BMW Electric Vehicle with REX       | BEV_REX       | status, range, location, service, check, charge, image, troubleshoot |\n+| BMW Plug-In-Hybrid Electric Vehicle | PHEV          | status, range, location, service, check, charge, image, troubleshoot |\n+| BMW Conventional Vehicle            | CONV          | status, range, location, service, check, image, troubleshoot         |\n+\n+ \n+#### Properties\n+\n+<img align=\"right\" src=\"./doc/properties.png\" width=\"500\" height=\"600\"/>\n+\n+For each Vehicle Properties are available. \n+Basically 3 Types of Information are registered as Properties\n+\n+* Informations regarding your Dealer with Address and Phone Number\n+* Which services are available / not available\n+* Vehicle Properties like Color, Model Type, Drive Train and Construction Year\n+\n+In the right picture  can see in *Services Activated* e.g. the *DoorLock* and *DoorUnlock* Services are mentioned. \n+This ensures [Channel Group _Remote Services_](#remote-services) is supporting Door lock and Door unlock.\n+\n+In  *Services Supported* the entry *LastDestination* is mentioned.\n+So it's valid to connect Channel Group [Last Destinations](#destinations) in order to display the last 3 Navigation Destinations.\n+\n+| Property Key       | Property Value      |  Supported Channel Groups    |\n+|--------------------|---------------------|------------------------------|\n+| Services Supported | Statistics          | last-trip, lifetime          |\n+| Services Supported | LastDestinations    | destinations                 |\n+| Services Activated | list of services    | remote                       |\n+\n+\n+## Discovery\n+\n+Auto Discovery is starting after creation of the Bridge towards BMW ConnectedDrive. \n+A list of your registered Vehicles is queried and all found Vehicles are added in Inbox.\n+Unique Identifier is the *Vehicle Identification Number* (VIN). \n+If a Thing is already declared in a  *.things configuration* Discovery won't highlight it again.\n+Properties will be attached to predefined Vehicles if the VIN is matching.\n+\n+## Configuration\n+\n+### Bridge\n+\n+| Parameter       | Type    | Description                                                             |           \n+|-----------------|---------|-------------------------------------------------------------------------|\n+| userName        | text    | BMW Connected Drive Username                  |\n+| password        | text    | BMW Connected Drive Password                  |\n+| region          | text    | Select Region in order to connect to the appropriate BMW Server.   |\n+\n+The region Configuration has 3 different possibilities\n+\n+* _NORTH_AMERICA_\n+* _CHINA_\n+* _ROW_ for Rest of World\n+\n+### Thing\n+\n+Same Configuration is needed for all Things\n+\n+| Parameter       | Type    | Description                           |           \n+|-----------------|---------|---------------------------------------|\n+| vin             | text    | Vehicle Identification Number (VIN)   |\n+| refreshInterval | integer | Refresh Interval in Minutes           |\n+| units           | text    | Unit Selection                        |\n+| imageSize       | integer | Image Size                            |\n+| imageViewport   | text    | Image Viewport                        |\n+\n+The units can be configured in 3 ways\n+\n+* _AUTODETECT_ selects Miles for US & UK, Kilometer otherwise\n+* _METRIC_ selects directly Kilometers\n+* _IMPERIAL_ selects directly Miles\n+\n+The imageVieport allows to show the Vehicle from different angels.\n+Possible values are \n+\n+* FRONT\n+* REAR\n+* SIDE\n+* DASHBOARD\n+* DRIVERDOOR\n+\n+## Channels\n+\n+There are many Channels available for each Vehicle. \n+For better overview they are clustered in different Channel Groups.\n+The Channel Groups are different for the Vehicle Types, on the build-in Sensors of the Vehicle and the activated Services.\n+\n+### Bridge Channels\n+\n+If the Vehicle isn't found in the Discovery force a log of Fingerprint Data which helps to analyze the problem.\n+Please check [TroubleShooting Section](#TroubleShooting) for further advice.\n+\n+| Channel Label         | Channel ID            | Type   | Description                                       |\n+|-----------------------|-----------------------|--------|---------------------------------------------------|\n+| Discovery Fingerprint | discovery-fingerprint | Switch | Forcing a log entry to analyze Discovery Problems |\n+\n+### Thing Channel Groups \n+\n+#### Vehicle Status\n+\n+Reflects Status of the Vehicle.\n+Available for all Vehicles, Read-only.\n+\n+| Channel Label             | Channel Group ID | Channel ID          | Type          | Description                                                                       |\n+|---------------------------|------------------|---------------------|---------------|-----------------------------------------------------------------------------------|\n+| Overall Door Status       | status           | doors               | String        | **Closed** if all closed otherwise **Open**. **Unknown** if no data is delivered  |\n+| Overall Window Status     | status           | windows             | String        | **Closed** if all closed otherwise **Open** or **Intermediate**. **Unknown** if no data is delivered   |\n+| Doors Locked              | status           | lock                | String        | Status if Doors are locked or unlocked                                            |\n+| Next Service Date         | status           | service-date        | DateTime      | Date of Upcoming Service                                                          |\n+| Mileage till Next Service | status           | service-mileage     | Number:Length | Mileage till Upcoming Service                                                     |\n+| Check Control             | status           | check-control       | String        | Indicator if CheckControl is **Active** or **Not Active**. **Unknown** if no data is delivered         |\n+| Charging Status           | status           | charge              | String        | Only available for PHEV, BEV_REX and BEV                                          |\n+| Last Status Timestamp     | status           | last-update         | DateTime      | Date and Time of last status update.                                              |\n+\n+See [further details for DateTime](#last-status-update-timestamp) in case of wrong timestamp values\n+\n+#### Services\n+\n+Group for all upcoming Services with Description, Service Date and / or Service Mileage\n+It's designed as [List Interface](#list-interface) so all upcoming Services can be checked.\n+\n+| Channel Label                  | Channel Group ID | Channel ID          | Type           | \n+|--------------------------------|------------------|---------------------|----------------|\n+| Service Name                   | service          | name                | String         |\n+| Service Date                   | service          | date                | Number         |\n+| Mileage till Service           | service          | mileage             | Number:Length  |\n+| Number of Scheduled Services   | service          | size                | String         |\n+| Current Selected Service Index | service          | index               | Number         |\n+| Select next Service            | service          | next                | Switch         |\n+\n+#### Check Control\n+\n+Group for all current active CheckControl Messages.\n+It's designed as [List Interface](#list-interface) to show all active Messages.\n+\n+| Channel Label                   | Channel Group ID | Channel ID          | Type           | \n+|---------------------------------|------------------|---------------------|----------------|\n+| CheckControl Description        | check            | name                | String         |\n+| CheckControl Mileage Occurrence | check            | mileage             | Number:Length  |\n+| Active CheckControl Messages    | check            | size                | String         |\n+| Selected CheckControl Message   | check            | index               | Number         |\n+| Next CheckControl Message       | check            | next                | Switch         |\n+\n+#### Doors Details\n+\n+Detailed Status of all Doors and Windows\n+Available for all Vehicles, Read-only. \n+\n+| Channel Label              | Channel Group ID | Channel ID              | Type          | \n+|----------------------------|------------------|-------------------------|---------------|\n+| Driver Door                | doors            | driver-front            | String        |\n+| Driver Door Rear           | doors            | driver-rear             | String        |\n+| Passenger Door             | doors            | passenger-front         | String        |\n+| Passenger Door Rear        | doors            | passenger-rear          | String        |\n+| Trunk                      | doors            | trunk                   | String        |\n+| Hood                       | doors            | hood                    | String        |\n+| Driver Door Window         | doors            | window-driver-front     | String        |\n+| Driver Door Rear Window    | doors            | window-driver-rear      | String        |\n+| Passenger Door Window      | doors            | window-passenger-front  | String        |\n+| Passenger Door Rear Window | doors            | window-passenger-rear   | String        |\n+| Rear Window                | doors            | window-rear             | String        |\n+| Sunroof                    | doors            | sunroof                 | String        |\n+\n+Following Strings will be delivered\n+\n+* UNKNOWN - no status data available\n+* INVALID - this item isn't applicable for this Vehicle\n+* CLOSED - the Door / Window is closed\n+* OPEN - the Door / Window is open\n+* INTERMEDIATE - Window in intermediate position, not applicable for Doors\n+\n+#### Range Data\n+\n+Based on Vehicle Type (Thing Type ID) some Channels are presented or not. \n+Conventional Fuel Vehicles don't provide *Electric Range* and Battery Electric Vehicles don't show *Range Fuel*.\n+Hybrid Vehicles have both and in addition *Hybrid Range*.\n+These are Read-only values.\n+\n+| Channel Label         | Channel Group ID | Channel ID            | Type                 | CONV | PHEV | BEV_REX | BEV |\n+|-----------------------|------------------|-----------------------|----------------------|------|------|---------|-----|\n+| Mileage               | range            | mileage               | Number:Length        |  X   |  X   |    X    |  X  |\n+| Fuel Range            | range            | range-fuel            | Number:Length        |  X   |  X   |    X    |     |\n+| Battery Range         | range            | range-electric        | Number:Length        |      |  X   |    X    |  X  | \n+| Hybrid Range          | range            | range-hybrid          | Number:Length        |      |  X   |    X    |     | \n+| Battery Charge Level  | range            | soc                   | Number:Dimensionless |      |  X   |    X    |  X  |\n+| Remaining Fuel        | range            | remaining-fuel        | Number:Volume        |  X   |  X   |    X    |     | \n+| Fuel Range Radius     | range            | range-radius-fuel     | Number:Length        |  X   |  X   |    X    |     | \n+| Electric Range Radius | range            | range-radius-electric | Number:Length        |      |  X   |    X    |  X  | \n+| Hybrid Range Radius   | range            | range-radius-hybrid   | Number:Length        |      |  X   |    X    |     | \n+\n+See Description [Range vs Range Radius](#range-vs-range-radius) to get more information\n+\n+#### Charge Profile\n+\n+Valid for Electric and Hybrid Vehicles\n+These are Read-only values.\n+\n+| Channel Label                      | Channel Group ID | Channel ID          | Type   | \n+|------------------------------------|------------------|---------------------|--------|\n+| Air Conditioning at Departure Time | charge           | profile-climate     | Switch | \n+| Charging Mode for Profile          | charge           | profile-mode        | String | \n+| Charging Window Start Time         | charge           | window-start        | String | \n+| Charging Window End Time           | charge           | window-end          | String | \n+| Timer 1: Departure Time            | charge           | timer1-departure    | String | \n+| Timer 1: Scheduled Days            | charge           | timer1-days         | String | \n+| Timer 1: Enabled                   | charge           | timer1-enabled      | Switch | \n+| Timer 2: Departure Time            | charge           | timer2-departure    | String | \n+| Timer 2: Scheduled Days            | charge           | timer2-days         | String | \n+| Timer 2: Enabled                   | charge           | timer2-enabled      | Switch | \n+| Timer 3: Departure Time            | charge           | timer3-departure    | String | \n+| Timer 3: Scheduled Days            | charge           | timer3-days         | String | \n+| Timer 3: Enabled                   | charge           | timer3-enabled      | Switch | \n+\n+\n+#### Location\n+\n+Available for all Vehicles.\n+These are Read-only values.\n+\n+| Channel Label  | Channel Group ID | Channel ID          | Type         | \n+|----------------|------------------|---------------------|--------------|\n+| Latitude       | location         | latitude            | Number       | \n+| Longitude      | location         | longitude           | Number       |\n+| Heading        | location         | heading             | Number:Angle | \n+\n+#### Last Trip\n+\n+Check [Vehicle Properties](#Properties) if *Statistics* is present in *Services Supported*\n+These are Read-only values.\n+\n+| Channel Label                           | Channel Group ID | Channel ID                   | Type          |\n+|-----------------------------------------|------------------|------------------------------|---------------|\n+| Last Trip Date                          | last-trip        | date                         | DateTime      |\n+| Last Trip Duration                      | last-trip        | duration                     | Number:Time   |\n+| Average Power Consumption per 100 km    | last-trip        | average-consumption          | Number:Power  |\n+| Average Combined Consumption per 100 km | last-trip        | average-combined-consumption | Number:Volume |\n+| Average Power Recuperation per 100 km   | last-trip        | average-recuperation         | Number:Power  |\n+| Last Trip Distance                      | last-trip        | distance                     | Number:Length |\n+| Distance since Last Charge              | last-trip        | distance-since-charging      | Number:Length |\n+\n+\n+#### Lifetime Statistics\n+\n+Check [Vehicle Properties](#Properties) if *Statistics* is present in *Services Supported*\n+These are Read-only values.\n+\n+| Channel Label                           | Channel Group ID | Channel ID                   | Type          | \n+|-----------------------------------------|------------------|------------------------------|---------------|\n+| Average Power Consumption per 100 km    | lifetime         | average-consumption          | Number:Power  |\n+| Average Power Recuperation per 100 km   | lifetime         | average-recuperation         | Number:Power  |\n+| Cumulated Electric Driven Distance      | lifetime         | cumulated-driven-distance    | Number:Length |\n+| Average Combined Consumption per 100 km | lifetime         | average-combined-consumption | Number:Volume |\n+| Longest Distance with one Charge        | lifetime         | single-longest-distance      | Number:Length |\n+\n+\n+#### Remote Services\n+\n+Check [Vehicle Properties](#Properties) *Services Activated* which Remote Services are available\n+Only one Remote Service can be executed each Time.\n+Parallel execution isn't supported.\n+The *Service Execution State* Channel is reporting the state.\n+State *Executed* is the final State when Execution is finished.\n+\n+| Channel Label           | Channel Group ID | Channel ID          | Type    | \n+|-------------------------|------------------|---------------------|---------|\n+| Activate Flash Lights   | remote           | light               | Switch  |\n+| Find Vehicle            | remote           | finder              | Switch  |\n+| Lock Doors              | remote           | lock                | Switch  |\n+| Unlock Doors            | remote           | unlock              | Switch  |\n+| Horn Blow               | remote           | horn                | Switch  |\n+| Active Air Conditioning | remote           | climate             | Switch  |\n+| Service Execution State | remote           | state               | STring  |\n+\n+#### Destinations\n+\n+Check [Vehicle Properties](#Properties) if *LastDestinations* is present in *Services Supported*\n+It's designed as [List Interface](#list-interface) in order to have access to all stored Destinations.\n+\n+| Channel Label                    | Channel Group ID | Channel ID          | Type    | \n+|----------------------------------|------------------|---------------------|---------|\n+| Destination Name                 | destination      | name                | String  |\n+| Destination Latitude             | destination      | latitude            | Number  |\n+| Destination Longitude            | destination      | longitude           | Number  |\n+| Number of Available Destinations | destination      | size                | String  |\n+| Index of Selected Destination    | destination      | index               | Number  |\n+| Skip to Next Destination         | destination      | next                | Switch  |\n+\n+\n+#### Image\n+\n+Available for all Vehicles.\n+Picture can be modified regarding *Viewport* and *Size*.\n+See [Things Section](#thing) for Viewport possibilities and [Status Image](#status-image) for possible Use Cases.\n+\n+| Channel Label                 | Channel Group ID | Channel ID          | Type   | \n+|-------------------------------|------------------|---------------------|--------|\n+| Rendered Image of the Vehicle | image            | png                 | Image  |\n+| Image Viewport                | image            | view                | String |\n+| Image Picture Size            | image            | size                | Number |\n+\n+\n+#### Troubleshooting\n+\n+Available for all Vehicles!\n+Switch will log a *Vehicle Data Fingerprint* into the openHAB log.\n+Please check [TroubleShooting Section](#TroubleShooting) for further advice.\n+\n+| Channel Label                       | Channel Group ID | Channel ID          | Type   | Description                                       |\n+|-------------------------------------|------------------|---------------------|--------|---------------------------------------------------|\n+| Log Vehicle Fingerprint             | troubleshoot     | vehicle-fingerprint | Switch | Forces log entries in openHAB logger in order to raise issues |\n+\n+## Further Descriptions\n+\n+### List Interface\n+\n+Currently there are 3 occurrences of dynamic data delivered as Lists\n+\n+* Upcoming Services\n+* Check Control Messages\n+* Last Destinations\n+\n+In order to provide all data the lists are organized the following way based on the Service Group example\n+\n+* **size** is the total length of the list. Read-only.\n+* **index** is the current selected index starting with 0 => list with size 10, valid index is between 0 - 9. If the index is set to _out of bounds_ it's set to first element. Read-write.\n+* **next** declares a switch for scrolling forward through the list in an endless way. Reaching end of list will start again from 0. Read-write.\n+* **name**, **mileage** and **date** declares the list item. It will change when setting new index or perform next. Read-only.\n+\n+### Range vs Range Radius\n+\n+<img align=\"right\" src=\"./doc/range-radius.png\" width=\"400\" height=\"350\"/>\n+\n+ will observe differences in the Vehicle Range and Range Radius values. \n+While Range is indicating the possible distance to be driven on roads the range radius indicates the reachable range on the Map.\n+\n+The right picture shows the distance between Kassel and Frankfurt in Germany. \n+While the Air-line Distance is ~145 Kilometer the Route Distance is ~192 Kilometer.\n+So Range value is the normal remaining range.\n+See the Section [OpenStreetMap](#openstreetMap-widget) how the Range Radius is used to indicate the reachable Range on Map.\n+Please note this is just an indicator and the effective range, especially for Electric Vehicles, \n+depends on many factors like driving style and electric consumers. \n+ \n+### Last Status Update Timestamp\n+\n+A timestamp is showing the last Vehicle Status update. If this isn't shown correctly please check the date settings.\n+In case of Raspberry Pi execute *raspi-config*, select *Localization Options*, the *Change Time Zone*\n+Select your *Geographical Area* and afterwards the correct City.\n+One restart of openHAB service with *systemctl restart openhab2* is necessary in order to see the corrected Time Settings.\n+ \n+Correct TimeZone is crucial for handling all Time information in openHAB and it's discussed many times in the Forum.\n+See [similar discussion in the openHAB Forum](https://community.openhab.org/t/solved-wrong-local-time-how-to-change/90938) which deals with the same problem.\n+\n+### TroubleShooting\n+\n+BMW has a high range of Vehicles supported by BMWs ConnectedDrive.\n+In case of any issues with this Binding please help to resolve it! \n+Please perform the following Steps:\n+\n+* Can you login [into ConnectedDrive](https://www.bmw-connecteddrive.com/country-region-select/country-region-selection.html) with your Credentials? _Please note this isn't the BMW Customer Portal - it's the ConnectedDrive Portal_", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTEzNTMzOA=="}, "originalCommit": {"oid": "e0bfe93e13df4a3c5de5f8819b94ebf795664904"}, "originalPosition": 404}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEzNzg5NTA4OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.bmwconnecteddrive/README.md", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wN1QxNjowODozNlrOHd65EQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yN1QwMjowMDoyNFrOILnjLw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTEzNTYzMw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            * Is the Vehicle listed in your Account? _There's a one-to-one dependency from User to Vehicle_\n          \n          \n            \n            * Is the Vehicle listed in your Account? _There's a one-to-one relation from User to Vehicle_", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r501135633", "createdAt": "2020-10-07T16:08:36Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/README.md", "diffHunk": "@@ -0,0 +1,862 @@\n+# BMW ConnectedDrive Binding\n+\n+<img align=\"right\" src=\"./doc/bmw-connected.png\" width=\"150\" height=\"150\"/>\n+\n+The Binding provides a Connection between [BMWs ConnectedDrive Portal](https://www.bmw-connecteddrive.com/country-region-select/country-region-selection.html) and openHAB.\n+All Vehicles connected to an Account will be detected by the Discovery with the correct type \n+\n+* Conventional Fuel Vehicle\n+* Plugin-Hybrid Electrical Vehicle \n+* Battery Electric Vehicle with Range Extender\n+* Battery Electric Vehicle \n+\n+In addition Properties are attached with Information and Services provided by this Vehicle.\n+The provided data depends on \n+\n+1. the [Type](#Things) and \n+2. the Services mentioned in [Properties](#properties)\n+\n+Different Channel Groups are clustering all informations.\n+Check for each Group if it's supported for this Vehicle.\n+\n+Please note **this isn't a real-time Binding**. \n+If the Door is opened the state isn't transmitted and changed immediately. \n+This isn't a flaw in the Binding itself because the state in BMWs own ConnectedDrive App is also updated with some delay. \n+\n+## Supported Things\n+\n+### Bridge\n+\n+The Bridge establishes the Connection between BMW ConnectedDrive Portal and openHAB.\n+\n+| Name                       | Bridge Type ID | Description                                                |\n+|----------------------------|----------------|------------------------------------------------------------|\n+| BMW ConnectedDrive Account | account        | Access to BMW ConnectedDrive Portal for a specific user    |\n+\n+\n+### Things\n+\n+Four different Vehicle Types are provided. \n+They differ in the supported Channel Groups & Channels. \n+Conventional Fuel Vehicles have no _Charging Profile_, Electric Vehicles don't provide a _Fuel Range_. \n+For Hybrid Vehicles in addition to _Fuel and Electric Range_ the _Hybrid Range_ is shown.\n+ \n+| Name                                | Thing Type ID | Supported Channel Groups                                             |\n+|-------------------------------------|---------------|----------------------------------------------------------------------|\n+| BMW Electric Vehicle                | BEV           | status, range, location, service, check, charge, image, troubleshoot |\n+| BMW Electric Vehicle with REX       | BEV_REX       | status, range, location, service, check, charge, image, troubleshoot |\n+| BMW Plug-In-Hybrid Electric Vehicle | PHEV          | status, range, location, service, check, charge, image, troubleshoot |\n+| BMW Conventional Vehicle            | CONV          | status, range, location, service, check, image, troubleshoot         |\n+\n+ \n+#### Properties\n+\n+<img align=\"right\" src=\"./doc/properties.png\" width=\"500\" height=\"600\"/>\n+\n+For each Vehicle Properties are available. \n+Basically 3 Types of Information are registered as Properties\n+\n+* Informations regarding your Dealer with Address and Phone Number\n+* Which services are available / not available\n+* Vehicle Properties like Color, Model Type, Drive Train and Construction Year\n+\n+In the right picture  can see in *Services Activated* e.g. the *DoorLock* and *DoorUnlock* Services are mentioned. \n+This ensures [Channel Group _Remote Services_](#remote-services) is supporting Door lock and Door unlock.\n+\n+In  *Services Supported* the entry *LastDestination* is mentioned.\n+So it's valid to connect Channel Group [Last Destinations](#destinations) in order to display the last 3 Navigation Destinations.\n+\n+| Property Key       | Property Value      |  Supported Channel Groups    |\n+|--------------------|---------------------|------------------------------|\n+| Services Supported | Statistics          | last-trip, lifetime          |\n+| Services Supported | LastDestinations    | destinations                 |\n+| Services Activated | list of services    | remote                       |\n+\n+\n+## Discovery\n+\n+Auto Discovery is starting after creation of the Bridge towards BMW ConnectedDrive. \n+A list of your registered Vehicles is queried and all found Vehicles are added in Inbox.\n+Unique Identifier is the *Vehicle Identification Number* (VIN). \n+If a Thing is already declared in a  *.things configuration* Discovery won't highlight it again.\n+Properties will be attached to predefined Vehicles if the VIN is matching.\n+\n+## Configuration\n+\n+### Bridge\n+\n+| Parameter       | Type    | Description                                                             |           \n+|-----------------|---------|-------------------------------------------------------------------------|\n+| userName        | text    | BMW Connected Drive Username                  |\n+| password        | text    | BMW Connected Drive Password                  |\n+| region          | text    | Select Region in order to connect to the appropriate BMW Server.   |\n+\n+The region Configuration has 3 different possibilities\n+\n+* _NORTH_AMERICA_\n+* _CHINA_\n+* _ROW_ for Rest of World\n+\n+### Thing\n+\n+Same Configuration is needed for all Things\n+\n+| Parameter       | Type    | Description                           |           \n+|-----------------|---------|---------------------------------------|\n+| vin             | text    | Vehicle Identification Number (VIN)   |\n+| refreshInterval | integer | Refresh Interval in Minutes           |\n+| units           | text    | Unit Selection                        |\n+| imageSize       | integer | Image Size                            |\n+| imageViewport   | text    | Image Viewport                        |\n+\n+The units can be configured in 3 ways\n+\n+* _AUTODETECT_ selects Miles for US & UK, Kilometer otherwise\n+* _METRIC_ selects directly Kilometers\n+* _IMPERIAL_ selects directly Miles\n+\n+The imageVieport allows to show the Vehicle from different angels.\n+Possible values are \n+\n+* FRONT\n+* REAR\n+* SIDE\n+* DASHBOARD\n+* DRIVERDOOR\n+\n+## Channels\n+\n+There are many Channels available for each Vehicle. \n+For better overview they are clustered in different Channel Groups.\n+The Channel Groups are different for the Vehicle Types, on the build-in Sensors of the Vehicle and the activated Services.\n+\n+### Bridge Channels\n+\n+If the Vehicle isn't found in the Discovery force a log of Fingerprint Data which helps to analyze the problem.\n+Please check [TroubleShooting Section](#TroubleShooting) for further advice.\n+\n+| Channel Label         | Channel ID            | Type   | Description                                       |\n+|-----------------------|-----------------------|--------|---------------------------------------------------|\n+| Discovery Fingerprint | discovery-fingerprint | Switch | Forcing a log entry to analyze Discovery Problems |\n+\n+### Thing Channel Groups \n+\n+#### Vehicle Status\n+\n+Reflects Status of the Vehicle.\n+Available for all Vehicles, Read-only.\n+\n+| Channel Label             | Channel Group ID | Channel ID          | Type          | Description                                                                       |\n+|---------------------------|------------------|---------------------|---------------|-----------------------------------------------------------------------------------|\n+| Overall Door Status       | status           | doors               | String        | **Closed** if all closed otherwise **Open**. **Unknown** if no data is delivered  |\n+| Overall Window Status     | status           | windows             | String        | **Closed** if all closed otherwise **Open** or **Intermediate**. **Unknown** if no data is delivered   |\n+| Doors Locked              | status           | lock                | String        | Status if Doors are locked or unlocked                                            |\n+| Next Service Date         | status           | service-date        | DateTime      | Date of Upcoming Service                                                          |\n+| Mileage till Next Service | status           | service-mileage     | Number:Length | Mileage till Upcoming Service                                                     |\n+| Check Control             | status           | check-control       | String        | Indicator if CheckControl is **Active** or **Not Active**. **Unknown** if no data is delivered         |\n+| Charging Status           | status           | charge              | String        | Only available for PHEV, BEV_REX and BEV                                          |\n+| Last Status Timestamp     | status           | last-update         | DateTime      | Date and Time of last status update.                                              |\n+\n+See [further details for DateTime](#last-status-update-timestamp) in case of wrong timestamp values\n+\n+#### Services\n+\n+Group for all upcoming Services with Description, Service Date and / or Service Mileage\n+It's designed as [List Interface](#list-interface) so all upcoming Services can be checked.\n+\n+| Channel Label                  | Channel Group ID | Channel ID          | Type           | \n+|--------------------------------|------------------|---------------------|----------------|\n+| Service Name                   | service          | name                | String         |\n+| Service Date                   | service          | date                | Number         |\n+| Mileage till Service           | service          | mileage             | Number:Length  |\n+| Number of Scheduled Services   | service          | size                | String         |\n+| Current Selected Service Index | service          | index               | Number         |\n+| Select next Service            | service          | next                | Switch         |\n+\n+#### Check Control\n+\n+Group for all current active CheckControl Messages.\n+It's designed as [List Interface](#list-interface) to show all active Messages.\n+\n+| Channel Label                   | Channel Group ID | Channel ID          | Type           | \n+|---------------------------------|------------------|---------------------|----------------|\n+| CheckControl Description        | check            | name                | String         |\n+| CheckControl Mileage Occurrence | check            | mileage             | Number:Length  |\n+| Active CheckControl Messages    | check            | size                | String         |\n+| Selected CheckControl Message   | check            | index               | Number         |\n+| Next CheckControl Message       | check            | next                | Switch         |\n+\n+#### Doors Details\n+\n+Detailed Status of all Doors and Windows\n+Available for all Vehicles, Read-only. \n+\n+| Channel Label              | Channel Group ID | Channel ID              | Type          | \n+|----------------------------|------------------|-------------------------|---------------|\n+| Driver Door                | doors            | driver-front            | String        |\n+| Driver Door Rear           | doors            | driver-rear             | String        |\n+| Passenger Door             | doors            | passenger-front         | String        |\n+| Passenger Door Rear        | doors            | passenger-rear          | String        |\n+| Trunk                      | doors            | trunk                   | String        |\n+| Hood                       | doors            | hood                    | String        |\n+| Driver Door Window         | doors            | window-driver-front     | String        |\n+| Driver Door Rear Window    | doors            | window-driver-rear      | String        |\n+| Passenger Door Window      | doors            | window-passenger-front  | String        |\n+| Passenger Door Rear Window | doors            | window-passenger-rear   | String        |\n+| Rear Window                | doors            | window-rear             | String        |\n+| Sunroof                    | doors            | sunroof                 | String        |\n+\n+Following Strings will be delivered\n+\n+* UNKNOWN - no status data available\n+* INVALID - this item isn't applicable for this Vehicle\n+* CLOSED - the Door / Window is closed\n+* OPEN - the Door / Window is open\n+* INTERMEDIATE - Window in intermediate position, not applicable for Doors\n+\n+#### Range Data\n+\n+Based on Vehicle Type (Thing Type ID) some Channels are presented or not. \n+Conventional Fuel Vehicles don't provide *Electric Range* and Battery Electric Vehicles don't show *Range Fuel*.\n+Hybrid Vehicles have both and in addition *Hybrid Range*.\n+These are Read-only values.\n+\n+| Channel Label         | Channel Group ID | Channel ID            | Type                 | CONV | PHEV | BEV_REX | BEV |\n+|-----------------------|------------------|-----------------------|----------------------|------|------|---------|-----|\n+| Mileage               | range            | mileage               | Number:Length        |  X   |  X   |    X    |  X  |\n+| Fuel Range            | range            | range-fuel            | Number:Length        |  X   |  X   |    X    |     |\n+| Battery Range         | range            | range-electric        | Number:Length        |      |  X   |    X    |  X  | \n+| Hybrid Range          | range            | range-hybrid          | Number:Length        |      |  X   |    X    |     | \n+| Battery Charge Level  | range            | soc                   | Number:Dimensionless |      |  X   |    X    |  X  |\n+| Remaining Fuel        | range            | remaining-fuel        | Number:Volume        |  X   |  X   |    X    |     | \n+| Fuel Range Radius     | range            | range-radius-fuel     | Number:Length        |  X   |  X   |    X    |     | \n+| Electric Range Radius | range            | range-radius-electric | Number:Length        |      |  X   |    X    |  X  | \n+| Hybrid Range Radius   | range            | range-radius-hybrid   | Number:Length        |      |  X   |    X    |     | \n+\n+See Description [Range vs Range Radius](#range-vs-range-radius) to get more information\n+\n+#### Charge Profile\n+\n+Valid for Electric and Hybrid Vehicles\n+These are Read-only values.\n+\n+| Channel Label                      | Channel Group ID | Channel ID          | Type   | \n+|------------------------------------|------------------|---------------------|--------|\n+| Air Conditioning at Departure Time | charge           | profile-climate     | Switch | \n+| Charging Mode for Profile          | charge           | profile-mode        | String | \n+| Charging Window Start Time         | charge           | window-start        | String | \n+| Charging Window End Time           | charge           | window-end          | String | \n+| Timer 1: Departure Time            | charge           | timer1-departure    | String | \n+| Timer 1: Scheduled Days            | charge           | timer1-days         | String | \n+| Timer 1: Enabled                   | charge           | timer1-enabled      | Switch | \n+| Timer 2: Departure Time            | charge           | timer2-departure    | String | \n+| Timer 2: Scheduled Days            | charge           | timer2-days         | String | \n+| Timer 2: Enabled                   | charge           | timer2-enabled      | Switch | \n+| Timer 3: Departure Time            | charge           | timer3-departure    | String | \n+| Timer 3: Scheduled Days            | charge           | timer3-days         | String | \n+| Timer 3: Enabled                   | charge           | timer3-enabled      | Switch | \n+\n+\n+#### Location\n+\n+Available for all Vehicles.\n+These are Read-only values.\n+\n+| Channel Label  | Channel Group ID | Channel ID          | Type         | \n+|----------------|------------------|---------------------|--------------|\n+| Latitude       | location         | latitude            | Number       | \n+| Longitude      | location         | longitude           | Number       |\n+| Heading        | location         | heading             | Number:Angle | \n+\n+#### Last Trip\n+\n+Check [Vehicle Properties](#Properties) if *Statistics* is present in *Services Supported*\n+These are Read-only values.\n+\n+| Channel Label                           | Channel Group ID | Channel ID                   | Type          |\n+|-----------------------------------------|------------------|------------------------------|---------------|\n+| Last Trip Date                          | last-trip        | date                         | DateTime      |\n+| Last Trip Duration                      | last-trip        | duration                     | Number:Time   |\n+| Average Power Consumption per 100 km    | last-trip        | average-consumption          | Number:Power  |\n+| Average Combined Consumption per 100 km | last-trip        | average-combined-consumption | Number:Volume |\n+| Average Power Recuperation per 100 km   | last-trip        | average-recuperation         | Number:Power  |\n+| Last Trip Distance                      | last-trip        | distance                     | Number:Length |\n+| Distance since Last Charge              | last-trip        | distance-since-charging      | Number:Length |\n+\n+\n+#### Lifetime Statistics\n+\n+Check [Vehicle Properties](#Properties) if *Statistics* is present in *Services Supported*\n+These are Read-only values.\n+\n+| Channel Label                           | Channel Group ID | Channel ID                   | Type          | \n+|-----------------------------------------|------------------|------------------------------|---------------|\n+| Average Power Consumption per 100 km    | lifetime         | average-consumption          | Number:Power  |\n+| Average Power Recuperation per 100 km   | lifetime         | average-recuperation         | Number:Power  |\n+| Cumulated Electric Driven Distance      | lifetime         | cumulated-driven-distance    | Number:Length |\n+| Average Combined Consumption per 100 km | lifetime         | average-combined-consumption | Number:Volume |\n+| Longest Distance with one Charge        | lifetime         | single-longest-distance      | Number:Length |\n+\n+\n+#### Remote Services\n+\n+Check [Vehicle Properties](#Properties) *Services Activated* which Remote Services are available\n+Only one Remote Service can be executed each Time.\n+Parallel execution isn't supported.\n+The *Service Execution State* Channel is reporting the state.\n+State *Executed* is the final State when Execution is finished.\n+\n+| Channel Label           | Channel Group ID | Channel ID          | Type    | \n+|-------------------------|------------------|---------------------|---------|\n+| Activate Flash Lights   | remote           | light               | Switch  |\n+| Find Vehicle            | remote           | finder              | Switch  |\n+| Lock Doors              | remote           | lock                | Switch  |\n+| Unlock Doors            | remote           | unlock              | Switch  |\n+| Horn Blow               | remote           | horn                | Switch  |\n+| Active Air Conditioning | remote           | climate             | Switch  |\n+| Service Execution State | remote           | state               | STring  |\n+\n+#### Destinations\n+\n+Check [Vehicle Properties](#Properties) if *LastDestinations* is present in *Services Supported*\n+It's designed as [List Interface](#list-interface) in order to have access to all stored Destinations.\n+\n+| Channel Label                    | Channel Group ID | Channel ID          | Type    | \n+|----------------------------------|------------------|---------------------|---------|\n+| Destination Name                 | destination      | name                | String  |\n+| Destination Latitude             | destination      | latitude            | Number  |\n+| Destination Longitude            | destination      | longitude           | Number  |\n+| Number of Available Destinations | destination      | size                | String  |\n+| Index of Selected Destination    | destination      | index               | Number  |\n+| Skip to Next Destination         | destination      | next                | Switch  |\n+\n+\n+#### Image\n+\n+Available for all Vehicles.\n+Picture can be modified regarding *Viewport* and *Size*.\n+See [Things Section](#thing) for Viewport possibilities and [Status Image](#status-image) for possible Use Cases.\n+\n+| Channel Label                 | Channel Group ID | Channel ID          | Type   | \n+|-------------------------------|------------------|---------------------|--------|\n+| Rendered Image of the Vehicle | image            | png                 | Image  |\n+| Image Viewport                | image            | view                | String |\n+| Image Picture Size            | image            | size                | Number |\n+\n+\n+#### Troubleshooting\n+\n+Available for all Vehicles!\n+Switch will log a *Vehicle Data Fingerprint* into the openHAB log.\n+Please check [TroubleShooting Section](#TroubleShooting) for further advice.\n+\n+| Channel Label                       | Channel Group ID | Channel ID          | Type   | Description                                       |\n+|-------------------------------------|------------------|---------------------|--------|---------------------------------------------------|\n+| Log Vehicle Fingerprint             | troubleshoot     | vehicle-fingerprint | Switch | Forces log entries in openHAB logger in order to raise issues |\n+\n+## Further Descriptions\n+\n+### List Interface\n+\n+Currently there are 3 occurrences of dynamic data delivered as Lists\n+\n+* Upcoming Services\n+* Check Control Messages\n+* Last Destinations\n+\n+In order to provide all data the lists are organized the following way based on the Service Group example\n+\n+* **size** is the total length of the list. Read-only.\n+* **index** is the current selected index starting with 0 => list with size 10, valid index is between 0 - 9. If the index is set to _out of bounds_ it's set to first element. Read-write.\n+* **next** declares a switch for scrolling forward through the list in an endless way. Reaching end of list will start again from 0. Read-write.\n+* **name**, **mileage** and **date** declares the list item. It will change when setting new index or perform next. Read-only.\n+\n+### Range vs Range Radius\n+\n+<img align=\"right\" src=\"./doc/range-radius.png\" width=\"400\" height=\"350\"/>\n+\n+ will observe differences in the Vehicle Range and Range Radius values. \n+While Range is indicating the possible distance to be driven on roads the range radius indicates the reachable range on the Map.\n+\n+The right picture shows the distance between Kassel and Frankfurt in Germany. \n+While the Air-line Distance is ~145 Kilometer the Route Distance is ~192 Kilometer.\n+So Range value is the normal remaining range.\n+See the Section [OpenStreetMap](#openstreetMap-widget) how the Range Radius is used to indicate the reachable Range on Map.\n+Please note this is just an indicator and the effective range, especially for Electric Vehicles, \n+depends on many factors like driving style and electric consumers. \n+ \n+### Last Status Update Timestamp\n+\n+A timestamp is showing the last Vehicle Status update. If this isn't shown correctly please check the date settings.\n+In case of Raspberry Pi execute *raspi-config*, select *Localization Options*, the *Change Time Zone*\n+Select your *Geographical Area* and afterwards the correct City.\n+One restart of openHAB service with *systemctl restart openhab2* is necessary in order to see the corrected Time Settings.\n+ \n+Correct TimeZone is crucial for handling all Time information in openHAB and it's discussed many times in the Forum.\n+See [similar discussion in the openHAB Forum](https://community.openhab.org/t/solved-wrong-local-time-how-to-change/90938) which deals with the same problem.\n+\n+### TroubleShooting\n+\n+BMW has a high range of Vehicles supported by BMWs ConnectedDrive.\n+In case of any issues with this Binding please help to resolve it! \n+Please perform the following Steps:\n+\n+* Can you login [into ConnectedDrive](https://www.bmw-connecteddrive.com/country-region-select/country-region-selection.html) with your Credentials? _Please note this isn't the BMW Customer Portal - it's the ConnectedDrive Portal_\n+* Is the Vehicle listed in your Account? _There's a one-to-one dependency from User to Vehicle_", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e0bfe93e13df4a3c5de5f8819b94ebf795664904"}, "originalPosition": 405}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTA1MzIzMQ==", "bodyText": "Corrected", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r549053231", "createdAt": "2020-12-27T02:00:24Z", "author": {"login": "weymann"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/README.md", "diffHunk": "@@ -0,0 +1,862 @@\n+# BMW ConnectedDrive Binding\n+\n+<img align=\"right\" src=\"./doc/bmw-connected.png\" width=\"150\" height=\"150\"/>\n+\n+The Binding provides a Connection between [BMWs ConnectedDrive Portal](https://www.bmw-connecteddrive.com/country-region-select/country-region-selection.html) and openHAB.\n+All Vehicles connected to an Account will be detected by the Discovery with the correct type \n+\n+* Conventional Fuel Vehicle\n+* Plugin-Hybrid Electrical Vehicle \n+* Battery Electric Vehicle with Range Extender\n+* Battery Electric Vehicle \n+\n+In addition Properties are attached with Information and Services provided by this Vehicle.\n+The provided data depends on \n+\n+1. the [Type](#Things) and \n+2. the Services mentioned in [Properties](#properties)\n+\n+Different Channel Groups are clustering all informations.\n+Check for each Group if it's supported for this Vehicle.\n+\n+Please note **this isn't a real-time Binding**. \n+If the Door is opened the state isn't transmitted and changed immediately. \n+This isn't a flaw in the Binding itself because the state in BMWs own ConnectedDrive App is also updated with some delay. \n+\n+## Supported Things\n+\n+### Bridge\n+\n+The Bridge establishes the Connection between BMW ConnectedDrive Portal and openHAB.\n+\n+| Name                       | Bridge Type ID | Description                                                |\n+|----------------------------|----------------|------------------------------------------------------------|\n+| BMW ConnectedDrive Account | account        | Access to BMW ConnectedDrive Portal for a specific user    |\n+\n+\n+### Things\n+\n+Four different Vehicle Types are provided. \n+They differ in the supported Channel Groups & Channels. \n+Conventional Fuel Vehicles have no _Charging Profile_, Electric Vehicles don't provide a _Fuel Range_. \n+For Hybrid Vehicles in addition to _Fuel and Electric Range_ the _Hybrid Range_ is shown.\n+ \n+| Name                                | Thing Type ID | Supported Channel Groups                                             |\n+|-------------------------------------|---------------|----------------------------------------------------------------------|\n+| BMW Electric Vehicle                | BEV           | status, range, location, service, check, charge, image, troubleshoot |\n+| BMW Electric Vehicle with REX       | BEV_REX       | status, range, location, service, check, charge, image, troubleshoot |\n+| BMW Plug-In-Hybrid Electric Vehicle | PHEV          | status, range, location, service, check, charge, image, troubleshoot |\n+| BMW Conventional Vehicle            | CONV          | status, range, location, service, check, image, troubleshoot         |\n+\n+ \n+#### Properties\n+\n+<img align=\"right\" src=\"./doc/properties.png\" width=\"500\" height=\"600\"/>\n+\n+For each Vehicle Properties are available. \n+Basically 3 Types of Information are registered as Properties\n+\n+* Informations regarding your Dealer with Address and Phone Number\n+* Which services are available / not available\n+* Vehicle Properties like Color, Model Type, Drive Train and Construction Year\n+\n+In the right picture  can see in *Services Activated* e.g. the *DoorLock* and *DoorUnlock* Services are mentioned. \n+This ensures [Channel Group _Remote Services_](#remote-services) is supporting Door lock and Door unlock.\n+\n+In  *Services Supported* the entry *LastDestination* is mentioned.\n+So it's valid to connect Channel Group [Last Destinations](#destinations) in order to display the last 3 Navigation Destinations.\n+\n+| Property Key       | Property Value      |  Supported Channel Groups    |\n+|--------------------|---------------------|------------------------------|\n+| Services Supported | Statistics          | last-trip, lifetime          |\n+| Services Supported | LastDestinations    | destinations                 |\n+| Services Activated | list of services    | remote                       |\n+\n+\n+## Discovery\n+\n+Auto Discovery is starting after creation of the Bridge towards BMW ConnectedDrive. \n+A list of your registered Vehicles is queried and all found Vehicles are added in Inbox.\n+Unique Identifier is the *Vehicle Identification Number* (VIN). \n+If a Thing is already declared in a  *.things configuration* Discovery won't highlight it again.\n+Properties will be attached to predefined Vehicles if the VIN is matching.\n+\n+## Configuration\n+\n+### Bridge\n+\n+| Parameter       | Type    | Description                                                             |           \n+|-----------------|---------|-------------------------------------------------------------------------|\n+| userName        | text    | BMW Connected Drive Username                  |\n+| password        | text    | BMW Connected Drive Password                  |\n+| region          | text    | Select Region in order to connect to the appropriate BMW Server.   |\n+\n+The region Configuration has 3 different possibilities\n+\n+* _NORTH_AMERICA_\n+* _CHINA_\n+* _ROW_ for Rest of World\n+\n+### Thing\n+\n+Same Configuration is needed for all Things\n+\n+| Parameter       | Type    | Description                           |           \n+|-----------------|---------|---------------------------------------|\n+| vin             | text    | Vehicle Identification Number (VIN)   |\n+| refreshInterval | integer | Refresh Interval in Minutes           |\n+| units           | text    | Unit Selection                        |\n+| imageSize       | integer | Image Size                            |\n+| imageViewport   | text    | Image Viewport                        |\n+\n+The units can be configured in 3 ways\n+\n+* _AUTODETECT_ selects Miles for US & UK, Kilometer otherwise\n+* _METRIC_ selects directly Kilometers\n+* _IMPERIAL_ selects directly Miles\n+\n+The imageVieport allows to show the Vehicle from different angels.\n+Possible values are \n+\n+* FRONT\n+* REAR\n+* SIDE\n+* DASHBOARD\n+* DRIVERDOOR\n+\n+## Channels\n+\n+There are many Channels available for each Vehicle. \n+For better overview they are clustered in different Channel Groups.\n+The Channel Groups are different for the Vehicle Types, on the build-in Sensors of the Vehicle and the activated Services.\n+\n+### Bridge Channels\n+\n+If the Vehicle isn't found in the Discovery force a log of Fingerprint Data which helps to analyze the problem.\n+Please check [TroubleShooting Section](#TroubleShooting) for further advice.\n+\n+| Channel Label         | Channel ID            | Type   | Description                                       |\n+|-----------------------|-----------------------|--------|---------------------------------------------------|\n+| Discovery Fingerprint | discovery-fingerprint | Switch | Forcing a log entry to analyze Discovery Problems |\n+\n+### Thing Channel Groups \n+\n+#### Vehicle Status\n+\n+Reflects Status of the Vehicle.\n+Available for all Vehicles, Read-only.\n+\n+| Channel Label             | Channel Group ID | Channel ID          | Type          | Description                                                                       |\n+|---------------------------|------------------|---------------------|---------------|-----------------------------------------------------------------------------------|\n+| Overall Door Status       | status           | doors               | String        | **Closed** if all closed otherwise **Open**. **Unknown** if no data is delivered  |\n+| Overall Window Status     | status           | windows             | String        | **Closed** if all closed otherwise **Open** or **Intermediate**. **Unknown** if no data is delivered   |\n+| Doors Locked              | status           | lock                | String        | Status if Doors are locked or unlocked                                            |\n+| Next Service Date         | status           | service-date        | DateTime      | Date of Upcoming Service                                                          |\n+| Mileage till Next Service | status           | service-mileage     | Number:Length | Mileage till Upcoming Service                                                     |\n+| Check Control             | status           | check-control       | String        | Indicator if CheckControl is **Active** or **Not Active**. **Unknown** if no data is delivered         |\n+| Charging Status           | status           | charge              | String        | Only available for PHEV, BEV_REX and BEV                                          |\n+| Last Status Timestamp     | status           | last-update         | DateTime      | Date and Time of last status update.                                              |\n+\n+See [further details for DateTime](#last-status-update-timestamp) in case of wrong timestamp values\n+\n+#### Services\n+\n+Group for all upcoming Services with Description, Service Date and / or Service Mileage\n+It's designed as [List Interface](#list-interface) so all upcoming Services can be checked.\n+\n+| Channel Label                  | Channel Group ID | Channel ID          | Type           | \n+|--------------------------------|------------------|---------------------|----------------|\n+| Service Name                   | service          | name                | String         |\n+| Service Date                   | service          | date                | Number         |\n+| Mileage till Service           | service          | mileage             | Number:Length  |\n+| Number of Scheduled Services   | service          | size                | String         |\n+| Current Selected Service Index | service          | index               | Number         |\n+| Select next Service            | service          | next                | Switch         |\n+\n+#### Check Control\n+\n+Group for all current active CheckControl Messages.\n+It's designed as [List Interface](#list-interface) to show all active Messages.\n+\n+| Channel Label                   | Channel Group ID | Channel ID          | Type           | \n+|---------------------------------|------------------|---------------------|----------------|\n+| CheckControl Description        | check            | name                | String         |\n+| CheckControl Mileage Occurrence | check            | mileage             | Number:Length  |\n+| Active CheckControl Messages    | check            | size                | String         |\n+| Selected CheckControl Message   | check            | index               | Number         |\n+| Next CheckControl Message       | check            | next                | Switch         |\n+\n+#### Doors Details\n+\n+Detailed Status of all Doors and Windows\n+Available for all Vehicles, Read-only. \n+\n+| Channel Label              | Channel Group ID | Channel ID              | Type          | \n+|----------------------------|------------------|-------------------------|---------------|\n+| Driver Door                | doors            | driver-front            | String        |\n+| Driver Door Rear           | doors            | driver-rear             | String        |\n+| Passenger Door             | doors            | passenger-front         | String        |\n+| Passenger Door Rear        | doors            | passenger-rear          | String        |\n+| Trunk                      | doors            | trunk                   | String        |\n+| Hood                       | doors            | hood                    | String        |\n+| Driver Door Window         | doors            | window-driver-front     | String        |\n+| Driver Door Rear Window    | doors            | window-driver-rear      | String        |\n+| Passenger Door Window      | doors            | window-passenger-front  | String        |\n+| Passenger Door Rear Window | doors            | window-passenger-rear   | String        |\n+| Rear Window                | doors            | window-rear             | String        |\n+| Sunroof                    | doors            | sunroof                 | String        |\n+\n+Following Strings will be delivered\n+\n+* UNKNOWN - no status data available\n+* INVALID - this item isn't applicable for this Vehicle\n+* CLOSED - the Door / Window is closed\n+* OPEN - the Door / Window is open\n+* INTERMEDIATE - Window in intermediate position, not applicable for Doors\n+\n+#### Range Data\n+\n+Based on Vehicle Type (Thing Type ID) some Channels are presented or not. \n+Conventional Fuel Vehicles don't provide *Electric Range* and Battery Electric Vehicles don't show *Range Fuel*.\n+Hybrid Vehicles have both and in addition *Hybrid Range*.\n+These are Read-only values.\n+\n+| Channel Label         | Channel Group ID | Channel ID            | Type                 | CONV | PHEV | BEV_REX | BEV |\n+|-----------------------|------------------|-----------------------|----------------------|------|------|---------|-----|\n+| Mileage               | range            | mileage               | Number:Length        |  X   |  X   |    X    |  X  |\n+| Fuel Range            | range            | range-fuel            | Number:Length        |  X   |  X   |    X    |     |\n+| Battery Range         | range            | range-electric        | Number:Length        |      |  X   |    X    |  X  | \n+| Hybrid Range          | range            | range-hybrid          | Number:Length        |      |  X   |    X    |     | \n+| Battery Charge Level  | range            | soc                   | Number:Dimensionless |      |  X   |    X    |  X  |\n+| Remaining Fuel        | range            | remaining-fuel        | Number:Volume        |  X   |  X   |    X    |     | \n+| Fuel Range Radius     | range            | range-radius-fuel     | Number:Length        |  X   |  X   |    X    |     | \n+| Electric Range Radius | range            | range-radius-electric | Number:Length        |      |  X   |    X    |  X  | \n+| Hybrid Range Radius   | range            | range-radius-hybrid   | Number:Length        |      |  X   |    X    |     | \n+\n+See Description [Range vs Range Radius](#range-vs-range-radius) to get more information\n+\n+#### Charge Profile\n+\n+Valid for Electric and Hybrid Vehicles\n+These are Read-only values.\n+\n+| Channel Label                      | Channel Group ID | Channel ID          | Type   | \n+|------------------------------------|------------------|---------------------|--------|\n+| Air Conditioning at Departure Time | charge           | profile-climate     | Switch | \n+| Charging Mode for Profile          | charge           | profile-mode        | String | \n+| Charging Window Start Time         | charge           | window-start        | String | \n+| Charging Window End Time           | charge           | window-end          | String | \n+| Timer 1: Departure Time            | charge           | timer1-departure    | String | \n+| Timer 1: Scheduled Days            | charge           | timer1-days         | String | \n+| Timer 1: Enabled                   | charge           | timer1-enabled      | Switch | \n+| Timer 2: Departure Time            | charge           | timer2-departure    | String | \n+| Timer 2: Scheduled Days            | charge           | timer2-days         | String | \n+| Timer 2: Enabled                   | charge           | timer2-enabled      | Switch | \n+| Timer 3: Departure Time            | charge           | timer3-departure    | String | \n+| Timer 3: Scheduled Days            | charge           | timer3-days         | String | \n+| Timer 3: Enabled                   | charge           | timer3-enabled      | Switch | \n+\n+\n+#### Location\n+\n+Available for all Vehicles.\n+These are Read-only values.\n+\n+| Channel Label  | Channel Group ID | Channel ID          | Type         | \n+|----------------|------------------|---------------------|--------------|\n+| Latitude       | location         | latitude            | Number       | \n+| Longitude      | location         | longitude           | Number       |\n+| Heading        | location         | heading             | Number:Angle | \n+\n+#### Last Trip\n+\n+Check [Vehicle Properties](#Properties) if *Statistics* is present in *Services Supported*\n+These are Read-only values.\n+\n+| Channel Label                           | Channel Group ID | Channel ID                   | Type          |\n+|-----------------------------------------|------------------|------------------------------|---------------|\n+| Last Trip Date                          | last-trip        | date                         | DateTime      |\n+| Last Trip Duration                      | last-trip        | duration                     | Number:Time   |\n+| Average Power Consumption per 100 km    | last-trip        | average-consumption          | Number:Power  |\n+| Average Combined Consumption per 100 km | last-trip        | average-combined-consumption | Number:Volume |\n+| Average Power Recuperation per 100 km   | last-trip        | average-recuperation         | Number:Power  |\n+| Last Trip Distance                      | last-trip        | distance                     | Number:Length |\n+| Distance since Last Charge              | last-trip        | distance-since-charging      | Number:Length |\n+\n+\n+#### Lifetime Statistics\n+\n+Check [Vehicle Properties](#Properties) if *Statistics* is present in *Services Supported*\n+These are Read-only values.\n+\n+| Channel Label                           | Channel Group ID | Channel ID                   | Type          | \n+|-----------------------------------------|------------------|------------------------------|---------------|\n+| Average Power Consumption per 100 km    | lifetime         | average-consumption          | Number:Power  |\n+| Average Power Recuperation per 100 km   | lifetime         | average-recuperation         | Number:Power  |\n+| Cumulated Electric Driven Distance      | lifetime         | cumulated-driven-distance    | Number:Length |\n+| Average Combined Consumption per 100 km | lifetime         | average-combined-consumption | Number:Volume |\n+| Longest Distance with one Charge        | lifetime         | single-longest-distance      | Number:Length |\n+\n+\n+#### Remote Services\n+\n+Check [Vehicle Properties](#Properties) *Services Activated* which Remote Services are available\n+Only one Remote Service can be executed each Time.\n+Parallel execution isn't supported.\n+The *Service Execution State* Channel is reporting the state.\n+State *Executed* is the final State when Execution is finished.\n+\n+| Channel Label           | Channel Group ID | Channel ID          | Type    | \n+|-------------------------|------------------|---------------------|---------|\n+| Activate Flash Lights   | remote           | light               | Switch  |\n+| Find Vehicle            | remote           | finder              | Switch  |\n+| Lock Doors              | remote           | lock                | Switch  |\n+| Unlock Doors            | remote           | unlock              | Switch  |\n+| Horn Blow               | remote           | horn                | Switch  |\n+| Active Air Conditioning | remote           | climate             | Switch  |\n+| Service Execution State | remote           | state               | STring  |\n+\n+#### Destinations\n+\n+Check [Vehicle Properties](#Properties) if *LastDestinations* is present in *Services Supported*\n+It's designed as [List Interface](#list-interface) in order to have access to all stored Destinations.\n+\n+| Channel Label                    | Channel Group ID | Channel ID          | Type    | \n+|----------------------------------|------------------|---------------------|---------|\n+| Destination Name                 | destination      | name                | String  |\n+| Destination Latitude             | destination      | latitude            | Number  |\n+| Destination Longitude            | destination      | longitude           | Number  |\n+| Number of Available Destinations | destination      | size                | String  |\n+| Index of Selected Destination    | destination      | index               | Number  |\n+| Skip to Next Destination         | destination      | next                | Switch  |\n+\n+\n+#### Image\n+\n+Available for all Vehicles.\n+Picture can be modified regarding *Viewport* and *Size*.\n+See [Things Section](#thing) for Viewport possibilities and [Status Image](#status-image) for possible Use Cases.\n+\n+| Channel Label                 | Channel Group ID | Channel ID          | Type   | \n+|-------------------------------|------------------|---------------------|--------|\n+| Rendered Image of the Vehicle | image            | png                 | Image  |\n+| Image Viewport                | image            | view                | String |\n+| Image Picture Size            | image            | size                | Number |\n+\n+\n+#### Troubleshooting\n+\n+Available for all Vehicles!\n+Switch will log a *Vehicle Data Fingerprint* into the openHAB log.\n+Please check [TroubleShooting Section](#TroubleShooting) for further advice.\n+\n+| Channel Label                       | Channel Group ID | Channel ID          | Type   | Description                                       |\n+|-------------------------------------|------------------|---------------------|--------|---------------------------------------------------|\n+| Log Vehicle Fingerprint             | troubleshoot     | vehicle-fingerprint | Switch | Forces log entries in openHAB logger in order to raise issues |\n+\n+## Further Descriptions\n+\n+### List Interface\n+\n+Currently there are 3 occurrences of dynamic data delivered as Lists\n+\n+* Upcoming Services\n+* Check Control Messages\n+* Last Destinations\n+\n+In order to provide all data the lists are organized the following way based on the Service Group example\n+\n+* **size** is the total length of the list. Read-only.\n+* **index** is the current selected index starting with 0 => list with size 10, valid index is between 0 - 9. If the index is set to _out of bounds_ it's set to first element. Read-write.\n+* **next** declares a switch for scrolling forward through the list in an endless way. Reaching end of list will start again from 0. Read-write.\n+* **name**, **mileage** and **date** declares the list item. It will change when setting new index or perform next. Read-only.\n+\n+### Range vs Range Radius\n+\n+<img align=\"right\" src=\"./doc/range-radius.png\" width=\"400\" height=\"350\"/>\n+\n+ will observe differences in the Vehicle Range and Range Radius values. \n+While Range is indicating the possible distance to be driven on roads the range radius indicates the reachable range on the Map.\n+\n+The right picture shows the distance between Kassel and Frankfurt in Germany. \n+While the Air-line Distance is ~145 Kilometer the Route Distance is ~192 Kilometer.\n+So Range value is the normal remaining range.\n+See the Section [OpenStreetMap](#openstreetMap-widget) how the Range Radius is used to indicate the reachable Range on Map.\n+Please note this is just an indicator and the effective range, especially for Electric Vehicles, \n+depends on many factors like driving style and electric consumers. \n+ \n+### Last Status Update Timestamp\n+\n+A timestamp is showing the last Vehicle Status update. If this isn't shown correctly please check the date settings.\n+In case of Raspberry Pi execute *raspi-config*, select *Localization Options*, the *Change Time Zone*\n+Select your *Geographical Area* and afterwards the correct City.\n+One restart of openHAB service with *systemctl restart openhab2* is necessary in order to see the corrected Time Settings.\n+ \n+Correct TimeZone is crucial for handling all Time information in openHAB and it's discussed many times in the Forum.\n+See [similar discussion in the openHAB Forum](https://community.openhab.org/t/solved-wrong-local-time-how-to-change/90938) which deals with the same problem.\n+\n+### TroubleShooting\n+\n+BMW has a high range of Vehicles supported by BMWs ConnectedDrive.\n+In case of any issues with this Binding please help to resolve it! \n+Please perform the following Steps:\n+\n+* Can you login [into ConnectedDrive](https://www.bmw-connecteddrive.com/country-region-select/country-region-selection.html) with your Credentials? _Please note this isn't the BMW Customer Portal - it's the ConnectedDrive Portal_\n+* Is the Vehicle listed in your Account? _There's a one-to-one dependency from User to Vehicle_", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTEzNTYzMw=="}, "originalCommit": {"oid": "e0bfe93e13df4a3c5de5f8819b94ebf795664904"}, "originalPosition": 405}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEzNzkxMjkyOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.bmwconnecteddrive/README.md", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wN1QxNjoxMjo1N1rOHd7EXw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yN1QwMTo1NDozN1rOILnhVw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTEzODUyNw==", "bodyText": "I think the example log doesn't provide any additional benefit. To keep the readme concise, I'd remove it.", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r501138527", "createdAt": "2020-10-07T16:12:57Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/README.md", "diffHunk": "@@ -0,0 +1,862 @@\n+# BMW ConnectedDrive Binding\n+\n+<img align=\"right\" src=\"./doc/bmw-connected.png\" width=\"150\" height=\"150\"/>\n+\n+The Binding provides a Connection between [BMWs ConnectedDrive Portal](https://www.bmw-connecteddrive.com/country-region-select/country-region-selection.html) and openHAB.\n+All Vehicles connected to an Account will be detected by the Discovery with the correct type \n+\n+* Conventional Fuel Vehicle\n+* Plugin-Hybrid Electrical Vehicle \n+* Battery Electric Vehicle with Range Extender\n+* Battery Electric Vehicle \n+\n+In addition Properties are attached with Information and Services provided by this Vehicle.\n+The provided data depends on \n+\n+1. the [Type](#Things) and \n+2. the Services mentioned in [Properties](#properties)\n+\n+Different Channel Groups are clustering all informations.\n+Check for each Group if it's supported for this Vehicle.\n+\n+Please note **this isn't a real-time Binding**. \n+If the Door is opened the state isn't transmitted and changed immediately. \n+This isn't a flaw in the Binding itself because the state in BMWs own ConnectedDrive App is also updated with some delay. \n+\n+## Supported Things\n+\n+### Bridge\n+\n+The Bridge establishes the Connection between BMW ConnectedDrive Portal and openHAB.\n+\n+| Name                       | Bridge Type ID | Description                                                |\n+|----------------------------|----------------|------------------------------------------------------------|\n+| BMW ConnectedDrive Account | account        | Access to BMW ConnectedDrive Portal for a specific user    |\n+\n+\n+### Things\n+\n+Four different Vehicle Types are provided. \n+They differ in the supported Channel Groups & Channels. \n+Conventional Fuel Vehicles have no _Charging Profile_, Electric Vehicles don't provide a _Fuel Range_. \n+For Hybrid Vehicles in addition to _Fuel and Electric Range_ the _Hybrid Range_ is shown.\n+ \n+| Name                                | Thing Type ID | Supported Channel Groups                                             |\n+|-------------------------------------|---------------|----------------------------------------------------------------------|\n+| BMW Electric Vehicle                | BEV           | status, range, location, service, check, charge, image, troubleshoot |\n+| BMW Electric Vehicle with REX       | BEV_REX       | status, range, location, service, check, charge, image, troubleshoot |\n+| BMW Plug-In-Hybrid Electric Vehicle | PHEV          | status, range, location, service, check, charge, image, troubleshoot |\n+| BMW Conventional Vehicle            | CONV          | status, range, location, service, check, image, troubleshoot         |\n+\n+ \n+#### Properties\n+\n+<img align=\"right\" src=\"./doc/properties.png\" width=\"500\" height=\"600\"/>\n+\n+For each Vehicle Properties are available. \n+Basically 3 Types of Information are registered as Properties\n+\n+* Informations regarding your Dealer with Address and Phone Number\n+* Which services are available / not available\n+* Vehicle Properties like Color, Model Type, Drive Train and Construction Year\n+\n+In the right picture  can see in *Services Activated* e.g. the *DoorLock* and *DoorUnlock* Services are mentioned. \n+This ensures [Channel Group _Remote Services_](#remote-services) is supporting Door lock and Door unlock.\n+\n+In  *Services Supported* the entry *LastDestination* is mentioned.\n+So it's valid to connect Channel Group [Last Destinations](#destinations) in order to display the last 3 Navigation Destinations.\n+\n+| Property Key       | Property Value      |  Supported Channel Groups    |\n+|--------------------|---------------------|------------------------------|\n+| Services Supported | Statistics          | last-trip, lifetime          |\n+| Services Supported | LastDestinations    | destinations                 |\n+| Services Activated | list of services    | remote                       |\n+\n+\n+## Discovery\n+\n+Auto Discovery is starting after creation of the Bridge towards BMW ConnectedDrive. \n+A list of your registered Vehicles is queried and all found Vehicles are added in Inbox.\n+Unique Identifier is the *Vehicle Identification Number* (VIN). \n+If a Thing is already declared in a  *.things configuration* Discovery won't highlight it again.\n+Properties will be attached to predefined Vehicles if the VIN is matching.\n+\n+## Configuration\n+\n+### Bridge\n+\n+| Parameter       | Type    | Description                                                             |           \n+|-----------------|---------|-------------------------------------------------------------------------|\n+| userName        | text    | BMW Connected Drive Username                  |\n+| password        | text    | BMW Connected Drive Password                  |\n+| region          | text    | Select Region in order to connect to the appropriate BMW Server.   |\n+\n+The region Configuration has 3 different possibilities\n+\n+* _NORTH_AMERICA_\n+* _CHINA_\n+* _ROW_ for Rest of World\n+\n+### Thing\n+\n+Same Configuration is needed for all Things\n+\n+| Parameter       | Type    | Description                           |           \n+|-----------------|---------|---------------------------------------|\n+| vin             | text    | Vehicle Identification Number (VIN)   |\n+| refreshInterval | integer | Refresh Interval in Minutes           |\n+| units           | text    | Unit Selection                        |\n+| imageSize       | integer | Image Size                            |\n+| imageViewport   | text    | Image Viewport                        |\n+\n+The units can be configured in 3 ways\n+\n+* _AUTODETECT_ selects Miles for US & UK, Kilometer otherwise\n+* _METRIC_ selects directly Kilometers\n+* _IMPERIAL_ selects directly Miles\n+\n+The imageVieport allows to show the Vehicle from different angels.\n+Possible values are \n+\n+* FRONT\n+* REAR\n+* SIDE\n+* DASHBOARD\n+* DRIVERDOOR\n+\n+## Channels\n+\n+There are many Channels available for each Vehicle. \n+For better overview they are clustered in different Channel Groups.\n+The Channel Groups are different for the Vehicle Types, on the build-in Sensors of the Vehicle and the activated Services.\n+\n+### Bridge Channels\n+\n+If the Vehicle isn't found in the Discovery force a log of Fingerprint Data which helps to analyze the problem.\n+Please check [TroubleShooting Section](#TroubleShooting) for further advice.\n+\n+| Channel Label         | Channel ID            | Type   | Description                                       |\n+|-----------------------|-----------------------|--------|---------------------------------------------------|\n+| Discovery Fingerprint | discovery-fingerprint | Switch | Forcing a log entry to analyze Discovery Problems |\n+\n+### Thing Channel Groups \n+\n+#### Vehicle Status\n+\n+Reflects Status of the Vehicle.\n+Available for all Vehicles, Read-only.\n+\n+| Channel Label             | Channel Group ID | Channel ID          | Type          | Description                                                                       |\n+|---------------------------|------------------|---------------------|---------------|-----------------------------------------------------------------------------------|\n+| Overall Door Status       | status           | doors               | String        | **Closed** if all closed otherwise **Open**. **Unknown** if no data is delivered  |\n+| Overall Window Status     | status           | windows             | String        | **Closed** if all closed otherwise **Open** or **Intermediate**. **Unknown** if no data is delivered   |\n+| Doors Locked              | status           | lock                | String        | Status if Doors are locked or unlocked                                            |\n+| Next Service Date         | status           | service-date        | DateTime      | Date of Upcoming Service                                                          |\n+| Mileage till Next Service | status           | service-mileage     | Number:Length | Mileage till Upcoming Service                                                     |\n+| Check Control             | status           | check-control       | String        | Indicator if CheckControl is **Active** or **Not Active**. **Unknown** if no data is delivered         |\n+| Charging Status           | status           | charge              | String        | Only available for PHEV, BEV_REX and BEV                                          |\n+| Last Status Timestamp     | status           | last-update         | DateTime      | Date and Time of last status update.                                              |\n+\n+See [further details for DateTime](#last-status-update-timestamp) in case of wrong timestamp values\n+\n+#### Services\n+\n+Group for all upcoming Services with Description, Service Date and / or Service Mileage\n+It's designed as [List Interface](#list-interface) so all upcoming Services can be checked.\n+\n+| Channel Label                  | Channel Group ID | Channel ID          | Type           | \n+|--------------------------------|------------------|---------------------|----------------|\n+| Service Name                   | service          | name                | String         |\n+| Service Date                   | service          | date                | Number         |\n+| Mileage till Service           | service          | mileage             | Number:Length  |\n+| Number of Scheduled Services   | service          | size                | String         |\n+| Current Selected Service Index | service          | index               | Number         |\n+| Select next Service            | service          | next                | Switch         |\n+\n+#### Check Control\n+\n+Group for all current active CheckControl Messages.\n+It's designed as [List Interface](#list-interface) to show all active Messages.\n+\n+| Channel Label                   | Channel Group ID | Channel ID          | Type           | \n+|---------------------------------|------------------|---------------------|----------------|\n+| CheckControl Description        | check            | name                | String         |\n+| CheckControl Mileage Occurrence | check            | mileage             | Number:Length  |\n+| Active CheckControl Messages    | check            | size                | String         |\n+| Selected CheckControl Message   | check            | index               | Number         |\n+| Next CheckControl Message       | check            | next                | Switch         |\n+\n+#### Doors Details\n+\n+Detailed Status of all Doors and Windows\n+Available for all Vehicles, Read-only. \n+\n+| Channel Label              | Channel Group ID | Channel ID              | Type          | \n+|----------------------------|------------------|-------------------------|---------------|\n+| Driver Door                | doors            | driver-front            | String        |\n+| Driver Door Rear           | doors            | driver-rear             | String        |\n+| Passenger Door             | doors            | passenger-front         | String        |\n+| Passenger Door Rear        | doors            | passenger-rear          | String        |\n+| Trunk                      | doors            | trunk                   | String        |\n+| Hood                       | doors            | hood                    | String        |\n+| Driver Door Window         | doors            | window-driver-front     | String        |\n+| Driver Door Rear Window    | doors            | window-driver-rear      | String        |\n+| Passenger Door Window      | doors            | window-passenger-front  | String        |\n+| Passenger Door Rear Window | doors            | window-passenger-rear   | String        |\n+| Rear Window                | doors            | window-rear             | String        |\n+| Sunroof                    | doors            | sunroof                 | String        |\n+\n+Following Strings will be delivered\n+\n+* UNKNOWN - no status data available\n+* INVALID - this item isn't applicable for this Vehicle\n+* CLOSED - the Door / Window is closed\n+* OPEN - the Door / Window is open\n+* INTERMEDIATE - Window in intermediate position, not applicable for Doors\n+\n+#### Range Data\n+\n+Based on Vehicle Type (Thing Type ID) some Channels are presented or not. \n+Conventional Fuel Vehicles don't provide *Electric Range* and Battery Electric Vehicles don't show *Range Fuel*.\n+Hybrid Vehicles have both and in addition *Hybrid Range*.\n+These are Read-only values.\n+\n+| Channel Label         | Channel Group ID | Channel ID            | Type                 | CONV | PHEV | BEV_REX | BEV |\n+|-----------------------|------------------|-----------------------|----------------------|------|------|---------|-----|\n+| Mileage               | range            | mileage               | Number:Length        |  X   |  X   |    X    |  X  |\n+| Fuel Range            | range            | range-fuel            | Number:Length        |  X   |  X   |    X    |     |\n+| Battery Range         | range            | range-electric        | Number:Length        |      |  X   |    X    |  X  | \n+| Hybrid Range          | range            | range-hybrid          | Number:Length        |      |  X   |    X    |     | \n+| Battery Charge Level  | range            | soc                   | Number:Dimensionless |      |  X   |    X    |  X  |\n+| Remaining Fuel        | range            | remaining-fuel        | Number:Volume        |  X   |  X   |    X    |     | \n+| Fuel Range Radius     | range            | range-radius-fuel     | Number:Length        |  X   |  X   |    X    |     | \n+| Electric Range Radius | range            | range-radius-electric | Number:Length        |      |  X   |    X    |  X  | \n+| Hybrid Range Radius   | range            | range-radius-hybrid   | Number:Length        |      |  X   |    X    |     | \n+\n+See Description [Range vs Range Radius](#range-vs-range-radius) to get more information\n+\n+#### Charge Profile\n+\n+Valid for Electric and Hybrid Vehicles\n+These are Read-only values.\n+\n+| Channel Label                      | Channel Group ID | Channel ID          | Type   | \n+|------------------------------------|------------------|---------------------|--------|\n+| Air Conditioning at Departure Time | charge           | profile-climate     | Switch | \n+| Charging Mode for Profile          | charge           | profile-mode        | String | \n+| Charging Window Start Time         | charge           | window-start        | String | \n+| Charging Window End Time           | charge           | window-end          | String | \n+| Timer 1: Departure Time            | charge           | timer1-departure    | String | \n+| Timer 1: Scheduled Days            | charge           | timer1-days         | String | \n+| Timer 1: Enabled                   | charge           | timer1-enabled      | Switch | \n+| Timer 2: Departure Time            | charge           | timer2-departure    | String | \n+| Timer 2: Scheduled Days            | charge           | timer2-days         | String | \n+| Timer 2: Enabled                   | charge           | timer2-enabled      | Switch | \n+| Timer 3: Departure Time            | charge           | timer3-departure    | String | \n+| Timer 3: Scheduled Days            | charge           | timer3-days         | String | \n+| Timer 3: Enabled                   | charge           | timer3-enabled      | Switch | \n+\n+\n+#### Location\n+\n+Available for all Vehicles.\n+These are Read-only values.\n+\n+| Channel Label  | Channel Group ID | Channel ID          | Type         | \n+|----------------|------------------|---------------------|--------------|\n+| Latitude       | location         | latitude            | Number       | \n+| Longitude      | location         | longitude           | Number       |\n+| Heading        | location         | heading             | Number:Angle | \n+\n+#### Last Trip\n+\n+Check [Vehicle Properties](#Properties) if *Statistics* is present in *Services Supported*\n+These are Read-only values.\n+\n+| Channel Label                           | Channel Group ID | Channel ID                   | Type          |\n+|-----------------------------------------|------------------|------------------------------|---------------|\n+| Last Trip Date                          | last-trip        | date                         | DateTime      |\n+| Last Trip Duration                      | last-trip        | duration                     | Number:Time   |\n+| Average Power Consumption per 100 km    | last-trip        | average-consumption          | Number:Power  |\n+| Average Combined Consumption per 100 km | last-trip        | average-combined-consumption | Number:Volume |\n+| Average Power Recuperation per 100 km   | last-trip        | average-recuperation         | Number:Power  |\n+| Last Trip Distance                      | last-trip        | distance                     | Number:Length |\n+| Distance since Last Charge              | last-trip        | distance-since-charging      | Number:Length |\n+\n+\n+#### Lifetime Statistics\n+\n+Check [Vehicle Properties](#Properties) if *Statistics* is present in *Services Supported*\n+These are Read-only values.\n+\n+| Channel Label                           | Channel Group ID | Channel ID                   | Type          | \n+|-----------------------------------------|------------------|------------------------------|---------------|\n+| Average Power Consumption per 100 km    | lifetime         | average-consumption          | Number:Power  |\n+| Average Power Recuperation per 100 km   | lifetime         | average-recuperation         | Number:Power  |\n+| Cumulated Electric Driven Distance      | lifetime         | cumulated-driven-distance    | Number:Length |\n+| Average Combined Consumption per 100 km | lifetime         | average-combined-consumption | Number:Volume |\n+| Longest Distance with one Charge        | lifetime         | single-longest-distance      | Number:Length |\n+\n+\n+#### Remote Services\n+\n+Check [Vehicle Properties](#Properties) *Services Activated* which Remote Services are available\n+Only one Remote Service can be executed each Time.\n+Parallel execution isn't supported.\n+The *Service Execution State* Channel is reporting the state.\n+State *Executed* is the final State when Execution is finished.\n+\n+| Channel Label           | Channel Group ID | Channel ID          | Type    | \n+|-------------------------|------------------|---------------------|---------|\n+| Activate Flash Lights   | remote           | light               | Switch  |\n+| Find Vehicle            | remote           | finder              | Switch  |\n+| Lock Doors              | remote           | lock                | Switch  |\n+| Unlock Doors            | remote           | unlock              | Switch  |\n+| Horn Blow               | remote           | horn                | Switch  |\n+| Active Air Conditioning | remote           | climate             | Switch  |\n+| Service Execution State | remote           | state               | STring  |\n+\n+#### Destinations\n+\n+Check [Vehicle Properties](#Properties) if *LastDestinations* is present in *Services Supported*\n+It's designed as [List Interface](#list-interface) in order to have access to all stored Destinations.\n+\n+| Channel Label                    | Channel Group ID | Channel ID          | Type    | \n+|----------------------------------|------------------|---------------------|---------|\n+| Destination Name                 | destination      | name                | String  |\n+| Destination Latitude             | destination      | latitude            | Number  |\n+| Destination Longitude            | destination      | longitude           | Number  |\n+| Number of Available Destinations | destination      | size                | String  |\n+| Index of Selected Destination    | destination      | index               | Number  |\n+| Skip to Next Destination         | destination      | next                | Switch  |\n+\n+\n+#### Image\n+\n+Available for all Vehicles.\n+Picture can be modified regarding *Viewport* and *Size*.\n+See [Things Section](#thing) for Viewport possibilities and [Status Image](#status-image) for possible Use Cases.\n+\n+| Channel Label                 | Channel Group ID | Channel ID          | Type   | \n+|-------------------------------|------------------|---------------------|--------|\n+| Rendered Image of the Vehicle | image            | png                 | Image  |\n+| Image Viewport                | image            | view                | String |\n+| Image Picture Size            | image            | size                | Number |\n+\n+\n+#### Troubleshooting\n+\n+Available for all Vehicles!\n+Switch will log a *Vehicle Data Fingerprint* into the openHAB log.\n+Please check [TroubleShooting Section](#TroubleShooting) for further advice.\n+\n+| Channel Label                       | Channel Group ID | Channel ID          | Type   | Description                                       |\n+|-------------------------------------|------------------|---------------------|--------|---------------------------------------------------|\n+| Log Vehicle Fingerprint             | troubleshoot     | vehicle-fingerprint | Switch | Forces log entries in openHAB logger in order to raise issues |\n+\n+## Further Descriptions\n+\n+### List Interface\n+\n+Currently there are 3 occurrences of dynamic data delivered as Lists\n+\n+* Upcoming Services\n+* Check Control Messages\n+* Last Destinations\n+\n+In order to provide all data the lists are organized the following way based on the Service Group example\n+\n+* **size** is the total length of the list. Read-only.\n+* **index** is the current selected index starting with 0 => list with size 10, valid index is between 0 - 9. If the index is set to _out of bounds_ it's set to first element. Read-write.\n+* **next** declares a switch for scrolling forward through the list in an endless way. Reaching end of list will start again from 0. Read-write.\n+* **name**, **mileage** and **date** declares the list item. It will change when setting new index or perform next. Read-only.\n+\n+### Range vs Range Radius\n+\n+<img align=\"right\" src=\"./doc/range-radius.png\" width=\"400\" height=\"350\"/>\n+\n+ will observe differences in the Vehicle Range and Range Radius values. \n+While Range is indicating the possible distance to be driven on roads the range radius indicates the reachable range on the Map.\n+\n+The right picture shows the distance between Kassel and Frankfurt in Germany. \n+While the Air-line Distance is ~145 Kilometer the Route Distance is ~192 Kilometer.\n+So Range value is the normal remaining range.\n+See the Section [OpenStreetMap](#openstreetMap-widget) how the Range Radius is used to indicate the reachable Range on Map.\n+Please note this is just an indicator and the effective range, especially for Electric Vehicles, \n+depends on many factors like driving style and electric consumers. \n+ \n+### Last Status Update Timestamp\n+\n+A timestamp is showing the last Vehicle Status update. If this isn't shown correctly please check the date settings.\n+In case of Raspberry Pi execute *raspi-config*, select *Localization Options*, the *Change Time Zone*\n+Select your *Geographical Area* and afterwards the correct City.\n+One restart of openHAB service with *systemctl restart openhab2* is necessary in order to see the corrected Time Settings.\n+ \n+Correct TimeZone is crucial for handling all Time information in openHAB and it's discussed many times in the Forum.\n+See [similar discussion in the openHAB Forum](https://community.openhab.org/t/solved-wrong-local-time-how-to-change/90938) which deals with the same problem.\n+\n+### TroubleShooting\n+\n+BMW has a high range of Vehicles supported by BMWs ConnectedDrive.\n+In case of any issues with this Binding please help to resolve it! \n+Please perform the following Steps:\n+\n+* Can you login [into ConnectedDrive](https://www.bmw-connecteddrive.com/country-region-select/country-region-selection.html) with your Credentials? _Please note this isn't the BMW Customer Portal - it's the ConnectedDrive Portal_\n+* Is the Vehicle listed in your Account? _There's a one-to-one dependency from User to Vehicle_\n+\n+If the access to the Portal and listing of the Vehicle is checked some debug data is needed in order to identify the issue. \n+The [Example Sitemap](#Sitemap) contains the necessary items to generate Debug Data.\n+\n+#### My Vehicle isn't found automatically!\n+\n+The Vehicle isn't recognized or a predefined Vehicle doesn't show the right properties?\n+For this the [Discovery Fingerprint](#bridge-channels) is needed.\n+Short press on the Switch will force some logging entries which can be [normally found in the logs here](http://openhab:9001/) \n+\n+#### My Vehicle shows wrong data or data is missing!\n+\n+Now the [Vehicle Fingerprint](#troubleshooting) is needed.\n+Proceed like before, shortly press the Switch and the log contains the data.\n+\n+Personal Data is eliminated from the log entries so it should be possible to share them in public.\n+Data like\n+\n+* Dealer Properties\n+* Vehicle Identification Number (VIN)\n+* Location Latitude / Longitude \n+\n+are anonymized.\n+\n+After the corresponding Fingerprint is generated please [follow the instructions to raise an Issue](https://community.openhab.org/t/how-to-file-an-issue/68464) and attach the Fingerprint data!\n+Your feedback is highly appreciated!\n+\n+Here an example of Debug Fingerprint Data from a BEV_REX Vehicle", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e0bfe93e13df4a3c5de5f8819b94ebf795664904"}, "originalPosition": 433}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTA1Mjc1OQ==", "bodyText": "Example removed", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r549052759", "createdAt": "2020-12-27T01:54:37Z", "author": {"login": "weymann"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/README.md", "diffHunk": "@@ -0,0 +1,862 @@\n+# BMW ConnectedDrive Binding\n+\n+<img align=\"right\" src=\"./doc/bmw-connected.png\" width=\"150\" height=\"150\"/>\n+\n+The Binding provides a Connection between [BMWs ConnectedDrive Portal](https://www.bmw-connecteddrive.com/country-region-select/country-region-selection.html) and openHAB.\n+All Vehicles connected to an Account will be detected by the Discovery with the correct type \n+\n+* Conventional Fuel Vehicle\n+* Plugin-Hybrid Electrical Vehicle \n+* Battery Electric Vehicle with Range Extender\n+* Battery Electric Vehicle \n+\n+In addition Properties are attached with Information and Services provided by this Vehicle.\n+The provided data depends on \n+\n+1. the [Type](#Things) and \n+2. the Services mentioned in [Properties](#properties)\n+\n+Different Channel Groups are clustering all informations.\n+Check for each Group if it's supported for this Vehicle.\n+\n+Please note **this isn't a real-time Binding**. \n+If the Door is opened the state isn't transmitted and changed immediately. \n+This isn't a flaw in the Binding itself because the state in BMWs own ConnectedDrive App is also updated with some delay. \n+\n+## Supported Things\n+\n+### Bridge\n+\n+The Bridge establishes the Connection between BMW ConnectedDrive Portal and openHAB.\n+\n+| Name                       | Bridge Type ID | Description                                                |\n+|----------------------------|----------------|------------------------------------------------------------|\n+| BMW ConnectedDrive Account | account        | Access to BMW ConnectedDrive Portal for a specific user    |\n+\n+\n+### Things\n+\n+Four different Vehicle Types are provided. \n+They differ in the supported Channel Groups & Channels. \n+Conventional Fuel Vehicles have no _Charging Profile_, Electric Vehicles don't provide a _Fuel Range_. \n+For Hybrid Vehicles in addition to _Fuel and Electric Range_ the _Hybrid Range_ is shown.\n+ \n+| Name                                | Thing Type ID | Supported Channel Groups                                             |\n+|-------------------------------------|---------------|----------------------------------------------------------------------|\n+| BMW Electric Vehicle                | BEV           | status, range, location, service, check, charge, image, troubleshoot |\n+| BMW Electric Vehicle with REX       | BEV_REX       | status, range, location, service, check, charge, image, troubleshoot |\n+| BMW Plug-In-Hybrid Electric Vehicle | PHEV          | status, range, location, service, check, charge, image, troubleshoot |\n+| BMW Conventional Vehicle            | CONV          | status, range, location, service, check, image, troubleshoot         |\n+\n+ \n+#### Properties\n+\n+<img align=\"right\" src=\"./doc/properties.png\" width=\"500\" height=\"600\"/>\n+\n+For each Vehicle Properties are available. \n+Basically 3 Types of Information are registered as Properties\n+\n+* Informations regarding your Dealer with Address and Phone Number\n+* Which services are available / not available\n+* Vehicle Properties like Color, Model Type, Drive Train and Construction Year\n+\n+In the right picture  can see in *Services Activated* e.g. the *DoorLock* and *DoorUnlock* Services are mentioned. \n+This ensures [Channel Group _Remote Services_](#remote-services) is supporting Door lock and Door unlock.\n+\n+In  *Services Supported* the entry *LastDestination* is mentioned.\n+So it's valid to connect Channel Group [Last Destinations](#destinations) in order to display the last 3 Navigation Destinations.\n+\n+| Property Key       | Property Value      |  Supported Channel Groups    |\n+|--------------------|---------------------|------------------------------|\n+| Services Supported | Statistics          | last-trip, lifetime          |\n+| Services Supported | LastDestinations    | destinations                 |\n+| Services Activated | list of services    | remote                       |\n+\n+\n+## Discovery\n+\n+Auto Discovery is starting after creation of the Bridge towards BMW ConnectedDrive. \n+A list of your registered Vehicles is queried and all found Vehicles are added in Inbox.\n+Unique Identifier is the *Vehicle Identification Number* (VIN). \n+If a Thing is already declared in a  *.things configuration* Discovery won't highlight it again.\n+Properties will be attached to predefined Vehicles if the VIN is matching.\n+\n+## Configuration\n+\n+### Bridge\n+\n+| Parameter       | Type    | Description                                                             |           \n+|-----------------|---------|-------------------------------------------------------------------------|\n+| userName        | text    | BMW Connected Drive Username                  |\n+| password        | text    | BMW Connected Drive Password                  |\n+| region          | text    | Select Region in order to connect to the appropriate BMW Server.   |\n+\n+The region Configuration has 3 different possibilities\n+\n+* _NORTH_AMERICA_\n+* _CHINA_\n+* _ROW_ for Rest of World\n+\n+### Thing\n+\n+Same Configuration is needed for all Things\n+\n+| Parameter       | Type    | Description                           |           \n+|-----------------|---------|---------------------------------------|\n+| vin             | text    | Vehicle Identification Number (VIN)   |\n+| refreshInterval | integer | Refresh Interval in Minutes           |\n+| units           | text    | Unit Selection                        |\n+| imageSize       | integer | Image Size                            |\n+| imageViewport   | text    | Image Viewport                        |\n+\n+The units can be configured in 3 ways\n+\n+* _AUTODETECT_ selects Miles for US & UK, Kilometer otherwise\n+* _METRIC_ selects directly Kilometers\n+* _IMPERIAL_ selects directly Miles\n+\n+The imageVieport allows to show the Vehicle from different angels.\n+Possible values are \n+\n+* FRONT\n+* REAR\n+* SIDE\n+* DASHBOARD\n+* DRIVERDOOR\n+\n+## Channels\n+\n+There are many Channels available for each Vehicle. \n+For better overview they are clustered in different Channel Groups.\n+The Channel Groups are different for the Vehicle Types, on the build-in Sensors of the Vehicle and the activated Services.\n+\n+### Bridge Channels\n+\n+If the Vehicle isn't found in the Discovery force a log of Fingerprint Data which helps to analyze the problem.\n+Please check [TroubleShooting Section](#TroubleShooting) for further advice.\n+\n+| Channel Label         | Channel ID            | Type   | Description                                       |\n+|-----------------------|-----------------------|--------|---------------------------------------------------|\n+| Discovery Fingerprint | discovery-fingerprint | Switch | Forcing a log entry to analyze Discovery Problems |\n+\n+### Thing Channel Groups \n+\n+#### Vehicle Status\n+\n+Reflects Status of the Vehicle.\n+Available for all Vehicles, Read-only.\n+\n+| Channel Label             | Channel Group ID | Channel ID          | Type          | Description                                                                       |\n+|---------------------------|------------------|---------------------|---------------|-----------------------------------------------------------------------------------|\n+| Overall Door Status       | status           | doors               | String        | **Closed** if all closed otherwise **Open**. **Unknown** if no data is delivered  |\n+| Overall Window Status     | status           | windows             | String        | **Closed** if all closed otherwise **Open** or **Intermediate**. **Unknown** if no data is delivered   |\n+| Doors Locked              | status           | lock                | String        | Status if Doors are locked or unlocked                                            |\n+| Next Service Date         | status           | service-date        | DateTime      | Date of Upcoming Service                                                          |\n+| Mileage till Next Service | status           | service-mileage     | Number:Length | Mileage till Upcoming Service                                                     |\n+| Check Control             | status           | check-control       | String        | Indicator if CheckControl is **Active** or **Not Active**. **Unknown** if no data is delivered         |\n+| Charging Status           | status           | charge              | String        | Only available for PHEV, BEV_REX and BEV                                          |\n+| Last Status Timestamp     | status           | last-update         | DateTime      | Date and Time of last status update.                                              |\n+\n+See [further details for DateTime](#last-status-update-timestamp) in case of wrong timestamp values\n+\n+#### Services\n+\n+Group for all upcoming Services with Description, Service Date and / or Service Mileage\n+It's designed as [List Interface](#list-interface) so all upcoming Services can be checked.\n+\n+| Channel Label                  | Channel Group ID | Channel ID          | Type           | \n+|--------------------------------|------------------|---------------------|----------------|\n+| Service Name                   | service          | name                | String         |\n+| Service Date                   | service          | date                | Number         |\n+| Mileage till Service           | service          | mileage             | Number:Length  |\n+| Number of Scheduled Services   | service          | size                | String         |\n+| Current Selected Service Index | service          | index               | Number         |\n+| Select next Service            | service          | next                | Switch         |\n+\n+#### Check Control\n+\n+Group for all current active CheckControl Messages.\n+It's designed as [List Interface](#list-interface) to show all active Messages.\n+\n+| Channel Label                   | Channel Group ID | Channel ID          | Type           | \n+|---------------------------------|------------------|---------------------|----------------|\n+| CheckControl Description        | check            | name                | String         |\n+| CheckControl Mileage Occurrence | check            | mileage             | Number:Length  |\n+| Active CheckControl Messages    | check            | size                | String         |\n+| Selected CheckControl Message   | check            | index               | Number         |\n+| Next CheckControl Message       | check            | next                | Switch         |\n+\n+#### Doors Details\n+\n+Detailed Status of all Doors and Windows\n+Available for all Vehicles, Read-only. \n+\n+| Channel Label              | Channel Group ID | Channel ID              | Type          | \n+|----------------------------|------------------|-------------------------|---------------|\n+| Driver Door                | doors            | driver-front            | String        |\n+| Driver Door Rear           | doors            | driver-rear             | String        |\n+| Passenger Door             | doors            | passenger-front         | String        |\n+| Passenger Door Rear        | doors            | passenger-rear          | String        |\n+| Trunk                      | doors            | trunk                   | String        |\n+| Hood                       | doors            | hood                    | String        |\n+| Driver Door Window         | doors            | window-driver-front     | String        |\n+| Driver Door Rear Window    | doors            | window-driver-rear      | String        |\n+| Passenger Door Window      | doors            | window-passenger-front  | String        |\n+| Passenger Door Rear Window | doors            | window-passenger-rear   | String        |\n+| Rear Window                | doors            | window-rear             | String        |\n+| Sunroof                    | doors            | sunroof                 | String        |\n+\n+Following Strings will be delivered\n+\n+* UNKNOWN - no status data available\n+* INVALID - this item isn't applicable for this Vehicle\n+* CLOSED - the Door / Window is closed\n+* OPEN - the Door / Window is open\n+* INTERMEDIATE - Window in intermediate position, not applicable for Doors\n+\n+#### Range Data\n+\n+Based on Vehicle Type (Thing Type ID) some Channels are presented or not. \n+Conventional Fuel Vehicles don't provide *Electric Range* and Battery Electric Vehicles don't show *Range Fuel*.\n+Hybrid Vehicles have both and in addition *Hybrid Range*.\n+These are Read-only values.\n+\n+| Channel Label         | Channel Group ID | Channel ID            | Type                 | CONV | PHEV | BEV_REX | BEV |\n+|-----------------------|------------------|-----------------------|----------------------|------|------|---------|-----|\n+| Mileage               | range            | mileage               | Number:Length        |  X   |  X   |    X    |  X  |\n+| Fuel Range            | range            | range-fuel            | Number:Length        |  X   |  X   |    X    |     |\n+| Battery Range         | range            | range-electric        | Number:Length        |      |  X   |    X    |  X  | \n+| Hybrid Range          | range            | range-hybrid          | Number:Length        |      |  X   |    X    |     | \n+| Battery Charge Level  | range            | soc                   | Number:Dimensionless |      |  X   |    X    |  X  |\n+| Remaining Fuel        | range            | remaining-fuel        | Number:Volume        |  X   |  X   |    X    |     | \n+| Fuel Range Radius     | range            | range-radius-fuel     | Number:Length        |  X   |  X   |    X    |     | \n+| Electric Range Radius | range            | range-radius-electric | Number:Length        |      |  X   |    X    |  X  | \n+| Hybrid Range Radius   | range            | range-radius-hybrid   | Number:Length        |      |  X   |    X    |     | \n+\n+See Description [Range vs Range Radius](#range-vs-range-radius) to get more information\n+\n+#### Charge Profile\n+\n+Valid for Electric and Hybrid Vehicles\n+These are Read-only values.\n+\n+| Channel Label                      | Channel Group ID | Channel ID          | Type   | \n+|------------------------------------|------------------|---------------------|--------|\n+| Air Conditioning at Departure Time | charge           | profile-climate     | Switch | \n+| Charging Mode for Profile          | charge           | profile-mode        | String | \n+| Charging Window Start Time         | charge           | window-start        | String | \n+| Charging Window End Time           | charge           | window-end          | String | \n+| Timer 1: Departure Time            | charge           | timer1-departure    | String | \n+| Timer 1: Scheduled Days            | charge           | timer1-days         | String | \n+| Timer 1: Enabled                   | charge           | timer1-enabled      | Switch | \n+| Timer 2: Departure Time            | charge           | timer2-departure    | String | \n+| Timer 2: Scheduled Days            | charge           | timer2-days         | String | \n+| Timer 2: Enabled                   | charge           | timer2-enabled      | Switch | \n+| Timer 3: Departure Time            | charge           | timer3-departure    | String | \n+| Timer 3: Scheduled Days            | charge           | timer3-days         | String | \n+| Timer 3: Enabled                   | charge           | timer3-enabled      | Switch | \n+\n+\n+#### Location\n+\n+Available for all Vehicles.\n+These are Read-only values.\n+\n+| Channel Label  | Channel Group ID | Channel ID          | Type         | \n+|----------------|------------------|---------------------|--------------|\n+| Latitude       | location         | latitude            | Number       | \n+| Longitude      | location         | longitude           | Number       |\n+| Heading        | location         | heading             | Number:Angle | \n+\n+#### Last Trip\n+\n+Check [Vehicle Properties](#Properties) if *Statistics* is present in *Services Supported*\n+These are Read-only values.\n+\n+| Channel Label                           | Channel Group ID | Channel ID                   | Type          |\n+|-----------------------------------------|------------------|------------------------------|---------------|\n+| Last Trip Date                          | last-trip        | date                         | DateTime      |\n+| Last Trip Duration                      | last-trip        | duration                     | Number:Time   |\n+| Average Power Consumption per 100 km    | last-trip        | average-consumption          | Number:Power  |\n+| Average Combined Consumption per 100 km | last-trip        | average-combined-consumption | Number:Volume |\n+| Average Power Recuperation per 100 km   | last-trip        | average-recuperation         | Number:Power  |\n+| Last Trip Distance                      | last-trip        | distance                     | Number:Length |\n+| Distance since Last Charge              | last-trip        | distance-since-charging      | Number:Length |\n+\n+\n+#### Lifetime Statistics\n+\n+Check [Vehicle Properties](#Properties) if *Statistics* is present in *Services Supported*\n+These are Read-only values.\n+\n+| Channel Label                           | Channel Group ID | Channel ID                   | Type          | \n+|-----------------------------------------|------------------|------------------------------|---------------|\n+| Average Power Consumption per 100 km    | lifetime         | average-consumption          | Number:Power  |\n+| Average Power Recuperation per 100 km   | lifetime         | average-recuperation         | Number:Power  |\n+| Cumulated Electric Driven Distance      | lifetime         | cumulated-driven-distance    | Number:Length |\n+| Average Combined Consumption per 100 km | lifetime         | average-combined-consumption | Number:Volume |\n+| Longest Distance with one Charge        | lifetime         | single-longest-distance      | Number:Length |\n+\n+\n+#### Remote Services\n+\n+Check [Vehicle Properties](#Properties) *Services Activated* which Remote Services are available\n+Only one Remote Service can be executed each Time.\n+Parallel execution isn't supported.\n+The *Service Execution State* Channel is reporting the state.\n+State *Executed* is the final State when Execution is finished.\n+\n+| Channel Label           | Channel Group ID | Channel ID          | Type    | \n+|-------------------------|------------------|---------------------|---------|\n+| Activate Flash Lights   | remote           | light               | Switch  |\n+| Find Vehicle            | remote           | finder              | Switch  |\n+| Lock Doors              | remote           | lock                | Switch  |\n+| Unlock Doors            | remote           | unlock              | Switch  |\n+| Horn Blow               | remote           | horn                | Switch  |\n+| Active Air Conditioning | remote           | climate             | Switch  |\n+| Service Execution State | remote           | state               | STring  |\n+\n+#### Destinations\n+\n+Check [Vehicle Properties](#Properties) if *LastDestinations* is present in *Services Supported*\n+It's designed as [List Interface](#list-interface) in order to have access to all stored Destinations.\n+\n+| Channel Label                    | Channel Group ID | Channel ID          | Type    | \n+|----------------------------------|------------------|---------------------|---------|\n+| Destination Name                 | destination      | name                | String  |\n+| Destination Latitude             | destination      | latitude            | Number  |\n+| Destination Longitude            | destination      | longitude           | Number  |\n+| Number of Available Destinations | destination      | size                | String  |\n+| Index of Selected Destination    | destination      | index               | Number  |\n+| Skip to Next Destination         | destination      | next                | Switch  |\n+\n+\n+#### Image\n+\n+Available for all Vehicles.\n+Picture can be modified regarding *Viewport* and *Size*.\n+See [Things Section](#thing) for Viewport possibilities and [Status Image](#status-image) for possible Use Cases.\n+\n+| Channel Label                 | Channel Group ID | Channel ID          | Type   | \n+|-------------------------------|------------------|---------------------|--------|\n+| Rendered Image of the Vehicle | image            | png                 | Image  |\n+| Image Viewport                | image            | view                | String |\n+| Image Picture Size            | image            | size                | Number |\n+\n+\n+#### Troubleshooting\n+\n+Available for all Vehicles!\n+Switch will log a *Vehicle Data Fingerprint* into the openHAB log.\n+Please check [TroubleShooting Section](#TroubleShooting) for further advice.\n+\n+| Channel Label                       | Channel Group ID | Channel ID          | Type   | Description                                       |\n+|-------------------------------------|------------------|---------------------|--------|---------------------------------------------------|\n+| Log Vehicle Fingerprint             | troubleshoot     | vehicle-fingerprint | Switch | Forces log entries in openHAB logger in order to raise issues |\n+\n+## Further Descriptions\n+\n+### List Interface\n+\n+Currently there are 3 occurrences of dynamic data delivered as Lists\n+\n+* Upcoming Services\n+* Check Control Messages\n+* Last Destinations\n+\n+In order to provide all data the lists are organized the following way based on the Service Group example\n+\n+* **size** is the total length of the list. Read-only.\n+* **index** is the current selected index starting with 0 => list with size 10, valid index is between 0 - 9. If the index is set to _out of bounds_ it's set to first element. Read-write.\n+* **next** declares a switch for scrolling forward through the list in an endless way. Reaching end of list will start again from 0. Read-write.\n+* **name**, **mileage** and **date** declares the list item. It will change when setting new index or perform next. Read-only.\n+\n+### Range vs Range Radius\n+\n+<img align=\"right\" src=\"./doc/range-radius.png\" width=\"400\" height=\"350\"/>\n+\n+ will observe differences in the Vehicle Range and Range Radius values. \n+While Range is indicating the possible distance to be driven on roads the range radius indicates the reachable range on the Map.\n+\n+The right picture shows the distance between Kassel and Frankfurt in Germany. \n+While the Air-line Distance is ~145 Kilometer the Route Distance is ~192 Kilometer.\n+So Range value is the normal remaining range.\n+See the Section [OpenStreetMap](#openstreetMap-widget) how the Range Radius is used to indicate the reachable Range on Map.\n+Please note this is just an indicator and the effective range, especially for Electric Vehicles, \n+depends on many factors like driving style and electric consumers. \n+ \n+### Last Status Update Timestamp\n+\n+A timestamp is showing the last Vehicle Status update. If this isn't shown correctly please check the date settings.\n+In case of Raspberry Pi execute *raspi-config*, select *Localization Options*, the *Change Time Zone*\n+Select your *Geographical Area* and afterwards the correct City.\n+One restart of openHAB service with *systemctl restart openhab2* is necessary in order to see the corrected Time Settings.\n+ \n+Correct TimeZone is crucial for handling all Time information in openHAB and it's discussed many times in the Forum.\n+See [similar discussion in the openHAB Forum](https://community.openhab.org/t/solved-wrong-local-time-how-to-change/90938) which deals with the same problem.\n+\n+### TroubleShooting\n+\n+BMW has a high range of Vehicles supported by BMWs ConnectedDrive.\n+In case of any issues with this Binding please help to resolve it! \n+Please perform the following Steps:\n+\n+* Can you login [into ConnectedDrive](https://www.bmw-connecteddrive.com/country-region-select/country-region-selection.html) with your Credentials? _Please note this isn't the BMW Customer Portal - it's the ConnectedDrive Portal_\n+* Is the Vehicle listed in your Account? _There's a one-to-one dependency from User to Vehicle_\n+\n+If the access to the Portal and listing of the Vehicle is checked some debug data is needed in order to identify the issue. \n+The [Example Sitemap](#Sitemap) contains the necessary items to generate Debug Data.\n+\n+#### My Vehicle isn't found automatically!\n+\n+The Vehicle isn't recognized or a predefined Vehicle doesn't show the right properties?\n+For this the [Discovery Fingerprint](#bridge-channels) is needed.\n+Short press on the Switch will force some logging entries which can be [normally found in the logs here](http://openhab:9001/) \n+\n+#### My Vehicle shows wrong data or data is missing!\n+\n+Now the [Vehicle Fingerprint](#troubleshooting) is needed.\n+Proceed like before, shortly press the Switch and the log contains the data.\n+\n+Personal Data is eliminated from the log entries so it should be possible to share them in public.\n+Data like\n+\n+* Dealer Properties\n+* Vehicle Identification Number (VIN)\n+* Location Latitude / Longitude \n+\n+are anonymized.\n+\n+After the corresponding Fingerprint is generated please [follow the instructions to raise an Issue](https://community.openhab.org/t/how-to-file-an-issue/68464) and attach the Fingerprint data!\n+Your feedback is highly appreciated!\n+\n+Here an example of Debug Fingerprint Data from a BEV_REX Vehicle", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTEzODUyNw=="}, "originalCommit": {"oid": "e0bfe93e13df4a3c5de5f8819b94ebf795664904"}, "originalPosition": 433}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEzNzkxNDgzOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.bmwconnecteddrive/README.md", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wN1QxNjoxMzoyOFrOHd7Fgg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yN1QwMTo1Mzo0NlrOILnhIg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTEzODgxOA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            In addition search for all occurrences of *i3* and replace it with your Vehicle Identification like *x3* or *535d* and 're ready to go!\n          \n          \n            \n            In addition search for all occurrences of *i3* and replace it with your Vehicle Identification like *x3* or *535d* and you're ready to go!", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r501138818", "createdAt": "2020-10-07T16:13:28Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/README.md", "diffHunk": "@@ -0,0 +1,862 @@\n+# BMW ConnectedDrive Binding\n+\n+<img align=\"right\" src=\"./doc/bmw-connected.png\" width=\"150\" height=\"150\"/>\n+\n+The Binding provides a Connection between [BMWs ConnectedDrive Portal](https://www.bmw-connecteddrive.com/country-region-select/country-region-selection.html) and openHAB.\n+All Vehicles connected to an Account will be detected by the Discovery with the correct type \n+\n+* Conventional Fuel Vehicle\n+* Plugin-Hybrid Electrical Vehicle \n+* Battery Electric Vehicle with Range Extender\n+* Battery Electric Vehicle \n+\n+In addition Properties are attached with Information and Services provided by this Vehicle.\n+The provided data depends on \n+\n+1. the [Type](#Things) and \n+2. the Services mentioned in [Properties](#properties)\n+\n+Different Channel Groups are clustering all informations.\n+Check for each Group if it's supported for this Vehicle.\n+\n+Please note **this isn't a real-time Binding**. \n+If the Door is opened the state isn't transmitted and changed immediately. \n+This isn't a flaw in the Binding itself because the state in BMWs own ConnectedDrive App is also updated with some delay. \n+\n+## Supported Things\n+\n+### Bridge\n+\n+The Bridge establishes the Connection between BMW ConnectedDrive Portal and openHAB.\n+\n+| Name                       | Bridge Type ID | Description                                                |\n+|----------------------------|----------------|------------------------------------------------------------|\n+| BMW ConnectedDrive Account | account        | Access to BMW ConnectedDrive Portal for a specific user    |\n+\n+\n+### Things\n+\n+Four different Vehicle Types are provided. \n+They differ in the supported Channel Groups & Channels. \n+Conventional Fuel Vehicles have no _Charging Profile_, Electric Vehicles don't provide a _Fuel Range_. \n+For Hybrid Vehicles in addition to _Fuel and Electric Range_ the _Hybrid Range_ is shown.\n+ \n+| Name                                | Thing Type ID | Supported Channel Groups                                             |\n+|-------------------------------------|---------------|----------------------------------------------------------------------|\n+| BMW Electric Vehicle                | BEV           | status, range, location, service, check, charge, image, troubleshoot |\n+| BMW Electric Vehicle with REX       | BEV_REX       | status, range, location, service, check, charge, image, troubleshoot |\n+| BMW Plug-In-Hybrid Electric Vehicle | PHEV          | status, range, location, service, check, charge, image, troubleshoot |\n+| BMW Conventional Vehicle            | CONV          | status, range, location, service, check, image, troubleshoot         |\n+\n+ \n+#### Properties\n+\n+<img align=\"right\" src=\"./doc/properties.png\" width=\"500\" height=\"600\"/>\n+\n+For each Vehicle Properties are available. \n+Basically 3 Types of Information are registered as Properties\n+\n+* Informations regarding your Dealer with Address and Phone Number\n+* Which services are available / not available\n+* Vehicle Properties like Color, Model Type, Drive Train and Construction Year\n+\n+In the right picture  can see in *Services Activated* e.g. the *DoorLock* and *DoorUnlock* Services are mentioned. \n+This ensures [Channel Group _Remote Services_](#remote-services) is supporting Door lock and Door unlock.\n+\n+In  *Services Supported* the entry *LastDestination* is mentioned.\n+So it's valid to connect Channel Group [Last Destinations](#destinations) in order to display the last 3 Navigation Destinations.\n+\n+| Property Key       | Property Value      |  Supported Channel Groups    |\n+|--------------------|---------------------|------------------------------|\n+| Services Supported | Statistics          | last-trip, lifetime          |\n+| Services Supported | LastDestinations    | destinations                 |\n+| Services Activated | list of services    | remote                       |\n+\n+\n+## Discovery\n+\n+Auto Discovery is starting after creation of the Bridge towards BMW ConnectedDrive. \n+A list of your registered Vehicles is queried and all found Vehicles are added in Inbox.\n+Unique Identifier is the *Vehicle Identification Number* (VIN). \n+If a Thing is already declared in a  *.things configuration* Discovery won't highlight it again.\n+Properties will be attached to predefined Vehicles if the VIN is matching.\n+\n+## Configuration\n+\n+### Bridge\n+\n+| Parameter       | Type    | Description                                                             |           \n+|-----------------|---------|-------------------------------------------------------------------------|\n+| userName        | text    | BMW Connected Drive Username                  |\n+| password        | text    | BMW Connected Drive Password                  |\n+| region          | text    | Select Region in order to connect to the appropriate BMW Server.   |\n+\n+The region Configuration has 3 different possibilities\n+\n+* _NORTH_AMERICA_\n+* _CHINA_\n+* _ROW_ for Rest of World\n+\n+### Thing\n+\n+Same Configuration is needed for all Things\n+\n+| Parameter       | Type    | Description                           |           \n+|-----------------|---------|---------------------------------------|\n+| vin             | text    | Vehicle Identification Number (VIN)   |\n+| refreshInterval | integer | Refresh Interval in Minutes           |\n+| units           | text    | Unit Selection                        |\n+| imageSize       | integer | Image Size                            |\n+| imageViewport   | text    | Image Viewport                        |\n+\n+The units can be configured in 3 ways\n+\n+* _AUTODETECT_ selects Miles for US & UK, Kilometer otherwise\n+* _METRIC_ selects directly Kilometers\n+* _IMPERIAL_ selects directly Miles\n+\n+The imageVieport allows to show the Vehicle from different angels.\n+Possible values are \n+\n+* FRONT\n+* REAR\n+* SIDE\n+* DASHBOARD\n+* DRIVERDOOR\n+\n+## Channels\n+\n+There are many Channels available for each Vehicle. \n+For better overview they are clustered in different Channel Groups.\n+The Channel Groups are different for the Vehicle Types, on the build-in Sensors of the Vehicle and the activated Services.\n+\n+### Bridge Channels\n+\n+If the Vehicle isn't found in the Discovery force a log of Fingerprint Data which helps to analyze the problem.\n+Please check [TroubleShooting Section](#TroubleShooting) for further advice.\n+\n+| Channel Label         | Channel ID            | Type   | Description                                       |\n+|-----------------------|-----------------------|--------|---------------------------------------------------|\n+| Discovery Fingerprint | discovery-fingerprint | Switch | Forcing a log entry to analyze Discovery Problems |\n+\n+### Thing Channel Groups \n+\n+#### Vehicle Status\n+\n+Reflects Status of the Vehicle.\n+Available for all Vehicles, Read-only.\n+\n+| Channel Label             | Channel Group ID | Channel ID          | Type          | Description                                                                       |\n+|---------------------------|------------------|---------------------|---------------|-----------------------------------------------------------------------------------|\n+| Overall Door Status       | status           | doors               | String        | **Closed** if all closed otherwise **Open**. **Unknown** if no data is delivered  |\n+| Overall Window Status     | status           | windows             | String        | **Closed** if all closed otherwise **Open** or **Intermediate**. **Unknown** if no data is delivered   |\n+| Doors Locked              | status           | lock                | String        | Status if Doors are locked or unlocked                                            |\n+| Next Service Date         | status           | service-date        | DateTime      | Date of Upcoming Service                                                          |\n+| Mileage till Next Service | status           | service-mileage     | Number:Length | Mileage till Upcoming Service                                                     |\n+| Check Control             | status           | check-control       | String        | Indicator if CheckControl is **Active** or **Not Active**. **Unknown** if no data is delivered         |\n+| Charging Status           | status           | charge              | String        | Only available for PHEV, BEV_REX and BEV                                          |\n+| Last Status Timestamp     | status           | last-update         | DateTime      | Date and Time of last status update.                                              |\n+\n+See [further details for DateTime](#last-status-update-timestamp) in case of wrong timestamp values\n+\n+#### Services\n+\n+Group for all upcoming Services with Description, Service Date and / or Service Mileage\n+It's designed as [List Interface](#list-interface) so all upcoming Services can be checked.\n+\n+| Channel Label                  | Channel Group ID | Channel ID          | Type           | \n+|--------------------------------|------------------|---------------------|----------------|\n+| Service Name                   | service          | name                | String         |\n+| Service Date                   | service          | date                | Number         |\n+| Mileage till Service           | service          | mileage             | Number:Length  |\n+| Number of Scheduled Services   | service          | size                | String         |\n+| Current Selected Service Index | service          | index               | Number         |\n+| Select next Service            | service          | next                | Switch         |\n+\n+#### Check Control\n+\n+Group for all current active CheckControl Messages.\n+It's designed as [List Interface](#list-interface) to show all active Messages.\n+\n+| Channel Label                   | Channel Group ID | Channel ID          | Type           | \n+|---------------------------------|------------------|---------------------|----------------|\n+| CheckControl Description        | check            | name                | String         |\n+| CheckControl Mileage Occurrence | check            | mileage             | Number:Length  |\n+| Active CheckControl Messages    | check            | size                | String         |\n+| Selected CheckControl Message   | check            | index               | Number         |\n+| Next CheckControl Message       | check            | next                | Switch         |\n+\n+#### Doors Details\n+\n+Detailed Status of all Doors and Windows\n+Available for all Vehicles, Read-only. \n+\n+| Channel Label              | Channel Group ID | Channel ID              | Type          | \n+|----------------------------|------------------|-------------------------|---------------|\n+| Driver Door                | doors            | driver-front            | String        |\n+| Driver Door Rear           | doors            | driver-rear             | String        |\n+| Passenger Door             | doors            | passenger-front         | String        |\n+| Passenger Door Rear        | doors            | passenger-rear          | String        |\n+| Trunk                      | doors            | trunk                   | String        |\n+| Hood                       | doors            | hood                    | String        |\n+| Driver Door Window         | doors            | window-driver-front     | String        |\n+| Driver Door Rear Window    | doors            | window-driver-rear      | String        |\n+| Passenger Door Window      | doors            | window-passenger-front  | String        |\n+| Passenger Door Rear Window | doors            | window-passenger-rear   | String        |\n+| Rear Window                | doors            | window-rear             | String        |\n+| Sunroof                    | doors            | sunroof                 | String        |\n+\n+Following Strings will be delivered\n+\n+* UNKNOWN - no status data available\n+* INVALID - this item isn't applicable for this Vehicle\n+* CLOSED - the Door / Window is closed\n+* OPEN - the Door / Window is open\n+* INTERMEDIATE - Window in intermediate position, not applicable for Doors\n+\n+#### Range Data\n+\n+Based on Vehicle Type (Thing Type ID) some Channels are presented or not. \n+Conventional Fuel Vehicles don't provide *Electric Range* and Battery Electric Vehicles don't show *Range Fuel*.\n+Hybrid Vehicles have both and in addition *Hybrid Range*.\n+These are Read-only values.\n+\n+| Channel Label         | Channel Group ID | Channel ID            | Type                 | CONV | PHEV | BEV_REX | BEV |\n+|-----------------------|------------------|-----------------------|----------------------|------|------|---------|-----|\n+| Mileage               | range            | mileage               | Number:Length        |  X   |  X   |    X    |  X  |\n+| Fuel Range            | range            | range-fuel            | Number:Length        |  X   |  X   |    X    |     |\n+| Battery Range         | range            | range-electric        | Number:Length        |      |  X   |    X    |  X  | \n+| Hybrid Range          | range            | range-hybrid          | Number:Length        |      |  X   |    X    |     | \n+| Battery Charge Level  | range            | soc                   | Number:Dimensionless |      |  X   |    X    |  X  |\n+| Remaining Fuel        | range            | remaining-fuel        | Number:Volume        |  X   |  X   |    X    |     | \n+| Fuel Range Radius     | range            | range-radius-fuel     | Number:Length        |  X   |  X   |    X    |     | \n+| Electric Range Radius | range            | range-radius-electric | Number:Length        |      |  X   |    X    |  X  | \n+| Hybrid Range Radius   | range            | range-radius-hybrid   | Number:Length        |      |  X   |    X    |     | \n+\n+See Description [Range vs Range Radius](#range-vs-range-radius) to get more information\n+\n+#### Charge Profile\n+\n+Valid for Electric and Hybrid Vehicles\n+These are Read-only values.\n+\n+| Channel Label                      | Channel Group ID | Channel ID          | Type   | \n+|------------------------------------|------------------|---------------------|--------|\n+| Air Conditioning at Departure Time | charge           | profile-climate     | Switch | \n+| Charging Mode for Profile          | charge           | profile-mode        | String | \n+| Charging Window Start Time         | charge           | window-start        | String | \n+| Charging Window End Time           | charge           | window-end          | String | \n+| Timer 1: Departure Time            | charge           | timer1-departure    | String | \n+| Timer 1: Scheduled Days            | charge           | timer1-days         | String | \n+| Timer 1: Enabled                   | charge           | timer1-enabled      | Switch | \n+| Timer 2: Departure Time            | charge           | timer2-departure    | String | \n+| Timer 2: Scheduled Days            | charge           | timer2-days         | String | \n+| Timer 2: Enabled                   | charge           | timer2-enabled      | Switch | \n+| Timer 3: Departure Time            | charge           | timer3-departure    | String | \n+| Timer 3: Scheduled Days            | charge           | timer3-days         | String | \n+| Timer 3: Enabled                   | charge           | timer3-enabled      | Switch | \n+\n+\n+#### Location\n+\n+Available for all Vehicles.\n+These are Read-only values.\n+\n+| Channel Label  | Channel Group ID | Channel ID          | Type         | \n+|----------------|------------------|---------------------|--------------|\n+| Latitude       | location         | latitude            | Number       | \n+| Longitude      | location         | longitude           | Number       |\n+| Heading        | location         | heading             | Number:Angle | \n+\n+#### Last Trip\n+\n+Check [Vehicle Properties](#Properties) if *Statistics* is present in *Services Supported*\n+These are Read-only values.\n+\n+| Channel Label                           | Channel Group ID | Channel ID                   | Type          |\n+|-----------------------------------------|------------------|------------------------------|---------------|\n+| Last Trip Date                          | last-trip        | date                         | DateTime      |\n+| Last Trip Duration                      | last-trip        | duration                     | Number:Time   |\n+| Average Power Consumption per 100 km    | last-trip        | average-consumption          | Number:Power  |\n+| Average Combined Consumption per 100 km | last-trip        | average-combined-consumption | Number:Volume |\n+| Average Power Recuperation per 100 km   | last-trip        | average-recuperation         | Number:Power  |\n+| Last Trip Distance                      | last-trip        | distance                     | Number:Length |\n+| Distance since Last Charge              | last-trip        | distance-since-charging      | Number:Length |\n+\n+\n+#### Lifetime Statistics\n+\n+Check [Vehicle Properties](#Properties) if *Statistics* is present in *Services Supported*\n+These are Read-only values.\n+\n+| Channel Label                           | Channel Group ID | Channel ID                   | Type          | \n+|-----------------------------------------|------------------|------------------------------|---------------|\n+| Average Power Consumption per 100 km    | lifetime         | average-consumption          | Number:Power  |\n+| Average Power Recuperation per 100 km   | lifetime         | average-recuperation         | Number:Power  |\n+| Cumulated Electric Driven Distance      | lifetime         | cumulated-driven-distance    | Number:Length |\n+| Average Combined Consumption per 100 km | lifetime         | average-combined-consumption | Number:Volume |\n+| Longest Distance with one Charge        | lifetime         | single-longest-distance      | Number:Length |\n+\n+\n+#### Remote Services\n+\n+Check [Vehicle Properties](#Properties) *Services Activated* which Remote Services are available\n+Only one Remote Service can be executed each Time.\n+Parallel execution isn't supported.\n+The *Service Execution State* Channel is reporting the state.\n+State *Executed* is the final State when Execution is finished.\n+\n+| Channel Label           | Channel Group ID | Channel ID          | Type    | \n+|-------------------------|------------------|---------------------|---------|\n+| Activate Flash Lights   | remote           | light               | Switch  |\n+| Find Vehicle            | remote           | finder              | Switch  |\n+| Lock Doors              | remote           | lock                | Switch  |\n+| Unlock Doors            | remote           | unlock              | Switch  |\n+| Horn Blow               | remote           | horn                | Switch  |\n+| Active Air Conditioning | remote           | climate             | Switch  |\n+| Service Execution State | remote           | state               | STring  |\n+\n+#### Destinations\n+\n+Check [Vehicle Properties](#Properties) if *LastDestinations* is present in *Services Supported*\n+It's designed as [List Interface](#list-interface) in order to have access to all stored Destinations.\n+\n+| Channel Label                    | Channel Group ID | Channel ID          | Type    | \n+|----------------------------------|------------------|---------------------|---------|\n+| Destination Name                 | destination      | name                | String  |\n+| Destination Latitude             | destination      | latitude            | Number  |\n+| Destination Longitude            | destination      | longitude           | Number  |\n+| Number of Available Destinations | destination      | size                | String  |\n+| Index of Selected Destination    | destination      | index               | Number  |\n+| Skip to Next Destination         | destination      | next                | Switch  |\n+\n+\n+#### Image\n+\n+Available for all Vehicles.\n+Picture can be modified regarding *Viewport* and *Size*.\n+See [Things Section](#thing) for Viewport possibilities and [Status Image](#status-image) for possible Use Cases.\n+\n+| Channel Label                 | Channel Group ID | Channel ID          | Type   | \n+|-------------------------------|------------------|---------------------|--------|\n+| Rendered Image of the Vehicle | image            | png                 | Image  |\n+| Image Viewport                | image            | view                | String |\n+| Image Picture Size            | image            | size                | Number |\n+\n+\n+#### Troubleshooting\n+\n+Available for all Vehicles!\n+Switch will log a *Vehicle Data Fingerprint* into the openHAB log.\n+Please check [TroubleShooting Section](#TroubleShooting) for further advice.\n+\n+| Channel Label                       | Channel Group ID | Channel ID          | Type   | Description                                       |\n+|-------------------------------------|------------------|---------------------|--------|---------------------------------------------------|\n+| Log Vehicle Fingerprint             | troubleshoot     | vehicle-fingerprint | Switch | Forces log entries in openHAB logger in order to raise issues |\n+\n+## Further Descriptions\n+\n+### List Interface\n+\n+Currently there are 3 occurrences of dynamic data delivered as Lists\n+\n+* Upcoming Services\n+* Check Control Messages\n+* Last Destinations\n+\n+In order to provide all data the lists are organized the following way based on the Service Group example\n+\n+* **size** is the total length of the list. Read-only.\n+* **index** is the current selected index starting with 0 => list with size 10, valid index is between 0 - 9. If the index is set to _out of bounds_ it's set to first element. Read-write.\n+* **next** declares a switch for scrolling forward through the list in an endless way. Reaching end of list will start again from 0. Read-write.\n+* **name**, **mileage** and **date** declares the list item. It will change when setting new index or perform next. Read-only.\n+\n+### Range vs Range Radius\n+\n+<img align=\"right\" src=\"./doc/range-radius.png\" width=\"400\" height=\"350\"/>\n+\n+ will observe differences in the Vehicle Range and Range Radius values. \n+While Range is indicating the possible distance to be driven on roads the range radius indicates the reachable range on the Map.\n+\n+The right picture shows the distance between Kassel and Frankfurt in Germany. \n+While the Air-line Distance is ~145 Kilometer the Route Distance is ~192 Kilometer.\n+So Range value is the normal remaining range.\n+See the Section [OpenStreetMap](#openstreetMap-widget) how the Range Radius is used to indicate the reachable Range on Map.\n+Please note this is just an indicator and the effective range, especially for Electric Vehicles, \n+depends on many factors like driving style and electric consumers. \n+ \n+### Last Status Update Timestamp\n+\n+A timestamp is showing the last Vehicle Status update. If this isn't shown correctly please check the date settings.\n+In case of Raspberry Pi execute *raspi-config*, select *Localization Options*, the *Change Time Zone*\n+Select your *Geographical Area* and afterwards the correct City.\n+One restart of openHAB service with *systemctl restart openhab2* is necessary in order to see the corrected Time Settings.\n+ \n+Correct TimeZone is crucial for handling all Time information in openHAB and it's discussed many times in the Forum.\n+See [similar discussion in the openHAB Forum](https://community.openhab.org/t/solved-wrong-local-time-how-to-change/90938) which deals with the same problem.\n+\n+### TroubleShooting\n+\n+BMW has a high range of Vehicles supported by BMWs ConnectedDrive.\n+In case of any issues with this Binding please help to resolve it! \n+Please perform the following Steps:\n+\n+* Can you login [into ConnectedDrive](https://www.bmw-connecteddrive.com/country-region-select/country-region-selection.html) with your Credentials? _Please note this isn't the BMW Customer Portal - it's the ConnectedDrive Portal_\n+* Is the Vehicle listed in your Account? _There's a one-to-one dependency from User to Vehicle_\n+\n+If the access to the Portal and listing of the Vehicle is checked some debug data is needed in order to identify the issue. \n+The [Example Sitemap](#Sitemap) contains the necessary items to generate Debug Data.\n+\n+#### My Vehicle isn't found automatically!\n+\n+The Vehicle isn't recognized or a predefined Vehicle doesn't show the right properties?\n+For this the [Discovery Fingerprint](#bridge-channels) is needed.\n+Short press on the Switch will force some logging entries which can be [normally found in the logs here](http://openhab:9001/) \n+\n+#### My Vehicle shows wrong data or data is missing!\n+\n+Now the [Vehicle Fingerprint](#troubleshooting) is needed.\n+Proceed like before, shortly press the Switch and the log contains the data.\n+\n+Personal Data is eliminated from the log entries so it should be possible to share them in public.\n+Data like\n+\n+* Dealer Properties\n+* Vehicle Identification Number (VIN)\n+* Location Latitude / Longitude \n+\n+are anonymized.\n+\n+After the corresponding Fingerprint is generated please [follow the instructions to raise an Issue](https://community.openhab.org/t/how-to-file-an-issue/68464) and attach the Fingerprint data!\n+Your feedback is highly appreciated!\n+\n+Here an example of Debug Fingerprint Data from a BEV_REX Vehicle\n+\n+```\n+2020-09-07 17:27:21.101 [WARN ] [rive.internal.handler.VehicleHandler] - ###### BMW ConnectedDrive Binding - Vehicle Troubleshoot Fingerprint Data - BEGIN ######\n+2020-09-07 17:27:21.105 [WARN ] [rive.internal.handler.VehicleHandler] - ### Discovery Result ###\n+2020-09-07 17:27:21.116 [WARN ] [rive.internal.handler.VehicleHandler] - {\"vehicles\":[{\"vin\":\"ANONYMOUS\",\"model\":\"i3 94 (+ REX)\",\"driveTrain\":\"BEV_REX\",\"brand\":\"BMW_I\",\"yearOfConstruction\":2017,\"bodytype\":\"I01\",\"color\":\"CAPPARISWEISS MIT AKZENT BMW I BLAU\",\"statisticsCommunityEnabled\":false,\"statisticsAvailable\":true,\"hasAlarmSystem\":true,\"dealer\":{\"name\":\"ANONYMOUS\",\"street\":\"ANONYMOUS\",\"postalCode\":\"ANONYMOUS\",\"city\":\"ANONYMOUS\",\"country\":\"ANONYMOUS\",\"phone\":\"ANONYMOUS\"},\"breakdownNumber\":\"ANONYMOUS\",\"supportedChargingModes\":[\"AC_LOW\",\"DC\"],\"chargingControl\":\"WEEKLY_PLANNER\",\"vehicleFinder\":\"ACTIVATED\",\"hornBlow\":\"ACTIVATED\",\"lightFlash\":\"ACTIVATED\",\"doorLock\":\"ACTIVATED\",\"doorUnlock\":\"ACTIVATED\",\"climateNow\":\"ACTIVATED\",\"sendPoi\":\"ACTIVATED\",\"remote360\":\"NOT_SUPPORTED\",\"climateControl\":\"NOT_SUPPORTED\",\"chargeNow\":\"NOT_SUPPORTED\",\"lastDestinations\":\"SUPPORTED\",\"carCloud\":\"NOT_SUPPORTED\",\"remoteSoftwareUpgrade\":\"NOT_SUPPORTED\",\"climateNowRES\":\"NOT_SUPPORTED\",\"climateControlRES\":\"NOT_SUPPORTED\",\"smartSolution\":\"NOT_SUPPORTED\",\"ipa\":\"NOT_SUPPORTED\"}]}\n+2020-09-07 17:27:21.121 [WARN ] [rive.internal.handler.VehicleHandler] - ### Vehicle Status ###\n+2020-09-07 17:27:21.125 [WARN ] [rive.internal.handler.VehicleHandler] - {\"vehicleStatus\":{\"mileage\":17708,\"remainingFuel\":4.0,\"remainingRangeElectric\":146.0,\"remainingRangeElectricMls\":90.0,\"remainingRangeFuel\":65.0,\"remainingRangeFuelMls\":40.0,\"maxRangeElectric\":203.0,\"maxRangeElectricMls\":126.0,\"maxFuel\":8.5,\"chargingLevelHv\":74.0,\"vin\":\"ANONYMOUS\",\"updateReason\":\"VEHICLE_SECURED\",\"updateTime\":\"2020-09-07T12:47:08+0000\",\"doorDriverFront\":\"CLOSED\",\"doorDriverRear\":\"CLOSED\",\"doorPassengerFront\":\"CLOSED\",\"doorPassengerRear\":\"CLOSED\",\"windowDriverFront\":\"CLOSED\",\"windowDriverRear\":\"CLOSED\",\"windowPassengerFront\":\"CLOSED\",\"windowPassengerRear\":\"CLOSED\",\"sunroof\":\"CLOSED\",\"trunk\":\"CLOSED\",\"rearWindow\":\"INVALID\",\"hood\":\"OPEN\",\"doorLockState\":\"SECURED\",\"parkingLight\":\"OFF\",\"positionLight\":\"ON\",\"connectionStatus\":\"DISCONNECTED\",\"chargingStatus\":\"INVALID\",\"lastChargingEndReason\":\"END_REQUESTED_BY_DRIVER\",\"lastChargingEndResult\":\"SUCCESS\",\"position\":{\"lat\":-1.0,\"lon\":-1.0,\"heading\":-1,\"status\":\"OK\"},\"internalDataTimeUTC\":\"2020-09-07T12:47:08\",\"singleImmediateCharging\":false,\"chargingConnectionType\":\"CONDUCTIVE\",\"chargingInductivePositioning\":\"NOT_POSITIONED\",\"vehicleCountry\":\"DE\",\"DCS_CCH_Activation\":\"NA\",\"DCS_CCH_Ongoing\":false,\"checkControlMessages\":[],\"cbsData\":[{\"cbsType\":\"BRAKE_FLUID\",\"cbsState\":\"OK\",\"cbsDueDate\":\"2021-11\",\"cbsDescription\":\"Next change due at the latest by the stated date.\",\"cbsRemainingMileage\":0},{\"cbsType\":\"VEHICLE_CHECK\",\"cbsState\":\"OK\",\"cbsDueDate\":\"2021-11\",\"cbsDescription\":\"Next visual inspection due when the stated distance has been covered or by the stated date.\",\"cbsRemainingMileage\":0},{\"cbsType\":\"OIL\",\"cbsState\":\"OK\",\"cbsDueDate\":\"2021-11\",\"cbsDescription\":\"Next change due when the stated distance has been covered or by the specified date.\",\"cbsRemainingMileage\":0},{\"cbsType\":\"VEHICLE_TUV\",\"cbsState\":\"OK\",\"cbsDueDate\":\"2021-11\",\"cbsDescription\":\"Next statutory vehicle inspection due by the stated date.\",\"cbsRemainingMileage\":0}]}}\n+2020-09-07 17:27:21.130 [WARN ] [rive.internal.handler.VehicleHandler] - ### Last Trip ###\n+2020-09-07 17:27:21.133 [WARN ] [rive.internal.handler.VehicleHandler] - {\"lastTrip\":{\"efficiencyValue\":0.8,\"totalDistance\":14,\"electricDistance\":14,\"avgElectricConsumption\":13.7,\"avgRecuperation\":3,\"drivingModeValue\":1,\"accelerationValue\":0.27,\"anticipationValue\":0.87,\"totalConsumptionValue\":0.98,\"auxiliaryConsumptionValue\":0.89,\"avgCombinedConsumption\":0,\"electricDistanceRatio\":100,\"savedFuel\":0,\"date\":\"2020-09-07T14:35:00+0000\",\"duration\":13}}\n+2020-09-07 17:27:21.135 [WARN ] [rive.internal.handler.VehicleHandler] - ### All Trips ###\n+2020-09-07 17:27:21.138 [WARN ] [rive.internal.handler.VehicleHandler] - {\"allTrips\":{\"avgElectricConsumption\":{\"communityLow\":11,\"communityAverage\":16.28,\"communityHigh\":22,\"userAverage\":16.46},\"avgRecuperation\":{\"communityLow\":0.47,\"communityAverage\":3.37,\"communityHigh\":11.51,\"userAverage\":4.53},\"chargecycleRange\":{\"communityAverage\":194.57,\"communityHigh\":270,\"userAverage\":57.28,\"userHigh\":185.48,\"userCurrentChargeCycle\":33},\"totalElectricDistance\":{\"communityLow\":58,\"communityAverage\":41269.29,\"communityHigh\":193882,\"userTotal\":17060.4},\"avgCombinedConsumption\":{\"communityLow\":0,\"communityAverage\":0.92,\"communityHigh\":4.44,\"userAverage\":0.64},\"savedCO2\":473.033,\"savedCO2greenEnergy\":2782.551,\"totalSavedFuel\":0,\"resetDate\":\"2020-09-07T12:00:04+0000\",\"batterySizeMax\":33200}}\n+2020-09-07 17:27:21.140 [WARN ] [rive.internal.handler.VehicleHandler] - ### Charge Profile ###\n+2020-09-07 17:27:21.142 [WARN ] [rive.internal.handler.VehicleHandler] - {\"weeklyPlanner\":{\"climatizationEnabled\":false,\"chargingMode\":\"DELAYED_CHARGING\",\"chargingPreferences\":\"CHARGING_WINDOW\",\"timer1\":{\"departureTime\":\"05:00\",\"timerEnabled\":true,\"weekdays\":[\"MONDAY\",\"TUESDAY\",\"WEDNESDAY\",\"THURSDAY\",\"FRIDAY\"]},\"timer2\":{\"departureTime\":\"12:00\",\"timerEnabled\":false,\"weekdays\":[\"SATURDAY\"]},\"timer3\":{\"departureTime\":\"00:00\",\"timerEnabled\":false,\"weekdays\":[]},\"overrideTimer\":{\"departureTime\":\"05:00\",\"timerEnabled\":false,\"weekdays\":[\"TUESDAY\"]},\"preferredChargingWindow\":{\"startTime\":\"11:00\",\"endTime\":\"17:00\"}}}\n+2020-09-07 17:27:21.144 [WARN ] [rive.internal.handler.VehicleHandler] - ### Charge Profile ###\n+2020-09-07 17:27:21.151 [WARN ] [rive.internal.handler.VehicleHandler] - {\"destinations\":[{\"lat\":0.0,\"lon\":0.0,\"country\":\"ANONYMOUS\",\"city\":\"ANONYMOUS\",\"street\":\"ANONYMOUS\",\"streetNumber\":\"ANONYMOUS\",\"type\":\"DESTINATION\",\"createdAt\":\"2020-08-16T12:52:58+0000\"},{\"lat\":0.0,\"lon\":0.0,\"country\":\"ANONYMOUS\",\"city\":\"ANONYMOUS\",\"street\":\"ANONYMOUS\",\"streetNumber\":\"ANONYMOUS\",\"type\":\"DESTINATION\",\"createdAt\":\"2020-08-12T17:03:35+0000\"},{\"lat\":0.0,\"lon\":0.0,\"country\":\"ANONYMOUS\",\"city\":\"ANONYMOUS\",\"street\":\"ANONYMOUS\",\"streetNumber\":\"ANONYMOUS\",\"type\":\"DESTINATION\",\"createdAt\":\"2020-08-03T08:15:20+0000\"},{\"lat\":0.0,\"lon\":0.0,\"country\":\"ANONYMOUS\",\"city\":\"ANONYMOUS\",\"street\":\"ANONYMOUS\",\"streetNumber\":\"ANONYMOUS\",\"type\":\"DESTINATION\",\"createdAt\":\"2020-07-31T13:09:15+0000\"},{\"lat\":0.0,\"lon\":0.0,\"country\":\"ANONYMOUS\",\"city\":\"ANONYMOUS\",\"street\":\"ANONYMOUS\",\"streetNumber\":\"ANONYMOUS\",\"type\":\"DESTINATION\",\"createdAt\":\"2020-07-25T11:20:18+0000\"},{\"lat\":0.0,\"lon\":0.0,\"country\":\"ANONYMOUS\",\"city\":\"ANONYMOUS\",\"street\":\"ANONYMOUS\",\"streetNumber\":\"ANONYMOUS\",\"type\":\"DESTINATION\",\"createdAt\":\"2020-07-18T11:22:37+0000\"},{\"lat\":0.0,\"lon\":0.0,\"country\":\"ANONYMOUS\",\"city\":\"ANONYMOUS\",\"street\":\"ANONYMOUS\",\"streetNumber\":\"ANONYMOUS\",\"type\":\"DESTINATION\",\"createdAt\":\"2020-02-08T11:06:52+0000\"},{\"lat\":0.0,\"lon\":0.0,\"country\":\"ANONYMOUS\",\"city\":\"ANONYMOUS\",\"street\":\"ANONYMOUS\",\"streetNumber\":\"ANONYMOUS\",\"type\":\"DESTINATION\",\"createdAt\":\"2020-02-02T14:07:54+0000\"},{\"lat\":0.0,\"lon\":0.0,\"country\":\"ANONYMOUS\",\"city\":\"ANONYMOUS\",\"street\":\"ANONYMOUS\",\"streetNumber\":\"ANONYMOUS\",\"type\":\"DESTINATION\",\"createdAt\":\"2020-02-02T13:24:36+0000\"}]}\n+2020-09-07 17:27:21.158 [WARN ] [rive.internal.handler.VehicleHandler] - ###### BMW ConnectedDrive Binding - Vehicle Troubleshoot Fingerprint Data - END ######\n+```\n+\n+## Full Example\n+\n+The example is based on a BMW i3 with Range Extender (REX). \n+Exchange the 3 configuration parameters in the Things section\n+\n+* YOUR_USERNAME - with your ConnectedDrive Login Username\n+* YOUR_PASSWORD - with your ConnectedDrive Password Credentials\n+* VEHICLE_VIN - the Vehicle Identification Number\n+\n+In addition search for all occurrences of *i3* and replace it with your Vehicle Identification like *x3* or *535d* and 're ready to go!", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e0bfe93e13df4a3c5de5f8819b94ebf795664904"}, "originalPosition": 461}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTA1MjcwNg==", "bodyText": "Corrected", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r549052706", "createdAt": "2020-12-27T01:53:46Z", "author": {"login": "weymann"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/README.md", "diffHunk": "@@ -0,0 +1,862 @@\n+# BMW ConnectedDrive Binding\n+\n+<img align=\"right\" src=\"./doc/bmw-connected.png\" width=\"150\" height=\"150\"/>\n+\n+The Binding provides a Connection between [BMWs ConnectedDrive Portal](https://www.bmw-connecteddrive.com/country-region-select/country-region-selection.html) and openHAB.\n+All Vehicles connected to an Account will be detected by the Discovery with the correct type \n+\n+* Conventional Fuel Vehicle\n+* Plugin-Hybrid Electrical Vehicle \n+* Battery Electric Vehicle with Range Extender\n+* Battery Electric Vehicle \n+\n+In addition Properties are attached with Information and Services provided by this Vehicle.\n+The provided data depends on \n+\n+1. the [Type](#Things) and \n+2. the Services mentioned in [Properties](#properties)\n+\n+Different Channel Groups are clustering all informations.\n+Check for each Group if it's supported for this Vehicle.\n+\n+Please note **this isn't a real-time Binding**. \n+If the Door is opened the state isn't transmitted and changed immediately. \n+This isn't a flaw in the Binding itself because the state in BMWs own ConnectedDrive App is also updated with some delay. \n+\n+## Supported Things\n+\n+### Bridge\n+\n+The Bridge establishes the Connection between BMW ConnectedDrive Portal and openHAB.\n+\n+| Name                       | Bridge Type ID | Description                                                |\n+|----------------------------|----------------|------------------------------------------------------------|\n+| BMW ConnectedDrive Account | account        | Access to BMW ConnectedDrive Portal for a specific user    |\n+\n+\n+### Things\n+\n+Four different Vehicle Types are provided. \n+They differ in the supported Channel Groups & Channels. \n+Conventional Fuel Vehicles have no _Charging Profile_, Electric Vehicles don't provide a _Fuel Range_. \n+For Hybrid Vehicles in addition to _Fuel and Electric Range_ the _Hybrid Range_ is shown.\n+ \n+| Name                                | Thing Type ID | Supported Channel Groups                                             |\n+|-------------------------------------|---------------|----------------------------------------------------------------------|\n+| BMW Electric Vehicle                | BEV           | status, range, location, service, check, charge, image, troubleshoot |\n+| BMW Electric Vehicle with REX       | BEV_REX       | status, range, location, service, check, charge, image, troubleshoot |\n+| BMW Plug-In-Hybrid Electric Vehicle | PHEV          | status, range, location, service, check, charge, image, troubleshoot |\n+| BMW Conventional Vehicle            | CONV          | status, range, location, service, check, image, troubleshoot         |\n+\n+ \n+#### Properties\n+\n+<img align=\"right\" src=\"./doc/properties.png\" width=\"500\" height=\"600\"/>\n+\n+For each Vehicle Properties are available. \n+Basically 3 Types of Information are registered as Properties\n+\n+* Informations regarding your Dealer with Address and Phone Number\n+* Which services are available / not available\n+* Vehicle Properties like Color, Model Type, Drive Train and Construction Year\n+\n+In the right picture  can see in *Services Activated* e.g. the *DoorLock* and *DoorUnlock* Services are mentioned. \n+This ensures [Channel Group _Remote Services_](#remote-services) is supporting Door lock and Door unlock.\n+\n+In  *Services Supported* the entry *LastDestination* is mentioned.\n+So it's valid to connect Channel Group [Last Destinations](#destinations) in order to display the last 3 Navigation Destinations.\n+\n+| Property Key       | Property Value      |  Supported Channel Groups    |\n+|--------------------|---------------------|------------------------------|\n+| Services Supported | Statistics          | last-trip, lifetime          |\n+| Services Supported | LastDestinations    | destinations                 |\n+| Services Activated | list of services    | remote                       |\n+\n+\n+## Discovery\n+\n+Auto Discovery is starting after creation of the Bridge towards BMW ConnectedDrive. \n+A list of your registered Vehicles is queried and all found Vehicles are added in Inbox.\n+Unique Identifier is the *Vehicle Identification Number* (VIN). \n+If a Thing is already declared in a  *.things configuration* Discovery won't highlight it again.\n+Properties will be attached to predefined Vehicles if the VIN is matching.\n+\n+## Configuration\n+\n+### Bridge\n+\n+| Parameter       | Type    | Description                                                             |           \n+|-----------------|---------|-------------------------------------------------------------------------|\n+| userName        | text    | BMW Connected Drive Username                  |\n+| password        | text    | BMW Connected Drive Password                  |\n+| region          | text    | Select Region in order to connect to the appropriate BMW Server.   |\n+\n+The region Configuration has 3 different possibilities\n+\n+* _NORTH_AMERICA_\n+* _CHINA_\n+* _ROW_ for Rest of World\n+\n+### Thing\n+\n+Same Configuration is needed for all Things\n+\n+| Parameter       | Type    | Description                           |           \n+|-----------------|---------|---------------------------------------|\n+| vin             | text    | Vehicle Identification Number (VIN)   |\n+| refreshInterval | integer | Refresh Interval in Minutes           |\n+| units           | text    | Unit Selection                        |\n+| imageSize       | integer | Image Size                            |\n+| imageViewport   | text    | Image Viewport                        |\n+\n+The units can be configured in 3 ways\n+\n+* _AUTODETECT_ selects Miles for US & UK, Kilometer otherwise\n+* _METRIC_ selects directly Kilometers\n+* _IMPERIAL_ selects directly Miles\n+\n+The imageVieport allows to show the Vehicle from different angels.\n+Possible values are \n+\n+* FRONT\n+* REAR\n+* SIDE\n+* DASHBOARD\n+* DRIVERDOOR\n+\n+## Channels\n+\n+There are many Channels available for each Vehicle. \n+For better overview they are clustered in different Channel Groups.\n+The Channel Groups are different for the Vehicle Types, on the build-in Sensors of the Vehicle and the activated Services.\n+\n+### Bridge Channels\n+\n+If the Vehicle isn't found in the Discovery force a log of Fingerprint Data which helps to analyze the problem.\n+Please check [TroubleShooting Section](#TroubleShooting) for further advice.\n+\n+| Channel Label         | Channel ID            | Type   | Description                                       |\n+|-----------------------|-----------------------|--------|---------------------------------------------------|\n+| Discovery Fingerprint | discovery-fingerprint | Switch | Forcing a log entry to analyze Discovery Problems |\n+\n+### Thing Channel Groups \n+\n+#### Vehicle Status\n+\n+Reflects Status of the Vehicle.\n+Available for all Vehicles, Read-only.\n+\n+| Channel Label             | Channel Group ID | Channel ID          | Type          | Description                                                                       |\n+|---------------------------|------------------|---------------------|---------------|-----------------------------------------------------------------------------------|\n+| Overall Door Status       | status           | doors               | String        | **Closed** if all closed otherwise **Open**. **Unknown** if no data is delivered  |\n+| Overall Window Status     | status           | windows             | String        | **Closed** if all closed otherwise **Open** or **Intermediate**. **Unknown** if no data is delivered   |\n+| Doors Locked              | status           | lock                | String        | Status if Doors are locked or unlocked                                            |\n+| Next Service Date         | status           | service-date        | DateTime      | Date of Upcoming Service                                                          |\n+| Mileage till Next Service | status           | service-mileage     | Number:Length | Mileage till Upcoming Service                                                     |\n+| Check Control             | status           | check-control       | String        | Indicator if CheckControl is **Active** or **Not Active**. **Unknown** if no data is delivered         |\n+| Charging Status           | status           | charge              | String        | Only available for PHEV, BEV_REX and BEV                                          |\n+| Last Status Timestamp     | status           | last-update         | DateTime      | Date and Time of last status update.                                              |\n+\n+See [further details for DateTime](#last-status-update-timestamp) in case of wrong timestamp values\n+\n+#### Services\n+\n+Group for all upcoming Services with Description, Service Date and / or Service Mileage\n+It's designed as [List Interface](#list-interface) so all upcoming Services can be checked.\n+\n+| Channel Label                  | Channel Group ID | Channel ID          | Type           | \n+|--------------------------------|------------------|---------------------|----------------|\n+| Service Name                   | service          | name                | String         |\n+| Service Date                   | service          | date                | Number         |\n+| Mileage till Service           | service          | mileage             | Number:Length  |\n+| Number of Scheduled Services   | service          | size                | String         |\n+| Current Selected Service Index | service          | index               | Number         |\n+| Select next Service            | service          | next                | Switch         |\n+\n+#### Check Control\n+\n+Group for all current active CheckControl Messages.\n+It's designed as [List Interface](#list-interface) to show all active Messages.\n+\n+| Channel Label                   | Channel Group ID | Channel ID          | Type           | \n+|---------------------------------|------------------|---------------------|----------------|\n+| CheckControl Description        | check            | name                | String         |\n+| CheckControl Mileage Occurrence | check            | mileage             | Number:Length  |\n+| Active CheckControl Messages    | check            | size                | String         |\n+| Selected CheckControl Message   | check            | index               | Number         |\n+| Next CheckControl Message       | check            | next                | Switch         |\n+\n+#### Doors Details\n+\n+Detailed Status of all Doors and Windows\n+Available for all Vehicles, Read-only. \n+\n+| Channel Label              | Channel Group ID | Channel ID              | Type          | \n+|----------------------------|------------------|-------------------------|---------------|\n+| Driver Door                | doors            | driver-front            | String        |\n+| Driver Door Rear           | doors            | driver-rear             | String        |\n+| Passenger Door             | doors            | passenger-front         | String        |\n+| Passenger Door Rear        | doors            | passenger-rear          | String        |\n+| Trunk                      | doors            | trunk                   | String        |\n+| Hood                       | doors            | hood                    | String        |\n+| Driver Door Window         | doors            | window-driver-front     | String        |\n+| Driver Door Rear Window    | doors            | window-driver-rear      | String        |\n+| Passenger Door Window      | doors            | window-passenger-front  | String        |\n+| Passenger Door Rear Window | doors            | window-passenger-rear   | String        |\n+| Rear Window                | doors            | window-rear             | String        |\n+| Sunroof                    | doors            | sunroof                 | String        |\n+\n+Following Strings will be delivered\n+\n+* UNKNOWN - no status data available\n+* INVALID - this item isn't applicable for this Vehicle\n+* CLOSED - the Door / Window is closed\n+* OPEN - the Door / Window is open\n+* INTERMEDIATE - Window in intermediate position, not applicable for Doors\n+\n+#### Range Data\n+\n+Based on Vehicle Type (Thing Type ID) some Channels are presented or not. \n+Conventional Fuel Vehicles don't provide *Electric Range* and Battery Electric Vehicles don't show *Range Fuel*.\n+Hybrid Vehicles have both and in addition *Hybrid Range*.\n+These are Read-only values.\n+\n+| Channel Label         | Channel Group ID | Channel ID            | Type                 | CONV | PHEV | BEV_REX | BEV |\n+|-----------------------|------------------|-----------------------|----------------------|------|------|---------|-----|\n+| Mileage               | range            | mileage               | Number:Length        |  X   |  X   |    X    |  X  |\n+| Fuel Range            | range            | range-fuel            | Number:Length        |  X   |  X   |    X    |     |\n+| Battery Range         | range            | range-electric        | Number:Length        |      |  X   |    X    |  X  | \n+| Hybrid Range          | range            | range-hybrid          | Number:Length        |      |  X   |    X    |     | \n+| Battery Charge Level  | range            | soc                   | Number:Dimensionless |      |  X   |    X    |  X  |\n+| Remaining Fuel        | range            | remaining-fuel        | Number:Volume        |  X   |  X   |    X    |     | \n+| Fuel Range Radius     | range            | range-radius-fuel     | Number:Length        |  X   |  X   |    X    |     | \n+| Electric Range Radius | range            | range-radius-electric | Number:Length        |      |  X   |    X    |  X  | \n+| Hybrid Range Radius   | range            | range-radius-hybrid   | Number:Length        |      |  X   |    X    |     | \n+\n+See Description [Range vs Range Radius](#range-vs-range-radius) to get more information\n+\n+#### Charge Profile\n+\n+Valid for Electric and Hybrid Vehicles\n+These are Read-only values.\n+\n+| Channel Label                      | Channel Group ID | Channel ID          | Type   | \n+|------------------------------------|------------------|---------------------|--------|\n+| Air Conditioning at Departure Time | charge           | profile-climate     | Switch | \n+| Charging Mode for Profile          | charge           | profile-mode        | String | \n+| Charging Window Start Time         | charge           | window-start        | String | \n+| Charging Window End Time           | charge           | window-end          | String | \n+| Timer 1: Departure Time            | charge           | timer1-departure    | String | \n+| Timer 1: Scheduled Days            | charge           | timer1-days         | String | \n+| Timer 1: Enabled                   | charge           | timer1-enabled      | Switch | \n+| Timer 2: Departure Time            | charge           | timer2-departure    | String | \n+| Timer 2: Scheduled Days            | charge           | timer2-days         | String | \n+| Timer 2: Enabled                   | charge           | timer2-enabled      | Switch | \n+| Timer 3: Departure Time            | charge           | timer3-departure    | String | \n+| Timer 3: Scheduled Days            | charge           | timer3-days         | String | \n+| Timer 3: Enabled                   | charge           | timer3-enabled      | Switch | \n+\n+\n+#### Location\n+\n+Available for all Vehicles.\n+These are Read-only values.\n+\n+| Channel Label  | Channel Group ID | Channel ID          | Type         | \n+|----------------|------------------|---------------------|--------------|\n+| Latitude       | location         | latitude            | Number       | \n+| Longitude      | location         | longitude           | Number       |\n+| Heading        | location         | heading             | Number:Angle | \n+\n+#### Last Trip\n+\n+Check [Vehicle Properties](#Properties) if *Statistics* is present in *Services Supported*\n+These are Read-only values.\n+\n+| Channel Label                           | Channel Group ID | Channel ID                   | Type          |\n+|-----------------------------------------|------------------|------------------------------|---------------|\n+| Last Trip Date                          | last-trip        | date                         | DateTime      |\n+| Last Trip Duration                      | last-trip        | duration                     | Number:Time   |\n+| Average Power Consumption per 100 km    | last-trip        | average-consumption          | Number:Power  |\n+| Average Combined Consumption per 100 km | last-trip        | average-combined-consumption | Number:Volume |\n+| Average Power Recuperation per 100 km   | last-trip        | average-recuperation         | Number:Power  |\n+| Last Trip Distance                      | last-trip        | distance                     | Number:Length |\n+| Distance since Last Charge              | last-trip        | distance-since-charging      | Number:Length |\n+\n+\n+#### Lifetime Statistics\n+\n+Check [Vehicle Properties](#Properties) if *Statistics* is present in *Services Supported*\n+These are Read-only values.\n+\n+| Channel Label                           | Channel Group ID | Channel ID                   | Type          | \n+|-----------------------------------------|------------------|------------------------------|---------------|\n+| Average Power Consumption per 100 km    | lifetime         | average-consumption          | Number:Power  |\n+| Average Power Recuperation per 100 km   | lifetime         | average-recuperation         | Number:Power  |\n+| Cumulated Electric Driven Distance      | lifetime         | cumulated-driven-distance    | Number:Length |\n+| Average Combined Consumption per 100 km | lifetime         | average-combined-consumption | Number:Volume |\n+| Longest Distance with one Charge        | lifetime         | single-longest-distance      | Number:Length |\n+\n+\n+#### Remote Services\n+\n+Check [Vehicle Properties](#Properties) *Services Activated* which Remote Services are available\n+Only one Remote Service can be executed each Time.\n+Parallel execution isn't supported.\n+The *Service Execution State* Channel is reporting the state.\n+State *Executed* is the final State when Execution is finished.\n+\n+| Channel Label           | Channel Group ID | Channel ID          | Type    | \n+|-------------------------|------------------|---------------------|---------|\n+| Activate Flash Lights   | remote           | light               | Switch  |\n+| Find Vehicle            | remote           | finder              | Switch  |\n+| Lock Doors              | remote           | lock                | Switch  |\n+| Unlock Doors            | remote           | unlock              | Switch  |\n+| Horn Blow               | remote           | horn                | Switch  |\n+| Active Air Conditioning | remote           | climate             | Switch  |\n+| Service Execution State | remote           | state               | STring  |\n+\n+#### Destinations\n+\n+Check [Vehicle Properties](#Properties) if *LastDestinations* is present in *Services Supported*\n+It's designed as [List Interface](#list-interface) in order to have access to all stored Destinations.\n+\n+| Channel Label                    | Channel Group ID | Channel ID          | Type    | \n+|----------------------------------|------------------|---------------------|---------|\n+| Destination Name                 | destination      | name                | String  |\n+| Destination Latitude             | destination      | latitude            | Number  |\n+| Destination Longitude            | destination      | longitude           | Number  |\n+| Number of Available Destinations | destination      | size                | String  |\n+| Index of Selected Destination    | destination      | index               | Number  |\n+| Skip to Next Destination         | destination      | next                | Switch  |\n+\n+\n+#### Image\n+\n+Available for all Vehicles.\n+Picture can be modified regarding *Viewport* and *Size*.\n+See [Things Section](#thing) for Viewport possibilities and [Status Image](#status-image) for possible Use Cases.\n+\n+| Channel Label                 | Channel Group ID | Channel ID          | Type   | \n+|-------------------------------|------------------|---------------------|--------|\n+| Rendered Image of the Vehicle | image            | png                 | Image  |\n+| Image Viewport                | image            | view                | String |\n+| Image Picture Size            | image            | size                | Number |\n+\n+\n+#### Troubleshooting\n+\n+Available for all Vehicles!\n+Switch will log a *Vehicle Data Fingerprint* into the openHAB log.\n+Please check [TroubleShooting Section](#TroubleShooting) for further advice.\n+\n+| Channel Label                       | Channel Group ID | Channel ID          | Type   | Description                                       |\n+|-------------------------------------|------------------|---------------------|--------|---------------------------------------------------|\n+| Log Vehicle Fingerprint             | troubleshoot     | vehicle-fingerprint | Switch | Forces log entries in openHAB logger in order to raise issues |\n+\n+## Further Descriptions\n+\n+### List Interface\n+\n+Currently there are 3 occurrences of dynamic data delivered as Lists\n+\n+* Upcoming Services\n+* Check Control Messages\n+* Last Destinations\n+\n+In order to provide all data the lists are organized the following way based on the Service Group example\n+\n+* **size** is the total length of the list. Read-only.\n+* **index** is the current selected index starting with 0 => list with size 10, valid index is between 0 - 9. If the index is set to _out of bounds_ it's set to first element. Read-write.\n+* **next** declares a switch for scrolling forward through the list in an endless way. Reaching end of list will start again from 0. Read-write.\n+* **name**, **mileage** and **date** declares the list item. It will change when setting new index or perform next. Read-only.\n+\n+### Range vs Range Radius\n+\n+<img align=\"right\" src=\"./doc/range-radius.png\" width=\"400\" height=\"350\"/>\n+\n+ will observe differences in the Vehicle Range and Range Radius values. \n+While Range is indicating the possible distance to be driven on roads the range radius indicates the reachable range on the Map.\n+\n+The right picture shows the distance between Kassel and Frankfurt in Germany. \n+While the Air-line Distance is ~145 Kilometer the Route Distance is ~192 Kilometer.\n+So Range value is the normal remaining range.\n+See the Section [OpenStreetMap](#openstreetMap-widget) how the Range Radius is used to indicate the reachable Range on Map.\n+Please note this is just an indicator and the effective range, especially for Electric Vehicles, \n+depends on many factors like driving style and electric consumers. \n+ \n+### Last Status Update Timestamp\n+\n+A timestamp is showing the last Vehicle Status update. If this isn't shown correctly please check the date settings.\n+In case of Raspberry Pi execute *raspi-config*, select *Localization Options*, the *Change Time Zone*\n+Select your *Geographical Area* and afterwards the correct City.\n+One restart of openHAB service with *systemctl restart openhab2* is necessary in order to see the corrected Time Settings.\n+ \n+Correct TimeZone is crucial for handling all Time information in openHAB and it's discussed many times in the Forum.\n+See [similar discussion in the openHAB Forum](https://community.openhab.org/t/solved-wrong-local-time-how-to-change/90938) which deals with the same problem.\n+\n+### TroubleShooting\n+\n+BMW has a high range of Vehicles supported by BMWs ConnectedDrive.\n+In case of any issues with this Binding please help to resolve it! \n+Please perform the following Steps:\n+\n+* Can you login [into ConnectedDrive](https://www.bmw-connecteddrive.com/country-region-select/country-region-selection.html) with your Credentials? _Please note this isn't the BMW Customer Portal - it's the ConnectedDrive Portal_\n+* Is the Vehicle listed in your Account? _There's a one-to-one dependency from User to Vehicle_\n+\n+If the access to the Portal and listing of the Vehicle is checked some debug data is needed in order to identify the issue. \n+The [Example Sitemap](#Sitemap) contains the necessary items to generate Debug Data.\n+\n+#### My Vehicle isn't found automatically!\n+\n+The Vehicle isn't recognized or a predefined Vehicle doesn't show the right properties?\n+For this the [Discovery Fingerprint](#bridge-channels) is needed.\n+Short press on the Switch will force some logging entries which can be [normally found in the logs here](http://openhab:9001/) \n+\n+#### My Vehicle shows wrong data or data is missing!\n+\n+Now the [Vehicle Fingerprint](#troubleshooting) is needed.\n+Proceed like before, shortly press the Switch and the log contains the data.\n+\n+Personal Data is eliminated from the log entries so it should be possible to share them in public.\n+Data like\n+\n+* Dealer Properties\n+* Vehicle Identification Number (VIN)\n+* Location Latitude / Longitude \n+\n+are anonymized.\n+\n+After the corresponding Fingerprint is generated please [follow the instructions to raise an Issue](https://community.openhab.org/t/how-to-file-an-issue/68464) and attach the Fingerprint data!\n+Your feedback is highly appreciated!\n+\n+Here an example of Debug Fingerprint Data from a BEV_REX Vehicle\n+\n+```\n+2020-09-07 17:27:21.101 [WARN ] [rive.internal.handler.VehicleHandler] - ###### BMW ConnectedDrive Binding - Vehicle Troubleshoot Fingerprint Data - BEGIN ######\n+2020-09-07 17:27:21.105 [WARN ] [rive.internal.handler.VehicleHandler] - ### Discovery Result ###\n+2020-09-07 17:27:21.116 [WARN ] [rive.internal.handler.VehicleHandler] - {\"vehicles\":[{\"vin\":\"ANONYMOUS\",\"model\":\"i3 94 (+ REX)\",\"driveTrain\":\"BEV_REX\",\"brand\":\"BMW_I\",\"yearOfConstruction\":2017,\"bodytype\":\"I01\",\"color\":\"CAPPARISWEISS MIT AKZENT BMW I BLAU\",\"statisticsCommunityEnabled\":false,\"statisticsAvailable\":true,\"hasAlarmSystem\":true,\"dealer\":{\"name\":\"ANONYMOUS\",\"street\":\"ANONYMOUS\",\"postalCode\":\"ANONYMOUS\",\"city\":\"ANONYMOUS\",\"country\":\"ANONYMOUS\",\"phone\":\"ANONYMOUS\"},\"breakdownNumber\":\"ANONYMOUS\",\"supportedChargingModes\":[\"AC_LOW\",\"DC\"],\"chargingControl\":\"WEEKLY_PLANNER\",\"vehicleFinder\":\"ACTIVATED\",\"hornBlow\":\"ACTIVATED\",\"lightFlash\":\"ACTIVATED\",\"doorLock\":\"ACTIVATED\",\"doorUnlock\":\"ACTIVATED\",\"climateNow\":\"ACTIVATED\",\"sendPoi\":\"ACTIVATED\",\"remote360\":\"NOT_SUPPORTED\",\"climateControl\":\"NOT_SUPPORTED\",\"chargeNow\":\"NOT_SUPPORTED\",\"lastDestinations\":\"SUPPORTED\",\"carCloud\":\"NOT_SUPPORTED\",\"remoteSoftwareUpgrade\":\"NOT_SUPPORTED\",\"climateNowRES\":\"NOT_SUPPORTED\",\"climateControlRES\":\"NOT_SUPPORTED\",\"smartSolution\":\"NOT_SUPPORTED\",\"ipa\":\"NOT_SUPPORTED\"}]}\n+2020-09-07 17:27:21.121 [WARN ] [rive.internal.handler.VehicleHandler] - ### Vehicle Status ###\n+2020-09-07 17:27:21.125 [WARN ] [rive.internal.handler.VehicleHandler] - {\"vehicleStatus\":{\"mileage\":17708,\"remainingFuel\":4.0,\"remainingRangeElectric\":146.0,\"remainingRangeElectricMls\":90.0,\"remainingRangeFuel\":65.0,\"remainingRangeFuelMls\":40.0,\"maxRangeElectric\":203.0,\"maxRangeElectricMls\":126.0,\"maxFuel\":8.5,\"chargingLevelHv\":74.0,\"vin\":\"ANONYMOUS\",\"updateReason\":\"VEHICLE_SECURED\",\"updateTime\":\"2020-09-07T12:47:08+0000\",\"doorDriverFront\":\"CLOSED\",\"doorDriverRear\":\"CLOSED\",\"doorPassengerFront\":\"CLOSED\",\"doorPassengerRear\":\"CLOSED\",\"windowDriverFront\":\"CLOSED\",\"windowDriverRear\":\"CLOSED\",\"windowPassengerFront\":\"CLOSED\",\"windowPassengerRear\":\"CLOSED\",\"sunroof\":\"CLOSED\",\"trunk\":\"CLOSED\",\"rearWindow\":\"INVALID\",\"hood\":\"OPEN\",\"doorLockState\":\"SECURED\",\"parkingLight\":\"OFF\",\"positionLight\":\"ON\",\"connectionStatus\":\"DISCONNECTED\",\"chargingStatus\":\"INVALID\",\"lastChargingEndReason\":\"END_REQUESTED_BY_DRIVER\",\"lastChargingEndResult\":\"SUCCESS\",\"position\":{\"lat\":-1.0,\"lon\":-1.0,\"heading\":-1,\"status\":\"OK\"},\"internalDataTimeUTC\":\"2020-09-07T12:47:08\",\"singleImmediateCharging\":false,\"chargingConnectionType\":\"CONDUCTIVE\",\"chargingInductivePositioning\":\"NOT_POSITIONED\",\"vehicleCountry\":\"DE\",\"DCS_CCH_Activation\":\"NA\",\"DCS_CCH_Ongoing\":false,\"checkControlMessages\":[],\"cbsData\":[{\"cbsType\":\"BRAKE_FLUID\",\"cbsState\":\"OK\",\"cbsDueDate\":\"2021-11\",\"cbsDescription\":\"Next change due at the latest by the stated date.\",\"cbsRemainingMileage\":0},{\"cbsType\":\"VEHICLE_CHECK\",\"cbsState\":\"OK\",\"cbsDueDate\":\"2021-11\",\"cbsDescription\":\"Next visual inspection due when the stated distance has been covered or by the stated date.\",\"cbsRemainingMileage\":0},{\"cbsType\":\"OIL\",\"cbsState\":\"OK\",\"cbsDueDate\":\"2021-11\",\"cbsDescription\":\"Next change due when the stated distance has been covered or by the specified date.\",\"cbsRemainingMileage\":0},{\"cbsType\":\"VEHICLE_TUV\",\"cbsState\":\"OK\",\"cbsDueDate\":\"2021-11\",\"cbsDescription\":\"Next statutory vehicle inspection due by the stated date.\",\"cbsRemainingMileage\":0}]}}\n+2020-09-07 17:27:21.130 [WARN ] [rive.internal.handler.VehicleHandler] - ### Last Trip ###\n+2020-09-07 17:27:21.133 [WARN ] [rive.internal.handler.VehicleHandler] - {\"lastTrip\":{\"efficiencyValue\":0.8,\"totalDistance\":14,\"electricDistance\":14,\"avgElectricConsumption\":13.7,\"avgRecuperation\":3,\"drivingModeValue\":1,\"accelerationValue\":0.27,\"anticipationValue\":0.87,\"totalConsumptionValue\":0.98,\"auxiliaryConsumptionValue\":0.89,\"avgCombinedConsumption\":0,\"electricDistanceRatio\":100,\"savedFuel\":0,\"date\":\"2020-09-07T14:35:00+0000\",\"duration\":13}}\n+2020-09-07 17:27:21.135 [WARN ] [rive.internal.handler.VehicleHandler] - ### All Trips ###\n+2020-09-07 17:27:21.138 [WARN ] [rive.internal.handler.VehicleHandler] - {\"allTrips\":{\"avgElectricConsumption\":{\"communityLow\":11,\"communityAverage\":16.28,\"communityHigh\":22,\"userAverage\":16.46},\"avgRecuperation\":{\"communityLow\":0.47,\"communityAverage\":3.37,\"communityHigh\":11.51,\"userAverage\":4.53},\"chargecycleRange\":{\"communityAverage\":194.57,\"communityHigh\":270,\"userAverage\":57.28,\"userHigh\":185.48,\"userCurrentChargeCycle\":33},\"totalElectricDistance\":{\"communityLow\":58,\"communityAverage\":41269.29,\"communityHigh\":193882,\"userTotal\":17060.4},\"avgCombinedConsumption\":{\"communityLow\":0,\"communityAverage\":0.92,\"communityHigh\":4.44,\"userAverage\":0.64},\"savedCO2\":473.033,\"savedCO2greenEnergy\":2782.551,\"totalSavedFuel\":0,\"resetDate\":\"2020-09-07T12:00:04+0000\",\"batterySizeMax\":33200}}\n+2020-09-07 17:27:21.140 [WARN ] [rive.internal.handler.VehicleHandler] - ### Charge Profile ###\n+2020-09-07 17:27:21.142 [WARN ] [rive.internal.handler.VehicleHandler] - {\"weeklyPlanner\":{\"climatizationEnabled\":false,\"chargingMode\":\"DELAYED_CHARGING\",\"chargingPreferences\":\"CHARGING_WINDOW\",\"timer1\":{\"departureTime\":\"05:00\",\"timerEnabled\":true,\"weekdays\":[\"MONDAY\",\"TUESDAY\",\"WEDNESDAY\",\"THURSDAY\",\"FRIDAY\"]},\"timer2\":{\"departureTime\":\"12:00\",\"timerEnabled\":false,\"weekdays\":[\"SATURDAY\"]},\"timer3\":{\"departureTime\":\"00:00\",\"timerEnabled\":false,\"weekdays\":[]},\"overrideTimer\":{\"departureTime\":\"05:00\",\"timerEnabled\":false,\"weekdays\":[\"TUESDAY\"]},\"preferredChargingWindow\":{\"startTime\":\"11:00\",\"endTime\":\"17:00\"}}}\n+2020-09-07 17:27:21.144 [WARN ] [rive.internal.handler.VehicleHandler] - ### Charge Profile ###\n+2020-09-07 17:27:21.151 [WARN ] [rive.internal.handler.VehicleHandler] - {\"destinations\":[{\"lat\":0.0,\"lon\":0.0,\"country\":\"ANONYMOUS\",\"city\":\"ANONYMOUS\",\"street\":\"ANONYMOUS\",\"streetNumber\":\"ANONYMOUS\",\"type\":\"DESTINATION\",\"createdAt\":\"2020-08-16T12:52:58+0000\"},{\"lat\":0.0,\"lon\":0.0,\"country\":\"ANONYMOUS\",\"city\":\"ANONYMOUS\",\"street\":\"ANONYMOUS\",\"streetNumber\":\"ANONYMOUS\",\"type\":\"DESTINATION\",\"createdAt\":\"2020-08-12T17:03:35+0000\"},{\"lat\":0.0,\"lon\":0.0,\"country\":\"ANONYMOUS\",\"city\":\"ANONYMOUS\",\"street\":\"ANONYMOUS\",\"streetNumber\":\"ANONYMOUS\",\"type\":\"DESTINATION\",\"createdAt\":\"2020-08-03T08:15:20+0000\"},{\"lat\":0.0,\"lon\":0.0,\"country\":\"ANONYMOUS\",\"city\":\"ANONYMOUS\",\"street\":\"ANONYMOUS\",\"streetNumber\":\"ANONYMOUS\",\"type\":\"DESTINATION\",\"createdAt\":\"2020-07-31T13:09:15+0000\"},{\"lat\":0.0,\"lon\":0.0,\"country\":\"ANONYMOUS\",\"city\":\"ANONYMOUS\",\"street\":\"ANONYMOUS\",\"streetNumber\":\"ANONYMOUS\",\"type\":\"DESTINATION\",\"createdAt\":\"2020-07-25T11:20:18+0000\"},{\"lat\":0.0,\"lon\":0.0,\"country\":\"ANONYMOUS\",\"city\":\"ANONYMOUS\",\"street\":\"ANONYMOUS\",\"streetNumber\":\"ANONYMOUS\",\"type\":\"DESTINATION\",\"createdAt\":\"2020-07-18T11:22:37+0000\"},{\"lat\":0.0,\"lon\":0.0,\"country\":\"ANONYMOUS\",\"city\":\"ANONYMOUS\",\"street\":\"ANONYMOUS\",\"streetNumber\":\"ANONYMOUS\",\"type\":\"DESTINATION\",\"createdAt\":\"2020-02-08T11:06:52+0000\"},{\"lat\":0.0,\"lon\":0.0,\"country\":\"ANONYMOUS\",\"city\":\"ANONYMOUS\",\"street\":\"ANONYMOUS\",\"streetNumber\":\"ANONYMOUS\",\"type\":\"DESTINATION\",\"createdAt\":\"2020-02-02T14:07:54+0000\"},{\"lat\":0.0,\"lon\":0.0,\"country\":\"ANONYMOUS\",\"city\":\"ANONYMOUS\",\"street\":\"ANONYMOUS\",\"streetNumber\":\"ANONYMOUS\",\"type\":\"DESTINATION\",\"createdAt\":\"2020-02-02T13:24:36+0000\"}]}\n+2020-09-07 17:27:21.158 [WARN ] [rive.internal.handler.VehicleHandler] - ###### BMW ConnectedDrive Binding - Vehicle Troubleshoot Fingerprint Data - END ######\n+```\n+\n+## Full Example\n+\n+The example is based on a BMW i3 with Range Extender (REX). \n+Exchange the 3 configuration parameters in the Things section\n+\n+* YOUR_USERNAME - with your ConnectedDrive Login Username\n+* YOUR_PASSWORD - with your ConnectedDrive Password Credentials\n+* VEHICLE_VIN - the Vehicle Identification Number\n+\n+In addition search for all occurrences of *i3* and replace it with your Vehicle Identification like *x3* or *535d* and 're ready to go!", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTEzODgxOA=="}, "originalCommit": {"oid": "e0bfe93e13df4a3c5de5f8819b94ebf795664904"}, "originalPosition": 461}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMxMTMyMDY1OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/ConnectedDriveConstants.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMVQwNjo0MzoyNVrOH3n8UQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yM1QyMTo0MDozNVrOH4gceA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODA4ODE0NQ==", "bodyText": "Please use Set.of instead. Apply elsewhere  where applicable.", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r528088145", "createdAt": "2020-11-21T06:43:25Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/ConnectedDriveConstants.java", "diffHunk": "@@ -0,0 +1,210 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bmwconnecteddrive.internal;\n+\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.core.thing.ThingTypeUID;\n+\n+/**\n+ * The {@link ConnectedDriveConstants} class defines common constants, which are\n+ * used across the whole binding.\n+ *\n+ * @author Bernd Weymann - Initial contribution\n+ */\n+@SuppressWarnings(\"serial\")\n+@NonNullByDefault\n+public class ConnectedDriveConstants {\n+\n+    private static final String BINDING_ID = \"bmwconnecteddrive\";\n+\n+    // Units\n+    public static final String UNITS_AUTODETECT = \"AUTODETECT\";\n+    public static final String UNITS_IMPERIAL = \"IMPERIAL\";\n+    public static final String UNITS_METRIC = \"METRIC\";\n+\n+    public static final int DEFAULT_IMAGE_SIZE = 1024;\n+    public static final int DEFAULT_REFRESH_INTERVAL = 5;\n+    public static final String DEFAULT_IMAGE_VIEWPORT = \"FRONT\";\n+\n+    // See constants from bimmer-connected\n+    // https://github.com/bimmerconnected/bimmer_connected/blob/master/bimmer_connected/vehicle.py\n+    public enum VehicleType {\n+        CONVENTIONAL(\"CONV\"),\n+        PLUGIN_HYBRID(\"PHEV\"),\n+        ELECTRIC_REX(\"BEV_REX\"),\n+        ELECTRIC(\"BEV\");\n+\n+        private final String type;\n+\n+        VehicleType(String s) {\n+            type = s;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return type;\n+        }\n+    }\n+\n+    public static final Set<String> FUEL_VEHICLES = new HashSet<String>() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e0bfe93e13df4a3c5de5f8819b94ebf795664904"}, "originalPosition": 62}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTAxMzg4MA==", "bodyText": "Corrected.", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r529013880", "createdAt": "2020-11-23T21:40:35Z", "author": {"login": "weymann"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/ConnectedDriveConstants.java", "diffHunk": "@@ -0,0 +1,210 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bmwconnecteddrive.internal;\n+\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.core.thing.ThingTypeUID;\n+\n+/**\n+ * The {@link ConnectedDriveConstants} class defines common constants, which are\n+ * used across the whole binding.\n+ *\n+ * @author Bernd Weymann - Initial contribution\n+ */\n+@SuppressWarnings(\"serial\")\n+@NonNullByDefault\n+public class ConnectedDriveConstants {\n+\n+    private static final String BINDING_ID = \"bmwconnecteddrive\";\n+\n+    // Units\n+    public static final String UNITS_AUTODETECT = \"AUTODETECT\";\n+    public static final String UNITS_IMPERIAL = \"IMPERIAL\";\n+    public static final String UNITS_METRIC = \"METRIC\";\n+\n+    public static final int DEFAULT_IMAGE_SIZE = 1024;\n+    public static final int DEFAULT_REFRESH_INTERVAL = 5;\n+    public static final String DEFAULT_IMAGE_VIEWPORT = \"FRONT\";\n+\n+    // See constants from bimmer-connected\n+    // https://github.com/bimmerconnected/bimmer_connected/blob/master/bimmer_connected/vehicle.py\n+    public enum VehicleType {\n+        CONVENTIONAL(\"CONV\"),\n+        PLUGIN_HYBRID(\"PHEV\"),\n+        ELECTRIC_REX(\"BEV_REX\"),\n+        ELECTRIC(\"BEV\");\n+\n+        private final String type;\n+\n+        VehicleType(String s) {\n+            type = s;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return type;\n+        }\n+    }\n+\n+    public static final Set<String> FUEL_VEHICLES = new HashSet<String>() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODA4ODE0NQ=="}, "originalCommit": {"oid": "e0bfe93e13df4a3c5de5f8819b94ebf795664904"}, "originalPosition": 62}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMxMTMyOTc5OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/discovery/VehicleDiscovery.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMVQwNjo0NTo0MVrOH3oCuQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yM1QyMTo0NDo0OFrOH4gkYg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODA4OTc4NQ==", "bodyText": "properties shouldn't have spaces in their names.", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r528089785", "createdAt": "2020-11-21T06:45:41Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/discovery/VehicleDiscovery.java", "diffHunk": "@@ -0,0 +1,178 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bmwconnecteddrive.internal.discovery;\n+\n+import static org.openhab.binding.bmwconnecteddrive.internal.ConnectedDriveConstants.SUPPORTED_THING_SET;\n+\n+import java.lang.reflect.Field;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.binding.bmwconnecteddrive.internal.ConnectedDriveConstants;\n+import org.openhab.binding.bmwconnecteddrive.internal.ConnectedDriveHandlerFactory;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.discovery.Vehicle;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.discovery.VehiclesContainer;\n+import org.openhab.binding.bmwconnecteddrive.internal.handler.ConnectedDriveBridgeHandler;\n+import org.openhab.binding.bmwconnecteddrive.internal.handler.VehicleHandler;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Constants;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Converter;\n+import org.openhab.core.config.core.Configuration;\n+import org.openhab.core.config.discovery.AbstractDiscoveryService;\n+import org.openhab.core.config.discovery.DiscoveryResultBuilder;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingUID;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link VehicleDiscovery} requests data from ConnectedDrive and is identifying the Vehicles after response\n+ *\n+ * @author Bernd Weymann - Initial contribution\n+ */\n+@NonNullByDefault\n+// @Component(service = DiscoveryService.class, immediate = true, configurationPid = \"discovery.bmwconnecteddrive\")\n+public class VehicleDiscovery extends AbstractDiscoveryService {\n+    private final Logger logger = LoggerFactory.getLogger(VehicleDiscovery.class);\n+    private static final int DISCOVERY_TIMEOUT = 10;\n+\n+    private ConnectedDriveBridgeHandler bridgeHandler;\n+\n+    public VehicleDiscovery(ConnectedDriveBridgeHandler bh) {\n+        super(SUPPORTED_THING_SET, DISCOVERY_TIMEOUT, false);\n+        bridgeHandler = bh;\n+    }\n+\n+    @Override\n+    protected void startScan() {\n+        bridgeHandler.requestVehicles();\n+    }\n+\n+    public void onResponse(VehiclesContainer container) {\n+        List<Vehicle> vehicles = container.vehicles;\n+        vehicles.forEach(vehicle -> {\n+            ThingUID bridgeUID = bridgeHandler.getThing().getUID();\n+            // the DriveTrain field in the delivered json is defining the Vehicle Type\n+            String vehicleType = vehicle.driveTrain;\n+            SUPPORTED_THING_SET.forEach(entry -> {\n+                if (entry.getId().equals(vehicleType)) {\n+                    ThingUID uid = new ThingUID(entry, vehicle.vin, bridgeUID.getId());\n+                    Map<String, String> properties = new HashMap<>();\n+                    // Dealer\n+                    if (vehicle.dealer != null) {\n+                        properties.put(\"Dealer\", vehicle.dealer.name);\n+                        properties.put(\"Dealer Address\", vehicle.dealer.street + \" \" + vehicle.dealer.country + \" \"\n+                                + vehicle.dealer.postalCode + \" \" + vehicle.dealer.city);\n+                        properties.put(\"Dealer Phone\", vehicle.dealer.phone);\n+                    }\n+\n+                    // Services & Support\n+                    properties.put(\"Services Activated\", getObject(vehicle, Constants.ACTIVATED));\n+                    String servicesSupported = getObject(vehicle, Constants.SUPPORTED);\n+                    String servicesNotSupported = getObject(vehicle, Constants.NOT_SUPPORTED);\n+                    if (vehicle.statisticsAvailable) {\n+                        servicesSupported += Constants.STATISTICS;\n+                    } else {\n+                        servicesNotSupported += Constants.STATISTICS;\n+                    }\n+                    properties.put(Constants.SERVICES_SUPPORTED, servicesSupported);\n+                    properties.put(\"Services Not Supported\", servicesNotSupported);\n+                    properties.put(\"Support Breakdown Number\", vehicle.breakdownNumber);\n+\n+                    // Vehicle Properties\n+                    if (vehicle.supportedChargingModes != null) {\n+                        StringBuffer chargingModes = new StringBuffer();\n+                        vehicle.supportedChargingModes.forEach(e -> {\n+                            chargingModes.append(e).append(Constants.SPACE);\n+                        });\n+                        properties.put(\"Vehicle Charge Modes\", chargingModes.toString());\n+                    }\n+                    if (vehicle.hasAlarmSystem) {\n+                        properties.put(\"Vehicle Alarm System\", \"Available\");\n+                    } else {\n+                        properties.put(\"Vehicle Alarm System\", \"Not Available\");\n+                    }\n+                    properties.put(\"Vehicle Brand\", vehicle.brand);\n+                    properties.put(\"Vehicle Bodytype\", vehicle.bodytype);\n+                    properties.put(\"Vehicle Color\", vehicle.color);\n+                    properties.put(\"Vehicle Construction Year\", Short.toString(vehicle.yearOfConstruction));\n+                    properties.put(\"Vehicle Drive Train\", vehicle.driveTrain);\n+                    properties.put(\"Vehicle Model\", vehicle.model);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e0bfe93e13df4a3c5de5f8819b94ebf795664904"}, "originalPosition": 112}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTAxNTkwNg==", "bodyText": "Removed the spaces so properties are CamelCase", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r529015906", "createdAt": "2020-11-23T21:44:48Z", "author": {"login": "weymann"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/discovery/VehicleDiscovery.java", "diffHunk": "@@ -0,0 +1,178 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bmwconnecteddrive.internal.discovery;\n+\n+import static org.openhab.binding.bmwconnecteddrive.internal.ConnectedDriveConstants.SUPPORTED_THING_SET;\n+\n+import java.lang.reflect.Field;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.binding.bmwconnecteddrive.internal.ConnectedDriveConstants;\n+import org.openhab.binding.bmwconnecteddrive.internal.ConnectedDriveHandlerFactory;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.discovery.Vehicle;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.discovery.VehiclesContainer;\n+import org.openhab.binding.bmwconnecteddrive.internal.handler.ConnectedDriveBridgeHandler;\n+import org.openhab.binding.bmwconnecteddrive.internal.handler.VehicleHandler;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Constants;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Converter;\n+import org.openhab.core.config.core.Configuration;\n+import org.openhab.core.config.discovery.AbstractDiscoveryService;\n+import org.openhab.core.config.discovery.DiscoveryResultBuilder;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingUID;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link VehicleDiscovery} requests data from ConnectedDrive and is identifying the Vehicles after response\n+ *\n+ * @author Bernd Weymann - Initial contribution\n+ */\n+@NonNullByDefault\n+// @Component(service = DiscoveryService.class, immediate = true, configurationPid = \"discovery.bmwconnecteddrive\")\n+public class VehicleDiscovery extends AbstractDiscoveryService {\n+    private final Logger logger = LoggerFactory.getLogger(VehicleDiscovery.class);\n+    private static final int DISCOVERY_TIMEOUT = 10;\n+\n+    private ConnectedDriveBridgeHandler bridgeHandler;\n+\n+    public VehicleDiscovery(ConnectedDriveBridgeHandler bh) {\n+        super(SUPPORTED_THING_SET, DISCOVERY_TIMEOUT, false);\n+        bridgeHandler = bh;\n+    }\n+\n+    @Override\n+    protected void startScan() {\n+        bridgeHandler.requestVehicles();\n+    }\n+\n+    public void onResponse(VehiclesContainer container) {\n+        List<Vehicle> vehicles = container.vehicles;\n+        vehicles.forEach(vehicle -> {\n+            ThingUID bridgeUID = bridgeHandler.getThing().getUID();\n+            // the DriveTrain field in the delivered json is defining the Vehicle Type\n+            String vehicleType = vehicle.driveTrain;\n+            SUPPORTED_THING_SET.forEach(entry -> {\n+                if (entry.getId().equals(vehicleType)) {\n+                    ThingUID uid = new ThingUID(entry, vehicle.vin, bridgeUID.getId());\n+                    Map<String, String> properties = new HashMap<>();\n+                    // Dealer\n+                    if (vehicle.dealer != null) {\n+                        properties.put(\"Dealer\", vehicle.dealer.name);\n+                        properties.put(\"Dealer Address\", vehicle.dealer.street + \" \" + vehicle.dealer.country + \" \"\n+                                + vehicle.dealer.postalCode + \" \" + vehicle.dealer.city);\n+                        properties.put(\"Dealer Phone\", vehicle.dealer.phone);\n+                    }\n+\n+                    // Services & Support\n+                    properties.put(\"Services Activated\", getObject(vehicle, Constants.ACTIVATED));\n+                    String servicesSupported = getObject(vehicle, Constants.SUPPORTED);\n+                    String servicesNotSupported = getObject(vehicle, Constants.NOT_SUPPORTED);\n+                    if (vehicle.statisticsAvailable) {\n+                        servicesSupported += Constants.STATISTICS;\n+                    } else {\n+                        servicesNotSupported += Constants.STATISTICS;\n+                    }\n+                    properties.put(Constants.SERVICES_SUPPORTED, servicesSupported);\n+                    properties.put(\"Services Not Supported\", servicesNotSupported);\n+                    properties.put(\"Support Breakdown Number\", vehicle.breakdownNumber);\n+\n+                    // Vehicle Properties\n+                    if (vehicle.supportedChargingModes != null) {\n+                        StringBuffer chargingModes = new StringBuffer();\n+                        vehicle.supportedChargingModes.forEach(e -> {\n+                            chargingModes.append(e).append(Constants.SPACE);\n+                        });\n+                        properties.put(\"Vehicle Charge Modes\", chargingModes.toString());\n+                    }\n+                    if (vehicle.hasAlarmSystem) {\n+                        properties.put(\"Vehicle Alarm System\", \"Available\");\n+                    } else {\n+                        properties.put(\"Vehicle Alarm System\", \"Not Available\");\n+                    }\n+                    properties.put(\"Vehicle Brand\", vehicle.brand);\n+                    properties.put(\"Vehicle Bodytype\", vehicle.bodytype);\n+                    properties.put(\"Vehicle Color\", vehicle.color);\n+                    properties.put(\"Vehicle Construction Year\", Short.toString(vehicle.yearOfConstruction));\n+                    properties.put(\"Vehicle Drive Train\", vehicle.driveTrain);\n+                    properties.put(\"Vehicle Model\", vehicle.model);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODA4OTc4NQ=="}, "originalCommit": {"oid": "e0bfe93e13df4a3c5de5f8819b94ebf795664904"}, "originalPosition": 112}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMxMTMzMjY4OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/discovery/VehicleDiscovery.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMVQwNjo0NjoyNlrOH3oFGA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yM1QyMTo1NTo0M1rOH4g6HQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODA5MDM5Mg==", "bodyText": "StringBuffer uses a lot of synchronization which makes it quite a bit slower than StringBuilder which does not. Since you aren't doing anything multithreading here, you should use StringBuilder instead.\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    StringBuffer buf = new StringBuffer();\n          \n          \n            \n                    StringBuilder buf = new StringBuilder();", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r528090392", "createdAt": "2020-11-21T06:46:26Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/discovery/VehicleDiscovery.java", "diffHunk": "@@ -0,0 +1,178 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bmwconnecteddrive.internal.discovery;\n+\n+import static org.openhab.binding.bmwconnecteddrive.internal.ConnectedDriveConstants.SUPPORTED_THING_SET;\n+\n+import java.lang.reflect.Field;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.binding.bmwconnecteddrive.internal.ConnectedDriveConstants;\n+import org.openhab.binding.bmwconnecteddrive.internal.ConnectedDriveHandlerFactory;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.discovery.Vehicle;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.discovery.VehiclesContainer;\n+import org.openhab.binding.bmwconnecteddrive.internal.handler.ConnectedDriveBridgeHandler;\n+import org.openhab.binding.bmwconnecteddrive.internal.handler.VehicleHandler;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Constants;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Converter;\n+import org.openhab.core.config.core.Configuration;\n+import org.openhab.core.config.discovery.AbstractDiscoveryService;\n+import org.openhab.core.config.discovery.DiscoveryResultBuilder;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingUID;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link VehicleDiscovery} requests data from ConnectedDrive and is identifying the Vehicles after response\n+ *\n+ * @author Bernd Weymann - Initial contribution\n+ */\n+@NonNullByDefault\n+// @Component(service = DiscoveryService.class, immediate = true, configurationPid = \"discovery.bmwconnecteddrive\")\n+public class VehicleDiscovery extends AbstractDiscoveryService {\n+    private final Logger logger = LoggerFactory.getLogger(VehicleDiscovery.class);\n+    private static final int DISCOVERY_TIMEOUT = 10;\n+\n+    private ConnectedDriveBridgeHandler bridgeHandler;\n+\n+    public VehicleDiscovery(ConnectedDriveBridgeHandler bh) {\n+        super(SUPPORTED_THING_SET, DISCOVERY_TIMEOUT, false);\n+        bridgeHandler = bh;\n+    }\n+\n+    @Override\n+    protected void startScan() {\n+        bridgeHandler.requestVehicles();\n+    }\n+\n+    public void onResponse(VehiclesContainer container) {\n+        List<Vehicle> vehicles = container.vehicles;\n+        vehicles.forEach(vehicle -> {\n+            ThingUID bridgeUID = bridgeHandler.getThing().getUID();\n+            // the DriveTrain field in the delivered json is defining the Vehicle Type\n+            String vehicleType = vehicle.driveTrain;\n+            SUPPORTED_THING_SET.forEach(entry -> {\n+                if (entry.getId().equals(vehicleType)) {\n+                    ThingUID uid = new ThingUID(entry, vehicle.vin, bridgeUID.getId());\n+                    Map<String, String> properties = new HashMap<>();\n+                    // Dealer\n+                    if (vehicle.dealer != null) {\n+                        properties.put(\"Dealer\", vehicle.dealer.name);\n+                        properties.put(\"Dealer Address\", vehicle.dealer.street + \" \" + vehicle.dealer.country + \" \"\n+                                + vehicle.dealer.postalCode + \" \" + vehicle.dealer.city);\n+                        properties.put(\"Dealer Phone\", vehicle.dealer.phone);\n+                    }\n+\n+                    // Services & Support\n+                    properties.put(\"Services Activated\", getObject(vehicle, Constants.ACTIVATED));\n+                    String servicesSupported = getObject(vehicle, Constants.SUPPORTED);\n+                    String servicesNotSupported = getObject(vehicle, Constants.NOT_SUPPORTED);\n+                    if (vehicle.statisticsAvailable) {\n+                        servicesSupported += Constants.STATISTICS;\n+                    } else {\n+                        servicesNotSupported += Constants.STATISTICS;\n+                    }\n+                    properties.put(Constants.SERVICES_SUPPORTED, servicesSupported);\n+                    properties.put(\"Services Not Supported\", servicesNotSupported);\n+                    properties.put(\"Support Breakdown Number\", vehicle.breakdownNumber);\n+\n+                    // Vehicle Properties\n+                    if (vehicle.supportedChargingModes != null) {\n+                        StringBuffer chargingModes = new StringBuffer();\n+                        vehicle.supportedChargingModes.forEach(e -> {\n+                            chargingModes.append(e).append(Constants.SPACE);\n+                        });\n+                        properties.put(\"Vehicle Charge Modes\", chargingModes.toString());\n+                    }\n+                    if (vehicle.hasAlarmSystem) {\n+                        properties.put(\"Vehicle Alarm System\", \"Available\");\n+                    } else {\n+                        properties.put(\"Vehicle Alarm System\", \"Not Available\");\n+                    }\n+                    properties.put(\"Vehicle Brand\", vehicle.brand);\n+                    properties.put(\"Vehicle Bodytype\", vehicle.bodytype);\n+                    properties.put(\"Vehicle Color\", vehicle.color);\n+                    properties.put(\"Vehicle Construction Year\", Short.toString(vehicle.yearOfConstruction));\n+                    properties.put(\"Vehicle Drive Train\", vehicle.driveTrain);\n+                    properties.put(\"Vehicle Model\", vehicle.model);\n+                    if (vehicle.chargingControl != null) {\n+                        properties.put(\"Vehicle Charge Control\", Converter.toTitleCase(vehicle.model));\n+                    }\n+\n+                    // Check now if a thing with the same VIN exists\n+                    final AtomicBoolean foundVehicle = new AtomicBoolean(false);\n+                    List<VehicleHandler> l = ConnectedDriveHandlerFactory.getHandlerRegistry();\n+                    l.forEach(handler -> {\n+                        Thing vehicleThing = handler.getThing();\n+                        Configuration c = vehicleThing.getConfiguration();\n+                        if (c.containsKey(\"vin\")) {\n+                            String thingVIN = c.get(\"vin\").toString();\n+                            if (vehicle.vin.equals(thingVIN)) {\n+                                vehicleThing.setProperties(properties);\n+                                foundVehicle.set(true);\n+                            }\n+                        }\n+                    });\n+\n+                    // Vehicle not found -> trigger discovery\n+                    if (!foundVehicle.get()) {\n+                        // Properties needed for functional THing\n+                        properties.put(\"vin\", vehicle.vin);\n+                        properties.put(\"refreshInterval\",\n+                                Integer.toString(ConnectedDriveConstants.DEFAULT_REFRESH_INTERVAL));\n+                        properties.put(\"units\", ConnectedDriveConstants.UNITS_AUTODETECT);\n+                        properties.put(\"imageSize\", Integer.toString(ConnectedDriveConstants.DEFAULT_IMAGE_SIZE));\n+                        properties.put(\"imageViewport\", ConnectedDriveConstants.DEFAULT_IMAGE_VIEWPORT);\n+\n+                        String vehicleLabel = vehicle.brand + \" \" + vehicle.model;\n+                        Map<String, Object> convertedProperties = new HashMap<String, Object>(properties);\n+                        thingDiscovered(DiscoveryResultBuilder.create(uid).withBridge(bridgeUID)\n+                                .withRepresentationProperty(\"vin\").withLabel(vehicleLabel)\n+                                .withProperties(convertedProperties).build());\n+                    }\n+                }\n+            });\n+        });\n+    }\n+\n+    /**\n+     * Get all field names from a DTO with a specific value\n+     * Used to get e.g. all services which are \"ACTIVATED\"\n+     *\n+     * @param DTO Object\n+     * @param compare String which needs to map with the value\n+     * @return String with all field names matching this value separated with Spaces\n+     */\n+    public String getObject(Object dto, String compare) {\n+        StringBuffer buf = new StringBuffer();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e0bfe93e13df4a3c5de5f8819b94ebf795664904"}, "originalPosition": 162}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTAyMTQ2OQ==", "bodyText": "Yes, checked other places too and they are also not multithreaded. StringBuffer is removed.", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r529021469", "createdAt": "2020-11-23T21:55:43Z", "author": {"login": "weymann"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/discovery/VehicleDiscovery.java", "diffHunk": "@@ -0,0 +1,178 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bmwconnecteddrive.internal.discovery;\n+\n+import static org.openhab.binding.bmwconnecteddrive.internal.ConnectedDriveConstants.SUPPORTED_THING_SET;\n+\n+import java.lang.reflect.Field;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.binding.bmwconnecteddrive.internal.ConnectedDriveConstants;\n+import org.openhab.binding.bmwconnecteddrive.internal.ConnectedDriveHandlerFactory;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.discovery.Vehicle;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.discovery.VehiclesContainer;\n+import org.openhab.binding.bmwconnecteddrive.internal.handler.ConnectedDriveBridgeHandler;\n+import org.openhab.binding.bmwconnecteddrive.internal.handler.VehicleHandler;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Constants;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Converter;\n+import org.openhab.core.config.core.Configuration;\n+import org.openhab.core.config.discovery.AbstractDiscoveryService;\n+import org.openhab.core.config.discovery.DiscoveryResultBuilder;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingUID;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link VehicleDiscovery} requests data from ConnectedDrive and is identifying the Vehicles after response\n+ *\n+ * @author Bernd Weymann - Initial contribution\n+ */\n+@NonNullByDefault\n+// @Component(service = DiscoveryService.class, immediate = true, configurationPid = \"discovery.bmwconnecteddrive\")\n+public class VehicleDiscovery extends AbstractDiscoveryService {\n+    private final Logger logger = LoggerFactory.getLogger(VehicleDiscovery.class);\n+    private static final int DISCOVERY_TIMEOUT = 10;\n+\n+    private ConnectedDriveBridgeHandler bridgeHandler;\n+\n+    public VehicleDiscovery(ConnectedDriveBridgeHandler bh) {\n+        super(SUPPORTED_THING_SET, DISCOVERY_TIMEOUT, false);\n+        bridgeHandler = bh;\n+    }\n+\n+    @Override\n+    protected void startScan() {\n+        bridgeHandler.requestVehicles();\n+    }\n+\n+    public void onResponse(VehiclesContainer container) {\n+        List<Vehicle> vehicles = container.vehicles;\n+        vehicles.forEach(vehicle -> {\n+            ThingUID bridgeUID = bridgeHandler.getThing().getUID();\n+            // the DriveTrain field in the delivered json is defining the Vehicle Type\n+            String vehicleType = vehicle.driveTrain;\n+            SUPPORTED_THING_SET.forEach(entry -> {\n+                if (entry.getId().equals(vehicleType)) {\n+                    ThingUID uid = new ThingUID(entry, vehicle.vin, bridgeUID.getId());\n+                    Map<String, String> properties = new HashMap<>();\n+                    // Dealer\n+                    if (vehicle.dealer != null) {\n+                        properties.put(\"Dealer\", vehicle.dealer.name);\n+                        properties.put(\"Dealer Address\", vehicle.dealer.street + \" \" + vehicle.dealer.country + \" \"\n+                                + vehicle.dealer.postalCode + \" \" + vehicle.dealer.city);\n+                        properties.put(\"Dealer Phone\", vehicle.dealer.phone);\n+                    }\n+\n+                    // Services & Support\n+                    properties.put(\"Services Activated\", getObject(vehicle, Constants.ACTIVATED));\n+                    String servicesSupported = getObject(vehicle, Constants.SUPPORTED);\n+                    String servicesNotSupported = getObject(vehicle, Constants.NOT_SUPPORTED);\n+                    if (vehicle.statisticsAvailable) {\n+                        servicesSupported += Constants.STATISTICS;\n+                    } else {\n+                        servicesNotSupported += Constants.STATISTICS;\n+                    }\n+                    properties.put(Constants.SERVICES_SUPPORTED, servicesSupported);\n+                    properties.put(\"Services Not Supported\", servicesNotSupported);\n+                    properties.put(\"Support Breakdown Number\", vehicle.breakdownNumber);\n+\n+                    // Vehicle Properties\n+                    if (vehicle.supportedChargingModes != null) {\n+                        StringBuffer chargingModes = new StringBuffer();\n+                        vehicle.supportedChargingModes.forEach(e -> {\n+                            chargingModes.append(e).append(Constants.SPACE);\n+                        });\n+                        properties.put(\"Vehicle Charge Modes\", chargingModes.toString());\n+                    }\n+                    if (vehicle.hasAlarmSystem) {\n+                        properties.put(\"Vehicle Alarm System\", \"Available\");\n+                    } else {\n+                        properties.put(\"Vehicle Alarm System\", \"Not Available\");\n+                    }\n+                    properties.put(\"Vehicle Brand\", vehicle.brand);\n+                    properties.put(\"Vehicle Bodytype\", vehicle.bodytype);\n+                    properties.put(\"Vehicle Color\", vehicle.color);\n+                    properties.put(\"Vehicle Construction Year\", Short.toString(vehicle.yearOfConstruction));\n+                    properties.put(\"Vehicle Drive Train\", vehicle.driveTrain);\n+                    properties.put(\"Vehicle Model\", vehicle.model);\n+                    if (vehicle.chargingControl != null) {\n+                        properties.put(\"Vehicle Charge Control\", Converter.toTitleCase(vehicle.model));\n+                    }\n+\n+                    // Check now if a thing with the same VIN exists\n+                    final AtomicBoolean foundVehicle = new AtomicBoolean(false);\n+                    List<VehicleHandler> l = ConnectedDriveHandlerFactory.getHandlerRegistry();\n+                    l.forEach(handler -> {\n+                        Thing vehicleThing = handler.getThing();\n+                        Configuration c = vehicleThing.getConfiguration();\n+                        if (c.containsKey(\"vin\")) {\n+                            String thingVIN = c.get(\"vin\").toString();\n+                            if (vehicle.vin.equals(thingVIN)) {\n+                                vehicleThing.setProperties(properties);\n+                                foundVehicle.set(true);\n+                            }\n+                        }\n+                    });\n+\n+                    // Vehicle not found -> trigger discovery\n+                    if (!foundVehicle.get()) {\n+                        // Properties needed for functional THing\n+                        properties.put(\"vin\", vehicle.vin);\n+                        properties.put(\"refreshInterval\",\n+                                Integer.toString(ConnectedDriveConstants.DEFAULT_REFRESH_INTERVAL));\n+                        properties.put(\"units\", ConnectedDriveConstants.UNITS_AUTODETECT);\n+                        properties.put(\"imageSize\", Integer.toString(ConnectedDriveConstants.DEFAULT_IMAGE_SIZE));\n+                        properties.put(\"imageViewport\", ConnectedDriveConstants.DEFAULT_IMAGE_VIEWPORT);\n+\n+                        String vehicleLabel = vehicle.brand + \" \" + vehicle.model;\n+                        Map<String, Object> convertedProperties = new HashMap<String, Object>(properties);\n+                        thingDiscovered(DiscoveryResultBuilder.create(uid).withBridge(bridgeUID)\n+                                .withRepresentationProperty(\"vin\").withLabel(vehicleLabel)\n+                                .withProperties(convertedProperties).build());\n+                    }\n+                }\n+            });\n+        });\n+    }\n+\n+    /**\n+     * Get all field names from a DTO with a specific value\n+     * Used to get e.g. all services which are \"ACTIVATED\"\n+     *\n+     * @param DTO Object\n+     * @param compare String which needs to map with the value\n+     * @return String with all field names matching this value separated with Spaces\n+     */\n+    public String getObject(Object dto, String compare) {\n+        StringBuffer buf = new StringBuffer();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODA5MDM5Mg=="}, "originalCommit": {"oid": "e0bfe93e13df4a3c5de5f8819b94ebf795664904"}, "originalPosition": 162}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMxMTMzNTg2OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/dto/Destination.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMVQwNjo0NzowNVrOH3oHQQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yM1QyMTo1NjoxMVrOH4g6-Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODA5MDk0NQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    StringBuffer buf = new StringBuffer();\n          \n          \n            \n                    StringBuilder buf = new StringBuilder();\n          \n      \n    \n    \n  \n\nPlease replace all other instances of StringBuffer with StringBuilder.", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r528090945", "createdAt": "2020-11-21T06:47:05Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/dto/Destination.java", "diffHunk": "@@ -0,0 +1,55 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bmwconnecteddrive.internal.dto;\n+\n+import static org.openhab.binding.bmwconnecteddrive.internal.utils.Constants.*;\n+\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Converter;\n+\n+/**\n+ * The {@link Destination} Data Transfer Object\n+ *\n+ * @author Bernd Weymann - Initial contribution\n+ */\n+public class Destination {\n+    public float lat;\n+    public float lon;\n+    public String country;\n+    public String city;\n+    public String street;\n+    public String streetNumber;\n+    public String type;\n+    public String createdAt;\n+\n+    public String getAddress() {\n+        StringBuffer buf = new StringBuffer();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e0bfe93e13df4a3c5de5f8819b94ebf795664904"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTAyMTY4OQ==", "bodyText": "Done", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r529021689", "createdAt": "2020-11-23T21:56:11Z", "author": {"login": "weymann"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/dto/Destination.java", "diffHunk": "@@ -0,0 +1,55 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bmwconnecteddrive.internal.dto;\n+\n+import static org.openhab.binding.bmwconnecteddrive.internal.utils.Constants.*;\n+\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Converter;\n+\n+/**\n+ * The {@link Destination} Data Transfer Object\n+ *\n+ * @author Bernd Weymann - Initial contribution\n+ */\n+public class Destination {\n+    public float lat;\n+    public float lon;\n+    public String country;\n+    public String city;\n+    public String street;\n+    public String streetNumber;\n+    public String type;\n+    public String createdAt;\n+\n+    public String getAddress() {\n+        StringBuffer buf = new StringBuffer();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODA5MDk0NQ=="}, "originalCommit": {"oid": "e0bfe93e13df4a3c5de5f8819b94ebf795664904"}, "originalPosition": 35}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMxMTM4NDc4OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/dto/status/VehicleStatus.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMVQwNjo1ODo1OFrOH3opNw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQxODo1MzozNVrOH5QyGw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODA5OTYzOQ==", "bodyText": "You should avoid putting any heavy logic in the DTO classes. First, because it adds complexity to the DTO classes and second because you end up skirting around the null checker's static analysis. Either add @NonNullByDefault to the method or move all the code into another class that has @NonNullByDefault at the top of the class.", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r528099639", "createdAt": "2020-11-21T06:58:58Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/dto/status/VehicleStatus.java", "diffHunk": "@@ -0,0 +1,248 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bmwconnecteddrive.internal.dto.status;\n+\n+import static org.openhab.binding.bmwconnecteddrive.internal.utils.Constants.*;\n+\n+import java.lang.reflect.Field;\n+import java.time.LocalDateTime;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Constants;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Converter;\n+\n+import com.google.gson.annotations.SerializedName;\n+\n+/**\n+ * The {@link VehicleStatus} Data Transfer Object\n+ *\n+ * @author Bernd Weymann - Initial contribution\n+ */\n+public class VehicleStatus {\n+    public int mileage;// \": 17273,\n+    public double remainingFuel;// \": 4,\n+    public double remainingRangeElectric;// \": 148,\n+    public double remainingRangeElectricMls;// \": 91,\n+    public double remainingRangeFuel;// \": 70,\"\n+    public double remainingRangeFuelMls;// \":43,\"\n+    public double maxRangeElectric;// \":216,\"\n+    public double maxRangeElectricMls;// \":134,\"\n+    public double maxFuel;// \":8.5,\n+    public double chargingLevelHv;// \":71,\n+    public String vin;// : \"ANONYMOUS\",\n+    public String updateReason;// \": \"VEHICLE_SHUTDOWN_SECURED\",\n+    public String updateTime;// \": \"2020-08-24 T15:55:32+0000\",\n+    public String doorDriverFront = Constants.UNKNOWN;// \": \"CLOSED\",\n+    public String doorDriverRear = Constants.UNKNOWN;// \": \"CLOSED\",\n+    public String doorPassengerFront = Constants.UNKNOWN;// \": \"CLOSED\",\n+    public String doorPassengerRear = Constants.UNKNOWN;// \": \"CLOSED\",\n+    public String windowDriverFront = Constants.UNKNOWN;// \": \"CLOSED\",\n+    public String windowDriverRear = Constants.UNKNOWN;// \": \"CLOSED\",\n+    public String windowPassengerFront = Constants.UNKNOWN;// \": \"CLOSED\",\n+    public String windowPassengerRear = Constants.UNKNOWN;// \": \"CLOSED\",\n+    public String sunroof = Constants.UNKNOWN;// \": \"CLOSED\",\n+    public String trunk = Constants.UNKNOWN;// \": \"CLOSED\",\n+    public String rearWindow = Constants.UNKNOWN;// \": \"INVALID\",\n+    public String hood = Constants.UNKNOWN;// \": \"CLOSED\",\n+    public String doorLockState;// \": \"SECURED\",\n+    public String parkingLight;// \": \"OFF\",\n+    public String positionLight;// \": \"ON\",\n+    public String connectionStatus;// \": \"DISCONNECTED\",\n+    public String chargingStatus;// \": \"INVALID\",\"\n+    public String lastChargingEndReason;// \": \"CHARGING_GOAL_REACHED\",\n+    public String lastChargingEndResult;// \": \"SUCCESS\",\"\n+    public Position position;\n+    public String internalDataTimeUTC;// \": \"2020-08-24 T15:55:32\",\n+    public boolean singleImmediateCharging;// \":false,\n+    public String chargingConnectionType;// \": \"CONDUCTIVE\",\n+    public String chargingInductivePositioning;// \": \"NOT_POSITIONED\",\n+    public String vehicleCountry;// \": \"DE\",\"+\"\n+    @SerializedName(\"DCS_CCH_Activation\")\n+    public String dcsCchActivation;// \": \"NA\",\n+    @SerializedName(\"DCS_CCH_Ongoing\")\n+    public boolean dcsCchOngoing;// \":false\n+    public List<CCMMessage> checkControlMessages = new ArrayList<CCMMessage>();// \":[],\n+    public List<CBSMessage> cbsData = new ArrayList<CBSMessage>();\n+\n+    /**\n+     * Get Next Service for Date and / or Mileage\n+     *\n+     * @param imperial\n+     * @return\n+     */\n+    public CBSMessage getNextService() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e0bfe93e13df4a3c5de5f8819b94ebf795664904"}, "originalPosition": 84}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTgwNTg1MQ==", "bodyText": "Right, these are some convenient functions to show the user the next service date or mileage. I introduced a small utils class to cover this.", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r529805851", "createdAt": "2020-11-24T18:53:35Z", "author": {"login": "weymann"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/dto/status/VehicleStatus.java", "diffHunk": "@@ -0,0 +1,248 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bmwconnecteddrive.internal.dto.status;\n+\n+import static org.openhab.binding.bmwconnecteddrive.internal.utils.Constants.*;\n+\n+import java.lang.reflect.Field;\n+import java.time.LocalDateTime;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Constants;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Converter;\n+\n+import com.google.gson.annotations.SerializedName;\n+\n+/**\n+ * The {@link VehicleStatus} Data Transfer Object\n+ *\n+ * @author Bernd Weymann - Initial contribution\n+ */\n+public class VehicleStatus {\n+    public int mileage;// \": 17273,\n+    public double remainingFuel;// \": 4,\n+    public double remainingRangeElectric;// \": 148,\n+    public double remainingRangeElectricMls;// \": 91,\n+    public double remainingRangeFuel;// \": 70,\"\n+    public double remainingRangeFuelMls;// \":43,\"\n+    public double maxRangeElectric;// \":216,\"\n+    public double maxRangeElectricMls;// \":134,\"\n+    public double maxFuel;// \":8.5,\n+    public double chargingLevelHv;// \":71,\n+    public String vin;// : \"ANONYMOUS\",\n+    public String updateReason;// \": \"VEHICLE_SHUTDOWN_SECURED\",\n+    public String updateTime;// \": \"2020-08-24 T15:55:32+0000\",\n+    public String doorDriverFront = Constants.UNKNOWN;// \": \"CLOSED\",\n+    public String doorDriverRear = Constants.UNKNOWN;// \": \"CLOSED\",\n+    public String doorPassengerFront = Constants.UNKNOWN;// \": \"CLOSED\",\n+    public String doorPassengerRear = Constants.UNKNOWN;// \": \"CLOSED\",\n+    public String windowDriverFront = Constants.UNKNOWN;// \": \"CLOSED\",\n+    public String windowDriverRear = Constants.UNKNOWN;// \": \"CLOSED\",\n+    public String windowPassengerFront = Constants.UNKNOWN;// \": \"CLOSED\",\n+    public String windowPassengerRear = Constants.UNKNOWN;// \": \"CLOSED\",\n+    public String sunroof = Constants.UNKNOWN;// \": \"CLOSED\",\n+    public String trunk = Constants.UNKNOWN;// \": \"CLOSED\",\n+    public String rearWindow = Constants.UNKNOWN;// \": \"INVALID\",\n+    public String hood = Constants.UNKNOWN;// \": \"CLOSED\",\n+    public String doorLockState;// \": \"SECURED\",\n+    public String parkingLight;// \": \"OFF\",\n+    public String positionLight;// \": \"ON\",\n+    public String connectionStatus;// \": \"DISCONNECTED\",\n+    public String chargingStatus;// \": \"INVALID\",\"\n+    public String lastChargingEndReason;// \": \"CHARGING_GOAL_REACHED\",\n+    public String lastChargingEndResult;// \": \"SUCCESS\",\"\n+    public Position position;\n+    public String internalDataTimeUTC;// \": \"2020-08-24 T15:55:32\",\n+    public boolean singleImmediateCharging;// \":false,\n+    public String chargingConnectionType;// \": \"CONDUCTIVE\",\n+    public String chargingInductivePositioning;// \": \"NOT_POSITIONED\",\n+    public String vehicleCountry;// \": \"DE\",\"+\"\n+    @SerializedName(\"DCS_CCH_Activation\")\n+    public String dcsCchActivation;// \": \"NA\",\n+    @SerializedName(\"DCS_CCH_Ongoing\")\n+    public boolean dcsCchOngoing;// \":false\n+    public List<CCMMessage> checkControlMessages = new ArrayList<CCMMessage>();// \":[],\n+    public List<CBSMessage> cbsData = new ArrayList<CBSMessage>();\n+\n+    /**\n+     * Get Next Service for Date and / or Mileage\n+     *\n+     * @param imperial\n+     * @return\n+     */\n+    public CBSMessage getNextService() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODA5OTYzOQ=="}, "originalCommit": {"oid": "e0bfe93e13df4a3c5de5f8819b94ebf795664904"}, "originalPosition": 84}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMxMTM4NTE0OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/dto/status/VehicleStatus.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMVQwNjo1OTowNVrOH3opeA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQxODo1Mzo1OVrOH5Qy_Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODA5OTcwNA==", "bodyText": "same as above", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r528099704", "createdAt": "2020-11-21T06:59:05Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/dto/status/VehicleStatus.java", "diffHunk": "@@ -0,0 +1,248 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bmwconnecteddrive.internal.dto.status;\n+\n+import static org.openhab.binding.bmwconnecteddrive.internal.utils.Constants.*;\n+\n+import java.lang.reflect.Field;\n+import java.time.LocalDateTime;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Constants;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Converter;\n+\n+import com.google.gson.annotations.SerializedName;\n+\n+/**\n+ * The {@link VehicleStatus} Data Transfer Object\n+ *\n+ * @author Bernd Weymann - Initial contribution\n+ */\n+public class VehicleStatus {\n+    public int mileage;// \": 17273,\n+    public double remainingFuel;// \": 4,\n+    public double remainingRangeElectric;// \": 148,\n+    public double remainingRangeElectricMls;// \": 91,\n+    public double remainingRangeFuel;// \": 70,\"\n+    public double remainingRangeFuelMls;// \":43,\"\n+    public double maxRangeElectric;// \":216,\"\n+    public double maxRangeElectricMls;// \":134,\"\n+    public double maxFuel;// \":8.5,\n+    public double chargingLevelHv;// \":71,\n+    public String vin;// : \"ANONYMOUS\",\n+    public String updateReason;// \": \"VEHICLE_SHUTDOWN_SECURED\",\n+    public String updateTime;// \": \"2020-08-24 T15:55:32+0000\",\n+    public String doorDriverFront = Constants.UNKNOWN;// \": \"CLOSED\",\n+    public String doorDriverRear = Constants.UNKNOWN;// \": \"CLOSED\",\n+    public String doorPassengerFront = Constants.UNKNOWN;// \": \"CLOSED\",\n+    public String doorPassengerRear = Constants.UNKNOWN;// \": \"CLOSED\",\n+    public String windowDriverFront = Constants.UNKNOWN;// \": \"CLOSED\",\n+    public String windowDriverRear = Constants.UNKNOWN;// \": \"CLOSED\",\n+    public String windowPassengerFront = Constants.UNKNOWN;// \": \"CLOSED\",\n+    public String windowPassengerRear = Constants.UNKNOWN;// \": \"CLOSED\",\n+    public String sunroof = Constants.UNKNOWN;// \": \"CLOSED\",\n+    public String trunk = Constants.UNKNOWN;// \": \"CLOSED\",\n+    public String rearWindow = Constants.UNKNOWN;// \": \"INVALID\",\n+    public String hood = Constants.UNKNOWN;// \": \"CLOSED\",\n+    public String doorLockState;// \": \"SECURED\",\n+    public String parkingLight;// \": \"OFF\",\n+    public String positionLight;// \": \"ON\",\n+    public String connectionStatus;// \": \"DISCONNECTED\",\n+    public String chargingStatus;// \": \"INVALID\",\"\n+    public String lastChargingEndReason;// \": \"CHARGING_GOAL_REACHED\",\n+    public String lastChargingEndResult;// \": \"SUCCESS\",\"\n+    public Position position;\n+    public String internalDataTimeUTC;// \": \"2020-08-24 T15:55:32\",\n+    public boolean singleImmediateCharging;// \":false,\n+    public String chargingConnectionType;// \": \"CONDUCTIVE\",\n+    public String chargingInductivePositioning;// \": \"NOT_POSITIONED\",\n+    public String vehicleCountry;// \": \"DE\",\"+\"\n+    @SerializedName(\"DCS_CCH_Activation\")\n+    public String dcsCchActivation;// \": \"NA\",\n+    @SerializedName(\"DCS_CCH_Ongoing\")\n+    public boolean dcsCchOngoing;// \":false\n+    public List<CCMMessage> checkControlMessages = new ArrayList<CCMMessage>();// \":[],\n+    public List<CBSMessage> cbsData = new ArrayList<CBSMessage>();\n+\n+    /**\n+     * Get Next Service for Date and / or Mileage\n+     *\n+     * @param imperial\n+     * @return\n+     */\n+    public CBSMessage getNextService() {\n+        CBSMessage cbs = new CBSMessage();\n+        if (cbsData == null) {\n+            return cbs;\n+        }\n+        if (cbsData.isEmpty()) {\n+            return cbs;\n+        } else {\n+            int serviceMileage = Integer.MAX_VALUE;\n+            LocalDateTime serviceDate = LocalDateTime.now().plusYears(100);\n+\n+            for (int i = 0; i < cbsData.size(); i++) {\n+                CBSMessage entry = cbsData.get(i);\n+                if (entry.cbsRemainingMileage != 0 && entry.cbsDueDate != null) {\n+                    LocalDateTime d = LocalDateTime.parse(entry.cbsDueDate + Constants.UTC_APPENDIX);\n+                    // LocalDate d = LocalDate.parse(entry.cbsDueDate + APPENDIX_DAY,\n+                    // Converter.SERVICE_DATE_INPUT_PATTERN);\n+                    if ((entry.cbsRemainingMileage < serviceMileage) || (d.isBefore(serviceDate))) {\n+                        serviceDate = d;\n+                        serviceMileage = entry.cbsRemainingMileage;\n+                        cbs = entry;\n+                    }\n+                } else if (entry.cbsRemainingMileage != 0) {\n+                    if (entry.cbsRemainingMileage < serviceMileage) {\n+                        serviceMileage = entry.cbsRemainingMileage;\n+                        cbs = entry;\n+                    }\n+                } else if (entry.cbsDueDate != null) {\n+                    LocalDateTime d = LocalDateTime.parse(entry.cbsDueDate + Constants.UTC_APPENDIX);\n+                    // LocalDate d = LocalDate.parse(entry.cbsDueDate + APPENDIX_DAY,\n+                    // Converter.SERVICE_DATE_INPUT_PATTERN);\n+                    if (d.isBefore(serviceDate)) {\n+                        serviceDate = d;\n+                        cbs = entry;\n+                    }\n+                }\n+            }\n+        }\n+        return cbs;\n+    }\n+\n+    public String getNextServiceDate() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e0bfe93e13df4a3c5de5f8819b94ebf795664904"}, "originalPosition": 125}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTgwNjA3Nw==", "bodyText": "as stated above", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r529806077", "createdAt": "2020-11-24T18:53:59Z", "author": {"login": "weymann"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/dto/status/VehicleStatus.java", "diffHunk": "@@ -0,0 +1,248 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bmwconnecteddrive.internal.dto.status;\n+\n+import static org.openhab.binding.bmwconnecteddrive.internal.utils.Constants.*;\n+\n+import java.lang.reflect.Field;\n+import java.time.LocalDateTime;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Constants;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Converter;\n+\n+import com.google.gson.annotations.SerializedName;\n+\n+/**\n+ * The {@link VehicleStatus} Data Transfer Object\n+ *\n+ * @author Bernd Weymann - Initial contribution\n+ */\n+public class VehicleStatus {\n+    public int mileage;// \": 17273,\n+    public double remainingFuel;// \": 4,\n+    public double remainingRangeElectric;// \": 148,\n+    public double remainingRangeElectricMls;// \": 91,\n+    public double remainingRangeFuel;// \": 70,\"\n+    public double remainingRangeFuelMls;// \":43,\"\n+    public double maxRangeElectric;// \":216,\"\n+    public double maxRangeElectricMls;// \":134,\"\n+    public double maxFuel;// \":8.5,\n+    public double chargingLevelHv;// \":71,\n+    public String vin;// : \"ANONYMOUS\",\n+    public String updateReason;// \": \"VEHICLE_SHUTDOWN_SECURED\",\n+    public String updateTime;// \": \"2020-08-24 T15:55:32+0000\",\n+    public String doorDriverFront = Constants.UNKNOWN;// \": \"CLOSED\",\n+    public String doorDriverRear = Constants.UNKNOWN;// \": \"CLOSED\",\n+    public String doorPassengerFront = Constants.UNKNOWN;// \": \"CLOSED\",\n+    public String doorPassengerRear = Constants.UNKNOWN;// \": \"CLOSED\",\n+    public String windowDriverFront = Constants.UNKNOWN;// \": \"CLOSED\",\n+    public String windowDriverRear = Constants.UNKNOWN;// \": \"CLOSED\",\n+    public String windowPassengerFront = Constants.UNKNOWN;// \": \"CLOSED\",\n+    public String windowPassengerRear = Constants.UNKNOWN;// \": \"CLOSED\",\n+    public String sunroof = Constants.UNKNOWN;// \": \"CLOSED\",\n+    public String trunk = Constants.UNKNOWN;// \": \"CLOSED\",\n+    public String rearWindow = Constants.UNKNOWN;// \": \"INVALID\",\n+    public String hood = Constants.UNKNOWN;// \": \"CLOSED\",\n+    public String doorLockState;// \": \"SECURED\",\n+    public String parkingLight;// \": \"OFF\",\n+    public String positionLight;// \": \"ON\",\n+    public String connectionStatus;// \": \"DISCONNECTED\",\n+    public String chargingStatus;// \": \"INVALID\",\"\n+    public String lastChargingEndReason;// \": \"CHARGING_GOAL_REACHED\",\n+    public String lastChargingEndResult;// \": \"SUCCESS\",\"\n+    public Position position;\n+    public String internalDataTimeUTC;// \": \"2020-08-24 T15:55:32\",\n+    public boolean singleImmediateCharging;// \":false,\n+    public String chargingConnectionType;// \": \"CONDUCTIVE\",\n+    public String chargingInductivePositioning;// \": \"NOT_POSITIONED\",\n+    public String vehicleCountry;// \": \"DE\",\"+\"\n+    @SerializedName(\"DCS_CCH_Activation\")\n+    public String dcsCchActivation;// \": \"NA\",\n+    @SerializedName(\"DCS_CCH_Ongoing\")\n+    public boolean dcsCchOngoing;// \":false\n+    public List<CCMMessage> checkControlMessages = new ArrayList<CCMMessage>();// \":[],\n+    public List<CBSMessage> cbsData = new ArrayList<CBSMessage>();\n+\n+    /**\n+     * Get Next Service for Date and / or Mileage\n+     *\n+     * @param imperial\n+     * @return\n+     */\n+    public CBSMessage getNextService() {\n+        CBSMessage cbs = new CBSMessage();\n+        if (cbsData == null) {\n+            return cbs;\n+        }\n+        if (cbsData.isEmpty()) {\n+            return cbs;\n+        } else {\n+            int serviceMileage = Integer.MAX_VALUE;\n+            LocalDateTime serviceDate = LocalDateTime.now().plusYears(100);\n+\n+            for (int i = 0; i < cbsData.size(); i++) {\n+                CBSMessage entry = cbsData.get(i);\n+                if (entry.cbsRemainingMileage != 0 && entry.cbsDueDate != null) {\n+                    LocalDateTime d = LocalDateTime.parse(entry.cbsDueDate + Constants.UTC_APPENDIX);\n+                    // LocalDate d = LocalDate.parse(entry.cbsDueDate + APPENDIX_DAY,\n+                    // Converter.SERVICE_DATE_INPUT_PATTERN);\n+                    if ((entry.cbsRemainingMileage < serviceMileage) || (d.isBefore(serviceDate))) {\n+                        serviceDate = d;\n+                        serviceMileage = entry.cbsRemainingMileage;\n+                        cbs = entry;\n+                    }\n+                } else if (entry.cbsRemainingMileage != 0) {\n+                    if (entry.cbsRemainingMileage < serviceMileage) {\n+                        serviceMileage = entry.cbsRemainingMileage;\n+                        cbs = entry;\n+                    }\n+                } else if (entry.cbsDueDate != null) {\n+                    LocalDateTime d = LocalDateTime.parse(entry.cbsDueDate + Constants.UTC_APPENDIX);\n+                    // LocalDate d = LocalDate.parse(entry.cbsDueDate + APPENDIX_DAY,\n+                    // Converter.SERVICE_DATE_INPUT_PATTERN);\n+                    if (d.isBefore(serviceDate)) {\n+                        serviceDate = d;\n+                        cbs = entry;\n+                    }\n+                }\n+            }\n+        }\n+        return cbs;\n+    }\n+\n+    public String getNextServiceDate() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODA5OTcwNA=="}, "originalCommit": {"oid": "e0bfe93e13df4a3c5de5f8819b94ebf795664904"}, "originalPosition": 125}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMxMTQwODE2OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/ConnectedDriveBridgeHandler.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMVQwNzowNDo1OFrOH3o57Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yN1QwMTo1MjoyN1rOILngsg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODEwMzkxNw==", "bodyText": "I suggest that you change your discovery service into a ThingHandlerService so that you don't have to manage osgi registration of this class. It is a bit verbose to explain how to make the change but I've found another PR that shows exactly the changes that are required: https://github.com/openhab/openhab-addons/pull/6396/files", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r528103917", "createdAt": "2020-11-21T07:04:58Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/ConnectedDriveBridgeHandler.java", "diffHunk": "@@ -0,0 +1,192 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bmwconnecteddrive.internal.handler;\n+\n+import static org.openhab.binding.bmwconnecteddrive.internal.utils.Constants.ANONYMOUS;\n+\n+import java.util.Hashtable;\n+import java.util.Optional;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.binding.bmwconnecteddrive.internal.ConnectedDriveConfiguration;\n+import org.openhab.binding.bmwconnecteddrive.internal.discovery.VehicleDiscovery;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.NetworkError;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.discovery.Dealer;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.discovery.VehiclesContainer;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Constants;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Converter;\n+import org.openhab.core.config.discovery.DiscoveryService;\n+import org.openhab.core.io.net.http.HttpClientFactory;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseBridgeHandler;\n+import org.openhab.core.types.Command;\n+import org.osgi.framework.BundleContext;\n+import org.osgi.framework.ServiceRegistration;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link ConnectedDriveBridgeHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Bernd Weymann - Initial contribution\n+ */\n+@NonNullByDefault\n+public class ConnectedDriveBridgeHandler extends BaseBridgeHandler implements StringResponseCallback {\n+    private final Logger logger = LoggerFactory.getLogger(ConnectedDriveBridgeHandler.class);\n+    private HttpClientFactory httpClientFactory;\n+    private BundleContext bundleContext;\n+    private VehicleDiscovery discoveryService;\n+    private ServiceRegistration<?> discoveryServiceRegstration;\n+    private Optional<ConnectedDriveProxy> proxy = Optional.empty();\n+    private Optional<ConnectedDriveConfiguration> configuration = Optional.empty();\n+    private Optional<ScheduledFuture<?>> refreshJob = Optional.empty();\n+    private Optional<String> troubleshootFingerprint = Optional.empty();\n+\n+    private static final String DISCOVERY_FINGERPRINT = \"discovery-fingerprint\";\n+    private ChannelUID discoveryFingerprintChannel;\n+\n+    public ConnectedDriveBridgeHandler(Bridge bridge, HttpClientFactory hcf, BundleContext bc) {\n+        super(bridge);\n+        httpClientFactory = hcf;\n+        bundleContext = bc;\n+        discoveryService = new VehicleDiscovery(this);\n+        discoveryServiceRegstration = bundleContext.registerService(DiscoveryService.class.getName(), discoveryService,\n+                new Hashtable<>());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e0bfe93e13df4a3c5de5f8819b94ebf795664904"}, "originalPosition": 71}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTA1MjU5NA==", "bodyText": "I've done the changes and it works in the OH3 environment so BundleContext and service registration are completely removed.", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r549052594", "createdAt": "2020-12-27T01:52:27Z", "author": {"login": "weymann"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/ConnectedDriveBridgeHandler.java", "diffHunk": "@@ -0,0 +1,192 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bmwconnecteddrive.internal.handler;\n+\n+import static org.openhab.binding.bmwconnecteddrive.internal.utils.Constants.ANONYMOUS;\n+\n+import java.util.Hashtable;\n+import java.util.Optional;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.binding.bmwconnecteddrive.internal.ConnectedDriveConfiguration;\n+import org.openhab.binding.bmwconnecteddrive.internal.discovery.VehicleDiscovery;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.NetworkError;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.discovery.Dealer;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.discovery.VehiclesContainer;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Constants;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Converter;\n+import org.openhab.core.config.discovery.DiscoveryService;\n+import org.openhab.core.io.net.http.HttpClientFactory;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseBridgeHandler;\n+import org.openhab.core.types.Command;\n+import org.osgi.framework.BundleContext;\n+import org.osgi.framework.ServiceRegistration;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link ConnectedDriveBridgeHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Bernd Weymann - Initial contribution\n+ */\n+@NonNullByDefault\n+public class ConnectedDriveBridgeHandler extends BaseBridgeHandler implements StringResponseCallback {\n+    private final Logger logger = LoggerFactory.getLogger(ConnectedDriveBridgeHandler.class);\n+    private HttpClientFactory httpClientFactory;\n+    private BundleContext bundleContext;\n+    private VehicleDiscovery discoveryService;\n+    private ServiceRegistration<?> discoveryServiceRegstration;\n+    private Optional<ConnectedDriveProxy> proxy = Optional.empty();\n+    private Optional<ConnectedDriveConfiguration> configuration = Optional.empty();\n+    private Optional<ScheduledFuture<?>> refreshJob = Optional.empty();\n+    private Optional<String> troubleshootFingerprint = Optional.empty();\n+\n+    private static final String DISCOVERY_FINGERPRINT = \"discovery-fingerprint\";\n+    private ChannelUID discoveryFingerprintChannel;\n+\n+    public ConnectedDriveBridgeHandler(Bridge bridge, HttpClientFactory hcf, BundleContext bc) {\n+        super(bridge);\n+        httpClientFactory = hcf;\n+        bundleContext = bc;\n+        discoveryService = new VehicleDiscovery(this);\n+        discoveryServiceRegstration = bundleContext.registerService(DiscoveryService.class.getName(), discoveryService,\n+                new Hashtable<>());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODEwMzkxNw=="}, "originalCommit": {"oid": "e0bfe93e13df4a3c5de5f8819b94ebf795664904"}, "originalPosition": 71}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMxMTQxMTcxOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/ConnectedDriveBridgeHandler.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMVQwNzowNTo1MVrOH3o8cg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yM1QyMjoyODoxNVrOH4h2AQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODEwNDU2Mg==", "bodyText": "You should save the future returned here and make sure to cancel it during dispose()", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r528104562", "createdAt": "2020-11-21T07:05:51Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/ConnectedDriveBridgeHandler.java", "diffHunk": "@@ -0,0 +1,192 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bmwconnecteddrive.internal.handler;\n+\n+import static org.openhab.binding.bmwconnecteddrive.internal.utils.Constants.ANONYMOUS;\n+\n+import java.util.Hashtable;\n+import java.util.Optional;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.binding.bmwconnecteddrive.internal.ConnectedDriveConfiguration;\n+import org.openhab.binding.bmwconnecteddrive.internal.discovery.VehicleDiscovery;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.NetworkError;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.discovery.Dealer;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.discovery.VehiclesContainer;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Constants;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Converter;\n+import org.openhab.core.config.discovery.DiscoveryService;\n+import org.openhab.core.io.net.http.HttpClientFactory;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseBridgeHandler;\n+import org.openhab.core.types.Command;\n+import org.osgi.framework.BundleContext;\n+import org.osgi.framework.ServiceRegistration;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link ConnectedDriveBridgeHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Bernd Weymann - Initial contribution\n+ */\n+@NonNullByDefault\n+public class ConnectedDriveBridgeHandler extends BaseBridgeHandler implements StringResponseCallback {\n+    private final Logger logger = LoggerFactory.getLogger(ConnectedDriveBridgeHandler.class);\n+    private HttpClientFactory httpClientFactory;\n+    private BundleContext bundleContext;\n+    private VehicleDiscovery discoveryService;\n+    private ServiceRegistration<?> discoveryServiceRegstration;\n+    private Optional<ConnectedDriveProxy> proxy = Optional.empty();\n+    private Optional<ConnectedDriveConfiguration> configuration = Optional.empty();\n+    private Optional<ScheduledFuture<?>> refreshJob = Optional.empty();\n+    private Optional<String> troubleshootFingerprint = Optional.empty();\n+\n+    private static final String DISCOVERY_FINGERPRINT = \"discovery-fingerprint\";\n+    private ChannelUID discoveryFingerprintChannel;\n+\n+    public ConnectedDriveBridgeHandler(Bridge bridge, HttpClientFactory hcf, BundleContext bc) {\n+        super(bridge);\n+        httpClientFactory = hcf;\n+        bundleContext = bc;\n+        discoveryService = new VehicleDiscovery(this);\n+        discoveryServiceRegstration = bundleContext.registerService(DiscoveryService.class.getName(), discoveryService,\n+                new Hashtable<>());\n+        discoveryFingerprintChannel = new ChannelUID(bridge.getUID(), DISCOVERY_FINGERPRINT);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (DISCOVERY_FINGERPRINT.equals(channelUID.getIdWithoutGroup()) && command instanceof OnOffType) {\n+            if (command.equals(OnOffType.ON)) {\n+                logger.warn(\n+                        \"###### BMW ConnectedDrive Binding - Discovery Troubleshoot Fingerprint Data - BEGIN ######\");\n+                logger.warn(\"### Discovery Result ###\");\n+                logger.warn(\"{}\", getDiscoveryFingerprint());\n+                logger.warn(\"###### BMW ConnectedDrive Binding - Discovery Troubleshoot Fingerprint Data - END ######\");\n+                updateState(discoveryFingerprintChannel, OnOffType.OFF);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        updateStatus(ThingStatus.UNKNOWN);\n+        configuration = Optional.of(getConfigAs(ConnectedDriveConfiguration.class));\n+        if (configuration.isPresent()) {\n+            proxy = Optional.of(new ConnectedDriveProxy(httpClientFactory, configuration.get()));\n+            // give the system some time to create all predefined Vehicles\n+            scheduler.schedule(this::requestVehicles, 5, TimeUnit.SECONDS);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e0bfe93e13df4a3c5de5f8819b94ebf795664904"}, "originalPosition": 96}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTAzNjgwMQ==", "bodyText": "Done", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r529036801", "createdAt": "2020-11-23T22:28:15Z", "author": {"login": "weymann"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/ConnectedDriveBridgeHandler.java", "diffHunk": "@@ -0,0 +1,192 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bmwconnecteddrive.internal.handler;\n+\n+import static org.openhab.binding.bmwconnecteddrive.internal.utils.Constants.ANONYMOUS;\n+\n+import java.util.Hashtable;\n+import java.util.Optional;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.binding.bmwconnecteddrive.internal.ConnectedDriveConfiguration;\n+import org.openhab.binding.bmwconnecteddrive.internal.discovery.VehicleDiscovery;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.NetworkError;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.discovery.Dealer;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.discovery.VehiclesContainer;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Constants;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Converter;\n+import org.openhab.core.config.discovery.DiscoveryService;\n+import org.openhab.core.io.net.http.HttpClientFactory;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseBridgeHandler;\n+import org.openhab.core.types.Command;\n+import org.osgi.framework.BundleContext;\n+import org.osgi.framework.ServiceRegistration;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link ConnectedDriveBridgeHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Bernd Weymann - Initial contribution\n+ */\n+@NonNullByDefault\n+public class ConnectedDriveBridgeHandler extends BaseBridgeHandler implements StringResponseCallback {\n+    private final Logger logger = LoggerFactory.getLogger(ConnectedDriveBridgeHandler.class);\n+    private HttpClientFactory httpClientFactory;\n+    private BundleContext bundleContext;\n+    private VehicleDiscovery discoveryService;\n+    private ServiceRegistration<?> discoveryServiceRegstration;\n+    private Optional<ConnectedDriveProxy> proxy = Optional.empty();\n+    private Optional<ConnectedDriveConfiguration> configuration = Optional.empty();\n+    private Optional<ScheduledFuture<?>> refreshJob = Optional.empty();\n+    private Optional<String> troubleshootFingerprint = Optional.empty();\n+\n+    private static final String DISCOVERY_FINGERPRINT = \"discovery-fingerprint\";\n+    private ChannelUID discoveryFingerprintChannel;\n+\n+    public ConnectedDriveBridgeHandler(Bridge bridge, HttpClientFactory hcf, BundleContext bc) {\n+        super(bridge);\n+        httpClientFactory = hcf;\n+        bundleContext = bc;\n+        discoveryService = new VehicleDiscovery(this);\n+        discoveryServiceRegstration = bundleContext.registerService(DiscoveryService.class.getName(), discoveryService,\n+                new Hashtable<>());\n+        discoveryFingerprintChannel = new ChannelUID(bridge.getUID(), DISCOVERY_FINGERPRINT);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (DISCOVERY_FINGERPRINT.equals(channelUID.getIdWithoutGroup()) && command instanceof OnOffType) {\n+            if (command.equals(OnOffType.ON)) {\n+                logger.warn(\n+                        \"###### BMW ConnectedDrive Binding - Discovery Troubleshoot Fingerprint Data - BEGIN ######\");\n+                logger.warn(\"### Discovery Result ###\");\n+                logger.warn(\"{}\", getDiscoveryFingerprint());\n+                logger.warn(\"###### BMW ConnectedDrive Binding - Discovery Troubleshoot Fingerprint Data - END ######\");\n+                updateState(discoveryFingerprintChannel, OnOffType.OFF);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        updateStatus(ThingStatus.UNKNOWN);\n+        configuration = Optional.of(getConfigAs(ConnectedDriveConfiguration.class));\n+        if (configuration.isPresent()) {\n+            proxy = Optional.of(new ConnectedDriveProxy(httpClientFactory, configuration.get()));\n+            // give the system some time to create all predefined Vehicles\n+            scheduler.schedule(this::requestVehicles, 5, TimeUnit.SECONDS);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODEwNDU2Mg=="}, "originalCommit": {"oid": "e0bfe93e13df4a3c5de5f8819b94ebf795664904"}, "originalPosition": 96}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMxMTQxODU3OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/utils/BimmerConstants.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMVQwNzowNzozMFrOH3pBPQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yM1QyMjoxNDozOVrOH4hdBw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODEwNTc4OQ==", "bodyText": "Use Set.of", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r528105789", "createdAt": "2020-11-21T07:07:30Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/utils/BimmerConstants.java", "diffHunk": "@@ -0,0 +1,49 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bmwconnecteddrive.internal.utils;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+\n+/**\n+ * The {@link BimmerConstants} This class holds the important constants for the BMW Connected Drive Authorization. They\n+ * are taken from the Bimmercode from github {@link https://github.com/bimmerconnected/bimmer_connected}\n+ * File defining these constants\n+ * {@link https://github.com/bimmerconnected/bimmer_connected/blob/master/bimmer_connected/account.py}\n+ * https://customer.bmwgroup.com/one/app/oauth.js\n+ *\n+ * @author Bernd Weymann - Initial contribution\n+ */\n+@SuppressWarnings(\"serial\")\n+@NonNullByDefault\n+public class BimmerConstants {\n+\n+    public static final String SERVER_NORTH_AMERICA = \"b2vapi.bmwgroup.us\";\n+    public static final String SERVER_CHINA = \"b2vapi.bmwgroup.cn:859\";\n+    public static final String SERVER_ROW = \"b2vapi.bmwgroup.com\";\n+    public static final Map<String, String> SERVER_MAP = new HashMap<String, String>() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e0bfe93e13df4a3c5de5f8819b94ebf795664904"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTAzMDQwNw==", "bodyText": "Used Map.of", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r529030407", "createdAt": "2020-11-23T22:14:39Z", "author": {"login": "weymann"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/utils/BimmerConstants.java", "diffHunk": "@@ -0,0 +1,49 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bmwconnecteddrive.internal.utils;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+\n+/**\n+ * The {@link BimmerConstants} This class holds the important constants for the BMW Connected Drive Authorization. They\n+ * are taken from the Bimmercode from github {@link https://github.com/bimmerconnected/bimmer_connected}\n+ * File defining these constants\n+ * {@link https://github.com/bimmerconnected/bimmer_connected/blob/master/bimmer_connected/account.py}\n+ * https://customer.bmwgroup.com/one/app/oauth.js\n+ *\n+ * @author Bernd Weymann - Initial contribution\n+ */\n+@SuppressWarnings(\"serial\")\n+@NonNullByDefault\n+public class BimmerConstants {\n+\n+    public static final String SERVER_NORTH_AMERICA = \"b2vapi.bmwgroup.us\";\n+    public static final String SERVER_CHINA = \"b2vapi.bmwgroup.cn:859\";\n+    public static final String SERVER_ROW = \"b2vapi.bmwgroup.com\";\n+    public static final Map<String, String> SERVER_MAP = new HashMap<String, String>() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODEwNTc4OQ=="}, "originalCommit": {"oid": "e0bfe93e13df4a3c5de5f8819b94ebf795664904"}, "originalPosition": 36}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMxMTQyMDE0OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/utils/Constants.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMVQwNzowNzo1NVrOH3pCXw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yM1QyMjoxNToxNlrOH4heRA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODEwNjA3OQ==", "bodyText": "and here", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r528106079", "createdAt": "2020-11-21T07:07:55Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/utils/Constants.java", "diffHunk": "@@ -0,0 +1,76 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bmwconnecteddrive.internal.utils;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+\n+/**\n+ * The {@link Constants} General Constant Definitions\n+ *\n+ * @author Bernd Weymann - Initial contribution\n+ */\n+@NonNullByDefault\n+public class Constants {\n+    // For Vehicle Status\n+    public static final String OK = \"Ok\";\n+    public static final String ACTIVE = \"ACTIVE\";\n+    public static final String NOT_ACTIVE = \"NOT ACTIVE\";\n+    public static final String OPEN = \"OPEN\";\n+    public static final String INVALID = \"INVALID\";\n+    public static final String CLOSED = \"CLOSED\";\n+    public static final String INTERMEDIATE = \"INTERMEDIATE\";\n+    public static final String UNKNOWN = \"UNKOWN\";\n+    public static final String NO_SERVICE_REQUEST = \"No Service Requests\";\n+    public static final String UTC_APPENDIX = \"-01T12:00:00\";\n+    public static final String NULL_DATE = \"1900-01-01T00:00:00\";\n+\n+    // Services to query\n+    public static final String SERVICES_SUPPORTED = \"Services Supported\";\n+    public static final String STATISTICS = \"Statistics\";\n+    public static final String LAST_DESTINATIONS = \"LastDestinations\";\n+\n+    // Services in Discovery\n+    public static final String ACTIVATED = \"ACTIVATED\";\n+    public static final String SUPPORTED = \"SUPPORTED\";\n+    public static final String NOT_SUPPORTED = \"NOT_SUPPORTED\";\n+\n+    // General Constants for String concatenation\n+    public static final String NULL = \"null\";\n+    public static final String SPACE = \" \";\n+    public static final String UNDERLINE = \"_\";\n+    public static final String HYPHEN = \" - \";\n+    public static final String PLUS = \"+\";\n+    public static final String EMPTY = \"\";\n+    public static final String COMMA = \",\";\n+    public static final String QUESTION = \"?\";\n+\n+    public static final String ANONYMOUS = \"ANONYMOUS\";\n+    public static final int MILES_TO_FEET_FACTOR = 5280;\n+    public static final String EMPTY_VEHICLES = \"{}\";\n+\n+    @SuppressWarnings(\"serial\")\n+    public static final Map<String, String> DAYS = new HashMap<String, String>() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e0bfe93e13df4a3c5de5f8819b94ebf795664904"}, "originalPosition": 65}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTAzMDcyNA==", "bodyText": "used Map.of as above", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r529030724", "createdAt": "2020-11-23T22:15:16Z", "author": {"login": "weymann"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/utils/Constants.java", "diffHunk": "@@ -0,0 +1,76 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bmwconnecteddrive.internal.utils;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+\n+/**\n+ * The {@link Constants} General Constant Definitions\n+ *\n+ * @author Bernd Weymann - Initial contribution\n+ */\n+@NonNullByDefault\n+public class Constants {\n+    // For Vehicle Status\n+    public static final String OK = \"Ok\";\n+    public static final String ACTIVE = \"ACTIVE\";\n+    public static final String NOT_ACTIVE = \"NOT ACTIVE\";\n+    public static final String OPEN = \"OPEN\";\n+    public static final String INVALID = \"INVALID\";\n+    public static final String CLOSED = \"CLOSED\";\n+    public static final String INTERMEDIATE = \"INTERMEDIATE\";\n+    public static final String UNKNOWN = \"UNKOWN\";\n+    public static final String NO_SERVICE_REQUEST = \"No Service Requests\";\n+    public static final String UTC_APPENDIX = \"-01T12:00:00\";\n+    public static final String NULL_DATE = \"1900-01-01T00:00:00\";\n+\n+    // Services to query\n+    public static final String SERVICES_SUPPORTED = \"Services Supported\";\n+    public static final String STATISTICS = \"Statistics\";\n+    public static final String LAST_DESTINATIONS = \"LastDestinations\";\n+\n+    // Services in Discovery\n+    public static final String ACTIVATED = \"ACTIVATED\";\n+    public static final String SUPPORTED = \"SUPPORTED\";\n+    public static final String NOT_SUPPORTED = \"NOT_SUPPORTED\";\n+\n+    // General Constants for String concatenation\n+    public static final String NULL = \"null\";\n+    public static final String SPACE = \" \";\n+    public static final String UNDERLINE = \"_\";\n+    public static final String HYPHEN = \" - \";\n+    public static final String PLUS = \"+\";\n+    public static final String EMPTY = \"\";\n+    public static final String COMMA = \",\";\n+    public static final String QUESTION = \"?\";\n+\n+    public static final String ANONYMOUS = \"ANONYMOUS\";\n+    public static final int MILES_TO_FEET_FACTOR = 5280;\n+    public static final String EMPTY_VEHICLES = \"{}\";\n+\n+    @SuppressWarnings(\"serial\")\n+    public static final Map<String, String> DAYS = new HashMap<String, String>() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODEwNjA3OQ=="}, "originalCommit": {"oid": "e0bfe93e13df4a3c5de5f8819b94ebf795664904"}, "originalPosition": 65}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMxMTQyMzMwOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/utils/Converter.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMVQwNzowODo0OVrOH3pEew==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yM1QyMjoyMjoxOFrOH4hrtQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODEwNjYxOQ==", "bodyText": "10 to the power of 1? Why not just return 10.0?", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r528106619", "createdAt": "2020-11-21T07:08:49Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/utils/Converter.java", "diffHunk": "@@ -0,0 +1,151 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bmwconnecteddrive.internal.utils;\n+\n+import java.time.LocalDateTime;\n+import java.time.ZoneId;\n+import java.time.ZonedDateTime;\n+import java.time.format.DateTimeFormatter;\n+import java.time.format.DateTimeParseException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+\n+import com.google.gson.Gson;\n+\n+/**\n+ * The {@link Converter} Conversion Helpers\n+ *\n+ * @author Bernd Weymann - Initial contribution\n+ */\n+@NonNullByDefault\n+public class Converter {\n+    public static final DateTimeFormatter SERVICE_DATE_INPUT_PATTERN = DateTimeFormatter.ofPattern(\"yyyy-MM-dd\");\n+    public static final DateTimeFormatter SERVICE_DATE_OUTPUT_PATTERN = DateTimeFormatter.ofPattern(\"MMM yyyy\");\n+\n+    public static final String LOCAL_DATE_INPUT_PATTERN_STRING = \"dd.MM.yyyy HH:mm\";\n+    public static final DateTimeFormatter LOCAL_DATE_INPUT_PATTERN = DateTimeFormatter\n+            .ofPattern(LOCAL_DATE_INPUT_PATTERN_STRING);\n+\n+    public static final String DATE_INPUT_PATTERN_STRING = \"yyyy-MM-dd'T'HH:mm:ss\";\n+    public static final DateTimeFormatter DATE_INPUT_PATTERN = DateTimeFormatter.ofPattern(DATE_INPUT_PATTERN_STRING);\n+\n+    public static final String DATE_INPUT_ZONE_PATTERN_STRING = \"yyyy-MM-dd'T'HH:mm:ssZ\";\n+    public static final DateTimeFormatter DATE_INPUT_ZONE_PATTERN = DateTimeFormatter\n+            .ofPattern(DATE_INPUT_ZONE_PATTERN_STRING);\n+\n+    public static final DateTimeFormatter DATE_OUTPUT_PATTERN = DateTimeFormatter.ofPattern(\"dd.MM.yyyy HH:mm\");\n+\n+    private static final Gson GSON = new Gson();\n+\n+    public static double round(double value) {\n+        double scale = Math.pow(10, 1);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e0bfe93e13df4a3c5de5f8819b94ebf795664904"}, "originalPosition": 52}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTAzNDE2NQ==", "bodyText": "Right. It's a leftover from previous round function which allowed configurable digits after comma. Default is now 1 digit so I put it as constant.", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r529034165", "createdAt": "2020-11-23T22:22:18Z", "author": {"login": "weymann"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/utils/Converter.java", "diffHunk": "@@ -0,0 +1,151 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bmwconnecteddrive.internal.utils;\n+\n+import java.time.LocalDateTime;\n+import java.time.ZoneId;\n+import java.time.ZonedDateTime;\n+import java.time.format.DateTimeFormatter;\n+import java.time.format.DateTimeParseException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+\n+import com.google.gson.Gson;\n+\n+/**\n+ * The {@link Converter} Conversion Helpers\n+ *\n+ * @author Bernd Weymann - Initial contribution\n+ */\n+@NonNullByDefault\n+public class Converter {\n+    public static final DateTimeFormatter SERVICE_DATE_INPUT_PATTERN = DateTimeFormatter.ofPattern(\"yyyy-MM-dd\");\n+    public static final DateTimeFormatter SERVICE_DATE_OUTPUT_PATTERN = DateTimeFormatter.ofPattern(\"MMM yyyy\");\n+\n+    public static final String LOCAL_DATE_INPUT_PATTERN_STRING = \"dd.MM.yyyy HH:mm\";\n+    public static final DateTimeFormatter LOCAL_DATE_INPUT_PATTERN = DateTimeFormatter\n+            .ofPattern(LOCAL_DATE_INPUT_PATTERN_STRING);\n+\n+    public static final String DATE_INPUT_PATTERN_STRING = \"yyyy-MM-dd'T'HH:mm:ss\";\n+    public static final DateTimeFormatter DATE_INPUT_PATTERN = DateTimeFormatter.ofPattern(DATE_INPUT_PATTERN_STRING);\n+\n+    public static final String DATE_INPUT_ZONE_PATTERN_STRING = \"yyyy-MM-dd'T'HH:mm:ssZ\";\n+    public static final DateTimeFormatter DATE_INPUT_ZONE_PATTERN = DateTimeFormatter\n+            .ofPattern(DATE_INPUT_ZONE_PATTERN_STRING);\n+\n+    public static final DateTimeFormatter DATE_OUTPUT_PATTERN = DateTimeFormatter.ofPattern(\"dd.MM.yyyy HH:mm\");\n+\n+    private static final Gson GSON = new Gson();\n+\n+    public static double round(double value) {\n+        double scale = Math.pow(10, 1);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODEwNjYxOQ=="}, "originalCommit": {"oid": "e0bfe93e13df4a3c5de5f8819b94ebf795664904"}, "originalPosition": 52}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMxMTQ0ODY1OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/resources/OH-INF/thing/destination-channel-types.xml", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMVQwNzoxNToyOVrOH3pW-w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQxNjo0MzoyNlrOH5Lolg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODExMTM1NQ==", "bodyText": "Is this supposed to be a number instead?", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r528111355", "createdAt": "2020-11-21T07:15:29Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/resources/OH-INF/thing/destination-channel-types.xml", "diffHunk": "@@ -0,0 +1,30 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"bmwconnecteddrive\"\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\t<channel-type id=\"destination-name-channel\">\n+\t\t<item-type>String</item-type>\n+\t\t<label>Destination Name</label>\n+\t</channel-type>\n+\t<channel-type id=\"destination-latitude-channel\">\n+\t\t<item-type>Number</item-type>\n+\t\t<label>Destination Latitude</label>\n+\t</channel-type>\n+\t<channel-type id=\"destination-longitude-channel\">\n+\t\t<item-type>Number</item-type>\n+\t\t<label>Destination Longitude </label>\n+\t</channel-type>\n+\t<channel-type id=\"destination-size-channel\">\n+\t\t<item-type>String</item-type>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e0bfe93e13df4a3c5de5f8819b94ebf795664904"}, "originalPosition": 19}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTcyMTQ5NA==", "bodyText": "Sure, checked also other size values - they are ok.", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r529721494", "createdAt": "2020-11-24T16:43:26Z", "author": {"login": "weymann"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/resources/OH-INF/thing/destination-channel-types.xml", "diffHunk": "@@ -0,0 +1,30 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"bmwconnecteddrive\"\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\t<channel-type id=\"destination-name-channel\">\n+\t\t<item-type>String</item-type>\n+\t\t<label>Destination Name</label>\n+\t</channel-type>\n+\t<channel-type id=\"destination-latitude-channel\">\n+\t\t<item-type>Number</item-type>\n+\t\t<label>Destination Latitude</label>\n+\t</channel-type>\n+\t<channel-type id=\"destination-longitude-channel\">\n+\t\t<item-type>Number</item-type>\n+\t\t<label>Destination Longitude </label>\n+\t</channel-type>\n+\t<channel-type id=\"destination-size-channel\">\n+\t\t<item-type>String</item-type>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODExMTM1NQ=="}, "originalCommit": {"oid": "e0bfe93e13df4a3c5de5f8819b94ebf795664904"}, "originalPosition": 19}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMxMTQ1MzY4OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/resources/OH-INF/thing/bridge-connected-drive.xml", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMVQwNzoxNjo1NVrOH3pahw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQxNjozODoxNFrOH5LZyA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODExMjI2Mw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\t\t\t<label>Password</label>\n          \n          \n            \n            \t\t\t\t<description>BMW Connected Drive Password</description>\n          \n          \n            \n            \t\t\t\t<context>password</context>\n          \n          \n            \n            \t\t\t\t<label>Password</label>\n          \n          \n            \n            \t\t\t\t<description>BMW Connected Drive Password</description>", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r528112263", "createdAt": "2020-11-21T07:16:55Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/resources/OH-INF/thing/bridge-connected-drive.xml", "diffHunk": "@@ -0,0 +1,44 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"bmwconnecteddrive\"\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\n+\t<!-- Sample Thing Type -->\n+\t<bridge-type id=\"account\">\n+\t\t<label>BMW ConnectedDrive Account</label>\n+\t\t<description>Access to BMW ConnectedDrive Portal for a specific user</description>\n+\n+\t\t<channels>\n+\t\t\t<channel id=\"discovery-fingerprint\" typeId=\"discovery-fingerprint-channel\"/>\n+\t\t</channels>\n+\n+\t\t<config-description>\n+\t\t\t<parameter name=\"userName\" type=\"text\" required=\"true\">\n+\t\t\t\t<label>Username</label>\n+\t\t\t\t<description>BMW Connected Drive Username</description>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"password\" type=\"text\" required=\"true\">\n+\t\t\t\t<label>Password</label>\n+\t\t\t\t<description>BMW Connected Drive Password</description>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e0bfe93e13df4a3c5de5f8819b94ebf795664904"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTcxNzcwNA==", "bodyText": "Added context", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r529717704", "createdAt": "2020-11-24T16:38:14Z", "author": {"login": "weymann"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/resources/OH-INF/thing/bridge-connected-drive.xml", "diffHunk": "@@ -0,0 +1,44 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"bmwconnecteddrive\"\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\n+\t<!-- Sample Thing Type -->\n+\t<bridge-type id=\"account\">\n+\t\t<label>BMW ConnectedDrive Account</label>\n+\t\t<description>Access to BMW ConnectedDrive Portal for a specific user</description>\n+\n+\t\t<channels>\n+\t\t\t<channel id=\"discovery-fingerprint\" typeId=\"discovery-fingerprint-channel\"/>\n+\t\t</channels>\n+\n+\t\t<config-description>\n+\t\t\t<parameter name=\"userName\" type=\"text\" required=\"true\">\n+\t\t\t\t<label>Username</label>\n+\t\t\t\t<description>BMW Connected Drive Username</description>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"password\" type=\"text\" required=\"true\">\n+\t\t\t\t<label>Password</label>\n+\t\t\t\t<description>BMW Connected Drive Password</description>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODExMjI2Mw=="}, "originalCommit": {"oid": "e0bfe93e13df4a3c5de5f8819b94ebf795664904"}, "originalPosition": 23}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMyMzAxNTQ5OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.bmwconnecteddrive/README.md", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQyMDoyMDo1OVrOH5Tvhw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yN1QwMDozNjo0MlrOILnLNw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTg1NDM0Mw==", "bodyText": "Just picking a random channel here: Please note that channel labels are expected to be as short as possible. Guideline is 2-3 words with up to 25 chars. Would be great if you could go over the list and check for potential shortening opportunities. :-)", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r529854343", "createdAt": "2020-11-24T20:20:59Z", "author": {"login": "kaikreuzer"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/README.md", "diffHunk": "@@ -0,0 +1,862 @@\n+# BMW ConnectedDrive Binding\n+\n+<img align=\"right\" src=\"./doc/bmw-connected.png\" width=\"150\" height=\"150\"/>\n+\n+The Binding provides a Connection between [BMWs ConnectedDrive Portal](https://www.bmw-connecteddrive.com/country-region-select/country-region-selection.html) and openHAB.\n+All Vehicles connected to an Account will be detected by the Discovery with the correct type \n+\n+* Conventional Fuel Vehicle\n+* Plugin-Hybrid Electrical Vehicle \n+* Battery Electric Vehicle with Range Extender\n+* Battery Electric Vehicle \n+\n+In addition Properties are attached with Information and Services provided by this Vehicle.\n+The provided data depends on \n+\n+1. the [Type](#Things) and \n+2. the Services mentioned in [Properties](#properties)\n+\n+Different Channel Groups are clustering all informations.\n+Check for each Group if it's supported for this Vehicle.\n+\n+Please note **this isn't a real-time Binding**. \n+If the Door is opened the state isn't transmitted and changed immediately. \n+This isn't a flaw in the Binding itself because the state in BMWs own ConnectedDrive App is also updated with some delay. \n+\n+## Supported Things\n+\n+### Bridge\n+\n+The Bridge establishes the Connection between BMW ConnectedDrive Portal and openHAB.\n+\n+| Name                       | Bridge Type ID | Description                                                |\n+|----------------------------|----------------|------------------------------------------------------------|\n+| BMW ConnectedDrive Account | account        | Access to BMW ConnectedDrive Portal for a specific user    |\n+\n+\n+### Things\n+\n+Four different Vehicle Types are provided. \n+They differ in the supported Channel Groups & Channels. \n+Conventional Fuel Vehicles have no _Charging Profile_, Electric Vehicles don't provide a _Fuel Range_. \n+For Hybrid Vehicles in addition to _Fuel and Electric Range_ the _Hybrid Range_ is shown.\n+ \n+| Name                                | Thing Type ID | Supported Channel Groups                                             |\n+|-------------------------------------|---------------|----------------------------------------------------------------------|\n+| BMW Electric Vehicle                | BEV           | status, range, location, service, check, charge, image, troubleshoot |\n+| BMW Electric Vehicle with REX       | BEV_REX       | status, range, location, service, check, charge, image, troubleshoot |\n+| BMW Plug-In-Hybrid Electric Vehicle | PHEV          | status, range, location, service, check, charge, image, troubleshoot |\n+| BMW Conventional Vehicle            | CONV          | status, range, location, service, check, image, troubleshoot         |\n+\n+ \n+#### Properties\n+\n+<img align=\"right\" src=\"./doc/properties.png\" width=\"500\" height=\"600\"/>\n+\n+For each Vehicle Properties are available. \n+Basically 3 Types of Information are registered as Properties\n+\n+* Informations regarding your Dealer with Address and Phone Number\n+* Which services are available / not available\n+* Vehicle Properties like Color, Model Type, Drive Train and Construction Year\n+\n+In the right picture  can see in *Services Activated* e.g. the *DoorLock* and *DoorUnlock* Services are mentioned. \n+This ensures [Channel Group _Remote Services_](#remote-services) is supporting Door lock and Door unlock.\n+\n+In  *Services Supported* the entry *LastDestination* is mentioned.\n+So it's valid to connect Channel Group [Last Destinations](#destinations) in order to display the last 3 Navigation Destinations.\n+\n+| Property Key       | Property Value      |  Supported Channel Groups    |\n+|--------------------|---------------------|------------------------------|\n+| Services Supported | Statistics          | last-trip, lifetime          |\n+| Services Supported | LastDestinations    | destinations                 |\n+| Services Activated | list of services    | remote                       |\n+\n+\n+## Discovery\n+\n+Auto Discovery is starting after creation of the Bridge towards BMW ConnectedDrive. \n+A list of your registered Vehicles is queried and all found Vehicles are added in Inbox.\n+Unique Identifier is the *Vehicle Identification Number* (VIN). \n+If a Thing is already declared in a  *.things configuration* Discovery won't highlight it again.\n+Properties will be attached to predefined Vehicles if the VIN is matching.\n+\n+## Configuration\n+\n+### Bridge\n+\n+| Parameter       | Type    | Description                                                             |           \n+|-----------------|---------|-------------------------------------------------------------------------|\n+| userName        | text    | BMW Connected Drive Username                  |\n+| password        | text    | BMW Connected Drive Password                  |\n+| region          | text    | Select Region in order to connect to the appropriate BMW Server.   |\n+\n+The region Configuration has 3 different possibilities\n+\n+* _NORTH_AMERICA_\n+* _CHINA_\n+* _ROW_ for Rest of World\n+\n+### Thing\n+\n+Same Configuration is needed for all Things\n+\n+| Parameter       | Type    | Description                           |           \n+|-----------------|---------|---------------------------------------|\n+| vin             | text    | Vehicle Identification Number (VIN)   |\n+| refreshInterval | integer | Refresh Interval in Minutes           |\n+| units           | text    | Unit Selection                        |\n+| imageSize       | integer | Image Size                            |\n+| imageViewport   | text    | Image Viewport                        |\n+\n+The units can be configured in 3 ways\n+\n+* _AUTODETECT_ selects Miles for US & UK, Kilometer otherwise\n+* _METRIC_ selects directly Kilometers\n+* _IMPERIAL_ selects directly Miles\n+\n+The imageVieport allows to show the Vehicle from different angels.\n+Possible values are \n+\n+* FRONT\n+* REAR\n+* SIDE\n+* DASHBOARD\n+* DRIVERDOOR\n+\n+## Channels\n+\n+There are many Channels available for each Vehicle. \n+For better overview they are clustered in different Channel Groups.\n+The Channel Groups are different for the Vehicle Types, on the build-in Sensors of the Vehicle and the activated Services.\n+\n+### Bridge Channels\n+\n+If the Vehicle isn't found in the Discovery force a log of Fingerprint Data which helps to analyze the problem.\n+Please check [TroubleShooting Section](#TroubleShooting) for further advice.\n+\n+| Channel Label         | Channel ID            | Type   | Description                                       |\n+|-----------------------|-----------------------|--------|---------------------------------------------------|\n+| Discovery Fingerprint | discovery-fingerprint | Switch | Forcing a log entry to analyze Discovery Problems |\n+\n+### Thing Channel Groups \n+\n+#### Vehicle Status\n+\n+Reflects Status of the Vehicle.\n+Available for all Vehicles, Read-only.\n+\n+| Channel Label             | Channel Group ID | Channel ID          | Type          | Description                                                                       |\n+|---------------------------|------------------|---------------------|---------------|-----------------------------------------------------------------------------------|\n+| Overall Door Status       | status           | doors               | String        | **Closed** if all closed otherwise **Open**. **Unknown** if no data is delivered  |\n+| Overall Window Status     | status           | windows             | String        | **Closed** if all closed otherwise **Open** or **Intermediate**. **Unknown** if no data is delivered   |\n+| Doors Locked              | status           | lock                | String        | Status if Doors are locked or unlocked                                            |\n+| Next Service Date         | status           | service-date        | DateTime      | Date of Upcoming Service                                                          |\n+| Mileage till Next Service | status           | service-mileage     | Number:Length | Mileage till Upcoming Service                                                     |\n+| Check Control             | status           | check-control       | String        | Indicator if CheckControl is **Active** or **Not Active**. **Unknown** if no data is delivered         |\n+| Charging Status           | status           | charge              | String        | Only available for PHEV, BEV_REX and BEV                                          |\n+| Last Status Timestamp     | status           | last-update         | DateTime      | Date and Time of last status update.                                              |\n+\n+See [further details for DateTime](#last-status-update-timestamp) in case of wrong timestamp values\n+\n+#### Services\n+\n+Group for all upcoming Services with Description, Service Date and / or Service Mileage\n+It's designed as [List Interface](#list-interface) so all upcoming Services can be checked.\n+\n+| Channel Label                  | Channel Group ID | Channel ID          | Type           | \n+|--------------------------------|------------------|---------------------|----------------|\n+| Service Name                   | service          | name                | String         |\n+| Service Date                   | service          | date                | Number         |\n+| Mileage till Service           | service          | mileage             | Number:Length  |\n+| Number of Scheduled Services   | service          | size                | String         |\n+| Current Selected Service Index | service          | index               | Number         |\n+| Select next Service            | service          | next                | Switch         |\n+\n+#### Check Control\n+\n+Group for all current active CheckControl Messages.\n+It's designed as [List Interface](#list-interface) to show all active Messages.\n+\n+| Channel Label                   | Channel Group ID | Channel ID          | Type           | \n+|---------------------------------|------------------|---------------------|----------------|\n+| CheckControl Description        | check            | name                | String         |\n+| CheckControl Mileage Occurrence | check            | mileage             | Number:Length  |\n+| Active CheckControl Messages    | check            | size                | String         |\n+| Selected CheckControl Message   | check            | index               | Number         |\n+| Next CheckControl Message       | check            | next                | Switch         |\n+\n+#### Doors Details\n+\n+Detailed Status of all Doors and Windows\n+Available for all Vehicles, Read-only. \n+\n+| Channel Label              | Channel Group ID | Channel ID              | Type          | \n+|----------------------------|------------------|-------------------------|---------------|\n+| Driver Door                | doors            | driver-front            | String        |\n+| Driver Door Rear           | doors            | driver-rear             | String        |\n+| Passenger Door             | doors            | passenger-front         | String        |\n+| Passenger Door Rear        | doors            | passenger-rear          | String        |\n+| Trunk                      | doors            | trunk                   | String        |\n+| Hood                       | doors            | hood                    | String        |\n+| Driver Door Window         | doors            | window-driver-front     | String        |\n+| Driver Door Rear Window    | doors            | window-driver-rear      | String        |\n+| Passenger Door Window      | doors            | window-passenger-front  | String        |\n+| Passenger Door Rear Window | doors            | window-passenger-rear   | String        |\n+| Rear Window                | doors            | window-rear             | String        |\n+| Sunroof                    | doors            | sunroof                 | String        |\n+\n+Following Strings will be delivered\n+\n+* UNKNOWN - no status data available\n+* INVALID - this item isn't applicable for this Vehicle\n+* CLOSED - the Door / Window is closed\n+* OPEN - the Door / Window is open\n+* INTERMEDIATE - Window in intermediate position, not applicable for Doors\n+\n+#### Range Data\n+\n+Based on Vehicle Type (Thing Type ID) some Channels are presented or not. \n+Conventional Fuel Vehicles don't provide *Electric Range* and Battery Electric Vehicles don't show *Range Fuel*.\n+Hybrid Vehicles have both and in addition *Hybrid Range*.\n+These are Read-only values.\n+\n+| Channel Label         | Channel Group ID | Channel ID            | Type                 | CONV | PHEV | BEV_REX | BEV |\n+|-----------------------|------------------|-----------------------|----------------------|------|------|---------|-----|\n+| Mileage               | range            | mileage               | Number:Length        |  X   |  X   |    X    |  X  |\n+| Fuel Range            | range            | range-fuel            | Number:Length        |  X   |  X   |    X    |     |\n+| Battery Range         | range            | range-electric        | Number:Length        |      |  X   |    X    |  X  | \n+| Hybrid Range          | range            | range-hybrid          | Number:Length        |      |  X   |    X    |     | \n+| Battery Charge Level  | range            | soc                   | Number:Dimensionless |      |  X   |    X    |  X  |\n+| Remaining Fuel        | range            | remaining-fuel        | Number:Volume        |  X   |  X   |    X    |     | \n+| Fuel Range Radius     | range            | range-radius-fuel     | Number:Length        |  X   |  X   |    X    |     | \n+| Electric Range Radius | range            | range-radius-electric | Number:Length        |      |  X   |    X    |  X  | \n+| Hybrid Range Radius   | range            | range-radius-hybrid   | Number:Length        |      |  X   |    X    |     | \n+\n+See Description [Range vs Range Radius](#range-vs-range-radius) to get more information\n+\n+#### Charge Profile\n+\n+Valid for Electric and Hybrid Vehicles\n+These are Read-only values.\n+\n+| Channel Label                      | Channel Group ID | Channel ID          | Type   | \n+|------------------------------------|------------------|---------------------|--------|\n+| Air Conditioning at Departure Time | charge           | profile-climate     | Switch | \n+| Charging Mode for Profile          | charge           | profile-mode        | String | \n+| Charging Window Start Time         | charge           | window-start        | String | \n+| Charging Window End Time           | charge           | window-end          | String | \n+| Timer 1: Departure Time            | charge           | timer1-departure    | String | \n+| Timer 1: Scheduled Days            | charge           | timer1-days         | String | \n+| Timer 1: Enabled                   | charge           | timer1-enabled      | Switch | \n+| Timer 2: Departure Time            | charge           | timer2-departure    | String | \n+| Timer 2: Scheduled Days            | charge           | timer2-days         | String | \n+| Timer 2: Enabled                   | charge           | timer2-enabled      | Switch | \n+| Timer 3: Departure Time            | charge           | timer3-departure    | String | \n+| Timer 3: Scheduled Days            | charge           | timer3-days         | String | \n+| Timer 3: Enabled                   | charge           | timer3-enabled      | Switch | \n+\n+\n+#### Location\n+\n+Available for all Vehicles.\n+These are Read-only values.\n+\n+| Channel Label  | Channel Group ID | Channel ID          | Type         | \n+|----------------|------------------|---------------------|--------------|\n+| Latitude       | location         | latitude            | Number       | \n+| Longitude      | location         | longitude           | Number       |\n+| Heading        | location         | heading             | Number:Angle | \n+\n+#### Last Trip\n+\n+Check [Vehicle Properties](#Properties) if *Statistics* is present in *Services Supported*\n+These are Read-only values.\n+\n+| Channel Label                           | Channel Group ID | Channel ID                   | Type          |\n+|-----------------------------------------|------------------|------------------------------|---------------|\n+| Last Trip Date                          | last-trip        | date                         | DateTime      |\n+| Last Trip Duration                      | last-trip        | duration                     | Number:Time   |\n+| Average Power Consumption per 100 km    | last-trip        | average-consumption          | Number:Power  |\n+| Average Combined Consumption per 100 km | last-trip        | average-combined-consumption | Number:Volume |", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e0bfe93e13df4a3c5de5f8819b94ebf795664904"}, "originalPosition": 281}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTA0NzA5NQ==", "bodyText": "Right, some exceeded the limit. Added some abbreviations and checked the channel ids => all below 25 chars now.", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r549047095", "createdAt": "2020-12-27T00:36:42Z", "author": {"login": "weymann"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/README.md", "diffHunk": "@@ -0,0 +1,862 @@\n+# BMW ConnectedDrive Binding\n+\n+<img align=\"right\" src=\"./doc/bmw-connected.png\" width=\"150\" height=\"150\"/>\n+\n+The Binding provides a Connection between [BMWs ConnectedDrive Portal](https://www.bmw-connecteddrive.com/country-region-select/country-region-selection.html) and openHAB.\n+All Vehicles connected to an Account will be detected by the Discovery with the correct type \n+\n+* Conventional Fuel Vehicle\n+* Plugin-Hybrid Electrical Vehicle \n+* Battery Electric Vehicle with Range Extender\n+* Battery Electric Vehicle \n+\n+In addition Properties are attached with Information and Services provided by this Vehicle.\n+The provided data depends on \n+\n+1. the [Type](#Things) and \n+2. the Services mentioned in [Properties](#properties)\n+\n+Different Channel Groups are clustering all informations.\n+Check for each Group if it's supported for this Vehicle.\n+\n+Please note **this isn't a real-time Binding**. \n+If the Door is opened the state isn't transmitted and changed immediately. \n+This isn't a flaw in the Binding itself because the state in BMWs own ConnectedDrive App is also updated with some delay. \n+\n+## Supported Things\n+\n+### Bridge\n+\n+The Bridge establishes the Connection between BMW ConnectedDrive Portal and openHAB.\n+\n+| Name                       | Bridge Type ID | Description                                                |\n+|----------------------------|----------------|------------------------------------------------------------|\n+| BMW ConnectedDrive Account | account        | Access to BMW ConnectedDrive Portal for a specific user    |\n+\n+\n+### Things\n+\n+Four different Vehicle Types are provided. \n+They differ in the supported Channel Groups & Channels. \n+Conventional Fuel Vehicles have no _Charging Profile_, Electric Vehicles don't provide a _Fuel Range_. \n+For Hybrid Vehicles in addition to _Fuel and Electric Range_ the _Hybrid Range_ is shown.\n+ \n+| Name                                | Thing Type ID | Supported Channel Groups                                             |\n+|-------------------------------------|---------------|----------------------------------------------------------------------|\n+| BMW Electric Vehicle                | BEV           | status, range, location, service, check, charge, image, troubleshoot |\n+| BMW Electric Vehicle with REX       | BEV_REX       | status, range, location, service, check, charge, image, troubleshoot |\n+| BMW Plug-In-Hybrid Electric Vehicle | PHEV          | status, range, location, service, check, charge, image, troubleshoot |\n+| BMW Conventional Vehicle            | CONV          | status, range, location, service, check, image, troubleshoot         |\n+\n+ \n+#### Properties\n+\n+<img align=\"right\" src=\"./doc/properties.png\" width=\"500\" height=\"600\"/>\n+\n+For each Vehicle Properties are available. \n+Basically 3 Types of Information are registered as Properties\n+\n+* Informations regarding your Dealer with Address and Phone Number\n+* Which services are available / not available\n+* Vehicle Properties like Color, Model Type, Drive Train and Construction Year\n+\n+In the right picture  can see in *Services Activated* e.g. the *DoorLock* and *DoorUnlock* Services are mentioned. \n+This ensures [Channel Group _Remote Services_](#remote-services) is supporting Door lock and Door unlock.\n+\n+In  *Services Supported* the entry *LastDestination* is mentioned.\n+So it's valid to connect Channel Group [Last Destinations](#destinations) in order to display the last 3 Navigation Destinations.\n+\n+| Property Key       | Property Value      |  Supported Channel Groups    |\n+|--------------------|---------------------|------------------------------|\n+| Services Supported | Statistics          | last-trip, lifetime          |\n+| Services Supported | LastDestinations    | destinations                 |\n+| Services Activated | list of services    | remote                       |\n+\n+\n+## Discovery\n+\n+Auto Discovery is starting after creation of the Bridge towards BMW ConnectedDrive. \n+A list of your registered Vehicles is queried and all found Vehicles are added in Inbox.\n+Unique Identifier is the *Vehicle Identification Number* (VIN). \n+If a Thing is already declared in a  *.things configuration* Discovery won't highlight it again.\n+Properties will be attached to predefined Vehicles if the VIN is matching.\n+\n+## Configuration\n+\n+### Bridge\n+\n+| Parameter       | Type    | Description                                                             |           \n+|-----------------|---------|-------------------------------------------------------------------------|\n+| userName        | text    | BMW Connected Drive Username                  |\n+| password        | text    | BMW Connected Drive Password                  |\n+| region          | text    | Select Region in order to connect to the appropriate BMW Server.   |\n+\n+The region Configuration has 3 different possibilities\n+\n+* _NORTH_AMERICA_\n+* _CHINA_\n+* _ROW_ for Rest of World\n+\n+### Thing\n+\n+Same Configuration is needed for all Things\n+\n+| Parameter       | Type    | Description                           |           \n+|-----------------|---------|---------------------------------------|\n+| vin             | text    | Vehicle Identification Number (VIN)   |\n+| refreshInterval | integer | Refresh Interval in Minutes           |\n+| units           | text    | Unit Selection                        |\n+| imageSize       | integer | Image Size                            |\n+| imageViewport   | text    | Image Viewport                        |\n+\n+The units can be configured in 3 ways\n+\n+* _AUTODETECT_ selects Miles for US & UK, Kilometer otherwise\n+* _METRIC_ selects directly Kilometers\n+* _IMPERIAL_ selects directly Miles\n+\n+The imageVieport allows to show the Vehicle from different angels.\n+Possible values are \n+\n+* FRONT\n+* REAR\n+* SIDE\n+* DASHBOARD\n+* DRIVERDOOR\n+\n+## Channels\n+\n+There are many Channels available for each Vehicle. \n+For better overview they are clustered in different Channel Groups.\n+The Channel Groups are different for the Vehicle Types, on the build-in Sensors of the Vehicle and the activated Services.\n+\n+### Bridge Channels\n+\n+If the Vehicle isn't found in the Discovery force a log of Fingerprint Data which helps to analyze the problem.\n+Please check [TroubleShooting Section](#TroubleShooting) for further advice.\n+\n+| Channel Label         | Channel ID            | Type   | Description                                       |\n+|-----------------------|-----------------------|--------|---------------------------------------------------|\n+| Discovery Fingerprint | discovery-fingerprint | Switch | Forcing a log entry to analyze Discovery Problems |\n+\n+### Thing Channel Groups \n+\n+#### Vehicle Status\n+\n+Reflects Status of the Vehicle.\n+Available for all Vehicles, Read-only.\n+\n+| Channel Label             | Channel Group ID | Channel ID          | Type          | Description                                                                       |\n+|---------------------------|------------------|---------------------|---------------|-----------------------------------------------------------------------------------|\n+| Overall Door Status       | status           | doors               | String        | **Closed** if all closed otherwise **Open**. **Unknown** if no data is delivered  |\n+| Overall Window Status     | status           | windows             | String        | **Closed** if all closed otherwise **Open** or **Intermediate**. **Unknown** if no data is delivered   |\n+| Doors Locked              | status           | lock                | String        | Status if Doors are locked or unlocked                                            |\n+| Next Service Date         | status           | service-date        | DateTime      | Date of Upcoming Service                                                          |\n+| Mileage till Next Service | status           | service-mileage     | Number:Length | Mileage till Upcoming Service                                                     |\n+| Check Control             | status           | check-control       | String        | Indicator if CheckControl is **Active** or **Not Active**. **Unknown** if no data is delivered         |\n+| Charging Status           | status           | charge              | String        | Only available for PHEV, BEV_REX and BEV                                          |\n+| Last Status Timestamp     | status           | last-update         | DateTime      | Date and Time of last status update.                                              |\n+\n+See [further details for DateTime](#last-status-update-timestamp) in case of wrong timestamp values\n+\n+#### Services\n+\n+Group for all upcoming Services with Description, Service Date and / or Service Mileage\n+It's designed as [List Interface](#list-interface) so all upcoming Services can be checked.\n+\n+| Channel Label                  | Channel Group ID | Channel ID          | Type           | \n+|--------------------------------|------------------|---------------------|----------------|\n+| Service Name                   | service          | name                | String         |\n+| Service Date                   | service          | date                | Number         |\n+| Mileage till Service           | service          | mileage             | Number:Length  |\n+| Number of Scheduled Services   | service          | size                | String         |\n+| Current Selected Service Index | service          | index               | Number         |\n+| Select next Service            | service          | next                | Switch         |\n+\n+#### Check Control\n+\n+Group for all current active CheckControl Messages.\n+It's designed as [List Interface](#list-interface) to show all active Messages.\n+\n+| Channel Label                   | Channel Group ID | Channel ID          | Type           | \n+|---------------------------------|------------------|---------------------|----------------|\n+| CheckControl Description        | check            | name                | String         |\n+| CheckControl Mileage Occurrence | check            | mileage             | Number:Length  |\n+| Active CheckControl Messages    | check            | size                | String         |\n+| Selected CheckControl Message   | check            | index               | Number         |\n+| Next CheckControl Message       | check            | next                | Switch         |\n+\n+#### Doors Details\n+\n+Detailed Status of all Doors and Windows\n+Available for all Vehicles, Read-only. \n+\n+| Channel Label              | Channel Group ID | Channel ID              | Type          | \n+|----------------------------|------------------|-------------------------|---------------|\n+| Driver Door                | doors            | driver-front            | String        |\n+| Driver Door Rear           | doors            | driver-rear             | String        |\n+| Passenger Door             | doors            | passenger-front         | String        |\n+| Passenger Door Rear        | doors            | passenger-rear          | String        |\n+| Trunk                      | doors            | trunk                   | String        |\n+| Hood                       | doors            | hood                    | String        |\n+| Driver Door Window         | doors            | window-driver-front     | String        |\n+| Driver Door Rear Window    | doors            | window-driver-rear      | String        |\n+| Passenger Door Window      | doors            | window-passenger-front  | String        |\n+| Passenger Door Rear Window | doors            | window-passenger-rear   | String        |\n+| Rear Window                | doors            | window-rear             | String        |\n+| Sunroof                    | doors            | sunroof                 | String        |\n+\n+Following Strings will be delivered\n+\n+* UNKNOWN - no status data available\n+* INVALID - this item isn't applicable for this Vehicle\n+* CLOSED - the Door / Window is closed\n+* OPEN - the Door / Window is open\n+* INTERMEDIATE - Window in intermediate position, not applicable for Doors\n+\n+#### Range Data\n+\n+Based on Vehicle Type (Thing Type ID) some Channels are presented or not. \n+Conventional Fuel Vehicles don't provide *Electric Range* and Battery Electric Vehicles don't show *Range Fuel*.\n+Hybrid Vehicles have both and in addition *Hybrid Range*.\n+These are Read-only values.\n+\n+| Channel Label         | Channel Group ID | Channel ID            | Type                 | CONV | PHEV | BEV_REX | BEV |\n+|-----------------------|------------------|-----------------------|----------------------|------|------|---------|-----|\n+| Mileage               | range            | mileage               | Number:Length        |  X   |  X   |    X    |  X  |\n+| Fuel Range            | range            | range-fuel            | Number:Length        |  X   |  X   |    X    |     |\n+| Battery Range         | range            | range-electric        | Number:Length        |      |  X   |    X    |  X  | \n+| Hybrid Range          | range            | range-hybrid          | Number:Length        |      |  X   |    X    |     | \n+| Battery Charge Level  | range            | soc                   | Number:Dimensionless |      |  X   |    X    |  X  |\n+| Remaining Fuel        | range            | remaining-fuel        | Number:Volume        |  X   |  X   |    X    |     | \n+| Fuel Range Radius     | range            | range-radius-fuel     | Number:Length        |  X   |  X   |    X    |     | \n+| Electric Range Radius | range            | range-radius-electric | Number:Length        |      |  X   |    X    |  X  | \n+| Hybrid Range Radius   | range            | range-radius-hybrid   | Number:Length        |      |  X   |    X    |     | \n+\n+See Description [Range vs Range Radius](#range-vs-range-radius) to get more information\n+\n+#### Charge Profile\n+\n+Valid for Electric and Hybrid Vehicles\n+These are Read-only values.\n+\n+| Channel Label                      | Channel Group ID | Channel ID          | Type   | \n+|------------------------------------|------------------|---------------------|--------|\n+| Air Conditioning at Departure Time | charge           | profile-climate     | Switch | \n+| Charging Mode for Profile          | charge           | profile-mode        | String | \n+| Charging Window Start Time         | charge           | window-start        | String | \n+| Charging Window End Time           | charge           | window-end          | String | \n+| Timer 1: Departure Time            | charge           | timer1-departure    | String | \n+| Timer 1: Scheduled Days            | charge           | timer1-days         | String | \n+| Timer 1: Enabled                   | charge           | timer1-enabled      | Switch | \n+| Timer 2: Departure Time            | charge           | timer2-departure    | String | \n+| Timer 2: Scheduled Days            | charge           | timer2-days         | String | \n+| Timer 2: Enabled                   | charge           | timer2-enabled      | Switch | \n+| Timer 3: Departure Time            | charge           | timer3-departure    | String | \n+| Timer 3: Scheduled Days            | charge           | timer3-days         | String | \n+| Timer 3: Enabled                   | charge           | timer3-enabled      | Switch | \n+\n+\n+#### Location\n+\n+Available for all Vehicles.\n+These are Read-only values.\n+\n+| Channel Label  | Channel Group ID | Channel ID          | Type         | \n+|----------------|------------------|---------------------|--------------|\n+| Latitude       | location         | latitude            | Number       | \n+| Longitude      | location         | longitude           | Number       |\n+| Heading        | location         | heading             | Number:Angle | \n+\n+#### Last Trip\n+\n+Check [Vehicle Properties](#Properties) if *Statistics* is present in *Services Supported*\n+These are Read-only values.\n+\n+| Channel Label                           | Channel Group ID | Channel ID                   | Type          |\n+|-----------------------------------------|------------------|------------------------------|---------------|\n+| Last Trip Date                          | last-trip        | date                         | DateTime      |\n+| Last Trip Duration                      | last-trip        | duration                     | Number:Time   |\n+| Average Power Consumption per 100 km    | last-trip        | average-consumption          | Number:Power  |\n+| Average Combined Consumption per 100 km | last-trip        | average-combined-consumption | Number:Volume |", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTg1NDM0Mw=="}, "originalCommit": {"oid": "e0bfe93e13df4a3c5de5f8819b94ebf795664904"}, "originalPosition": 281}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ1OTE0NjgxOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.bmwconnecteddrive/.gitignore", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yOVQyMzowOTozM1rOIMaLIA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNVQyMjoxOToyMVrOIOpofw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTg4MjY1Ng==", "bodyText": "Did you add this by intention?", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r549882656", "createdAt": "2020-12-29T23:09:33Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/.gitignore", "diffHunk": "@@ -0,0 +1 @@\n+/.README.md.html", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "71d5496aba829f6628dd1676734e39c5a7d14f2f"}, "originalPosition": 1}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDgxMTY1OA==", "bodyText": "Yes, ignoring the precompiled readme.md from eclipse. Is this a problem?", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r550811658", "createdAt": "2021-01-01T21:59:16Z", "author": {"login": "weymann"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/.gitignore", "diffHunk": "@@ -0,0 +1 @@\n+/.README.md.html", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTg4MjY1Ng=="}, "originalCommit": {"oid": "71d5496aba829f6628dd1676734e39c5a7d14f2f"}, "originalPosition": 1}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDk5NDEwMg==", "bodyText": "It would be a bit strange to only ignore it in your binding. You can define ignore patterns in your local git configuration if the file bothers you.", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r550994102", "createdAt": "2021-01-03T11:37:40Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/.gitignore", "diffHunk": "@@ -0,0 +1 @@\n+/.README.md.html", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTg4MjY1Ng=="}, "originalCommit": {"oid": "71d5496aba829f6628dd1676734e39c5a7d14f2f"}, "originalPosition": 1}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjIzMzA4Nw==", "bodyText": "ok", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r552233087", "createdAt": "2021-01-05T22:19:21Z", "author": {"login": "weymann"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/.gitignore", "diffHunk": "@@ -0,0 +1 @@\n+/.README.md.html", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTg4MjY1Ng=="}, "originalCommit": {"oid": "71d5496aba829f6628dd1676734e39c5a7d14f2f"}, "originalPosition": 1}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ1OTE1ODQzOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.bmwconnecteddrive/README.md", "isResolved": true, "comments": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yOVQyMzoxNzozOVrOIMaRQg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0xMFQyMDoyOTo0NFrOIjdgkQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTg4NDIyNg==", "bodyText": "Is this setting used for the representation within OH or for intepreting the API calls?", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r549884226", "createdAt": "2020-12-29T23:17:39Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/README.md", "diffHunk": "@@ -0,0 +1,686 @@\n+# BMW ConnectedDrive Binding\n+\n+<img align=\"right\" src=\"./doc/bmw-connected.png\" width=\"150\" height=\"150\"/>\n+\n+The binding provides a connection between [BMW's ConnectedDrive Portal](https://www.bmw-connecteddrive.com/country-region-select/country-region-selection.html) and openHAB.\n+All vehicles connected to an account will be detected by the discovery with the correct type \n+\n+* Conventional Fuel Vehicle\n+* Plugin-Hybrid Electrical Vehicle \n+* Battery Electric Vehicle with Range Extender\n+* Battery Electric Vehicle \n+\n+In addition properties are attached with information and services provided by this vehicle.\n+The provided data depends on \n+\n+1. the [Thing Type](#things) and \n+2. the [Properties](#properties) mentioned in Services\n+\n+Different channel groups are clustering all informations.\n+Check for each group if it's supported for this Vehicle.\n+\n+Please note **this isn't a real-time binding**. \n+If a door is opened the state isn't transmitted and changed immediately. \n+This isn't a flaw in the binding itself because the state in BMW's own ConnectedDrive App is also updated with some delay. \n+\n+## Supported Things\n+\n+### Bridge\n+\n+The bridge establishes the connection between BMW's ConnectedDrive Portal and openHAB.\n+\n+| Name                       | Bridge Type ID | Description                                                |\n+|----------------------------|----------------|------------------------------------------------------------|\n+| BMW ConnectedDrive Account | account        | Access to BMW ConnectedDrive Portal for a specific user    |\n+\n+\n+### Things\n+\n+Four different vehicle types are provided. \n+They differ in the supported channel groups & channels. \n+Conventional Fuel Vehicles have no _Charging Profile_, Electric Vehicles don't provide a _Fuel Range_. \n+For hybrid vehicles in addition to _Fuel and Electric Range_ the _Hybrid Range_ is shown.\n+ \n+| Name                                | Thing Type ID | Supported Channel Groups                               |\n+|-------------------------------------|---------------|--------------------------------------------------------|\n+| BMW Electric Vehicle                | bev           | status, range, location, service, check, charge, image |\n+| BMW Electric Vehicle with REX       | bev_rex       | status, range, location, service, check, charge, image |\n+| BMW Plug-In-Hybrid Electric Vehicle | phev          | status, range, location, service, check, charge, image |\n+| BMW Conventional Vehicle            | conv          | status, range, location, service, check, image         |\n+\n+ \n+#### Properties\n+\n+<img align=\"right\" src=\"./doc/properties.png\" width=\"500\" height=\"600\"/>\n+\n+For each vehicle properties are available. \n+Basically 3 types of information are registered as properties\n+\n+* Informations regarding your dealer with address and phone number\n+* Which services are available / not available\n+* Vehicle properties like color, model type, drive train and construction year\n+\n+In the right picture can see in *Services Activated* e.g. the *DoorLock* and *DoorUnlock* services are mentioned. \n+This ensures channel group [Remote Services](#remote-services) is supporting door lock and unlock remote control.\n+\n+In  *Services Supported* the entry *LastDestination* is mentioned.\n+So it's valid to connect channel group [Last Destinations](#destinations) in order to display and select the last navigation destinations.\n+\n+| Property Key       | Property Value      |  Supported Channel Groups    |\n+|--------------------|---------------------|------------------------------|\n+| Services Supported | Statistics          | last-trip, lifetime          |\n+| Services Supported | LastDestinations    | destinations                 |\n+| Services Activated | _list of services_  | remote                       |\n+\n+\n+## Discovery\n+\n+Auto discovery is starting after the bridge towards BMW's ConnectedDrive is created. \n+A list of your registered vehicles is queried and all found things are added in the inbox.\n+Unique identifier is the *Vehicle Identification Number* (VIN). \n+If a thing is already declared in a  _.things_ configuration, discovery won't highlight it again.\n+Properties will be attached to predefined vehicles if the VIN is matching.\n+\n+## Configuration\n+\n+### Bridge Configuration\n+\n+| Parameter       | Type    | Description                                                        |           \n+|-----------------|---------|--------------------------------------------------------------------|\n+| userName        | text    | BMW ConnectedDrive Username                                       |\n+| password        | text    | BMW ConnectedDrive Password                                       |\n+| region          | text    | Select region in order to connect to the appropriate BMW server.   |\n+\n+The region Configuration has 3 different options\n+\n+* _NORTH_AMERICA_\n+* _CHINA_\n+* _ROW_  (Rest of World)\n+\n+### Thing Configuration\n+\n+Same configuration is needed for all things\n+\n+| Parameter       | Type    | Description                           |           \n+|-----------------|---------|---------------------------------------|\n+| vin             | text    | Vehicle Identification Number (VIN)   |\n+| refreshInterval | integer | Refresh Interval in Minutes           |\n+| units           | text    | Unit Selection. See below.            |\n+| imageSize       | integer | Image Size                            |\n+| imageViewport   | text    | Image Viewport                        |\n+\n+The unit configuration has 3 options\n+\n+* _AUTODETECT_ selects miles for US & UK, kilometer otherwise\n+* _METRIC_ selects directly kilometers\n+* _IMPERIAL_ selects directly miles", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "71d5496aba829f6628dd1676734e39c5a7d14f2f"}, "originalPosition": 116}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDgxMjA1NA==", "bodyText": "It's used to pick the right element from json response.\n...\n\"remainingRangeElectric\": 184,\n\"remainingRangeElectricMls\": 114,\n...", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r550812054", "createdAt": "2021-01-01T22:04:10Z", "author": {"login": "weymann"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/README.md", "diffHunk": "@@ -0,0 +1,686 @@\n+# BMW ConnectedDrive Binding\n+\n+<img align=\"right\" src=\"./doc/bmw-connected.png\" width=\"150\" height=\"150\"/>\n+\n+The binding provides a connection between [BMW's ConnectedDrive Portal](https://www.bmw-connecteddrive.com/country-region-select/country-region-selection.html) and openHAB.\n+All vehicles connected to an account will be detected by the discovery with the correct type \n+\n+* Conventional Fuel Vehicle\n+* Plugin-Hybrid Electrical Vehicle \n+* Battery Electric Vehicle with Range Extender\n+* Battery Electric Vehicle \n+\n+In addition properties are attached with information and services provided by this vehicle.\n+The provided data depends on \n+\n+1. the [Thing Type](#things) and \n+2. the [Properties](#properties) mentioned in Services\n+\n+Different channel groups are clustering all informations.\n+Check for each group if it's supported for this Vehicle.\n+\n+Please note **this isn't a real-time binding**. \n+If a door is opened the state isn't transmitted and changed immediately. \n+This isn't a flaw in the binding itself because the state in BMW's own ConnectedDrive App is also updated with some delay. \n+\n+## Supported Things\n+\n+### Bridge\n+\n+The bridge establishes the connection between BMW's ConnectedDrive Portal and openHAB.\n+\n+| Name                       | Bridge Type ID | Description                                                |\n+|----------------------------|----------------|------------------------------------------------------------|\n+| BMW ConnectedDrive Account | account        | Access to BMW ConnectedDrive Portal for a specific user    |\n+\n+\n+### Things\n+\n+Four different vehicle types are provided. \n+They differ in the supported channel groups & channels. \n+Conventional Fuel Vehicles have no _Charging Profile_, Electric Vehicles don't provide a _Fuel Range_. \n+For hybrid vehicles in addition to _Fuel and Electric Range_ the _Hybrid Range_ is shown.\n+ \n+| Name                                | Thing Type ID | Supported Channel Groups                               |\n+|-------------------------------------|---------------|--------------------------------------------------------|\n+| BMW Electric Vehicle                | bev           | status, range, location, service, check, charge, image |\n+| BMW Electric Vehicle with REX       | bev_rex       | status, range, location, service, check, charge, image |\n+| BMW Plug-In-Hybrid Electric Vehicle | phev          | status, range, location, service, check, charge, image |\n+| BMW Conventional Vehicle            | conv          | status, range, location, service, check, image         |\n+\n+ \n+#### Properties\n+\n+<img align=\"right\" src=\"./doc/properties.png\" width=\"500\" height=\"600\"/>\n+\n+For each vehicle properties are available. \n+Basically 3 types of information are registered as properties\n+\n+* Informations regarding your dealer with address and phone number\n+* Which services are available / not available\n+* Vehicle properties like color, model type, drive train and construction year\n+\n+In the right picture can see in *Services Activated* e.g. the *DoorLock* and *DoorUnlock* services are mentioned. \n+This ensures channel group [Remote Services](#remote-services) is supporting door lock and unlock remote control.\n+\n+In  *Services Supported* the entry *LastDestination* is mentioned.\n+So it's valid to connect channel group [Last Destinations](#destinations) in order to display and select the last navigation destinations.\n+\n+| Property Key       | Property Value      |  Supported Channel Groups    |\n+|--------------------|---------------------|------------------------------|\n+| Services Supported | Statistics          | last-trip, lifetime          |\n+| Services Supported | LastDestinations    | destinations                 |\n+| Services Activated | _list of services_  | remote                       |\n+\n+\n+## Discovery\n+\n+Auto discovery is starting after the bridge towards BMW's ConnectedDrive is created. \n+A list of your registered vehicles is queried and all found things are added in the inbox.\n+Unique identifier is the *Vehicle Identification Number* (VIN). \n+If a thing is already declared in a  _.things_ configuration, discovery won't highlight it again.\n+Properties will be attached to predefined vehicles if the VIN is matching.\n+\n+## Configuration\n+\n+### Bridge Configuration\n+\n+| Parameter       | Type    | Description                                                        |           \n+|-----------------|---------|--------------------------------------------------------------------|\n+| userName        | text    | BMW ConnectedDrive Username                                       |\n+| password        | text    | BMW ConnectedDrive Password                                       |\n+| region          | text    | Select region in order to connect to the appropriate BMW server.   |\n+\n+The region Configuration has 3 different options\n+\n+* _NORTH_AMERICA_\n+* _CHINA_\n+* _ROW_  (Rest of World)\n+\n+### Thing Configuration\n+\n+Same configuration is needed for all things\n+\n+| Parameter       | Type    | Description                           |           \n+|-----------------|---------|---------------------------------------|\n+| vin             | text    | Vehicle Identification Number (VIN)   |\n+| refreshInterval | integer | Refresh Interval in Minutes           |\n+| units           | text    | Unit Selection. See below.            |\n+| imageSize       | integer | Image Size                            |\n+| imageViewport   | text    | Image Viewport                        |\n+\n+The unit configuration has 3 options\n+\n+* _AUTODETECT_ selects miles for US & UK, kilometer otherwise\n+* _METRIC_ selects directly kilometers\n+* _IMPERIAL_ selects directly miles", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTg4NDIyNg=="}, "originalCommit": {"oid": "71d5496aba829f6628dd1676734e39c5a7d14f2f"}, "originalPosition": 116}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDk5NDM2NQ==", "bodyText": "Why not picking always the same item and use QuantityType to convert it? Then, the user can rely on his system settings and this setting would be unnecessary.", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r550994365", "createdAt": "2021-01-03T11:40:11Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/README.md", "diffHunk": "@@ -0,0 +1,686 @@\n+# BMW ConnectedDrive Binding\n+\n+<img align=\"right\" src=\"./doc/bmw-connected.png\" width=\"150\" height=\"150\"/>\n+\n+The binding provides a connection between [BMW's ConnectedDrive Portal](https://www.bmw-connecteddrive.com/country-region-select/country-region-selection.html) and openHAB.\n+All vehicles connected to an account will be detected by the discovery with the correct type \n+\n+* Conventional Fuel Vehicle\n+* Plugin-Hybrid Electrical Vehicle \n+* Battery Electric Vehicle with Range Extender\n+* Battery Electric Vehicle \n+\n+In addition properties are attached with information and services provided by this vehicle.\n+The provided data depends on \n+\n+1. the [Thing Type](#things) and \n+2. the [Properties](#properties) mentioned in Services\n+\n+Different channel groups are clustering all informations.\n+Check for each group if it's supported for this Vehicle.\n+\n+Please note **this isn't a real-time binding**. \n+If a door is opened the state isn't transmitted and changed immediately. \n+This isn't a flaw in the binding itself because the state in BMW's own ConnectedDrive App is also updated with some delay. \n+\n+## Supported Things\n+\n+### Bridge\n+\n+The bridge establishes the connection between BMW's ConnectedDrive Portal and openHAB.\n+\n+| Name                       | Bridge Type ID | Description                                                |\n+|----------------------------|----------------|------------------------------------------------------------|\n+| BMW ConnectedDrive Account | account        | Access to BMW ConnectedDrive Portal for a specific user    |\n+\n+\n+### Things\n+\n+Four different vehicle types are provided. \n+They differ in the supported channel groups & channels. \n+Conventional Fuel Vehicles have no _Charging Profile_, Electric Vehicles don't provide a _Fuel Range_. \n+For hybrid vehicles in addition to _Fuel and Electric Range_ the _Hybrid Range_ is shown.\n+ \n+| Name                                | Thing Type ID | Supported Channel Groups                               |\n+|-------------------------------------|---------------|--------------------------------------------------------|\n+| BMW Electric Vehicle                | bev           | status, range, location, service, check, charge, image |\n+| BMW Electric Vehicle with REX       | bev_rex       | status, range, location, service, check, charge, image |\n+| BMW Plug-In-Hybrid Electric Vehicle | phev          | status, range, location, service, check, charge, image |\n+| BMW Conventional Vehicle            | conv          | status, range, location, service, check, image         |\n+\n+ \n+#### Properties\n+\n+<img align=\"right\" src=\"./doc/properties.png\" width=\"500\" height=\"600\"/>\n+\n+For each vehicle properties are available. \n+Basically 3 types of information are registered as properties\n+\n+* Informations regarding your dealer with address and phone number\n+* Which services are available / not available\n+* Vehicle properties like color, model type, drive train and construction year\n+\n+In the right picture can see in *Services Activated* e.g. the *DoorLock* and *DoorUnlock* services are mentioned. \n+This ensures channel group [Remote Services](#remote-services) is supporting door lock and unlock remote control.\n+\n+In  *Services Supported* the entry *LastDestination* is mentioned.\n+So it's valid to connect channel group [Last Destinations](#destinations) in order to display and select the last navigation destinations.\n+\n+| Property Key       | Property Value      |  Supported Channel Groups    |\n+|--------------------|---------------------|------------------------------|\n+| Services Supported | Statistics          | last-trip, lifetime          |\n+| Services Supported | LastDestinations    | destinations                 |\n+| Services Activated | _list of services_  | remote                       |\n+\n+\n+## Discovery\n+\n+Auto discovery is starting after the bridge towards BMW's ConnectedDrive is created. \n+A list of your registered vehicles is queried and all found things are added in the inbox.\n+Unique identifier is the *Vehicle Identification Number* (VIN). \n+If a thing is already declared in a  _.things_ configuration, discovery won't highlight it again.\n+Properties will be attached to predefined vehicles if the VIN is matching.\n+\n+## Configuration\n+\n+### Bridge Configuration\n+\n+| Parameter       | Type    | Description                                                        |           \n+|-----------------|---------|--------------------------------------------------------------------|\n+| userName        | text    | BMW ConnectedDrive Username                                       |\n+| password        | text    | BMW ConnectedDrive Password                                       |\n+| region          | text    | Select region in order to connect to the appropriate BMW server.   |\n+\n+The region Configuration has 3 different options\n+\n+* _NORTH_AMERICA_\n+* _CHINA_\n+* _ROW_  (Rest of World)\n+\n+### Thing Configuration\n+\n+Same configuration is needed for all things\n+\n+| Parameter       | Type    | Description                           |           \n+|-----------------|---------|---------------------------------------|\n+| vin             | text    | Vehicle Identification Number (VIN)   |\n+| refreshInterval | integer | Refresh Interval in Minutes           |\n+| units           | text    | Unit Selection. See below.            |\n+| imageSize       | integer | Image Size                            |\n+| imageViewport   | text    | Image Viewport                        |\n+\n+The unit configuration has 3 options\n+\n+* _AUTODETECT_ selects miles for US & UK, kilometer otherwise\n+* _METRIC_ selects directly kilometers\n+* _IMPERIAL_ selects directly miles", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTg4NDIyNg=="}, "originalCommit": {"oid": "71d5496aba829f6628dd1676734e39c5a7d14f2f"}, "originalPosition": 116}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjI1ODM3NQ==", "bodyText": "In principle I would say yes. I think this would satisy more than 99% of the users. Nevertheless there are some countries besides UK & US using miles. I refused to maintain a list locales for all these countries in this particular binding to have 100% accuracy. Therefore I came up with this: Autodetect as default config will satisfy 99,9% of the users and in case it's wrong the user can select it by hard as a last resort.", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r552258375", "createdAt": "2021-01-05T23:25:00Z", "author": {"login": "weymann"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/README.md", "diffHunk": "@@ -0,0 +1,686 @@\n+# BMW ConnectedDrive Binding\n+\n+<img align=\"right\" src=\"./doc/bmw-connected.png\" width=\"150\" height=\"150\"/>\n+\n+The binding provides a connection between [BMW's ConnectedDrive Portal](https://www.bmw-connecteddrive.com/country-region-select/country-region-selection.html) and openHAB.\n+All vehicles connected to an account will be detected by the discovery with the correct type \n+\n+* Conventional Fuel Vehicle\n+* Plugin-Hybrid Electrical Vehicle \n+* Battery Electric Vehicle with Range Extender\n+* Battery Electric Vehicle \n+\n+In addition properties are attached with information and services provided by this vehicle.\n+The provided data depends on \n+\n+1. the [Thing Type](#things) and \n+2. the [Properties](#properties) mentioned in Services\n+\n+Different channel groups are clustering all informations.\n+Check for each group if it's supported for this Vehicle.\n+\n+Please note **this isn't a real-time binding**. \n+If a door is opened the state isn't transmitted and changed immediately. \n+This isn't a flaw in the binding itself because the state in BMW's own ConnectedDrive App is also updated with some delay. \n+\n+## Supported Things\n+\n+### Bridge\n+\n+The bridge establishes the connection between BMW's ConnectedDrive Portal and openHAB.\n+\n+| Name                       | Bridge Type ID | Description                                                |\n+|----------------------------|----------------|------------------------------------------------------------|\n+| BMW ConnectedDrive Account | account        | Access to BMW ConnectedDrive Portal for a specific user    |\n+\n+\n+### Things\n+\n+Four different vehicle types are provided. \n+They differ in the supported channel groups & channels. \n+Conventional Fuel Vehicles have no _Charging Profile_, Electric Vehicles don't provide a _Fuel Range_. \n+For hybrid vehicles in addition to _Fuel and Electric Range_ the _Hybrid Range_ is shown.\n+ \n+| Name                                | Thing Type ID | Supported Channel Groups                               |\n+|-------------------------------------|---------------|--------------------------------------------------------|\n+| BMW Electric Vehicle                | bev           | status, range, location, service, check, charge, image |\n+| BMW Electric Vehicle with REX       | bev_rex       | status, range, location, service, check, charge, image |\n+| BMW Plug-In-Hybrid Electric Vehicle | phev          | status, range, location, service, check, charge, image |\n+| BMW Conventional Vehicle            | conv          | status, range, location, service, check, image         |\n+\n+ \n+#### Properties\n+\n+<img align=\"right\" src=\"./doc/properties.png\" width=\"500\" height=\"600\"/>\n+\n+For each vehicle properties are available. \n+Basically 3 types of information are registered as properties\n+\n+* Informations regarding your dealer with address and phone number\n+* Which services are available / not available\n+* Vehicle properties like color, model type, drive train and construction year\n+\n+In the right picture can see in *Services Activated* e.g. the *DoorLock* and *DoorUnlock* services are mentioned. \n+This ensures channel group [Remote Services](#remote-services) is supporting door lock and unlock remote control.\n+\n+In  *Services Supported* the entry *LastDestination* is mentioned.\n+So it's valid to connect channel group [Last Destinations](#destinations) in order to display and select the last navigation destinations.\n+\n+| Property Key       | Property Value      |  Supported Channel Groups    |\n+|--------------------|---------------------|------------------------------|\n+| Services Supported | Statistics          | last-trip, lifetime          |\n+| Services Supported | LastDestinations    | destinations                 |\n+| Services Activated | _list of services_  | remote                       |\n+\n+\n+## Discovery\n+\n+Auto discovery is starting after the bridge towards BMW's ConnectedDrive is created. \n+A list of your registered vehicles is queried and all found things are added in the inbox.\n+Unique identifier is the *Vehicle Identification Number* (VIN). \n+If a thing is already declared in a  _.things_ configuration, discovery won't highlight it again.\n+Properties will be attached to predefined vehicles if the VIN is matching.\n+\n+## Configuration\n+\n+### Bridge Configuration\n+\n+| Parameter       | Type    | Description                                                        |           \n+|-----------------|---------|--------------------------------------------------------------------|\n+| userName        | text    | BMW ConnectedDrive Username                                       |\n+| password        | text    | BMW ConnectedDrive Password                                       |\n+| region          | text    | Select region in order to connect to the appropriate BMW server.   |\n+\n+The region Configuration has 3 different options\n+\n+* _NORTH_AMERICA_\n+* _CHINA_\n+* _ROW_  (Rest of World)\n+\n+### Thing Configuration\n+\n+Same configuration is needed for all things\n+\n+| Parameter       | Type    | Description                           |           \n+|-----------------|---------|---------------------------------------|\n+| vin             | text    | Vehicle Identification Number (VIN)   |\n+| refreshInterval | integer | Refresh Interval in Minutes           |\n+| units           | text    | Unit Selection. See below.            |\n+| imageSize       | integer | Image Size                            |\n+| imageViewport   | text    | Image Viewport                        |\n+\n+The unit configuration has 3 options\n+\n+* _AUTODETECT_ selects miles for US & UK, kilometer otherwise\n+* _METRIC_ selects directly kilometers\n+* _IMPERIAL_ selects directly miles", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTg4NDIyNg=="}, "originalCommit": {"oid": "71d5496aba829f6628dd1676734e39c5a7d14f2f"}, "originalPosition": 116}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjkyMjQ4Mw==", "bodyText": "Isn't the API for all countries the same? I.e. both variants are present? Why not use one unit in your code and make a universal QuantityType, that the user can choose the unit himself/herself by selecting the right unit in the state pattern?", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r556922483", "createdAt": "2021-01-13T22:40:25Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/README.md", "diffHunk": "@@ -0,0 +1,686 @@\n+# BMW ConnectedDrive Binding\n+\n+<img align=\"right\" src=\"./doc/bmw-connected.png\" width=\"150\" height=\"150\"/>\n+\n+The binding provides a connection between [BMW's ConnectedDrive Portal](https://www.bmw-connecteddrive.com/country-region-select/country-region-selection.html) and openHAB.\n+All vehicles connected to an account will be detected by the discovery with the correct type \n+\n+* Conventional Fuel Vehicle\n+* Plugin-Hybrid Electrical Vehicle \n+* Battery Electric Vehicle with Range Extender\n+* Battery Electric Vehicle \n+\n+In addition properties are attached with information and services provided by this vehicle.\n+The provided data depends on \n+\n+1. the [Thing Type](#things) and \n+2. the [Properties](#properties) mentioned in Services\n+\n+Different channel groups are clustering all informations.\n+Check for each group if it's supported for this Vehicle.\n+\n+Please note **this isn't a real-time binding**. \n+If a door is opened the state isn't transmitted and changed immediately. \n+This isn't a flaw in the binding itself because the state in BMW's own ConnectedDrive App is also updated with some delay. \n+\n+## Supported Things\n+\n+### Bridge\n+\n+The bridge establishes the connection between BMW's ConnectedDrive Portal and openHAB.\n+\n+| Name                       | Bridge Type ID | Description                                                |\n+|----------------------------|----------------|------------------------------------------------------------|\n+| BMW ConnectedDrive Account | account        | Access to BMW ConnectedDrive Portal for a specific user    |\n+\n+\n+### Things\n+\n+Four different vehicle types are provided. \n+They differ in the supported channel groups & channels. \n+Conventional Fuel Vehicles have no _Charging Profile_, Electric Vehicles don't provide a _Fuel Range_. \n+For hybrid vehicles in addition to _Fuel and Electric Range_ the _Hybrid Range_ is shown.\n+ \n+| Name                                | Thing Type ID | Supported Channel Groups                               |\n+|-------------------------------------|---------------|--------------------------------------------------------|\n+| BMW Electric Vehicle                | bev           | status, range, location, service, check, charge, image |\n+| BMW Electric Vehicle with REX       | bev_rex       | status, range, location, service, check, charge, image |\n+| BMW Plug-In-Hybrid Electric Vehicle | phev          | status, range, location, service, check, charge, image |\n+| BMW Conventional Vehicle            | conv          | status, range, location, service, check, image         |\n+\n+ \n+#### Properties\n+\n+<img align=\"right\" src=\"./doc/properties.png\" width=\"500\" height=\"600\"/>\n+\n+For each vehicle properties are available. \n+Basically 3 types of information are registered as properties\n+\n+* Informations regarding your dealer with address and phone number\n+* Which services are available / not available\n+* Vehicle properties like color, model type, drive train and construction year\n+\n+In the right picture can see in *Services Activated* e.g. the *DoorLock* and *DoorUnlock* services are mentioned. \n+This ensures channel group [Remote Services](#remote-services) is supporting door lock and unlock remote control.\n+\n+In  *Services Supported* the entry *LastDestination* is mentioned.\n+So it's valid to connect channel group [Last Destinations](#destinations) in order to display and select the last navigation destinations.\n+\n+| Property Key       | Property Value      |  Supported Channel Groups    |\n+|--------------------|---------------------|------------------------------|\n+| Services Supported | Statistics          | last-trip, lifetime          |\n+| Services Supported | LastDestinations    | destinations                 |\n+| Services Activated | _list of services_  | remote                       |\n+\n+\n+## Discovery\n+\n+Auto discovery is starting after the bridge towards BMW's ConnectedDrive is created. \n+A list of your registered vehicles is queried and all found things are added in the inbox.\n+Unique identifier is the *Vehicle Identification Number* (VIN). \n+If a thing is already declared in a  _.things_ configuration, discovery won't highlight it again.\n+Properties will be attached to predefined vehicles if the VIN is matching.\n+\n+## Configuration\n+\n+### Bridge Configuration\n+\n+| Parameter       | Type    | Description                                                        |           \n+|-----------------|---------|--------------------------------------------------------------------|\n+| userName        | text    | BMW ConnectedDrive Username                                       |\n+| password        | text    | BMW ConnectedDrive Password                                       |\n+| region          | text    | Select region in order to connect to the appropriate BMW server.   |\n+\n+The region Configuration has 3 different options\n+\n+* _NORTH_AMERICA_\n+* _CHINA_\n+* _ROW_  (Rest of World)\n+\n+### Thing Configuration\n+\n+Same configuration is needed for all things\n+\n+| Parameter       | Type    | Description                           |           \n+|-----------------|---------|---------------------------------------|\n+| vin             | text    | Vehicle Identification Number (VIN)   |\n+| refreshInterval | integer | Refresh Interval in Minutes           |\n+| units           | text    | Unit Selection. See below.            |\n+| imageSize       | integer | Image Size                            |\n+| imageViewport   | text    | Image Viewport                        |\n+\n+The unit configuration has 3 options\n+\n+* _AUTODETECT_ selects miles for US & UK, kilometer otherwise\n+* _METRIC_ selects directly kilometers\n+* _IMPERIAL_ selects directly miles", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTg4NDIyNg=="}, "originalCommit": {"oid": "71d5496aba829f6628dd1676734e39c5a7d14f2f"}, "originalPosition": 116}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MzMwOTMzNQ==", "bodyText": "API is the same but not for all values both values are given\n\nrange values have separate json fields for mi and km\ntrip values are alway given in km without additional mi field\nmileage - either km or mi, cannot be evaluted by the binding itsself. It's either 1234 km or 1234 mi without conversion of the value\n\nI don't know if I fully got your idea. So you propose to define a combined km/mi QuantityType and the user needs to select the unit via format?", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r563309335", "createdAt": "2021-01-24T15:34:24Z", "author": {"login": "weymann"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/README.md", "diffHunk": "@@ -0,0 +1,686 @@\n+# BMW ConnectedDrive Binding\n+\n+<img align=\"right\" src=\"./doc/bmw-connected.png\" width=\"150\" height=\"150\"/>\n+\n+The binding provides a connection between [BMW's ConnectedDrive Portal](https://www.bmw-connecteddrive.com/country-region-select/country-region-selection.html) and openHAB.\n+All vehicles connected to an account will be detected by the discovery with the correct type \n+\n+* Conventional Fuel Vehicle\n+* Plugin-Hybrid Electrical Vehicle \n+* Battery Electric Vehicle with Range Extender\n+* Battery Electric Vehicle \n+\n+In addition properties are attached with information and services provided by this vehicle.\n+The provided data depends on \n+\n+1. the [Thing Type](#things) and \n+2. the [Properties](#properties) mentioned in Services\n+\n+Different channel groups are clustering all informations.\n+Check for each group if it's supported for this Vehicle.\n+\n+Please note **this isn't a real-time binding**. \n+If a door is opened the state isn't transmitted and changed immediately. \n+This isn't a flaw in the binding itself because the state in BMW's own ConnectedDrive App is also updated with some delay. \n+\n+## Supported Things\n+\n+### Bridge\n+\n+The bridge establishes the connection between BMW's ConnectedDrive Portal and openHAB.\n+\n+| Name                       | Bridge Type ID | Description                                                |\n+|----------------------------|----------------|------------------------------------------------------------|\n+| BMW ConnectedDrive Account | account        | Access to BMW ConnectedDrive Portal for a specific user    |\n+\n+\n+### Things\n+\n+Four different vehicle types are provided. \n+They differ in the supported channel groups & channels. \n+Conventional Fuel Vehicles have no _Charging Profile_, Electric Vehicles don't provide a _Fuel Range_. \n+For hybrid vehicles in addition to _Fuel and Electric Range_ the _Hybrid Range_ is shown.\n+ \n+| Name                                | Thing Type ID | Supported Channel Groups                               |\n+|-------------------------------------|---------------|--------------------------------------------------------|\n+| BMW Electric Vehicle                | bev           | status, range, location, service, check, charge, image |\n+| BMW Electric Vehicle with REX       | bev_rex       | status, range, location, service, check, charge, image |\n+| BMW Plug-In-Hybrid Electric Vehicle | phev          | status, range, location, service, check, charge, image |\n+| BMW Conventional Vehicle            | conv          | status, range, location, service, check, image         |\n+\n+ \n+#### Properties\n+\n+<img align=\"right\" src=\"./doc/properties.png\" width=\"500\" height=\"600\"/>\n+\n+For each vehicle properties are available. \n+Basically 3 types of information are registered as properties\n+\n+* Informations regarding your dealer with address and phone number\n+* Which services are available / not available\n+* Vehicle properties like color, model type, drive train and construction year\n+\n+In the right picture can see in *Services Activated* e.g. the *DoorLock* and *DoorUnlock* services are mentioned. \n+This ensures channel group [Remote Services](#remote-services) is supporting door lock and unlock remote control.\n+\n+In  *Services Supported* the entry *LastDestination* is mentioned.\n+So it's valid to connect channel group [Last Destinations](#destinations) in order to display and select the last navigation destinations.\n+\n+| Property Key       | Property Value      |  Supported Channel Groups    |\n+|--------------------|---------------------|------------------------------|\n+| Services Supported | Statistics          | last-trip, lifetime          |\n+| Services Supported | LastDestinations    | destinations                 |\n+| Services Activated | _list of services_  | remote                       |\n+\n+\n+## Discovery\n+\n+Auto discovery is starting after the bridge towards BMW's ConnectedDrive is created. \n+A list of your registered vehicles is queried and all found things are added in the inbox.\n+Unique identifier is the *Vehicle Identification Number* (VIN). \n+If a thing is already declared in a  _.things_ configuration, discovery won't highlight it again.\n+Properties will be attached to predefined vehicles if the VIN is matching.\n+\n+## Configuration\n+\n+### Bridge Configuration\n+\n+| Parameter       | Type    | Description                                                        |           \n+|-----------------|---------|--------------------------------------------------------------------|\n+| userName        | text    | BMW ConnectedDrive Username                                       |\n+| password        | text    | BMW ConnectedDrive Password                                       |\n+| region          | text    | Select region in order to connect to the appropriate BMW server.   |\n+\n+The region Configuration has 3 different options\n+\n+* _NORTH_AMERICA_\n+* _CHINA_\n+* _ROW_  (Rest of World)\n+\n+### Thing Configuration\n+\n+Same configuration is needed for all things\n+\n+| Parameter       | Type    | Description                           |           \n+|-----------------|---------|---------------------------------------|\n+| vin             | text    | Vehicle Identification Number (VIN)   |\n+| refreshInterval | integer | Refresh Interval in Minutes           |\n+| units           | text    | Unit Selection. See below.            |\n+| imageSize       | integer | Image Size                            |\n+| imageViewport   | text    | Image Viewport                        |\n+\n+The unit configuration has 3 options\n+\n+* _AUTODETECT_ selects miles for US & UK, kilometer otherwise\n+* _METRIC_ selects directly kilometers\n+* _IMPERIAL_ selects directly miles", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTg4NDIyNg=="}, "originalCommit": {"oid": "71d5496aba829f6628dd1676734e39c5a7d14f2f"}, "originalPosition": 116}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MzMxMDk0OA==", "bodyText": "Yes, that way you could remove the configuration options and the user can set the desired unit via the well-known pattern. Same as for temperatures to select Celsius/Fahrenheit.", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r563310948", "createdAt": "2021-01-24T15:46:50Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/README.md", "diffHunk": "@@ -0,0 +1,686 @@\n+# BMW ConnectedDrive Binding\n+\n+<img align=\"right\" src=\"./doc/bmw-connected.png\" width=\"150\" height=\"150\"/>\n+\n+The binding provides a connection between [BMW's ConnectedDrive Portal](https://www.bmw-connecteddrive.com/country-region-select/country-region-selection.html) and openHAB.\n+All vehicles connected to an account will be detected by the discovery with the correct type \n+\n+* Conventional Fuel Vehicle\n+* Plugin-Hybrid Electrical Vehicle \n+* Battery Electric Vehicle with Range Extender\n+* Battery Electric Vehicle \n+\n+In addition properties are attached with information and services provided by this vehicle.\n+The provided data depends on \n+\n+1. the [Thing Type](#things) and \n+2. the [Properties](#properties) mentioned in Services\n+\n+Different channel groups are clustering all informations.\n+Check for each group if it's supported for this Vehicle.\n+\n+Please note **this isn't a real-time binding**. \n+If a door is opened the state isn't transmitted and changed immediately. \n+This isn't a flaw in the binding itself because the state in BMW's own ConnectedDrive App is also updated with some delay. \n+\n+## Supported Things\n+\n+### Bridge\n+\n+The bridge establishes the connection between BMW's ConnectedDrive Portal and openHAB.\n+\n+| Name                       | Bridge Type ID | Description                                                |\n+|----------------------------|----------------|------------------------------------------------------------|\n+| BMW ConnectedDrive Account | account        | Access to BMW ConnectedDrive Portal for a specific user    |\n+\n+\n+### Things\n+\n+Four different vehicle types are provided. \n+They differ in the supported channel groups & channels. \n+Conventional Fuel Vehicles have no _Charging Profile_, Electric Vehicles don't provide a _Fuel Range_. \n+For hybrid vehicles in addition to _Fuel and Electric Range_ the _Hybrid Range_ is shown.\n+ \n+| Name                                | Thing Type ID | Supported Channel Groups                               |\n+|-------------------------------------|---------------|--------------------------------------------------------|\n+| BMW Electric Vehicle                | bev           | status, range, location, service, check, charge, image |\n+| BMW Electric Vehicle with REX       | bev_rex       | status, range, location, service, check, charge, image |\n+| BMW Plug-In-Hybrid Electric Vehicle | phev          | status, range, location, service, check, charge, image |\n+| BMW Conventional Vehicle            | conv          | status, range, location, service, check, image         |\n+\n+ \n+#### Properties\n+\n+<img align=\"right\" src=\"./doc/properties.png\" width=\"500\" height=\"600\"/>\n+\n+For each vehicle properties are available. \n+Basically 3 types of information are registered as properties\n+\n+* Informations regarding your dealer with address and phone number\n+* Which services are available / not available\n+* Vehicle properties like color, model type, drive train and construction year\n+\n+In the right picture can see in *Services Activated* e.g. the *DoorLock* and *DoorUnlock* services are mentioned. \n+This ensures channel group [Remote Services](#remote-services) is supporting door lock and unlock remote control.\n+\n+In  *Services Supported* the entry *LastDestination* is mentioned.\n+So it's valid to connect channel group [Last Destinations](#destinations) in order to display and select the last navigation destinations.\n+\n+| Property Key       | Property Value      |  Supported Channel Groups    |\n+|--------------------|---------------------|------------------------------|\n+| Services Supported | Statistics          | last-trip, lifetime          |\n+| Services Supported | LastDestinations    | destinations                 |\n+| Services Activated | _list of services_  | remote                       |\n+\n+\n+## Discovery\n+\n+Auto discovery is starting after the bridge towards BMW's ConnectedDrive is created. \n+A list of your registered vehicles is queried and all found things are added in the inbox.\n+Unique identifier is the *Vehicle Identification Number* (VIN). \n+If a thing is already declared in a  _.things_ configuration, discovery won't highlight it again.\n+Properties will be attached to predefined vehicles if the VIN is matching.\n+\n+## Configuration\n+\n+### Bridge Configuration\n+\n+| Parameter       | Type    | Description                                                        |           \n+|-----------------|---------|--------------------------------------------------------------------|\n+| userName        | text    | BMW ConnectedDrive Username                                       |\n+| password        | text    | BMW ConnectedDrive Password                                       |\n+| region          | text    | Select region in order to connect to the appropriate BMW server.   |\n+\n+The region Configuration has 3 different options\n+\n+* _NORTH_AMERICA_\n+* _CHINA_\n+* _ROW_  (Rest of World)\n+\n+### Thing Configuration\n+\n+Same configuration is needed for all things\n+\n+| Parameter       | Type    | Description                           |           \n+|-----------------|---------|---------------------------------------|\n+| vin             | text    | Vehicle Identification Number (VIN)   |\n+| refreshInterval | integer | Refresh Interval in Minutes           |\n+| units           | text    | Unit Selection. See below.            |\n+| imageSize       | integer | Image Size                            |\n+| imageViewport   | text    | Image Viewport                        |\n+\n+The unit configuration has 3 options\n+\n+* _AUTODETECT_ selects miles for US & UK, kilometer otherwise\n+* _METRIC_ selects directly kilometers\n+* _IMPERIAL_ selects directly miles", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTg4NDIyNg=="}, "originalCommit": {"oid": "71d5496aba829f6628dd1676734e39c5a7d14f2f"}, "originalPosition": 116}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NDA1NDU0NQ==", "bodyText": "I see your point. Unfortunately it's not possible inside the binding if the mileage integer value is referring to kilometers or miles. This is an internal car coding which needs a corresponding configuration by the user and cannot be evaluated by the binding itsself.", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r574054545", "createdAt": "2021-02-10T20:29:44Z", "author": {"login": "weymann"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/README.md", "diffHunk": "@@ -0,0 +1,686 @@\n+# BMW ConnectedDrive Binding\n+\n+<img align=\"right\" src=\"./doc/bmw-connected.png\" width=\"150\" height=\"150\"/>\n+\n+The binding provides a connection between [BMW's ConnectedDrive Portal](https://www.bmw-connecteddrive.com/country-region-select/country-region-selection.html) and openHAB.\n+All vehicles connected to an account will be detected by the discovery with the correct type \n+\n+* Conventional Fuel Vehicle\n+* Plugin-Hybrid Electrical Vehicle \n+* Battery Electric Vehicle with Range Extender\n+* Battery Electric Vehicle \n+\n+In addition properties are attached with information and services provided by this vehicle.\n+The provided data depends on \n+\n+1. the [Thing Type](#things) and \n+2. the [Properties](#properties) mentioned in Services\n+\n+Different channel groups are clustering all informations.\n+Check for each group if it's supported for this Vehicle.\n+\n+Please note **this isn't a real-time binding**. \n+If a door is opened the state isn't transmitted and changed immediately. \n+This isn't a flaw in the binding itself because the state in BMW's own ConnectedDrive App is also updated with some delay. \n+\n+## Supported Things\n+\n+### Bridge\n+\n+The bridge establishes the connection between BMW's ConnectedDrive Portal and openHAB.\n+\n+| Name                       | Bridge Type ID | Description                                                |\n+|----------------------------|----------------|------------------------------------------------------------|\n+| BMW ConnectedDrive Account | account        | Access to BMW ConnectedDrive Portal for a specific user    |\n+\n+\n+### Things\n+\n+Four different vehicle types are provided. \n+They differ in the supported channel groups & channels. \n+Conventional Fuel Vehicles have no _Charging Profile_, Electric Vehicles don't provide a _Fuel Range_. \n+For hybrid vehicles in addition to _Fuel and Electric Range_ the _Hybrid Range_ is shown.\n+ \n+| Name                                | Thing Type ID | Supported Channel Groups                               |\n+|-------------------------------------|---------------|--------------------------------------------------------|\n+| BMW Electric Vehicle                | bev           | status, range, location, service, check, charge, image |\n+| BMW Electric Vehicle with REX       | bev_rex       | status, range, location, service, check, charge, image |\n+| BMW Plug-In-Hybrid Electric Vehicle | phev          | status, range, location, service, check, charge, image |\n+| BMW Conventional Vehicle            | conv          | status, range, location, service, check, image         |\n+\n+ \n+#### Properties\n+\n+<img align=\"right\" src=\"./doc/properties.png\" width=\"500\" height=\"600\"/>\n+\n+For each vehicle properties are available. \n+Basically 3 types of information are registered as properties\n+\n+* Informations regarding your dealer with address and phone number\n+* Which services are available / not available\n+* Vehicle properties like color, model type, drive train and construction year\n+\n+In the right picture can see in *Services Activated* e.g. the *DoorLock* and *DoorUnlock* services are mentioned. \n+This ensures channel group [Remote Services](#remote-services) is supporting door lock and unlock remote control.\n+\n+In  *Services Supported* the entry *LastDestination* is mentioned.\n+So it's valid to connect channel group [Last Destinations](#destinations) in order to display and select the last navigation destinations.\n+\n+| Property Key       | Property Value      |  Supported Channel Groups    |\n+|--------------------|---------------------|------------------------------|\n+| Services Supported | Statistics          | last-trip, lifetime          |\n+| Services Supported | LastDestinations    | destinations                 |\n+| Services Activated | _list of services_  | remote                       |\n+\n+\n+## Discovery\n+\n+Auto discovery is starting after the bridge towards BMW's ConnectedDrive is created. \n+A list of your registered vehicles is queried and all found things are added in the inbox.\n+Unique identifier is the *Vehicle Identification Number* (VIN). \n+If a thing is already declared in a  _.things_ configuration, discovery won't highlight it again.\n+Properties will be attached to predefined vehicles if the VIN is matching.\n+\n+## Configuration\n+\n+### Bridge Configuration\n+\n+| Parameter       | Type    | Description                                                        |           \n+|-----------------|---------|--------------------------------------------------------------------|\n+| userName        | text    | BMW ConnectedDrive Username                                       |\n+| password        | text    | BMW ConnectedDrive Password                                       |\n+| region          | text    | Select region in order to connect to the appropriate BMW server.   |\n+\n+The region Configuration has 3 different options\n+\n+* _NORTH_AMERICA_\n+* _CHINA_\n+* _ROW_  (Rest of World)\n+\n+### Thing Configuration\n+\n+Same configuration is needed for all things\n+\n+| Parameter       | Type    | Description                           |           \n+|-----------------|---------|---------------------------------------|\n+| vin             | text    | Vehicle Identification Number (VIN)   |\n+| refreshInterval | integer | Refresh Interval in Minutes           |\n+| units           | text    | Unit Selection. See below.            |\n+| imageSize       | integer | Image Size                            |\n+| imageViewport   | text    | Image Viewport                        |\n+\n+The unit configuration has 3 options\n+\n+* _AUTODETECT_ selects miles for US & UK, kilometer otherwise\n+* _METRIC_ selects directly kilometers\n+* _IMPERIAL_ selects directly miles", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTg4NDIyNg=="}, "originalCommit": {"oid": "71d5496aba829f6628dd1676734e39c5a7d14f2f"}, "originalPosition": 116}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ1OTE2MjczOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.bmwconnecteddrive/README.md", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yOVQyMzoyMDo0NVrOIMaTdw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wMVQyMjozNDo0N1rOINTD-g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTg4NDc5MQ==", "bodyText": "You could set the Channel to UNDEF in this case. Same for below.", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r549884791", "createdAt": "2020-12-29T23:20:45Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/README.md", "diffHunk": "@@ -0,0 +1,686 @@\n+# BMW ConnectedDrive Binding\n+\n+<img align=\"right\" src=\"./doc/bmw-connected.png\" width=\"150\" height=\"150\"/>\n+\n+The binding provides a connection between [BMW's ConnectedDrive Portal](https://www.bmw-connecteddrive.com/country-region-select/country-region-selection.html) and openHAB.\n+All vehicles connected to an account will be detected by the discovery with the correct type \n+\n+* Conventional Fuel Vehicle\n+* Plugin-Hybrid Electrical Vehicle \n+* Battery Electric Vehicle with Range Extender\n+* Battery Electric Vehicle \n+\n+In addition properties are attached with information and services provided by this vehicle.\n+The provided data depends on \n+\n+1. the [Thing Type](#things) and \n+2. the [Properties](#properties) mentioned in Services\n+\n+Different channel groups are clustering all informations.\n+Check for each group if it's supported for this Vehicle.\n+\n+Please note **this isn't a real-time binding**. \n+If a door is opened the state isn't transmitted and changed immediately. \n+This isn't a flaw in the binding itself because the state in BMW's own ConnectedDrive App is also updated with some delay. \n+\n+## Supported Things\n+\n+### Bridge\n+\n+The bridge establishes the connection between BMW's ConnectedDrive Portal and openHAB.\n+\n+| Name                       | Bridge Type ID | Description                                                |\n+|----------------------------|----------------|------------------------------------------------------------|\n+| BMW ConnectedDrive Account | account        | Access to BMW ConnectedDrive Portal for a specific user    |\n+\n+\n+### Things\n+\n+Four different vehicle types are provided. \n+They differ in the supported channel groups & channels. \n+Conventional Fuel Vehicles have no _Charging Profile_, Electric Vehicles don't provide a _Fuel Range_. \n+For hybrid vehicles in addition to _Fuel and Electric Range_ the _Hybrid Range_ is shown.\n+ \n+| Name                                | Thing Type ID | Supported Channel Groups                               |\n+|-------------------------------------|---------------|--------------------------------------------------------|\n+| BMW Electric Vehicle                | bev           | status, range, location, service, check, charge, image |\n+| BMW Electric Vehicle with REX       | bev_rex       | status, range, location, service, check, charge, image |\n+| BMW Plug-In-Hybrid Electric Vehicle | phev          | status, range, location, service, check, charge, image |\n+| BMW Conventional Vehicle            | conv          | status, range, location, service, check, image         |\n+\n+ \n+#### Properties\n+\n+<img align=\"right\" src=\"./doc/properties.png\" width=\"500\" height=\"600\"/>\n+\n+For each vehicle properties are available. \n+Basically 3 types of information are registered as properties\n+\n+* Informations regarding your dealer with address and phone number\n+* Which services are available / not available\n+* Vehicle properties like color, model type, drive train and construction year\n+\n+In the right picture can see in *Services Activated* e.g. the *DoorLock* and *DoorUnlock* services are mentioned. \n+This ensures channel group [Remote Services](#remote-services) is supporting door lock and unlock remote control.\n+\n+In  *Services Supported* the entry *LastDestination* is mentioned.\n+So it's valid to connect channel group [Last Destinations](#destinations) in order to display and select the last navigation destinations.\n+\n+| Property Key       | Property Value      |  Supported Channel Groups    |\n+|--------------------|---------------------|------------------------------|\n+| Services Supported | Statistics          | last-trip, lifetime          |\n+| Services Supported | LastDestinations    | destinations                 |\n+| Services Activated | _list of services_  | remote                       |\n+\n+\n+## Discovery\n+\n+Auto discovery is starting after the bridge towards BMW's ConnectedDrive is created. \n+A list of your registered vehicles is queried and all found things are added in the inbox.\n+Unique identifier is the *Vehicle Identification Number* (VIN). \n+If a thing is already declared in a  _.things_ configuration, discovery won't highlight it again.\n+Properties will be attached to predefined vehicles if the VIN is matching.\n+\n+## Configuration\n+\n+### Bridge Configuration\n+\n+| Parameter       | Type    | Description                                                        |           \n+|-----------------|---------|--------------------------------------------------------------------|\n+| userName        | text    | BMW ConnectedDrive Username                                       |\n+| password        | text    | BMW ConnectedDrive Password                                       |\n+| region          | text    | Select region in order to connect to the appropriate BMW server.   |\n+\n+The region Configuration has 3 different options\n+\n+* _NORTH_AMERICA_\n+* _CHINA_\n+* _ROW_  (Rest of World)\n+\n+### Thing Configuration\n+\n+Same configuration is needed for all things\n+\n+| Parameter       | Type    | Description                           |           \n+|-----------------|---------|---------------------------------------|\n+| vin             | text    | Vehicle Identification Number (VIN)   |\n+| refreshInterval | integer | Refresh Interval in Minutes           |\n+| units           | text    | Unit Selection. See below.            |\n+| imageSize       | integer | Image Size                            |\n+| imageViewport   | text    | Image Viewport                        |\n+\n+The unit configuration has 3 options\n+\n+* _AUTODETECT_ selects miles for US & UK, kilometer otherwise\n+* _METRIC_ selects directly kilometers\n+* _IMPERIAL_ selects directly miles\n+\n+The _imageVieport_ allows to show the vehicle from different angels.\n+Possible options are \n+\n+* _FRONT_\n+* _REAR_\n+* _SIDE_\n+* _DASHBOARD_\n+* _DRIVERDOOR_\n+\n+## Channels\n+\n+There are many channels available for each vehicle. \n+For better overview they are clustered in different channel groups.\n+They differ for each vehicle type, build-in sensors and activated services.\n+\n+\n+### Thing Channel Groups \n+\n+#### Vehicle Status\n+\n+Reflects overall status of the vehicle.\n+\n+* Channel Group ID is **status**\n+* Available for all vehicles\n+* Read-only values\n+\n+| Channel Label             | Channel ID          | Type          | Description                                    |\n+|---------------------------|---------------------|---------------|------------------------------------------------|\n+| Overall Door Status       | doors               | String        | Combined status for all doors                  |\n+| Overall Window Status     | windows             | String        | Combined status for all windows                |\n+| Doors Locked              | lock                | String        | Status if doors are locked or unlocked         |\n+| Next Service Date         | service-date        | DateTime      | Date of upcoming service                       |\n+| Mileage till Next Service | service-mileage     | Number:Length | Mileage till upcoming service                  |\n+| Check Control             | check-control       | String        | Presence of active warning messages            |\n+| Charging Status           | charge              | String        | Only available for phev, bev_rex and bev       |\n+| Last Status Timestamp     | last-update         | DateTime      | Date and time of last status update            |\n+\n+Overall Door Status values\n+\n+* _Closed_ - all doors closed\n+* _Open_ - at least one door is open\n+* _Unknown_ - no door data delivered at all", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "71d5496aba829f6628dd1676734e39c5a7d14f2f"}, "originalPosition": 159}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDgxNDcxNA==", "bodyText": "I changed all occurences of Unknown to Undef", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r550814714", "createdAt": "2021-01-01T22:34:47Z", "author": {"login": "weymann"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/README.md", "diffHunk": "@@ -0,0 +1,686 @@\n+# BMW ConnectedDrive Binding\n+\n+<img align=\"right\" src=\"./doc/bmw-connected.png\" width=\"150\" height=\"150\"/>\n+\n+The binding provides a connection between [BMW's ConnectedDrive Portal](https://www.bmw-connecteddrive.com/country-region-select/country-region-selection.html) and openHAB.\n+All vehicles connected to an account will be detected by the discovery with the correct type \n+\n+* Conventional Fuel Vehicle\n+* Plugin-Hybrid Electrical Vehicle \n+* Battery Electric Vehicle with Range Extender\n+* Battery Electric Vehicle \n+\n+In addition properties are attached with information and services provided by this vehicle.\n+The provided data depends on \n+\n+1. the [Thing Type](#things) and \n+2. the [Properties](#properties) mentioned in Services\n+\n+Different channel groups are clustering all informations.\n+Check for each group if it's supported for this Vehicle.\n+\n+Please note **this isn't a real-time binding**. \n+If a door is opened the state isn't transmitted and changed immediately. \n+This isn't a flaw in the binding itself because the state in BMW's own ConnectedDrive App is also updated with some delay. \n+\n+## Supported Things\n+\n+### Bridge\n+\n+The bridge establishes the connection between BMW's ConnectedDrive Portal and openHAB.\n+\n+| Name                       | Bridge Type ID | Description                                                |\n+|----------------------------|----------------|------------------------------------------------------------|\n+| BMW ConnectedDrive Account | account        | Access to BMW ConnectedDrive Portal for a specific user    |\n+\n+\n+### Things\n+\n+Four different vehicle types are provided. \n+They differ in the supported channel groups & channels. \n+Conventional Fuel Vehicles have no _Charging Profile_, Electric Vehicles don't provide a _Fuel Range_. \n+For hybrid vehicles in addition to _Fuel and Electric Range_ the _Hybrid Range_ is shown.\n+ \n+| Name                                | Thing Type ID | Supported Channel Groups                               |\n+|-------------------------------------|---------------|--------------------------------------------------------|\n+| BMW Electric Vehicle                | bev           | status, range, location, service, check, charge, image |\n+| BMW Electric Vehicle with REX       | bev_rex       | status, range, location, service, check, charge, image |\n+| BMW Plug-In-Hybrid Electric Vehicle | phev          | status, range, location, service, check, charge, image |\n+| BMW Conventional Vehicle            | conv          | status, range, location, service, check, image         |\n+\n+ \n+#### Properties\n+\n+<img align=\"right\" src=\"./doc/properties.png\" width=\"500\" height=\"600\"/>\n+\n+For each vehicle properties are available. \n+Basically 3 types of information are registered as properties\n+\n+* Informations regarding your dealer with address and phone number\n+* Which services are available / not available\n+* Vehicle properties like color, model type, drive train and construction year\n+\n+In the right picture can see in *Services Activated* e.g. the *DoorLock* and *DoorUnlock* services are mentioned. \n+This ensures channel group [Remote Services](#remote-services) is supporting door lock and unlock remote control.\n+\n+In  *Services Supported* the entry *LastDestination* is mentioned.\n+So it's valid to connect channel group [Last Destinations](#destinations) in order to display and select the last navigation destinations.\n+\n+| Property Key       | Property Value      |  Supported Channel Groups    |\n+|--------------------|---------------------|------------------------------|\n+| Services Supported | Statistics          | last-trip, lifetime          |\n+| Services Supported | LastDestinations    | destinations                 |\n+| Services Activated | _list of services_  | remote                       |\n+\n+\n+## Discovery\n+\n+Auto discovery is starting after the bridge towards BMW's ConnectedDrive is created. \n+A list of your registered vehicles is queried and all found things are added in the inbox.\n+Unique identifier is the *Vehicle Identification Number* (VIN). \n+If a thing is already declared in a  _.things_ configuration, discovery won't highlight it again.\n+Properties will be attached to predefined vehicles if the VIN is matching.\n+\n+## Configuration\n+\n+### Bridge Configuration\n+\n+| Parameter       | Type    | Description                                                        |           \n+|-----------------|---------|--------------------------------------------------------------------|\n+| userName        | text    | BMW ConnectedDrive Username                                       |\n+| password        | text    | BMW ConnectedDrive Password                                       |\n+| region          | text    | Select region in order to connect to the appropriate BMW server.   |\n+\n+The region Configuration has 3 different options\n+\n+* _NORTH_AMERICA_\n+* _CHINA_\n+* _ROW_  (Rest of World)\n+\n+### Thing Configuration\n+\n+Same configuration is needed for all things\n+\n+| Parameter       | Type    | Description                           |           \n+|-----------------|---------|---------------------------------------|\n+| vin             | text    | Vehicle Identification Number (VIN)   |\n+| refreshInterval | integer | Refresh Interval in Minutes           |\n+| units           | text    | Unit Selection. See below.            |\n+| imageSize       | integer | Image Size                            |\n+| imageViewport   | text    | Image Viewport                        |\n+\n+The unit configuration has 3 options\n+\n+* _AUTODETECT_ selects miles for US & UK, kilometer otherwise\n+* _METRIC_ selects directly kilometers\n+* _IMPERIAL_ selects directly miles\n+\n+The _imageVieport_ allows to show the vehicle from different angels.\n+Possible options are \n+\n+* _FRONT_\n+* _REAR_\n+* _SIDE_\n+* _DASHBOARD_\n+* _DRIVERDOOR_\n+\n+## Channels\n+\n+There are many channels available for each vehicle. \n+For better overview they are clustered in different channel groups.\n+They differ for each vehicle type, build-in sensors and activated services.\n+\n+\n+### Thing Channel Groups \n+\n+#### Vehicle Status\n+\n+Reflects overall status of the vehicle.\n+\n+* Channel Group ID is **status**\n+* Available for all vehicles\n+* Read-only values\n+\n+| Channel Label             | Channel ID          | Type          | Description                                    |\n+|---------------------------|---------------------|---------------|------------------------------------------------|\n+| Overall Door Status       | doors               | String        | Combined status for all doors                  |\n+| Overall Window Status     | windows             | String        | Combined status for all windows                |\n+| Doors Locked              | lock                | String        | Status if doors are locked or unlocked         |\n+| Next Service Date         | service-date        | DateTime      | Date of upcoming service                       |\n+| Mileage till Next Service | service-mileage     | Number:Length | Mileage till upcoming service                  |\n+| Check Control             | check-control       | String        | Presence of active warning messages            |\n+| Charging Status           | charge              | String        | Only available for phev, bev_rex and bev       |\n+| Last Status Timestamp     | last-update         | DateTime      | Date and time of last status update            |\n+\n+Overall Door Status values\n+\n+* _Closed_ - all doors closed\n+* _Open_ - at least one door is open\n+* _Unknown_ - no door data delivered at all", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTg4NDc5MQ=="}, "originalCommit": {"oid": "71d5496aba829f6628dd1676734e39c5a7d14f2f"}, "originalPosition": 159}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ1OTE2NjIyOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.bmwconnecteddrive/README.md", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yOVQyMzoyMzoyNFrOIMaVVw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wMVQyMTo1NDo1MlrOINS2VQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTg4NTI3MQ==", "bodyText": "Labels are expected to be as short as possible. Guideline is 2-3 words with max 20-25 chars. See https://www.openhab.org/docs/developer/bindings/thing-xml.html#formatting-labels-and-descriptions", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r549885271", "createdAt": "2020-12-29T23:23:24Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/README.md", "diffHunk": "@@ -0,0 +1,686 @@\n+# BMW ConnectedDrive Binding\n+\n+<img align=\"right\" src=\"./doc/bmw-connected.png\" width=\"150\" height=\"150\"/>\n+\n+The binding provides a connection between [BMW's ConnectedDrive Portal](https://www.bmw-connecteddrive.com/country-region-select/country-region-selection.html) and openHAB.\n+All vehicles connected to an account will be detected by the discovery with the correct type \n+\n+* Conventional Fuel Vehicle\n+* Plugin-Hybrid Electrical Vehicle \n+* Battery Electric Vehicle with Range Extender\n+* Battery Electric Vehicle \n+\n+In addition properties are attached with information and services provided by this vehicle.\n+The provided data depends on \n+\n+1. the [Thing Type](#things) and \n+2. the [Properties](#properties) mentioned in Services\n+\n+Different channel groups are clustering all informations.\n+Check for each group if it's supported for this Vehicle.\n+\n+Please note **this isn't a real-time binding**. \n+If a door is opened the state isn't transmitted and changed immediately. \n+This isn't a flaw in the binding itself because the state in BMW's own ConnectedDrive App is also updated with some delay. \n+\n+## Supported Things\n+\n+### Bridge\n+\n+The bridge establishes the connection between BMW's ConnectedDrive Portal and openHAB.\n+\n+| Name                       | Bridge Type ID | Description                                                |\n+|----------------------------|----------------|------------------------------------------------------------|\n+| BMW ConnectedDrive Account | account        | Access to BMW ConnectedDrive Portal for a specific user    |\n+\n+\n+### Things\n+\n+Four different vehicle types are provided. \n+They differ in the supported channel groups & channels. \n+Conventional Fuel Vehicles have no _Charging Profile_, Electric Vehicles don't provide a _Fuel Range_. \n+For hybrid vehicles in addition to _Fuel and Electric Range_ the _Hybrid Range_ is shown.\n+ \n+| Name                                | Thing Type ID | Supported Channel Groups                               |\n+|-------------------------------------|---------------|--------------------------------------------------------|\n+| BMW Electric Vehicle                | bev           | status, range, location, service, check, charge, image |\n+| BMW Electric Vehicle with REX       | bev_rex       | status, range, location, service, check, charge, image |\n+| BMW Plug-In-Hybrid Electric Vehicle | phev          | status, range, location, service, check, charge, image |\n+| BMW Conventional Vehicle            | conv          | status, range, location, service, check, image         |\n+\n+ \n+#### Properties\n+\n+<img align=\"right\" src=\"./doc/properties.png\" width=\"500\" height=\"600\"/>\n+\n+For each vehicle properties are available. \n+Basically 3 types of information are registered as properties\n+\n+* Informations regarding your dealer with address and phone number\n+* Which services are available / not available\n+* Vehicle properties like color, model type, drive train and construction year\n+\n+In the right picture can see in *Services Activated* e.g. the *DoorLock* and *DoorUnlock* services are mentioned. \n+This ensures channel group [Remote Services](#remote-services) is supporting door lock and unlock remote control.\n+\n+In  *Services Supported* the entry *LastDestination* is mentioned.\n+So it's valid to connect channel group [Last Destinations](#destinations) in order to display and select the last navigation destinations.\n+\n+| Property Key       | Property Value      |  Supported Channel Groups    |\n+|--------------------|---------------------|------------------------------|\n+| Services Supported | Statistics          | last-trip, lifetime          |\n+| Services Supported | LastDestinations    | destinations                 |\n+| Services Activated | _list of services_  | remote                       |\n+\n+\n+## Discovery\n+\n+Auto discovery is starting after the bridge towards BMW's ConnectedDrive is created. \n+A list of your registered vehicles is queried and all found things are added in the inbox.\n+Unique identifier is the *Vehicle Identification Number* (VIN). \n+If a thing is already declared in a  _.things_ configuration, discovery won't highlight it again.\n+Properties will be attached to predefined vehicles if the VIN is matching.\n+\n+## Configuration\n+\n+### Bridge Configuration\n+\n+| Parameter       | Type    | Description                                                        |           \n+|-----------------|---------|--------------------------------------------------------------------|\n+| userName        | text    | BMW ConnectedDrive Username                                       |\n+| password        | text    | BMW ConnectedDrive Password                                       |\n+| region          | text    | Select region in order to connect to the appropriate BMW server.   |\n+\n+The region Configuration has 3 different options\n+\n+* _NORTH_AMERICA_\n+* _CHINA_\n+* _ROW_  (Rest of World)\n+\n+### Thing Configuration\n+\n+Same configuration is needed for all things\n+\n+| Parameter       | Type    | Description                           |           \n+|-----------------|---------|---------------------------------------|\n+| vin             | text    | Vehicle Identification Number (VIN)   |\n+| refreshInterval | integer | Refresh Interval in Minutes           |\n+| units           | text    | Unit Selection. See below.            |\n+| imageSize       | integer | Image Size                            |\n+| imageViewport   | text    | Image Viewport                        |\n+\n+The unit configuration has 3 options\n+\n+* _AUTODETECT_ selects miles for US & UK, kilometer otherwise\n+* _METRIC_ selects directly kilometers\n+* _IMPERIAL_ selects directly miles\n+\n+The _imageVieport_ allows to show the vehicle from different angels.\n+Possible options are \n+\n+* _FRONT_\n+* _REAR_\n+* _SIDE_\n+* _DASHBOARD_\n+* _DRIVERDOOR_\n+\n+## Channels\n+\n+There are many channels available for each vehicle. \n+For better overview they are clustered in different channel groups.\n+They differ for each vehicle type, build-in sensors and activated services.\n+\n+\n+### Thing Channel Groups \n+\n+#### Vehicle Status\n+\n+Reflects overall status of the vehicle.\n+\n+* Channel Group ID is **status**\n+* Available for all vehicles\n+* Read-only values\n+\n+| Channel Label             | Channel ID          | Type          | Description                                    |\n+|---------------------------|---------------------|---------------|------------------------------------------------|\n+| Overall Door Status       | doors               | String        | Combined status for all doors                  |\n+| Overall Window Status     | windows             | String        | Combined status for all windows                |\n+| Doors Locked              | lock                | String        | Status if doors are locked or unlocked         |\n+| Next Service Date         | service-date        | DateTime      | Date of upcoming service                       |\n+| Mileage till Next Service | service-mileage     | Number:Length | Mileage till upcoming service                  |\n+| Check Control             | check-control       | String        | Presence of active warning messages            |\n+| Charging Status           | charge              | String        | Only available for phev, bev_rex and bev       |\n+| Last Status Timestamp     | last-update         | DateTime      | Date and time of last status update            |\n+\n+Overall Door Status values\n+\n+* _Closed_ - all doors closed\n+* _Open_ - at least one door is open\n+* _Unknown_ - no door data delivered at all\n+\n+Overall Windows Status values\n+\n+* _Closed_ - all windows closed\n+* _Open_ - at least one window is completely open\n+* _Intermediate_ - at least one window is partially open\n+* _Unknown_ - no window data delivered at all\n+\n+Check Control values\n+\n+* _Active_ - at least one warning message is active\n+* _Not Active_ - no warning message is active\n+* _Unknown_ - no data for warnings delivered\n+\n+Charging Status values\n+\n+* _Charging_\n+* _Error_\n+* _Finished Fully Charged_\n+* _Finished Not Full_\n+* _Invalid_\n+* _Not Charging_\n+* _Charging Goal reached_\n+* _Waiting For Charging_\n+\n+#### Services\n+\n+Group for all upcoming services with description, service date and/or service mileage.\n+If more than one service is scheduled in the future the channel _name_ contains all future services as options.\n+\n+* Channel Group ID is **service**\n+* Available for all vehicles\n+* Read/Write access\n+\n+| Channel Label                  | Channel ID          | Type           | Access     |\n+|--------------------------------|---------------------|----------------|------------|\n+| Service Name                   | name                | String         | Read/Write |\n+| Service Date                   | date                | Number         | Read       |\n+| Mileage till Service           | mileage             | Number:Length  | Read       |\n+\n+#### Check Control\n+\n+Group for all current active CheckControl messages.\n+If more than one message is active the channel _name_ contains all active messages as options.\n+\n+* Channel Group ID is **check**\n+* Available for all vehicles\n+* Read/Write access\n+\n+| Channel Label                   | Channel ID          | Type           | Access     |\n+|---------------------------------|---------------------|----------------|------------|\n+| CheckControl Description        | name                | String         | Read/Write |\n+| CheckControl Mileage Occurrence | mileage             | Number:Length  | Read       |", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "71d5496aba829f6628dd1676734e39c5a7d14f2f"}, "originalPosition": 212}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDgxMTIyMQ==", "bodyText": "Corrected", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r550811221", "createdAt": "2021-01-01T21:54:52Z", "author": {"login": "weymann"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/README.md", "diffHunk": "@@ -0,0 +1,686 @@\n+# BMW ConnectedDrive Binding\n+\n+<img align=\"right\" src=\"./doc/bmw-connected.png\" width=\"150\" height=\"150\"/>\n+\n+The binding provides a connection between [BMW's ConnectedDrive Portal](https://www.bmw-connecteddrive.com/country-region-select/country-region-selection.html) and openHAB.\n+All vehicles connected to an account will be detected by the discovery with the correct type \n+\n+* Conventional Fuel Vehicle\n+* Plugin-Hybrid Electrical Vehicle \n+* Battery Electric Vehicle with Range Extender\n+* Battery Electric Vehicle \n+\n+In addition properties are attached with information and services provided by this vehicle.\n+The provided data depends on \n+\n+1. the [Thing Type](#things) and \n+2. the [Properties](#properties) mentioned in Services\n+\n+Different channel groups are clustering all informations.\n+Check for each group if it's supported for this Vehicle.\n+\n+Please note **this isn't a real-time binding**. \n+If a door is opened the state isn't transmitted and changed immediately. \n+This isn't a flaw in the binding itself because the state in BMW's own ConnectedDrive App is also updated with some delay. \n+\n+## Supported Things\n+\n+### Bridge\n+\n+The bridge establishes the connection between BMW's ConnectedDrive Portal and openHAB.\n+\n+| Name                       | Bridge Type ID | Description                                                |\n+|----------------------------|----------------|------------------------------------------------------------|\n+| BMW ConnectedDrive Account | account        | Access to BMW ConnectedDrive Portal for a specific user    |\n+\n+\n+### Things\n+\n+Four different vehicle types are provided. \n+They differ in the supported channel groups & channels. \n+Conventional Fuel Vehicles have no _Charging Profile_, Electric Vehicles don't provide a _Fuel Range_. \n+For hybrid vehicles in addition to _Fuel and Electric Range_ the _Hybrid Range_ is shown.\n+ \n+| Name                                | Thing Type ID | Supported Channel Groups                               |\n+|-------------------------------------|---------------|--------------------------------------------------------|\n+| BMW Electric Vehicle                | bev           | status, range, location, service, check, charge, image |\n+| BMW Electric Vehicle with REX       | bev_rex       | status, range, location, service, check, charge, image |\n+| BMW Plug-In-Hybrid Electric Vehicle | phev          | status, range, location, service, check, charge, image |\n+| BMW Conventional Vehicle            | conv          | status, range, location, service, check, image         |\n+\n+ \n+#### Properties\n+\n+<img align=\"right\" src=\"./doc/properties.png\" width=\"500\" height=\"600\"/>\n+\n+For each vehicle properties are available. \n+Basically 3 types of information are registered as properties\n+\n+* Informations regarding your dealer with address and phone number\n+* Which services are available / not available\n+* Vehicle properties like color, model type, drive train and construction year\n+\n+In the right picture can see in *Services Activated* e.g. the *DoorLock* and *DoorUnlock* services are mentioned. \n+This ensures channel group [Remote Services](#remote-services) is supporting door lock and unlock remote control.\n+\n+In  *Services Supported* the entry *LastDestination* is mentioned.\n+So it's valid to connect channel group [Last Destinations](#destinations) in order to display and select the last navigation destinations.\n+\n+| Property Key       | Property Value      |  Supported Channel Groups    |\n+|--------------------|---------------------|------------------------------|\n+| Services Supported | Statistics          | last-trip, lifetime          |\n+| Services Supported | LastDestinations    | destinations                 |\n+| Services Activated | _list of services_  | remote                       |\n+\n+\n+## Discovery\n+\n+Auto discovery is starting after the bridge towards BMW's ConnectedDrive is created. \n+A list of your registered vehicles is queried and all found things are added in the inbox.\n+Unique identifier is the *Vehicle Identification Number* (VIN). \n+If a thing is already declared in a  _.things_ configuration, discovery won't highlight it again.\n+Properties will be attached to predefined vehicles if the VIN is matching.\n+\n+## Configuration\n+\n+### Bridge Configuration\n+\n+| Parameter       | Type    | Description                                                        |           \n+|-----------------|---------|--------------------------------------------------------------------|\n+| userName        | text    | BMW ConnectedDrive Username                                       |\n+| password        | text    | BMW ConnectedDrive Password                                       |\n+| region          | text    | Select region in order to connect to the appropriate BMW server.   |\n+\n+The region Configuration has 3 different options\n+\n+* _NORTH_AMERICA_\n+* _CHINA_\n+* _ROW_  (Rest of World)\n+\n+### Thing Configuration\n+\n+Same configuration is needed for all things\n+\n+| Parameter       | Type    | Description                           |           \n+|-----------------|---------|---------------------------------------|\n+| vin             | text    | Vehicle Identification Number (VIN)   |\n+| refreshInterval | integer | Refresh Interval in Minutes           |\n+| units           | text    | Unit Selection. See below.            |\n+| imageSize       | integer | Image Size                            |\n+| imageViewport   | text    | Image Viewport                        |\n+\n+The unit configuration has 3 options\n+\n+* _AUTODETECT_ selects miles for US & UK, kilometer otherwise\n+* _METRIC_ selects directly kilometers\n+* _IMPERIAL_ selects directly miles\n+\n+The _imageVieport_ allows to show the vehicle from different angels.\n+Possible options are \n+\n+* _FRONT_\n+* _REAR_\n+* _SIDE_\n+* _DASHBOARD_\n+* _DRIVERDOOR_\n+\n+## Channels\n+\n+There are many channels available for each vehicle. \n+For better overview they are clustered in different channel groups.\n+They differ for each vehicle type, build-in sensors and activated services.\n+\n+\n+### Thing Channel Groups \n+\n+#### Vehicle Status\n+\n+Reflects overall status of the vehicle.\n+\n+* Channel Group ID is **status**\n+* Available for all vehicles\n+* Read-only values\n+\n+| Channel Label             | Channel ID          | Type          | Description                                    |\n+|---------------------------|---------------------|---------------|------------------------------------------------|\n+| Overall Door Status       | doors               | String        | Combined status for all doors                  |\n+| Overall Window Status     | windows             | String        | Combined status for all windows                |\n+| Doors Locked              | lock                | String        | Status if doors are locked or unlocked         |\n+| Next Service Date         | service-date        | DateTime      | Date of upcoming service                       |\n+| Mileage till Next Service | service-mileage     | Number:Length | Mileage till upcoming service                  |\n+| Check Control             | check-control       | String        | Presence of active warning messages            |\n+| Charging Status           | charge              | String        | Only available for phev, bev_rex and bev       |\n+| Last Status Timestamp     | last-update         | DateTime      | Date and time of last status update            |\n+\n+Overall Door Status values\n+\n+* _Closed_ - all doors closed\n+* _Open_ - at least one door is open\n+* _Unknown_ - no door data delivered at all\n+\n+Overall Windows Status values\n+\n+* _Closed_ - all windows closed\n+* _Open_ - at least one window is completely open\n+* _Intermediate_ - at least one window is partially open\n+* _Unknown_ - no window data delivered at all\n+\n+Check Control values\n+\n+* _Active_ - at least one warning message is active\n+* _Not Active_ - no warning message is active\n+* _Unknown_ - no data for warnings delivered\n+\n+Charging Status values\n+\n+* _Charging_\n+* _Error_\n+* _Finished Fully Charged_\n+* _Finished Not Full_\n+* _Invalid_\n+* _Not Charging_\n+* _Charging Goal reached_\n+* _Waiting For Charging_\n+\n+#### Services\n+\n+Group for all upcoming services with description, service date and/or service mileage.\n+If more than one service is scheduled in the future the channel _name_ contains all future services as options.\n+\n+* Channel Group ID is **service**\n+* Available for all vehicles\n+* Read/Write access\n+\n+| Channel Label                  | Channel ID          | Type           | Access     |\n+|--------------------------------|---------------------|----------------|------------|\n+| Service Name                   | name                | String         | Read/Write |\n+| Service Date                   | date                | Number         | Read       |\n+| Mileage till Service           | mileage             | Number:Length  | Read       |\n+\n+#### Check Control\n+\n+Group for all current active CheckControl messages.\n+If more than one message is active the channel _name_ contains all active messages as options.\n+\n+* Channel Group ID is **check**\n+* Available for all vehicles\n+* Read/Write access\n+\n+| Channel Label                   | Channel ID          | Type           | Access     |\n+|---------------------------------|---------------------|----------------|------------|\n+| CheckControl Description        | name                | String         | Read/Write |\n+| CheckControl Mileage Occurrence | mileage             | Number:Length  | Read       |", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTg4NTI3MQ=="}, "originalCommit": {"oid": "71d5496aba829f6628dd1676734e39c5a7d14f2f"}, "originalPosition": 212}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ1OTE3NTU4OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.bmwconnecteddrive/README.md", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yOVQyMzoyOTo1MlrOIMaaOQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wMVQyMjo1NDo1NVrOINTLrw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTg4NjUyMQ==", "bodyText": "Is the \"per 100 km\" also applicable if the user uses imperial units?", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r549886521", "createdAt": "2020-12-29T23:29:52Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/README.md", "diffHunk": "@@ -0,0 +1,686 @@\n+# BMW ConnectedDrive Binding\n+\n+<img align=\"right\" src=\"./doc/bmw-connected.png\" width=\"150\" height=\"150\"/>\n+\n+The binding provides a connection between [BMW's ConnectedDrive Portal](https://www.bmw-connecteddrive.com/country-region-select/country-region-selection.html) and openHAB.\n+All vehicles connected to an account will be detected by the discovery with the correct type \n+\n+* Conventional Fuel Vehicle\n+* Plugin-Hybrid Electrical Vehicle \n+* Battery Electric Vehicle with Range Extender\n+* Battery Electric Vehicle \n+\n+In addition properties are attached with information and services provided by this vehicle.\n+The provided data depends on \n+\n+1. the [Thing Type](#things) and \n+2. the [Properties](#properties) mentioned in Services\n+\n+Different channel groups are clustering all informations.\n+Check for each group if it's supported for this Vehicle.\n+\n+Please note **this isn't a real-time binding**. \n+If a door is opened the state isn't transmitted and changed immediately. \n+This isn't a flaw in the binding itself because the state in BMW's own ConnectedDrive App is also updated with some delay. \n+\n+## Supported Things\n+\n+### Bridge\n+\n+The bridge establishes the connection between BMW's ConnectedDrive Portal and openHAB.\n+\n+| Name                       | Bridge Type ID | Description                                                |\n+|----------------------------|----------------|------------------------------------------------------------|\n+| BMW ConnectedDrive Account | account        | Access to BMW ConnectedDrive Portal for a specific user    |\n+\n+\n+### Things\n+\n+Four different vehicle types are provided. \n+They differ in the supported channel groups & channels. \n+Conventional Fuel Vehicles have no _Charging Profile_, Electric Vehicles don't provide a _Fuel Range_. \n+For hybrid vehicles in addition to _Fuel and Electric Range_ the _Hybrid Range_ is shown.\n+ \n+| Name                                | Thing Type ID | Supported Channel Groups                               |\n+|-------------------------------------|---------------|--------------------------------------------------------|\n+| BMW Electric Vehicle                | bev           | status, range, location, service, check, charge, image |\n+| BMW Electric Vehicle with REX       | bev_rex       | status, range, location, service, check, charge, image |\n+| BMW Plug-In-Hybrid Electric Vehicle | phev          | status, range, location, service, check, charge, image |\n+| BMW Conventional Vehicle            | conv          | status, range, location, service, check, image         |\n+\n+ \n+#### Properties\n+\n+<img align=\"right\" src=\"./doc/properties.png\" width=\"500\" height=\"600\"/>\n+\n+For each vehicle properties are available. \n+Basically 3 types of information are registered as properties\n+\n+* Informations regarding your dealer with address and phone number\n+* Which services are available / not available\n+* Vehicle properties like color, model type, drive train and construction year\n+\n+In the right picture can see in *Services Activated* e.g. the *DoorLock* and *DoorUnlock* services are mentioned. \n+This ensures channel group [Remote Services](#remote-services) is supporting door lock and unlock remote control.\n+\n+In  *Services Supported* the entry *LastDestination* is mentioned.\n+So it's valid to connect channel group [Last Destinations](#destinations) in order to display and select the last navigation destinations.\n+\n+| Property Key       | Property Value      |  Supported Channel Groups    |\n+|--------------------|---------------------|------------------------------|\n+| Services Supported | Statistics          | last-trip, lifetime          |\n+| Services Supported | LastDestinations    | destinations                 |\n+| Services Activated | _list of services_  | remote                       |\n+\n+\n+## Discovery\n+\n+Auto discovery is starting after the bridge towards BMW's ConnectedDrive is created. \n+A list of your registered vehicles is queried and all found things are added in the inbox.\n+Unique identifier is the *Vehicle Identification Number* (VIN). \n+If a thing is already declared in a  _.things_ configuration, discovery won't highlight it again.\n+Properties will be attached to predefined vehicles if the VIN is matching.\n+\n+## Configuration\n+\n+### Bridge Configuration\n+\n+| Parameter       | Type    | Description                                                        |           \n+|-----------------|---------|--------------------------------------------------------------------|\n+| userName        | text    | BMW ConnectedDrive Username                                       |\n+| password        | text    | BMW ConnectedDrive Password                                       |\n+| region          | text    | Select region in order to connect to the appropriate BMW server.   |\n+\n+The region Configuration has 3 different options\n+\n+* _NORTH_AMERICA_\n+* _CHINA_\n+* _ROW_  (Rest of World)\n+\n+### Thing Configuration\n+\n+Same configuration is needed for all things\n+\n+| Parameter       | Type    | Description                           |           \n+|-----------------|---------|---------------------------------------|\n+| vin             | text    | Vehicle Identification Number (VIN)   |\n+| refreshInterval | integer | Refresh Interval in Minutes           |\n+| units           | text    | Unit Selection. See below.            |\n+| imageSize       | integer | Image Size                            |\n+| imageViewport   | text    | Image Viewport                        |\n+\n+The unit configuration has 3 options\n+\n+* _AUTODETECT_ selects miles for US & UK, kilometer otherwise\n+* _METRIC_ selects directly kilometers\n+* _IMPERIAL_ selects directly miles\n+\n+The _imageVieport_ allows to show the vehicle from different angels.\n+Possible options are \n+\n+* _FRONT_\n+* _REAR_\n+* _SIDE_\n+* _DASHBOARD_\n+* _DRIVERDOOR_\n+\n+## Channels\n+\n+There are many channels available for each vehicle. \n+For better overview they are clustered in different channel groups.\n+They differ for each vehicle type, build-in sensors and activated services.\n+\n+\n+### Thing Channel Groups \n+\n+#### Vehicle Status\n+\n+Reflects overall status of the vehicle.\n+\n+* Channel Group ID is **status**\n+* Available for all vehicles\n+* Read-only values\n+\n+| Channel Label             | Channel ID          | Type          | Description                                    |\n+|---------------------------|---------------------|---------------|------------------------------------------------|\n+| Overall Door Status       | doors               | String        | Combined status for all doors                  |\n+| Overall Window Status     | windows             | String        | Combined status for all windows                |\n+| Doors Locked              | lock                | String        | Status if doors are locked or unlocked         |\n+| Next Service Date         | service-date        | DateTime      | Date of upcoming service                       |\n+| Mileage till Next Service | service-mileage     | Number:Length | Mileage till upcoming service                  |\n+| Check Control             | check-control       | String        | Presence of active warning messages            |\n+| Charging Status           | charge              | String        | Only available for phev, bev_rex and bev       |\n+| Last Status Timestamp     | last-update         | DateTime      | Date and time of last status update            |\n+\n+Overall Door Status values\n+\n+* _Closed_ - all doors closed\n+* _Open_ - at least one door is open\n+* _Unknown_ - no door data delivered at all\n+\n+Overall Windows Status values\n+\n+* _Closed_ - all windows closed\n+* _Open_ - at least one window is completely open\n+* _Intermediate_ - at least one window is partially open\n+* _Unknown_ - no window data delivered at all\n+\n+Check Control values\n+\n+* _Active_ - at least one warning message is active\n+* _Not Active_ - no warning message is active\n+* _Unknown_ - no data for warnings delivered\n+\n+Charging Status values\n+\n+* _Charging_\n+* _Error_\n+* _Finished Fully Charged_\n+* _Finished Not Full_\n+* _Invalid_\n+* _Not Charging_\n+* _Charging Goal reached_\n+* _Waiting For Charging_\n+\n+#### Services\n+\n+Group for all upcoming services with description, service date and/or service mileage.\n+If more than one service is scheduled in the future the channel _name_ contains all future services as options.\n+\n+* Channel Group ID is **service**\n+* Available for all vehicles\n+* Read/Write access\n+\n+| Channel Label                  | Channel ID          | Type           | Access     |\n+|--------------------------------|---------------------|----------------|------------|\n+| Service Name                   | name                | String         | Read/Write |\n+| Service Date                   | date                | Number         | Read       |\n+| Mileage till Service           | mileage             | Number:Length  | Read       |\n+\n+#### Check Control\n+\n+Group for all current active CheckControl messages.\n+If more than one message is active the channel _name_ contains all active messages as options.\n+\n+* Channel Group ID is **check**\n+* Available for all vehicles\n+* Read/Write access\n+\n+| Channel Label                   | Channel ID          | Type           | Access     |\n+|---------------------------------|---------------------|----------------|------------|\n+| CheckControl Description        | name                | String         | Read/Write |\n+| CheckControl Mileage Occurrence | mileage             | Number:Length  | Read       |\n+\n+#### Doors Details\n+\n+Detailed status of all doors and windows.\n+\n+* Channel Group ID is **doors**\n+* Available for all vehicles if corresponding sensors are built-in \n+* Read-only values\n+ \n+| Channel Label              | Channel ID              | Type          | \n+|----------------------------|-------------------------|---------------|\n+| Driver Door                | driver-front            | String        |\n+| Driver Door Rear           | driver-rear             | String        |\n+| Passenger Door             | passenger-front         | String        |\n+| Passenger Door Rear        | passenger-rear          | String        |\n+| Trunk                      | trunk                   | String        |\n+| Hood                       | hood                    | String        |\n+| Driver Door Window         | win-driver-front        | String        |\n+| Driver Door Rear Window    | win-driver-rear         | String        |\n+| Passenger Door Window      | win-passenger-front     | String        |\n+| Passenger Door Rear Window | win-passenger-rear      | String        |\n+| Rear Window                | win-rear                | String        |\n+| Sunroof                    | sunroof                 | String        |\n+\n+Possible states\n+\n+* _Unknown_ - no status data available\n+* _Invalid_ - this door / window isn't applicable for this vehicle\n+* _Closed_ - the door / window is closed\n+* _Open_ - the door / window is open\n+* _Intermediate_ - window in intermediate position, not applicable for doors\n+\n+#### Range Data\n+\n+Based on vehicle type some channels are present or not. \n+Conventional fuel vehicles don't provide *Electric Range* and battery electric vehicles don't show *Fuel Range*.\n+Hybrid vehicles have both and in addition *Hybrid Range*.\n+See description [Range vs Range Radius](#range-vs-range-radius) to get more information.\n+\n+* Channel Group ID is **range**\n+* Availability according to table\n+* Read-only values\n+\n+| Channel Label         | Channel ID            | Type                 | conv | phev | bev_rex | bev |\n+|-----------------------|-----------------------|----------------------|------|------|---------|-----|\n+| Mileage               | mileage               | Number:Length        |  X   |  X   |    X    |  X  |\n+| Fuel Range            | range-fuel            | Number:Length        |  X   |  X   |    X    |     |\n+| Battery Range         | range-electric        | Number:Length        |      |  X   |    X    |  X  | \n+| Hybrid Range          | range-hybrid          | Number:Length        |      |  X   |    X    |     | \n+| Battery Charge Level  | soc                   | Number:Dimensionless |      |  X   |    X    |  X  |\n+| Remaining Fuel        | remaining-fuel        | Number:Volume        |  X   |  X   |    X    |     | \n+| Fuel Range Radius     | range-radius-fuel     | Number:Length        |  X   |  X   |    X    |     | \n+| Electric Range Radius | range-radius-electric | Number:Length        |      |  X   |    X    |  X  | \n+| Hybrid Range Radius   | range-radius-hybrid   | Number:Length        |      |  X   |    X    |     | \n+\n+\n+#### Charge Profile\n+\n+Charging options with date and time for preferred time windows and charging modes.\n+\n+* Channel Group ID is **charge**\n+* Available for electric and hybrid vehicles\n+* Read-only values\n+\n+| Channel Label                      | Channel ID          | Type   | \n+|------------------------------------|---------------------|--------|\n+| Air Conditioning at Departure Time | profile-climate     | Switch | \n+| Charging Mode for Profile          | profile-mode        | String | \n+| Charging Window Start Time         | window-start        | String | \n+| Charging Window End Time           | window-end          | String | \n+| Timer 1: Departure Time            | timer1-departure    | String | \n+| Timer 1: Scheduled Days            | timer1-days         | String | \n+| Timer 1: Enabled                   | timer1-enabled      | Switch | \n+| Timer 2: Departure Time            | timer2-departure    | String | \n+| Timer 2: Scheduled Days            | timer2-days         | String | \n+| Timer 2: Enabled                   | timer2-enabled      | Switch | \n+| Timer 3: Departure Time            | timer3-departure    | String | \n+| Timer 3: Scheduled Days            | timer3-days         | String | \n+| Timer 3: Enabled                   | timer3-enabled      | Switch | \n+\n+\n+#### Location\n+\n+GPS location and heading of the vehicle.\n+\n+* Channel Group ID is **location**\n+* Available for all vehicles with built-in GPS sensor. Function can be enabled/disabled in the head unit\n+* Read-only values\n+\n+| Channel Label   | Channel ID          | Type         | \n+|-----------------|---------------------|--------------|\n+| GPS Coordinates | gps                 | Location     | \n+| Heading         | heading             | Number:Angle | \n+\n+#### Last Trip\n+\n+Statistic values of duration, distance and consumption of the last trip.\n+\n+* Channel Group ID is **last-trip**\n+* Available if *Statistics* is present in *Services Supported*. See [Vehicle Properties](#properties) for further details\n+* Read-only values\n+\n+| Channel Label                           | Channel ID                   | Type          |\n+|-----------------------------------------|------------------------------|---------------|\n+| Last Trip Date                          | date                         | DateTime      |\n+| Last Trip Duration                      | duration                     | Number:Time   |\n+| Average Power Consumption per 100 km    | avg-consumption              | Number:Power  |\n+| Average Combined Consumption per 100 km | avg-combined-consumption     | Number:Volume |\n+| Average Power Recuperation per 100 km   | avg-recuperation             | Number:Power  |\n+| Last Trip Distance                      | distance                     | Number:Length |\n+| Distance since Last Charge              | distance-since-charging      | Number:Length |\n+\n+\n+#### Lifetime Statistics\n+\n+Providing lifetime consumption values.\n+\n+* Channel Group ID is **lifetime**\n+* Available if *Statistics* is present in *Services Supported*. See [Vehicle Properties](#properties) for further details\n+* Read-only values\n+\n+| Channel Label                           | Channel ID                   | Type          | \n+|-----------------------------------------|------------------------------|---------------|\n+| Average Power Consumption per 100 km    | avg-consumption              | Number:Power  |", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "71d5496aba829f6628dd1676734e39c5a7d14f2f"}, "originalPosition": 336}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDgxNjY4Nw==", "bodyText": "Yes, the API is delivering only this value. In the car you can change the display to km / kwh or mi / kwh but this doesn't effect the API content.\nBut this is a good point I've overseen so far. I'll perform the conversion inside the binding in order to give consistent feedback in case of Imperial configuration", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r550816687", "createdAt": "2021-01-01T22:54:55Z", "author": {"login": "weymann"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/README.md", "diffHunk": "@@ -0,0 +1,686 @@\n+# BMW ConnectedDrive Binding\n+\n+<img align=\"right\" src=\"./doc/bmw-connected.png\" width=\"150\" height=\"150\"/>\n+\n+The binding provides a connection between [BMW's ConnectedDrive Portal](https://www.bmw-connecteddrive.com/country-region-select/country-region-selection.html) and openHAB.\n+All vehicles connected to an account will be detected by the discovery with the correct type \n+\n+* Conventional Fuel Vehicle\n+* Plugin-Hybrid Electrical Vehicle \n+* Battery Electric Vehicle with Range Extender\n+* Battery Electric Vehicle \n+\n+In addition properties are attached with information and services provided by this vehicle.\n+The provided data depends on \n+\n+1. the [Thing Type](#things) and \n+2. the [Properties](#properties) mentioned in Services\n+\n+Different channel groups are clustering all informations.\n+Check for each group if it's supported for this Vehicle.\n+\n+Please note **this isn't a real-time binding**. \n+If a door is opened the state isn't transmitted and changed immediately. \n+This isn't a flaw in the binding itself because the state in BMW's own ConnectedDrive App is also updated with some delay. \n+\n+## Supported Things\n+\n+### Bridge\n+\n+The bridge establishes the connection between BMW's ConnectedDrive Portal and openHAB.\n+\n+| Name                       | Bridge Type ID | Description                                                |\n+|----------------------------|----------------|------------------------------------------------------------|\n+| BMW ConnectedDrive Account | account        | Access to BMW ConnectedDrive Portal for a specific user    |\n+\n+\n+### Things\n+\n+Four different vehicle types are provided. \n+They differ in the supported channel groups & channels. \n+Conventional Fuel Vehicles have no _Charging Profile_, Electric Vehicles don't provide a _Fuel Range_. \n+For hybrid vehicles in addition to _Fuel and Electric Range_ the _Hybrid Range_ is shown.\n+ \n+| Name                                | Thing Type ID | Supported Channel Groups                               |\n+|-------------------------------------|---------------|--------------------------------------------------------|\n+| BMW Electric Vehicle                | bev           | status, range, location, service, check, charge, image |\n+| BMW Electric Vehicle with REX       | bev_rex       | status, range, location, service, check, charge, image |\n+| BMW Plug-In-Hybrid Electric Vehicle | phev          | status, range, location, service, check, charge, image |\n+| BMW Conventional Vehicle            | conv          | status, range, location, service, check, image         |\n+\n+ \n+#### Properties\n+\n+<img align=\"right\" src=\"./doc/properties.png\" width=\"500\" height=\"600\"/>\n+\n+For each vehicle properties are available. \n+Basically 3 types of information are registered as properties\n+\n+* Informations regarding your dealer with address and phone number\n+* Which services are available / not available\n+* Vehicle properties like color, model type, drive train and construction year\n+\n+In the right picture can see in *Services Activated* e.g. the *DoorLock* and *DoorUnlock* services are mentioned. \n+This ensures channel group [Remote Services](#remote-services) is supporting door lock and unlock remote control.\n+\n+In  *Services Supported* the entry *LastDestination* is mentioned.\n+So it's valid to connect channel group [Last Destinations](#destinations) in order to display and select the last navigation destinations.\n+\n+| Property Key       | Property Value      |  Supported Channel Groups    |\n+|--------------------|---------------------|------------------------------|\n+| Services Supported | Statistics          | last-trip, lifetime          |\n+| Services Supported | LastDestinations    | destinations                 |\n+| Services Activated | _list of services_  | remote                       |\n+\n+\n+## Discovery\n+\n+Auto discovery is starting after the bridge towards BMW's ConnectedDrive is created. \n+A list of your registered vehicles is queried and all found things are added in the inbox.\n+Unique identifier is the *Vehicle Identification Number* (VIN). \n+If a thing is already declared in a  _.things_ configuration, discovery won't highlight it again.\n+Properties will be attached to predefined vehicles if the VIN is matching.\n+\n+## Configuration\n+\n+### Bridge Configuration\n+\n+| Parameter       | Type    | Description                                                        |           \n+|-----------------|---------|--------------------------------------------------------------------|\n+| userName        | text    | BMW ConnectedDrive Username                                       |\n+| password        | text    | BMW ConnectedDrive Password                                       |\n+| region          | text    | Select region in order to connect to the appropriate BMW server.   |\n+\n+The region Configuration has 3 different options\n+\n+* _NORTH_AMERICA_\n+* _CHINA_\n+* _ROW_  (Rest of World)\n+\n+### Thing Configuration\n+\n+Same configuration is needed for all things\n+\n+| Parameter       | Type    | Description                           |           \n+|-----------------|---------|---------------------------------------|\n+| vin             | text    | Vehicle Identification Number (VIN)   |\n+| refreshInterval | integer | Refresh Interval in Minutes           |\n+| units           | text    | Unit Selection. See below.            |\n+| imageSize       | integer | Image Size                            |\n+| imageViewport   | text    | Image Viewport                        |\n+\n+The unit configuration has 3 options\n+\n+* _AUTODETECT_ selects miles for US & UK, kilometer otherwise\n+* _METRIC_ selects directly kilometers\n+* _IMPERIAL_ selects directly miles\n+\n+The _imageVieport_ allows to show the vehicle from different angels.\n+Possible options are \n+\n+* _FRONT_\n+* _REAR_\n+* _SIDE_\n+* _DASHBOARD_\n+* _DRIVERDOOR_\n+\n+## Channels\n+\n+There are many channels available for each vehicle. \n+For better overview they are clustered in different channel groups.\n+They differ for each vehicle type, build-in sensors and activated services.\n+\n+\n+### Thing Channel Groups \n+\n+#### Vehicle Status\n+\n+Reflects overall status of the vehicle.\n+\n+* Channel Group ID is **status**\n+* Available for all vehicles\n+* Read-only values\n+\n+| Channel Label             | Channel ID          | Type          | Description                                    |\n+|---------------------------|---------------------|---------------|------------------------------------------------|\n+| Overall Door Status       | doors               | String        | Combined status for all doors                  |\n+| Overall Window Status     | windows             | String        | Combined status for all windows                |\n+| Doors Locked              | lock                | String        | Status if doors are locked or unlocked         |\n+| Next Service Date         | service-date        | DateTime      | Date of upcoming service                       |\n+| Mileage till Next Service | service-mileage     | Number:Length | Mileage till upcoming service                  |\n+| Check Control             | check-control       | String        | Presence of active warning messages            |\n+| Charging Status           | charge              | String        | Only available for phev, bev_rex and bev       |\n+| Last Status Timestamp     | last-update         | DateTime      | Date and time of last status update            |\n+\n+Overall Door Status values\n+\n+* _Closed_ - all doors closed\n+* _Open_ - at least one door is open\n+* _Unknown_ - no door data delivered at all\n+\n+Overall Windows Status values\n+\n+* _Closed_ - all windows closed\n+* _Open_ - at least one window is completely open\n+* _Intermediate_ - at least one window is partially open\n+* _Unknown_ - no window data delivered at all\n+\n+Check Control values\n+\n+* _Active_ - at least one warning message is active\n+* _Not Active_ - no warning message is active\n+* _Unknown_ - no data for warnings delivered\n+\n+Charging Status values\n+\n+* _Charging_\n+* _Error_\n+* _Finished Fully Charged_\n+* _Finished Not Full_\n+* _Invalid_\n+* _Not Charging_\n+* _Charging Goal reached_\n+* _Waiting For Charging_\n+\n+#### Services\n+\n+Group for all upcoming services with description, service date and/or service mileage.\n+If more than one service is scheduled in the future the channel _name_ contains all future services as options.\n+\n+* Channel Group ID is **service**\n+* Available for all vehicles\n+* Read/Write access\n+\n+| Channel Label                  | Channel ID          | Type           | Access     |\n+|--------------------------------|---------------------|----------------|------------|\n+| Service Name                   | name                | String         | Read/Write |\n+| Service Date                   | date                | Number         | Read       |\n+| Mileage till Service           | mileage             | Number:Length  | Read       |\n+\n+#### Check Control\n+\n+Group for all current active CheckControl messages.\n+If more than one message is active the channel _name_ contains all active messages as options.\n+\n+* Channel Group ID is **check**\n+* Available for all vehicles\n+* Read/Write access\n+\n+| Channel Label                   | Channel ID          | Type           | Access     |\n+|---------------------------------|---------------------|----------------|------------|\n+| CheckControl Description        | name                | String         | Read/Write |\n+| CheckControl Mileage Occurrence | mileage             | Number:Length  | Read       |\n+\n+#### Doors Details\n+\n+Detailed status of all doors and windows.\n+\n+* Channel Group ID is **doors**\n+* Available for all vehicles if corresponding sensors are built-in \n+* Read-only values\n+ \n+| Channel Label              | Channel ID              | Type          | \n+|----------------------------|-------------------------|---------------|\n+| Driver Door                | driver-front            | String        |\n+| Driver Door Rear           | driver-rear             | String        |\n+| Passenger Door             | passenger-front         | String        |\n+| Passenger Door Rear        | passenger-rear          | String        |\n+| Trunk                      | trunk                   | String        |\n+| Hood                       | hood                    | String        |\n+| Driver Door Window         | win-driver-front        | String        |\n+| Driver Door Rear Window    | win-driver-rear         | String        |\n+| Passenger Door Window      | win-passenger-front     | String        |\n+| Passenger Door Rear Window | win-passenger-rear      | String        |\n+| Rear Window                | win-rear                | String        |\n+| Sunroof                    | sunroof                 | String        |\n+\n+Possible states\n+\n+* _Unknown_ - no status data available\n+* _Invalid_ - this door / window isn't applicable for this vehicle\n+* _Closed_ - the door / window is closed\n+* _Open_ - the door / window is open\n+* _Intermediate_ - window in intermediate position, not applicable for doors\n+\n+#### Range Data\n+\n+Based on vehicle type some channels are present or not. \n+Conventional fuel vehicles don't provide *Electric Range* and battery electric vehicles don't show *Fuel Range*.\n+Hybrid vehicles have both and in addition *Hybrid Range*.\n+See description [Range vs Range Radius](#range-vs-range-radius) to get more information.\n+\n+* Channel Group ID is **range**\n+* Availability according to table\n+* Read-only values\n+\n+| Channel Label         | Channel ID            | Type                 | conv | phev | bev_rex | bev |\n+|-----------------------|-----------------------|----------------------|------|------|---------|-----|\n+| Mileage               | mileage               | Number:Length        |  X   |  X   |    X    |  X  |\n+| Fuel Range            | range-fuel            | Number:Length        |  X   |  X   |    X    |     |\n+| Battery Range         | range-electric        | Number:Length        |      |  X   |    X    |  X  | \n+| Hybrid Range          | range-hybrid          | Number:Length        |      |  X   |    X    |     | \n+| Battery Charge Level  | soc                   | Number:Dimensionless |      |  X   |    X    |  X  |\n+| Remaining Fuel        | remaining-fuel        | Number:Volume        |  X   |  X   |    X    |     | \n+| Fuel Range Radius     | range-radius-fuel     | Number:Length        |  X   |  X   |    X    |     | \n+| Electric Range Radius | range-radius-electric | Number:Length        |      |  X   |    X    |  X  | \n+| Hybrid Range Radius   | range-radius-hybrid   | Number:Length        |      |  X   |    X    |     | \n+\n+\n+#### Charge Profile\n+\n+Charging options with date and time for preferred time windows and charging modes.\n+\n+* Channel Group ID is **charge**\n+* Available for electric and hybrid vehicles\n+* Read-only values\n+\n+| Channel Label                      | Channel ID          | Type   | \n+|------------------------------------|---------------------|--------|\n+| Air Conditioning at Departure Time | profile-climate     | Switch | \n+| Charging Mode for Profile          | profile-mode        | String | \n+| Charging Window Start Time         | window-start        | String | \n+| Charging Window End Time           | window-end          | String | \n+| Timer 1: Departure Time            | timer1-departure    | String | \n+| Timer 1: Scheduled Days            | timer1-days         | String | \n+| Timer 1: Enabled                   | timer1-enabled      | Switch | \n+| Timer 2: Departure Time            | timer2-departure    | String | \n+| Timer 2: Scheduled Days            | timer2-days         | String | \n+| Timer 2: Enabled                   | timer2-enabled      | Switch | \n+| Timer 3: Departure Time            | timer3-departure    | String | \n+| Timer 3: Scheduled Days            | timer3-days         | String | \n+| Timer 3: Enabled                   | timer3-enabled      | Switch | \n+\n+\n+#### Location\n+\n+GPS location and heading of the vehicle.\n+\n+* Channel Group ID is **location**\n+* Available for all vehicles with built-in GPS sensor. Function can be enabled/disabled in the head unit\n+* Read-only values\n+\n+| Channel Label   | Channel ID          | Type         | \n+|-----------------|---------------------|--------------|\n+| GPS Coordinates | gps                 | Location     | \n+| Heading         | heading             | Number:Angle | \n+\n+#### Last Trip\n+\n+Statistic values of duration, distance and consumption of the last trip.\n+\n+* Channel Group ID is **last-trip**\n+* Available if *Statistics* is present in *Services Supported*. See [Vehicle Properties](#properties) for further details\n+* Read-only values\n+\n+| Channel Label                           | Channel ID                   | Type          |\n+|-----------------------------------------|------------------------------|---------------|\n+| Last Trip Date                          | date                         | DateTime      |\n+| Last Trip Duration                      | duration                     | Number:Time   |\n+| Average Power Consumption per 100 km    | avg-consumption              | Number:Power  |\n+| Average Combined Consumption per 100 km | avg-combined-consumption     | Number:Volume |\n+| Average Power Recuperation per 100 km   | avg-recuperation             | Number:Power  |\n+| Last Trip Distance                      | distance                     | Number:Length |\n+| Distance since Last Charge              | distance-since-charging      | Number:Length |\n+\n+\n+#### Lifetime Statistics\n+\n+Providing lifetime consumption values.\n+\n+* Channel Group ID is **lifetime**\n+* Available if *Statistics* is present in *Services Supported*. See [Vehicle Properties](#properties) for further details\n+* Read-only values\n+\n+| Channel Label                           | Channel ID                   | Type          | \n+|-----------------------------------------|------------------------------|---------------|\n+| Average Power Consumption per 100 km    | avg-consumption              | Number:Power  |", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTg4NjUyMQ=="}, "originalCommit": {"oid": "71d5496aba829f6628dd1676734e39c5a7d14f2f"}, "originalPosition": 336}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ1OTE4MjAxOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.bmwconnecteddrive/README.md", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yOVQyMzozNDo1N1rOIMadjA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wMVQyMjo1NTo1NVrOINTMFw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTg4NzM3Mg==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            Select the wanted service and the corresponding _Service Date & Milage_ will be shown.  \n          \n          \n            \n            Select the desired service and the corresponding _Service Date & Milage_ will be shown.", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r549887372", "createdAt": "2020-12-29T23:34:57Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/README.md", "diffHunk": "@@ -0,0 +1,686 @@\n+# BMW ConnectedDrive Binding\n+\n+<img align=\"right\" src=\"./doc/bmw-connected.png\" width=\"150\" height=\"150\"/>\n+\n+The binding provides a connection between [BMW's ConnectedDrive Portal](https://www.bmw-connecteddrive.com/country-region-select/country-region-selection.html) and openHAB.\n+All vehicles connected to an account will be detected by the discovery with the correct type \n+\n+* Conventional Fuel Vehicle\n+* Plugin-Hybrid Electrical Vehicle \n+* Battery Electric Vehicle with Range Extender\n+* Battery Electric Vehicle \n+\n+In addition properties are attached with information and services provided by this vehicle.\n+The provided data depends on \n+\n+1. the [Thing Type](#things) and \n+2. the [Properties](#properties) mentioned in Services\n+\n+Different channel groups are clustering all informations.\n+Check for each group if it's supported for this Vehicle.\n+\n+Please note **this isn't a real-time binding**. \n+If a door is opened the state isn't transmitted and changed immediately. \n+This isn't a flaw in the binding itself because the state in BMW's own ConnectedDrive App is also updated with some delay. \n+\n+## Supported Things\n+\n+### Bridge\n+\n+The bridge establishes the connection between BMW's ConnectedDrive Portal and openHAB.\n+\n+| Name                       | Bridge Type ID | Description                                                |\n+|----------------------------|----------------|------------------------------------------------------------|\n+| BMW ConnectedDrive Account | account        | Access to BMW ConnectedDrive Portal for a specific user    |\n+\n+\n+### Things\n+\n+Four different vehicle types are provided. \n+They differ in the supported channel groups & channels. \n+Conventional Fuel Vehicles have no _Charging Profile_, Electric Vehicles don't provide a _Fuel Range_. \n+For hybrid vehicles in addition to _Fuel and Electric Range_ the _Hybrid Range_ is shown.\n+ \n+| Name                                | Thing Type ID | Supported Channel Groups                               |\n+|-------------------------------------|---------------|--------------------------------------------------------|\n+| BMW Electric Vehicle                | bev           | status, range, location, service, check, charge, image |\n+| BMW Electric Vehicle with REX       | bev_rex       | status, range, location, service, check, charge, image |\n+| BMW Plug-In-Hybrid Electric Vehicle | phev          | status, range, location, service, check, charge, image |\n+| BMW Conventional Vehicle            | conv          | status, range, location, service, check, image         |\n+\n+ \n+#### Properties\n+\n+<img align=\"right\" src=\"./doc/properties.png\" width=\"500\" height=\"600\"/>\n+\n+For each vehicle properties are available. \n+Basically 3 types of information are registered as properties\n+\n+* Informations regarding your dealer with address and phone number\n+* Which services are available / not available\n+* Vehicle properties like color, model type, drive train and construction year\n+\n+In the right picture can see in *Services Activated* e.g. the *DoorLock* and *DoorUnlock* services are mentioned. \n+This ensures channel group [Remote Services](#remote-services) is supporting door lock and unlock remote control.\n+\n+In  *Services Supported* the entry *LastDestination* is mentioned.\n+So it's valid to connect channel group [Last Destinations](#destinations) in order to display and select the last navigation destinations.\n+\n+| Property Key       | Property Value      |  Supported Channel Groups    |\n+|--------------------|---------------------|------------------------------|\n+| Services Supported | Statistics          | last-trip, lifetime          |\n+| Services Supported | LastDestinations    | destinations                 |\n+| Services Activated | _list of services_  | remote                       |\n+\n+\n+## Discovery\n+\n+Auto discovery is starting after the bridge towards BMW's ConnectedDrive is created. \n+A list of your registered vehicles is queried and all found things are added in the inbox.\n+Unique identifier is the *Vehicle Identification Number* (VIN). \n+If a thing is already declared in a  _.things_ configuration, discovery won't highlight it again.\n+Properties will be attached to predefined vehicles if the VIN is matching.\n+\n+## Configuration\n+\n+### Bridge Configuration\n+\n+| Parameter       | Type    | Description                                                        |           \n+|-----------------|---------|--------------------------------------------------------------------|\n+| userName        | text    | BMW ConnectedDrive Username                                       |\n+| password        | text    | BMW ConnectedDrive Password                                       |\n+| region          | text    | Select region in order to connect to the appropriate BMW server.   |\n+\n+The region Configuration has 3 different options\n+\n+* _NORTH_AMERICA_\n+* _CHINA_\n+* _ROW_  (Rest of World)\n+\n+### Thing Configuration\n+\n+Same configuration is needed for all things\n+\n+| Parameter       | Type    | Description                           |           \n+|-----------------|---------|---------------------------------------|\n+| vin             | text    | Vehicle Identification Number (VIN)   |\n+| refreshInterval | integer | Refresh Interval in Minutes           |\n+| units           | text    | Unit Selection. See below.            |\n+| imageSize       | integer | Image Size                            |\n+| imageViewport   | text    | Image Viewport                        |\n+\n+The unit configuration has 3 options\n+\n+* _AUTODETECT_ selects miles for US & UK, kilometer otherwise\n+* _METRIC_ selects directly kilometers\n+* _IMPERIAL_ selects directly miles\n+\n+The _imageVieport_ allows to show the vehicle from different angels.\n+Possible options are \n+\n+* _FRONT_\n+* _REAR_\n+* _SIDE_\n+* _DASHBOARD_\n+* _DRIVERDOOR_\n+\n+## Channels\n+\n+There are many channels available for each vehicle. \n+For better overview they are clustered in different channel groups.\n+They differ for each vehicle type, build-in sensors and activated services.\n+\n+\n+### Thing Channel Groups \n+\n+#### Vehicle Status\n+\n+Reflects overall status of the vehicle.\n+\n+* Channel Group ID is **status**\n+* Available for all vehicles\n+* Read-only values\n+\n+| Channel Label             | Channel ID          | Type          | Description                                    |\n+|---------------------------|---------------------|---------------|------------------------------------------------|\n+| Overall Door Status       | doors               | String        | Combined status for all doors                  |\n+| Overall Window Status     | windows             | String        | Combined status for all windows                |\n+| Doors Locked              | lock                | String        | Status if doors are locked or unlocked         |\n+| Next Service Date         | service-date        | DateTime      | Date of upcoming service                       |\n+| Mileage till Next Service | service-mileage     | Number:Length | Mileage till upcoming service                  |\n+| Check Control             | check-control       | String        | Presence of active warning messages            |\n+| Charging Status           | charge              | String        | Only available for phev, bev_rex and bev       |\n+| Last Status Timestamp     | last-update         | DateTime      | Date and time of last status update            |\n+\n+Overall Door Status values\n+\n+* _Closed_ - all doors closed\n+* _Open_ - at least one door is open\n+* _Unknown_ - no door data delivered at all\n+\n+Overall Windows Status values\n+\n+* _Closed_ - all windows closed\n+* _Open_ - at least one window is completely open\n+* _Intermediate_ - at least one window is partially open\n+* _Unknown_ - no window data delivered at all\n+\n+Check Control values\n+\n+* _Active_ - at least one warning message is active\n+* _Not Active_ - no warning message is active\n+* _Unknown_ - no data for warnings delivered\n+\n+Charging Status values\n+\n+* _Charging_\n+* _Error_\n+* _Finished Fully Charged_\n+* _Finished Not Full_\n+* _Invalid_\n+* _Not Charging_\n+* _Charging Goal reached_\n+* _Waiting For Charging_\n+\n+#### Services\n+\n+Group for all upcoming services with description, service date and/or service mileage.\n+If more than one service is scheduled in the future the channel _name_ contains all future services as options.\n+\n+* Channel Group ID is **service**\n+* Available for all vehicles\n+* Read/Write access\n+\n+| Channel Label                  | Channel ID          | Type           | Access     |\n+|--------------------------------|---------------------|----------------|------------|\n+| Service Name                   | name                | String         | Read/Write |\n+| Service Date                   | date                | Number         | Read       |\n+| Mileage till Service           | mileage             | Number:Length  | Read       |\n+\n+#### Check Control\n+\n+Group for all current active CheckControl messages.\n+If more than one message is active the channel _name_ contains all active messages as options.\n+\n+* Channel Group ID is **check**\n+* Available for all vehicles\n+* Read/Write access\n+\n+| Channel Label                   | Channel ID          | Type           | Access     |\n+|---------------------------------|---------------------|----------------|------------|\n+| CheckControl Description        | name                | String         | Read/Write |\n+| CheckControl Mileage Occurrence | mileage             | Number:Length  | Read       |\n+\n+#### Doors Details\n+\n+Detailed status of all doors and windows.\n+\n+* Channel Group ID is **doors**\n+* Available for all vehicles if corresponding sensors are built-in \n+* Read-only values\n+ \n+| Channel Label              | Channel ID              | Type          | \n+|----------------------------|-------------------------|---------------|\n+| Driver Door                | driver-front            | String        |\n+| Driver Door Rear           | driver-rear             | String        |\n+| Passenger Door             | passenger-front         | String        |\n+| Passenger Door Rear        | passenger-rear          | String        |\n+| Trunk                      | trunk                   | String        |\n+| Hood                       | hood                    | String        |\n+| Driver Door Window         | win-driver-front        | String        |\n+| Driver Door Rear Window    | win-driver-rear         | String        |\n+| Passenger Door Window      | win-passenger-front     | String        |\n+| Passenger Door Rear Window | win-passenger-rear      | String        |\n+| Rear Window                | win-rear                | String        |\n+| Sunroof                    | sunroof                 | String        |\n+\n+Possible states\n+\n+* _Unknown_ - no status data available\n+* _Invalid_ - this door / window isn't applicable for this vehicle\n+* _Closed_ - the door / window is closed\n+* _Open_ - the door / window is open\n+* _Intermediate_ - window in intermediate position, not applicable for doors\n+\n+#### Range Data\n+\n+Based on vehicle type some channels are present or not. \n+Conventional fuel vehicles don't provide *Electric Range* and battery electric vehicles don't show *Fuel Range*.\n+Hybrid vehicles have both and in addition *Hybrid Range*.\n+See description [Range vs Range Radius](#range-vs-range-radius) to get more information.\n+\n+* Channel Group ID is **range**\n+* Availability according to table\n+* Read-only values\n+\n+| Channel Label         | Channel ID            | Type                 | conv | phev | bev_rex | bev |\n+|-----------------------|-----------------------|----------------------|------|------|---------|-----|\n+| Mileage               | mileage               | Number:Length        |  X   |  X   |    X    |  X  |\n+| Fuel Range            | range-fuel            | Number:Length        |  X   |  X   |    X    |     |\n+| Battery Range         | range-electric        | Number:Length        |      |  X   |    X    |  X  | \n+| Hybrid Range          | range-hybrid          | Number:Length        |      |  X   |    X    |     | \n+| Battery Charge Level  | soc                   | Number:Dimensionless |      |  X   |    X    |  X  |\n+| Remaining Fuel        | remaining-fuel        | Number:Volume        |  X   |  X   |    X    |     | \n+| Fuel Range Radius     | range-radius-fuel     | Number:Length        |  X   |  X   |    X    |     | \n+| Electric Range Radius | range-radius-electric | Number:Length        |      |  X   |    X    |  X  | \n+| Hybrid Range Radius   | range-radius-hybrid   | Number:Length        |      |  X   |    X    |     | \n+\n+\n+#### Charge Profile\n+\n+Charging options with date and time for preferred time windows and charging modes.\n+\n+* Channel Group ID is **charge**\n+* Available for electric and hybrid vehicles\n+* Read-only values\n+\n+| Channel Label                      | Channel ID          | Type   | \n+|------------------------------------|---------------------|--------|\n+| Air Conditioning at Departure Time | profile-climate     | Switch | \n+| Charging Mode for Profile          | profile-mode        | String | \n+| Charging Window Start Time         | window-start        | String | \n+| Charging Window End Time           | window-end          | String | \n+| Timer 1: Departure Time            | timer1-departure    | String | \n+| Timer 1: Scheduled Days            | timer1-days         | String | \n+| Timer 1: Enabled                   | timer1-enabled      | Switch | \n+| Timer 2: Departure Time            | timer2-departure    | String | \n+| Timer 2: Scheduled Days            | timer2-days         | String | \n+| Timer 2: Enabled                   | timer2-enabled      | Switch | \n+| Timer 3: Departure Time            | timer3-departure    | String | \n+| Timer 3: Scheduled Days            | timer3-days         | String | \n+| Timer 3: Enabled                   | timer3-enabled      | Switch | \n+\n+\n+#### Location\n+\n+GPS location and heading of the vehicle.\n+\n+* Channel Group ID is **location**\n+* Available for all vehicles with built-in GPS sensor. Function can be enabled/disabled in the head unit\n+* Read-only values\n+\n+| Channel Label   | Channel ID          | Type         | \n+|-----------------|---------------------|--------------|\n+| GPS Coordinates | gps                 | Location     | \n+| Heading         | heading             | Number:Angle | \n+\n+#### Last Trip\n+\n+Statistic values of duration, distance and consumption of the last trip.\n+\n+* Channel Group ID is **last-trip**\n+* Available if *Statistics* is present in *Services Supported*. See [Vehicle Properties](#properties) for further details\n+* Read-only values\n+\n+| Channel Label                           | Channel ID                   | Type          |\n+|-----------------------------------------|------------------------------|---------------|\n+| Last Trip Date                          | date                         | DateTime      |\n+| Last Trip Duration                      | duration                     | Number:Time   |\n+| Average Power Consumption per 100 km    | avg-consumption              | Number:Power  |\n+| Average Combined Consumption per 100 km | avg-combined-consumption     | Number:Volume |\n+| Average Power Recuperation per 100 km   | avg-recuperation             | Number:Power  |\n+| Last Trip Distance                      | distance                     | Number:Length |\n+| Distance since Last Charge              | distance-since-charging      | Number:Length |\n+\n+\n+#### Lifetime Statistics\n+\n+Providing lifetime consumption values.\n+\n+* Channel Group ID is **lifetime**\n+* Available if *Statistics* is present in *Services Supported*. See [Vehicle Properties](#properties) for further details\n+* Read-only values\n+\n+| Channel Label                           | Channel ID                   | Type          | \n+|-----------------------------------------|------------------------------|---------------|\n+| Average Power Consumption per 100 km    | avg-consumption              | Number:Power  |\n+| Average Power Recuperation per 100 km   | avg-recuperation             | Number:Power  |\n+| Cumulated Electric Driven Distance      | cumulated-driven-distance    | Number:Length |\n+| Average Combined Consumption per 100 km | avg-combined-consumption     | Number:Volume |\n+| Longest Distance with one Charge        | single-longest-distance      | Number:Length |\n+\n+\n+#### Remote Services\n+\n+Remote control of the vehicle. \n+Send a *command* to the vehicle and the *state* is reporting the execution progress.\n+Only one command can be executed each time.\n+Parallel execution isn't supported.\n+\n+* Channel Group ID is **remote**\n+* Available for all commands mentioned in *Services Activated*. See [Vehicle Properties](#properties) for further details\n+* Read/Write access\n+\n+\n+| Channel Label           | Channel ID          | Type    | Access |\n+|-------------------------|---------------------|---------|--------|\n+| Remote Service Command  | command             | String  | Write  |\n+| Service Execution State | state               | String  | Read   |\n+\n+The channel _command_ provides options\n+\n+* _Flash Lights_ \n+* _Vehicle Finder_\n+* _Door Lock_\n+* _Door Unlock_\n+* _Horn Blow_\n+* _Climate Control_\n+\n+The channel _state_ shows the progress of the command execution in the following order\n+\n+1) _Initiated_ \n+2) _Pending_\n+3) _Delivered_\n+4) _Executed_\n+\n+#### Destinations\n+\n+Shows the last destinations stored in the navigation system.\n+If several last destinations are stored in the navigation system the channel _name_ contains all addresses as options.\n+\n+* Channel Group ID is **destination**\n+* Available if *LastDestinations* is present in *Services Supported*. Check [Vehicle Properties](#properties) for further details\n+* Read/Write access\n+\n+\n+| Channel Label                    | Channel ID          | Type      | Access      |\n+|----------------------------------|---------------------|-----------|-------------|\n+| Destination Name                 | name                | String    | Read/Write  |\n+| Destination GPS Coordinates      | gps                 | Location  | Read        |\n+\n+\n+\n+#### Image\n+\n+Image representation of the vehicle. Size and viewport are writable and can be \n+The possible values are the same mentioned in [Thing Configuration](#thing-configuration).\n+\n+* Channel Group ID is **image**\n+* Available for all vehicles\n+* Read/Write access\n+\n+| Channel Label                 | Channel ID          | Type   |  Access  |\n+|-------------------------------|---------------------|--------|----------|\n+| Rendered Image of the Vehicle | png                 | Image  | Read     |\n+| Image Viewport                | view                | String | Write    |\n+| Image Picture Size            | size                | Number | Write    |\n+\n+\n+## Further Descriptions\n+\n+### Dynamic Data\n+\n+<img align=\"right\" src=\"./doc/ServiceOptions.png\" width=\"400\" height=\"350\"/>\n+\n+There are 3 occurrences of dynamic data delivered\n+\n+* Upcoming Services delivered in group [Services](#services)\n+* Check Control Messages delivered in group [Check Control](#check-control)\n+* Last Destinations delivered in group [Destinations](#destinations)\n+\n+The channel id _name_ shows the first element as default. \n+All other possibilities are attached as options. \n+The picture on the right shows the _Service Name_ item and all four possible options. \n+Select the wanted service and the corresponding _Service Date & Milage_ will be shown.  ", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "71d5496aba829f6628dd1676734e39c5a7d14f2f"}, "originalPosition": 424}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDgxNjc5MQ==", "bodyText": "Corrected", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r550816791", "createdAt": "2021-01-01T22:55:55Z", "author": {"login": "weymann"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/README.md", "diffHunk": "@@ -0,0 +1,686 @@\n+# BMW ConnectedDrive Binding\n+\n+<img align=\"right\" src=\"./doc/bmw-connected.png\" width=\"150\" height=\"150\"/>\n+\n+The binding provides a connection between [BMW's ConnectedDrive Portal](https://www.bmw-connecteddrive.com/country-region-select/country-region-selection.html) and openHAB.\n+All vehicles connected to an account will be detected by the discovery with the correct type \n+\n+* Conventional Fuel Vehicle\n+* Plugin-Hybrid Electrical Vehicle \n+* Battery Electric Vehicle with Range Extender\n+* Battery Electric Vehicle \n+\n+In addition properties are attached with information and services provided by this vehicle.\n+The provided data depends on \n+\n+1. the [Thing Type](#things) and \n+2. the [Properties](#properties) mentioned in Services\n+\n+Different channel groups are clustering all informations.\n+Check for each group if it's supported for this Vehicle.\n+\n+Please note **this isn't a real-time binding**. \n+If a door is opened the state isn't transmitted and changed immediately. \n+This isn't a flaw in the binding itself because the state in BMW's own ConnectedDrive App is also updated with some delay. \n+\n+## Supported Things\n+\n+### Bridge\n+\n+The bridge establishes the connection between BMW's ConnectedDrive Portal and openHAB.\n+\n+| Name                       | Bridge Type ID | Description                                                |\n+|----------------------------|----------------|------------------------------------------------------------|\n+| BMW ConnectedDrive Account | account        | Access to BMW ConnectedDrive Portal for a specific user    |\n+\n+\n+### Things\n+\n+Four different vehicle types are provided. \n+They differ in the supported channel groups & channels. \n+Conventional Fuel Vehicles have no _Charging Profile_, Electric Vehicles don't provide a _Fuel Range_. \n+For hybrid vehicles in addition to _Fuel and Electric Range_ the _Hybrid Range_ is shown.\n+ \n+| Name                                | Thing Type ID | Supported Channel Groups                               |\n+|-------------------------------------|---------------|--------------------------------------------------------|\n+| BMW Electric Vehicle                | bev           | status, range, location, service, check, charge, image |\n+| BMW Electric Vehicle with REX       | bev_rex       | status, range, location, service, check, charge, image |\n+| BMW Plug-In-Hybrid Electric Vehicle | phev          | status, range, location, service, check, charge, image |\n+| BMW Conventional Vehicle            | conv          | status, range, location, service, check, image         |\n+\n+ \n+#### Properties\n+\n+<img align=\"right\" src=\"./doc/properties.png\" width=\"500\" height=\"600\"/>\n+\n+For each vehicle properties are available. \n+Basically 3 types of information are registered as properties\n+\n+* Informations regarding your dealer with address and phone number\n+* Which services are available / not available\n+* Vehicle properties like color, model type, drive train and construction year\n+\n+In the right picture can see in *Services Activated* e.g. the *DoorLock* and *DoorUnlock* services are mentioned. \n+This ensures channel group [Remote Services](#remote-services) is supporting door lock and unlock remote control.\n+\n+In  *Services Supported* the entry *LastDestination* is mentioned.\n+So it's valid to connect channel group [Last Destinations](#destinations) in order to display and select the last navigation destinations.\n+\n+| Property Key       | Property Value      |  Supported Channel Groups    |\n+|--------------------|---------------------|------------------------------|\n+| Services Supported | Statistics          | last-trip, lifetime          |\n+| Services Supported | LastDestinations    | destinations                 |\n+| Services Activated | _list of services_  | remote                       |\n+\n+\n+## Discovery\n+\n+Auto discovery is starting after the bridge towards BMW's ConnectedDrive is created. \n+A list of your registered vehicles is queried and all found things are added in the inbox.\n+Unique identifier is the *Vehicle Identification Number* (VIN). \n+If a thing is already declared in a  _.things_ configuration, discovery won't highlight it again.\n+Properties will be attached to predefined vehicles if the VIN is matching.\n+\n+## Configuration\n+\n+### Bridge Configuration\n+\n+| Parameter       | Type    | Description                                                        |           \n+|-----------------|---------|--------------------------------------------------------------------|\n+| userName        | text    | BMW ConnectedDrive Username                                       |\n+| password        | text    | BMW ConnectedDrive Password                                       |\n+| region          | text    | Select region in order to connect to the appropriate BMW server.   |\n+\n+The region Configuration has 3 different options\n+\n+* _NORTH_AMERICA_\n+* _CHINA_\n+* _ROW_  (Rest of World)\n+\n+### Thing Configuration\n+\n+Same configuration is needed for all things\n+\n+| Parameter       | Type    | Description                           |           \n+|-----------------|---------|---------------------------------------|\n+| vin             | text    | Vehicle Identification Number (VIN)   |\n+| refreshInterval | integer | Refresh Interval in Minutes           |\n+| units           | text    | Unit Selection. See below.            |\n+| imageSize       | integer | Image Size                            |\n+| imageViewport   | text    | Image Viewport                        |\n+\n+The unit configuration has 3 options\n+\n+* _AUTODETECT_ selects miles for US & UK, kilometer otherwise\n+* _METRIC_ selects directly kilometers\n+* _IMPERIAL_ selects directly miles\n+\n+The _imageVieport_ allows to show the vehicle from different angels.\n+Possible options are \n+\n+* _FRONT_\n+* _REAR_\n+* _SIDE_\n+* _DASHBOARD_\n+* _DRIVERDOOR_\n+\n+## Channels\n+\n+There are many channels available for each vehicle. \n+For better overview they are clustered in different channel groups.\n+They differ for each vehicle type, build-in sensors and activated services.\n+\n+\n+### Thing Channel Groups \n+\n+#### Vehicle Status\n+\n+Reflects overall status of the vehicle.\n+\n+* Channel Group ID is **status**\n+* Available for all vehicles\n+* Read-only values\n+\n+| Channel Label             | Channel ID          | Type          | Description                                    |\n+|---------------------------|---------------------|---------------|------------------------------------------------|\n+| Overall Door Status       | doors               | String        | Combined status for all doors                  |\n+| Overall Window Status     | windows             | String        | Combined status for all windows                |\n+| Doors Locked              | lock                | String        | Status if doors are locked or unlocked         |\n+| Next Service Date         | service-date        | DateTime      | Date of upcoming service                       |\n+| Mileage till Next Service | service-mileage     | Number:Length | Mileage till upcoming service                  |\n+| Check Control             | check-control       | String        | Presence of active warning messages            |\n+| Charging Status           | charge              | String        | Only available for phev, bev_rex and bev       |\n+| Last Status Timestamp     | last-update         | DateTime      | Date and time of last status update            |\n+\n+Overall Door Status values\n+\n+* _Closed_ - all doors closed\n+* _Open_ - at least one door is open\n+* _Unknown_ - no door data delivered at all\n+\n+Overall Windows Status values\n+\n+* _Closed_ - all windows closed\n+* _Open_ - at least one window is completely open\n+* _Intermediate_ - at least one window is partially open\n+* _Unknown_ - no window data delivered at all\n+\n+Check Control values\n+\n+* _Active_ - at least one warning message is active\n+* _Not Active_ - no warning message is active\n+* _Unknown_ - no data for warnings delivered\n+\n+Charging Status values\n+\n+* _Charging_\n+* _Error_\n+* _Finished Fully Charged_\n+* _Finished Not Full_\n+* _Invalid_\n+* _Not Charging_\n+* _Charging Goal reached_\n+* _Waiting For Charging_\n+\n+#### Services\n+\n+Group for all upcoming services with description, service date and/or service mileage.\n+If more than one service is scheduled in the future the channel _name_ contains all future services as options.\n+\n+* Channel Group ID is **service**\n+* Available for all vehicles\n+* Read/Write access\n+\n+| Channel Label                  | Channel ID          | Type           | Access     |\n+|--------------------------------|---------------------|----------------|------------|\n+| Service Name                   | name                | String         | Read/Write |\n+| Service Date                   | date                | Number         | Read       |\n+| Mileage till Service           | mileage             | Number:Length  | Read       |\n+\n+#### Check Control\n+\n+Group for all current active CheckControl messages.\n+If more than one message is active the channel _name_ contains all active messages as options.\n+\n+* Channel Group ID is **check**\n+* Available for all vehicles\n+* Read/Write access\n+\n+| Channel Label                   | Channel ID          | Type           | Access     |\n+|---------------------------------|---------------------|----------------|------------|\n+| CheckControl Description        | name                | String         | Read/Write |\n+| CheckControl Mileage Occurrence | mileage             | Number:Length  | Read       |\n+\n+#### Doors Details\n+\n+Detailed status of all doors and windows.\n+\n+* Channel Group ID is **doors**\n+* Available for all vehicles if corresponding sensors are built-in \n+* Read-only values\n+ \n+| Channel Label              | Channel ID              | Type          | \n+|----------------------------|-------------------------|---------------|\n+| Driver Door                | driver-front            | String        |\n+| Driver Door Rear           | driver-rear             | String        |\n+| Passenger Door             | passenger-front         | String        |\n+| Passenger Door Rear        | passenger-rear          | String        |\n+| Trunk                      | trunk                   | String        |\n+| Hood                       | hood                    | String        |\n+| Driver Door Window         | win-driver-front        | String        |\n+| Driver Door Rear Window    | win-driver-rear         | String        |\n+| Passenger Door Window      | win-passenger-front     | String        |\n+| Passenger Door Rear Window | win-passenger-rear      | String        |\n+| Rear Window                | win-rear                | String        |\n+| Sunroof                    | sunroof                 | String        |\n+\n+Possible states\n+\n+* _Unknown_ - no status data available\n+* _Invalid_ - this door / window isn't applicable for this vehicle\n+* _Closed_ - the door / window is closed\n+* _Open_ - the door / window is open\n+* _Intermediate_ - window in intermediate position, not applicable for doors\n+\n+#### Range Data\n+\n+Based on vehicle type some channels are present or not. \n+Conventional fuel vehicles don't provide *Electric Range* and battery electric vehicles don't show *Fuel Range*.\n+Hybrid vehicles have both and in addition *Hybrid Range*.\n+See description [Range vs Range Radius](#range-vs-range-radius) to get more information.\n+\n+* Channel Group ID is **range**\n+* Availability according to table\n+* Read-only values\n+\n+| Channel Label         | Channel ID            | Type                 | conv | phev | bev_rex | bev |\n+|-----------------------|-----------------------|----------------------|------|------|---------|-----|\n+| Mileage               | mileage               | Number:Length        |  X   |  X   |    X    |  X  |\n+| Fuel Range            | range-fuel            | Number:Length        |  X   |  X   |    X    |     |\n+| Battery Range         | range-electric        | Number:Length        |      |  X   |    X    |  X  | \n+| Hybrid Range          | range-hybrid          | Number:Length        |      |  X   |    X    |     | \n+| Battery Charge Level  | soc                   | Number:Dimensionless |      |  X   |    X    |  X  |\n+| Remaining Fuel        | remaining-fuel        | Number:Volume        |  X   |  X   |    X    |     | \n+| Fuel Range Radius     | range-radius-fuel     | Number:Length        |  X   |  X   |    X    |     | \n+| Electric Range Radius | range-radius-electric | Number:Length        |      |  X   |    X    |  X  | \n+| Hybrid Range Radius   | range-radius-hybrid   | Number:Length        |      |  X   |    X    |     | \n+\n+\n+#### Charge Profile\n+\n+Charging options with date and time for preferred time windows and charging modes.\n+\n+* Channel Group ID is **charge**\n+* Available for electric and hybrid vehicles\n+* Read-only values\n+\n+| Channel Label                      | Channel ID          | Type   | \n+|------------------------------------|---------------------|--------|\n+| Air Conditioning at Departure Time | profile-climate     | Switch | \n+| Charging Mode for Profile          | profile-mode        | String | \n+| Charging Window Start Time         | window-start        | String | \n+| Charging Window End Time           | window-end          | String | \n+| Timer 1: Departure Time            | timer1-departure    | String | \n+| Timer 1: Scheduled Days            | timer1-days         | String | \n+| Timer 1: Enabled                   | timer1-enabled      | Switch | \n+| Timer 2: Departure Time            | timer2-departure    | String | \n+| Timer 2: Scheduled Days            | timer2-days         | String | \n+| Timer 2: Enabled                   | timer2-enabled      | Switch | \n+| Timer 3: Departure Time            | timer3-departure    | String | \n+| Timer 3: Scheduled Days            | timer3-days         | String | \n+| Timer 3: Enabled                   | timer3-enabled      | Switch | \n+\n+\n+#### Location\n+\n+GPS location and heading of the vehicle.\n+\n+* Channel Group ID is **location**\n+* Available for all vehicles with built-in GPS sensor. Function can be enabled/disabled in the head unit\n+* Read-only values\n+\n+| Channel Label   | Channel ID          | Type         | \n+|-----------------|---------------------|--------------|\n+| GPS Coordinates | gps                 | Location     | \n+| Heading         | heading             | Number:Angle | \n+\n+#### Last Trip\n+\n+Statistic values of duration, distance and consumption of the last trip.\n+\n+* Channel Group ID is **last-trip**\n+* Available if *Statistics* is present in *Services Supported*. See [Vehicle Properties](#properties) for further details\n+* Read-only values\n+\n+| Channel Label                           | Channel ID                   | Type          |\n+|-----------------------------------------|------------------------------|---------------|\n+| Last Trip Date                          | date                         | DateTime      |\n+| Last Trip Duration                      | duration                     | Number:Time   |\n+| Average Power Consumption per 100 km    | avg-consumption              | Number:Power  |\n+| Average Combined Consumption per 100 km | avg-combined-consumption     | Number:Volume |\n+| Average Power Recuperation per 100 km   | avg-recuperation             | Number:Power  |\n+| Last Trip Distance                      | distance                     | Number:Length |\n+| Distance since Last Charge              | distance-since-charging      | Number:Length |\n+\n+\n+#### Lifetime Statistics\n+\n+Providing lifetime consumption values.\n+\n+* Channel Group ID is **lifetime**\n+* Available if *Statistics* is present in *Services Supported*. See [Vehicle Properties](#properties) for further details\n+* Read-only values\n+\n+| Channel Label                           | Channel ID                   | Type          | \n+|-----------------------------------------|------------------------------|---------------|\n+| Average Power Consumption per 100 km    | avg-consumption              | Number:Power  |\n+| Average Power Recuperation per 100 km   | avg-recuperation             | Number:Power  |\n+| Cumulated Electric Driven Distance      | cumulated-driven-distance    | Number:Length |\n+| Average Combined Consumption per 100 km | avg-combined-consumption     | Number:Volume |\n+| Longest Distance with one Charge        | single-longest-distance      | Number:Length |\n+\n+\n+#### Remote Services\n+\n+Remote control of the vehicle. \n+Send a *command* to the vehicle and the *state* is reporting the execution progress.\n+Only one command can be executed each time.\n+Parallel execution isn't supported.\n+\n+* Channel Group ID is **remote**\n+* Available for all commands mentioned in *Services Activated*. See [Vehicle Properties](#properties) for further details\n+* Read/Write access\n+\n+\n+| Channel Label           | Channel ID          | Type    | Access |\n+|-------------------------|---------------------|---------|--------|\n+| Remote Service Command  | command             | String  | Write  |\n+| Service Execution State | state               | String  | Read   |\n+\n+The channel _command_ provides options\n+\n+* _Flash Lights_ \n+* _Vehicle Finder_\n+* _Door Lock_\n+* _Door Unlock_\n+* _Horn Blow_\n+* _Climate Control_\n+\n+The channel _state_ shows the progress of the command execution in the following order\n+\n+1) _Initiated_ \n+2) _Pending_\n+3) _Delivered_\n+4) _Executed_\n+\n+#### Destinations\n+\n+Shows the last destinations stored in the navigation system.\n+If several last destinations are stored in the navigation system the channel _name_ contains all addresses as options.\n+\n+* Channel Group ID is **destination**\n+* Available if *LastDestinations* is present in *Services Supported*. Check [Vehicle Properties](#properties) for further details\n+* Read/Write access\n+\n+\n+| Channel Label                    | Channel ID          | Type      | Access      |\n+|----------------------------------|---------------------|-----------|-------------|\n+| Destination Name                 | name                | String    | Read/Write  |\n+| Destination GPS Coordinates      | gps                 | Location  | Read        |\n+\n+\n+\n+#### Image\n+\n+Image representation of the vehicle. Size and viewport are writable and can be \n+The possible values are the same mentioned in [Thing Configuration](#thing-configuration).\n+\n+* Channel Group ID is **image**\n+* Available for all vehicles\n+* Read/Write access\n+\n+| Channel Label                 | Channel ID          | Type   |  Access  |\n+|-------------------------------|---------------------|--------|----------|\n+| Rendered Image of the Vehicle | png                 | Image  | Read     |\n+| Image Viewport                | view                | String | Write    |\n+| Image Picture Size            | size                | Number | Write    |\n+\n+\n+## Further Descriptions\n+\n+### Dynamic Data\n+\n+<img align=\"right\" src=\"./doc/ServiceOptions.png\" width=\"400\" height=\"350\"/>\n+\n+There are 3 occurrences of dynamic data delivered\n+\n+* Upcoming Services delivered in group [Services](#services)\n+* Check Control Messages delivered in group [Check Control](#check-control)\n+* Last Destinations delivered in group [Destinations](#destinations)\n+\n+The channel id _name_ shows the first element as default. \n+All other possibilities are attached as options. \n+The picture on the right shows the _Service Name_ item and all four possible options. \n+Select the wanted service and the corresponding _Service Date & Milage_ will be shown.  ", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTg4NzM3Mg=="}, "originalCommit": {"oid": "71d5496aba829f6628dd1676734e39c5a7d14f2f"}, "originalPosition": 424}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ1OTE4NTQwOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.bmwconnecteddrive/README.md", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yOVQyMzozNzowN1rOIMafOw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wMVQyMjo1Njo0N1rOINTMiQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTg4NzgwMw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            less openhab.log | grep \"BMW ConnectedDrive Binding\"\n          \n          \n            \n            grep \"BMW ConnectedDrive Binding\" openhab.log", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r549887803", "createdAt": "2020-12-29T23:37:07Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/README.md", "diffHunk": "@@ -0,0 +1,686 @@\n+# BMW ConnectedDrive Binding\n+\n+<img align=\"right\" src=\"./doc/bmw-connected.png\" width=\"150\" height=\"150\"/>\n+\n+The binding provides a connection between [BMW's ConnectedDrive Portal](https://www.bmw-connecteddrive.com/country-region-select/country-region-selection.html) and openHAB.\n+All vehicles connected to an account will be detected by the discovery with the correct type \n+\n+* Conventional Fuel Vehicle\n+* Plugin-Hybrid Electrical Vehicle \n+* Battery Electric Vehicle with Range Extender\n+* Battery Electric Vehicle \n+\n+In addition properties are attached with information and services provided by this vehicle.\n+The provided data depends on \n+\n+1. the [Thing Type](#things) and \n+2. the [Properties](#properties) mentioned in Services\n+\n+Different channel groups are clustering all informations.\n+Check for each group if it's supported for this Vehicle.\n+\n+Please note **this isn't a real-time binding**. \n+If a door is opened the state isn't transmitted and changed immediately. \n+This isn't a flaw in the binding itself because the state in BMW's own ConnectedDrive App is also updated with some delay. \n+\n+## Supported Things\n+\n+### Bridge\n+\n+The bridge establishes the connection between BMW's ConnectedDrive Portal and openHAB.\n+\n+| Name                       | Bridge Type ID | Description                                                |\n+|----------------------------|----------------|------------------------------------------------------------|\n+| BMW ConnectedDrive Account | account        | Access to BMW ConnectedDrive Portal for a specific user    |\n+\n+\n+### Things\n+\n+Four different vehicle types are provided. \n+They differ in the supported channel groups & channels. \n+Conventional Fuel Vehicles have no _Charging Profile_, Electric Vehicles don't provide a _Fuel Range_. \n+For hybrid vehicles in addition to _Fuel and Electric Range_ the _Hybrid Range_ is shown.\n+ \n+| Name                                | Thing Type ID | Supported Channel Groups                               |\n+|-------------------------------------|---------------|--------------------------------------------------------|\n+| BMW Electric Vehicle                | bev           | status, range, location, service, check, charge, image |\n+| BMW Electric Vehicle with REX       | bev_rex       | status, range, location, service, check, charge, image |\n+| BMW Plug-In-Hybrid Electric Vehicle | phev          | status, range, location, service, check, charge, image |\n+| BMW Conventional Vehicle            | conv          | status, range, location, service, check, image         |\n+\n+ \n+#### Properties\n+\n+<img align=\"right\" src=\"./doc/properties.png\" width=\"500\" height=\"600\"/>\n+\n+For each vehicle properties are available. \n+Basically 3 types of information are registered as properties\n+\n+* Informations regarding your dealer with address and phone number\n+* Which services are available / not available\n+* Vehicle properties like color, model type, drive train and construction year\n+\n+In the right picture can see in *Services Activated* e.g. the *DoorLock* and *DoorUnlock* services are mentioned. \n+This ensures channel group [Remote Services](#remote-services) is supporting door lock and unlock remote control.\n+\n+In  *Services Supported* the entry *LastDestination* is mentioned.\n+So it's valid to connect channel group [Last Destinations](#destinations) in order to display and select the last navigation destinations.\n+\n+| Property Key       | Property Value      |  Supported Channel Groups    |\n+|--------------------|---------------------|------------------------------|\n+| Services Supported | Statistics          | last-trip, lifetime          |\n+| Services Supported | LastDestinations    | destinations                 |\n+| Services Activated | _list of services_  | remote                       |\n+\n+\n+## Discovery\n+\n+Auto discovery is starting after the bridge towards BMW's ConnectedDrive is created. \n+A list of your registered vehicles is queried and all found things are added in the inbox.\n+Unique identifier is the *Vehicle Identification Number* (VIN). \n+If a thing is already declared in a  _.things_ configuration, discovery won't highlight it again.\n+Properties will be attached to predefined vehicles if the VIN is matching.\n+\n+## Configuration\n+\n+### Bridge Configuration\n+\n+| Parameter       | Type    | Description                                                        |           \n+|-----------------|---------|--------------------------------------------------------------------|\n+| userName        | text    | BMW ConnectedDrive Username                                       |\n+| password        | text    | BMW ConnectedDrive Password                                       |\n+| region          | text    | Select region in order to connect to the appropriate BMW server.   |\n+\n+The region Configuration has 3 different options\n+\n+* _NORTH_AMERICA_\n+* _CHINA_\n+* _ROW_  (Rest of World)\n+\n+### Thing Configuration\n+\n+Same configuration is needed for all things\n+\n+| Parameter       | Type    | Description                           |           \n+|-----------------|---------|---------------------------------------|\n+| vin             | text    | Vehicle Identification Number (VIN)   |\n+| refreshInterval | integer | Refresh Interval in Minutes           |\n+| units           | text    | Unit Selection. See below.            |\n+| imageSize       | integer | Image Size                            |\n+| imageViewport   | text    | Image Viewport                        |\n+\n+The unit configuration has 3 options\n+\n+* _AUTODETECT_ selects miles for US & UK, kilometer otherwise\n+* _METRIC_ selects directly kilometers\n+* _IMPERIAL_ selects directly miles\n+\n+The _imageVieport_ allows to show the vehicle from different angels.\n+Possible options are \n+\n+* _FRONT_\n+* _REAR_\n+* _SIDE_\n+* _DASHBOARD_\n+* _DRIVERDOOR_\n+\n+## Channels\n+\n+There are many channels available for each vehicle. \n+For better overview they are clustered in different channel groups.\n+They differ for each vehicle type, build-in sensors and activated services.\n+\n+\n+### Thing Channel Groups \n+\n+#### Vehicle Status\n+\n+Reflects overall status of the vehicle.\n+\n+* Channel Group ID is **status**\n+* Available for all vehicles\n+* Read-only values\n+\n+| Channel Label             | Channel ID          | Type          | Description                                    |\n+|---------------------------|---------------------|---------------|------------------------------------------------|\n+| Overall Door Status       | doors               | String        | Combined status for all doors                  |\n+| Overall Window Status     | windows             | String        | Combined status for all windows                |\n+| Doors Locked              | lock                | String        | Status if doors are locked or unlocked         |\n+| Next Service Date         | service-date        | DateTime      | Date of upcoming service                       |\n+| Mileage till Next Service | service-mileage     | Number:Length | Mileage till upcoming service                  |\n+| Check Control             | check-control       | String        | Presence of active warning messages            |\n+| Charging Status           | charge              | String        | Only available for phev, bev_rex and bev       |\n+| Last Status Timestamp     | last-update         | DateTime      | Date and time of last status update            |\n+\n+Overall Door Status values\n+\n+* _Closed_ - all doors closed\n+* _Open_ - at least one door is open\n+* _Unknown_ - no door data delivered at all\n+\n+Overall Windows Status values\n+\n+* _Closed_ - all windows closed\n+* _Open_ - at least one window is completely open\n+* _Intermediate_ - at least one window is partially open\n+* _Unknown_ - no window data delivered at all\n+\n+Check Control values\n+\n+* _Active_ - at least one warning message is active\n+* _Not Active_ - no warning message is active\n+* _Unknown_ - no data for warnings delivered\n+\n+Charging Status values\n+\n+* _Charging_\n+* _Error_\n+* _Finished Fully Charged_\n+* _Finished Not Full_\n+* _Invalid_\n+* _Not Charging_\n+* _Charging Goal reached_\n+* _Waiting For Charging_\n+\n+#### Services\n+\n+Group for all upcoming services with description, service date and/or service mileage.\n+If more than one service is scheduled in the future the channel _name_ contains all future services as options.\n+\n+* Channel Group ID is **service**\n+* Available for all vehicles\n+* Read/Write access\n+\n+| Channel Label                  | Channel ID          | Type           | Access     |\n+|--------------------------------|---------------------|----------------|------------|\n+| Service Name                   | name                | String         | Read/Write |\n+| Service Date                   | date                | Number         | Read       |\n+| Mileage till Service           | mileage             | Number:Length  | Read       |\n+\n+#### Check Control\n+\n+Group for all current active CheckControl messages.\n+If more than one message is active the channel _name_ contains all active messages as options.\n+\n+* Channel Group ID is **check**\n+* Available for all vehicles\n+* Read/Write access\n+\n+| Channel Label                   | Channel ID          | Type           | Access     |\n+|---------------------------------|---------------------|----------------|------------|\n+| CheckControl Description        | name                | String         | Read/Write |\n+| CheckControl Mileage Occurrence | mileage             | Number:Length  | Read       |\n+\n+#### Doors Details\n+\n+Detailed status of all doors and windows.\n+\n+* Channel Group ID is **doors**\n+* Available for all vehicles if corresponding sensors are built-in \n+* Read-only values\n+ \n+| Channel Label              | Channel ID              | Type          | \n+|----------------------------|-------------------------|---------------|\n+| Driver Door                | driver-front            | String        |\n+| Driver Door Rear           | driver-rear             | String        |\n+| Passenger Door             | passenger-front         | String        |\n+| Passenger Door Rear        | passenger-rear          | String        |\n+| Trunk                      | trunk                   | String        |\n+| Hood                       | hood                    | String        |\n+| Driver Door Window         | win-driver-front        | String        |\n+| Driver Door Rear Window    | win-driver-rear         | String        |\n+| Passenger Door Window      | win-passenger-front     | String        |\n+| Passenger Door Rear Window | win-passenger-rear      | String        |\n+| Rear Window                | win-rear                | String        |\n+| Sunroof                    | sunroof                 | String        |\n+\n+Possible states\n+\n+* _Unknown_ - no status data available\n+* _Invalid_ - this door / window isn't applicable for this vehicle\n+* _Closed_ - the door / window is closed\n+* _Open_ - the door / window is open\n+* _Intermediate_ - window in intermediate position, not applicable for doors\n+\n+#### Range Data\n+\n+Based on vehicle type some channels are present or not. \n+Conventional fuel vehicles don't provide *Electric Range* and battery electric vehicles don't show *Fuel Range*.\n+Hybrid vehicles have both and in addition *Hybrid Range*.\n+See description [Range vs Range Radius](#range-vs-range-radius) to get more information.\n+\n+* Channel Group ID is **range**\n+* Availability according to table\n+* Read-only values\n+\n+| Channel Label         | Channel ID            | Type                 | conv | phev | bev_rex | bev |\n+|-----------------------|-----------------------|----------------------|------|------|---------|-----|\n+| Mileage               | mileage               | Number:Length        |  X   |  X   |    X    |  X  |\n+| Fuel Range            | range-fuel            | Number:Length        |  X   |  X   |    X    |     |\n+| Battery Range         | range-electric        | Number:Length        |      |  X   |    X    |  X  | \n+| Hybrid Range          | range-hybrid          | Number:Length        |      |  X   |    X    |     | \n+| Battery Charge Level  | soc                   | Number:Dimensionless |      |  X   |    X    |  X  |\n+| Remaining Fuel        | remaining-fuel        | Number:Volume        |  X   |  X   |    X    |     | \n+| Fuel Range Radius     | range-radius-fuel     | Number:Length        |  X   |  X   |    X    |     | \n+| Electric Range Radius | range-radius-electric | Number:Length        |      |  X   |    X    |  X  | \n+| Hybrid Range Radius   | range-radius-hybrid   | Number:Length        |      |  X   |    X    |     | \n+\n+\n+#### Charge Profile\n+\n+Charging options with date and time for preferred time windows and charging modes.\n+\n+* Channel Group ID is **charge**\n+* Available for electric and hybrid vehicles\n+* Read-only values\n+\n+| Channel Label                      | Channel ID          | Type   | \n+|------------------------------------|---------------------|--------|\n+| Air Conditioning at Departure Time | profile-climate     | Switch | \n+| Charging Mode for Profile          | profile-mode        | String | \n+| Charging Window Start Time         | window-start        | String | \n+| Charging Window End Time           | window-end          | String | \n+| Timer 1: Departure Time            | timer1-departure    | String | \n+| Timer 1: Scheduled Days            | timer1-days         | String | \n+| Timer 1: Enabled                   | timer1-enabled      | Switch | \n+| Timer 2: Departure Time            | timer2-departure    | String | \n+| Timer 2: Scheduled Days            | timer2-days         | String | \n+| Timer 2: Enabled                   | timer2-enabled      | Switch | \n+| Timer 3: Departure Time            | timer3-departure    | String | \n+| Timer 3: Scheduled Days            | timer3-days         | String | \n+| Timer 3: Enabled                   | timer3-enabled      | Switch | \n+\n+\n+#### Location\n+\n+GPS location and heading of the vehicle.\n+\n+* Channel Group ID is **location**\n+* Available for all vehicles with built-in GPS sensor. Function can be enabled/disabled in the head unit\n+* Read-only values\n+\n+| Channel Label   | Channel ID          | Type         | \n+|-----------------|---------------------|--------------|\n+| GPS Coordinates | gps                 | Location     | \n+| Heading         | heading             | Number:Angle | \n+\n+#### Last Trip\n+\n+Statistic values of duration, distance and consumption of the last trip.\n+\n+* Channel Group ID is **last-trip**\n+* Available if *Statistics* is present in *Services Supported*. See [Vehicle Properties](#properties) for further details\n+* Read-only values\n+\n+| Channel Label                           | Channel ID                   | Type          |\n+|-----------------------------------------|------------------------------|---------------|\n+| Last Trip Date                          | date                         | DateTime      |\n+| Last Trip Duration                      | duration                     | Number:Time   |\n+| Average Power Consumption per 100 km    | avg-consumption              | Number:Power  |\n+| Average Combined Consumption per 100 km | avg-combined-consumption     | Number:Volume |\n+| Average Power Recuperation per 100 km   | avg-recuperation             | Number:Power  |\n+| Last Trip Distance                      | distance                     | Number:Length |\n+| Distance since Last Charge              | distance-since-charging      | Number:Length |\n+\n+\n+#### Lifetime Statistics\n+\n+Providing lifetime consumption values.\n+\n+* Channel Group ID is **lifetime**\n+* Available if *Statistics* is present in *Services Supported*. See [Vehicle Properties](#properties) for further details\n+* Read-only values\n+\n+| Channel Label                           | Channel ID                   | Type          | \n+|-----------------------------------------|------------------------------|---------------|\n+| Average Power Consumption per 100 km    | avg-consumption              | Number:Power  |\n+| Average Power Recuperation per 100 km   | avg-recuperation             | Number:Power  |\n+| Cumulated Electric Driven Distance      | cumulated-driven-distance    | Number:Length |\n+| Average Combined Consumption per 100 km | avg-combined-consumption     | Number:Volume |\n+| Longest Distance with one Charge        | single-longest-distance      | Number:Length |\n+\n+\n+#### Remote Services\n+\n+Remote control of the vehicle. \n+Send a *command* to the vehicle and the *state* is reporting the execution progress.\n+Only one command can be executed each time.\n+Parallel execution isn't supported.\n+\n+* Channel Group ID is **remote**\n+* Available for all commands mentioned in *Services Activated*. See [Vehicle Properties](#properties) for further details\n+* Read/Write access\n+\n+\n+| Channel Label           | Channel ID          | Type    | Access |\n+|-------------------------|---------------------|---------|--------|\n+| Remote Service Command  | command             | String  | Write  |\n+| Service Execution State | state               | String  | Read   |\n+\n+The channel _command_ provides options\n+\n+* _Flash Lights_ \n+* _Vehicle Finder_\n+* _Door Lock_\n+* _Door Unlock_\n+* _Horn Blow_\n+* _Climate Control_\n+\n+The channel _state_ shows the progress of the command execution in the following order\n+\n+1) _Initiated_ \n+2) _Pending_\n+3) _Delivered_\n+4) _Executed_\n+\n+#### Destinations\n+\n+Shows the last destinations stored in the navigation system.\n+If several last destinations are stored in the navigation system the channel _name_ contains all addresses as options.\n+\n+* Channel Group ID is **destination**\n+* Available if *LastDestinations* is present in *Services Supported*. Check [Vehicle Properties](#properties) for further details\n+* Read/Write access\n+\n+\n+| Channel Label                    | Channel ID          | Type      | Access      |\n+|----------------------------------|---------------------|-----------|-------------|\n+| Destination Name                 | name                | String    | Read/Write  |\n+| Destination GPS Coordinates      | gps                 | Location  | Read        |\n+\n+\n+\n+#### Image\n+\n+Image representation of the vehicle. Size and viewport are writable and can be \n+The possible values are the same mentioned in [Thing Configuration](#thing-configuration).\n+\n+* Channel Group ID is **image**\n+* Available for all vehicles\n+* Read/Write access\n+\n+| Channel Label                 | Channel ID          | Type   |  Access  |\n+|-------------------------------|---------------------|--------|----------|\n+| Rendered Image of the Vehicle | png                 | Image  | Read     |\n+| Image Viewport                | view                | String | Write    |\n+| Image Picture Size            | size                | Number | Write    |\n+\n+\n+## Further Descriptions\n+\n+### Dynamic Data\n+\n+<img align=\"right\" src=\"./doc/ServiceOptions.png\" width=\"400\" height=\"350\"/>\n+\n+There are 3 occurrences of dynamic data delivered\n+\n+* Upcoming Services delivered in group [Services](#services)\n+* Check Control Messages delivered in group [Check Control](#check-control)\n+* Last Destinations delivered in group [Destinations](#destinations)\n+\n+The channel id _name_ shows the first element as default. \n+All other possibilities are attached as options. \n+The picture on the right shows the _Service Name_ item and all four possible options. \n+Select the wanted service and the corresponding _Service Date & Milage_ will be shown.  \n+\n+### TroubleShooting\n+\n+BMW has a high range of vehicles supported by ConnectedDrive.\n+In case of any issues with this binding help to resolve it! \n+Please perform the following steps:\n+\n+* Can you [log into ConnectedDrive](https://www.bmw-connecteddrive.com/country-region-select/country-region-selection.html) with your credentials? Please note this isn't the BMW Customer portal - it's the ConnectedDrive portal\n+* Is the vehicle listed in your account? There's a one-to-one relation from user to vehicle\n+\n+If the access to the portal is working and the vehicle is listed some debug data is needed in order to identify the issue. \n+\n+#### Generate Debug Fingerprint\n+\n+If you checked the above pre-conditions you need to get the debug fingerprint from the logs.\n+First [enable debug logging](https://www.openhab.org/docs/administration/logging.html#defining-what-to-log) for the binding.\n+\n+```\n+log:set DEBUG org.openhab.binding.bmwconnecteddrive\n+```\n+\n+The debug fingerprint is generated immediately after the vehicle thing is initialized the first time, e.g. after openHAB startup. \n+To force a new fingerprint disable the thing shortly and enable it again. \n+Personal data is eliminated from the log entries so it should be possible to share them in public.\n+Data like\n+\n+* Dealer Properties\n+* Vehicle Identification Number (VIN)\n+* Location latitude / longitude \n+\n+are anonymized.\n+You'll find the fingerprint in the logs with the command\n+\n+```\n+less openhab.log | grep \"BMW ConnectedDrive Binding\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "71d5496aba829f6628dd1676734e39c5a7d14f2f"}, "originalPosition": 459}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDgxNjkwNQ==", "bodyText": "Corrected", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r550816905", "createdAt": "2021-01-01T22:56:47Z", "author": {"login": "weymann"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/README.md", "diffHunk": "@@ -0,0 +1,686 @@\n+# BMW ConnectedDrive Binding\n+\n+<img align=\"right\" src=\"./doc/bmw-connected.png\" width=\"150\" height=\"150\"/>\n+\n+The binding provides a connection between [BMW's ConnectedDrive Portal](https://www.bmw-connecteddrive.com/country-region-select/country-region-selection.html) and openHAB.\n+All vehicles connected to an account will be detected by the discovery with the correct type \n+\n+* Conventional Fuel Vehicle\n+* Plugin-Hybrid Electrical Vehicle \n+* Battery Electric Vehicle with Range Extender\n+* Battery Electric Vehicle \n+\n+In addition properties are attached with information and services provided by this vehicle.\n+The provided data depends on \n+\n+1. the [Thing Type](#things) and \n+2. the [Properties](#properties) mentioned in Services\n+\n+Different channel groups are clustering all informations.\n+Check for each group if it's supported for this Vehicle.\n+\n+Please note **this isn't a real-time binding**. \n+If a door is opened the state isn't transmitted and changed immediately. \n+This isn't a flaw in the binding itself because the state in BMW's own ConnectedDrive App is also updated with some delay. \n+\n+## Supported Things\n+\n+### Bridge\n+\n+The bridge establishes the connection between BMW's ConnectedDrive Portal and openHAB.\n+\n+| Name                       | Bridge Type ID | Description                                                |\n+|----------------------------|----------------|------------------------------------------------------------|\n+| BMW ConnectedDrive Account | account        | Access to BMW ConnectedDrive Portal for a specific user    |\n+\n+\n+### Things\n+\n+Four different vehicle types are provided. \n+They differ in the supported channel groups & channels. \n+Conventional Fuel Vehicles have no _Charging Profile_, Electric Vehicles don't provide a _Fuel Range_. \n+For hybrid vehicles in addition to _Fuel and Electric Range_ the _Hybrid Range_ is shown.\n+ \n+| Name                                | Thing Type ID | Supported Channel Groups                               |\n+|-------------------------------------|---------------|--------------------------------------------------------|\n+| BMW Electric Vehicle                | bev           | status, range, location, service, check, charge, image |\n+| BMW Electric Vehicle with REX       | bev_rex       | status, range, location, service, check, charge, image |\n+| BMW Plug-In-Hybrid Electric Vehicle | phev          | status, range, location, service, check, charge, image |\n+| BMW Conventional Vehicle            | conv          | status, range, location, service, check, image         |\n+\n+ \n+#### Properties\n+\n+<img align=\"right\" src=\"./doc/properties.png\" width=\"500\" height=\"600\"/>\n+\n+For each vehicle properties are available. \n+Basically 3 types of information are registered as properties\n+\n+* Informations regarding your dealer with address and phone number\n+* Which services are available / not available\n+* Vehicle properties like color, model type, drive train and construction year\n+\n+In the right picture can see in *Services Activated* e.g. the *DoorLock* and *DoorUnlock* services are mentioned. \n+This ensures channel group [Remote Services](#remote-services) is supporting door lock and unlock remote control.\n+\n+In  *Services Supported* the entry *LastDestination* is mentioned.\n+So it's valid to connect channel group [Last Destinations](#destinations) in order to display and select the last navigation destinations.\n+\n+| Property Key       | Property Value      |  Supported Channel Groups    |\n+|--------------------|---------------------|------------------------------|\n+| Services Supported | Statistics          | last-trip, lifetime          |\n+| Services Supported | LastDestinations    | destinations                 |\n+| Services Activated | _list of services_  | remote                       |\n+\n+\n+## Discovery\n+\n+Auto discovery is starting after the bridge towards BMW's ConnectedDrive is created. \n+A list of your registered vehicles is queried and all found things are added in the inbox.\n+Unique identifier is the *Vehicle Identification Number* (VIN). \n+If a thing is already declared in a  _.things_ configuration, discovery won't highlight it again.\n+Properties will be attached to predefined vehicles if the VIN is matching.\n+\n+## Configuration\n+\n+### Bridge Configuration\n+\n+| Parameter       | Type    | Description                                                        |           \n+|-----------------|---------|--------------------------------------------------------------------|\n+| userName        | text    | BMW ConnectedDrive Username                                       |\n+| password        | text    | BMW ConnectedDrive Password                                       |\n+| region          | text    | Select region in order to connect to the appropriate BMW server.   |\n+\n+The region Configuration has 3 different options\n+\n+* _NORTH_AMERICA_\n+* _CHINA_\n+* _ROW_  (Rest of World)\n+\n+### Thing Configuration\n+\n+Same configuration is needed for all things\n+\n+| Parameter       | Type    | Description                           |           \n+|-----------------|---------|---------------------------------------|\n+| vin             | text    | Vehicle Identification Number (VIN)   |\n+| refreshInterval | integer | Refresh Interval in Minutes           |\n+| units           | text    | Unit Selection. See below.            |\n+| imageSize       | integer | Image Size                            |\n+| imageViewport   | text    | Image Viewport                        |\n+\n+The unit configuration has 3 options\n+\n+* _AUTODETECT_ selects miles for US & UK, kilometer otherwise\n+* _METRIC_ selects directly kilometers\n+* _IMPERIAL_ selects directly miles\n+\n+The _imageVieport_ allows to show the vehicle from different angels.\n+Possible options are \n+\n+* _FRONT_\n+* _REAR_\n+* _SIDE_\n+* _DASHBOARD_\n+* _DRIVERDOOR_\n+\n+## Channels\n+\n+There are many channels available for each vehicle. \n+For better overview they are clustered in different channel groups.\n+They differ for each vehicle type, build-in sensors and activated services.\n+\n+\n+### Thing Channel Groups \n+\n+#### Vehicle Status\n+\n+Reflects overall status of the vehicle.\n+\n+* Channel Group ID is **status**\n+* Available for all vehicles\n+* Read-only values\n+\n+| Channel Label             | Channel ID          | Type          | Description                                    |\n+|---------------------------|---------------------|---------------|------------------------------------------------|\n+| Overall Door Status       | doors               | String        | Combined status for all doors                  |\n+| Overall Window Status     | windows             | String        | Combined status for all windows                |\n+| Doors Locked              | lock                | String        | Status if doors are locked or unlocked         |\n+| Next Service Date         | service-date        | DateTime      | Date of upcoming service                       |\n+| Mileage till Next Service | service-mileage     | Number:Length | Mileage till upcoming service                  |\n+| Check Control             | check-control       | String        | Presence of active warning messages            |\n+| Charging Status           | charge              | String        | Only available for phev, bev_rex and bev       |\n+| Last Status Timestamp     | last-update         | DateTime      | Date and time of last status update            |\n+\n+Overall Door Status values\n+\n+* _Closed_ - all doors closed\n+* _Open_ - at least one door is open\n+* _Unknown_ - no door data delivered at all\n+\n+Overall Windows Status values\n+\n+* _Closed_ - all windows closed\n+* _Open_ - at least one window is completely open\n+* _Intermediate_ - at least one window is partially open\n+* _Unknown_ - no window data delivered at all\n+\n+Check Control values\n+\n+* _Active_ - at least one warning message is active\n+* _Not Active_ - no warning message is active\n+* _Unknown_ - no data for warnings delivered\n+\n+Charging Status values\n+\n+* _Charging_\n+* _Error_\n+* _Finished Fully Charged_\n+* _Finished Not Full_\n+* _Invalid_\n+* _Not Charging_\n+* _Charging Goal reached_\n+* _Waiting For Charging_\n+\n+#### Services\n+\n+Group for all upcoming services with description, service date and/or service mileage.\n+If more than one service is scheduled in the future the channel _name_ contains all future services as options.\n+\n+* Channel Group ID is **service**\n+* Available for all vehicles\n+* Read/Write access\n+\n+| Channel Label                  | Channel ID          | Type           | Access     |\n+|--------------------------------|---------------------|----------------|------------|\n+| Service Name                   | name                | String         | Read/Write |\n+| Service Date                   | date                | Number         | Read       |\n+| Mileage till Service           | mileage             | Number:Length  | Read       |\n+\n+#### Check Control\n+\n+Group for all current active CheckControl messages.\n+If more than one message is active the channel _name_ contains all active messages as options.\n+\n+* Channel Group ID is **check**\n+* Available for all vehicles\n+* Read/Write access\n+\n+| Channel Label                   | Channel ID          | Type           | Access     |\n+|---------------------------------|---------------------|----------------|------------|\n+| CheckControl Description        | name                | String         | Read/Write |\n+| CheckControl Mileage Occurrence | mileage             | Number:Length  | Read       |\n+\n+#### Doors Details\n+\n+Detailed status of all doors and windows.\n+\n+* Channel Group ID is **doors**\n+* Available for all vehicles if corresponding sensors are built-in \n+* Read-only values\n+ \n+| Channel Label              | Channel ID              | Type          | \n+|----------------------------|-------------------------|---------------|\n+| Driver Door                | driver-front            | String        |\n+| Driver Door Rear           | driver-rear             | String        |\n+| Passenger Door             | passenger-front         | String        |\n+| Passenger Door Rear        | passenger-rear          | String        |\n+| Trunk                      | trunk                   | String        |\n+| Hood                       | hood                    | String        |\n+| Driver Door Window         | win-driver-front        | String        |\n+| Driver Door Rear Window    | win-driver-rear         | String        |\n+| Passenger Door Window      | win-passenger-front     | String        |\n+| Passenger Door Rear Window | win-passenger-rear      | String        |\n+| Rear Window                | win-rear                | String        |\n+| Sunroof                    | sunroof                 | String        |\n+\n+Possible states\n+\n+* _Unknown_ - no status data available\n+* _Invalid_ - this door / window isn't applicable for this vehicle\n+* _Closed_ - the door / window is closed\n+* _Open_ - the door / window is open\n+* _Intermediate_ - window in intermediate position, not applicable for doors\n+\n+#### Range Data\n+\n+Based on vehicle type some channels are present or not. \n+Conventional fuel vehicles don't provide *Electric Range* and battery electric vehicles don't show *Fuel Range*.\n+Hybrid vehicles have both and in addition *Hybrid Range*.\n+See description [Range vs Range Radius](#range-vs-range-radius) to get more information.\n+\n+* Channel Group ID is **range**\n+* Availability according to table\n+* Read-only values\n+\n+| Channel Label         | Channel ID            | Type                 | conv | phev | bev_rex | bev |\n+|-----------------------|-----------------------|----------------------|------|------|---------|-----|\n+| Mileage               | mileage               | Number:Length        |  X   |  X   |    X    |  X  |\n+| Fuel Range            | range-fuel            | Number:Length        |  X   |  X   |    X    |     |\n+| Battery Range         | range-electric        | Number:Length        |      |  X   |    X    |  X  | \n+| Hybrid Range          | range-hybrid          | Number:Length        |      |  X   |    X    |     | \n+| Battery Charge Level  | soc                   | Number:Dimensionless |      |  X   |    X    |  X  |\n+| Remaining Fuel        | remaining-fuel        | Number:Volume        |  X   |  X   |    X    |     | \n+| Fuel Range Radius     | range-radius-fuel     | Number:Length        |  X   |  X   |    X    |     | \n+| Electric Range Radius | range-radius-electric | Number:Length        |      |  X   |    X    |  X  | \n+| Hybrid Range Radius   | range-radius-hybrid   | Number:Length        |      |  X   |    X    |     | \n+\n+\n+#### Charge Profile\n+\n+Charging options with date and time for preferred time windows and charging modes.\n+\n+* Channel Group ID is **charge**\n+* Available for electric and hybrid vehicles\n+* Read-only values\n+\n+| Channel Label                      | Channel ID          | Type   | \n+|------------------------------------|---------------------|--------|\n+| Air Conditioning at Departure Time | profile-climate     | Switch | \n+| Charging Mode for Profile          | profile-mode        | String | \n+| Charging Window Start Time         | window-start        | String | \n+| Charging Window End Time           | window-end          | String | \n+| Timer 1: Departure Time            | timer1-departure    | String | \n+| Timer 1: Scheduled Days            | timer1-days         | String | \n+| Timer 1: Enabled                   | timer1-enabled      | Switch | \n+| Timer 2: Departure Time            | timer2-departure    | String | \n+| Timer 2: Scheduled Days            | timer2-days         | String | \n+| Timer 2: Enabled                   | timer2-enabled      | Switch | \n+| Timer 3: Departure Time            | timer3-departure    | String | \n+| Timer 3: Scheduled Days            | timer3-days         | String | \n+| Timer 3: Enabled                   | timer3-enabled      | Switch | \n+\n+\n+#### Location\n+\n+GPS location and heading of the vehicle.\n+\n+* Channel Group ID is **location**\n+* Available for all vehicles with built-in GPS sensor. Function can be enabled/disabled in the head unit\n+* Read-only values\n+\n+| Channel Label   | Channel ID          | Type         | \n+|-----------------|---------------------|--------------|\n+| GPS Coordinates | gps                 | Location     | \n+| Heading         | heading             | Number:Angle | \n+\n+#### Last Trip\n+\n+Statistic values of duration, distance and consumption of the last trip.\n+\n+* Channel Group ID is **last-trip**\n+* Available if *Statistics* is present in *Services Supported*. See [Vehicle Properties](#properties) for further details\n+* Read-only values\n+\n+| Channel Label                           | Channel ID                   | Type          |\n+|-----------------------------------------|------------------------------|---------------|\n+| Last Trip Date                          | date                         | DateTime      |\n+| Last Trip Duration                      | duration                     | Number:Time   |\n+| Average Power Consumption per 100 km    | avg-consumption              | Number:Power  |\n+| Average Combined Consumption per 100 km | avg-combined-consumption     | Number:Volume |\n+| Average Power Recuperation per 100 km   | avg-recuperation             | Number:Power  |\n+| Last Trip Distance                      | distance                     | Number:Length |\n+| Distance since Last Charge              | distance-since-charging      | Number:Length |\n+\n+\n+#### Lifetime Statistics\n+\n+Providing lifetime consumption values.\n+\n+* Channel Group ID is **lifetime**\n+* Available if *Statistics* is present in *Services Supported*. See [Vehicle Properties](#properties) for further details\n+* Read-only values\n+\n+| Channel Label                           | Channel ID                   | Type          | \n+|-----------------------------------------|------------------------------|---------------|\n+| Average Power Consumption per 100 km    | avg-consumption              | Number:Power  |\n+| Average Power Recuperation per 100 km   | avg-recuperation             | Number:Power  |\n+| Cumulated Electric Driven Distance      | cumulated-driven-distance    | Number:Length |\n+| Average Combined Consumption per 100 km | avg-combined-consumption     | Number:Volume |\n+| Longest Distance with one Charge        | single-longest-distance      | Number:Length |\n+\n+\n+#### Remote Services\n+\n+Remote control of the vehicle. \n+Send a *command* to the vehicle and the *state* is reporting the execution progress.\n+Only one command can be executed each time.\n+Parallel execution isn't supported.\n+\n+* Channel Group ID is **remote**\n+* Available for all commands mentioned in *Services Activated*. See [Vehicle Properties](#properties) for further details\n+* Read/Write access\n+\n+\n+| Channel Label           | Channel ID          | Type    | Access |\n+|-------------------------|---------------------|---------|--------|\n+| Remote Service Command  | command             | String  | Write  |\n+| Service Execution State | state               | String  | Read   |\n+\n+The channel _command_ provides options\n+\n+* _Flash Lights_ \n+* _Vehicle Finder_\n+* _Door Lock_\n+* _Door Unlock_\n+* _Horn Blow_\n+* _Climate Control_\n+\n+The channel _state_ shows the progress of the command execution in the following order\n+\n+1) _Initiated_ \n+2) _Pending_\n+3) _Delivered_\n+4) _Executed_\n+\n+#### Destinations\n+\n+Shows the last destinations stored in the navigation system.\n+If several last destinations are stored in the navigation system the channel _name_ contains all addresses as options.\n+\n+* Channel Group ID is **destination**\n+* Available if *LastDestinations* is present in *Services Supported*. Check [Vehicle Properties](#properties) for further details\n+* Read/Write access\n+\n+\n+| Channel Label                    | Channel ID          | Type      | Access      |\n+|----------------------------------|---------------------|-----------|-------------|\n+| Destination Name                 | name                | String    | Read/Write  |\n+| Destination GPS Coordinates      | gps                 | Location  | Read        |\n+\n+\n+\n+#### Image\n+\n+Image representation of the vehicle. Size and viewport are writable and can be \n+The possible values are the same mentioned in [Thing Configuration](#thing-configuration).\n+\n+* Channel Group ID is **image**\n+* Available for all vehicles\n+* Read/Write access\n+\n+| Channel Label                 | Channel ID          | Type   |  Access  |\n+|-------------------------------|---------------------|--------|----------|\n+| Rendered Image of the Vehicle | png                 | Image  | Read     |\n+| Image Viewport                | view                | String | Write    |\n+| Image Picture Size            | size                | Number | Write    |\n+\n+\n+## Further Descriptions\n+\n+### Dynamic Data\n+\n+<img align=\"right\" src=\"./doc/ServiceOptions.png\" width=\"400\" height=\"350\"/>\n+\n+There are 3 occurrences of dynamic data delivered\n+\n+* Upcoming Services delivered in group [Services](#services)\n+* Check Control Messages delivered in group [Check Control](#check-control)\n+* Last Destinations delivered in group [Destinations](#destinations)\n+\n+The channel id _name_ shows the first element as default. \n+All other possibilities are attached as options. \n+The picture on the right shows the _Service Name_ item and all four possible options. \n+Select the wanted service and the corresponding _Service Date & Milage_ will be shown.  \n+\n+### TroubleShooting\n+\n+BMW has a high range of vehicles supported by ConnectedDrive.\n+In case of any issues with this binding help to resolve it! \n+Please perform the following steps:\n+\n+* Can you [log into ConnectedDrive](https://www.bmw-connecteddrive.com/country-region-select/country-region-selection.html) with your credentials? Please note this isn't the BMW Customer portal - it's the ConnectedDrive portal\n+* Is the vehicle listed in your account? There's a one-to-one relation from user to vehicle\n+\n+If the access to the portal is working and the vehicle is listed some debug data is needed in order to identify the issue. \n+\n+#### Generate Debug Fingerprint\n+\n+If you checked the above pre-conditions you need to get the debug fingerprint from the logs.\n+First [enable debug logging](https://www.openhab.org/docs/administration/logging.html#defining-what-to-log) for the binding.\n+\n+```\n+log:set DEBUG org.openhab.binding.bmwconnecteddrive\n+```\n+\n+The debug fingerprint is generated immediately after the vehicle thing is initialized the first time, e.g. after openHAB startup. \n+To force a new fingerprint disable the thing shortly and enable it again. \n+Personal data is eliminated from the log entries so it should be possible to share them in public.\n+Data like\n+\n+* Dealer Properties\n+* Vehicle Identification Number (VIN)\n+* Location latitude / longitude \n+\n+are anonymized.\n+You'll find the fingerprint in the logs with the command\n+\n+```\n+less openhab.log | grep \"BMW ConnectedDrive Binding\"", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTg4NzgwMw=="}, "originalCommit": {"oid": "71d5496aba829f6628dd1676734e39c5a7d14f2f"}, "originalPosition": 459}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ2MzAwMzI2OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.bmwconnecteddrive/README.md", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0zMVQwOTo1Mjo0N1rOIM8dbA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wMVQyMzoyODoxNlrOINTW-g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDQ0NDM5Ng==", "bodyText": "Property keys shouldn't contain white spaces and start with lower case.", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r550444396", "createdAt": "2020-12-31T09:52:47Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/README.md", "diffHunk": "@@ -0,0 +1,686 @@\n+# BMW ConnectedDrive Binding\n+\n+<img align=\"right\" src=\"./doc/bmw-connected.png\" width=\"150\" height=\"150\"/>\n+\n+The binding provides a connection between [BMW's ConnectedDrive Portal](https://www.bmw-connecteddrive.com/country-region-select/country-region-selection.html) and openHAB.\n+All vehicles connected to an account will be detected by the discovery with the correct type \n+\n+* Conventional Fuel Vehicle\n+* Plugin-Hybrid Electrical Vehicle \n+* Battery Electric Vehicle with Range Extender\n+* Battery Electric Vehicle \n+\n+In addition properties are attached with information and services provided by this vehicle.\n+The provided data depends on \n+\n+1. the [Thing Type](#things) and \n+2. the [Properties](#properties) mentioned in Services\n+\n+Different channel groups are clustering all informations.\n+Check for each group if it's supported for this Vehicle.\n+\n+Please note **this isn't a real-time binding**. \n+If a door is opened the state isn't transmitted and changed immediately. \n+This isn't a flaw in the binding itself because the state in BMW's own ConnectedDrive App is also updated with some delay. \n+\n+## Supported Things\n+\n+### Bridge\n+\n+The bridge establishes the connection between BMW's ConnectedDrive Portal and openHAB.\n+\n+| Name                       | Bridge Type ID | Description                                                |\n+|----------------------------|----------------|------------------------------------------------------------|\n+| BMW ConnectedDrive Account | account        | Access to BMW ConnectedDrive Portal for a specific user    |\n+\n+\n+### Things\n+\n+Four different vehicle types are provided. \n+They differ in the supported channel groups & channels. \n+Conventional Fuel Vehicles have no _Charging Profile_, Electric Vehicles don't provide a _Fuel Range_. \n+For hybrid vehicles in addition to _Fuel and Electric Range_ the _Hybrid Range_ is shown.\n+ \n+| Name                                | Thing Type ID | Supported Channel Groups                               |\n+|-------------------------------------|---------------|--------------------------------------------------------|\n+| BMW Electric Vehicle                | bev           | status, range, location, service, check, charge, image |\n+| BMW Electric Vehicle with REX       | bev_rex       | status, range, location, service, check, charge, image |\n+| BMW Plug-In-Hybrid Electric Vehicle | phev          | status, range, location, service, check, charge, image |\n+| BMW Conventional Vehicle            | conv          | status, range, location, service, check, image         |\n+\n+ \n+#### Properties\n+\n+<img align=\"right\" src=\"./doc/properties.png\" width=\"500\" height=\"600\"/>\n+\n+For each vehicle properties are available. \n+Basically 3 types of information are registered as properties\n+\n+* Informations regarding your dealer with address and phone number\n+* Which services are available / not available\n+* Vehicle properties like color, model type, drive train and construction year\n+\n+In the right picture can see in *Services Activated* e.g. the *DoorLock* and *DoorUnlock* services are mentioned. \n+This ensures channel group [Remote Services](#remote-services) is supporting door lock and unlock remote control.\n+\n+In  *Services Supported* the entry *LastDestination* is mentioned.\n+So it's valid to connect channel group [Last Destinations](#destinations) in order to display and select the last navigation destinations.\n+\n+| Property Key       | Property Value      |  Supported Channel Groups    |\n+|--------------------|---------------------|------------------------------|\n+| Services Supported | Statistics          | last-trip, lifetime          |\n+| Services Supported | LastDestinations    | destinations                 |\n+| Services Activated | _list of services_  | remote                       |", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "71d5496aba829f6628dd1676734e39c5a7d14f2f"}, "originalPosition": 73}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDgxOTU3OA==", "bodyText": "Fixed", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r550819578", "createdAt": "2021-01-01T23:28:16Z", "author": {"login": "weymann"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/README.md", "diffHunk": "@@ -0,0 +1,686 @@\n+# BMW ConnectedDrive Binding\n+\n+<img align=\"right\" src=\"./doc/bmw-connected.png\" width=\"150\" height=\"150\"/>\n+\n+The binding provides a connection between [BMW's ConnectedDrive Portal](https://www.bmw-connecteddrive.com/country-region-select/country-region-selection.html) and openHAB.\n+All vehicles connected to an account will be detected by the discovery with the correct type \n+\n+* Conventional Fuel Vehicle\n+* Plugin-Hybrid Electrical Vehicle \n+* Battery Electric Vehicle with Range Extender\n+* Battery Electric Vehicle \n+\n+In addition properties are attached with information and services provided by this vehicle.\n+The provided data depends on \n+\n+1. the [Thing Type](#things) and \n+2. the [Properties](#properties) mentioned in Services\n+\n+Different channel groups are clustering all informations.\n+Check for each group if it's supported for this Vehicle.\n+\n+Please note **this isn't a real-time binding**. \n+If a door is opened the state isn't transmitted and changed immediately. \n+This isn't a flaw in the binding itself because the state in BMW's own ConnectedDrive App is also updated with some delay. \n+\n+## Supported Things\n+\n+### Bridge\n+\n+The bridge establishes the connection between BMW's ConnectedDrive Portal and openHAB.\n+\n+| Name                       | Bridge Type ID | Description                                                |\n+|----------------------------|----------------|------------------------------------------------------------|\n+| BMW ConnectedDrive Account | account        | Access to BMW ConnectedDrive Portal for a specific user    |\n+\n+\n+### Things\n+\n+Four different vehicle types are provided. \n+They differ in the supported channel groups & channels. \n+Conventional Fuel Vehicles have no _Charging Profile_, Electric Vehicles don't provide a _Fuel Range_. \n+For hybrid vehicles in addition to _Fuel and Electric Range_ the _Hybrid Range_ is shown.\n+ \n+| Name                                | Thing Type ID | Supported Channel Groups                               |\n+|-------------------------------------|---------------|--------------------------------------------------------|\n+| BMW Electric Vehicle                | bev           | status, range, location, service, check, charge, image |\n+| BMW Electric Vehicle with REX       | bev_rex       | status, range, location, service, check, charge, image |\n+| BMW Plug-In-Hybrid Electric Vehicle | phev          | status, range, location, service, check, charge, image |\n+| BMW Conventional Vehicle            | conv          | status, range, location, service, check, image         |\n+\n+ \n+#### Properties\n+\n+<img align=\"right\" src=\"./doc/properties.png\" width=\"500\" height=\"600\"/>\n+\n+For each vehicle properties are available. \n+Basically 3 types of information are registered as properties\n+\n+* Informations regarding your dealer with address and phone number\n+* Which services are available / not available\n+* Vehicle properties like color, model type, drive train and construction year\n+\n+In the right picture can see in *Services Activated* e.g. the *DoorLock* and *DoorUnlock* services are mentioned. \n+This ensures channel group [Remote Services](#remote-services) is supporting door lock and unlock remote control.\n+\n+In  *Services Supported* the entry *LastDestination* is mentioned.\n+So it's valid to connect channel group [Last Destinations](#destinations) in order to display and select the last navigation destinations.\n+\n+| Property Key       | Property Value      |  Supported Channel Groups    |\n+|--------------------|---------------------|------------------------------|\n+| Services Supported | Statistics          | last-trip, lifetime          |\n+| Services Supported | LastDestinations    | destinations                 |\n+| Services Activated | _list of services_  | remote                       |", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDQ0NDM5Ng=="}, "originalCommit": {"oid": "71d5496aba829f6628dd1676734e39c5a7d14f2f"}, "originalPosition": 73}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzYwMTg1MTQ0OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/discovery/VehicleDiscovery.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0wN1QwMjo0Mjo0N1rOIhC0YQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0wNVQxMToxMjozNFrOIw94XA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MTUyMDA5Nw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    if (bridgeHandler.isPresent()) {\n          \n          \n            \n                        bridgeHandler.get().requestVehicles();\n          \n          \n            \n                    }\n          \n          \n            \n                    bridgeHandler.ifPresent(ConnectedDriveBridgeHandler::requestVehicles);", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r571520097", "createdAt": "2021-02-07T02:42:47Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/discovery/VehicleDiscovery.java", "diffHunk": "@@ -0,0 +1,227 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bmwconnecteddrive.internal.discovery;\n+\n+import static org.openhab.binding.bmwconnecteddrive.internal.ConnectedDriveConstants.SUPPORTED_THING_SET;\n+\n+import java.lang.reflect.Field;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.bmwconnecteddrive.internal.ConnectedDriveConstants;\n+import org.openhab.binding.bmwconnecteddrive.internal.ConnectedDriveHandlerFactory;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.discovery.Vehicle;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.discovery.VehiclesContainer;\n+import org.openhab.binding.bmwconnecteddrive.internal.handler.ConnectedDriveBridgeHandler;\n+import org.openhab.binding.bmwconnecteddrive.internal.handler.VehicleHandler;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Constants;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Converter;\n+import org.openhab.core.config.core.Configuration;\n+import org.openhab.core.config.discovery.AbstractDiscoveryService;\n+import org.openhab.core.config.discovery.DiscoveryResultBuilder;\n+import org.openhab.core.config.discovery.DiscoveryService;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingUID;\n+import org.openhab.core.thing.binding.ThingHandler;\n+import org.openhab.core.thing.binding.ThingHandlerService;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link VehicleDiscovery} requests data from ConnectedDrive and is identifying the Vehicles after response\n+ *\n+ * @author Bernd Weymann - Initial contribution\n+ */\n+@NonNullByDefault\n+public class VehicleDiscovery extends AbstractDiscoveryService implements DiscoveryService, ThingHandlerService {\n+    private final Logger logger = LoggerFactory.getLogger(VehicleDiscovery.class);\n+    private static final int DISCOVERY_TIMEOUT = 10;\n+    private Optional<ConnectedDriveBridgeHandler> bridgeHandler = Optional.empty();\n+\n+    public VehicleDiscovery() {\n+        super(SUPPORTED_THING_SET, DISCOVERY_TIMEOUT, false);\n+    }\n+\n+    public void onResponse(VehiclesContainer container) {\n+        List<Vehicle> vehicles = container.vehicles;\n+        vehicles.forEach(vehicle -> {\n+            if (bridgeHandler.isPresent()) {\n+                ThingUID bridgeUID = bridgeHandler.get().getThing().getUID();\n+                // the DriveTrain field in the delivered json is defining the Vehicle Type\n+                String vehicleType = vehicle.driveTrain.toLowerCase();\n+                SUPPORTED_THING_SET.forEach(entry -> {\n+                    if (entry.getId().equals(vehicleType)) {\n+                        ThingUID uid = new ThingUID(entry, vehicle.vin, bridgeUID.getId());\n+                        Map<String, String> properties = new HashMap<>();\n+                        // Dealer\n+                        if (vehicle.dealer != null) {\n+                            properties.put(\"dealer\", vehicle.dealer.name);\n+                            properties.put(\"dealerAddress\", vehicle.dealer.street + \" \" + vehicle.dealer.country + \" \"\n+                                    + vehicle.dealer.postalCode + \" \" + vehicle.dealer.city);\n+                            properties.put(\"dealerPhone\", vehicle.dealer.phone);\n+                        }\n+\n+                        // Services & Support\n+                        properties.put(\"servicesActivated\", getObject(vehicle, Constants.ACTIVATED));\n+                        String servicesSupported = getObject(vehicle, Constants.SUPPORTED);\n+                        String servicesNotSupported = getObject(vehicle, Constants.NOT_SUPPORTED);\n+                        if (vehicle.statisticsAvailable) {\n+                            servicesSupported += Constants.STATISTICS;\n+                        } else {\n+                            servicesNotSupported += Constants.STATISTICS;\n+                        }\n+                        properties.put(Constants.SERVICES_SUPPORTED, servicesSupported);\n+                        properties.put(\"servicesNotSupported\", servicesNotSupported);\n+                        properties.put(\"supportBreakdownNumber\", vehicle.breakdownNumber);\n+\n+                        // Vehicle Properties\n+                        if (vehicle.supportedChargingModes != null) {\n+                            StringBuilder chargingModes = new StringBuilder();\n+                            vehicle.supportedChargingModes.forEach(e -> {\n+                                chargingModes.append(e).append(Constants.SPACE);\n+                            });\n+                            properties.put(\"vehicleChargeModes\", chargingModes.toString());\n+                        }\n+                        if (vehicle.hasAlarmSystem) {\n+                            properties.put(\"vehicleAlarmSystem\", \"Available\");\n+                        } else {\n+                            properties.put(\"vehicleAlarmSystem\", \"Not Available\");\n+                        }\n+                        properties.put(\"vehicleBrand\", vehicle.brand);\n+                        properties.put(\"vehicleBodytype\", vehicle.bodytype);\n+                        properties.put(\"vehicleColor\", vehicle.color);\n+                        properties.put(\"vehicleConstructionYear\", Short.toString(vehicle.yearOfConstruction));\n+                        properties.put(\"vehicleDriveTrain\", vehicle.driveTrain);\n+                        properties.put(\"vehicleModel\", vehicle.model);\n+                        if (vehicle.chargingControl != null) {\n+                            properties.put(\"vehicleChargeControl\", Converter.toTitleCase(vehicle.model));\n+                        }\n+\n+                        // Check now if a thing with the same VIN exists\n+                        final AtomicBoolean foundVehicle = new AtomicBoolean(false);\n+                        List<VehicleHandler> l = ConnectedDriveHandlerFactory.getHandlerRegistry();\n+                        l.forEach(handler -> {\n+                            Thing vehicleThing = handler.getThing();\n+                            Configuration c = vehicleThing.getConfiguration();\n+                            if (c.containsKey(\"vin\")) {\n+                                String thingVIN = c.get(\"vin\").toString();\n+                                if (vehicle.vin.equals(thingVIN)) {\n+                                    vehicleThing.setProperties(properties);\n+                                    foundVehicle.set(true);\n+                                }\n+                            }\n+                        });\n+\n+                        // Vehicle not found -> trigger discovery\n+                        if (!foundVehicle.get()) {\n+                            // Properties needed for functional THing\n+                            properties.put(\"vin\", vehicle.vin);\n+                            properties.put(\"refreshInterval\",\n+                                    Integer.toString(ConnectedDriveConstants.DEFAULT_REFRESH_INTERVAL));\n+                            properties.put(\"units\", ConnectedDriveConstants.UNITS_AUTODETECT);\n+                            properties.put(\"imageSize\", Integer.toString(ConnectedDriveConstants.DEFAULT_IMAGE_SIZE));\n+                            properties.put(\"imageViewport\", ConnectedDriveConstants.DEFAULT_IMAGE_VIEWPORT);\n+\n+                            String vehicleLabel = vehicle.brand + \" \" + vehicle.model;\n+                            Map<String, Object> convertedProperties = new HashMap<String, Object>(properties);\n+                            thingDiscovered(DiscoveryResultBuilder.create(uid).withBridge(bridgeUID)\n+                                    .withRepresentationProperty(\"vin\").withLabel(vehicleLabel)\n+                                    .withProperties(convertedProperties).build());\n+                        }\n+                    }\n+                });\n+            }\n+        });\n+    }\n+\n+    /**\n+     * Get all field names from a DTO with a specific value\n+     * Used to get e.g. all services which are \"ACTIVATED\"\n+     *\n+     * @param DTO Object\n+     * @param compare String which needs to map with the value\n+     * @return String with all field names matching this value separated with Spaces\n+     */\n+    public String getObject(Object dto, String compare) {\n+        StringBuilder buf = new StringBuilder();\n+        for (Field field : dto.getClass().getDeclaredFields()) {\n+            try {\n+                Object value = field.get(dto);\n+                if (value != null) {\n+                    if (value.equals(compare)) {\n+                        buf.append(Converter.capitalizeFirst(field.getName()) + Constants.SPACE);\n+                    }\n+                }\n+            } catch (IllegalArgumentException e) {\n+                logger.debug(\"Field {} not found {}\", compare, e.getMessage());\n+            } catch (IllegalAccessException e) {\n+                logger.debug(\"Field {} not found {}\", compare, e.getMessage());\n+            }\n+        }\n+        return buf.toString();\n+    }\n+\n+    @Override\n+    public void setThingHandler(ThingHandler handler) {\n+        if (handler instanceof ConnectedDriveBridgeHandler) {\n+            bridgeHandler = Optional.of((ConnectedDriveBridgeHandler) handler);\n+            bridgeHandler.get().setDiscoveryService(this);\n+        }\n+    }\n+\n+    @Override\n+    public @Nullable ThingHandler getThingHandler() {\n+        if (bridgeHandler.isPresent()) {\n+            return bridgeHandler.get();\n+        } else {\n+            return null;\n+        }\n+    }\n+\n+    @Override\n+    public int getScanTimeout() {\n+        return DISCOVERY_TIMEOUT;\n+    }\n+\n+    @Override\n+    public boolean isBackgroundDiscoveryEnabled() {\n+        return false;\n+    }\n+\n+    @Override\n+    protected void startScan() {\n+        if (bridgeHandler.isPresent()) {\n+            bridgeHandler.get().requestVehicles();\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d5c01cbf22b288e86546da29f08d62c4d59189e5"}, "originalPosition": 210}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4ODIxNjQxMg==", "bodyText": "all occurences of 'isPresent() + get()' that can reasonably be implemented using ifPresent/map/flatMap.... are fixed", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r588216412", "createdAt": "2021-03-05T11:12:34Z", "author": {"login": "ntruchsess"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/discovery/VehicleDiscovery.java", "diffHunk": "@@ -0,0 +1,227 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bmwconnecteddrive.internal.discovery;\n+\n+import static org.openhab.binding.bmwconnecteddrive.internal.ConnectedDriveConstants.SUPPORTED_THING_SET;\n+\n+import java.lang.reflect.Field;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.bmwconnecteddrive.internal.ConnectedDriveConstants;\n+import org.openhab.binding.bmwconnecteddrive.internal.ConnectedDriveHandlerFactory;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.discovery.Vehicle;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.discovery.VehiclesContainer;\n+import org.openhab.binding.bmwconnecteddrive.internal.handler.ConnectedDriveBridgeHandler;\n+import org.openhab.binding.bmwconnecteddrive.internal.handler.VehicleHandler;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Constants;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Converter;\n+import org.openhab.core.config.core.Configuration;\n+import org.openhab.core.config.discovery.AbstractDiscoveryService;\n+import org.openhab.core.config.discovery.DiscoveryResultBuilder;\n+import org.openhab.core.config.discovery.DiscoveryService;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingUID;\n+import org.openhab.core.thing.binding.ThingHandler;\n+import org.openhab.core.thing.binding.ThingHandlerService;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link VehicleDiscovery} requests data from ConnectedDrive and is identifying the Vehicles after response\n+ *\n+ * @author Bernd Weymann - Initial contribution\n+ */\n+@NonNullByDefault\n+public class VehicleDiscovery extends AbstractDiscoveryService implements DiscoveryService, ThingHandlerService {\n+    private final Logger logger = LoggerFactory.getLogger(VehicleDiscovery.class);\n+    private static final int DISCOVERY_TIMEOUT = 10;\n+    private Optional<ConnectedDriveBridgeHandler> bridgeHandler = Optional.empty();\n+\n+    public VehicleDiscovery() {\n+        super(SUPPORTED_THING_SET, DISCOVERY_TIMEOUT, false);\n+    }\n+\n+    public void onResponse(VehiclesContainer container) {\n+        List<Vehicle> vehicles = container.vehicles;\n+        vehicles.forEach(vehicle -> {\n+            if (bridgeHandler.isPresent()) {\n+                ThingUID bridgeUID = bridgeHandler.get().getThing().getUID();\n+                // the DriveTrain field in the delivered json is defining the Vehicle Type\n+                String vehicleType = vehicle.driveTrain.toLowerCase();\n+                SUPPORTED_THING_SET.forEach(entry -> {\n+                    if (entry.getId().equals(vehicleType)) {\n+                        ThingUID uid = new ThingUID(entry, vehicle.vin, bridgeUID.getId());\n+                        Map<String, String> properties = new HashMap<>();\n+                        // Dealer\n+                        if (vehicle.dealer != null) {\n+                            properties.put(\"dealer\", vehicle.dealer.name);\n+                            properties.put(\"dealerAddress\", vehicle.dealer.street + \" \" + vehicle.dealer.country + \" \"\n+                                    + vehicle.dealer.postalCode + \" \" + vehicle.dealer.city);\n+                            properties.put(\"dealerPhone\", vehicle.dealer.phone);\n+                        }\n+\n+                        // Services & Support\n+                        properties.put(\"servicesActivated\", getObject(vehicle, Constants.ACTIVATED));\n+                        String servicesSupported = getObject(vehicle, Constants.SUPPORTED);\n+                        String servicesNotSupported = getObject(vehicle, Constants.NOT_SUPPORTED);\n+                        if (vehicle.statisticsAvailable) {\n+                            servicesSupported += Constants.STATISTICS;\n+                        } else {\n+                            servicesNotSupported += Constants.STATISTICS;\n+                        }\n+                        properties.put(Constants.SERVICES_SUPPORTED, servicesSupported);\n+                        properties.put(\"servicesNotSupported\", servicesNotSupported);\n+                        properties.put(\"supportBreakdownNumber\", vehicle.breakdownNumber);\n+\n+                        // Vehicle Properties\n+                        if (vehicle.supportedChargingModes != null) {\n+                            StringBuilder chargingModes = new StringBuilder();\n+                            vehicle.supportedChargingModes.forEach(e -> {\n+                                chargingModes.append(e).append(Constants.SPACE);\n+                            });\n+                            properties.put(\"vehicleChargeModes\", chargingModes.toString());\n+                        }\n+                        if (vehicle.hasAlarmSystem) {\n+                            properties.put(\"vehicleAlarmSystem\", \"Available\");\n+                        } else {\n+                            properties.put(\"vehicleAlarmSystem\", \"Not Available\");\n+                        }\n+                        properties.put(\"vehicleBrand\", vehicle.brand);\n+                        properties.put(\"vehicleBodytype\", vehicle.bodytype);\n+                        properties.put(\"vehicleColor\", vehicle.color);\n+                        properties.put(\"vehicleConstructionYear\", Short.toString(vehicle.yearOfConstruction));\n+                        properties.put(\"vehicleDriveTrain\", vehicle.driveTrain);\n+                        properties.put(\"vehicleModel\", vehicle.model);\n+                        if (vehicle.chargingControl != null) {\n+                            properties.put(\"vehicleChargeControl\", Converter.toTitleCase(vehicle.model));\n+                        }\n+\n+                        // Check now if a thing with the same VIN exists\n+                        final AtomicBoolean foundVehicle = new AtomicBoolean(false);\n+                        List<VehicleHandler> l = ConnectedDriveHandlerFactory.getHandlerRegistry();\n+                        l.forEach(handler -> {\n+                            Thing vehicleThing = handler.getThing();\n+                            Configuration c = vehicleThing.getConfiguration();\n+                            if (c.containsKey(\"vin\")) {\n+                                String thingVIN = c.get(\"vin\").toString();\n+                                if (vehicle.vin.equals(thingVIN)) {\n+                                    vehicleThing.setProperties(properties);\n+                                    foundVehicle.set(true);\n+                                }\n+                            }\n+                        });\n+\n+                        // Vehicle not found -> trigger discovery\n+                        if (!foundVehicle.get()) {\n+                            // Properties needed for functional THing\n+                            properties.put(\"vin\", vehicle.vin);\n+                            properties.put(\"refreshInterval\",\n+                                    Integer.toString(ConnectedDriveConstants.DEFAULT_REFRESH_INTERVAL));\n+                            properties.put(\"units\", ConnectedDriveConstants.UNITS_AUTODETECT);\n+                            properties.put(\"imageSize\", Integer.toString(ConnectedDriveConstants.DEFAULT_IMAGE_SIZE));\n+                            properties.put(\"imageViewport\", ConnectedDriveConstants.DEFAULT_IMAGE_VIEWPORT);\n+\n+                            String vehicleLabel = vehicle.brand + \" \" + vehicle.model;\n+                            Map<String, Object> convertedProperties = new HashMap<String, Object>(properties);\n+                            thingDiscovered(DiscoveryResultBuilder.create(uid).withBridge(bridgeUID)\n+                                    .withRepresentationProperty(\"vin\").withLabel(vehicleLabel)\n+                                    .withProperties(convertedProperties).build());\n+                        }\n+                    }\n+                });\n+            }\n+        });\n+    }\n+\n+    /**\n+     * Get all field names from a DTO with a specific value\n+     * Used to get e.g. all services which are \"ACTIVATED\"\n+     *\n+     * @param DTO Object\n+     * @param compare String which needs to map with the value\n+     * @return String with all field names matching this value separated with Spaces\n+     */\n+    public String getObject(Object dto, String compare) {\n+        StringBuilder buf = new StringBuilder();\n+        for (Field field : dto.getClass().getDeclaredFields()) {\n+            try {\n+                Object value = field.get(dto);\n+                if (value != null) {\n+                    if (value.equals(compare)) {\n+                        buf.append(Converter.capitalizeFirst(field.getName()) + Constants.SPACE);\n+                    }\n+                }\n+            } catch (IllegalArgumentException e) {\n+                logger.debug(\"Field {} not found {}\", compare, e.getMessage());\n+            } catch (IllegalAccessException e) {\n+                logger.debug(\"Field {} not found {}\", compare, e.getMessage());\n+            }\n+        }\n+        return buf.toString();\n+    }\n+\n+    @Override\n+    public void setThingHandler(ThingHandler handler) {\n+        if (handler instanceof ConnectedDriveBridgeHandler) {\n+            bridgeHandler = Optional.of((ConnectedDriveBridgeHandler) handler);\n+            bridgeHandler.get().setDiscoveryService(this);\n+        }\n+    }\n+\n+    @Override\n+    public @Nullable ThingHandler getThingHandler() {\n+        if (bridgeHandler.isPresent()) {\n+            return bridgeHandler.get();\n+        } else {\n+            return null;\n+        }\n+    }\n+\n+    @Override\n+    public int getScanTimeout() {\n+        return DISCOVERY_TIMEOUT;\n+    }\n+\n+    @Override\n+    public boolean isBackgroundDiscoveryEnabled() {\n+        return false;\n+    }\n+\n+    @Override\n+    protected void startScan() {\n+        if (bridgeHandler.isPresent()) {\n+            bridgeHandler.get().requestVehicles();\n+        }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MTUyMDA5Nw=="}, "originalCommit": {"oid": "d5c01cbf22b288e86546da29f08d62c4d59189e5"}, "originalPosition": 210}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzYwMTg1MzQ0OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/discovery/VehicleDiscovery.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0wN1QwMjo0NTo0NVrOIhC1Ww==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0wNVQxMToxMjo0OVrOIw947Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MTUyMDM0Nw==", "bodyText": "If the null checker throws a fit you can ignore this suggestion.\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    if (bridgeHandler.isPresent()) {\n          \n          \n            \n                        return bridgeHandler.get();\n          \n          \n            \n                    } else {\n          \n          \n            \n                        return null;\n          \n          \n            \n                    }\n          \n          \n            \n                    return bridgeHandler.orElse(null);", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r571520347", "createdAt": "2021-02-07T02:45:45Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/discovery/VehicleDiscovery.java", "diffHunk": "@@ -0,0 +1,227 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bmwconnecteddrive.internal.discovery;\n+\n+import static org.openhab.binding.bmwconnecteddrive.internal.ConnectedDriveConstants.SUPPORTED_THING_SET;\n+\n+import java.lang.reflect.Field;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.bmwconnecteddrive.internal.ConnectedDriveConstants;\n+import org.openhab.binding.bmwconnecteddrive.internal.ConnectedDriveHandlerFactory;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.discovery.Vehicle;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.discovery.VehiclesContainer;\n+import org.openhab.binding.bmwconnecteddrive.internal.handler.ConnectedDriveBridgeHandler;\n+import org.openhab.binding.bmwconnecteddrive.internal.handler.VehicleHandler;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Constants;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Converter;\n+import org.openhab.core.config.core.Configuration;\n+import org.openhab.core.config.discovery.AbstractDiscoveryService;\n+import org.openhab.core.config.discovery.DiscoveryResultBuilder;\n+import org.openhab.core.config.discovery.DiscoveryService;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingUID;\n+import org.openhab.core.thing.binding.ThingHandler;\n+import org.openhab.core.thing.binding.ThingHandlerService;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link VehicleDiscovery} requests data from ConnectedDrive and is identifying the Vehicles after response\n+ *\n+ * @author Bernd Weymann - Initial contribution\n+ */\n+@NonNullByDefault\n+public class VehicleDiscovery extends AbstractDiscoveryService implements DiscoveryService, ThingHandlerService {\n+    private final Logger logger = LoggerFactory.getLogger(VehicleDiscovery.class);\n+    private static final int DISCOVERY_TIMEOUT = 10;\n+    private Optional<ConnectedDriveBridgeHandler> bridgeHandler = Optional.empty();\n+\n+    public VehicleDiscovery() {\n+        super(SUPPORTED_THING_SET, DISCOVERY_TIMEOUT, false);\n+    }\n+\n+    public void onResponse(VehiclesContainer container) {\n+        List<Vehicle> vehicles = container.vehicles;\n+        vehicles.forEach(vehicle -> {\n+            if (bridgeHandler.isPresent()) {\n+                ThingUID bridgeUID = bridgeHandler.get().getThing().getUID();\n+                // the DriveTrain field in the delivered json is defining the Vehicle Type\n+                String vehicleType = vehicle.driveTrain.toLowerCase();\n+                SUPPORTED_THING_SET.forEach(entry -> {\n+                    if (entry.getId().equals(vehicleType)) {\n+                        ThingUID uid = new ThingUID(entry, vehicle.vin, bridgeUID.getId());\n+                        Map<String, String> properties = new HashMap<>();\n+                        // Dealer\n+                        if (vehicle.dealer != null) {\n+                            properties.put(\"dealer\", vehicle.dealer.name);\n+                            properties.put(\"dealerAddress\", vehicle.dealer.street + \" \" + vehicle.dealer.country + \" \"\n+                                    + vehicle.dealer.postalCode + \" \" + vehicle.dealer.city);\n+                            properties.put(\"dealerPhone\", vehicle.dealer.phone);\n+                        }\n+\n+                        // Services & Support\n+                        properties.put(\"servicesActivated\", getObject(vehicle, Constants.ACTIVATED));\n+                        String servicesSupported = getObject(vehicle, Constants.SUPPORTED);\n+                        String servicesNotSupported = getObject(vehicle, Constants.NOT_SUPPORTED);\n+                        if (vehicle.statisticsAvailable) {\n+                            servicesSupported += Constants.STATISTICS;\n+                        } else {\n+                            servicesNotSupported += Constants.STATISTICS;\n+                        }\n+                        properties.put(Constants.SERVICES_SUPPORTED, servicesSupported);\n+                        properties.put(\"servicesNotSupported\", servicesNotSupported);\n+                        properties.put(\"supportBreakdownNumber\", vehicle.breakdownNumber);\n+\n+                        // Vehicle Properties\n+                        if (vehicle.supportedChargingModes != null) {\n+                            StringBuilder chargingModes = new StringBuilder();\n+                            vehicle.supportedChargingModes.forEach(e -> {\n+                                chargingModes.append(e).append(Constants.SPACE);\n+                            });\n+                            properties.put(\"vehicleChargeModes\", chargingModes.toString());\n+                        }\n+                        if (vehicle.hasAlarmSystem) {\n+                            properties.put(\"vehicleAlarmSystem\", \"Available\");\n+                        } else {\n+                            properties.put(\"vehicleAlarmSystem\", \"Not Available\");\n+                        }\n+                        properties.put(\"vehicleBrand\", vehicle.brand);\n+                        properties.put(\"vehicleBodytype\", vehicle.bodytype);\n+                        properties.put(\"vehicleColor\", vehicle.color);\n+                        properties.put(\"vehicleConstructionYear\", Short.toString(vehicle.yearOfConstruction));\n+                        properties.put(\"vehicleDriveTrain\", vehicle.driveTrain);\n+                        properties.put(\"vehicleModel\", vehicle.model);\n+                        if (vehicle.chargingControl != null) {\n+                            properties.put(\"vehicleChargeControl\", Converter.toTitleCase(vehicle.model));\n+                        }\n+\n+                        // Check now if a thing with the same VIN exists\n+                        final AtomicBoolean foundVehicle = new AtomicBoolean(false);\n+                        List<VehicleHandler> l = ConnectedDriveHandlerFactory.getHandlerRegistry();\n+                        l.forEach(handler -> {\n+                            Thing vehicleThing = handler.getThing();\n+                            Configuration c = vehicleThing.getConfiguration();\n+                            if (c.containsKey(\"vin\")) {\n+                                String thingVIN = c.get(\"vin\").toString();\n+                                if (vehicle.vin.equals(thingVIN)) {\n+                                    vehicleThing.setProperties(properties);\n+                                    foundVehicle.set(true);\n+                                }\n+                            }\n+                        });\n+\n+                        // Vehicle not found -> trigger discovery\n+                        if (!foundVehicle.get()) {\n+                            // Properties needed for functional THing\n+                            properties.put(\"vin\", vehicle.vin);\n+                            properties.put(\"refreshInterval\",\n+                                    Integer.toString(ConnectedDriveConstants.DEFAULT_REFRESH_INTERVAL));\n+                            properties.put(\"units\", ConnectedDriveConstants.UNITS_AUTODETECT);\n+                            properties.put(\"imageSize\", Integer.toString(ConnectedDriveConstants.DEFAULT_IMAGE_SIZE));\n+                            properties.put(\"imageViewport\", ConnectedDriveConstants.DEFAULT_IMAGE_VIEWPORT);\n+\n+                            String vehicleLabel = vehicle.brand + \" \" + vehicle.model;\n+                            Map<String, Object> convertedProperties = new HashMap<String, Object>(properties);\n+                            thingDiscovered(DiscoveryResultBuilder.create(uid).withBridge(bridgeUID)\n+                                    .withRepresentationProperty(\"vin\").withLabel(vehicleLabel)\n+                                    .withProperties(convertedProperties).build());\n+                        }\n+                    }\n+                });\n+            }\n+        });\n+    }\n+\n+    /**\n+     * Get all field names from a DTO with a specific value\n+     * Used to get e.g. all services which are \"ACTIVATED\"\n+     *\n+     * @param DTO Object\n+     * @param compare String which needs to map with the value\n+     * @return String with all field names matching this value separated with Spaces\n+     */\n+    public String getObject(Object dto, String compare) {\n+        StringBuilder buf = new StringBuilder();\n+        for (Field field : dto.getClass().getDeclaredFields()) {\n+            try {\n+                Object value = field.get(dto);\n+                if (value != null) {\n+                    if (value.equals(compare)) {\n+                        buf.append(Converter.capitalizeFirst(field.getName()) + Constants.SPACE);\n+                    }\n+                }\n+            } catch (IllegalArgumentException e) {\n+                logger.debug(\"Field {} not found {}\", compare, e.getMessage());\n+            } catch (IllegalAccessException e) {\n+                logger.debug(\"Field {} not found {}\", compare, e.getMessage());\n+            }\n+        }\n+        return buf.toString();\n+    }\n+\n+    @Override\n+    public void setThingHandler(ThingHandler handler) {\n+        if (handler instanceof ConnectedDriveBridgeHandler) {\n+            bridgeHandler = Optional.of((ConnectedDriveBridgeHandler) handler);\n+            bridgeHandler.get().setDiscoveryService(this);\n+        }\n+    }\n+\n+    @Override\n+    public @Nullable ThingHandler getThingHandler() {\n+        if (bridgeHandler.isPresent()) {\n+            return bridgeHandler.get();\n+        } else {\n+            return null;\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d5c01cbf22b288e86546da29f08d62c4d59189e5"}, "originalPosition": 193}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4ODIxNjU1Nw==", "bodyText": "fixed", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r588216557", "createdAt": "2021-03-05T11:12:49Z", "author": {"login": "ntruchsess"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/discovery/VehicleDiscovery.java", "diffHunk": "@@ -0,0 +1,227 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bmwconnecteddrive.internal.discovery;\n+\n+import static org.openhab.binding.bmwconnecteddrive.internal.ConnectedDriveConstants.SUPPORTED_THING_SET;\n+\n+import java.lang.reflect.Field;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.bmwconnecteddrive.internal.ConnectedDriveConstants;\n+import org.openhab.binding.bmwconnecteddrive.internal.ConnectedDriveHandlerFactory;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.discovery.Vehicle;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.discovery.VehiclesContainer;\n+import org.openhab.binding.bmwconnecteddrive.internal.handler.ConnectedDriveBridgeHandler;\n+import org.openhab.binding.bmwconnecteddrive.internal.handler.VehicleHandler;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Constants;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Converter;\n+import org.openhab.core.config.core.Configuration;\n+import org.openhab.core.config.discovery.AbstractDiscoveryService;\n+import org.openhab.core.config.discovery.DiscoveryResultBuilder;\n+import org.openhab.core.config.discovery.DiscoveryService;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingUID;\n+import org.openhab.core.thing.binding.ThingHandler;\n+import org.openhab.core.thing.binding.ThingHandlerService;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link VehicleDiscovery} requests data from ConnectedDrive and is identifying the Vehicles after response\n+ *\n+ * @author Bernd Weymann - Initial contribution\n+ */\n+@NonNullByDefault\n+public class VehicleDiscovery extends AbstractDiscoveryService implements DiscoveryService, ThingHandlerService {\n+    private final Logger logger = LoggerFactory.getLogger(VehicleDiscovery.class);\n+    private static final int DISCOVERY_TIMEOUT = 10;\n+    private Optional<ConnectedDriveBridgeHandler> bridgeHandler = Optional.empty();\n+\n+    public VehicleDiscovery() {\n+        super(SUPPORTED_THING_SET, DISCOVERY_TIMEOUT, false);\n+    }\n+\n+    public void onResponse(VehiclesContainer container) {\n+        List<Vehicle> vehicles = container.vehicles;\n+        vehicles.forEach(vehicle -> {\n+            if (bridgeHandler.isPresent()) {\n+                ThingUID bridgeUID = bridgeHandler.get().getThing().getUID();\n+                // the DriveTrain field in the delivered json is defining the Vehicle Type\n+                String vehicleType = vehicle.driveTrain.toLowerCase();\n+                SUPPORTED_THING_SET.forEach(entry -> {\n+                    if (entry.getId().equals(vehicleType)) {\n+                        ThingUID uid = new ThingUID(entry, vehicle.vin, bridgeUID.getId());\n+                        Map<String, String> properties = new HashMap<>();\n+                        // Dealer\n+                        if (vehicle.dealer != null) {\n+                            properties.put(\"dealer\", vehicle.dealer.name);\n+                            properties.put(\"dealerAddress\", vehicle.dealer.street + \" \" + vehicle.dealer.country + \" \"\n+                                    + vehicle.dealer.postalCode + \" \" + vehicle.dealer.city);\n+                            properties.put(\"dealerPhone\", vehicle.dealer.phone);\n+                        }\n+\n+                        // Services & Support\n+                        properties.put(\"servicesActivated\", getObject(vehicle, Constants.ACTIVATED));\n+                        String servicesSupported = getObject(vehicle, Constants.SUPPORTED);\n+                        String servicesNotSupported = getObject(vehicle, Constants.NOT_SUPPORTED);\n+                        if (vehicle.statisticsAvailable) {\n+                            servicesSupported += Constants.STATISTICS;\n+                        } else {\n+                            servicesNotSupported += Constants.STATISTICS;\n+                        }\n+                        properties.put(Constants.SERVICES_SUPPORTED, servicesSupported);\n+                        properties.put(\"servicesNotSupported\", servicesNotSupported);\n+                        properties.put(\"supportBreakdownNumber\", vehicle.breakdownNumber);\n+\n+                        // Vehicle Properties\n+                        if (vehicle.supportedChargingModes != null) {\n+                            StringBuilder chargingModes = new StringBuilder();\n+                            vehicle.supportedChargingModes.forEach(e -> {\n+                                chargingModes.append(e).append(Constants.SPACE);\n+                            });\n+                            properties.put(\"vehicleChargeModes\", chargingModes.toString());\n+                        }\n+                        if (vehicle.hasAlarmSystem) {\n+                            properties.put(\"vehicleAlarmSystem\", \"Available\");\n+                        } else {\n+                            properties.put(\"vehicleAlarmSystem\", \"Not Available\");\n+                        }\n+                        properties.put(\"vehicleBrand\", vehicle.brand);\n+                        properties.put(\"vehicleBodytype\", vehicle.bodytype);\n+                        properties.put(\"vehicleColor\", vehicle.color);\n+                        properties.put(\"vehicleConstructionYear\", Short.toString(vehicle.yearOfConstruction));\n+                        properties.put(\"vehicleDriveTrain\", vehicle.driveTrain);\n+                        properties.put(\"vehicleModel\", vehicle.model);\n+                        if (vehicle.chargingControl != null) {\n+                            properties.put(\"vehicleChargeControl\", Converter.toTitleCase(vehicle.model));\n+                        }\n+\n+                        // Check now if a thing with the same VIN exists\n+                        final AtomicBoolean foundVehicle = new AtomicBoolean(false);\n+                        List<VehicleHandler> l = ConnectedDriveHandlerFactory.getHandlerRegistry();\n+                        l.forEach(handler -> {\n+                            Thing vehicleThing = handler.getThing();\n+                            Configuration c = vehicleThing.getConfiguration();\n+                            if (c.containsKey(\"vin\")) {\n+                                String thingVIN = c.get(\"vin\").toString();\n+                                if (vehicle.vin.equals(thingVIN)) {\n+                                    vehicleThing.setProperties(properties);\n+                                    foundVehicle.set(true);\n+                                }\n+                            }\n+                        });\n+\n+                        // Vehicle not found -> trigger discovery\n+                        if (!foundVehicle.get()) {\n+                            // Properties needed for functional THing\n+                            properties.put(\"vin\", vehicle.vin);\n+                            properties.put(\"refreshInterval\",\n+                                    Integer.toString(ConnectedDriveConstants.DEFAULT_REFRESH_INTERVAL));\n+                            properties.put(\"units\", ConnectedDriveConstants.UNITS_AUTODETECT);\n+                            properties.put(\"imageSize\", Integer.toString(ConnectedDriveConstants.DEFAULT_IMAGE_SIZE));\n+                            properties.put(\"imageViewport\", ConnectedDriveConstants.DEFAULT_IMAGE_VIEWPORT);\n+\n+                            String vehicleLabel = vehicle.brand + \" \" + vehicle.model;\n+                            Map<String, Object> convertedProperties = new HashMap<String, Object>(properties);\n+                            thingDiscovered(DiscoveryResultBuilder.create(uid).withBridge(bridgeUID)\n+                                    .withRepresentationProperty(\"vin\").withLabel(vehicleLabel)\n+                                    .withProperties(convertedProperties).build());\n+                        }\n+                    }\n+                });\n+            }\n+        });\n+    }\n+\n+    /**\n+     * Get all field names from a DTO with a specific value\n+     * Used to get e.g. all services which are \"ACTIVATED\"\n+     *\n+     * @param DTO Object\n+     * @param compare String which needs to map with the value\n+     * @return String with all field names matching this value separated with Spaces\n+     */\n+    public String getObject(Object dto, String compare) {\n+        StringBuilder buf = new StringBuilder();\n+        for (Field field : dto.getClass().getDeclaredFields()) {\n+            try {\n+                Object value = field.get(dto);\n+                if (value != null) {\n+                    if (value.equals(compare)) {\n+                        buf.append(Converter.capitalizeFirst(field.getName()) + Constants.SPACE);\n+                    }\n+                }\n+            } catch (IllegalArgumentException e) {\n+                logger.debug(\"Field {} not found {}\", compare, e.getMessage());\n+            } catch (IllegalAccessException e) {\n+                logger.debug(\"Field {} not found {}\", compare, e.getMessage());\n+            }\n+        }\n+        return buf.toString();\n+    }\n+\n+    @Override\n+    public void setThingHandler(ThingHandler handler) {\n+        if (handler instanceof ConnectedDriveBridgeHandler) {\n+            bridgeHandler = Optional.of((ConnectedDriveBridgeHandler) handler);\n+            bridgeHandler.get().setDiscoveryService(this);\n+        }\n+    }\n+\n+    @Override\n+    public @Nullable ThingHandler getThingHandler() {\n+        if (bridgeHandler.isPresent()) {\n+            return bridgeHandler.get();\n+        } else {\n+            return null;\n+        }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MTUyMDM0Nw=="}, "originalCommit": {"oid": "d5c01cbf22b288e86546da29f08d62c4d59189e5"}, "originalPosition": 193}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzYwMTg1ODA4OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/discovery/VehicleDiscovery.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0wN1QwMjo1MToyMlrOIhC3dA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0wNVQxMToxMzowMFrOIw95TA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MTUyMDg4NA==", "bodyText": "This should be checked before you go into the loop.", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r571520884", "createdAt": "2021-02-07T02:51:22Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/discovery/VehicleDiscovery.java", "diffHunk": "@@ -0,0 +1,227 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bmwconnecteddrive.internal.discovery;\n+\n+import static org.openhab.binding.bmwconnecteddrive.internal.ConnectedDriveConstants.SUPPORTED_THING_SET;\n+\n+import java.lang.reflect.Field;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.bmwconnecteddrive.internal.ConnectedDriveConstants;\n+import org.openhab.binding.bmwconnecteddrive.internal.ConnectedDriveHandlerFactory;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.discovery.Vehicle;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.discovery.VehiclesContainer;\n+import org.openhab.binding.bmwconnecteddrive.internal.handler.ConnectedDriveBridgeHandler;\n+import org.openhab.binding.bmwconnecteddrive.internal.handler.VehicleHandler;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Constants;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Converter;\n+import org.openhab.core.config.core.Configuration;\n+import org.openhab.core.config.discovery.AbstractDiscoveryService;\n+import org.openhab.core.config.discovery.DiscoveryResultBuilder;\n+import org.openhab.core.config.discovery.DiscoveryService;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingUID;\n+import org.openhab.core.thing.binding.ThingHandler;\n+import org.openhab.core.thing.binding.ThingHandlerService;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link VehicleDiscovery} requests data from ConnectedDrive and is identifying the Vehicles after response\n+ *\n+ * @author Bernd Weymann - Initial contribution\n+ */\n+@NonNullByDefault\n+public class VehicleDiscovery extends AbstractDiscoveryService implements DiscoveryService, ThingHandlerService {\n+    private final Logger logger = LoggerFactory.getLogger(VehicleDiscovery.class);\n+    private static final int DISCOVERY_TIMEOUT = 10;\n+    private Optional<ConnectedDriveBridgeHandler> bridgeHandler = Optional.empty();\n+\n+    public VehicleDiscovery() {\n+        super(SUPPORTED_THING_SET, DISCOVERY_TIMEOUT, false);\n+    }\n+\n+    public void onResponse(VehiclesContainer container) {\n+        List<Vehicle> vehicles = container.vehicles;\n+        vehicles.forEach(vehicle -> {\n+            if (bridgeHandler.isPresent()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d5c01cbf22b288e86546da29f08d62c4d59189e5"}, "originalPosition": 63}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4ODIxNjY1Mg==", "bodyText": "fixed", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r588216652", "createdAt": "2021-03-05T11:13:00Z", "author": {"login": "ntruchsess"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/discovery/VehicleDiscovery.java", "diffHunk": "@@ -0,0 +1,227 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bmwconnecteddrive.internal.discovery;\n+\n+import static org.openhab.binding.bmwconnecteddrive.internal.ConnectedDriveConstants.SUPPORTED_THING_SET;\n+\n+import java.lang.reflect.Field;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.bmwconnecteddrive.internal.ConnectedDriveConstants;\n+import org.openhab.binding.bmwconnecteddrive.internal.ConnectedDriveHandlerFactory;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.discovery.Vehicle;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.discovery.VehiclesContainer;\n+import org.openhab.binding.bmwconnecteddrive.internal.handler.ConnectedDriveBridgeHandler;\n+import org.openhab.binding.bmwconnecteddrive.internal.handler.VehicleHandler;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Constants;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Converter;\n+import org.openhab.core.config.core.Configuration;\n+import org.openhab.core.config.discovery.AbstractDiscoveryService;\n+import org.openhab.core.config.discovery.DiscoveryResultBuilder;\n+import org.openhab.core.config.discovery.DiscoveryService;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingUID;\n+import org.openhab.core.thing.binding.ThingHandler;\n+import org.openhab.core.thing.binding.ThingHandlerService;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link VehicleDiscovery} requests data from ConnectedDrive and is identifying the Vehicles after response\n+ *\n+ * @author Bernd Weymann - Initial contribution\n+ */\n+@NonNullByDefault\n+public class VehicleDiscovery extends AbstractDiscoveryService implements DiscoveryService, ThingHandlerService {\n+    private final Logger logger = LoggerFactory.getLogger(VehicleDiscovery.class);\n+    private static final int DISCOVERY_TIMEOUT = 10;\n+    private Optional<ConnectedDriveBridgeHandler> bridgeHandler = Optional.empty();\n+\n+    public VehicleDiscovery() {\n+        super(SUPPORTED_THING_SET, DISCOVERY_TIMEOUT, false);\n+    }\n+\n+    public void onResponse(VehiclesContainer container) {\n+        List<Vehicle> vehicles = container.vehicles;\n+        vehicles.forEach(vehicle -> {\n+            if (bridgeHandler.isPresent()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MTUyMDg4NA=="}, "originalCommit": {"oid": "d5c01cbf22b288e86546da29f08d62c4d59189e5"}, "originalPosition": 63}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzYwMTg2MDE2OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/discovery/VehicleDiscovery.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0wN1QwMjo1NDoyMVrOIhC4Yg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0wNVQxMToxMzowOVrOIw95pA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MTUyMTEyMg==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        } catch (IllegalArgumentException e) {\n          \n          \n            \n                            logger.debug(\"Field {} not found {}\", compare, e.getMessage());\n          \n          \n            \n                        } catch (IllegalAccessException e) {\n          \n          \n            \n                        } catch (IllegalArgumentException | IllegalAccessException e) {", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r571521122", "createdAt": "2021-02-07T02:54:21Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/discovery/VehicleDiscovery.java", "diffHunk": "@@ -0,0 +1,227 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bmwconnecteddrive.internal.discovery;\n+\n+import static org.openhab.binding.bmwconnecteddrive.internal.ConnectedDriveConstants.SUPPORTED_THING_SET;\n+\n+import java.lang.reflect.Field;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.bmwconnecteddrive.internal.ConnectedDriveConstants;\n+import org.openhab.binding.bmwconnecteddrive.internal.ConnectedDriveHandlerFactory;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.discovery.Vehicle;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.discovery.VehiclesContainer;\n+import org.openhab.binding.bmwconnecteddrive.internal.handler.ConnectedDriveBridgeHandler;\n+import org.openhab.binding.bmwconnecteddrive.internal.handler.VehicleHandler;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Constants;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Converter;\n+import org.openhab.core.config.core.Configuration;\n+import org.openhab.core.config.discovery.AbstractDiscoveryService;\n+import org.openhab.core.config.discovery.DiscoveryResultBuilder;\n+import org.openhab.core.config.discovery.DiscoveryService;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingUID;\n+import org.openhab.core.thing.binding.ThingHandler;\n+import org.openhab.core.thing.binding.ThingHandlerService;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link VehicleDiscovery} requests data from ConnectedDrive and is identifying the Vehicles after response\n+ *\n+ * @author Bernd Weymann - Initial contribution\n+ */\n+@NonNullByDefault\n+public class VehicleDiscovery extends AbstractDiscoveryService implements DiscoveryService, ThingHandlerService {\n+    private final Logger logger = LoggerFactory.getLogger(VehicleDiscovery.class);\n+    private static final int DISCOVERY_TIMEOUT = 10;\n+    private Optional<ConnectedDriveBridgeHandler> bridgeHandler = Optional.empty();\n+\n+    public VehicleDiscovery() {\n+        super(SUPPORTED_THING_SET, DISCOVERY_TIMEOUT, false);\n+    }\n+\n+    public void onResponse(VehiclesContainer container) {\n+        List<Vehicle> vehicles = container.vehicles;\n+        vehicles.forEach(vehicle -> {\n+            if (bridgeHandler.isPresent()) {\n+                ThingUID bridgeUID = bridgeHandler.get().getThing().getUID();\n+                // the DriveTrain field in the delivered json is defining the Vehicle Type\n+                String vehicleType = vehicle.driveTrain.toLowerCase();\n+                SUPPORTED_THING_SET.forEach(entry -> {\n+                    if (entry.getId().equals(vehicleType)) {\n+                        ThingUID uid = new ThingUID(entry, vehicle.vin, bridgeUID.getId());\n+                        Map<String, String> properties = new HashMap<>();\n+                        // Dealer\n+                        if (vehicle.dealer != null) {\n+                            properties.put(\"dealer\", vehicle.dealer.name);\n+                            properties.put(\"dealerAddress\", vehicle.dealer.street + \" \" + vehicle.dealer.country + \" \"\n+                                    + vehicle.dealer.postalCode + \" \" + vehicle.dealer.city);\n+                            properties.put(\"dealerPhone\", vehicle.dealer.phone);\n+                        }\n+\n+                        // Services & Support\n+                        properties.put(\"servicesActivated\", getObject(vehicle, Constants.ACTIVATED));\n+                        String servicesSupported = getObject(vehicle, Constants.SUPPORTED);\n+                        String servicesNotSupported = getObject(vehicle, Constants.NOT_SUPPORTED);\n+                        if (vehicle.statisticsAvailable) {\n+                            servicesSupported += Constants.STATISTICS;\n+                        } else {\n+                            servicesNotSupported += Constants.STATISTICS;\n+                        }\n+                        properties.put(Constants.SERVICES_SUPPORTED, servicesSupported);\n+                        properties.put(\"servicesNotSupported\", servicesNotSupported);\n+                        properties.put(\"supportBreakdownNumber\", vehicle.breakdownNumber);\n+\n+                        // Vehicle Properties\n+                        if (vehicle.supportedChargingModes != null) {\n+                            StringBuilder chargingModes = new StringBuilder();\n+                            vehicle.supportedChargingModes.forEach(e -> {\n+                                chargingModes.append(e).append(Constants.SPACE);\n+                            });\n+                            properties.put(\"vehicleChargeModes\", chargingModes.toString());\n+                        }\n+                        if (vehicle.hasAlarmSystem) {\n+                            properties.put(\"vehicleAlarmSystem\", \"Available\");\n+                        } else {\n+                            properties.put(\"vehicleAlarmSystem\", \"Not Available\");\n+                        }\n+                        properties.put(\"vehicleBrand\", vehicle.brand);\n+                        properties.put(\"vehicleBodytype\", vehicle.bodytype);\n+                        properties.put(\"vehicleColor\", vehicle.color);\n+                        properties.put(\"vehicleConstructionYear\", Short.toString(vehicle.yearOfConstruction));\n+                        properties.put(\"vehicleDriveTrain\", vehicle.driveTrain);\n+                        properties.put(\"vehicleModel\", vehicle.model);\n+                        if (vehicle.chargingControl != null) {\n+                            properties.put(\"vehicleChargeControl\", Converter.toTitleCase(vehicle.model));\n+                        }\n+\n+                        // Check now if a thing with the same VIN exists\n+                        final AtomicBoolean foundVehicle = new AtomicBoolean(false);\n+                        List<VehicleHandler> l = ConnectedDriveHandlerFactory.getHandlerRegistry();\n+                        l.forEach(handler -> {\n+                            Thing vehicleThing = handler.getThing();\n+                            Configuration c = vehicleThing.getConfiguration();\n+                            if (c.containsKey(\"vin\")) {\n+                                String thingVIN = c.get(\"vin\").toString();\n+                                if (vehicle.vin.equals(thingVIN)) {\n+                                    vehicleThing.setProperties(properties);\n+                                    foundVehicle.set(true);\n+                                }\n+                            }\n+                        });\n+\n+                        // Vehicle not found -> trigger discovery\n+                        if (!foundVehicle.get()) {\n+                            // Properties needed for functional THing\n+                            properties.put(\"vin\", vehicle.vin);\n+                            properties.put(\"refreshInterval\",\n+                                    Integer.toString(ConnectedDriveConstants.DEFAULT_REFRESH_INTERVAL));\n+                            properties.put(\"units\", ConnectedDriveConstants.UNITS_AUTODETECT);\n+                            properties.put(\"imageSize\", Integer.toString(ConnectedDriveConstants.DEFAULT_IMAGE_SIZE));\n+                            properties.put(\"imageViewport\", ConnectedDriveConstants.DEFAULT_IMAGE_VIEWPORT);\n+\n+                            String vehicleLabel = vehicle.brand + \" \" + vehicle.model;\n+                            Map<String, Object> convertedProperties = new HashMap<String, Object>(properties);\n+                            thingDiscovered(DiscoveryResultBuilder.create(uid).withBridge(bridgeUID)\n+                                    .withRepresentationProperty(\"vin\").withLabel(vehicleLabel)\n+                                    .withProperties(convertedProperties).build());\n+                        }\n+                    }\n+                });\n+            }\n+        });\n+    }\n+\n+    /**\n+     * Get all field names from a DTO with a specific value\n+     * Used to get e.g. all services which are \"ACTIVATED\"\n+     *\n+     * @param DTO Object\n+     * @param compare String which needs to map with the value\n+     * @return String with all field names matching this value separated with Spaces\n+     */\n+    public String getObject(Object dto, String compare) {\n+        StringBuilder buf = new StringBuilder();\n+        for (Field field : dto.getClass().getDeclaredFields()) {\n+            try {\n+                Object value = field.get(dto);\n+                if (value != null) {\n+                    if (value.equals(compare)) {\n+                        buf.append(Converter.capitalizeFirst(field.getName()) + Constants.SPACE);\n+                    }\n+                }\n+            } catch (IllegalArgumentException e) {\n+                logger.debug(\"Field {} not found {}\", compare, e.getMessage());\n+            } catch (IllegalAccessException e) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d5c01cbf22b288e86546da29f08d62c4d59189e5"}, "originalPosition": 172}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4ODIxNjc0MA==", "bodyText": "fixed", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r588216740", "createdAt": "2021-03-05T11:13:09Z", "author": {"login": "ntruchsess"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/discovery/VehicleDiscovery.java", "diffHunk": "@@ -0,0 +1,227 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bmwconnecteddrive.internal.discovery;\n+\n+import static org.openhab.binding.bmwconnecteddrive.internal.ConnectedDriveConstants.SUPPORTED_THING_SET;\n+\n+import java.lang.reflect.Field;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.bmwconnecteddrive.internal.ConnectedDriveConstants;\n+import org.openhab.binding.bmwconnecteddrive.internal.ConnectedDriveHandlerFactory;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.discovery.Vehicle;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.discovery.VehiclesContainer;\n+import org.openhab.binding.bmwconnecteddrive.internal.handler.ConnectedDriveBridgeHandler;\n+import org.openhab.binding.bmwconnecteddrive.internal.handler.VehicleHandler;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Constants;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Converter;\n+import org.openhab.core.config.core.Configuration;\n+import org.openhab.core.config.discovery.AbstractDiscoveryService;\n+import org.openhab.core.config.discovery.DiscoveryResultBuilder;\n+import org.openhab.core.config.discovery.DiscoveryService;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingUID;\n+import org.openhab.core.thing.binding.ThingHandler;\n+import org.openhab.core.thing.binding.ThingHandlerService;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link VehicleDiscovery} requests data from ConnectedDrive and is identifying the Vehicles after response\n+ *\n+ * @author Bernd Weymann - Initial contribution\n+ */\n+@NonNullByDefault\n+public class VehicleDiscovery extends AbstractDiscoveryService implements DiscoveryService, ThingHandlerService {\n+    private final Logger logger = LoggerFactory.getLogger(VehicleDiscovery.class);\n+    private static final int DISCOVERY_TIMEOUT = 10;\n+    private Optional<ConnectedDriveBridgeHandler> bridgeHandler = Optional.empty();\n+\n+    public VehicleDiscovery() {\n+        super(SUPPORTED_THING_SET, DISCOVERY_TIMEOUT, false);\n+    }\n+\n+    public void onResponse(VehiclesContainer container) {\n+        List<Vehicle> vehicles = container.vehicles;\n+        vehicles.forEach(vehicle -> {\n+            if (bridgeHandler.isPresent()) {\n+                ThingUID bridgeUID = bridgeHandler.get().getThing().getUID();\n+                // the DriveTrain field in the delivered json is defining the Vehicle Type\n+                String vehicleType = vehicle.driveTrain.toLowerCase();\n+                SUPPORTED_THING_SET.forEach(entry -> {\n+                    if (entry.getId().equals(vehicleType)) {\n+                        ThingUID uid = new ThingUID(entry, vehicle.vin, bridgeUID.getId());\n+                        Map<String, String> properties = new HashMap<>();\n+                        // Dealer\n+                        if (vehicle.dealer != null) {\n+                            properties.put(\"dealer\", vehicle.dealer.name);\n+                            properties.put(\"dealerAddress\", vehicle.dealer.street + \" \" + vehicle.dealer.country + \" \"\n+                                    + vehicle.dealer.postalCode + \" \" + vehicle.dealer.city);\n+                            properties.put(\"dealerPhone\", vehicle.dealer.phone);\n+                        }\n+\n+                        // Services & Support\n+                        properties.put(\"servicesActivated\", getObject(vehicle, Constants.ACTIVATED));\n+                        String servicesSupported = getObject(vehicle, Constants.SUPPORTED);\n+                        String servicesNotSupported = getObject(vehicle, Constants.NOT_SUPPORTED);\n+                        if (vehicle.statisticsAvailable) {\n+                            servicesSupported += Constants.STATISTICS;\n+                        } else {\n+                            servicesNotSupported += Constants.STATISTICS;\n+                        }\n+                        properties.put(Constants.SERVICES_SUPPORTED, servicesSupported);\n+                        properties.put(\"servicesNotSupported\", servicesNotSupported);\n+                        properties.put(\"supportBreakdownNumber\", vehicle.breakdownNumber);\n+\n+                        // Vehicle Properties\n+                        if (vehicle.supportedChargingModes != null) {\n+                            StringBuilder chargingModes = new StringBuilder();\n+                            vehicle.supportedChargingModes.forEach(e -> {\n+                                chargingModes.append(e).append(Constants.SPACE);\n+                            });\n+                            properties.put(\"vehicleChargeModes\", chargingModes.toString());\n+                        }\n+                        if (vehicle.hasAlarmSystem) {\n+                            properties.put(\"vehicleAlarmSystem\", \"Available\");\n+                        } else {\n+                            properties.put(\"vehicleAlarmSystem\", \"Not Available\");\n+                        }\n+                        properties.put(\"vehicleBrand\", vehicle.brand);\n+                        properties.put(\"vehicleBodytype\", vehicle.bodytype);\n+                        properties.put(\"vehicleColor\", vehicle.color);\n+                        properties.put(\"vehicleConstructionYear\", Short.toString(vehicle.yearOfConstruction));\n+                        properties.put(\"vehicleDriveTrain\", vehicle.driveTrain);\n+                        properties.put(\"vehicleModel\", vehicle.model);\n+                        if (vehicle.chargingControl != null) {\n+                            properties.put(\"vehicleChargeControl\", Converter.toTitleCase(vehicle.model));\n+                        }\n+\n+                        // Check now if a thing with the same VIN exists\n+                        final AtomicBoolean foundVehicle = new AtomicBoolean(false);\n+                        List<VehicleHandler> l = ConnectedDriveHandlerFactory.getHandlerRegistry();\n+                        l.forEach(handler -> {\n+                            Thing vehicleThing = handler.getThing();\n+                            Configuration c = vehicleThing.getConfiguration();\n+                            if (c.containsKey(\"vin\")) {\n+                                String thingVIN = c.get(\"vin\").toString();\n+                                if (vehicle.vin.equals(thingVIN)) {\n+                                    vehicleThing.setProperties(properties);\n+                                    foundVehicle.set(true);\n+                                }\n+                            }\n+                        });\n+\n+                        // Vehicle not found -> trigger discovery\n+                        if (!foundVehicle.get()) {\n+                            // Properties needed for functional THing\n+                            properties.put(\"vin\", vehicle.vin);\n+                            properties.put(\"refreshInterval\",\n+                                    Integer.toString(ConnectedDriveConstants.DEFAULT_REFRESH_INTERVAL));\n+                            properties.put(\"units\", ConnectedDriveConstants.UNITS_AUTODETECT);\n+                            properties.put(\"imageSize\", Integer.toString(ConnectedDriveConstants.DEFAULT_IMAGE_SIZE));\n+                            properties.put(\"imageViewport\", ConnectedDriveConstants.DEFAULT_IMAGE_VIEWPORT);\n+\n+                            String vehicleLabel = vehicle.brand + \" \" + vehicle.model;\n+                            Map<String, Object> convertedProperties = new HashMap<String, Object>(properties);\n+                            thingDiscovered(DiscoveryResultBuilder.create(uid).withBridge(bridgeUID)\n+                                    .withRepresentationProperty(\"vin\").withLabel(vehicleLabel)\n+                                    .withProperties(convertedProperties).build());\n+                        }\n+                    }\n+                });\n+            }\n+        });\n+    }\n+\n+    /**\n+     * Get all field names from a DTO with a specific value\n+     * Used to get e.g. all services which are \"ACTIVATED\"\n+     *\n+     * @param DTO Object\n+     * @param compare String which needs to map with the value\n+     * @return String with all field names matching this value separated with Spaces\n+     */\n+    public String getObject(Object dto, String compare) {\n+        StringBuilder buf = new StringBuilder();\n+        for (Field field : dto.getClass().getDeclaredFields()) {\n+            try {\n+                Object value = field.get(dto);\n+                if (value != null) {\n+                    if (value.equals(compare)) {\n+                        buf.append(Converter.capitalizeFirst(field.getName()) + Constants.SPACE);\n+                    }\n+                }\n+            } catch (IllegalArgumentException e) {\n+                logger.debug(\"Field {} not found {}\", compare, e.getMessage());\n+            } catch (IllegalAccessException e) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MTUyMTEyMg=="}, "originalCommit": {"oid": "d5c01cbf22b288e86546da29f08d62c4d59189e5"}, "originalPosition": 172}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzYwMTg2MDQ1OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/discovery/VehicleDiscovery.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0wN1QwMjo1NTowMVrOIhC4kQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0wNVQxMToxMzoyOVrOIw96Vw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MTUyMTE2OQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            if (value != null) {\n          \n          \n            \n                                if (value.equals(compare)) {\n          \n          \n            \n                                    buf.append(Converter.capitalizeFirst(field.getName()) + Constants.SPACE);\n          \n          \n            \n                                }\n          \n          \n            \n                            }\n          \n          \n            \n                            if (compare.equals(value)) {\n          \n          \n            \n                                buf.append(Converter.capitalizeFirst(field.getName()) + Constants.SPACE);\n          \n          \n            \n                            }", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r571521169", "createdAt": "2021-02-07T02:55:01Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/discovery/VehicleDiscovery.java", "diffHunk": "@@ -0,0 +1,227 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bmwconnecteddrive.internal.discovery;\n+\n+import static org.openhab.binding.bmwconnecteddrive.internal.ConnectedDriveConstants.SUPPORTED_THING_SET;\n+\n+import java.lang.reflect.Field;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.bmwconnecteddrive.internal.ConnectedDriveConstants;\n+import org.openhab.binding.bmwconnecteddrive.internal.ConnectedDriveHandlerFactory;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.discovery.Vehicle;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.discovery.VehiclesContainer;\n+import org.openhab.binding.bmwconnecteddrive.internal.handler.ConnectedDriveBridgeHandler;\n+import org.openhab.binding.bmwconnecteddrive.internal.handler.VehicleHandler;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Constants;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Converter;\n+import org.openhab.core.config.core.Configuration;\n+import org.openhab.core.config.discovery.AbstractDiscoveryService;\n+import org.openhab.core.config.discovery.DiscoveryResultBuilder;\n+import org.openhab.core.config.discovery.DiscoveryService;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingUID;\n+import org.openhab.core.thing.binding.ThingHandler;\n+import org.openhab.core.thing.binding.ThingHandlerService;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link VehicleDiscovery} requests data from ConnectedDrive and is identifying the Vehicles after response\n+ *\n+ * @author Bernd Weymann - Initial contribution\n+ */\n+@NonNullByDefault\n+public class VehicleDiscovery extends AbstractDiscoveryService implements DiscoveryService, ThingHandlerService {\n+    private final Logger logger = LoggerFactory.getLogger(VehicleDiscovery.class);\n+    private static final int DISCOVERY_TIMEOUT = 10;\n+    private Optional<ConnectedDriveBridgeHandler> bridgeHandler = Optional.empty();\n+\n+    public VehicleDiscovery() {\n+        super(SUPPORTED_THING_SET, DISCOVERY_TIMEOUT, false);\n+    }\n+\n+    public void onResponse(VehiclesContainer container) {\n+        List<Vehicle> vehicles = container.vehicles;\n+        vehicles.forEach(vehicle -> {\n+            if (bridgeHandler.isPresent()) {\n+                ThingUID bridgeUID = bridgeHandler.get().getThing().getUID();\n+                // the DriveTrain field in the delivered json is defining the Vehicle Type\n+                String vehicleType = vehicle.driveTrain.toLowerCase();\n+                SUPPORTED_THING_SET.forEach(entry -> {\n+                    if (entry.getId().equals(vehicleType)) {\n+                        ThingUID uid = new ThingUID(entry, vehicle.vin, bridgeUID.getId());\n+                        Map<String, String> properties = new HashMap<>();\n+                        // Dealer\n+                        if (vehicle.dealer != null) {\n+                            properties.put(\"dealer\", vehicle.dealer.name);\n+                            properties.put(\"dealerAddress\", vehicle.dealer.street + \" \" + vehicle.dealer.country + \" \"\n+                                    + vehicle.dealer.postalCode + \" \" + vehicle.dealer.city);\n+                            properties.put(\"dealerPhone\", vehicle.dealer.phone);\n+                        }\n+\n+                        // Services & Support\n+                        properties.put(\"servicesActivated\", getObject(vehicle, Constants.ACTIVATED));\n+                        String servicesSupported = getObject(vehicle, Constants.SUPPORTED);\n+                        String servicesNotSupported = getObject(vehicle, Constants.NOT_SUPPORTED);\n+                        if (vehicle.statisticsAvailable) {\n+                            servicesSupported += Constants.STATISTICS;\n+                        } else {\n+                            servicesNotSupported += Constants.STATISTICS;\n+                        }\n+                        properties.put(Constants.SERVICES_SUPPORTED, servicesSupported);\n+                        properties.put(\"servicesNotSupported\", servicesNotSupported);\n+                        properties.put(\"supportBreakdownNumber\", vehicle.breakdownNumber);\n+\n+                        // Vehicle Properties\n+                        if (vehicle.supportedChargingModes != null) {\n+                            StringBuilder chargingModes = new StringBuilder();\n+                            vehicle.supportedChargingModes.forEach(e -> {\n+                                chargingModes.append(e).append(Constants.SPACE);\n+                            });\n+                            properties.put(\"vehicleChargeModes\", chargingModes.toString());\n+                        }\n+                        if (vehicle.hasAlarmSystem) {\n+                            properties.put(\"vehicleAlarmSystem\", \"Available\");\n+                        } else {\n+                            properties.put(\"vehicleAlarmSystem\", \"Not Available\");\n+                        }\n+                        properties.put(\"vehicleBrand\", vehicle.brand);\n+                        properties.put(\"vehicleBodytype\", vehicle.bodytype);\n+                        properties.put(\"vehicleColor\", vehicle.color);\n+                        properties.put(\"vehicleConstructionYear\", Short.toString(vehicle.yearOfConstruction));\n+                        properties.put(\"vehicleDriveTrain\", vehicle.driveTrain);\n+                        properties.put(\"vehicleModel\", vehicle.model);\n+                        if (vehicle.chargingControl != null) {\n+                            properties.put(\"vehicleChargeControl\", Converter.toTitleCase(vehicle.model));\n+                        }\n+\n+                        // Check now if a thing with the same VIN exists\n+                        final AtomicBoolean foundVehicle = new AtomicBoolean(false);\n+                        List<VehicleHandler> l = ConnectedDriveHandlerFactory.getHandlerRegistry();\n+                        l.forEach(handler -> {\n+                            Thing vehicleThing = handler.getThing();\n+                            Configuration c = vehicleThing.getConfiguration();\n+                            if (c.containsKey(\"vin\")) {\n+                                String thingVIN = c.get(\"vin\").toString();\n+                                if (vehicle.vin.equals(thingVIN)) {\n+                                    vehicleThing.setProperties(properties);\n+                                    foundVehicle.set(true);\n+                                }\n+                            }\n+                        });\n+\n+                        // Vehicle not found -> trigger discovery\n+                        if (!foundVehicle.get()) {\n+                            // Properties needed for functional THing\n+                            properties.put(\"vin\", vehicle.vin);\n+                            properties.put(\"refreshInterval\",\n+                                    Integer.toString(ConnectedDriveConstants.DEFAULT_REFRESH_INTERVAL));\n+                            properties.put(\"units\", ConnectedDriveConstants.UNITS_AUTODETECT);\n+                            properties.put(\"imageSize\", Integer.toString(ConnectedDriveConstants.DEFAULT_IMAGE_SIZE));\n+                            properties.put(\"imageViewport\", ConnectedDriveConstants.DEFAULT_IMAGE_VIEWPORT);\n+\n+                            String vehicleLabel = vehicle.brand + \" \" + vehicle.model;\n+                            Map<String, Object> convertedProperties = new HashMap<String, Object>(properties);\n+                            thingDiscovered(DiscoveryResultBuilder.create(uid).withBridge(bridgeUID)\n+                                    .withRepresentationProperty(\"vin\").withLabel(vehicleLabel)\n+                                    .withProperties(convertedProperties).build());\n+                        }\n+                    }\n+                });\n+            }\n+        });\n+    }\n+\n+    /**\n+     * Get all field names from a DTO with a specific value\n+     * Used to get e.g. all services which are \"ACTIVATED\"\n+     *\n+     * @param DTO Object\n+     * @param compare String which needs to map with the value\n+     * @return String with all field names matching this value separated with Spaces\n+     */\n+    public String getObject(Object dto, String compare) {\n+        StringBuilder buf = new StringBuilder();\n+        for (Field field : dto.getClass().getDeclaredFields()) {\n+            try {\n+                Object value = field.get(dto);\n+                if (value != null) {\n+                    if (value.equals(compare)) {\n+                        buf.append(Converter.capitalizeFirst(field.getName()) + Constants.SPACE);\n+                    }\n+                }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d5c01cbf22b288e86546da29f08d62c4d59189e5"}, "originalPosition": 169}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4ODIxNjkxOQ==", "bodyText": "fixed", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r588216919", "createdAt": "2021-03-05T11:13:29Z", "author": {"login": "ntruchsess"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/discovery/VehicleDiscovery.java", "diffHunk": "@@ -0,0 +1,227 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bmwconnecteddrive.internal.discovery;\n+\n+import static org.openhab.binding.bmwconnecteddrive.internal.ConnectedDriveConstants.SUPPORTED_THING_SET;\n+\n+import java.lang.reflect.Field;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.bmwconnecteddrive.internal.ConnectedDriveConstants;\n+import org.openhab.binding.bmwconnecteddrive.internal.ConnectedDriveHandlerFactory;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.discovery.Vehicle;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.discovery.VehiclesContainer;\n+import org.openhab.binding.bmwconnecteddrive.internal.handler.ConnectedDriveBridgeHandler;\n+import org.openhab.binding.bmwconnecteddrive.internal.handler.VehicleHandler;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Constants;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Converter;\n+import org.openhab.core.config.core.Configuration;\n+import org.openhab.core.config.discovery.AbstractDiscoveryService;\n+import org.openhab.core.config.discovery.DiscoveryResultBuilder;\n+import org.openhab.core.config.discovery.DiscoveryService;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingUID;\n+import org.openhab.core.thing.binding.ThingHandler;\n+import org.openhab.core.thing.binding.ThingHandlerService;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link VehicleDiscovery} requests data from ConnectedDrive and is identifying the Vehicles after response\n+ *\n+ * @author Bernd Weymann - Initial contribution\n+ */\n+@NonNullByDefault\n+public class VehicleDiscovery extends AbstractDiscoveryService implements DiscoveryService, ThingHandlerService {\n+    private final Logger logger = LoggerFactory.getLogger(VehicleDiscovery.class);\n+    private static final int DISCOVERY_TIMEOUT = 10;\n+    private Optional<ConnectedDriveBridgeHandler> bridgeHandler = Optional.empty();\n+\n+    public VehicleDiscovery() {\n+        super(SUPPORTED_THING_SET, DISCOVERY_TIMEOUT, false);\n+    }\n+\n+    public void onResponse(VehiclesContainer container) {\n+        List<Vehicle> vehicles = container.vehicles;\n+        vehicles.forEach(vehicle -> {\n+            if (bridgeHandler.isPresent()) {\n+                ThingUID bridgeUID = bridgeHandler.get().getThing().getUID();\n+                // the DriveTrain field in the delivered json is defining the Vehicle Type\n+                String vehicleType = vehicle.driveTrain.toLowerCase();\n+                SUPPORTED_THING_SET.forEach(entry -> {\n+                    if (entry.getId().equals(vehicleType)) {\n+                        ThingUID uid = new ThingUID(entry, vehicle.vin, bridgeUID.getId());\n+                        Map<String, String> properties = new HashMap<>();\n+                        // Dealer\n+                        if (vehicle.dealer != null) {\n+                            properties.put(\"dealer\", vehicle.dealer.name);\n+                            properties.put(\"dealerAddress\", vehicle.dealer.street + \" \" + vehicle.dealer.country + \" \"\n+                                    + vehicle.dealer.postalCode + \" \" + vehicle.dealer.city);\n+                            properties.put(\"dealerPhone\", vehicle.dealer.phone);\n+                        }\n+\n+                        // Services & Support\n+                        properties.put(\"servicesActivated\", getObject(vehicle, Constants.ACTIVATED));\n+                        String servicesSupported = getObject(vehicle, Constants.SUPPORTED);\n+                        String servicesNotSupported = getObject(vehicle, Constants.NOT_SUPPORTED);\n+                        if (vehicle.statisticsAvailable) {\n+                            servicesSupported += Constants.STATISTICS;\n+                        } else {\n+                            servicesNotSupported += Constants.STATISTICS;\n+                        }\n+                        properties.put(Constants.SERVICES_SUPPORTED, servicesSupported);\n+                        properties.put(\"servicesNotSupported\", servicesNotSupported);\n+                        properties.put(\"supportBreakdownNumber\", vehicle.breakdownNumber);\n+\n+                        // Vehicle Properties\n+                        if (vehicle.supportedChargingModes != null) {\n+                            StringBuilder chargingModes = new StringBuilder();\n+                            vehicle.supportedChargingModes.forEach(e -> {\n+                                chargingModes.append(e).append(Constants.SPACE);\n+                            });\n+                            properties.put(\"vehicleChargeModes\", chargingModes.toString());\n+                        }\n+                        if (vehicle.hasAlarmSystem) {\n+                            properties.put(\"vehicleAlarmSystem\", \"Available\");\n+                        } else {\n+                            properties.put(\"vehicleAlarmSystem\", \"Not Available\");\n+                        }\n+                        properties.put(\"vehicleBrand\", vehicle.brand);\n+                        properties.put(\"vehicleBodytype\", vehicle.bodytype);\n+                        properties.put(\"vehicleColor\", vehicle.color);\n+                        properties.put(\"vehicleConstructionYear\", Short.toString(vehicle.yearOfConstruction));\n+                        properties.put(\"vehicleDriveTrain\", vehicle.driveTrain);\n+                        properties.put(\"vehicleModel\", vehicle.model);\n+                        if (vehicle.chargingControl != null) {\n+                            properties.put(\"vehicleChargeControl\", Converter.toTitleCase(vehicle.model));\n+                        }\n+\n+                        // Check now if a thing with the same VIN exists\n+                        final AtomicBoolean foundVehicle = new AtomicBoolean(false);\n+                        List<VehicleHandler> l = ConnectedDriveHandlerFactory.getHandlerRegistry();\n+                        l.forEach(handler -> {\n+                            Thing vehicleThing = handler.getThing();\n+                            Configuration c = vehicleThing.getConfiguration();\n+                            if (c.containsKey(\"vin\")) {\n+                                String thingVIN = c.get(\"vin\").toString();\n+                                if (vehicle.vin.equals(thingVIN)) {\n+                                    vehicleThing.setProperties(properties);\n+                                    foundVehicle.set(true);\n+                                }\n+                            }\n+                        });\n+\n+                        // Vehicle not found -> trigger discovery\n+                        if (!foundVehicle.get()) {\n+                            // Properties needed for functional THing\n+                            properties.put(\"vin\", vehicle.vin);\n+                            properties.put(\"refreshInterval\",\n+                                    Integer.toString(ConnectedDriveConstants.DEFAULT_REFRESH_INTERVAL));\n+                            properties.put(\"units\", ConnectedDriveConstants.UNITS_AUTODETECT);\n+                            properties.put(\"imageSize\", Integer.toString(ConnectedDriveConstants.DEFAULT_IMAGE_SIZE));\n+                            properties.put(\"imageViewport\", ConnectedDriveConstants.DEFAULT_IMAGE_VIEWPORT);\n+\n+                            String vehicleLabel = vehicle.brand + \" \" + vehicle.model;\n+                            Map<String, Object> convertedProperties = new HashMap<String, Object>(properties);\n+                            thingDiscovered(DiscoveryResultBuilder.create(uid).withBridge(bridgeUID)\n+                                    .withRepresentationProperty(\"vin\").withLabel(vehicleLabel)\n+                                    .withProperties(convertedProperties).build());\n+                        }\n+                    }\n+                });\n+            }\n+        });\n+    }\n+\n+    /**\n+     * Get all field names from a DTO with a specific value\n+     * Used to get e.g. all services which are \"ACTIVATED\"\n+     *\n+     * @param DTO Object\n+     * @param compare String which needs to map with the value\n+     * @return String with all field names matching this value separated with Spaces\n+     */\n+    public String getObject(Object dto, String compare) {\n+        StringBuilder buf = new StringBuilder();\n+        for (Field field : dto.getClass().getDeclaredFields()) {\n+            try {\n+                Object value = field.get(dto);\n+                if (value != null) {\n+                    if (value.equals(compare)) {\n+                        buf.append(Converter.capitalizeFirst(field.getName()) + Constants.SPACE);\n+                    }\n+                }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MTUyMTE2OQ=="}, "originalCommit": {"oid": "d5c01cbf22b288e86546da29f08d62c4d59189e5"}, "originalPosition": 169}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzYwMTg2NzcwOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/discovery/VehicleDiscovery.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0wN1QwMjo1OToyMFrOIhC89Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0wNlQxNjo0OTowMFrOIxn0dA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MTUyMjI5Mw==", "bodyText": "Please make \"vin\" a static constant since you use it in several places.", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r571522293", "createdAt": "2021-02-07T02:59:20Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/discovery/VehicleDiscovery.java", "diffHunk": "@@ -0,0 +1,227 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bmwconnecteddrive.internal.discovery;\n+\n+import static org.openhab.binding.bmwconnecteddrive.internal.ConnectedDriveConstants.SUPPORTED_THING_SET;\n+\n+import java.lang.reflect.Field;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.bmwconnecteddrive.internal.ConnectedDriveConstants;\n+import org.openhab.binding.bmwconnecteddrive.internal.ConnectedDriveHandlerFactory;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.discovery.Vehicle;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.discovery.VehiclesContainer;\n+import org.openhab.binding.bmwconnecteddrive.internal.handler.ConnectedDriveBridgeHandler;\n+import org.openhab.binding.bmwconnecteddrive.internal.handler.VehicleHandler;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Constants;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Converter;\n+import org.openhab.core.config.core.Configuration;\n+import org.openhab.core.config.discovery.AbstractDiscoveryService;\n+import org.openhab.core.config.discovery.DiscoveryResultBuilder;\n+import org.openhab.core.config.discovery.DiscoveryService;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingUID;\n+import org.openhab.core.thing.binding.ThingHandler;\n+import org.openhab.core.thing.binding.ThingHandlerService;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link VehicleDiscovery} requests data from ConnectedDrive and is identifying the Vehicles after response\n+ *\n+ * @author Bernd Weymann - Initial contribution\n+ */\n+@NonNullByDefault\n+public class VehicleDiscovery extends AbstractDiscoveryService implements DiscoveryService, ThingHandlerService {\n+    private final Logger logger = LoggerFactory.getLogger(VehicleDiscovery.class);\n+    private static final int DISCOVERY_TIMEOUT = 10;\n+    private Optional<ConnectedDriveBridgeHandler> bridgeHandler = Optional.empty();\n+\n+    public VehicleDiscovery() {\n+        super(SUPPORTED_THING_SET, DISCOVERY_TIMEOUT, false);\n+    }\n+\n+    public void onResponse(VehiclesContainer container) {\n+        List<Vehicle> vehicles = container.vehicles;\n+        vehicles.forEach(vehicle -> {\n+            if (bridgeHandler.isPresent()) {\n+                ThingUID bridgeUID = bridgeHandler.get().getThing().getUID();\n+                // the DriveTrain field in the delivered json is defining the Vehicle Type\n+                String vehicleType = vehicle.driveTrain.toLowerCase();\n+                SUPPORTED_THING_SET.forEach(entry -> {\n+                    if (entry.getId().equals(vehicleType)) {\n+                        ThingUID uid = new ThingUID(entry, vehicle.vin, bridgeUID.getId());\n+                        Map<String, String> properties = new HashMap<>();\n+                        // Dealer\n+                        if (vehicle.dealer != null) {\n+                            properties.put(\"dealer\", vehicle.dealer.name);\n+                            properties.put(\"dealerAddress\", vehicle.dealer.street + \" \" + vehicle.dealer.country + \" \"\n+                                    + vehicle.dealer.postalCode + \" \" + vehicle.dealer.city);\n+                            properties.put(\"dealerPhone\", vehicle.dealer.phone);\n+                        }\n+\n+                        // Services & Support\n+                        properties.put(\"servicesActivated\", getObject(vehicle, Constants.ACTIVATED));\n+                        String servicesSupported = getObject(vehicle, Constants.SUPPORTED);\n+                        String servicesNotSupported = getObject(vehicle, Constants.NOT_SUPPORTED);\n+                        if (vehicle.statisticsAvailable) {\n+                            servicesSupported += Constants.STATISTICS;\n+                        } else {\n+                            servicesNotSupported += Constants.STATISTICS;\n+                        }\n+                        properties.put(Constants.SERVICES_SUPPORTED, servicesSupported);\n+                        properties.put(\"servicesNotSupported\", servicesNotSupported);\n+                        properties.put(\"supportBreakdownNumber\", vehicle.breakdownNumber);\n+\n+                        // Vehicle Properties\n+                        if (vehicle.supportedChargingModes != null) {\n+                            StringBuilder chargingModes = new StringBuilder();\n+                            vehicle.supportedChargingModes.forEach(e -> {\n+                                chargingModes.append(e).append(Constants.SPACE);\n+                            });\n+                            properties.put(\"vehicleChargeModes\", chargingModes.toString());\n+                        }\n+                        if (vehicle.hasAlarmSystem) {\n+                            properties.put(\"vehicleAlarmSystem\", \"Available\");\n+                        } else {\n+                            properties.put(\"vehicleAlarmSystem\", \"Not Available\");\n+                        }\n+                        properties.put(\"vehicleBrand\", vehicle.brand);\n+                        properties.put(\"vehicleBodytype\", vehicle.bodytype);\n+                        properties.put(\"vehicleColor\", vehicle.color);\n+                        properties.put(\"vehicleConstructionYear\", Short.toString(vehicle.yearOfConstruction));\n+                        properties.put(\"vehicleDriveTrain\", vehicle.driveTrain);\n+                        properties.put(\"vehicleModel\", vehicle.model);\n+                        if (vehicle.chargingControl != null) {\n+                            properties.put(\"vehicleChargeControl\", Converter.toTitleCase(vehicle.model));\n+                        }\n+\n+                        // Check now if a thing with the same VIN exists\n+                        final AtomicBoolean foundVehicle = new AtomicBoolean(false);\n+                        List<VehicleHandler> l = ConnectedDriveHandlerFactory.getHandlerRegistry();\n+                        l.forEach(handler -> {\n+                            Thing vehicleThing = handler.getThing();\n+                            Configuration c = vehicleThing.getConfiguration();\n+                            if (c.containsKey(\"vin\")) {\n+                                String thingVIN = c.get(\"vin\").toString();\n+                                if (vehicle.vin.equals(thingVIN)) {\n+                                    vehicleThing.setProperties(properties);\n+                                    foundVehicle.set(true);\n+                                }\n+                            }\n+                        });\n+\n+                        // Vehicle not found -> trigger discovery\n+                        if (!foundVehicle.get()) {\n+                            // Properties needed for functional THing\n+                            properties.put(\"vin\", vehicle.vin);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d5c01cbf22b288e86546da29f08d62c4d59189e5"}, "originalPosition": 133}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4ODkwMzU0MA==", "bodyText": "fixed", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r588903540", "createdAt": "2021-03-06T16:49:00Z", "author": {"login": "weymann"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/discovery/VehicleDiscovery.java", "diffHunk": "@@ -0,0 +1,227 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bmwconnecteddrive.internal.discovery;\n+\n+import static org.openhab.binding.bmwconnecteddrive.internal.ConnectedDriveConstants.SUPPORTED_THING_SET;\n+\n+import java.lang.reflect.Field;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.bmwconnecteddrive.internal.ConnectedDriveConstants;\n+import org.openhab.binding.bmwconnecteddrive.internal.ConnectedDriveHandlerFactory;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.discovery.Vehicle;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.discovery.VehiclesContainer;\n+import org.openhab.binding.bmwconnecteddrive.internal.handler.ConnectedDriveBridgeHandler;\n+import org.openhab.binding.bmwconnecteddrive.internal.handler.VehicleHandler;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Constants;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Converter;\n+import org.openhab.core.config.core.Configuration;\n+import org.openhab.core.config.discovery.AbstractDiscoveryService;\n+import org.openhab.core.config.discovery.DiscoveryResultBuilder;\n+import org.openhab.core.config.discovery.DiscoveryService;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingUID;\n+import org.openhab.core.thing.binding.ThingHandler;\n+import org.openhab.core.thing.binding.ThingHandlerService;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link VehicleDiscovery} requests data from ConnectedDrive and is identifying the Vehicles after response\n+ *\n+ * @author Bernd Weymann - Initial contribution\n+ */\n+@NonNullByDefault\n+public class VehicleDiscovery extends AbstractDiscoveryService implements DiscoveryService, ThingHandlerService {\n+    private final Logger logger = LoggerFactory.getLogger(VehicleDiscovery.class);\n+    private static final int DISCOVERY_TIMEOUT = 10;\n+    private Optional<ConnectedDriveBridgeHandler> bridgeHandler = Optional.empty();\n+\n+    public VehicleDiscovery() {\n+        super(SUPPORTED_THING_SET, DISCOVERY_TIMEOUT, false);\n+    }\n+\n+    public void onResponse(VehiclesContainer container) {\n+        List<Vehicle> vehicles = container.vehicles;\n+        vehicles.forEach(vehicle -> {\n+            if (bridgeHandler.isPresent()) {\n+                ThingUID bridgeUID = bridgeHandler.get().getThing().getUID();\n+                // the DriveTrain field in the delivered json is defining the Vehicle Type\n+                String vehicleType = vehicle.driveTrain.toLowerCase();\n+                SUPPORTED_THING_SET.forEach(entry -> {\n+                    if (entry.getId().equals(vehicleType)) {\n+                        ThingUID uid = new ThingUID(entry, vehicle.vin, bridgeUID.getId());\n+                        Map<String, String> properties = new HashMap<>();\n+                        // Dealer\n+                        if (vehicle.dealer != null) {\n+                            properties.put(\"dealer\", vehicle.dealer.name);\n+                            properties.put(\"dealerAddress\", vehicle.dealer.street + \" \" + vehicle.dealer.country + \" \"\n+                                    + vehicle.dealer.postalCode + \" \" + vehicle.dealer.city);\n+                            properties.put(\"dealerPhone\", vehicle.dealer.phone);\n+                        }\n+\n+                        // Services & Support\n+                        properties.put(\"servicesActivated\", getObject(vehicle, Constants.ACTIVATED));\n+                        String servicesSupported = getObject(vehicle, Constants.SUPPORTED);\n+                        String servicesNotSupported = getObject(vehicle, Constants.NOT_SUPPORTED);\n+                        if (vehicle.statisticsAvailable) {\n+                            servicesSupported += Constants.STATISTICS;\n+                        } else {\n+                            servicesNotSupported += Constants.STATISTICS;\n+                        }\n+                        properties.put(Constants.SERVICES_SUPPORTED, servicesSupported);\n+                        properties.put(\"servicesNotSupported\", servicesNotSupported);\n+                        properties.put(\"supportBreakdownNumber\", vehicle.breakdownNumber);\n+\n+                        // Vehicle Properties\n+                        if (vehicle.supportedChargingModes != null) {\n+                            StringBuilder chargingModes = new StringBuilder();\n+                            vehicle.supportedChargingModes.forEach(e -> {\n+                                chargingModes.append(e).append(Constants.SPACE);\n+                            });\n+                            properties.put(\"vehicleChargeModes\", chargingModes.toString());\n+                        }\n+                        if (vehicle.hasAlarmSystem) {\n+                            properties.put(\"vehicleAlarmSystem\", \"Available\");\n+                        } else {\n+                            properties.put(\"vehicleAlarmSystem\", \"Not Available\");\n+                        }\n+                        properties.put(\"vehicleBrand\", vehicle.brand);\n+                        properties.put(\"vehicleBodytype\", vehicle.bodytype);\n+                        properties.put(\"vehicleColor\", vehicle.color);\n+                        properties.put(\"vehicleConstructionYear\", Short.toString(vehicle.yearOfConstruction));\n+                        properties.put(\"vehicleDriveTrain\", vehicle.driveTrain);\n+                        properties.put(\"vehicleModel\", vehicle.model);\n+                        if (vehicle.chargingControl != null) {\n+                            properties.put(\"vehicleChargeControl\", Converter.toTitleCase(vehicle.model));\n+                        }\n+\n+                        // Check now if a thing with the same VIN exists\n+                        final AtomicBoolean foundVehicle = new AtomicBoolean(false);\n+                        List<VehicleHandler> l = ConnectedDriveHandlerFactory.getHandlerRegistry();\n+                        l.forEach(handler -> {\n+                            Thing vehicleThing = handler.getThing();\n+                            Configuration c = vehicleThing.getConfiguration();\n+                            if (c.containsKey(\"vin\")) {\n+                                String thingVIN = c.get(\"vin\").toString();\n+                                if (vehicle.vin.equals(thingVIN)) {\n+                                    vehicleThing.setProperties(properties);\n+                                    foundVehicle.set(true);\n+                                }\n+                            }\n+                        });\n+\n+                        // Vehicle not found -> trigger discovery\n+                        if (!foundVehicle.get()) {\n+                            // Properties needed for functional THing\n+                            properties.put(\"vin\", vehicle.vin);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MTUyMjI5Mw=="}, "originalCommit": {"oid": "d5c01cbf22b288e86546da29f08d62c4d59189e5"}, "originalPosition": 133}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzYwMTg2OTc5OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/discovery/VehicleDiscovery.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0wN1QwMzowMjo1M1rOIhC95g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0wNVQxNDowOTozOFrOIxETng==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MTUyMjUzNA==", "bodyText": "I assume that the extra space at the end isn't intentional.\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                        StringBuilder chargingModes = new StringBuilder();\n          \n          \n            \n                                        vehicle.supportedChargingModes.forEach(e -> {\n          \n          \n            \n                                            chargingModes.append(e).append(Constants.SPACE);\n          \n          \n            \n                                        });\n          \n          \n            \n                                        properties.put(\"vehicleChargeModes\", chargingModes.toString());\n          \n          \n            \n                                        properties.put(\"vehicleChargeModes\", String.join(Constants.SPACE, vehicle.supportedChargingModes));", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r571522534", "createdAt": "2021-02-07T03:02:53Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/discovery/VehicleDiscovery.java", "diffHunk": "@@ -0,0 +1,227 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bmwconnecteddrive.internal.discovery;\n+\n+import static org.openhab.binding.bmwconnecteddrive.internal.ConnectedDriveConstants.SUPPORTED_THING_SET;\n+\n+import java.lang.reflect.Field;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.bmwconnecteddrive.internal.ConnectedDriveConstants;\n+import org.openhab.binding.bmwconnecteddrive.internal.ConnectedDriveHandlerFactory;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.discovery.Vehicle;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.discovery.VehiclesContainer;\n+import org.openhab.binding.bmwconnecteddrive.internal.handler.ConnectedDriveBridgeHandler;\n+import org.openhab.binding.bmwconnecteddrive.internal.handler.VehicleHandler;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Constants;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Converter;\n+import org.openhab.core.config.core.Configuration;\n+import org.openhab.core.config.discovery.AbstractDiscoveryService;\n+import org.openhab.core.config.discovery.DiscoveryResultBuilder;\n+import org.openhab.core.config.discovery.DiscoveryService;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingUID;\n+import org.openhab.core.thing.binding.ThingHandler;\n+import org.openhab.core.thing.binding.ThingHandlerService;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link VehicleDiscovery} requests data from ConnectedDrive and is identifying the Vehicles after response\n+ *\n+ * @author Bernd Weymann - Initial contribution\n+ */\n+@NonNullByDefault\n+public class VehicleDiscovery extends AbstractDiscoveryService implements DiscoveryService, ThingHandlerService {\n+    private final Logger logger = LoggerFactory.getLogger(VehicleDiscovery.class);\n+    private static final int DISCOVERY_TIMEOUT = 10;\n+    private Optional<ConnectedDriveBridgeHandler> bridgeHandler = Optional.empty();\n+\n+    public VehicleDiscovery() {\n+        super(SUPPORTED_THING_SET, DISCOVERY_TIMEOUT, false);\n+    }\n+\n+    public void onResponse(VehiclesContainer container) {\n+        List<Vehicle> vehicles = container.vehicles;\n+        vehicles.forEach(vehicle -> {\n+            if (bridgeHandler.isPresent()) {\n+                ThingUID bridgeUID = bridgeHandler.get().getThing().getUID();\n+                // the DriveTrain field in the delivered json is defining the Vehicle Type\n+                String vehicleType = vehicle.driveTrain.toLowerCase();\n+                SUPPORTED_THING_SET.forEach(entry -> {\n+                    if (entry.getId().equals(vehicleType)) {\n+                        ThingUID uid = new ThingUID(entry, vehicle.vin, bridgeUID.getId());\n+                        Map<String, String> properties = new HashMap<>();\n+                        // Dealer\n+                        if (vehicle.dealer != null) {\n+                            properties.put(\"dealer\", vehicle.dealer.name);\n+                            properties.put(\"dealerAddress\", vehicle.dealer.street + \" \" + vehicle.dealer.country + \" \"\n+                                    + vehicle.dealer.postalCode + \" \" + vehicle.dealer.city);\n+                            properties.put(\"dealerPhone\", vehicle.dealer.phone);\n+                        }\n+\n+                        // Services & Support\n+                        properties.put(\"servicesActivated\", getObject(vehicle, Constants.ACTIVATED));\n+                        String servicesSupported = getObject(vehicle, Constants.SUPPORTED);\n+                        String servicesNotSupported = getObject(vehicle, Constants.NOT_SUPPORTED);\n+                        if (vehicle.statisticsAvailable) {\n+                            servicesSupported += Constants.STATISTICS;\n+                        } else {\n+                            servicesNotSupported += Constants.STATISTICS;\n+                        }\n+                        properties.put(Constants.SERVICES_SUPPORTED, servicesSupported);\n+                        properties.put(\"servicesNotSupported\", servicesNotSupported);\n+                        properties.put(\"supportBreakdownNumber\", vehicle.breakdownNumber);\n+\n+                        // Vehicle Properties\n+                        if (vehicle.supportedChargingModes != null) {\n+                            StringBuilder chargingModes = new StringBuilder();\n+                            vehicle.supportedChargingModes.forEach(e -> {\n+                                chargingModes.append(e).append(Constants.SPACE);\n+                            });\n+                            properties.put(\"vehicleChargeModes\", chargingModes.toString());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d5c01cbf22b288e86546da29f08d62c4d59189e5"}, "originalPosition": 98}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4ODMyMTY5NA==", "bodyText": "fixed", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r588321694", "createdAt": "2021-03-05T14:09:38Z", "author": {"login": "ntruchsess"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/discovery/VehicleDiscovery.java", "diffHunk": "@@ -0,0 +1,227 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bmwconnecteddrive.internal.discovery;\n+\n+import static org.openhab.binding.bmwconnecteddrive.internal.ConnectedDriveConstants.SUPPORTED_THING_SET;\n+\n+import java.lang.reflect.Field;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.bmwconnecteddrive.internal.ConnectedDriveConstants;\n+import org.openhab.binding.bmwconnecteddrive.internal.ConnectedDriveHandlerFactory;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.discovery.Vehicle;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.discovery.VehiclesContainer;\n+import org.openhab.binding.bmwconnecteddrive.internal.handler.ConnectedDriveBridgeHandler;\n+import org.openhab.binding.bmwconnecteddrive.internal.handler.VehicleHandler;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Constants;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Converter;\n+import org.openhab.core.config.core.Configuration;\n+import org.openhab.core.config.discovery.AbstractDiscoveryService;\n+import org.openhab.core.config.discovery.DiscoveryResultBuilder;\n+import org.openhab.core.config.discovery.DiscoveryService;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingUID;\n+import org.openhab.core.thing.binding.ThingHandler;\n+import org.openhab.core.thing.binding.ThingHandlerService;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link VehicleDiscovery} requests data from ConnectedDrive and is identifying the Vehicles after response\n+ *\n+ * @author Bernd Weymann - Initial contribution\n+ */\n+@NonNullByDefault\n+public class VehicleDiscovery extends AbstractDiscoveryService implements DiscoveryService, ThingHandlerService {\n+    private final Logger logger = LoggerFactory.getLogger(VehicleDiscovery.class);\n+    private static final int DISCOVERY_TIMEOUT = 10;\n+    private Optional<ConnectedDriveBridgeHandler> bridgeHandler = Optional.empty();\n+\n+    public VehicleDiscovery() {\n+        super(SUPPORTED_THING_SET, DISCOVERY_TIMEOUT, false);\n+    }\n+\n+    public void onResponse(VehiclesContainer container) {\n+        List<Vehicle> vehicles = container.vehicles;\n+        vehicles.forEach(vehicle -> {\n+            if (bridgeHandler.isPresent()) {\n+                ThingUID bridgeUID = bridgeHandler.get().getThing().getUID();\n+                // the DriveTrain field in the delivered json is defining the Vehicle Type\n+                String vehicleType = vehicle.driveTrain.toLowerCase();\n+                SUPPORTED_THING_SET.forEach(entry -> {\n+                    if (entry.getId().equals(vehicleType)) {\n+                        ThingUID uid = new ThingUID(entry, vehicle.vin, bridgeUID.getId());\n+                        Map<String, String> properties = new HashMap<>();\n+                        // Dealer\n+                        if (vehicle.dealer != null) {\n+                            properties.put(\"dealer\", vehicle.dealer.name);\n+                            properties.put(\"dealerAddress\", vehicle.dealer.street + \" \" + vehicle.dealer.country + \" \"\n+                                    + vehicle.dealer.postalCode + \" \" + vehicle.dealer.city);\n+                            properties.put(\"dealerPhone\", vehicle.dealer.phone);\n+                        }\n+\n+                        // Services & Support\n+                        properties.put(\"servicesActivated\", getObject(vehicle, Constants.ACTIVATED));\n+                        String servicesSupported = getObject(vehicle, Constants.SUPPORTED);\n+                        String servicesNotSupported = getObject(vehicle, Constants.NOT_SUPPORTED);\n+                        if (vehicle.statisticsAvailable) {\n+                            servicesSupported += Constants.STATISTICS;\n+                        } else {\n+                            servicesNotSupported += Constants.STATISTICS;\n+                        }\n+                        properties.put(Constants.SERVICES_SUPPORTED, servicesSupported);\n+                        properties.put(\"servicesNotSupported\", servicesNotSupported);\n+                        properties.put(\"supportBreakdownNumber\", vehicle.breakdownNumber);\n+\n+                        // Vehicle Properties\n+                        if (vehicle.supportedChargingModes != null) {\n+                            StringBuilder chargingModes = new StringBuilder();\n+                            vehicle.supportedChargingModes.forEach(e -> {\n+                                chargingModes.append(e).append(Constants.SPACE);\n+                            });\n+                            properties.put(\"vehicleChargeModes\", chargingModes.toString());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MTUyMjUzNA=="}, "originalCommit": {"oid": "d5c01cbf22b288e86546da29f08d62c4d59189e5"}, "originalPosition": 98}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzYwMTg3MTMwOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/resources/OH-INF/thing/vehicle-status-channel-types.xml", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0wN1QwMzowNToyNFrOIhC-kg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0wNVQxMToxNjo0NVrOIw-BQQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MTUyMjcwNg==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\t<label>Doors Locked </label>\n          \n          \n            \n            \t\t<label>Doors Locked</label>", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r571522706", "createdAt": "2021-02-07T03:05:24Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/resources/OH-INF/thing/vehicle-status-channel-types.xml", "diffHunk": "@@ -0,0 +1,38 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"bmwconnecteddrive\"\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\t<channel-type id=\"doors-channel\">\n+\t\t<item-type>String</item-type>\n+\t\t<label>Overall Door Status</label>\n+\t</channel-type>\n+\t<channel-type id=\"windows-channel\">\n+\t\t<item-type>String</item-type>\n+\t\t<label>Overall Window Status</label>\n+\t</channel-type>\n+\t<channel-type id=\"lock-channel\">\n+\t\t<item-type>String</item-type>\n+\t\t<label>Doors Locked </label>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d5c01cbf22b288e86546da29f08d62c4d59189e5"}, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4ODIxODY4OQ==", "bodyText": "fixed", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r588218689", "createdAt": "2021-03-05T11:16:45Z", "author": {"login": "ntruchsess"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/resources/OH-INF/thing/vehicle-status-channel-types.xml", "diffHunk": "@@ -0,0 +1,38 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"bmwconnecteddrive\"\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\t<channel-type id=\"doors-channel\">\n+\t\t<item-type>String</item-type>\n+\t\t<label>Overall Door Status</label>\n+\t</channel-type>\n+\t<channel-type id=\"windows-channel\">\n+\t\t<item-type>String</item-type>\n+\t\t<label>Overall Window Status</label>\n+\t</channel-type>\n+\t<channel-type id=\"lock-channel\">\n+\t\t<item-type>String</item-type>\n+\t\t<label>Doors Locked </label>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MTUyMjcwNg=="}, "originalCommit": {"oid": "d5c01cbf22b288e86546da29f08d62c4d59189e5"}, "originalPosition": 16}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzYwMTg3MTg0OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/resources/OH-INF/thing/vehicle-status-channel-types.xml", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0wN1QwMzowNTo1NVrOIhC-zA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0wNVQxMToxNzowM1rOIw-CCA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MTUyMjc2NA==", "bodyText": "The first letter of every word in a label must be capitalized.\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\t<label>Mileage till Next Service</label>\n          \n          \n            \n            \t\t<label>Mileage Till Next Service</label>", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r571522764", "createdAt": "2021-02-07T03:05:55Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/resources/OH-INF/thing/vehicle-status-channel-types.xml", "diffHunk": "@@ -0,0 +1,38 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"bmwconnecteddrive\"\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\t<channel-type id=\"doors-channel\">\n+\t\t<item-type>String</item-type>\n+\t\t<label>Overall Door Status</label>\n+\t</channel-type>\n+\t<channel-type id=\"windows-channel\">\n+\t\t<item-type>String</item-type>\n+\t\t<label>Overall Window Status</label>\n+\t</channel-type>\n+\t<channel-type id=\"lock-channel\">\n+\t\t<item-type>String</item-type>\n+\t\t<label>Doors Locked </label>\n+\t</channel-type>\n+\t<channel-type id=\"next-service-date-channel\">\n+\t\t<item-type>DateTime</item-type>\n+\t\t<label>Next Service Date</label>\n+\t</channel-type>\n+\t<channel-type id=\"next-service-mileage-channel\">\n+\t\t<item-type>Number:Length</item-type>\n+\t\t<label>Mileage till Next Service</label>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d5c01cbf22b288e86546da29f08d62c4d59189e5"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4ODIxODg4OA==", "bodyText": "fixed", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r588218888", "createdAt": "2021-03-05T11:17:03Z", "author": {"login": "ntruchsess"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/resources/OH-INF/thing/vehicle-status-channel-types.xml", "diffHunk": "@@ -0,0 +1,38 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"bmwconnecteddrive\"\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\t<channel-type id=\"doors-channel\">\n+\t\t<item-type>String</item-type>\n+\t\t<label>Overall Door Status</label>\n+\t</channel-type>\n+\t<channel-type id=\"windows-channel\">\n+\t\t<item-type>String</item-type>\n+\t\t<label>Overall Window Status</label>\n+\t</channel-type>\n+\t<channel-type id=\"lock-channel\">\n+\t\t<item-type>String</item-type>\n+\t\t<label>Doors Locked </label>\n+\t</channel-type>\n+\t<channel-type id=\"next-service-date-channel\">\n+\t\t<item-type>DateTime</item-type>\n+\t\t<label>Next Service Date</label>\n+\t</channel-type>\n+\t<channel-type id=\"next-service-mileage-channel\">\n+\t\t<item-type>Number:Length</item-type>\n+\t\t<label>Mileage till Next Service</label>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MTUyMjc2NA=="}, "originalCommit": {"oid": "d5c01cbf22b288e86546da29f08d62c4d59189e5"}, "originalPosition": 24}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzYwMTg4Mzg2OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/discovery/VehicleDiscovery.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0wN1QwMzoxMDo0MlrOIhDGkw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0wNVQxMToyMjo1NVrOIw-OHw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MTUyNDc1NQ==", "bodyText": "You can get all of the handlers by iterating through the handlers of the children of the bridge.\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                    List<VehicleHandler> l = ConnectedDriveHandlerFactory.getHandlerRegistry();\n          \n          \n            \n                                    l.forEach(handler -> {\n          \n          \n            \n                                        Thing vehicleThing = handler.getThing();\n          \n          \n            \n                                    bridgeHandler.get().getThing().getThings().forEach(vehicleThing ->", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r571524755", "createdAt": "2021-02-07T03:10:42Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/discovery/VehicleDiscovery.java", "diffHunk": "@@ -0,0 +1,227 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bmwconnecteddrive.internal.discovery;\n+\n+import static org.openhab.binding.bmwconnecteddrive.internal.ConnectedDriveConstants.SUPPORTED_THING_SET;\n+\n+import java.lang.reflect.Field;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.bmwconnecteddrive.internal.ConnectedDriveConstants;\n+import org.openhab.binding.bmwconnecteddrive.internal.ConnectedDriveHandlerFactory;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.discovery.Vehicle;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.discovery.VehiclesContainer;\n+import org.openhab.binding.bmwconnecteddrive.internal.handler.ConnectedDriveBridgeHandler;\n+import org.openhab.binding.bmwconnecteddrive.internal.handler.VehicleHandler;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Constants;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Converter;\n+import org.openhab.core.config.core.Configuration;\n+import org.openhab.core.config.discovery.AbstractDiscoveryService;\n+import org.openhab.core.config.discovery.DiscoveryResultBuilder;\n+import org.openhab.core.config.discovery.DiscoveryService;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingUID;\n+import org.openhab.core.thing.binding.ThingHandler;\n+import org.openhab.core.thing.binding.ThingHandlerService;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link VehicleDiscovery} requests data from ConnectedDrive and is identifying the Vehicles after response\n+ *\n+ * @author Bernd Weymann - Initial contribution\n+ */\n+@NonNullByDefault\n+public class VehicleDiscovery extends AbstractDiscoveryService implements DiscoveryService, ThingHandlerService {\n+    private final Logger logger = LoggerFactory.getLogger(VehicleDiscovery.class);\n+    private static final int DISCOVERY_TIMEOUT = 10;\n+    private Optional<ConnectedDriveBridgeHandler> bridgeHandler = Optional.empty();\n+\n+    public VehicleDiscovery() {\n+        super(SUPPORTED_THING_SET, DISCOVERY_TIMEOUT, false);\n+    }\n+\n+    public void onResponse(VehiclesContainer container) {\n+        List<Vehicle> vehicles = container.vehicles;\n+        vehicles.forEach(vehicle -> {\n+            if (bridgeHandler.isPresent()) {\n+                ThingUID bridgeUID = bridgeHandler.get().getThing().getUID();\n+                // the DriveTrain field in the delivered json is defining the Vehicle Type\n+                String vehicleType = vehicle.driveTrain.toLowerCase();\n+                SUPPORTED_THING_SET.forEach(entry -> {\n+                    if (entry.getId().equals(vehicleType)) {\n+                        ThingUID uid = new ThingUID(entry, vehicle.vin, bridgeUID.getId());\n+                        Map<String, String> properties = new HashMap<>();\n+                        // Dealer\n+                        if (vehicle.dealer != null) {\n+                            properties.put(\"dealer\", vehicle.dealer.name);\n+                            properties.put(\"dealerAddress\", vehicle.dealer.street + \" \" + vehicle.dealer.country + \" \"\n+                                    + vehicle.dealer.postalCode + \" \" + vehicle.dealer.city);\n+                            properties.put(\"dealerPhone\", vehicle.dealer.phone);\n+                        }\n+\n+                        // Services & Support\n+                        properties.put(\"servicesActivated\", getObject(vehicle, Constants.ACTIVATED));\n+                        String servicesSupported = getObject(vehicle, Constants.SUPPORTED);\n+                        String servicesNotSupported = getObject(vehicle, Constants.NOT_SUPPORTED);\n+                        if (vehicle.statisticsAvailable) {\n+                            servicesSupported += Constants.STATISTICS;\n+                        } else {\n+                            servicesNotSupported += Constants.STATISTICS;\n+                        }\n+                        properties.put(Constants.SERVICES_SUPPORTED, servicesSupported);\n+                        properties.put(\"servicesNotSupported\", servicesNotSupported);\n+                        properties.put(\"supportBreakdownNumber\", vehicle.breakdownNumber);\n+\n+                        // Vehicle Properties\n+                        if (vehicle.supportedChargingModes != null) {\n+                            StringBuilder chargingModes = new StringBuilder();\n+                            vehicle.supportedChargingModes.forEach(e -> {\n+                                chargingModes.append(e).append(Constants.SPACE);\n+                            });\n+                            properties.put(\"vehicleChargeModes\", chargingModes.toString());\n+                        }\n+                        if (vehicle.hasAlarmSystem) {\n+                            properties.put(\"vehicleAlarmSystem\", \"Available\");\n+                        } else {\n+                            properties.put(\"vehicleAlarmSystem\", \"Not Available\");\n+                        }\n+                        properties.put(\"vehicleBrand\", vehicle.brand);\n+                        properties.put(\"vehicleBodytype\", vehicle.bodytype);\n+                        properties.put(\"vehicleColor\", vehicle.color);\n+                        properties.put(\"vehicleConstructionYear\", Short.toString(vehicle.yearOfConstruction));\n+                        properties.put(\"vehicleDriveTrain\", vehicle.driveTrain);\n+                        properties.put(\"vehicleModel\", vehicle.model);\n+                        if (vehicle.chargingControl != null) {\n+                            properties.put(\"vehicleChargeControl\", Converter.toTitleCase(vehicle.model));\n+                        }\n+\n+                        // Check now if a thing with the same VIN exists\n+                        final AtomicBoolean foundVehicle = new AtomicBoolean(false);\n+                        List<VehicleHandler> l = ConnectedDriveHandlerFactory.getHandlerRegistry();\n+                        l.forEach(handler -> {\n+                            Thing vehicleThing = handler.getThing();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d5c01cbf22b288e86546da29f08d62c4d59189e5"}, "originalPosition": 119}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4ODIyMTk4Mw==", "bodyText": "fixed. Replaced by 'bridgeHandler.ifPresent(...' at begin of method. All other code in method is pointless without valid bridgeHandler", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r588221983", "createdAt": "2021-03-05T11:22:55Z", "author": {"login": "ntruchsess"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/discovery/VehicleDiscovery.java", "diffHunk": "@@ -0,0 +1,227 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bmwconnecteddrive.internal.discovery;\n+\n+import static org.openhab.binding.bmwconnecteddrive.internal.ConnectedDriveConstants.SUPPORTED_THING_SET;\n+\n+import java.lang.reflect.Field;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.bmwconnecteddrive.internal.ConnectedDriveConstants;\n+import org.openhab.binding.bmwconnecteddrive.internal.ConnectedDriveHandlerFactory;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.discovery.Vehicle;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.discovery.VehiclesContainer;\n+import org.openhab.binding.bmwconnecteddrive.internal.handler.ConnectedDriveBridgeHandler;\n+import org.openhab.binding.bmwconnecteddrive.internal.handler.VehicleHandler;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Constants;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Converter;\n+import org.openhab.core.config.core.Configuration;\n+import org.openhab.core.config.discovery.AbstractDiscoveryService;\n+import org.openhab.core.config.discovery.DiscoveryResultBuilder;\n+import org.openhab.core.config.discovery.DiscoveryService;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingUID;\n+import org.openhab.core.thing.binding.ThingHandler;\n+import org.openhab.core.thing.binding.ThingHandlerService;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link VehicleDiscovery} requests data from ConnectedDrive and is identifying the Vehicles after response\n+ *\n+ * @author Bernd Weymann - Initial contribution\n+ */\n+@NonNullByDefault\n+public class VehicleDiscovery extends AbstractDiscoveryService implements DiscoveryService, ThingHandlerService {\n+    private final Logger logger = LoggerFactory.getLogger(VehicleDiscovery.class);\n+    private static final int DISCOVERY_TIMEOUT = 10;\n+    private Optional<ConnectedDriveBridgeHandler> bridgeHandler = Optional.empty();\n+\n+    public VehicleDiscovery() {\n+        super(SUPPORTED_THING_SET, DISCOVERY_TIMEOUT, false);\n+    }\n+\n+    public void onResponse(VehiclesContainer container) {\n+        List<Vehicle> vehicles = container.vehicles;\n+        vehicles.forEach(vehicle -> {\n+            if (bridgeHandler.isPresent()) {\n+                ThingUID bridgeUID = bridgeHandler.get().getThing().getUID();\n+                // the DriveTrain field in the delivered json is defining the Vehicle Type\n+                String vehicleType = vehicle.driveTrain.toLowerCase();\n+                SUPPORTED_THING_SET.forEach(entry -> {\n+                    if (entry.getId().equals(vehicleType)) {\n+                        ThingUID uid = new ThingUID(entry, vehicle.vin, bridgeUID.getId());\n+                        Map<String, String> properties = new HashMap<>();\n+                        // Dealer\n+                        if (vehicle.dealer != null) {\n+                            properties.put(\"dealer\", vehicle.dealer.name);\n+                            properties.put(\"dealerAddress\", vehicle.dealer.street + \" \" + vehicle.dealer.country + \" \"\n+                                    + vehicle.dealer.postalCode + \" \" + vehicle.dealer.city);\n+                            properties.put(\"dealerPhone\", vehicle.dealer.phone);\n+                        }\n+\n+                        // Services & Support\n+                        properties.put(\"servicesActivated\", getObject(vehicle, Constants.ACTIVATED));\n+                        String servicesSupported = getObject(vehicle, Constants.SUPPORTED);\n+                        String servicesNotSupported = getObject(vehicle, Constants.NOT_SUPPORTED);\n+                        if (vehicle.statisticsAvailable) {\n+                            servicesSupported += Constants.STATISTICS;\n+                        } else {\n+                            servicesNotSupported += Constants.STATISTICS;\n+                        }\n+                        properties.put(Constants.SERVICES_SUPPORTED, servicesSupported);\n+                        properties.put(\"servicesNotSupported\", servicesNotSupported);\n+                        properties.put(\"supportBreakdownNumber\", vehicle.breakdownNumber);\n+\n+                        // Vehicle Properties\n+                        if (vehicle.supportedChargingModes != null) {\n+                            StringBuilder chargingModes = new StringBuilder();\n+                            vehicle.supportedChargingModes.forEach(e -> {\n+                                chargingModes.append(e).append(Constants.SPACE);\n+                            });\n+                            properties.put(\"vehicleChargeModes\", chargingModes.toString());\n+                        }\n+                        if (vehicle.hasAlarmSystem) {\n+                            properties.put(\"vehicleAlarmSystem\", \"Available\");\n+                        } else {\n+                            properties.put(\"vehicleAlarmSystem\", \"Not Available\");\n+                        }\n+                        properties.put(\"vehicleBrand\", vehicle.brand);\n+                        properties.put(\"vehicleBodytype\", vehicle.bodytype);\n+                        properties.put(\"vehicleColor\", vehicle.color);\n+                        properties.put(\"vehicleConstructionYear\", Short.toString(vehicle.yearOfConstruction));\n+                        properties.put(\"vehicleDriveTrain\", vehicle.driveTrain);\n+                        properties.put(\"vehicleModel\", vehicle.model);\n+                        if (vehicle.chargingControl != null) {\n+                            properties.put(\"vehicleChargeControl\", Converter.toTitleCase(vehicle.model));\n+                        }\n+\n+                        // Check now if a thing with the same VIN exists\n+                        final AtomicBoolean foundVehicle = new AtomicBoolean(false);\n+                        List<VehicleHandler> l = ConnectedDriveHandlerFactory.getHandlerRegistry();\n+                        l.forEach(handler -> {\n+                            Thing vehicleThing = handler.getThing();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MTUyNDc1NQ=="}, "originalCommit": {"oid": "d5c01cbf22b288e86546da29f08d62c4d59189e5"}, "originalPosition": 119}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzYwMTg4NTY2OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/dto/Destination.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0wN1QwMzoxMzo1OFrOIhDHbQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0wNlQxNzo1MzowMVrOIxoPcA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MTUyNDk3Mw==", "bodyText": "I feel it should be up to the callers of getAddress() and getCoordinates() to cache these values, not this class. Is there any performance reason to cache these values in this class instead?", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r571524973", "createdAt": "2021-02-07T03:13:58Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/dto/Destination.java", "diffHunk": "@@ -0,0 +1,69 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bmwconnecteddrive.internal.dto;\n+\n+import static org.openhab.binding.bmwconnecteddrive.internal.utils.Constants.*;\n+\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Constants;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Converter;\n+\n+/**\n+ * The {@link Destination} Data Transfer Object\n+ *\n+ * @author Bernd Weymann - Initial contribution\n+ */\n+public class Destination {\n+    public float lat;\n+    public float lon;\n+    public String country;\n+    public String city;\n+    public String street;\n+    public String streetNumber;\n+    public String type;\n+    public String createdAt;\n+\n+    private String address = null;\n+    private String coordinates = null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d5c01cbf22b288e86546da29f08d62c4d59189e5"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4ODkxMDQ0OA==", "bodyText": "Not for performance reasons. The Handler is already quite packed and I want to provide easy calls which can be directly used to update the corresponding channles. An extra Wrapper for this small functionality isn't really needed from my point of view so I placed it here.\nI removed the cache variables because it doesn't provide a performance benefit.", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r588910448", "createdAt": "2021-03-06T17:53:01Z", "author": {"login": "weymann"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/dto/Destination.java", "diffHunk": "@@ -0,0 +1,69 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bmwconnecteddrive.internal.dto;\n+\n+import static org.openhab.binding.bmwconnecteddrive.internal.utils.Constants.*;\n+\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Constants;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Converter;\n+\n+/**\n+ * The {@link Destination} Data Transfer Object\n+ *\n+ * @author Bernd Weymann - Initial contribution\n+ */\n+public class Destination {\n+    public float lat;\n+    public float lon;\n+    public String country;\n+    public String city;\n+    public String street;\n+    public String streetNumber;\n+    public String type;\n+    public String createdAt;\n+\n+    private String address = null;\n+    private String coordinates = null;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MTUyNDk3Mw=="}, "originalCommit": {"oid": "d5c01cbf22b288e86546da29f08d62c4d59189e5"}, "originalPosition": 36}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzYwMTg4NzkwOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/dto/charge/Timer.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0wN1QwMzoxNTo1MlrOIhDIpA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0wNVQxMToyNjoyOVrOIw-VXg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MTUyNTI4NA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        if (days.length() == 0) {\n          \n          \n            \n                            days.append(Constants.DAYS.get(entry));\n          \n          \n            \n                        } else {\n          \n          \n            \n                            days.append(Constants.COMMA).append(Constants.DAYS.get(entry));\n          \n          \n            \n                        }\n          \n          \n            \n                        if (days.length() != 0){\n          \n          \n            \n                            days.append(Constants.COMMA);\n          \n          \n            \n                        }\n          \n          \n            \n                        days.append(Constants.DAYS.get(entry));", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r571525284", "createdAt": "2021-02-07T03:15:52Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/dto/charge/Timer.java", "diffHunk": "@@ -0,0 +1,51 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bmwconnecteddrive.internal.dto.charge;\n+\n+import java.util.List;\n+\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Constants;\n+\n+/**\n+ * The {@link Timer} Data Transfer Object\n+ *\n+ * @author Bernd Weymann - Initial contribution\n+ */\n+public class Timer {\n+    public String departureTime;// \": \"05:00\",\n+    public boolean timerEnabled;// \": false,\n+    public List<String> weekdays;\n+\n+    /**\n+     * \"MONDAY\",\n+     * \"TUESDAY\",\n+     * \"WEDNESDAY\",\n+     * \"THURSDAY\",\n+     * \"FRIDAY\"\n+     * ] '\n+     */\n+    public String getDays() {\n+        if (weekdays == null) {\n+            return Constants.UNDEF;\n+        }\n+        StringBuilder days = new StringBuilder();\n+        weekdays.forEach(entry -> {\n+            if (days.length() == 0) {\n+                days.append(Constants.DAYS.get(entry));\n+            } else {\n+                days.append(Constants.COMMA).append(Constants.DAYS.get(entry));\n+            }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d5c01cbf22b288e86546da29f08d62c4d59189e5"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4ODIyMzgzOA==", "bodyText": "refactored fixing this issue. See ChargeProfileUtils.formatDays().", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r588223838", "createdAt": "2021-03-05T11:26:29Z", "author": {"login": "ntruchsess"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/dto/charge/Timer.java", "diffHunk": "@@ -0,0 +1,51 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bmwconnecteddrive.internal.dto.charge;\n+\n+import java.util.List;\n+\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Constants;\n+\n+/**\n+ * The {@link Timer} Data Transfer Object\n+ *\n+ * @author Bernd Weymann - Initial contribution\n+ */\n+public class Timer {\n+    public String departureTime;// \": \"05:00\",\n+    public boolean timerEnabled;// \": false,\n+    public List<String> weekdays;\n+\n+    /**\n+     * \"MONDAY\",\n+     * \"TUESDAY\",\n+     * \"WEDNESDAY\",\n+     * \"THURSDAY\",\n+     * \"FRIDAY\"\n+     * ] '\n+     */\n+    public String getDays() {\n+        if (weekdays == null) {\n+            return Constants.UNDEF;\n+        }\n+        StringBuilder days = new StringBuilder();\n+        weekdays.forEach(entry -> {\n+            if (days.length() == 0) {\n+                days.append(Constants.DAYS.get(entry));\n+            } else {\n+                days.append(Constants.COMMA).append(Constants.DAYS.get(entry));\n+            }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MTUyNTI4NA=="}, "originalCommit": {"oid": "d5c01cbf22b288e86546da29f08d62c4d59189e5"}, "originalPosition": 47}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzYwMTg5MTYwOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/dto/status/Position.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0wN1QwMzoxODo0MFrOIhDKeg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0wNlQxNzo1NjoyMVrOIxoQ1g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MTUyNTc1NA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    return new StringBuilder(Float.toString(lat)).append(Constants.COMMA).append(Float.toString(lon)).toString();\n          \n          \n            \n                    return getCoordinates();", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r571525754", "createdAt": "2021-02-07T03:18:40Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/dto/status/Position.java", "diffHunk": "@@ -0,0 +1,36 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bmwconnecteddrive.internal.dto.status;\n+\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Constants;\n+\n+/**\n+ * The {@link Position} Data Transfer Object\n+ *\n+ * @author Bernd Weymann - Initial contribution\n+ */\n+public class Position {\n+    public float lat;// \": 46.55605,\n+    public float lon;// \": 10.495669,\n+    public int heading;// \": 219,\n+    public String status;// \": \"OK\"\n+\n+    public String getCoordinates() {\n+        return new StringBuilder(Float.toString(lat)).append(Constants.COMMA).append(Float.toString(lon)).toString();\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return new StringBuilder(Float.toString(lat)).append(Constants.COMMA).append(Float.toString(lon)).toString();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d5c01cbf22b288e86546da29f08d62c4d59189e5"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4ODkxMDgwNg==", "bodyText": "OMG, sure!", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r588910806", "createdAt": "2021-03-06T17:56:21Z", "author": {"login": "weymann"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/dto/status/Position.java", "diffHunk": "@@ -0,0 +1,36 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bmwconnecteddrive.internal.dto.status;\n+\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Constants;\n+\n+/**\n+ * The {@link Position} Data Transfer Object\n+ *\n+ * @author Bernd Weymann - Initial contribution\n+ */\n+public class Position {\n+    public float lat;// \": 46.55605,\n+    public float lon;// \": 10.495669,\n+    public int heading;// \": 219,\n+    public String status;// \": \"OK\"\n+\n+    public String getCoordinates() {\n+        return new StringBuilder(Float.toString(lat)).append(Constants.COMMA).append(Float.toString(lon)).toString();\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return new StringBuilder(Float.toString(lat)).append(Constants.COMMA).append(Float.toString(lon)).toString();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MTUyNTc1NA=="}, "originalCommit": {"oid": "d5c01cbf22b288e86546da29f08d62c4d59189e5"}, "originalPosition": 34}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzYwMTg5MzQyOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/ConnectedDriveBridgeHandler.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0wN1QwMzoyMDo0OFrOIhDLQg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0wNVQxMToyNzo0M1rOIw-X3w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MTUyNTk1NA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    if (initializerJob.isPresent()) {\n          \n          \n            \n                        initializerJob.get().cancel(true);\n          \n          \n            \n                    }\n          \n          \n            \n                    initializerJob.ifPresent(job -> job.cancel(true));", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r571525954", "createdAt": "2021-02-07T03:20:48Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/ConnectedDriveBridgeHandler.java", "diffHunk": "@@ -0,0 +1,196 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bmwconnecteddrive.internal.handler;\n+\n+import static org.openhab.binding.bmwconnecteddrive.internal.utils.Constants.ANONYMOUS;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Optional;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.binding.bmwconnecteddrive.internal.ConnectedDriveConfiguration;\n+import org.openhab.binding.bmwconnecteddrive.internal.discovery.VehicleDiscovery;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.NetworkError;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.discovery.Dealer;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.discovery.VehiclesContainer;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Constants;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Converter;\n+import org.openhab.core.io.net.http.HttpClientFactory;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseBridgeHandler;\n+import org.openhab.core.thing.binding.ThingHandlerService;\n+import org.openhab.core.types.Command;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link ConnectedDriveBridgeHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Bernd Weymann - Initial contribution\n+ */\n+@NonNullByDefault\n+public class ConnectedDriveBridgeHandler extends BaseBridgeHandler implements StringResponseCallback {\n+    private final Logger logger = LoggerFactory.getLogger(ConnectedDriveBridgeHandler.class);\n+    private HttpClientFactory httpClientFactory;\n+    private Optional<VehicleDiscovery> discoveryService = Optional.empty();\n+    private Optional<ConnectedDriveProxy> proxy = Optional.empty();\n+    private Optional<ConnectedDriveConfiguration> configuration = Optional.empty();\n+    private Optional<ScheduledFuture<?>> initializerJob = Optional.empty();\n+    private Optional<String> troubleshootFingerprint = Optional.empty();\n+\n+    public ConnectedDriveBridgeHandler(Bridge bridge, HttpClientFactory hcf) {\n+        super(bridge);\n+        httpClientFactory = hcf;\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        // no commands available\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        troubleshootFingerprint = Optional.empty();\n+        updateStatus(ThingStatus.UNKNOWN);\n+        configuration = Optional.of(getConfigAs(ConnectedDriveConfiguration.class));\n+        if (configuration.isPresent()) {\n+            proxy = Optional.of(new ConnectedDriveProxy(httpClientFactory, configuration.get()));\n+            // give the system some time to create all predefined Vehicles\n+            initializerJob = Optional.of(scheduler.schedule(this::requestVehicles, 5, TimeUnit.SECONDS));\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR);\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        if (initializerJob.isPresent()) {\n+            initializerJob.get().cancel(true);\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d5c01cbf22b288e86546da29f08d62c4d59189e5"}, "originalPosition": 86}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4ODIyNDQ3OQ==", "bodyText": "fixed", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r588224479", "createdAt": "2021-03-05T11:27:43Z", "author": {"login": "ntruchsess"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/ConnectedDriveBridgeHandler.java", "diffHunk": "@@ -0,0 +1,196 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bmwconnecteddrive.internal.handler;\n+\n+import static org.openhab.binding.bmwconnecteddrive.internal.utils.Constants.ANONYMOUS;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Optional;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.binding.bmwconnecteddrive.internal.ConnectedDriveConfiguration;\n+import org.openhab.binding.bmwconnecteddrive.internal.discovery.VehicleDiscovery;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.NetworkError;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.discovery.Dealer;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.discovery.VehiclesContainer;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Constants;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Converter;\n+import org.openhab.core.io.net.http.HttpClientFactory;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseBridgeHandler;\n+import org.openhab.core.thing.binding.ThingHandlerService;\n+import org.openhab.core.types.Command;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link ConnectedDriveBridgeHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Bernd Weymann - Initial contribution\n+ */\n+@NonNullByDefault\n+public class ConnectedDriveBridgeHandler extends BaseBridgeHandler implements StringResponseCallback {\n+    private final Logger logger = LoggerFactory.getLogger(ConnectedDriveBridgeHandler.class);\n+    private HttpClientFactory httpClientFactory;\n+    private Optional<VehicleDiscovery> discoveryService = Optional.empty();\n+    private Optional<ConnectedDriveProxy> proxy = Optional.empty();\n+    private Optional<ConnectedDriveConfiguration> configuration = Optional.empty();\n+    private Optional<ScheduledFuture<?>> initializerJob = Optional.empty();\n+    private Optional<String> troubleshootFingerprint = Optional.empty();\n+\n+    public ConnectedDriveBridgeHandler(Bridge bridge, HttpClientFactory hcf) {\n+        super(bridge);\n+        httpClientFactory = hcf;\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        // no commands available\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        troubleshootFingerprint = Optional.empty();\n+        updateStatus(ThingStatus.UNKNOWN);\n+        configuration = Optional.of(getConfigAs(ConnectedDriveConfiguration.class));\n+        if (configuration.isPresent()) {\n+            proxy = Optional.of(new ConnectedDriveProxy(httpClientFactory, configuration.get()));\n+            // give the system some time to create all predefined Vehicles\n+            initializerJob = Optional.of(scheduler.schedule(this::requestVehicles, 5, TimeUnit.SECONDS));\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR);\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        if (initializerJob.isPresent()) {\n+            initializerJob.get().cancel(true);\n+        }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MTUyNTk1NA=="}, "originalCommit": {"oid": "d5c01cbf22b288e86546da29f08d62c4d59189e5"}, "originalPosition": 86}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzYwMTg5MzgxOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/ConnectedDriveBridgeHandler.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0wN1QwMzoyMToyN1rOIhDLcA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0wNVQxMToyNzo1NlrOIw-YeA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MTUyNjAwMA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    if (proxy.isPresent()) {\n          \n          \n            \n                        proxy.get().requestVehicles(this);\n          \n          \n            \n                    }\n          \n          \n            \n                    proxy.ifPresent(prox -> prox.requestVehicles(this));", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r571526000", "createdAt": "2021-02-07T03:21:27Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/ConnectedDriveBridgeHandler.java", "diffHunk": "@@ -0,0 +1,196 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bmwconnecteddrive.internal.handler;\n+\n+import static org.openhab.binding.bmwconnecteddrive.internal.utils.Constants.ANONYMOUS;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Optional;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.binding.bmwconnecteddrive.internal.ConnectedDriveConfiguration;\n+import org.openhab.binding.bmwconnecteddrive.internal.discovery.VehicleDiscovery;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.NetworkError;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.discovery.Dealer;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.discovery.VehiclesContainer;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Constants;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Converter;\n+import org.openhab.core.io.net.http.HttpClientFactory;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseBridgeHandler;\n+import org.openhab.core.thing.binding.ThingHandlerService;\n+import org.openhab.core.types.Command;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link ConnectedDriveBridgeHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Bernd Weymann - Initial contribution\n+ */\n+@NonNullByDefault\n+public class ConnectedDriveBridgeHandler extends BaseBridgeHandler implements StringResponseCallback {\n+    private final Logger logger = LoggerFactory.getLogger(ConnectedDriveBridgeHandler.class);\n+    private HttpClientFactory httpClientFactory;\n+    private Optional<VehicleDiscovery> discoveryService = Optional.empty();\n+    private Optional<ConnectedDriveProxy> proxy = Optional.empty();\n+    private Optional<ConnectedDriveConfiguration> configuration = Optional.empty();\n+    private Optional<ScheduledFuture<?>> initializerJob = Optional.empty();\n+    private Optional<String> troubleshootFingerprint = Optional.empty();\n+\n+    public ConnectedDriveBridgeHandler(Bridge bridge, HttpClientFactory hcf) {\n+        super(bridge);\n+        httpClientFactory = hcf;\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        // no commands available\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        troubleshootFingerprint = Optional.empty();\n+        updateStatus(ThingStatus.UNKNOWN);\n+        configuration = Optional.of(getConfigAs(ConnectedDriveConfiguration.class));\n+        if (configuration.isPresent()) {\n+            proxy = Optional.of(new ConnectedDriveProxy(httpClientFactory, configuration.get()));\n+            // give the system some time to create all predefined Vehicles\n+            initializerJob = Optional.of(scheduler.schedule(this::requestVehicles, 5, TimeUnit.SECONDS));\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR);\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        if (initializerJob.isPresent()) {\n+            initializerJob.get().cancel(true);\n+        }\n+    }\n+\n+    public void requestVehicles() {\n+        if (proxy.isPresent()) {\n+            proxy.get().requestVehicles(this);\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d5c01cbf22b288e86546da29f08d62c4d59189e5"}, "originalPosition": 92}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4ODIyNDYzMg==", "bodyText": "fixed", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r588224632", "createdAt": "2021-03-05T11:27:56Z", "author": {"login": "ntruchsess"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/ConnectedDriveBridgeHandler.java", "diffHunk": "@@ -0,0 +1,196 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bmwconnecteddrive.internal.handler;\n+\n+import static org.openhab.binding.bmwconnecteddrive.internal.utils.Constants.ANONYMOUS;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Optional;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.binding.bmwconnecteddrive.internal.ConnectedDriveConfiguration;\n+import org.openhab.binding.bmwconnecteddrive.internal.discovery.VehicleDiscovery;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.NetworkError;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.discovery.Dealer;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.discovery.VehiclesContainer;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Constants;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Converter;\n+import org.openhab.core.io.net.http.HttpClientFactory;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseBridgeHandler;\n+import org.openhab.core.thing.binding.ThingHandlerService;\n+import org.openhab.core.types.Command;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link ConnectedDriveBridgeHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Bernd Weymann - Initial contribution\n+ */\n+@NonNullByDefault\n+public class ConnectedDriveBridgeHandler extends BaseBridgeHandler implements StringResponseCallback {\n+    private final Logger logger = LoggerFactory.getLogger(ConnectedDriveBridgeHandler.class);\n+    private HttpClientFactory httpClientFactory;\n+    private Optional<VehicleDiscovery> discoveryService = Optional.empty();\n+    private Optional<ConnectedDriveProxy> proxy = Optional.empty();\n+    private Optional<ConnectedDriveConfiguration> configuration = Optional.empty();\n+    private Optional<ScheduledFuture<?>> initializerJob = Optional.empty();\n+    private Optional<String> troubleshootFingerprint = Optional.empty();\n+\n+    public ConnectedDriveBridgeHandler(Bridge bridge, HttpClientFactory hcf) {\n+        super(bridge);\n+        httpClientFactory = hcf;\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        // no commands available\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        troubleshootFingerprint = Optional.empty();\n+        updateStatus(ThingStatus.UNKNOWN);\n+        configuration = Optional.of(getConfigAs(ConnectedDriveConfiguration.class));\n+        if (configuration.isPresent()) {\n+            proxy = Optional.of(new ConnectedDriveProxy(httpClientFactory, configuration.get()));\n+            // give the system some time to create all predefined Vehicles\n+            initializerJob = Optional.of(scheduler.schedule(this::requestVehicles, 5, TimeUnit.SECONDS));\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR);\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        if (initializerJob.isPresent()) {\n+            initializerJob.get().cancel(true);\n+        }\n+    }\n+\n+    public void requestVehicles() {\n+        if (proxy.isPresent()) {\n+            proxy.get().requestVehicles(this);\n+        }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MTUyNjAwMA=="}, "originalCommit": {"oid": "d5c01cbf22b288e86546da29f08d62c4d59189e5"}, "originalPosition": 92}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzYwMTkxOTAxOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/ConnectedDriveBridgeHandler.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0wN1QwMzo0NDoyN1rOIhDZ_w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0wNlQyMDowNDoxNlrOIxpHSg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MTUyOTcyNw==", "bodyText": "You should catch the parsing exception that is thrown by gson.", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r571529727", "createdAt": "2021-02-07T03:44:27Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/ConnectedDriveBridgeHandler.java", "diffHunk": "@@ -0,0 +1,196 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bmwconnecteddrive.internal.handler;\n+\n+import static org.openhab.binding.bmwconnecteddrive.internal.utils.Constants.ANONYMOUS;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Optional;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.binding.bmwconnecteddrive.internal.ConnectedDriveConfiguration;\n+import org.openhab.binding.bmwconnecteddrive.internal.discovery.VehicleDiscovery;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.NetworkError;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.discovery.Dealer;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.discovery.VehiclesContainer;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Constants;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Converter;\n+import org.openhab.core.io.net.http.HttpClientFactory;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseBridgeHandler;\n+import org.openhab.core.thing.binding.ThingHandlerService;\n+import org.openhab.core.types.Command;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link ConnectedDriveBridgeHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Bernd Weymann - Initial contribution\n+ */\n+@NonNullByDefault\n+public class ConnectedDriveBridgeHandler extends BaseBridgeHandler implements StringResponseCallback {\n+    private final Logger logger = LoggerFactory.getLogger(ConnectedDriveBridgeHandler.class);\n+    private HttpClientFactory httpClientFactory;\n+    private Optional<VehicleDiscovery> discoveryService = Optional.empty();\n+    private Optional<ConnectedDriveProxy> proxy = Optional.empty();\n+    private Optional<ConnectedDriveConfiguration> configuration = Optional.empty();\n+    private Optional<ScheduledFuture<?>> initializerJob = Optional.empty();\n+    private Optional<String> troubleshootFingerprint = Optional.empty();\n+\n+    public ConnectedDriveBridgeHandler(Bridge bridge, HttpClientFactory hcf) {\n+        super(bridge);\n+        httpClientFactory = hcf;\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        // no commands available\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        troubleshootFingerprint = Optional.empty();\n+        updateStatus(ThingStatus.UNKNOWN);\n+        configuration = Optional.of(getConfigAs(ConnectedDriveConfiguration.class));\n+        if (configuration.isPresent()) {\n+            proxy = Optional.of(new ConnectedDriveProxy(httpClientFactory, configuration.get()));\n+            // give the system some time to create all predefined Vehicles\n+            initializerJob = Optional.of(scheduler.schedule(this::requestVehicles, 5, TimeUnit.SECONDS));\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR);\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        if (initializerJob.isPresent()) {\n+            initializerJob.get().cancel(true);\n+        }\n+    }\n+\n+    public void requestVehicles() {\n+        if (proxy.isPresent()) {\n+            proxy.get().requestVehicles(this);\n+        }\n+    }\n+\n+    public String getDiscoveryFingerprint() {\n+        if (troubleshootFingerprint.isPresent()) {\n+            VehiclesContainer container = Converter.getGson().fromJson(troubleshootFingerprint.get(),\n+                    VehiclesContainer.class);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d5c01cbf22b288e86546da29f08d62c4d59189e5"}, "originalPosition": 98}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4ODkyNDc0Ng==", "bodyText": "Done for all occurrences", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r588924746", "createdAt": "2021-03-06T20:04:16Z", "author": {"login": "weymann"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/ConnectedDriveBridgeHandler.java", "diffHunk": "@@ -0,0 +1,196 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bmwconnecteddrive.internal.handler;\n+\n+import static org.openhab.binding.bmwconnecteddrive.internal.utils.Constants.ANONYMOUS;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Optional;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.binding.bmwconnecteddrive.internal.ConnectedDriveConfiguration;\n+import org.openhab.binding.bmwconnecteddrive.internal.discovery.VehicleDiscovery;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.NetworkError;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.discovery.Dealer;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.discovery.VehiclesContainer;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Constants;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Converter;\n+import org.openhab.core.io.net.http.HttpClientFactory;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseBridgeHandler;\n+import org.openhab.core.thing.binding.ThingHandlerService;\n+import org.openhab.core.types.Command;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link ConnectedDriveBridgeHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Bernd Weymann - Initial contribution\n+ */\n+@NonNullByDefault\n+public class ConnectedDriveBridgeHandler extends BaseBridgeHandler implements StringResponseCallback {\n+    private final Logger logger = LoggerFactory.getLogger(ConnectedDriveBridgeHandler.class);\n+    private HttpClientFactory httpClientFactory;\n+    private Optional<VehicleDiscovery> discoveryService = Optional.empty();\n+    private Optional<ConnectedDriveProxy> proxy = Optional.empty();\n+    private Optional<ConnectedDriveConfiguration> configuration = Optional.empty();\n+    private Optional<ScheduledFuture<?>> initializerJob = Optional.empty();\n+    private Optional<String> troubleshootFingerprint = Optional.empty();\n+\n+    public ConnectedDriveBridgeHandler(Bridge bridge, HttpClientFactory hcf) {\n+        super(bridge);\n+        httpClientFactory = hcf;\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        // no commands available\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        troubleshootFingerprint = Optional.empty();\n+        updateStatus(ThingStatus.UNKNOWN);\n+        configuration = Optional.of(getConfigAs(ConnectedDriveConfiguration.class));\n+        if (configuration.isPresent()) {\n+            proxy = Optional.of(new ConnectedDriveProxy(httpClientFactory, configuration.get()));\n+            // give the system some time to create all predefined Vehicles\n+            initializerJob = Optional.of(scheduler.schedule(this::requestVehicles, 5, TimeUnit.SECONDS));\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR);\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        if (initializerJob.isPresent()) {\n+            initializerJob.get().cancel(true);\n+        }\n+    }\n+\n+    public void requestVehicles() {\n+        if (proxy.isPresent()) {\n+            proxy.get().requestVehicles(this);\n+        }\n+    }\n+\n+    public String getDiscoveryFingerprint() {\n+        if (troubleshootFingerprint.isPresent()) {\n+            VehiclesContainer container = Converter.getGson().fromJson(troubleshootFingerprint.get(),\n+                    VehiclesContainer.class);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MTUyOTcyNw=="}, "originalCommit": {"oid": "d5c01cbf22b288e86546da29f08d62c4d59189e5"}, "originalPosition": 98}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzYwMTkyMTM1OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/ConnectedDriveProxy.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0wN1QwMzo0NzowOFrOIhDbBw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0wNVQxMzo1MjoxMlrOIxDm_w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MTUyOTk5MQ==", "bodyText": "Why are you manually writing the trace when you can include the entire exception as part of the logged message?\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        logger.debug(\"Authorization exception: {}\", e.getMessage());\n          \n          \n            \n                        StackTraceElement[] trace = e.getStackTrace();\n          \n          \n            \n                        for (int i = 0; i < trace.length; i++) {\n          \n          \n            \n                            logger.info(\"{}\", trace[i]);\n          \n          \n            \n                        }\n          \n          \n            \n                        logger.debug(\"Authorization exception: {}\", e.getMessage(), e);", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r571529991", "createdAt": "2021-02-07T03:47:08Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/ConnectedDriveProxy.java", "diffHunk": "@@ -0,0 +1,315 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bmwconnecteddrive.internal.handler;\n+\n+import static org.openhab.binding.bmwconnecteddrive.internal.utils.HTTPConstants.*;\n+\n+import java.nio.charset.Charset;\n+import java.nio.charset.StandardCharsets;\n+import java.util.Optional;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.client.util.BufferingResponseListener;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.eclipse.jetty.http.HttpField;\n+import org.eclipse.jetty.http.HttpFields;\n+import org.eclipse.jetty.http.HttpHeader;\n+import org.eclipse.jetty.util.MultiMap;\n+import org.eclipse.jetty.util.UrlEncoded;\n+import org.openhab.binding.bmwconnecteddrive.internal.ConnectedDriveConfiguration;\n+import org.openhab.binding.bmwconnecteddrive.internal.VehicleConfiguration;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.NetworkError;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.auth.AuthResponse;\n+import org.openhab.binding.bmwconnecteddrive.internal.handler.simulation.Injector;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.BimmerConstants;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Constants;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Converter;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ImageProperties;\n+import org.openhab.core.io.net.http.HttpClientFactory;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link ConnectedDriveProxy} This class holds the important constants for the BMW Connected Drive Authorization.\n+ * They\n+ * are taken from the Bimmercode from github {@link https://github.com/bimmerconnected/bimmer_connected}\n+ * File defining these constants\n+ * {@link https://github.com/bimmerconnected/bimmer_connected/blob/master/bimmer_connected/account.py}\n+ * https://customer.bmwgroup.com/one/app/oauth.js\n+ *\n+ * @author Bernd Weymann - Initial contribution\n+ */\n+@NonNullByDefault\n+public class ConnectedDriveProxy {\n+    private final Logger logger = LoggerFactory.getLogger(ConnectedDriveProxy.class);\n+    private final Token token = new Token();\n+    private HttpClient httpClient;\n+    private HttpClient authHttpClient;\n+    private String legacyAuthUri;\n+    private ConnectedDriveConfiguration configuration;\n+\n+    /**\n+     * URLs taken from https://github.com/bimmerconnected/bimmer_connected/blob/master/bimmer_connected/const.py\n+     */\n+    String baseUrl;\n+    String vehicleUrl;\n+    String legacyUrl;\n+    String vehicleStatusAPI = \"/status\";\n+    String lastTripAPI = \"/statistics/lastTrip\";\n+    String allTripsAPI = \"/statistics/allTrips\";\n+    String chargeAPI = \"/chargingprofile\";\n+    String destinationAPI = \"/destinations\";\n+    String imageAPI = \"/image\";\n+    String rangeMapAPI = \"/rangemap\";\n+    String serviceExecutionAPI = \"/executeService\";\n+    String serviceExecutionStateAPI = \"/serviceExecutionStatus\";\n+\n+    public ConnectedDriveProxy(HttpClientFactory httpClientFactory, ConnectedDriveConfiguration config) {\n+        httpClient = httpClientFactory.getCommonHttpClient();\n+        authHttpClient = httpClientFactory.createHttpClient(AUTH_HTTP_CLIENT_NAME);\n+        authHttpClient.setFollowRedirects(false);\n+        try {\n+            authHttpClient.start();\n+        } catch (Exception e) {\n+            logger.warn(\"Auth Http Client cannot be started\");\n+        }\n+        configuration = config;\n+\n+        StringBuilder legacyAuth = new StringBuilder();\n+        legacyAuth.append(\"https://\");\n+        legacyAuth.append(BimmerConstants.AUTH_SERVER_MAP.get(configuration.region));\n+        legacyAuth.append(BimmerConstants.OAUTH_ENDPOINT);\n+        legacyAuthUri = legacyAuth.toString();\n+        vehicleUrl = \"https://\" + getRegionServer() + \"/webapi/v1/user/vehicles\";\n+        baseUrl = vehicleUrl + \"/\";\n+        legacyUrl = \"https://\" + getRegionServer() + \"/api/vehicle/dynamic/v1/\";\n+    }\n+\n+    private synchronized void call(String url, boolean post, Optional<MultiMap<String>> params,\n+            ResponseCallback callback) {\n+        // only executed in \"simulation mode\"\n+        // SimulationTest.testSimulationOff() assures Injector is off when releasing\n+        if (Injector.isActive()) {\n+            if (url.equals(baseUrl)) {\n+                ((StringResponseCallback) callback).onResponse(Optional.of(Injector.getDiscovery()));\n+            } else if (url.endsWith(vehicleStatusAPI)) {\n+                ((StringResponseCallback) callback).onResponse(Optional.of(Injector.getStatus()));\n+            } else {\n+                logger.info(\"Simulation of {} not supported\", url);\n+            }\n+            return;\n+        }\n+        Request req;\n+        final StringBuilder completeUrl = new StringBuilder(url);\n+        if (post) {\n+            req = httpClient.POST(completeUrl.toString());\n+            if (params.isPresent()) {\n+                String urlEncodedParameter = UrlEncoded.encode(params.get(), Charset.defaultCharset(), false);\n+                req.header(HttpHeader.CONTENT_TYPE, CONTENT_TYPE_URL_ENCODED);\n+                req.header(CONTENT_LENGTH, Integer.toString(urlEncodedParameter.length()));\n+                req.content(new StringContentProvider(urlEncodedParameter));\n+            }\n+        } else {\n+            if (params.isPresent()) {\n+                completeUrl.append(Constants.QUESTION)\n+                        .append(UrlEncoded.encode(params.get(), Charset.defaultCharset(), false)).toString();\n+            }\n+            req = httpClient.newRequest(completeUrl.toString());\n+        }\n+        req.header(HttpHeader.AUTHORIZATION, getToken().getBearerToken());\n+        req.header(HttpHeader.REFERER, BimmerConstants.REFERER_URL);\n+\n+        req.timeout(HTTP_TIMEOUT_SEC, TimeUnit.SECONDS).send(new BufferingResponseListener() {\n+            @NonNullByDefault({})\n+            @Override\n+            public void onComplete(org.eclipse.jetty.client.api.Result result) {\n+                if (result.getResponse().getStatus() != 200) {\n+                    NetworkError error = new NetworkError();\n+                    error.url = completeUrl.toString();\n+                    error.status = result.getResponse().getStatus();\n+                    if (result.getResponse().getReason() != null) {\n+                        error.reason = result.getResponse().getReason();\n+                    } else {\n+                        error.reason = result.getFailure().getMessage();\n+                    }\n+                    error.params = result.getRequest().getParams().toString();\n+                    logger.debug(\"HTTP Error {}\", error.toString());\n+                    callback.onError(error);\n+                } else {\n+                    if (callback instanceof StringResponseCallback) {\n+                        ((StringResponseCallback) callback).onResponse(Optional.of(getContentAsString()));\n+                    } else {\n+                        ((ByteResponseCallback) callback).onResponse(Optional.of(getContent()));\n+                    }\n+                }\n+            }\n+        });\n+    }\n+\n+    public void get(String url, Optional<MultiMap<String>> params, ResponseCallback callback) {\n+        call(url, false, params, callback);\n+    }\n+\n+    public void post(String url, Optional<MultiMap<String>> params, ResponseCallback callback) {\n+        call(url, true, params, callback);\n+    }\n+\n+    public void requestVehicles(StringResponseCallback callback) {\n+        get(vehicleUrl, Optional.empty(), callback);\n+    }\n+\n+    public void requestVehcileStatus(VehicleConfiguration config, StringResponseCallback callback) {\n+        get(new StringBuilder(baseUrl).append(config.vin).append(vehicleStatusAPI).toString(), Optional.empty(),\n+                callback);\n+    }\n+\n+    public void requestLegacyVehcileStatus(VehicleConfiguration config, StringResponseCallback callback) {\n+        // see https://github.com/jupe76/bmwcdapi/search?q=dynamic%2Fv1\n+        get(new StringBuilder(legacyUrl).append(config.vin).append(\"?offset=-60\").toString(), Optional.empty(),\n+                callback);\n+    }\n+\n+    public void requestLastTrip(VehicleConfiguration config, StringResponseCallback callback) {\n+        get(new StringBuilder(baseUrl).append(config.vin).append(lastTripAPI).toString(), Optional.empty(), callback);\n+    }\n+\n+    public void requestAllTrips(VehicleConfiguration config, StringResponseCallback callback) {\n+        get(new StringBuilder(baseUrl).append(config.vin).append(allTripsAPI).toString(), Optional.empty(), callback);\n+    }\n+\n+    public void requestChargingProfile(VehicleConfiguration config, StringResponseCallback callback) {\n+        get(new StringBuilder(baseUrl).append(config.vin).append(chargeAPI).toString(), Optional.empty(), callback);\n+    }\n+\n+    public void requestDestinations(VehicleConfiguration config, StringResponseCallback callback) {\n+        get(new StringBuilder(baseUrl).append(config.vin).append(destinationAPI).toString(), Optional.empty(),\n+                callback);\n+    }\n+\n+    public void requestRangeMap(VehicleConfiguration config, Optional<MultiMap<String>> params,\n+            StringResponseCallback callback) {\n+        get(new StringBuilder(baseUrl).append(config.vin).append(rangeMapAPI).toString(), params, callback);\n+    }\n+\n+    public void requestImage(VehicleConfiguration config, ImageProperties props, ByteResponseCallback callback) {\n+        String localImageUrl = new StringBuilder(baseUrl).append(config.vin).append(imageAPI).toString();\n+        MultiMap<String> dataMap = new MultiMap<String>();\n+        dataMap.add(\"width\", Integer.toString(props.size));\n+        dataMap.add(\"height\", Integer.toString(props.size));\n+        dataMap.add(\"view\", props.viewport);\n+        get(localImageUrl, Optional.of(dataMap), callback);\n+    }\n+\n+    private String getRegionServer() {\n+        String retVal = BimmerConstants.SERVER_MAP.get(configuration.region);\n+        if (retVal != null) {\n+            return retVal;\n+        } else {\n+            return Constants.INVALID;\n+        }\n+    }\n+\n+    RemoteServiceHandler getRemoteServiceHandler(VehicleHandler vehicleHandler) {\n+        return new RemoteServiceHandler(vehicleHandler, this);\n+    }\n+\n+    // Token handling\n+\n+    /**\n+     * Gets new token if old one is expired or invalid. In case of error the token remains.\n+     * So if token refresh fails the corresponding requests will also fail and update the\n+     * Thing status accordingly.\n+     *\n+     * @return token\n+     */\n+    public Token getToken() {\n+        if (token.isExpired() || !token.isValid()) {\n+            updateToken();\n+        }\n+        return token;\n+    }\n+\n+    /**\n+     * Authorize at BMW Connected Drive Portal and get Token\n+     *\n+     * @return\n+     */\n+    private synchronized void updateToken() {\n+        Request req = authHttpClient.POST(legacyAuthUri);\n+\n+        req.header(HttpHeader.CONTENT_TYPE, CONTENT_TYPE_URL_ENCODED);\n+        req.header(HttpHeader.CONNECTION, KEEP_ALIVE);\n+        req.header(HttpHeader.HOST, BimmerConstants.SERVER_MAP.get(configuration.region));\n+        req.header(HttpHeader.AUTHORIZATION, BimmerConstants.AUTHORIZATION_VALUE_MAP.get(configuration.region));\n+        req.header(CREDENTIALS, BimmerConstants.CREDENTIAL_VALUES);\n+        req.header(HttpHeader.REFERER, BimmerConstants.REFERER_URL);\n+\n+        MultiMap<String> dataMap = new MultiMap<String>();\n+        dataMap.add(\"grant_type\", \"password\");\n+        dataMap.add(SCOPE, BimmerConstants.SCOPE_VALUES);\n+        dataMap.add(USERNAME, configuration.userName);\n+        dataMap.add(PASSWORD, configuration.password);\n+        String urlEncodedData = UrlEncoded.encode(dataMap, Charset.defaultCharset(), false);\n+        req.header(CONTENT_LENGTH, Integer.toString(urlEncodedData.length()));\n+        req.content(new StringContentProvider(urlEncodedData));\n+        try {\n+            ContentResponse contentResponse = req.timeout(HTTP_TIMEOUT_SEC, TimeUnit.SECONDS).send();\n+            // Status needs to be 302 - Response is stored in Header\n+            if (contentResponse.getStatus() == 302) {\n+                HttpFields fields = contentResponse.getHeaders();\n+                HttpField field = fields.getField(HttpHeader.LOCATION);\n+                tokenFromUrl(field.getValue());\n+            } else if (contentResponse.getStatus() == 200) {\n+                AuthResponse authResponse = Converter.getGson().fromJson(contentResponse.getContentAsString(),\n+                        AuthResponse.class);\n+                if (authResponse != null) {\n+                    token.setToken(authResponse.accessToken);\n+                    token.setType(authResponse.tokenType);\n+                    token.setExpiration(authResponse.expiresIn);\n+                }\n+            } else {\n+                logger.debug(\"Authorization status {} reason {}\", contentResponse.getStatus(),\n+                        contentResponse.getReason());\n+            }\n+        } catch (InterruptedException | ExecutionException | TimeoutException e) {\n+            logger.debug(\"Authorization exception: {}\", e.getMessage());\n+            StackTraceElement[] trace = e.getStackTrace();\n+            for (int i = 0; i < trace.length; i++) {\n+                logger.info(\"{}\", trace[i]);\n+            }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d5c01cbf22b288e86546da29f08d62c4d59189e5"}, "originalPosition": 295}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4ODMxMDI3MQ==", "bodyText": "fixed", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r588310271", "createdAt": "2021-03-05T13:52:12Z", "author": {"login": "ntruchsess"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/ConnectedDriveProxy.java", "diffHunk": "@@ -0,0 +1,315 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bmwconnecteddrive.internal.handler;\n+\n+import static org.openhab.binding.bmwconnecteddrive.internal.utils.HTTPConstants.*;\n+\n+import java.nio.charset.Charset;\n+import java.nio.charset.StandardCharsets;\n+import java.util.Optional;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.client.util.BufferingResponseListener;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.eclipse.jetty.http.HttpField;\n+import org.eclipse.jetty.http.HttpFields;\n+import org.eclipse.jetty.http.HttpHeader;\n+import org.eclipse.jetty.util.MultiMap;\n+import org.eclipse.jetty.util.UrlEncoded;\n+import org.openhab.binding.bmwconnecteddrive.internal.ConnectedDriveConfiguration;\n+import org.openhab.binding.bmwconnecteddrive.internal.VehicleConfiguration;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.NetworkError;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.auth.AuthResponse;\n+import org.openhab.binding.bmwconnecteddrive.internal.handler.simulation.Injector;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.BimmerConstants;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Constants;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Converter;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ImageProperties;\n+import org.openhab.core.io.net.http.HttpClientFactory;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link ConnectedDriveProxy} This class holds the important constants for the BMW Connected Drive Authorization.\n+ * They\n+ * are taken from the Bimmercode from github {@link https://github.com/bimmerconnected/bimmer_connected}\n+ * File defining these constants\n+ * {@link https://github.com/bimmerconnected/bimmer_connected/blob/master/bimmer_connected/account.py}\n+ * https://customer.bmwgroup.com/one/app/oauth.js\n+ *\n+ * @author Bernd Weymann - Initial contribution\n+ */\n+@NonNullByDefault\n+public class ConnectedDriveProxy {\n+    private final Logger logger = LoggerFactory.getLogger(ConnectedDriveProxy.class);\n+    private final Token token = new Token();\n+    private HttpClient httpClient;\n+    private HttpClient authHttpClient;\n+    private String legacyAuthUri;\n+    private ConnectedDriveConfiguration configuration;\n+\n+    /**\n+     * URLs taken from https://github.com/bimmerconnected/bimmer_connected/blob/master/bimmer_connected/const.py\n+     */\n+    String baseUrl;\n+    String vehicleUrl;\n+    String legacyUrl;\n+    String vehicleStatusAPI = \"/status\";\n+    String lastTripAPI = \"/statistics/lastTrip\";\n+    String allTripsAPI = \"/statistics/allTrips\";\n+    String chargeAPI = \"/chargingprofile\";\n+    String destinationAPI = \"/destinations\";\n+    String imageAPI = \"/image\";\n+    String rangeMapAPI = \"/rangemap\";\n+    String serviceExecutionAPI = \"/executeService\";\n+    String serviceExecutionStateAPI = \"/serviceExecutionStatus\";\n+\n+    public ConnectedDriveProxy(HttpClientFactory httpClientFactory, ConnectedDriveConfiguration config) {\n+        httpClient = httpClientFactory.getCommonHttpClient();\n+        authHttpClient = httpClientFactory.createHttpClient(AUTH_HTTP_CLIENT_NAME);\n+        authHttpClient.setFollowRedirects(false);\n+        try {\n+            authHttpClient.start();\n+        } catch (Exception e) {\n+            logger.warn(\"Auth Http Client cannot be started\");\n+        }\n+        configuration = config;\n+\n+        StringBuilder legacyAuth = new StringBuilder();\n+        legacyAuth.append(\"https://\");\n+        legacyAuth.append(BimmerConstants.AUTH_SERVER_MAP.get(configuration.region));\n+        legacyAuth.append(BimmerConstants.OAUTH_ENDPOINT);\n+        legacyAuthUri = legacyAuth.toString();\n+        vehicleUrl = \"https://\" + getRegionServer() + \"/webapi/v1/user/vehicles\";\n+        baseUrl = vehicleUrl + \"/\";\n+        legacyUrl = \"https://\" + getRegionServer() + \"/api/vehicle/dynamic/v1/\";\n+    }\n+\n+    private synchronized void call(String url, boolean post, Optional<MultiMap<String>> params,\n+            ResponseCallback callback) {\n+        // only executed in \"simulation mode\"\n+        // SimulationTest.testSimulationOff() assures Injector is off when releasing\n+        if (Injector.isActive()) {\n+            if (url.equals(baseUrl)) {\n+                ((StringResponseCallback) callback).onResponse(Optional.of(Injector.getDiscovery()));\n+            } else if (url.endsWith(vehicleStatusAPI)) {\n+                ((StringResponseCallback) callback).onResponse(Optional.of(Injector.getStatus()));\n+            } else {\n+                logger.info(\"Simulation of {} not supported\", url);\n+            }\n+            return;\n+        }\n+        Request req;\n+        final StringBuilder completeUrl = new StringBuilder(url);\n+        if (post) {\n+            req = httpClient.POST(completeUrl.toString());\n+            if (params.isPresent()) {\n+                String urlEncodedParameter = UrlEncoded.encode(params.get(), Charset.defaultCharset(), false);\n+                req.header(HttpHeader.CONTENT_TYPE, CONTENT_TYPE_URL_ENCODED);\n+                req.header(CONTENT_LENGTH, Integer.toString(urlEncodedParameter.length()));\n+                req.content(new StringContentProvider(urlEncodedParameter));\n+            }\n+        } else {\n+            if (params.isPresent()) {\n+                completeUrl.append(Constants.QUESTION)\n+                        .append(UrlEncoded.encode(params.get(), Charset.defaultCharset(), false)).toString();\n+            }\n+            req = httpClient.newRequest(completeUrl.toString());\n+        }\n+        req.header(HttpHeader.AUTHORIZATION, getToken().getBearerToken());\n+        req.header(HttpHeader.REFERER, BimmerConstants.REFERER_URL);\n+\n+        req.timeout(HTTP_TIMEOUT_SEC, TimeUnit.SECONDS).send(new BufferingResponseListener() {\n+            @NonNullByDefault({})\n+            @Override\n+            public void onComplete(org.eclipse.jetty.client.api.Result result) {\n+                if (result.getResponse().getStatus() != 200) {\n+                    NetworkError error = new NetworkError();\n+                    error.url = completeUrl.toString();\n+                    error.status = result.getResponse().getStatus();\n+                    if (result.getResponse().getReason() != null) {\n+                        error.reason = result.getResponse().getReason();\n+                    } else {\n+                        error.reason = result.getFailure().getMessage();\n+                    }\n+                    error.params = result.getRequest().getParams().toString();\n+                    logger.debug(\"HTTP Error {}\", error.toString());\n+                    callback.onError(error);\n+                } else {\n+                    if (callback instanceof StringResponseCallback) {\n+                        ((StringResponseCallback) callback).onResponse(Optional.of(getContentAsString()));\n+                    } else {\n+                        ((ByteResponseCallback) callback).onResponse(Optional.of(getContent()));\n+                    }\n+                }\n+            }\n+        });\n+    }\n+\n+    public void get(String url, Optional<MultiMap<String>> params, ResponseCallback callback) {\n+        call(url, false, params, callback);\n+    }\n+\n+    public void post(String url, Optional<MultiMap<String>> params, ResponseCallback callback) {\n+        call(url, true, params, callback);\n+    }\n+\n+    public void requestVehicles(StringResponseCallback callback) {\n+        get(vehicleUrl, Optional.empty(), callback);\n+    }\n+\n+    public void requestVehcileStatus(VehicleConfiguration config, StringResponseCallback callback) {\n+        get(new StringBuilder(baseUrl).append(config.vin).append(vehicleStatusAPI).toString(), Optional.empty(),\n+                callback);\n+    }\n+\n+    public void requestLegacyVehcileStatus(VehicleConfiguration config, StringResponseCallback callback) {\n+        // see https://github.com/jupe76/bmwcdapi/search?q=dynamic%2Fv1\n+        get(new StringBuilder(legacyUrl).append(config.vin).append(\"?offset=-60\").toString(), Optional.empty(),\n+                callback);\n+    }\n+\n+    public void requestLastTrip(VehicleConfiguration config, StringResponseCallback callback) {\n+        get(new StringBuilder(baseUrl).append(config.vin).append(lastTripAPI).toString(), Optional.empty(), callback);\n+    }\n+\n+    public void requestAllTrips(VehicleConfiguration config, StringResponseCallback callback) {\n+        get(new StringBuilder(baseUrl).append(config.vin).append(allTripsAPI).toString(), Optional.empty(), callback);\n+    }\n+\n+    public void requestChargingProfile(VehicleConfiguration config, StringResponseCallback callback) {\n+        get(new StringBuilder(baseUrl).append(config.vin).append(chargeAPI).toString(), Optional.empty(), callback);\n+    }\n+\n+    public void requestDestinations(VehicleConfiguration config, StringResponseCallback callback) {\n+        get(new StringBuilder(baseUrl).append(config.vin).append(destinationAPI).toString(), Optional.empty(),\n+                callback);\n+    }\n+\n+    public void requestRangeMap(VehicleConfiguration config, Optional<MultiMap<String>> params,\n+            StringResponseCallback callback) {\n+        get(new StringBuilder(baseUrl).append(config.vin).append(rangeMapAPI).toString(), params, callback);\n+    }\n+\n+    public void requestImage(VehicleConfiguration config, ImageProperties props, ByteResponseCallback callback) {\n+        String localImageUrl = new StringBuilder(baseUrl).append(config.vin).append(imageAPI).toString();\n+        MultiMap<String> dataMap = new MultiMap<String>();\n+        dataMap.add(\"width\", Integer.toString(props.size));\n+        dataMap.add(\"height\", Integer.toString(props.size));\n+        dataMap.add(\"view\", props.viewport);\n+        get(localImageUrl, Optional.of(dataMap), callback);\n+    }\n+\n+    private String getRegionServer() {\n+        String retVal = BimmerConstants.SERVER_MAP.get(configuration.region);\n+        if (retVal != null) {\n+            return retVal;\n+        } else {\n+            return Constants.INVALID;\n+        }\n+    }\n+\n+    RemoteServiceHandler getRemoteServiceHandler(VehicleHandler vehicleHandler) {\n+        return new RemoteServiceHandler(vehicleHandler, this);\n+    }\n+\n+    // Token handling\n+\n+    /**\n+     * Gets new token if old one is expired or invalid. In case of error the token remains.\n+     * So if token refresh fails the corresponding requests will also fail and update the\n+     * Thing status accordingly.\n+     *\n+     * @return token\n+     */\n+    public Token getToken() {\n+        if (token.isExpired() || !token.isValid()) {\n+            updateToken();\n+        }\n+        return token;\n+    }\n+\n+    /**\n+     * Authorize at BMW Connected Drive Portal and get Token\n+     *\n+     * @return\n+     */\n+    private synchronized void updateToken() {\n+        Request req = authHttpClient.POST(legacyAuthUri);\n+\n+        req.header(HttpHeader.CONTENT_TYPE, CONTENT_TYPE_URL_ENCODED);\n+        req.header(HttpHeader.CONNECTION, KEEP_ALIVE);\n+        req.header(HttpHeader.HOST, BimmerConstants.SERVER_MAP.get(configuration.region));\n+        req.header(HttpHeader.AUTHORIZATION, BimmerConstants.AUTHORIZATION_VALUE_MAP.get(configuration.region));\n+        req.header(CREDENTIALS, BimmerConstants.CREDENTIAL_VALUES);\n+        req.header(HttpHeader.REFERER, BimmerConstants.REFERER_URL);\n+\n+        MultiMap<String> dataMap = new MultiMap<String>();\n+        dataMap.add(\"grant_type\", \"password\");\n+        dataMap.add(SCOPE, BimmerConstants.SCOPE_VALUES);\n+        dataMap.add(USERNAME, configuration.userName);\n+        dataMap.add(PASSWORD, configuration.password);\n+        String urlEncodedData = UrlEncoded.encode(dataMap, Charset.defaultCharset(), false);\n+        req.header(CONTENT_LENGTH, Integer.toString(urlEncodedData.length()));\n+        req.content(new StringContentProvider(urlEncodedData));\n+        try {\n+            ContentResponse contentResponse = req.timeout(HTTP_TIMEOUT_SEC, TimeUnit.SECONDS).send();\n+            // Status needs to be 302 - Response is stored in Header\n+            if (contentResponse.getStatus() == 302) {\n+                HttpFields fields = contentResponse.getHeaders();\n+                HttpField field = fields.getField(HttpHeader.LOCATION);\n+                tokenFromUrl(field.getValue());\n+            } else if (contentResponse.getStatus() == 200) {\n+                AuthResponse authResponse = Converter.getGson().fromJson(contentResponse.getContentAsString(),\n+                        AuthResponse.class);\n+                if (authResponse != null) {\n+                    token.setToken(authResponse.accessToken);\n+                    token.setType(authResponse.tokenType);\n+                    token.setExpiration(authResponse.expiresIn);\n+                }\n+            } else {\n+                logger.debug(\"Authorization status {} reason {}\", contentResponse.getStatus(),\n+                        contentResponse.getReason());\n+            }\n+        } catch (InterruptedException | ExecutionException | TimeoutException e) {\n+            logger.debug(\"Authorization exception: {}\", e.getMessage());\n+            StackTraceElement[] trace = e.getStackTrace();\n+            for (int i = 0; i < trace.length; i++) {\n+                logger.info(\"{}\", trace[i]);\n+            }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MTUyOTk5MQ=="}, "originalCommit": {"oid": "d5c01cbf22b288e86546da29f08d62c4d59189e5"}, "originalPosition": 295}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzYwMTkyNTc1OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/utils/ImageProperties.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0wN1QwMzo1MjoxNVrOIhDc8w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0wNVQxMzo1MzoyMFrOIxDpnA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MTUzMDQ4Mw==", "bodyText": "The direct use of StringBuilder can get rather verbose. So try to avoid using it when only concatenating a small number of things.\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    return new StringBuilder(viewport).append(Integer.toString(size)).toString();\n          \n          \n            \n                    return viewport + size;", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r571530483", "createdAt": "2021-02-07T03:52:15Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/utils/ImageProperties.java", "diffHunk": "@@ -0,0 +1,49 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bmwconnecteddrive.internal.utils;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+\n+/**\n+ * The {@link ImageProperties} Properties of current Vehicle Image\n+ *\n+ * @author Bernd Weymann - Initial contribution\n+ */\n+@NonNullByDefault\n+public class ImageProperties {\n+    public static final int RETRY_COUNTER = 5;\n+    public int failCounter = 0;\n+    public String viewport = Constants.EMPTY;\n+    public int size = -1;\n+\n+    public ImageProperties(String viewport, int size) {\n+        this.viewport = viewport;\n+        this.size = size;\n+    }\n+\n+    public ImageProperties() {\n+    }\n+\n+    public void failed() {\n+        failCounter++;\n+    }\n+\n+    public boolean failLimitReached() {\n+        return failCounter > RETRY_COUNTER;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return new StringBuilder(viewport).append(Integer.toString(size)).toString();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d5c01cbf22b288e86546da29f08d62c4d59189e5"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4ODMxMDk0MA==", "bodyText": "fixed. direct use of String replaced by '+'-operator in most places where this is equivalent to using the StringBuilder.", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r588310940", "createdAt": "2021-03-05T13:53:20Z", "author": {"login": "ntruchsess"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/utils/ImageProperties.java", "diffHunk": "@@ -0,0 +1,49 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bmwconnecteddrive.internal.utils;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+\n+/**\n+ * The {@link ImageProperties} Properties of current Vehicle Image\n+ *\n+ * @author Bernd Weymann - Initial contribution\n+ */\n+@NonNullByDefault\n+public class ImageProperties {\n+    public static final int RETRY_COUNTER = 5;\n+    public int failCounter = 0;\n+    public String viewport = Constants.EMPTY;\n+    public int size = -1;\n+\n+    public ImageProperties(String viewport, int size) {\n+        this.viewport = viewport;\n+        this.size = size;\n+    }\n+\n+    public ImageProperties() {\n+    }\n+\n+    public void failed() {\n+        failCounter++;\n+    }\n+\n+    public boolean failLimitReached() {\n+        return failCounter > RETRY_COUNTER;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return new StringBuilder(viewport).append(Integer.toString(size)).toString();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MTUzMDQ4Mw=="}, "originalCommit": {"oid": "d5c01cbf22b288e86546da29f08d62c4d59189e5"}, "originalPosition": 47}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzYwMTkyNzEzOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/VehicleChannelHandler.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0wN1QwMzo1NDo1NFrOIhDdmg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0wNlQxODowNDozMFrOIxoUTA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MTUzMDY1MA==", "bodyText": "You can easily create the ChannelUIDs on demand. So it seems pretty wasteful to make fields for each of them. Please remove these fields.", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r571530650", "createdAt": "2021-02-07T03:54:54Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/VehicleChannelHandler.java", "diffHunk": "@@ -0,0 +1,646 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bmwconnecteddrive.internal.handler;\n+\n+import static org.openhab.binding.bmwconnecteddrive.internal.ConnectedDriveConstants.*;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Optional;\n+\n+import javax.measure.quantity.Length;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.binding.bmwconnecteddrive.internal.ConnectedDriveConstants.VehicleType;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.Destination;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.charge.ChargeProfile;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.charge.ChargingWindow;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.charge.Timer;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.charge.WeeklyPlanner;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.statistics.AllTrips;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.statistics.LastTrip;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.status.CBSMessage;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.status.CCMMessage;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.status.Doors;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.status.Position;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.status.VehicleStatus;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.status.Windows;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Constants;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Converter;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.VehicleStatusUtils;\n+import org.openhab.core.library.types.DateTimeType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.PointType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.library.unit.ImperialUnits;\n+import org.openhab.core.library.unit.MetricPrefix;\n+import org.openhab.core.library.unit.SIUnits;\n+import org.openhab.core.library.unit.Units;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.StateOption;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link VehicleChannelHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Bernd Weymann - Initial contribution\n+ */\n+@NonNullByDefault\n+public class VehicleChannelHandler extends BaseThingHandler {\n+    protected final Logger logger = LoggerFactory.getLogger(VehicleChannelHandler.class);\n+    protected boolean imperial = false;\n+    protected boolean hasFuel = false;\n+    protected boolean isElectric = false;\n+    protected boolean isHybrid = false;\n+\n+    // List Interfaces\n+    protected List<CBSMessage> serviceList = new ArrayList<CBSMessage>();\n+    protected String selectedService = Constants.UNDEF;\n+    protected List<CCMMessage> checkControlList = new ArrayList<CCMMessage>();\n+    protected String selectedCC = Constants.UNDEF;\n+    protected List<Destination> destinationList = new ArrayList<Destination>();\n+    protected String selectedDestination = Constants.UNDEF;\n+\n+    protected BMWConnectedDriveOptionProvider optionProvider;\n+\n+    // Vehicle Status Channels\n+    protected ChannelUID doors;\n+    protected ChannelUID windows;\n+    protected ChannelUID lock;\n+    protected ChannelUID serviceNextDate;\n+    protected ChannelUID serviceNextMileage;\n+    protected ChannelUID checkControl;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d5c01cbf22b288e86546da29f08d62c4d59189e5"}, "originalPosition": 88}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4ODMxMTA1Ng==", "bodyText": "fixed", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r588311056", "createdAt": "2021-03-05T13:53:32Z", "author": {"login": "ntruchsess"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/VehicleChannelHandler.java", "diffHunk": "@@ -0,0 +1,646 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bmwconnecteddrive.internal.handler;\n+\n+import static org.openhab.binding.bmwconnecteddrive.internal.ConnectedDriveConstants.*;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Optional;\n+\n+import javax.measure.quantity.Length;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.binding.bmwconnecteddrive.internal.ConnectedDriveConstants.VehicleType;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.Destination;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.charge.ChargeProfile;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.charge.ChargingWindow;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.charge.Timer;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.charge.WeeklyPlanner;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.statistics.AllTrips;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.statistics.LastTrip;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.status.CBSMessage;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.status.CCMMessage;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.status.Doors;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.status.Position;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.status.VehicleStatus;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.status.Windows;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Constants;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Converter;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.VehicleStatusUtils;\n+import org.openhab.core.library.types.DateTimeType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.PointType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.library.unit.ImperialUnits;\n+import org.openhab.core.library.unit.MetricPrefix;\n+import org.openhab.core.library.unit.SIUnits;\n+import org.openhab.core.library.unit.Units;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.StateOption;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link VehicleChannelHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Bernd Weymann - Initial contribution\n+ */\n+@NonNullByDefault\n+public class VehicleChannelHandler extends BaseThingHandler {\n+    protected final Logger logger = LoggerFactory.getLogger(VehicleChannelHandler.class);\n+    protected boolean imperial = false;\n+    protected boolean hasFuel = false;\n+    protected boolean isElectric = false;\n+    protected boolean isHybrid = false;\n+\n+    // List Interfaces\n+    protected List<CBSMessage> serviceList = new ArrayList<CBSMessage>();\n+    protected String selectedService = Constants.UNDEF;\n+    protected List<CCMMessage> checkControlList = new ArrayList<CCMMessage>();\n+    protected String selectedCC = Constants.UNDEF;\n+    protected List<Destination> destinationList = new ArrayList<Destination>();\n+    protected String selectedDestination = Constants.UNDEF;\n+\n+    protected BMWConnectedDriveOptionProvider optionProvider;\n+\n+    // Vehicle Status Channels\n+    protected ChannelUID doors;\n+    protected ChannelUID windows;\n+    protected ChannelUID lock;\n+    protected ChannelUID serviceNextDate;\n+    protected ChannelUID serviceNextMileage;\n+    protected ChannelUID checkControl;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MTUzMDY1MA=="}, "originalCommit": {"oid": "d5c01cbf22b288e86546da29f08d62c4d59189e5"}, "originalPosition": 88}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4ODkxMTY5Mg==", "bodyText": "Channel UID creation is taking for each update several String concatenations. So I found it pretty watseful to cerate these on demand. But fine for me.", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r588911692", "createdAt": "2021-03-06T18:04:30Z", "author": {"login": "weymann"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/VehicleChannelHandler.java", "diffHunk": "@@ -0,0 +1,646 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bmwconnecteddrive.internal.handler;\n+\n+import static org.openhab.binding.bmwconnecteddrive.internal.ConnectedDriveConstants.*;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Optional;\n+\n+import javax.measure.quantity.Length;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.binding.bmwconnecteddrive.internal.ConnectedDriveConstants.VehicleType;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.Destination;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.charge.ChargeProfile;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.charge.ChargingWindow;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.charge.Timer;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.charge.WeeklyPlanner;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.statistics.AllTrips;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.statistics.LastTrip;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.status.CBSMessage;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.status.CCMMessage;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.status.Doors;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.status.Position;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.status.VehicleStatus;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.status.Windows;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Constants;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Converter;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.VehicleStatusUtils;\n+import org.openhab.core.library.types.DateTimeType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.PointType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.library.unit.ImperialUnits;\n+import org.openhab.core.library.unit.MetricPrefix;\n+import org.openhab.core.library.unit.SIUnits;\n+import org.openhab.core.library.unit.Units;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.StateOption;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link VehicleChannelHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Bernd Weymann - Initial contribution\n+ */\n+@NonNullByDefault\n+public class VehicleChannelHandler extends BaseThingHandler {\n+    protected final Logger logger = LoggerFactory.getLogger(VehicleChannelHandler.class);\n+    protected boolean imperial = false;\n+    protected boolean hasFuel = false;\n+    protected boolean isElectric = false;\n+    protected boolean isHybrid = false;\n+\n+    // List Interfaces\n+    protected List<CBSMessage> serviceList = new ArrayList<CBSMessage>();\n+    protected String selectedService = Constants.UNDEF;\n+    protected List<CCMMessage> checkControlList = new ArrayList<CCMMessage>();\n+    protected String selectedCC = Constants.UNDEF;\n+    protected List<Destination> destinationList = new ArrayList<Destination>();\n+    protected String selectedDestination = Constants.UNDEF;\n+\n+    protected BMWConnectedDriveOptionProvider optionProvider;\n+\n+    // Vehicle Status Channels\n+    protected ChannelUID doors;\n+    protected ChannelUID windows;\n+    protected ChannelUID lock;\n+    protected ChannelUID serviceNextDate;\n+    protected ChannelUID serviceNextMileage;\n+    protected ChannelUID checkControl;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MTUzMDY1MA=="}, "originalCommit": {"oid": "d5c01cbf22b288e86546da29f08d62c4d59189e5"}, "originalPosition": 88}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzcxNzEyMTE3OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/dto/compat/VehicleAttributesContainer.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0wNlQyMTo1ODoyMVrOIxpz3Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0wN1QxNjozMDoxN1rOIxxCUA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4ODkzNjE1Nw==", "bodyText": "from what I can see toJson() does not throw JsonSyntaxException. (fromJson does)", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r588936157", "createdAt": "2021-03-06T21:58:21Z", "author": {"login": "ntruchsess"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/dto/compat/VehicleAttributesContainer.java", "diffHunk": "@@ -101,7 +103,11 @@ public String transform() {\n             }\n         }\n         vs.cbsData = cbsl;\n-\n-        return Converter.getGson().toJson(vsc);\n+        String returnVal = Constants.EMPTY_JSON;\n+        try {\n+            returnVal = Converter.getGson().toJson(vsc);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "60d9ba89e05508de81acafb965b5a16e5c09fbf5"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4OTA1NDU0NA==", "bodyText": "True! Reverted this", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r589054544", "createdAt": "2021-03-07T16:30:17Z", "author": {"login": "weymann"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/dto/compat/VehicleAttributesContainer.java", "diffHunk": "@@ -101,7 +103,11 @@ public String transform() {\n             }\n         }\n         vs.cbsData = cbsl;\n-\n-        return Converter.getGson().toJson(vsc);\n+        String returnVal = Constants.EMPTY_JSON;\n+        try {\n+            returnVal = Converter.getGson().toJson(vsc);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4ODkzNjE1Nw=="}, "originalCommit": {"oid": "60d9ba89e05508de81acafb965b5a16e5c09fbf5"}, "originalPosition": 17}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzcxNzEyMzgzOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/ConnectedDriveProxy.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0wNlQyMjowMTo0OFrOIxp1JA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0wN1QxNjoyMzozN1rOIxw-dQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4ODkzNjQ4NA==", "bodyText": "catching JsonSyntaxException here is redundant to the catch in line 283", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r588936484", "createdAt": "2021-03-06T22:01:48Z", "author": {"login": "ntruchsess"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/ConnectedDriveProxy.java", "diffHunk": "@@ -290,7 +290,7 @@ private synchronized void updateToken() {\n                 logger.debug(\"Authorization status {} reason {}\", contentResponse.getStatus(),\n                         contentResponse.getReason());\n             }\n-        } catch (InterruptedException | ExecutionException | TimeoutException e) {\n+        } catch (InterruptedException | ExecutionException | TimeoutException | JsonSyntaxException e) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "60d9ba89e05508de81acafb965b5a16e5c09fbf5"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4OTA1MzU1Nw==", "bodyText": "Reverted", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r589053557", "createdAt": "2021-03-07T16:23:37Z", "author": {"login": "weymann"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/ConnectedDriveProxy.java", "diffHunk": "@@ -290,7 +290,7 @@ private synchronized void updateToken() {\n                 logger.debug(\"Authorization status {} reason {}\", contentResponse.getStatus(),\n                         contentResponse.getReason());\n             }\n-        } catch (InterruptedException | ExecutionException | TimeoutException e) {\n+        } catch (InterruptedException | ExecutionException | TimeoutException | JsonSyntaxException e) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4ODkzNjQ4NA=="}, "originalCommit": {"oid": "60d9ba89e05508de81acafb965b5a16e5c09fbf5"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzcxNzEyNTMzOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/VehicleChannelHandler.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0wNlQyMjowMzo1NFrOIxp13g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0wN1QxNjoyNzo0MVrOIxxA0w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4ODkzNjY3MA==", "bodyText": "ChargeProfileWrapper.fromJson does not throw any Exception. It will return empty Optional in case the Json is unparseable.", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r588936670", "createdAt": "2021-03-06T22:03:54Z", "author": {"login": "ntruchsess"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/VehicleChannelHandler.java", "diffHunk": "@@ -334,7 +336,11 @@ protected void updateLastTrip(LastTrip trip) {\n     }\n \n     protected void updateChargeProfileFromContent(String content) {\n-        ChargeProfileWrapper.fromJson(content).ifPresent(this::updateChargeProfile);\n+        try {\n+            ChargeProfileWrapper.fromJson(content).ifPresent(this::updateChargeProfile);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "60d9ba89e05508de81acafb965b5a16e5c09fbf5"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4OTA1NDE2Mw==", "bodyText": "I see", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r589054163", "createdAt": "2021-03-07T16:27:41Z", "author": {"login": "weymann"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/VehicleChannelHandler.java", "diffHunk": "@@ -334,7 +336,11 @@ protected void updateLastTrip(LastTrip trip) {\n     }\n \n     protected void updateChargeProfileFromContent(String content) {\n-        ChargeProfileWrapper.fromJson(content).ifPresent(this::updateChargeProfile);\n+        try {\n+            ChargeProfileWrapper.fromJson(content).ifPresent(this::updateChargeProfile);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4ODkzNjY3MA=="}, "originalCommit": {"oid": "60d9ba89e05508de81acafb965b5a16e5c09fbf5"}, "originalPosition": 15}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzc3NjQyMDMxOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/ConnectedDriveConstants.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0xOVQxNzozNjo1NVrOI6KnsA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0yMVQxMToyOToxM1rOI6jJGA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5Nzg2MjMyMA==", "bodyText": "It's good practice to append the unit to the field name e.g. TIMEOUT_SEC.", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r597862320", "createdAt": "2021-03-19T17:36:55Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/ConnectedDriveConstants.java", "diffHunk": "@@ -0,0 +1,204 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bmwconnecteddrive.internal;\n+\n+import java.util.Set;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.core.thing.ThingTypeUID;\n+\n+/**\n+ * The {@link ConnectedDriveConstants} class defines common constants, which are\n+ * used across the whole binding.\n+ *\n+ * @author Bernd Weymann - Initial contribution\n+ * @author Norbert Truchsess - edit & send of charge profile\n+ */\n+@NonNullByDefault\n+public class ConnectedDriveConstants {\n+\n+    private static final String BINDING_ID = \"bmwconnecteddrive\";\n+\n+    // Units\n+    public static final String UNITS_AUTODETECT = \"AUTODETECT\";\n+    public static final String UNITS_IMPERIAL = \"IMPERIAL\";\n+    public static final String UNITS_METRIC = \"METRIC\";\n+\n+    public static final String VIN = \"vin\";\n+\n+    public static final int DEFAULT_IMAGE_SIZE = 1024;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "48af48c82562d006b6f2aa35922270f181c885ed"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5ODI2NDA4OA==", "bodyText": "Fixed", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r598264088", "createdAt": "2021-03-21T11:29:13Z", "author": {"login": "weymann"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/ConnectedDriveConstants.java", "diffHunk": "@@ -0,0 +1,204 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bmwconnecteddrive.internal;\n+\n+import java.util.Set;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.core.thing.ThingTypeUID;\n+\n+/**\n+ * The {@link ConnectedDriveConstants} class defines common constants, which are\n+ * used across the whole binding.\n+ *\n+ * @author Bernd Weymann - Initial contribution\n+ * @author Norbert Truchsess - edit & send of charge profile\n+ */\n+@NonNullByDefault\n+public class ConnectedDriveConstants {\n+\n+    private static final String BINDING_ID = \"bmwconnecteddrive\";\n+\n+    // Units\n+    public static final String UNITS_AUTODETECT = \"AUTODETECT\";\n+    public static final String UNITS_IMPERIAL = \"IMPERIAL\";\n+    public static final String UNITS_METRIC = \"METRIC\";\n+\n+    public static final String VIN = \"vin\";\n+\n+    public static final int DEFAULT_IMAGE_SIZE = 1024;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5Nzg2MjMyMA=="}, "originalCommit": {"oid": "48af48c82562d006b6f2aa35922270f181c885ed"}, "originalPosition": 39}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzc3NjQyMTc0OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/ConnectedDriveConstants.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0xOVQxNzozNzoxMVrOI6Kogg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0yMVQxMToyOToyM1rOI6jJJw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5Nzg2MjUzMA==", "bodyText": "Same as above. Unit.", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r597862530", "createdAt": "2021-03-19T17:37:11Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/ConnectedDriveConstants.java", "diffHunk": "@@ -0,0 +1,204 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bmwconnecteddrive.internal;\n+\n+import java.util.Set;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.core.thing.ThingTypeUID;\n+\n+/**\n+ * The {@link ConnectedDriveConstants} class defines common constants, which are\n+ * used across the whole binding.\n+ *\n+ * @author Bernd Weymann - Initial contribution\n+ * @author Norbert Truchsess - edit & send of charge profile\n+ */\n+@NonNullByDefault\n+public class ConnectedDriveConstants {\n+\n+    private static final String BINDING_ID = \"bmwconnecteddrive\";\n+\n+    // Units\n+    public static final String UNITS_AUTODETECT = \"AUTODETECT\";\n+    public static final String UNITS_IMPERIAL = \"IMPERIAL\";\n+    public static final String UNITS_METRIC = \"METRIC\";\n+\n+    public static final String VIN = \"vin\";\n+\n+    public static final int DEFAULT_IMAGE_SIZE = 1024;\n+    public static final int DEFAULT_REFRESH_INTERVAL = 5;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "48af48c82562d006b6f2aa35922270f181c885ed"}, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5ODI2NDEwMw==", "bodyText": "Fixed", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r598264103", "createdAt": "2021-03-21T11:29:23Z", "author": {"login": "weymann"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/ConnectedDriveConstants.java", "diffHunk": "@@ -0,0 +1,204 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bmwconnecteddrive.internal;\n+\n+import java.util.Set;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.core.thing.ThingTypeUID;\n+\n+/**\n+ * The {@link ConnectedDriveConstants} class defines common constants, which are\n+ * used across the whole binding.\n+ *\n+ * @author Bernd Weymann - Initial contribution\n+ * @author Norbert Truchsess - edit & send of charge profile\n+ */\n+@NonNullByDefault\n+public class ConnectedDriveConstants {\n+\n+    private static final String BINDING_ID = \"bmwconnecteddrive\";\n+\n+    // Units\n+    public static final String UNITS_AUTODETECT = \"AUTODETECT\";\n+    public static final String UNITS_IMPERIAL = \"IMPERIAL\";\n+    public static final String UNITS_METRIC = \"METRIC\";\n+\n+    public static final String VIN = \"vin\";\n+\n+    public static final int DEFAULT_IMAGE_SIZE = 1024;\n+    public static final int DEFAULT_REFRESH_INTERVAL = 5;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5Nzg2MjUzMA=="}, "originalCommit": {"oid": "48af48c82562d006b6f2aa35922270f181c885ed"}, "originalPosition": 40}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzc3NjQ0NjQyOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/ConnectedDriveHandlerFactory.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0xOVQxNzo0MzozMFrOI6K4FQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0yMVQxMTozNjo1MVrOI6jMuQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5Nzg2NjUxNw==", "bodyText": "What is the purpose of this field?", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r597866517", "createdAt": "2021-03-19T17:43:30Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/ConnectedDriveHandlerFactory.java", "diffHunk": "@@ -0,0 +1,92 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bmwconnecteddrive.internal;\n+\n+import static org.openhab.binding.bmwconnecteddrive.internal.ConnectedDriveConstants.*;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.bmwconnecteddrive.internal.handler.BMWConnectedDriveOptionProvider;\n+import org.openhab.binding.bmwconnecteddrive.internal.handler.ConnectedDriveBridgeHandler;\n+import org.openhab.binding.bmwconnecteddrive.internal.handler.VehicleHandler;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Converter;\n+import org.openhab.core.i18n.LocaleProvider;\n+import org.openhab.core.i18n.TimeZoneProvider;\n+import org.openhab.core.io.net.http.HttpClientFactory;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingTypeUID;\n+import org.openhab.core.thing.binding.BaseThingHandlerFactory;\n+import org.openhab.core.thing.binding.ThingHandler;\n+import org.openhab.core.thing.binding.ThingHandlerFactory;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Reference;\n+\n+/**\n+ * The {@link ConnectedDriveHandlerFactory} is responsible for creating things and thing\n+ * handlers.\n+ *\n+ * @author Bernd Weymann - Initial contribution\n+ */\n+@NonNullByDefault\n+@Component(configurationPid = \"binding.bmwconnecteddrive\", service = ThingHandlerFactory.class)\n+public class ConnectedDriveHandlerFactory extends BaseThingHandlerFactory {\n+\n+    private final HttpClientFactory httpClientFactory;\n+    private final BMWConnectedDriveOptionProvider optionProvider;\n+    private static final List<VehicleHandler> VEHICLE_HANDLER_REGISTRY = new ArrayList<VehicleHandler>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "48af48c82562d006b6f2aa35922270f181c885ed"}, "originalPosition": 51}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5ODI2NTAxNw==", "bodyText": "Leftover from intermediate implementation - removed", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r598265017", "createdAt": "2021-03-21T11:36:51Z", "author": {"login": "weymann"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/ConnectedDriveHandlerFactory.java", "diffHunk": "@@ -0,0 +1,92 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bmwconnecteddrive.internal;\n+\n+import static org.openhab.binding.bmwconnecteddrive.internal.ConnectedDriveConstants.*;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.bmwconnecteddrive.internal.handler.BMWConnectedDriveOptionProvider;\n+import org.openhab.binding.bmwconnecteddrive.internal.handler.ConnectedDriveBridgeHandler;\n+import org.openhab.binding.bmwconnecteddrive.internal.handler.VehicleHandler;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Converter;\n+import org.openhab.core.i18n.LocaleProvider;\n+import org.openhab.core.i18n.TimeZoneProvider;\n+import org.openhab.core.io.net.http.HttpClientFactory;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingTypeUID;\n+import org.openhab.core.thing.binding.BaseThingHandlerFactory;\n+import org.openhab.core.thing.binding.ThingHandler;\n+import org.openhab.core.thing.binding.ThingHandlerFactory;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Reference;\n+\n+/**\n+ * The {@link ConnectedDriveHandlerFactory} is responsible for creating things and thing\n+ * handlers.\n+ *\n+ * @author Bernd Weymann - Initial contribution\n+ */\n+@NonNullByDefault\n+@Component(configurationPid = \"binding.bmwconnecteddrive\", service = ThingHandlerFactory.class)\n+public class ConnectedDriveHandlerFactory extends BaseThingHandlerFactory {\n+\n+    private final HttpClientFactory httpClientFactory;\n+    private final BMWConnectedDriveOptionProvider optionProvider;\n+    private static final List<VehicleHandler> VEHICLE_HANDLER_REGISTRY = new ArrayList<VehicleHandler>();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5Nzg2NjUxNw=="}, "originalCommit": {"oid": "48af48c82562d006b6f2aa35922270f181c885ed"}, "originalPosition": 51}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzc3NjQ0OTQxOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/action/ChargeProfileActions.java", "isResolved": true, "comments": {"totalCount": 24, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0xOVQxNzo0NDoxN1rOI6K59A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNC0xMlQxOTo1MDo0OVrOJHkBvQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5Nzg2Njk5Ng==", "bodyText": "The scope's name should match with the binding's name", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r597866996", "createdAt": "2021-03-19T17:44:17Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/action/ChargeProfileActions.java", "diffHunk": "@@ -0,0 +1,406 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bmwconnecteddrive.internal.action;\n+\n+import static org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileWrapper.ProfileKey.*;\n+\n+import java.time.DayOfWeek;\n+import java.time.LocalTime;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.bmwconnecteddrive.internal.handler.VehicleHandler;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileWrapper;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileWrapper.ProfileKey;\n+import org.openhab.core.automation.annotation.ActionInput;\n+import org.openhab.core.automation.annotation.ActionOutput;\n+import org.openhab.core.automation.annotation.RuleAction;\n+import org.openhab.core.thing.binding.ThingActions;\n+import org.openhab.core.thing.binding.ThingActionsScope;\n+import org.openhab.core.thing.binding.ThingHandler;\n+\n+/**\n+ * The {@link ChargeProfileActions} provides actions for VehicleHandler\n+ *\n+ * @author Norbert Truchsess - Initial contribution\n+ */\n+@ThingActionsScope(name = \"chargeprofile\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "48af48c82562d006b6f2aa35922270f181c885ed"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5ODI3MzkzMQ==", "bodyText": "That implies you could have only a single action per binding. Is this the intention? Or is there a naming-scheme if you want to have multiple actions for the same binding?", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r598273931", "createdAt": "2021-03-21T12:44:51Z", "author": {"login": "ntruchsess"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/action/ChargeProfileActions.java", "diffHunk": "@@ -0,0 +1,406 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bmwconnecteddrive.internal.action;\n+\n+import static org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileWrapper.ProfileKey.*;\n+\n+import java.time.DayOfWeek;\n+import java.time.LocalTime;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.bmwconnecteddrive.internal.handler.VehicleHandler;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileWrapper;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileWrapper.ProfileKey;\n+import org.openhab.core.automation.annotation.ActionInput;\n+import org.openhab.core.automation.annotation.ActionOutput;\n+import org.openhab.core.automation.annotation.RuleAction;\n+import org.openhab.core.thing.binding.ThingActions;\n+import org.openhab.core.thing.binding.ThingActionsScope;\n+import org.openhab.core.thing.binding.ThingHandler;\n+\n+/**\n+ * The {@link ChargeProfileActions} provides actions for VehicleHandler\n+ *\n+ * @author Norbert Truchsess - Initial contribution\n+ */\n+@ThingActionsScope(name = \"chargeprofile\")", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5Nzg2Njk5Ng=="}, "originalCommit": {"oid": "48af48c82562d006b6f2aa35922270f181c885ed"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5ODI3NjA1Nw==", "bodyText": "I'm not aware of a binding that has multiple Action classes for the same Thing. If I see correctly this binding has only one Action class. Is this a hypothetical question or is there maybe some misunderstanding?", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r598276057", "createdAt": "2021-03-21T12:59:08Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/action/ChargeProfileActions.java", "diffHunk": "@@ -0,0 +1,406 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bmwconnecteddrive.internal.action;\n+\n+import static org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileWrapper.ProfileKey.*;\n+\n+import java.time.DayOfWeek;\n+import java.time.LocalTime;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.bmwconnecteddrive.internal.handler.VehicleHandler;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileWrapper;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileWrapper.ProfileKey;\n+import org.openhab.core.automation.annotation.ActionInput;\n+import org.openhab.core.automation.annotation.ActionOutput;\n+import org.openhab.core.automation.annotation.RuleAction;\n+import org.openhab.core.thing.binding.ThingActions;\n+import org.openhab.core.thing.binding.ThingActionsScope;\n+import org.openhab.core.thing.binding.ThingHandler;\n+\n+/**\n+ * The {@link ChargeProfileActions} provides actions for VehicleHandler\n+ *\n+ * @author Norbert Truchsess - Initial contribution\n+ */\n+@ThingActionsScope(name = \"chargeprofile\")", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5Nzg2Njk5Ng=="}, "originalCommit": {"oid": "48af48c82562d006b6f2aa35922270f181c885ed"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5ODMyMjE0MQ==", "bodyText": "That is not a hypothetical question - from my point of view it makes sense to have multiple actions per thing but I don't know whether this is somehow forbidden by the OH3 design. Technically it doesn't seem to be. Is there some documentation that lists such conventions? By just looking into the examples this is not obvious.\nOf course I can easily change that if multiple actions per thing are not something anybody would ever want in OH.", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r598322141", "createdAt": "2021-03-21T18:56:55Z", "author": {"login": "ntruchsess"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/action/ChargeProfileActions.java", "diffHunk": "@@ -0,0 +1,406 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bmwconnecteddrive.internal.action;\n+\n+import static org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileWrapper.ProfileKey.*;\n+\n+import java.time.DayOfWeek;\n+import java.time.LocalTime;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.bmwconnecteddrive.internal.handler.VehicleHandler;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileWrapper;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileWrapper.ProfileKey;\n+import org.openhab.core.automation.annotation.ActionInput;\n+import org.openhab.core.automation.annotation.ActionOutput;\n+import org.openhab.core.automation.annotation.RuleAction;\n+import org.openhab.core.thing.binding.ThingActions;\n+import org.openhab.core.thing.binding.ThingActionsScope;\n+import org.openhab.core.thing.binding.ThingHandler;\n+\n+/**\n+ * The {@link ChargeProfileActions} provides actions for VehicleHandler\n+ *\n+ * @author Norbert Truchsess - Initial contribution\n+ */\n+@ThingActionsScope(name = \"chargeprofile\")", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5Nzg2Njk5Ng=="}, "originalCommit": {"oid": "48af48c82562d006b6f2aa35922270f181c885ed"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMTg2MTY5Mw==", "bodyText": "Just for clarification, there can be multiple Actions per Thing, but if I understand correctly, you want to add multiple Action classes per Thing?", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r601861693", "createdAt": "2021-03-25T21:48:36Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/action/ChargeProfileActions.java", "diffHunk": "@@ -0,0 +1,406 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bmwconnecteddrive.internal.action;\n+\n+import static org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileWrapper.ProfileKey.*;\n+\n+import java.time.DayOfWeek;\n+import java.time.LocalTime;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.bmwconnecteddrive.internal.handler.VehicleHandler;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileWrapper;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileWrapper.ProfileKey;\n+import org.openhab.core.automation.annotation.ActionInput;\n+import org.openhab.core.automation.annotation.ActionOutput;\n+import org.openhab.core.automation.annotation.RuleAction;\n+import org.openhab.core.thing.binding.ThingActions;\n+import org.openhab.core.thing.binding.ThingActionsScope;\n+import org.openhab.core.thing.binding.ThingHandler;\n+\n+/**\n+ * The {@link ChargeProfileActions} provides actions for VehicleHandler\n+ *\n+ * @author Norbert Truchsess - Initial contribution\n+ */\n+@ThingActionsScope(name = \"chargeprofile\")", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5Nzg2Njk5Ng=="}, "originalCommit": {"oid": "48af48c82562d006b6f2aa35922270f181c885ed"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMTg4NDYyOQ==", "bodyText": "sure - for what other reason does ThingHandler.getServices() return a collection if not to allow for multiple Action-classes per thing?\npublic Collection<Class<? extends ThingHandlerService>> getServices();\nWhat would the ThingActionsScope-(per-class)-annotation be good for if not to differentiate in between multiple implementations of ThingActions per Thing? If the scope would be a semantical synonym to the Thing-type then it would be just redundant to the ThingUID that is also passed to getActions in a script.\nThe implementation of class ScriptThingActions (how keys of THINGS_ACTION_MAP are being constructed and used) seems to be desinged exactly for that purpose.", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r601884629", "createdAt": "2021-03-25T22:40:49Z", "author": {"login": "ntruchsess"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/action/ChargeProfileActions.java", "diffHunk": "@@ -0,0 +1,406 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bmwconnecteddrive.internal.action;\n+\n+import static org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileWrapper.ProfileKey.*;\n+\n+import java.time.DayOfWeek;\n+import java.time.LocalTime;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.bmwconnecteddrive.internal.handler.VehicleHandler;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileWrapper;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileWrapper.ProfileKey;\n+import org.openhab.core.automation.annotation.ActionInput;\n+import org.openhab.core.automation.annotation.ActionOutput;\n+import org.openhab.core.automation.annotation.RuleAction;\n+import org.openhab.core.thing.binding.ThingActions;\n+import org.openhab.core.thing.binding.ThingActionsScope;\n+import org.openhab.core.thing.binding.ThingHandler;\n+\n+/**\n+ * The {@link ChargeProfileActions} provides actions for VehicleHandler\n+ *\n+ * @author Norbert Truchsess - Initial contribution\n+ */\n+@ThingActionsScope(name = \"chargeprofile\")", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5Nzg2Njk5Ng=="}, "originalCommit": {"oid": "48af48c82562d006b6f2aa35922270f181c885ed"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMjExMzM1MQ==", "bodyText": "The method signature should a strong evidence, that the framework supports multiple action classes per Thing! :)\nThe scope's name will be used to group the actions in the UI. So, if you call it \"chargeprofile\", it might be a bit lost in the UI.", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r602113351", "createdAt": "2021-03-26T08:58:02Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/action/ChargeProfileActions.java", "diffHunk": "@@ -0,0 +1,406 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bmwconnecteddrive.internal.action;\n+\n+import static org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileWrapper.ProfileKey.*;\n+\n+import java.time.DayOfWeek;\n+import java.time.LocalTime;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.bmwconnecteddrive.internal.handler.VehicleHandler;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileWrapper;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileWrapper.ProfileKey;\n+import org.openhab.core.automation.annotation.ActionInput;\n+import org.openhab.core.automation.annotation.ActionOutput;\n+import org.openhab.core.automation.annotation.RuleAction;\n+import org.openhab.core.thing.binding.ThingActions;\n+import org.openhab.core.thing.binding.ThingActionsScope;\n+import org.openhab.core.thing.binding.ThingHandler;\n+\n+/**\n+ * The {@link ChargeProfileActions} provides actions for VehicleHandler\n+ *\n+ * @author Norbert Truchsess - Initial contribution\n+ */\n+@ThingActionsScope(name = \"chargeprofile\")", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5Nzg2Njk5Ng=="}, "originalCommit": {"oid": "48af48c82562d006b6f2aa35922270f181c885ed"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMjE1MDQ5Ng==", "bodyText": "I was not aware it shows in the ui and I don't think the approach you link works out well. It results in a long list of different scopes with a single method for most bindings. It should group per binding and then per scope. Or - if same scope would be used for equivalent actions in different things - optionally first per sope, then per thing-type.\nGiven it groups only per scope it would make sense to use a common prefix for all thing's actions. Like bmw-charging, bmw-navigation (to access recent destinations and send new destinations to the car). But if multiple car-related bindings would offer simmilar actions the prefix should rather be 'car-charging' + 'car-navigation'. But then there might be a binding for the garmin web-portal\nthat also allows to send destinations to so both might group as just 'navigation'.\nMaybe the best choice would be to use the most generic term it might group within? I think there should be a real concept for the grouping in the first place not just examples of existing use (that only shows the shortcomings of not having a concept).", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r602150496", "createdAt": "2021-03-26T09:55:37Z", "author": {"login": "ntruchsess"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/action/ChargeProfileActions.java", "diffHunk": "@@ -0,0 +1,406 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bmwconnecteddrive.internal.action;\n+\n+import static org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileWrapper.ProfileKey.*;\n+\n+import java.time.DayOfWeek;\n+import java.time.LocalTime;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.bmwconnecteddrive.internal.handler.VehicleHandler;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileWrapper;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileWrapper.ProfileKey;\n+import org.openhab.core.automation.annotation.ActionInput;\n+import org.openhab.core.automation.annotation.ActionOutput;\n+import org.openhab.core.automation.annotation.RuleAction;\n+import org.openhab.core.thing.binding.ThingActions;\n+import org.openhab.core.thing.binding.ThingActionsScope;\n+import org.openhab.core.thing.binding.ThingHandler;\n+\n+/**\n+ * The {@link ChargeProfileActions} provides actions for VehicleHandler\n+ *\n+ * @author Norbert Truchsess - Initial contribution\n+ */\n+@ThingActionsScope(name = \"chargeprofile\")", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5Nzg2Njk5Ng=="}, "originalCommit": {"oid": "48af48c82562d006b6f2aa35922270f181c885ed"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMjQ2NTgyOA==", "bodyText": "ATM all actions are grouped by the binding (which is identical to the scope). Can you elaborate what's your concern about this approach?", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r602465828", "createdAt": "2021-03-26T17:19:18Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/action/ChargeProfileActions.java", "diffHunk": "@@ -0,0 +1,406 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bmwconnecteddrive.internal.action;\n+\n+import static org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileWrapper.ProfileKey.*;\n+\n+import java.time.DayOfWeek;\n+import java.time.LocalTime;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.bmwconnecteddrive.internal.handler.VehicleHandler;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileWrapper;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileWrapper.ProfileKey;\n+import org.openhab.core.automation.annotation.ActionInput;\n+import org.openhab.core.automation.annotation.ActionOutput;\n+import org.openhab.core.automation.annotation.RuleAction;\n+import org.openhab.core.thing.binding.ThingActions;\n+import org.openhab.core.thing.binding.ThingActionsScope;\n+import org.openhab.core.thing.binding.ThingHandler;\n+\n+/**\n+ * The {@link ChargeProfileActions} provides actions for VehicleHandler\n+ *\n+ * @author Norbert Truchsess - Initial contribution\n+ */\n+@ThingActionsScope(name = \"chargeprofile\")", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5Nzg2Njk5Ng=="}, "originalCommit": {"oid": "48af48c82562d006b6f2aa35922270f181c885ed"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMjYyNzQ1Mw==", "bodyText": "if a binding has multiple ThingActions-classes and thus multiple scopes those are not grouped beneath each other unless their scopes share a common prefix, don't they?. But the information a common prefix for all ThingAction-classes belonging to the same Thing contains is redundant to the fact the actions belong to the same thing.\nAnd actually this is not just a hypothetical question. I'm planning to add a ThingActions-class to the bmwconnecteddrive-binding for creation and sending of messages containing navigation-destinations to the car. I do not want to prefix those names just for the UI, I'll use scope names without prefix and the UI might then be changed to accommodate this.", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r602627453", "createdAt": "2021-03-26T23:14:44Z", "author": {"login": "ntruchsess"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/action/ChargeProfileActions.java", "diffHunk": "@@ -0,0 +1,406 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bmwconnecteddrive.internal.action;\n+\n+import static org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileWrapper.ProfileKey.*;\n+\n+import java.time.DayOfWeek;\n+import java.time.LocalTime;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.bmwconnecteddrive.internal.handler.VehicleHandler;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileWrapper;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileWrapper.ProfileKey;\n+import org.openhab.core.automation.annotation.ActionInput;\n+import org.openhab.core.automation.annotation.ActionOutput;\n+import org.openhab.core.automation.annotation.RuleAction;\n+import org.openhab.core.thing.binding.ThingActions;\n+import org.openhab.core.thing.binding.ThingActionsScope;\n+import org.openhab.core.thing.binding.ThingHandler;\n+\n+/**\n+ * The {@link ChargeProfileActions} provides actions for VehicleHandler\n+ *\n+ * @author Norbert Truchsess - Initial contribution\n+ */\n+@ThingActionsScope(name = \"chargeprofile\")", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5Nzg2Njk5Ng=="}, "originalCommit": {"oid": "48af48c82562d006b6f2aa35922270f181c885ed"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMjY5MDE0NQ==", "bodyText": "if a binding has multiple ThingActions-classes and thus multiple scopes those are not grouped beneath each other unless their scopes share a common prefix, don't they?\n\nI think so, too.\nYou could file an issue for the UI and core to group the actions by binding. I would check beforehand, if a grouping PR is accepted as we might not discussed the whole story here. I'm not familiar with the insights in core and UI at this place.", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r602690145", "createdAt": "2021-03-27T08:27:58Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/action/ChargeProfileActions.java", "diffHunk": "@@ -0,0 +1,406 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bmwconnecteddrive.internal.action;\n+\n+import static org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileWrapper.ProfileKey.*;\n+\n+import java.time.DayOfWeek;\n+import java.time.LocalTime;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.bmwconnecteddrive.internal.handler.VehicleHandler;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileWrapper;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileWrapper.ProfileKey;\n+import org.openhab.core.automation.annotation.ActionInput;\n+import org.openhab.core.automation.annotation.ActionOutput;\n+import org.openhab.core.automation.annotation.RuleAction;\n+import org.openhab.core.thing.binding.ThingActions;\n+import org.openhab.core.thing.binding.ThingActionsScope;\n+import org.openhab.core.thing.binding.ThingHandler;\n+\n+/**\n+ * The {@link ChargeProfileActions} provides actions for VehicleHandler\n+ *\n+ * @author Norbert Truchsess - Initial contribution\n+ */\n+@ThingActionsScope(name = \"chargeprofile\")", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5Nzg2Njk5Ng=="}, "originalCommit": {"oid": "48af48c82562d006b6f2aa35922270f181c885ed"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwNTc3NzI4MQ==", "bodyText": "I'm a bit puzzeld here. I checked rules creation dialog but didn't find any actions from other bindings. I think just the core actions are in. Besides the BMW binding there's also mqtt active and I would expect the publishMQTTMessage here.", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r605777281", "createdAt": "2021-04-01T16:07:52Z", "author": {"login": "weymann"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/action/ChargeProfileActions.java", "diffHunk": "@@ -0,0 +1,406 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bmwconnecteddrive.internal.action;\n+\n+import static org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileWrapper.ProfileKey.*;\n+\n+import java.time.DayOfWeek;\n+import java.time.LocalTime;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.bmwconnecteddrive.internal.handler.VehicleHandler;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileWrapper;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileWrapper.ProfileKey;\n+import org.openhab.core.automation.annotation.ActionInput;\n+import org.openhab.core.automation.annotation.ActionOutput;\n+import org.openhab.core.automation.annotation.RuleAction;\n+import org.openhab.core.thing.binding.ThingActions;\n+import org.openhab.core.thing.binding.ThingActionsScope;\n+import org.openhab.core.thing.binding.ThingHandler;\n+\n+/**\n+ * The {@link ChargeProfileActions} provides actions for VehicleHandler\n+ *\n+ * @author Norbert Truchsess - Initial contribution\n+ */\n+@ThingActionsScope(name = \"chargeprofile\")", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5Nzg2Njk5Ng=="}, "originalCommit": {"oid": "48af48c82562d006b6f2aa35922270f181c885ed"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwODc1ODMzNw==", "bodyText": "I agree with @ntruchsess that more actions will come. I've already sendPointOfInterest in mind which  can be sent to the vehicle and has nothing to do with the ChargeProfile.\nI searched through all present bindings and found only 2 with more than one Action\n\ncaddx - same naming but on different things - doesn't apply in this case\nmax - has 2 different actions max-cube and max-devices\n\nI think chargeprofile is too generic because it can apply to several upcoming car bindings in the future. Is it a valid approach to add the binding name as prefix like the MAX binding?\n@fwolter Can you give advice here?", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r608758337", "createdAt": "2021-04-07T15:25:00Z", "author": {"login": "weymann"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/action/ChargeProfileActions.java", "diffHunk": "@@ -0,0 +1,406 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bmwconnecteddrive.internal.action;\n+\n+import static org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileWrapper.ProfileKey.*;\n+\n+import java.time.DayOfWeek;\n+import java.time.LocalTime;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.bmwconnecteddrive.internal.handler.VehicleHandler;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileWrapper;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileWrapper.ProfileKey;\n+import org.openhab.core.automation.annotation.ActionInput;\n+import org.openhab.core.automation.annotation.ActionOutput;\n+import org.openhab.core.automation.annotation.RuleAction;\n+import org.openhab.core.thing.binding.ThingActions;\n+import org.openhab.core.thing.binding.ThingActionsScope;\n+import org.openhab.core.thing.binding.ThingHandler;\n+\n+/**\n+ * The {@link ChargeProfileActions} provides actions for VehicleHandler\n+ *\n+ * @author Norbert Truchsess - Initial contribution\n+ */\n+@ThingActionsScope(name = \"chargeprofile\")", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5Nzg2Njk5Ng=="}, "originalCommit": {"oid": "48af48c82562d006b6f2aa35922270f181c885ed"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwODc2MTM4Nw==", "bodyText": "I think so. But I would use a . to separate the binding name from the topic.", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r608761387", "createdAt": "2021-04-07T15:28:10Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/action/ChargeProfileActions.java", "diffHunk": "@@ -0,0 +1,406 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bmwconnecteddrive.internal.action;\n+\n+import static org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileWrapper.ProfileKey.*;\n+\n+import java.time.DayOfWeek;\n+import java.time.LocalTime;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.bmwconnecteddrive.internal.handler.VehicleHandler;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileWrapper;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileWrapper.ProfileKey;\n+import org.openhab.core.automation.annotation.ActionInput;\n+import org.openhab.core.automation.annotation.ActionOutput;\n+import org.openhab.core.automation.annotation.RuleAction;\n+import org.openhab.core.thing.binding.ThingActions;\n+import org.openhab.core.thing.binding.ThingActionsScope;\n+import org.openhab.core.thing.binding.ThingHandler;\n+\n+/**\n+ * The {@link ChargeProfileActions} provides actions for VehicleHandler\n+ *\n+ * @author Norbert Truchsess - Initial contribution\n+ */\n+@ThingActionsScope(name = \"chargeprofile\")", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5Nzg2Njk5Ng=="}, "originalCommit": {"oid": "48af48c82562d006b6f2aa35922270f181c885ed"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwODc3NjA1Mg==", "bodyText": "the scope is valid only for the given thing. So even if multiple bindings use same scopes technically there will be no clash. (Of course any ui that groups 'by scope' should take this into account).\nFrom my point of view prepending the scope with the binding-name is redundant. Of course besides having to type more characters it will do no harm though;-)", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r608776052", "createdAt": "2021-04-07T15:45:11Z", "author": {"login": "ntruchsess"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/action/ChargeProfileActions.java", "diffHunk": "@@ -0,0 +1,406 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bmwconnecteddrive.internal.action;\n+\n+import static org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileWrapper.ProfileKey.*;\n+\n+import java.time.DayOfWeek;\n+import java.time.LocalTime;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.bmwconnecteddrive.internal.handler.VehicleHandler;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileWrapper;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileWrapper.ProfileKey;\n+import org.openhab.core.automation.annotation.ActionInput;\n+import org.openhab.core.automation.annotation.ActionOutput;\n+import org.openhab.core.automation.annotation.RuleAction;\n+import org.openhab.core.thing.binding.ThingActions;\n+import org.openhab.core.thing.binding.ThingActionsScope;\n+import org.openhab.core.thing.binding.ThingHandler;\n+\n+/**\n+ * The {@link ChargeProfileActions} provides actions for VehicleHandler\n+ *\n+ * @author Norbert Truchsess - Initial contribution\n+ */\n+@ThingActionsScope(name = \"chargeprofile\")", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5Nzg2Njk5Ng=="}, "originalCommit": {"oid": "48af48c82562d006b6f2aa35922270f181c885ed"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwODgwOTMyNQ==", "bodyText": "the scope is valid only for the given thing.\n\nWhat's the source of this statement? Genuinely asking.", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r608809325", "createdAt": "2021-04-07T16:25:59Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/action/ChargeProfileActions.java", "diffHunk": "@@ -0,0 +1,406 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bmwconnecteddrive.internal.action;\n+\n+import static org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileWrapper.ProfileKey.*;\n+\n+import java.time.DayOfWeek;\n+import java.time.LocalTime;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.bmwconnecteddrive.internal.handler.VehicleHandler;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileWrapper;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileWrapper.ProfileKey;\n+import org.openhab.core.automation.annotation.ActionInput;\n+import org.openhab.core.automation.annotation.ActionOutput;\n+import org.openhab.core.automation.annotation.RuleAction;\n+import org.openhab.core.thing.binding.ThingActions;\n+import org.openhab.core.thing.binding.ThingActionsScope;\n+import org.openhab.core.thing.binding.ThingHandler;\n+\n+/**\n+ * The {@link ChargeProfileActions} provides actions for VehicleHandler\n+ *\n+ * @author Norbert Truchsess - Initial contribution\n+ */\n+@ThingActionsScope(name = \"chargeprofile\")", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5Nzg2Njk5Ng=="}, "originalCommit": {"oid": "48af48c82562d006b6f2aa35922270f181c885ed"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwODk0NDk1Ng==", "bodyText": "it is in those lengthy specs only few people actually read ;-)", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r608944956", "createdAt": "2021-04-07T19:08:45Z", "author": {"login": "ntruchsess"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/action/ChargeProfileActions.java", "diffHunk": "@@ -0,0 +1,406 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bmwconnecteddrive.internal.action;\n+\n+import static org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileWrapper.ProfileKey.*;\n+\n+import java.time.DayOfWeek;\n+import java.time.LocalTime;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.bmwconnecteddrive.internal.handler.VehicleHandler;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileWrapper;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileWrapper.ProfileKey;\n+import org.openhab.core.automation.annotation.ActionInput;\n+import org.openhab.core.automation.annotation.ActionOutput;\n+import org.openhab.core.automation.annotation.RuleAction;\n+import org.openhab.core.thing.binding.ThingActions;\n+import org.openhab.core.thing.binding.ThingActionsScope;\n+import org.openhab.core.thing.binding.ThingHandler;\n+\n+/**\n+ * The {@link ChargeProfileActions} provides actions for VehicleHandler\n+ *\n+ * @author Norbert Truchsess - Initial contribution\n+ */\n+@ThingActionsScope(name = \"chargeprofile\")", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5Nzg2Njk5Ng=="}, "originalCommit": {"oid": "48af48c82562d006b6f2aa35922270f181c885ed"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxMTA5MDc0OQ==", "bodyText": "I cannot really understand the discussion here. \ud83e\udd14\nWhy isn't a single action class enough? As @fwolter pointed out, a single action class can hold any number of actions, so why should there be a need to split it?\nIt is indeed meant to have the scope be identical to the binding id - this makes it simplest for the user as any exception to this rule can easily lead to mistakes and misunderstandings.\nThe main reason why it is possible to define the scope at all (and not have the binding id applied by the framework automatically) is that there are bindings that consist out of multiple bundles (such as Bluetooth) - in these cases, it must be possible to let the binding extensions also register action classes.\nFor the BMW binding, I'd strongly suggest to go with a single action class, unless I am missing something here.", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r611090749", "createdAt": "2021-04-10T20:38:57Z", "author": {"login": "kaikreuzer"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/action/ChargeProfileActions.java", "diffHunk": "@@ -0,0 +1,406 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bmwconnecteddrive.internal.action;\n+\n+import static org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileWrapper.ProfileKey.*;\n+\n+import java.time.DayOfWeek;\n+import java.time.LocalTime;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.bmwconnecteddrive.internal.handler.VehicleHandler;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileWrapper;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileWrapper.ProfileKey;\n+import org.openhab.core.automation.annotation.ActionInput;\n+import org.openhab.core.automation.annotation.ActionOutput;\n+import org.openhab.core.automation.annotation.RuleAction;\n+import org.openhab.core.thing.binding.ThingActions;\n+import org.openhab.core.thing.binding.ThingActionsScope;\n+import org.openhab.core.thing.binding.ThingHandler;\n+\n+/**\n+ * The {@link ChargeProfileActions} provides actions for VehicleHandler\n+ *\n+ * @author Norbert Truchsess - Initial contribution\n+ */\n+@ThingActionsScope(name = \"chargeprofile\")", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5Nzg2Njk5Ng=="}, "originalCommit": {"oid": "48af48c82562d006b6f2aa35922270f181c885ed"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxMTA5NjY3Mg==", "bodyText": "@kaikreuzer if you don't understand such discussion you should work on the docs. The main reason for this discussion is that there is no documentation regarding this topic (or if there is then it is well hidden) and the source-code doesn't suggest that it should be such either.\nOf course - technically there is no restrictions in number of methods in a single action-class. If there shall only be a single action-class per binding we have to rename the class and some of it's methods as e.g. a 'send' or 'cancel' will be ambigous as soon we add further remoting functionality (like sending points-of-interest)", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r611096672", "createdAt": "2021-04-10T21:42:18Z", "author": {"login": "ntruchsess"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/action/ChargeProfileActions.java", "diffHunk": "@@ -0,0 +1,406 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bmwconnecteddrive.internal.action;\n+\n+import static org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileWrapper.ProfileKey.*;\n+\n+import java.time.DayOfWeek;\n+import java.time.LocalTime;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.bmwconnecteddrive.internal.handler.VehicleHandler;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileWrapper;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileWrapper.ProfileKey;\n+import org.openhab.core.automation.annotation.ActionInput;\n+import org.openhab.core.automation.annotation.ActionOutput;\n+import org.openhab.core.automation.annotation.RuleAction;\n+import org.openhab.core.thing.binding.ThingActions;\n+import org.openhab.core.thing.binding.ThingActionsScope;\n+import org.openhab.core.thing.binding.ThingHandler;\n+\n+/**\n+ * The {@link ChargeProfileActions} provides actions for VehicleHandler\n+ *\n+ * @author Norbert Truchsess - Initial contribution\n+ */\n+@ThingActionsScope(name = \"chargeprofile\")", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5Nzg2Njk5Ng=="}, "originalCommit": {"oid": "48af48c82562d006b6f2aa35922270f181c885ed"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxMTA5Njk2OQ==", "bodyText": "I'm glad that things are clear now.\nYou could file a PR to improve the docs.", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r611096969", "createdAt": "2021-04-10T21:46:10Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/action/ChargeProfileActions.java", "diffHunk": "@@ -0,0 +1,406 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bmwconnecteddrive.internal.action;\n+\n+import static org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileWrapper.ProfileKey.*;\n+\n+import java.time.DayOfWeek;\n+import java.time.LocalTime;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.bmwconnecteddrive.internal.handler.VehicleHandler;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileWrapper;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileWrapper.ProfileKey;\n+import org.openhab.core.automation.annotation.ActionInput;\n+import org.openhab.core.automation.annotation.ActionOutput;\n+import org.openhab.core.automation.annotation.RuleAction;\n+import org.openhab.core.thing.binding.ThingActions;\n+import org.openhab.core.thing.binding.ThingActionsScope;\n+import org.openhab.core.thing.binding.ThingHandler;\n+\n+/**\n+ * The {@link ChargeProfileActions} provides actions for VehicleHandler\n+ *\n+ * @author Norbert Truchsess - Initial contribution\n+ */\n+@ThingActionsScope(name = \"chargeprofile\")", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5Nzg2Njk5Ng=="}, "originalCommit": {"oid": "48af48c82562d006b6f2aa35922270f181c885ed"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxMTA5OTk4NQ==", "bodyText": "Looking at the telegram binding gives a good impression what happens if an unlimited number of thing actions are implemented in one ThingActions class. If everything that is requested in issues (and what is - in most cases - a good idea), we\u2018ll easily end up with 1k+ lines in a single class file (already 650 lines now). This will end up in unmanageable code (like the Connection class in the amazonechocontrol binding).", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r611099985", "createdAt": "2021-04-10T22:18:55Z", "author": {"login": "J-N-K"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/action/ChargeProfileActions.java", "diffHunk": "@@ -0,0 +1,406 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bmwconnecteddrive.internal.action;\n+\n+import static org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileWrapper.ProfileKey.*;\n+\n+import java.time.DayOfWeek;\n+import java.time.LocalTime;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.bmwconnecteddrive.internal.handler.VehicleHandler;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileWrapper;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileWrapper.ProfileKey;\n+import org.openhab.core.automation.annotation.ActionInput;\n+import org.openhab.core.automation.annotation.ActionOutput;\n+import org.openhab.core.automation.annotation.RuleAction;\n+import org.openhab.core.thing.binding.ThingActions;\n+import org.openhab.core.thing.binding.ThingActionsScope;\n+import org.openhab.core.thing.binding.ThingHandler;\n+\n+/**\n+ * The {@link ChargeProfileActions} provides actions for VehicleHandler\n+ *\n+ * @author Norbert Truchsess - Initial contribution\n+ */\n+@ThingActionsScope(name = \"chargeprofile\")", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5Nzg2Njk5Ng=="}, "originalCommit": {"oid": "48af48c82562d006b6f2aa35922270f181c885ed"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxMTE3NjU0Mw==", "bodyText": "I'm glad that things are clear now.\nYou could file a PR to improve the docs.\n\nI don't see how I can improve the docs. If design-decisions and conventions cannot be derived from the code then it must be written by someone who knows the design-decisions. I can only read the code and I've just learned in openhab that is not a reliable source in terms of extracting wanted behaviour.", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r611176543", "createdAt": "2021-04-11T11:50:10Z", "author": {"login": "ntruchsess"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/action/ChargeProfileActions.java", "diffHunk": "@@ -0,0 +1,406 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bmwconnecteddrive.internal.action;\n+\n+import static org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileWrapper.ProfileKey.*;\n+\n+import java.time.DayOfWeek;\n+import java.time.LocalTime;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.bmwconnecteddrive.internal.handler.VehicleHandler;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileWrapper;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileWrapper.ProfileKey;\n+import org.openhab.core.automation.annotation.ActionInput;\n+import org.openhab.core.automation.annotation.ActionOutput;\n+import org.openhab.core.automation.annotation.RuleAction;\n+import org.openhab.core.thing.binding.ThingActions;\n+import org.openhab.core.thing.binding.ThingActionsScope;\n+import org.openhab.core.thing.binding.ThingHandler;\n+\n+/**\n+ * The {@link ChargeProfileActions} provides actions for VehicleHandler\n+ *\n+ * @author Norbert Truchsess - Initial contribution\n+ */\n+@ThingActionsScope(name = \"chargeprofile\")", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5Nzg2Njk5Ng=="}, "originalCommit": {"oid": "48af48c82562d006b6f2aa35922270f181c885ed"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxMTE4NTM5Ng==", "bodyText": "@weymann please merge weymann#15 so we comply with @kaikreuzer s philosophy", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r611185396", "createdAt": "2021-04-11T13:00:35Z", "author": {"login": "ntruchsess"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/action/ChargeProfileActions.java", "diffHunk": "@@ -0,0 +1,406 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bmwconnecteddrive.internal.action;\n+\n+import static org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileWrapper.ProfileKey.*;\n+\n+import java.time.DayOfWeek;\n+import java.time.LocalTime;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.bmwconnecteddrive.internal.handler.VehicleHandler;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileWrapper;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileWrapper.ProfileKey;\n+import org.openhab.core.automation.annotation.ActionInput;\n+import org.openhab.core.automation.annotation.ActionOutput;\n+import org.openhab.core.automation.annotation.RuleAction;\n+import org.openhab.core.thing.binding.ThingActions;\n+import org.openhab.core.thing.binding.ThingActionsScope;\n+import org.openhab.core.thing.binding.ThingHandler;\n+\n+/**\n+ * The {@link ChargeProfileActions} provides actions for VehicleHandler\n+ *\n+ * @author Norbert Truchsess - Initial contribution\n+ */\n+@ThingActionsScope(name = \"chargeprofile\")", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5Nzg2Njk5Ng=="}, "originalCommit": {"oid": "48af48c82562d006b6f2aa35922270f181c885ed"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxMTkxMDA3Nw==", "bodyText": "That's a valid discusion! I raised the issue #10510", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r611910077", "createdAt": "2021-04-12T19:50:49Z", "author": {"login": "weymann"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/action/ChargeProfileActions.java", "diffHunk": "@@ -0,0 +1,406 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bmwconnecteddrive.internal.action;\n+\n+import static org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileWrapper.ProfileKey.*;\n+\n+import java.time.DayOfWeek;\n+import java.time.LocalTime;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.bmwconnecteddrive.internal.handler.VehicleHandler;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileWrapper;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileWrapper.ProfileKey;\n+import org.openhab.core.automation.annotation.ActionInput;\n+import org.openhab.core.automation.annotation.ActionOutput;\n+import org.openhab.core.automation.annotation.RuleAction;\n+import org.openhab.core.thing.binding.ThingActions;\n+import org.openhab.core.thing.binding.ThingActionsScope;\n+import org.openhab.core.thing.binding.ThingHandler;\n+\n+/**\n+ * The {@link ChargeProfileActions} provides actions for VehicleHandler\n+ *\n+ * @author Norbert Truchsess - Initial contribution\n+ */\n+@ThingActionsScope(name = \"chargeprofile\")", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5Nzg2Njk5Ng=="}, "originalCommit": {"oid": "48af48c82562d006b6f2aa35922270f181c885ed"}, "originalPosition": 39}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzc3NjQ1NTU3OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/action/ChargeProfileActions.java", "isResolved": true, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0xOVQxNzo0NTo1NFrOI6K9qg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0yNVQyMTo0NDo1OVrOI9-nLQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5Nzg2Nzk0Ng==", "bodyText": "Is there a reason why you don't add the timer number as an argument to a single common action?", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r597867946", "createdAt": "2021-03-19T17:45:54Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/action/ChargeProfileActions.java", "diffHunk": "@@ -0,0 +1,406 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bmwconnecteddrive.internal.action;\n+\n+import static org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileWrapper.ProfileKey.*;\n+\n+import java.time.DayOfWeek;\n+import java.time.LocalTime;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.bmwconnecteddrive.internal.handler.VehicleHandler;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileWrapper;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileWrapper.ProfileKey;\n+import org.openhab.core.automation.annotation.ActionInput;\n+import org.openhab.core.automation.annotation.ActionOutput;\n+import org.openhab.core.automation.annotation.RuleAction;\n+import org.openhab.core.thing.binding.ThingActions;\n+import org.openhab.core.thing.binding.ThingActionsScope;\n+import org.openhab.core.thing.binding.ThingHandler;\n+\n+/**\n+ * The {@link ChargeProfileActions} provides actions for VehicleHandler\n+ *\n+ * @author Norbert Truchsess - Initial contribution\n+ */\n+@ThingActionsScope(name = \"chargeprofile\")\n+@NonNullByDefault\n+public class ChargeProfileActions implements ThingActions {\n+\n+    private Optional<VehicleHandler> handler = Optional.empty();\n+\n+    private Optional<ChargeProfileWrapper> profile = Optional.empty();\n+\n+    @RuleAction(label = \"getTimer1Departure\", description = \"returns the departure time of timer1\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "48af48c82562d006b6f2aa35922270f181c885ed"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5ODI3MzcyNA==", "bodyText": "The reason is that not all timers are the same - one has a special behaviour (the so called 'Override'-timer).\nOf course for timer 1 to 3 the number could be passed as a parameter but (besides there would be less methods) - is this really any better?", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r598273724", "createdAt": "2021-03-21T12:42:52Z", "author": {"login": "ntruchsess"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/action/ChargeProfileActions.java", "diffHunk": "@@ -0,0 +1,406 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bmwconnecteddrive.internal.action;\n+\n+import static org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileWrapper.ProfileKey.*;\n+\n+import java.time.DayOfWeek;\n+import java.time.LocalTime;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.bmwconnecteddrive.internal.handler.VehicleHandler;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileWrapper;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileWrapper.ProfileKey;\n+import org.openhab.core.automation.annotation.ActionInput;\n+import org.openhab.core.automation.annotation.ActionOutput;\n+import org.openhab.core.automation.annotation.RuleAction;\n+import org.openhab.core.thing.binding.ThingActions;\n+import org.openhab.core.thing.binding.ThingActionsScope;\n+import org.openhab.core.thing.binding.ThingHandler;\n+\n+/**\n+ * The {@link ChargeProfileActions} provides actions for VehicleHandler\n+ *\n+ * @author Norbert Truchsess - Initial contribution\n+ */\n+@ThingActionsScope(name = \"chargeprofile\")\n+@NonNullByDefault\n+public class ChargeProfileActions implements ThingActions {\n+\n+    private Optional<VehicleHandler> handler = Optional.empty();\n+\n+    private Optional<ChargeProfileWrapper> profile = Optional.empty();\n+\n+    @RuleAction(label = \"getTimer1Departure\", description = \"returns the departure time of timer1\")", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5Nzg2Nzk0Ng=="}, "originalCommit": {"oid": "48af48c82562d006b6f2aa35922270f181c885ed"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5ODI3NTM1Mw==", "bodyText": "I think it would make the code cleaner, more concise and thus better maintainable.", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r598275353", "createdAt": "2021-03-21T12:55:05Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/action/ChargeProfileActions.java", "diffHunk": "@@ -0,0 +1,406 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bmwconnecteddrive.internal.action;\n+\n+import static org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileWrapper.ProfileKey.*;\n+\n+import java.time.DayOfWeek;\n+import java.time.LocalTime;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.bmwconnecteddrive.internal.handler.VehicleHandler;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileWrapper;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileWrapper.ProfileKey;\n+import org.openhab.core.automation.annotation.ActionInput;\n+import org.openhab.core.automation.annotation.ActionOutput;\n+import org.openhab.core.automation.annotation.RuleAction;\n+import org.openhab.core.thing.binding.ThingActions;\n+import org.openhab.core.thing.binding.ThingActionsScope;\n+import org.openhab.core.thing.binding.ThingHandler;\n+\n+/**\n+ * The {@link ChargeProfileActions} provides actions for VehicleHandler\n+ *\n+ * @author Norbert Truchsess - Initial contribution\n+ */\n+@ThingActionsScope(name = \"chargeprofile\")\n+@NonNullByDefault\n+public class ChargeProfileActions implements ThingActions {\n+\n+    private Optional<VehicleHandler> handler = Optional.empty();\n+\n+    private Optional<ChargeProfileWrapper> profile = Optional.empty();\n+\n+    @RuleAction(label = \"getTimer1Departure\", description = \"returns the departure time of timer1\")", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5Nzg2Nzk0Ng=="}, "originalCommit": {"oid": "48af48c82562d006b6f2aa35922270f181c885ed"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5ODMyMDQ1NA==", "bodyText": "The properties of a charging-profile are being accessible by a few methods on the ChargeProfileWrapper-class (getTime/setTime, getEnabled/setEnabled, getDays/setDays). That Wrapper is being used both by the actions and by the command-handler. The actual Actions-class is just a dumb wrapper around the ChargeProfileWrapper. Besides hiding the typed keys that are used in ChargeProfileWrapper there is no logic in the Actions class. That also implies there is not much maintainability that one might gain here ;-)\nOf course the Actions-class might just wrap those getTime/setTime-methods of ChargeProfileWrapper, but that would imply exposing the ProfileKey-enum in the scripting-api which makes it harder to use for the script-developer (which is the main reason for the design-decission to offer more methods instead).", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r598320454", "createdAt": "2021-03-21T18:41:39Z", "author": {"login": "ntruchsess"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/action/ChargeProfileActions.java", "diffHunk": "@@ -0,0 +1,406 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bmwconnecteddrive.internal.action;\n+\n+import static org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileWrapper.ProfileKey.*;\n+\n+import java.time.DayOfWeek;\n+import java.time.LocalTime;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.bmwconnecteddrive.internal.handler.VehicleHandler;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileWrapper;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileWrapper.ProfileKey;\n+import org.openhab.core.automation.annotation.ActionInput;\n+import org.openhab.core.automation.annotation.ActionOutput;\n+import org.openhab.core.automation.annotation.RuleAction;\n+import org.openhab.core.thing.binding.ThingActions;\n+import org.openhab.core.thing.binding.ThingActionsScope;\n+import org.openhab.core.thing.binding.ThingHandler;\n+\n+/**\n+ * The {@link ChargeProfileActions} provides actions for VehicleHandler\n+ *\n+ * @author Norbert Truchsess - Initial contribution\n+ */\n+@ThingActionsScope(name = \"chargeprofile\")\n+@NonNullByDefault\n+public class ChargeProfileActions implements ThingActions {\n+\n+    private Optional<VehicleHandler> handler = Optional.empty();\n+\n+    private Optional<ChargeProfileWrapper> profile = Optional.empty();\n+\n+    @RuleAction(label = \"getTimer1Departure\", description = \"returns the departure time of timer1\")", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5Nzg2Nzk0Ng=="}, "originalCommit": {"oid": "48af48c82562d006b6f2aa35922270f181c885ed"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMTg1OTg4NQ==", "bodyText": "OK", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r601859885", "createdAt": "2021-03-25T21:44:59Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/action/ChargeProfileActions.java", "diffHunk": "@@ -0,0 +1,406 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bmwconnecteddrive.internal.action;\n+\n+import static org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileWrapper.ProfileKey.*;\n+\n+import java.time.DayOfWeek;\n+import java.time.LocalTime;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.bmwconnecteddrive.internal.handler.VehicleHandler;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileWrapper;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileWrapper.ProfileKey;\n+import org.openhab.core.automation.annotation.ActionInput;\n+import org.openhab.core.automation.annotation.ActionOutput;\n+import org.openhab.core.automation.annotation.RuleAction;\n+import org.openhab.core.thing.binding.ThingActions;\n+import org.openhab.core.thing.binding.ThingActionsScope;\n+import org.openhab.core.thing.binding.ThingHandler;\n+\n+/**\n+ * The {@link ChargeProfileActions} provides actions for VehicleHandler\n+ *\n+ * @author Norbert Truchsess - Initial contribution\n+ */\n+@ThingActionsScope(name = \"chargeprofile\")\n+@NonNullByDefault\n+public class ChargeProfileActions implements ThingActions {\n+\n+    private Optional<VehicleHandler> handler = Optional.empty();\n+\n+    private Optional<ChargeProfileWrapper> profile = Optional.empty();\n+\n+    @RuleAction(label = \"getTimer1Departure\", description = \"returns the departure time of timer1\")", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5Nzg2Nzk0Ng=="}, "originalCommit": {"oid": "48af48c82562d006b6f2aa35922270f181c885ed"}, "originalPosition": 47}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzc3NjQ4NDY3OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/discovery/VehicleDiscovery.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0xOVQxNzo1MjozMlrOI6LPjA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0yMVQxMTo1MDoxOVrOI6jT-Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5Nzg3MjUyNA==", "bodyText": "It's good practice to append the unit to the field name e.g. TIMEOUT_SEC.", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r597872524", "createdAt": "2021-03-19T17:52:32Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/discovery/VehicleDiscovery.java", "diffHunk": "@@ -0,0 +1,207 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bmwconnecteddrive.internal.discovery;\n+\n+import static org.openhab.binding.bmwconnecteddrive.internal.ConnectedDriveConstants.SUPPORTED_THING_SET;\n+\n+import java.lang.reflect.Field;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.bmwconnecteddrive.internal.ConnectedDriveConstants;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.discovery.VehiclesContainer;\n+import org.openhab.binding.bmwconnecteddrive.internal.handler.ConnectedDriveBridgeHandler;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Constants;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Converter;\n+import org.openhab.core.config.core.Configuration;\n+import org.openhab.core.config.discovery.AbstractDiscoveryService;\n+import org.openhab.core.config.discovery.DiscoveryResultBuilder;\n+import org.openhab.core.config.discovery.DiscoveryService;\n+import org.openhab.core.thing.ThingUID;\n+import org.openhab.core.thing.binding.ThingHandler;\n+import org.openhab.core.thing.binding.ThingHandlerService;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link VehicleDiscovery} requests data from ConnectedDrive and is identifying the Vehicles after response\n+ *\n+ * @author Bernd Weymann - Initial contribution\n+ */\n+@NonNullByDefault\n+public class VehicleDiscovery extends AbstractDiscoveryService implements DiscoveryService, ThingHandlerService {\n+\n+    private final Logger logger = LoggerFactory.getLogger(VehicleDiscovery.class);\n+    private static final int DISCOVERY_TIMEOUT = 10;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "48af48c82562d006b6f2aa35922270f181c885ed"}, "originalPosition": 49}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5ODI2Njg3Mw==", "bodyText": "fixed", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r598266873", "createdAt": "2021-03-21T11:50:19Z", "author": {"login": "weymann"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/discovery/VehicleDiscovery.java", "diffHunk": "@@ -0,0 +1,207 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bmwconnecteddrive.internal.discovery;\n+\n+import static org.openhab.binding.bmwconnecteddrive.internal.ConnectedDriveConstants.SUPPORTED_THING_SET;\n+\n+import java.lang.reflect.Field;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.bmwconnecteddrive.internal.ConnectedDriveConstants;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.discovery.VehiclesContainer;\n+import org.openhab.binding.bmwconnecteddrive.internal.handler.ConnectedDriveBridgeHandler;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Constants;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Converter;\n+import org.openhab.core.config.core.Configuration;\n+import org.openhab.core.config.discovery.AbstractDiscoveryService;\n+import org.openhab.core.config.discovery.DiscoveryResultBuilder;\n+import org.openhab.core.config.discovery.DiscoveryService;\n+import org.openhab.core.thing.ThingUID;\n+import org.openhab.core.thing.binding.ThingHandler;\n+import org.openhab.core.thing.binding.ThingHandlerService;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link VehicleDiscovery} requests data from ConnectedDrive and is identifying the Vehicles after response\n+ *\n+ * @author Bernd Weymann - Initial contribution\n+ */\n+@NonNullByDefault\n+public class VehicleDiscovery extends AbstractDiscoveryService implements DiscoveryService, ThingHandlerService {\n+\n+    private final Logger logger = LoggerFactory.getLogger(VehicleDiscovery.class);\n+    private static final int DISCOVERY_TIMEOUT = 10;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5Nzg3MjUyNA=="}, "originalCommit": {"oid": "48af48c82562d006b6f2aa35922270f181c885ed"}, "originalPosition": 49}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzc3NjQ5Njk0OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/discovery/VehicleDiscovery.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0xOVQxNzo1NTo0N1rOI6LXhQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0yMlQyMjo1Mzo1NFrOI7X4rA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5Nzg3NDU2NQ==", "bodyText": "Actually, the framework takes care that no Things with the same reprentation property are added to the inbox. What is the reason for checking it here?", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r597874565", "createdAt": "2021-03-19T17:55:47Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/discovery/VehicleDiscovery.java", "diffHunk": "@@ -0,0 +1,207 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bmwconnecteddrive.internal.discovery;\n+\n+import static org.openhab.binding.bmwconnecteddrive.internal.ConnectedDriveConstants.SUPPORTED_THING_SET;\n+\n+import java.lang.reflect.Field;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.bmwconnecteddrive.internal.ConnectedDriveConstants;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.discovery.VehiclesContainer;\n+import org.openhab.binding.bmwconnecteddrive.internal.handler.ConnectedDriveBridgeHandler;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Constants;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Converter;\n+import org.openhab.core.config.core.Configuration;\n+import org.openhab.core.config.discovery.AbstractDiscoveryService;\n+import org.openhab.core.config.discovery.DiscoveryResultBuilder;\n+import org.openhab.core.config.discovery.DiscoveryService;\n+import org.openhab.core.thing.ThingUID;\n+import org.openhab.core.thing.binding.ThingHandler;\n+import org.openhab.core.thing.binding.ThingHandlerService;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link VehicleDiscovery} requests data from ConnectedDrive and is identifying the Vehicles after response\n+ *\n+ * @author Bernd Weymann - Initial contribution\n+ */\n+@NonNullByDefault\n+public class VehicleDiscovery extends AbstractDiscoveryService implements DiscoveryService, ThingHandlerService {\n+\n+    private final Logger logger = LoggerFactory.getLogger(VehicleDiscovery.class);\n+    private static final int DISCOVERY_TIMEOUT = 10;\n+    private Optional<ConnectedDriveBridgeHandler> bridgeHandler = Optional.empty();\n+\n+    public VehicleDiscovery() {\n+        super(SUPPORTED_THING_SET, DISCOVERY_TIMEOUT, false);\n+    }\n+\n+    public void onResponse(VehiclesContainer container) {\n+        bridgeHandler.ifPresent(bridge -> {\n+            final ThingUID bridgeUID = bridge.getThing().getUID();\n+            container.vehicles.forEach(vehicle -> {\n+                // the DriveTrain field in the delivered json is defining the Vehicle Type\n+                String vehicleType = vehicle.driveTrain.toLowerCase();\n+                SUPPORTED_THING_SET.forEach(entry -> {\n+                    if (entry.getId().equals(vehicleType)) {\n+                        ThingUID uid = new ThingUID(entry, vehicle.vin, bridgeUID.getId());\n+                        Map<String, String> properties = new HashMap<>();\n+                        // Dealer\n+                        if (vehicle.dealer != null) {\n+                            properties.put(\"dealer\", vehicle.dealer.name);\n+                            properties.put(\"dealerAddress\", vehicle.dealer.street + \" \" + vehicle.dealer.country + \" \"\n+                                    + vehicle.dealer.postalCode + \" \" + vehicle.dealer.city);\n+                            properties.put(\"dealerPhone\", vehicle.dealer.phone);\n+                        }\n+\n+                        // Services & Support\n+                        properties.put(\"servicesActivated\", getObject(vehicle, Constants.ACTIVATED));\n+                        String servicesSupported = getObject(vehicle, Constants.SUPPORTED);\n+                        String servicesNotSupported = getObject(vehicle, Constants.NOT_SUPPORTED);\n+                        if (vehicle.statisticsAvailable) {\n+                            servicesSupported += Constants.STATISTICS;\n+                        } else {\n+                            servicesNotSupported += Constants.STATISTICS;\n+                        }\n+                        properties.put(Constants.SERVICES_SUPPORTED, servicesSupported);\n+                        properties.put(\"servicesNotSupported\", servicesNotSupported);\n+                        properties.put(\"supportBreakdownNumber\", vehicle.breakdownNumber);\n+\n+                        // Vehicle Properties\n+                        if (vehicle.supportedChargingModes != null) {\n+                            properties.put(\"vehicleChargeModes\",\n+                                    String.join(Constants.SPACE, vehicle.supportedChargingModes));\n+                        }\n+                        if (vehicle.hasAlarmSystem) {\n+                            properties.put(\"vehicleAlarmSystem\", \"Available\");\n+                        } else {\n+                            properties.put(\"vehicleAlarmSystem\", \"Not Available\");\n+                        }\n+                        properties.put(\"vehicleBrand\", vehicle.brand);\n+                        properties.put(\"vehicleBodytype\", vehicle.bodytype);\n+                        properties.put(\"vehicleColor\", vehicle.color);\n+                        properties.put(\"vehicleConstructionYear\", Short.toString(vehicle.yearOfConstruction));\n+                        properties.put(\"vehicleDriveTrain\", vehicle.driveTrain);\n+                        properties.put(\"vehicleModel\", vehicle.model);\n+                        if (vehicle.chargingControl != null) {\n+                            properties.put(\"vehicleChargeControl\", Converter.toTitleCase(vehicle.model));\n+                        }\n+\n+                        // Check now if a thing with the same VIN exists\n+                        final AtomicBoolean foundVehicle = new AtomicBoolean(false);\n+                        bridge.getThing().getThings().forEach(vehicleThing -> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "48af48c82562d006b6f2aa35922270f181c885ed"}, "originalPosition": 109}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5OTEyODIzNg==", "bodyText": "Ok, removed", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r599128236", "createdAt": "2021-03-22T22:53:54Z", "author": {"login": "weymann"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/discovery/VehicleDiscovery.java", "diffHunk": "@@ -0,0 +1,207 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bmwconnecteddrive.internal.discovery;\n+\n+import static org.openhab.binding.bmwconnecteddrive.internal.ConnectedDriveConstants.SUPPORTED_THING_SET;\n+\n+import java.lang.reflect.Field;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.bmwconnecteddrive.internal.ConnectedDriveConstants;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.discovery.VehiclesContainer;\n+import org.openhab.binding.bmwconnecteddrive.internal.handler.ConnectedDriveBridgeHandler;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Constants;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Converter;\n+import org.openhab.core.config.core.Configuration;\n+import org.openhab.core.config.discovery.AbstractDiscoveryService;\n+import org.openhab.core.config.discovery.DiscoveryResultBuilder;\n+import org.openhab.core.config.discovery.DiscoveryService;\n+import org.openhab.core.thing.ThingUID;\n+import org.openhab.core.thing.binding.ThingHandler;\n+import org.openhab.core.thing.binding.ThingHandlerService;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link VehicleDiscovery} requests data from ConnectedDrive and is identifying the Vehicles after response\n+ *\n+ * @author Bernd Weymann - Initial contribution\n+ */\n+@NonNullByDefault\n+public class VehicleDiscovery extends AbstractDiscoveryService implements DiscoveryService, ThingHandlerService {\n+\n+    private final Logger logger = LoggerFactory.getLogger(VehicleDiscovery.class);\n+    private static final int DISCOVERY_TIMEOUT = 10;\n+    private Optional<ConnectedDriveBridgeHandler> bridgeHandler = Optional.empty();\n+\n+    public VehicleDiscovery() {\n+        super(SUPPORTED_THING_SET, DISCOVERY_TIMEOUT, false);\n+    }\n+\n+    public void onResponse(VehiclesContainer container) {\n+        bridgeHandler.ifPresent(bridge -> {\n+            final ThingUID bridgeUID = bridge.getThing().getUID();\n+            container.vehicles.forEach(vehicle -> {\n+                // the DriveTrain field in the delivered json is defining the Vehicle Type\n+                String vehicleType = vehicle.driveTrain.toLowerCase();\n+                SUPPORTED_THING_SET.forEach(entry -> {\n+                    if (entry.getId().equals(vehicleType)) {\n+                        ThingUID uid = new ThingUID(entry, vehicle.vin, bridgeUID.getId());\n+                        Map<String, String> properties = new HashMap<>();\n+                        // Dealer\n+                        if (vehicle.dealer != null) {\n+                            properties.put(\"dealer\", vehicle.dealer.name);\n+                            properties.put(\"dealerAddress\", vehicle.dealer.street + \" \" + vehicle.dealer.country + \" \"\n+                                    + vehicle.dealer.postalCode + \" \" + vehicle.dealer.city);\n+                            properties.put(\"dealerPhone\", vehicle.dealer.phone);\n+                        }\n+\n+                        // Services & Support\n+                        properties.put(\"servicesActivated\", getObject(vehicle, Constants.ACTIVATED));\n+                        String servicesSupported = getObject(vehicle, Constants.SUPPORTED);\n+                        String servicesNotSupported = getObject(vehicle, Constants.NOT_SUPPORTED);\n+                        if (vehicle.statisticsAvailable) {\n+                            servicesSupported += Constants.STATISTICS;\n+                        } else {\n+                            servicesNotSupported += Constants.STATISTICS;\n+                        }\n+                        properties.put(Constants.SERVICES_SUPPORTED, servicesSupported);\n+                        properties.put(\"servicesNotSupported\", servicesNotSupported);\n+                        properties.put(\"supportBreakdownNumber\", vehicle.breakdownNumber);\n+\n+                        // Vehicle Properties\n+                        if (vehicle.supportedChargingModes != null) {\n+                            properties.put(\"vehicleChargeModes\",\n+                                    String.join(Constants.SPACE, vehicle.supportedChargingModes));\n+                        }\n+                        if (vehicle.hasAlarmSystem) {\n+                            properties.put(\"vehicleAlarmSystem\", \"Available\");\n+                        } else {\n+                            properties.put(\"vehicleAlarmSystem\", \"Not Available\");\n+                        }\n+                        properties.put(\"vehicleBrand\", vehicle.brand);\n+                        properties.put(\"vehicleBodytype\", vehicle.bodytype);\n+                        properties.put(\"vehicleColor\", vehicle.color);\n+                        properties.put(\"vehicleConstructionYear\", Short.toString(vehicle.yearOfConstruction));\n+                        properties.put(\"vehicleDriveTrain\", vehicle.driveTrain);\n+                        properties.put(\"vehicleModel\", vehicle.model);\n+                        if (vehicle.chargingControl != null) {\n+                            properties.put(\"vehicleChargeControl\", Converter.toTitleCase(vehicle.model));\n+                        }\n+\n+                        // Check now if a thing with the same VIN exists\n+                        final AtomicBoolean foundVehicle = new AtomicBoolean(false);\n+                        bridge.getThing().getThings().forEach(vehicleThing -> {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5Nzg3NDU2NQ=="}, "originalCommit": {"oid": "48af48c82562d006b6f2aa35922270f181c885ed"}, "originalPosition": 109}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzc3NjUxMDk2OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/discovery/VehicleDiscovery.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0xOVQxNzo1OToxN1rOI6LgkA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0yMVQxMjoxMzo0NVrOI6je-w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5Nzg3Njg4MA==", "bodyText": "What is the purpose of overriding this?", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r597876880", "createdAt": "2021-03-19T17:59:17Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/discovery/VehicleDiscovery.java", "diffHunk": "@@ -0,0 +1,207 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bmwconnecteddrive.internal.discovery;\n+\n+import static org.openhab.binding.bmwconnecteddrive.internal.ConnectedDriveConstants.SUPPORTED_THING_SET;\n+\n+import java.lang.reflect.Field;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.bmwconnecteddrive.internal.ConnectedDriveConstants;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.discovery.VehiclesContainer;\n+import org.openhab.binding.bmwconnecteddrive.internal.handler.ConnectedDriveBridgeHandler;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Constants;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Converter;\n+import org.openhab.core.config.core.Configuration;\n+import org.openhab.core.config.discovery.AbstractDiscoveryService;\n+import org.openhab.core.config.discovery.DiscoveryResultBuilder;\n+import org.openhab.core.config.discovery.DiscoveryService;\n+import org.openhab.core.thing.ThingUID;\n+import org.openhab.core.thing.binding.ThingHandler;\n+import org.openhab.core.thing.binding.ThingHandlerService;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link VehicleDiscovery} requests data from ConnectedDrive and is identifying the Vehicles after response\n+ *\n+ * @author Bernd Weymann - Initial contribution\n+ */\n+@NonNullByDefault\n+public class VehicleDiscovery extends AbstractDiscoveryService implements DiscoveryService, ThingHandlerService {\n+\n+    private final Logger logger = LoggerFactory.getLogger(VehicleDiscovery.class);\n+    private static final int DISCOVERY_TIMEOUT = 10;\n+    private Optional<ConnectedDriveBridgeHandler> bridgeHandler = Optional.empty();\n+\n+    public VehicleDiscovery() {\n+        super(SUPPORTED_THING_SET, DISCOVERY_TIMEOUT, false);\n+    }\n+\n+    public void onResponse(VehiclesContainer container) {\n+        bridgeHandler.ifPresent(bridge -> {\n+            final ThingUID bridgeUID = bridge.getThing().getUID();\n+            container.vehicles.forEach(vehicle -> {\n+                // the DriveTrain field in the delivered json is defining the Vehicle Type\n+                String vehicleType = vehicle.driveTrain.toLowerCase();\n+                SUPPORTED_THING_SET.forEach(entry -> {\n+                    if (entry.getId().equals(vehicleType)) {\n+                        ThingUID uid = new ThingUID(entry, vehicle.vin, bridgeUID.getId());\n+                        Map<String, String> properties = new HashMap<>();\n+                        // Dealer\n+                        if (vehicle.dealer != null) {\n+                            properties.put(\"dealer\", vehicle.dealer.name);\n+                            properties.put(\"dealerAddress\", vehicle.dealer.street + \" \" + vehicle.dealer.country + \" \"\n+                                    + vehicle.dealer.postalCode + \" \" + vehicle.dealer.city);\n+                            properties.put(\"dealerPhone\", vehicle.dealer.phone);\n+                        }\n+\n+                        // Services & Support\n+                        properties.put(\"servicesActivated\", getObject(vehicle, Constants.ACTIVATED));\n+                        String servicesSupported = getObject(vehicle, Constants.SUPPORTED);\n+                        String servicesNotSupported = getObject(vehicle, Constants.NOT_SUPPORTED);\n+                        if (vehicle.statisticsAvailable) {\n+                            servicesSupported += Constants.STATISTICS;\n+                        } else {\n+                            servicesNotSupported += Constants.STATISTICS;\n+                        }\n+                        properties.put(Constants.SERVICES_SUPPORTED, servicesSupported);\n+                        properties.put(\"servicesNotSupported\", servicesNotSupported);\n+                        properties.put(\"supportBreakdownNumber\", vehicle.breakdownNumber);\n+\n+                        // Vehicle Properties\n+                        if (vehicle.supportedChargingModes != null) {\n+                            properties.put(\"vehicleChargeModes\",\n+                                    String.join(Constants.SPACE, vehicle.supportedChargingModes));\n+                        }\n+                        if (vehicle.hasAlarmSystem) {\n+                            properties.put(\"vehicleAlarmSystem\", \"Available\");\n+                        } else {\n+                            properties.put(\"vehicleAlarmSystem\", \"Not Available\");\n+                        }\n+                        properties.put(\"vehicleBrand\", vehicle.brand);\n+                        properties.put(\"vehicleBodytype\", vehicle.bodytype);\n+                        properties.put(\"vehicleColor\", vehicle.color);\n+                        properties.put(\"vehicleConstructionYear\", Short.toString(vehicle.yearOfConstruction));\n+                        properties.put(\"vehicleDriveTrain\", vehicle.driveTrain);\n+                        properties.put(\"vehicleModel\", vehicle.model);\n+                        if (vehicle.chargingControl != null) {\n+                            properties.put(\"vehicleChargeControl\", Converter.toTitleCase(vehicle.model));\n+                        }\n+\n+                        // Check now if a thing with the same VIN exists\n+                        final AtomicBoolean foundVehicle = new AtomicBoolean(false);\n+                        bridge.getThing().getThings().forEach(vehicleThing -> {\n+                            Configuration c = vehicleThing.getConfiguration();\n+                            if (c.containsKey(ConnectedDriveConstants.VIN)) {\n+                                String thingVIN = c.get(ConnectedDriveConstants.VIN).toString();\n+                                if (vehicle.vin.equals(thingVIN)) {\n+                                    vehicleThing.setProperties(properties);\n+                                    foundVehicle.set(true);\n+                                }\n+                            }\n+                        });\n+\n+                        // Vehicle not found -> trigger discovery\n+                        if (!foundVehicle.get()) {\n+                            // Properties needed for functional THing\n+                            properties.put(ConnectedDriveConstants.VIN, vehicle.vin);\n+                            properties.put(\"refreshInterval\",\n+                                    Integer.toString(ConnectedDriveConstants.DEFAULT_REFRESH_INTERVAL));\n+                            properties.put(\"units\", ConnectedDriveConstants.UNITS_AUTODETECT);\n+                            properties.put(\"imageSize\", Integer.toString(ConnectedDriveConstants.DEFAULT_IMAGE_SIZE));\n+                            properties.put(\"imageViewport\", ConnectedDriveConstants.DEFAULT_IMAGE_VIEWPORT);\n+\n+                            String vehicleLabel = vehicle.brand + \" \" + vehicle.model;\n+                            Map<String, Object> convertedProperties = new HashMap<String, Object>(properties);\n+                            thingDiscovered(DiscoveryResultBuilder.create(uid).withBridge(bridgeUID)\n+                                    .withRepresentationProperty(ConnectedDriveConstants.VIN).withLabel(vehicleLabel)\n+                                    .withProperties(convertedProperties).build());\n+                        }\n+                    }\n+                });\n+            });\n+        });\n+    };\n+\n+    /**\n+     * Get all field names from a DTO with a specific value\n+     * Used to get e.g. all services which are \"ACTIVATED\"\n+     *\n+     * @param DTO Object\n+     * @param compare String which needs to map with the value\n+     * @return String with all field names matching this value separated with Spaces\n+     */\n+    public String getObject(Object dto, String compare) {\n+        StringBuilder buf = new StringBuilder();\n+        for (Field field : dto.getClass().getDeclaredFields()) {\n+            try {\n+                Object value = field.get(dto);\n+                if (compare.equals(value)) {\n+                    buf.append(Converter.capitalizeFirst(field.getName()) + Constants.SPACE);\n+                }\n+            } catch (IllegalArgumentException | IllegalAccessException e) {\n+                logger.debug(\"Field {} not found {}\", compare, e.getMessage());\n+            }\n+        }\n+        return buf.toString();\n+    }\n+\n+    @Override\n+    public void setThingHandler(ThingHandler handler) {\n+        if (handler instanceof ConnectedDriveBridgeHandler) {\n+            bridgeHandler = Optional.of((ConnectedDriveBridgeHandler) handler);\n+            bridgeHandler.get().setDiscoveryService(this);\n+        }\n+    }\n+\n+    @Override\n+    public @Nullable ThingHandler getThingHandler() {\n+        return bridgeHandler.orElse(null);\n+    }\n+\n+    @Override\n+    public int getScanTimeout() {\n+        return DISCOVERY_TIMEOUT;\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "48af48c82562d006b6f2aa35922270f181c885ed"}, "originalPosition": 181}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5ODI2OTY5MQ==", "bodyText": "No purpose! Was somehow added by Eclipse when adding ThingHandlerService.\nDeleted", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r598269691", "createdAt": "2021-03-21T12:13:45Z", "author": {"login": "weymann"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/discovery/VehicleDiscovery.java", "diffHunk": "@@ -0,0 +1,207 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bmwconnecteddrive.internal.discovery;\n+\n+import static org.openhab.binding.bmwconnecteddrive.internal.ConnectedDriveConstants.SUPPORTED_THING_SET;\n+\n+import java.lang.reflect.Field;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.bmwconnecteddrive.internal.ConnectedDriveConstants;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.discovery.VehiclesContainer;\n+import org.openhab.binding.bmwconnecteddrive.internal.handler.ConnectedDriveBridgeHandler;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Constants;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Converter;\n+import org.openhab.core.config.core.Configuration;\n+import org.openhab.core.config.discovery.AbstractDiscoveryService;\n+import org.openhab.core.config.discovery.DiscoveryResultBuilder;\n+import org.openhab.core.config.discovery.DiscoveryService;\n+import org.openhab.core.thing.ThingUID;\n+import org.openhab.core.thing.binding.ThingHandler;\n+import org.openhab.core.thing.binding.ThingHandlerService;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link VehicleDiscovery} requests data from ConnectedDrive and is identifying the Vehicles after response\n+ *\n+ * @author Bernd Weymann - Initial contribution\n+ */\n+@NonNullByDefault\n+public class VehicleDiscovery extends AbstractDiscoveryService implements DiscoveryService, ThingHandlerService {\n+\n+    private final Logger logger = LoggerFactory.getLogger(VehicleDiscovery.class);\n+    private static final int DISCOVERY_TIMEOUT = 10;\n+    private Optional<ConnectedDriveBridgeHandler> bridgeHandler = Optional.empty();\n+\n+    public VehicleDiscovery() {\n+        super(SUPPORTED_THING_SET, DISCOVERY_TIMEOUT, false);\n+    }\n+\n+    public void onResponse(VehiclesContainer container) {\n+        bridgeHandler.ifPresent(bridge -> {\n+            final ThingUID bridgeUID = bridge.getThing().getUID();\n+            container.vehicles.forEach(vehicle -> {\n+                // the DriveTrain field in the delivered json is defining the Vehicle Type\n+                String vehicleType = vehicle.driveTrain.toLowerCase();\n+                SUPPORTED_THING_SET.forEach(entry -> {\n+                    if (entry.getId().equals(vehicleType)) {\n+                        ThingUID uid = new ThingUID(entry, vehicle.vin, bridgeUID.getId());\n+                        Map<String, String> properties = new HashMap<>();\n+                        // Dealer\n+                        if (vehicle.dealer != null) {\n+                            properties.put(\"dealer\", vehicle.dealer.name);\n+                            properties.put(\"dealerAddress\", vehicle.dealer.street + \" \" + vehicle.dealer.country + \" \"\n+                                    + vehicle.dealer.postalCode + \" \" + vehicle.dealer.city);\n+                            properties.put(\"dealerPhone\", vehicle.dealer.phone);\n+                        }\n+\n+                        // Services & Support\n+                        properties.put(\"servicesActivated\", getObject(vehicle, Constants.ACTIVATED));\n+                        String servicesSupported = getObject(vehicle, Constants.SUPPORTED);\n+                        String servicesNotSupported = getObject(vehicle, Constants.NOT_SUPPORTED);\n+                        if (vehicle.statisticsAvailable) {\n+                            servicesSupported += Constants.STATISTICS;\n+                        } else {\n+                            servicesNotSupported += Constants.STATISTICS;\n+                        }\n+                        properties.put(Constants.SERVICES_SUPPORTED, servicesSupported);\n+                        properties.put(\"servicesNotSupported\", servicesNotSupported);\n+                        properties.put(\"supportBreakdownNumber\", vehicle.breakdownNumber);\n+\n+                        // Vehicle Properties\n+                        if (vehicle.supportedChargingModes != null) {\n+                            properties.put(\"vehicleChargeModes\",\n+                                    String.join(Constants.SPACE, vehicle.supportedChargingModes));\n+                        }\n+                        if (vehicle.hasAlarmSystem) {\n+                            properties.put(\"vehicleAlarmSystem\", \"Available\");\n+                        } else {\n+                            properties.put(\"vehicleAlarmSystem\", \"Not Available\");\n+                        }\n+                        properties.put(\"vehicleBrand\", vehicle.brand);\n+                        properties.put(\"vehicleBodytype\", vehicle.bodytype);\n+                        properties.put(\"vehicleColor\", vehicle.color);\n+                        properties.put(\"vehicleConstructionYear\", Short.toString(vehicle.yearOfConstruction));\n+                        properties.put(\"vehicleDriveTrain\", vehicle.driveTrain);\n+                        properties.put(\"vehicleModel\", vehicle.model);\n+                        if (vehicle.chargingControl != null) {\n+                            properties.put(\"vehicleChargeControl\", Converter.toTitleCase(vehicle.model));\n+                        }\n+\n+                        // Check now if a thing with the same VIN exists\n+                        final AtomicBoolean foundVehicle = new AtomicBoolean(false);\n+                        bridge.getThing().getThings().forEach(vehicleThing -> {\n+                            Configuration c = vehicleThing.getConfiguration();\n+                            if (c.containsKey(ConnectedDriveConstants.VIN)) {\n+                                String thingVIN = c.get(ConnectedDriveConstants.VIN).toString();\n+                                if (vehicle.vin.equals(thingVIN)) {\n+                                    vehicleThing.setProperties(properties);\n+                                    foundVehicle.set(true);\n+                                }\n+                            }\n+                        });\n+\n+                        // Vehicle not found -> trigger discovery\n+                        if (!foundVehicle.get()) {\n+                            // Properties needed for functional THing\n+                            properties.put(ConnectedDriveConstants.VIN, vehicle.vin);\n+                            properties.put(\"refreshInterval\",\n+                                    Integer.toString(ConnectedDriveConstants.DEFAULT_REFRESH_INTERVAL));\n+                            properties.put(\"units\", ConnectedDriveConstants.UNITS_AUTODETECT);\n+                            properties.put(\"imageSize\", Integer.toString(ConnectedDriveConstants.DEFAULT_IMAGE_SIZE));\n+                            properties.put(\"imageViewport\", ConnectedDriveConstants.DEFAULT_IMAGE_VIEWPORT);\n+\n+                            String vehicleLabel = vehicle.brand + \" \" + vehicle.model;\n+                            Map<String, Object> convertedProperties = new HashMap<String, Object>(properties);\n+                            thingDiscovered(DiscoveryResultBuilder.create(uid).withBridge(bridgeUID)\n+                                    .withRepresentationProperty(ConnectedDriveConstants.VIN).withLabel(vehicleLabel)\n+                                    .withProperties(convertedProperties).build());\n+                        }\n+                    }\n+                });\n+            });\n+        });\n+    };\n+\n+    /**\n+     * Get all field names from a DTO with a specific value\n+     * Used to get e.g. all services which are \"ACTIVATED\"\n+     *\n+     * @param DTO Object\n+     * @param compare String which needs to map with the value\n+     * @return String with all field names matching this value separated with Spaces\n+     */\n+    public String getObject(Object dto, String compare) {\n+        StringBuilder buf = new StringBuilder();\n+        for (Field field : dto.getClass().getDeclaredFields()) {\n+            try {\n+                Object value = field.get(dto);\n+                if (compare.equals(value)) {\n+                    buf.append(Converter.capitalizeFirst(field.getName()) + Constants.SPACE);\n+                }\n+            } catch (IllegalArgumentException | IllegalAccessException e) {\n+                logger.debug(\"Field {} not found {}\", compare, e.getMessage());\n+            }\n+        }\n+        return buf.toString();\n+    }\n+\n+    @Override\n+    public void setThingHandler(ThingHandler handler) {\n+        if (handler instanceof ConnectedDriveBridgeHandler) {\n+            bridgeHandler = Optional.of((ConnectedDriveBridgeHandler) handler);\n+            bridgeHandler.get().setDiscoveryService(this);\n+        }\n+    }\n+\n+    @Override\n+    public @Nullable ThingHandler getThingHandler() {\n+        return bridgeHandler.orElse(null);\n+    }\n+\n+    @Override\n+    public int getScanTimeout() {\n+        return DISCOVERY_TIMEOUT;\n+    }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5Nzg3Njg4MA=="}, "originalCommit": {"oid": "48af48c82562d006b6f2aa35922270f181c885ed"}, "originalPosition": 181}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzc3NjUxNDcwOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/discovery/VehicleDiscovery.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0xOVQxODowMDoxMFrOI6Li5w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0yMVQxMjoxNDoyOVrOI6jfQQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5Nzg3NzQ3OQ==", "bodyText": "Same as above. Purpose.", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r597877479", "createdAt": "2021-03-19T18:00:10Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/discovery/VehicleDiscovery.java", "diffHunk": "@@ -0,0 +1,207 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bmwconnecteddrive.internal.discovery;\n+\n+import static org.openhab.binding.bmwconnecteddrive.internal.ConnectedDriveConstants.SUPPORTED_THING_SET;\n+\n+import java.lang.reflect.Field;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.bmwconnecteddrive.internal.ConnectedDriveConstants;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.discovery.VehiclesContainer;\n+import org.openhab.binding.bmwconnecteddrive.internal.handler.ConnectedDriveBridgeHandler;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Constants;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Converter;\n+import org.openhab.core.config.core.Configuration;\n+import org.openhab.core.config.discovery.AbstractDiscoveryService;\n+import org.openhab.core.config.discovery.DiscoveryResultBuilder;\n+import org.openhab.core.config.discovery.DiscoveryService;\n+import org.openhab.core.thing.ThingUID;\n+import org.openhab.core.thing.binding.ThingHandler;\n+import org.openhab.core.thing.binding.ThingHandlerService;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link VehicleDiscovery} requests data from ConnectedDrive and is identifying the Vehicles after response\n+ *\n+ * @author Bernd Weymann - Initial contribution\n+ */\n+@NonNullByDefault\n+public class VehicleDiscovery extends AbstractDiscoveryService implements DiscoveryService, ThingHandlerService {\n+\n+    private final Logger logger = LoggerFactory.getLogger(VehicleDiscovery.class);\n+    private static final int DISCOVERY_TIMEOUT = 10;\n+    private Optional<ConnectedDriveBridgeHandler> bridgeHandler = Optional.empty();\n+\n+    public VehicleDiscovery() {\n+        super(SUPPORTED_THING_SET, DISCOVERY_TIMEOUT, false);\n+    }\n+\n+    public void onResponse(VehiclesContainer container) {\n+        bridgeHandler.ifPresent(bridge -> {\n+            final ThingUID bridgeUID = bridge.getThing().getUID();\n+            container.vehicles.forEach(vehicle -> {\n+                // the DriveTrain field in the delivered json is defining the Vehicle Type\n+                String vehicleType = vehicle.driveTrain.toLowerCase();\n+                SUPPORTED_THING_SET.forEach(entry -> {\n+                    if (entry.getId().equals(vehicleType)) {\n+                        ThingUID uid = new ThingUID(entry, vehicle.vin, bridgeUID.getId());\n+                        Map<String, String> properties = new HashMap<>();\n+                        // Dealer\n+                        if (vehicle.dealer != null) {\n+                            properties.put(\"dealer\", vehicle.dealer.name);\n+                            properties.put(\"dealerAddress\", vehicle.dealer.street + \" \" + vehicle.dealer.country + \" \"\n+                                    + vehicle.dealer.postalCode + \" \" + vehicle.dealer.city);\n+                            properties.put(\"dealerPhone\", vehicle.dealer.phone);\n+                        }\n+\n+                        // Services & Support\n+                        properties.put(\"servicesActivated\", getObject(vehicle, Constants.ACTIVATED));\n+                        String servicesSupported = getObject(vehicle, Constants.SUPPORTED);\n+                        String servicesNotSupported = getObject(vehicle, Constants.NOT_SUPPORTED);\n+                        if (vehicle.statisticsAvailable) {\n+                            servicesSupported += Constants.STATISTICS;\n+                        } else {\n+                            servicesNotSupported += Constants.STATISTICS;\n+                        }\n+                        properties.put(Constants.SERVICES_SUPPORTED, servicesSupported);\n+                        properties.put(\"servicesNotSupported\", servicesNotSupported);\n+                        properties.put(\"supportBreakdownNumber\", vehicle.breakdownNumber);\n+\n+                        // Vehicle Properties\n+                        if (vehicle.supportedChargingModes != null) {\n+                            properties.put(\"vehicleChargeModes\",\n+                                    String.join(Constants.SPACE, vehicle.supportedChargingModes));\n+                        }\n+                        if (vehicle.hasAlarmSystem) {\n+                            properties.put(\"vehicleAlarmSystem\", \"Available\");\n+                        } else {\n+                            properties.put(\"vehicleAlarmSystem\", \"Not Available\");\n+                        }\n+                        properties.put(\"vehicleBrand\", vehicle.brand);\n+                        properties.put(\"vehicleBodytype\", vehicle.bodytype);\n+                        properties.put(\"vehicleColor\", vehicle.color);\n+                        properties.put(\"vehicleConstructionYear\", Short.toString(vehicle.yearOfConstruction));\n+                        properties.put(\"vehicleDriveTrain\", vehicle.driveTrain);\n+                        properties.put(\"vehicleModel\", vehicle.model);\n+                        if (vehicle.chargingControl != null) {\n+                            properties.put(\"vehicleChargeControl\", Converter.toTitleCase(vehicle.model));\n+                        }\n+\n+                        // Check now if a thing with the same VIN exists\n+                        final AtomicBoolean foundVehicle = new AtomicBoolean(false);\n+                        bridge.getThing().getThings().forEach(vehicleThing -> {\n+                            Configuration c = vehicleThing.getConfiguration();\n+                            if (c.containsKey(ConnectedDriveConstants.VIN)) {\n+                                String thingVIN = c.get(ConnectedDriveConstants.VIN).toString();\n+                                if (vehicle.vin.equals(thingVIN)) {\n+                                    vehicleThing.setProperties(properties);\n+                                    foundVehicle.set(true);\n+                                }\n+                            }\n+                        });\n+\n+                        // Vehicle not found -> trigger discovery\n+                        if (!foundVehicle.get()) {\n+                            // Properties needed for functional THing\n+                            properties.put(ConnectedDriveConstants.VIN, vehicle.vin);\n+                            properties.put(\"refreshInterval\",\n+                                    Integer.toString(ConnectedDriveConstants.DEFAULT_REFRESH_INTERVAL));\n+                            properties.put(\"units\", ConnectedDriveConstants.UNITS_AUTODETECT);\n+                            properties.put(\"imageSize\", Integer.toString(ConnectedDriveConstants.DEFAULT_IMAGE_SIZE));\n+                            properties.put(\"imageViewport\", ConnectedDriveConstants.DEFAULT_IMAGE_VIEWPORT);\n+\n+                            String vehicleLabel = vehicle.brand + \" \" + vehicle.model;\n+                            Map<String, Object> convertedProperties = new HashMap<String, Object>(properties);\n+                            thingDiscovered(DiscoveryResultBuilder.create(uid).withBridge(bridgeUID)\n+                                    .withRepresentationProperty(ConnectedDriveConstants.VIN).withLabel(vehicleLabel)\n+                                    .withProperties(convertedProperties).build());\n+                        }\n+                    }\n+                });\n+            });\n+        });\n+    };\n+\n+    /**\n+     * Get all field names from a DTO with a specific value\n+     * Used to get e.g. all services which are \"ACTIVATED\"\n+     *\n+     * @param DTO Object\n+     * @param compare String which needs to map with the value\n+     * @return String with all field names matching this value separated with Spaces\n+     */\n+    public String getObject(Object dto, String compare) {\n+        StringBuilder buf = new StringBuilder();\n+        for (Field field : dto.getClass().getDeclaredFields()) {\n+            try {\n+                Object value = field.get(dto);\n+                if (compare.equals(value)) {\n+                    buf.append(Converter.capitalizeFirst(field.getName()) + Constants.SPACE);\n+                }\n+            } catch (IllegalArgumentException | IllegalAccessException e) {\n+                logger.debug(\"Field {} not found {}\", compare, e.getMessage());\n+            }\n+        }\n+        return buf.toString();\n+    }\n+\n+    @Override\n+    public void setThingHandler(ThingHandler handler) {\n+        if (handler instanceof ConnectedDriveBridgeHandler) {\n+            bridgeHandler = Optional.of((ConnectedDriveBridgeHandler) handler);\n+            bridgeHandler.get().setDiscoveryService(this);\n+        }\n+    }\n+\n+    @Override\n+    public @Nullable ThingHandler getThingHandler() {\n+        return bridgeHandler.orElse(null);\n+    }\n+\n+    @Override\n+    public int getScanTimeout() {\n+        return DISCOVERY_TIMEOUT;\n+    }\n+\n+    @Override\n+    public boolean isBackgroundDiscoveryEnabled() {\n+        return false;\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "48af48c82562d006b6f2aa35922270f181c885ed"}, "originalPosition": 186}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5ODI2OTc2MQ==", "bodyText": "No purpose, same comment as above", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r598269761", "createdAt": "2021-03-21T12:14:29Z", "author": {"login": "weymann"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/discovery/VehicleDiscovery.java", "diffHunk": "@@ -0,0 +1,207 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bmwconnecteddrive.internal.discovery;\n+\n+import static org.openhab.binding.bmwconnecteddrive.internal.ConnectedDriveConstants.SUPPORTED_THING_SET;\n+\n+import java.lang.reflect.Field;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.bmwconnecteddrive.internal.ConnectedDriveConstants;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.discovery.VehiclesContainer;\n+import org.openhab.binding.bmwconnecteddrive.internal.handler.ConnectedDriveBridgeHandler;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Constants;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Converter;\n+import org.openhab.core.config.core.Configuration;\n+import org.openhab.core.config.discovery.AbstractDiscoveryService;\n+import org.openhab.core.config.discovery.DiscoveryResultBuilder;\n+import org.openhab.core.config.discovery.DiscoveryService;\n+import org.openhab.core.thing.ThingUID;\n+import org.openhab.core.thing.binding.ThingHandler;\n+import org.openhab.core.thing.binding.ThingHandlerService;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link VehicleDiscovery} requests data from ConnectedDrive and is identifying the Vehicles after response\n+ *\n+ * @author Bernd Weymann - Initial contribution\n+ */\n+@NonNullByDefault\n+public class VehicleDiscovery extends AbstractDiscoveryService implements DiscoveryService, ThingHandlerService {\n+\n+    private final Logger logger = LoggerFactory.getLogger(VehicleDiscovery.class);\n+    private static final int DISCOVERY_TIMEOUT = 10;\n+    private Optional<ConnectedDriveBridgeHandler> bridgeHandler = Optional.empty();\n+\n+    public VehicleDiscovery() {\n+        super(SUPPORTED_THING_SET, DISCOVERY_TIMEOUT, false);\n+    }\n+\n+    public void onResponse(VehiclesContainer container) {\n+        bridgeHandler.ifPresent(bridge -> {\n+            final ThingUID bridgeUID = bridge.getThing().getUID();\n+            container.vehicles.forEach(vehicle -> {\n+                // the DriveTrain field in the delivered json is defining the Vehicle Type\n+                String vehicleType = vehicle.driveTrain.toLowerCase();\n+                SUPPORTED_THING_SET.forEach(entry -> {\n+                    if (entry.getId().equals(vehicleType)) {\n+                        ThingUID uid = new ThingUID(entry, vehicle.vin, bridgeUID.getId());\n+                        Map<String, String> properties = new HashMap<>();\n+                        // Dealer\n+                        if (vehicle.dealer != null) {\n+                            properties.put(\"dealer\", vehicle.dealer.name);\n+                            properties.put(\"dealerAddress\", vehicle.dealer.street + \" \" + vehicle.dealer.country + \" \"\n+                                    + vehicle.dealer.postalCode + \" \" + vehicle.dealer.city);\n+                            properties.put(\"dealerPhone\", vehicle.dealer.phone);\n+                        }\n+\n+                        // Services & Support\n+                        properties.put(\"servicesActivated\", getObject(vehicle, Constants.ACTIVATED));\n+                        String servicesSupported = getObject(vehicle, Constants.SUPPORTED);\n+                        String servicesNotSupported = getObject(vehicle, Constants.NOT_SUPPORTED);\n+                        if (vehicle.statisticsAvailable) {\n+                            servicesSupported += Constants.STATISTICS;\n+                        } else {\n+                            servicesNotSupported += Constants.STATISTICS;\n+                        }\n+                        properties.put(Constants.SERVICES_SUPPORTED, servicesSupported);\n+                        properties.put(\"servicesNotSupported\", servicesNotSupported);\n+                        properties.put(\"supportBreakdownNumber\", vehicle.breakdownNumber);\n+\n+                        // Vehicle Properties\n+                        if (vehicle.supportedChargingModes != null) {\n+                            properties.put(\"vehicleChargeModes\",\n+                                    String.join(Constants.SPACE, vehicle.supportedChargingModes));\n+                        }\n+                        if (vehicle.hasAlarmSystem) {\n+                            properties.put(\"vehicleAlarmSystem\", \"Available\");\n+                        } else {\n+                            properties.put(\"vehicleAlarmSystem\", \"Not Available\");\n+                        }\n+                        properties.put(\"vehicleBrand\", vehicle.brand);\n+                        properties.put(\"vehicleBodytype\", vehicle.bodytype);\n+                        properties.put(\"vehicleColor\", vehicle.color);\n+                        properties.put(\"vehicleConstructionYear\", Short.toString(vehicle.yearOfConstruction));\n+                        properties.put(\"vehicleDriveTrain\", vehicle.driveTrain);\n+                        properties.put(\"vehicleModel\", vehicle.model);\n+                        if (vehicle.chargingControl != null) {\n+                            properties.put(\"vehicleChargeControl\", Converter.toTitleCase(vehicle.model));\n+                        }\n+\n+                        // Check now if a thing with the same VIN exists\n+                        final AtomicBoolean foundVehicle = new AtomicBoolean(false);\n+                        bridge.getThing().getThings().forEach(vehicleThing -> {\n+                            Configuration c = vehicleThing.getConfiguration();\n+                            if (c.containsKey(ConnectedDriveConstants.VIN)) {\n+                                String thingVIN = c.get(ConnectedDriveConstants.VIN).toString();\n+                                if (vehicle.vin.equals(thingVIN)) {\n+                                    vehicleThing.setProperties(properties);\n+                                    foundVehicle.set(true);\n+                                }\n+                            }\n+                        });\n+\n+                        // Vehicle not found -> trigger discovery\n+                        if (!foundVehicle.get()) {\n+                            // Properties needed for functional THing\n+                            properties.put(ConnectedDriveConstants.VIN, vehicle.vin);\n+                            properties.put(\"refreshInterval\",\n+                                    Integer.toString(ConnectedDriveConstants.DEFAULT_REFRESH_INTERVAL));\n+                            properties.put(\"units\", ConnectedDriveConstants.UNITS_AUTODETECT);\n+                            properties.put(\"imageSize\", Integer.toString(ConnectedDriveConstants.DEFAULT_IMAGE_SIZE));\n+                            properties.put(\"imageViewport\", ConnectedDriveConstants.DEFAULT_IMAGE_VIEWPORT);\n+\n+                            String vehicleLabel = vehicle.brand + \" \" + vehicle.model;\n+                            Map<String, Object> convertedProperties = new HashMap<String, Object>(properties);\n+                            thingDiscovered(DiscoveryResultBuilder.create(uid).withBridge(bridgeUID)\n+                                    .withRepresentationProperty(ConnectedDriveConstants.VIN).withLabel(vehicleLabel)\n+                                    .withProperties(convertedProperties).build());\n+                        }\n+                    }\n+                });\n+            });\n+        });\n+    };\n+\n+    /**\n+     * Get all field names from a DTO with a specific value\n+     * Used to get e.g. all services which are \"ACTIVATED\"\n+     *\n+     * @param DTO Object\n+     * @param compare String which needs to map with the value\n+     * @return String with all field names matching this value separated with Spaces\n+     */\n+    public String getObject(Object dto, String compare) {\n+        StringBuilder buf = new StringBuilder();\n+        for (Field field : dto.getClass().getDeclaredFields()) {\n+            try {\n+                Object value = field.get(dto);\n+                if (compare.equals(value)) {\n+                    buf.append(Converter.capitalizeFirst(field.getName()) + Constants.SPACE);\n+                }\n+            } catch (IllegalArgumentException | IllegalAccessException e) {\n+                logger.debug(\"Field {} not found {}\", compare, e.getMessage());\n+            }\n+        }\n+        return buf.toString();\n+    }\n+\n+    @Override\n+    public void setThingHandler(ThingHandler handler) {\n+        if (handler instanceof ConnectedDriveBridgeHandler) {\n+            bridgeHandler = Optional.of((ConnectedDriveBridgeHandler) handler);\n+            bridgeHandler.get().setDiscoveryService(this);\n+        }\n+    }\n+\n+    @Override\n+    public @Nullable ThingHandler getThingHandler() {\n+        return bridgeHandler.orElse(null);\n+    }\n+\n+    @Override\n+    public int getScanTimeout() {\n+        return DISCOVERY_TIMEOUT;\n+    }\n+\n+    @Override\n+    public boolean isBackgroundDiscoveryEnabled() {\n+        return false;\n+    }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5Nzg3NzQ3OQ=="}, "originalCommit": {"oid": "48af48c82562d006b6f2aa35922270f181c885ed"}, "originalPosition": 186}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzc3NjUxNTMwOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/discovery/VehicleDiscovery.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0xOVQxODowMDoxOFrOI6LjSA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0yMVQxMjoxNDo0N1rOI6jfXA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5Nzg3NzU3Ng==", "bodyText": "Same as above. Purpose.", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r597877576", "createdAt": "2021-03-19T18:00:18Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/discovery/VehicleDiscovery.java", "diffHunk": "@@ -0,0 +1,207 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bmwconnecteddrive.internal.discovery;\n+\n+import static org.openhab.binding.bmwconnecteddrive.internal.ConnectedDriveConstants.SUPPORTED_THING_SET;\n+\n+import java.lang.reflect.Field;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.bmwconnecteddrive.internal.ConnectedDriveConstants;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.discovery.VehiclesContainer;\n+import org.openhab.binding.bmwconnecteddrive.internal.handler.ConnectedDriveBridgeHandler;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Constants;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Converter;\n+import org.openhab.core.config.core.Configuration;\n+import org.openhab.core.config.discovery.AbstractDiscoveryService;\n+import org.openhab.core.config.discovery.DiscoveryResultBuilder;\n+import org.openhab.core.config.discovery.DiscoveryService;\n+import org.openhab.core.thing.ThingUID;\n+import org.openhab.core.thing.binding.ThingHandler;\n+import org.openhab.core.thing.binding.ThingHandlerService;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link VehicleDiscovery} requests data from ConnectedDrive and is identifying the Vehicles after response\n+ *\n+ * @author Bernd Weymann - Initial contribution\n+ */\n+@NonNullByDefault\n+public class VehicleDiscovery extends AbstractDiscoveryService implements DiscoveryService, ThingHandlerService {\n+\n+    private final Logger logger = LoggerFactory.getLogger(VehicleDiscovery.class);\n+    private static final int DISCOVERY_TIMEOUT = 10;\n+    private Optional<ConnectedDriveBridgeHandler> bridgeHandler = Optional.empty();\n+\n+    public VehicleDiscovery() {\n+        super(SUPPORTED_THING_SET, DISCOVERY_TIMEOUT, false);\n+    }\n+\n+    public void onResponse(VehiclesContainer container) {\n+        bridgeHandler.ifPresent(bridge -> {\n+            final ThingUID bridgeUID = bridge.getThing().getUID();\n+            container.vehicles.forEach(vehicle -> {\n+                // the DriveTrain field in the delivered json is defining the Vehicle Type\n+                String vehicleType = vehicle.driveTrain.toLowerCase();\n+                SUPPORTED_THING_SET.forEach(entry -> {\n+                    if (entry.getId().equals(vehicleType)) {\n+                        ThingUID uid = new ThingUID(entry, vehicle.vin, bridgeUID.getId());\n+                        Map<String, String> properties = new HashMap<>();\n+                        // Dealer\n+                        if (vehicle.dealer != null) {\n+                            properties.put(\"dealer\", vehicle.dealer.name);\n+                            properties.put(\"dealerAddress\", vehicle.dealer.street + \" \" + vehicle.dealer.country + \" \"\n+                                    + vehicle.dealer.postalCode + \" \" + vehicle.dealer.city);\n+                            properties.put(\"dealerPhone\", vehicle.dealer.phone);\n+                        }\n+\n+                        // Services & Support\n+                        properties.put(\"servicesActivated\", getObject(vehicle, Constants.ACTIVATED));\n+                        String servicesSupported = getObject(vehicle, Constants.SUPPORTED);\n+                        String servicesNotSupported = getObject(vehicle, Constants.NOT_SUPPORTED);\n+                        if (vehicle.statisticsAvailable) {\n+                            servicesSupported += Constants.STATISTICS;\n+                        } else {\n+                            servicesNotSupported += Constants.STATISTICS;\n+                        }\n+                        properties.put(Constants.SERVICES_SUPPORTED, servicesSupported);\n+                        properties.put(\"servicesNotSupported\", servicesNotSupported);\n+                        properties.put(\"supportBreakdownNumber\", vehicle.breakdownNumber);\n+\n+                        // Vehicle Properties\n+                        if (vehicle.supportedChargingModes != null) {\n+                            properties.put(\"vehicleChargeModes\",\n+                                    String.join(Constants.SPACE, vehicle.supportedChargingModes));\n+                        }\n+                        if (vehicle.hasAlarmSystem) {\n+                            properties.put(\"vehicleAlarmSystem\", \"Available\");\n+                        } else {\n+                            properties.put(\"vehicleAlarmSystem\", \"Not Available\");\n+                        }\n+                        properties.put(\"vehicleBrand\", vehicle.brand);\n+                        properties.put(\"vehicleBodytype\", vehicle.bodytype);\n+                        properties.put(\"vehicleColor\", vehicle.color);\n+                        properties.put(\"vehicleConstructionYear\", Short.toString(vehicle.yearOfConstruction));\n+                        properties.put(\"vehicleDriveTrain\", vehicle.driveTrain);\n+                        properties.put(\"vehicleModel\", vehicle.model);\n+                        if (vehicle.chargingControl != null) {\n+                            properties.put(\"vehicleChargeControl\", Converter.toTitleCase(vehicle.model));\n+                        }\n+\n+                        // Check now if a thing with the same VIN exists\n+                        final AtomicBoolean foundVehicle = new AtomicBoolean(false);\n+                        bridge.getThing().getThings().forEach(vehicleThing -> {\n+                            Configuration c = vehicleThing.getConfiguration();\n+                            if (c.containsKey(ConnectedDriveConstants.VIN)) {\n+                                String thingVIN = c.get(ConnectedDriveConstants.VIN).toString();\n+                                if (vehicle.vin.equals(thingVIN)) {\n+                                    vehicleThing.setProperties(properties);\n+                                    foundVehicle.set(true);\n+                                }\n+                            }\n+                        });\n+\n+                        // Vehicle not found -> trigger discovery\n+                        if (!foundVehicle.get()) {\n+                            // Properties needed for functional THing\n+                            properties.put(ConnectedDriveConstants.VIN, vehicle.vin);\n+                            properties.put(\"refreshInterval\",\n+                                    Integer.toString(ConnectedDriveConstants.DEFAULT_REFRESH_INTERVAL));\n+                            properties.put(\"units\", ConnectedDriveConstants.UNITS_AUTODETECT);\n+                            properties.put(\"imageSize\", Integer.toString(ConnectedDriveConstants.DEFAULT_IMAGE_SIZE));\n+                            properties.put(\"imageViewport\", ConnectedDriveConstants.DEFAULT_IMAGE_VIEWPORT);\n+\n+                            String vehicleLabel = vehicle.brand + \" \" + vehicle.model;\n+                            Map<String, Object> convertedProperties = new HashMap<String, Object>(properties);\n+                            thingDiscovered(DiscoveryResultBuilder.create(uid).withBridge(bridgeUID)\n+                                    .withRepresentationProperty(ConnectedDriveConstants.VIN).withLabel(vehicleLabel)\n+                                    .withProperties(convertedProperties).build());\n+                        }\n+                    }\n+                });\n+            });\n+        });\n+    };\n+\n+    /**\n+     * Get all field names from a DTO with a specific value\n+     * Used to get e.g. all services which are \"ACTIVATED\"\n+     *\n+     * @param DTO Object\n+     * @param compare String which needs to map with the value\n+     * @return String with all field names matching this value separated with Spaces\n+     */\n+    public String getObject(Object dto, String compare) {\n+        StringBuilder buf = new StringBuilder();\n+        for (Field field : dto.getClass().getDeclaredFields()) {\n+            try {\n+                Object value = field.get(dto);\n+                if (compare.equals(value)) {\n+                    buf.append(Converter.capitalizeFirst(field.getName()) + Constants.SPACE);\n+                }\n+            } catch (IllegalArgumentException | IllegalAccessException e) {\n+                logger.debug(\"Field {} not found {}\", compare, e.getMessage());\n+            }\n+        }\n+        return buf.toString();\n+    }\n+\n+    @Override\n+    public void setThingHandler(ThingHandler handler) {\n+        if (handler instanceof ConnectedDriveBridgeHandler) {\n+            bridgeHandler = Optional.of((ConnectedDriveBridgeHandler) handler);\n+            bridgeHandler.get().setDiscoveryService(this);\n+        }\n+    }\n+\n+    @Override\n+    public @Nullable ThingHandler getThingHandler() {\n+        return bridgeHandler.orElse(null);\n+    }\n+\n+    @Override\n+    public int getScanTimeout() {\n+        return DISCOVERY_TIMEOUT;\n+    }\n+\n+    @Override\n+    public boolean isBackgroundDiscoveryEnabled() {\n+        return false;\n+    }\n+\n+    @Override\n+    protected void startScan() {\n+        bridgeHandler.ifPresent(ConnectedDriveBridgeHandler::requestVehicles);\n+    }\n+\n+    @Override\n+    public void abortScan() {\n+        // nothing to abort\n+    }\n+\n+    @Override\n+    public void activate() {\n+        super.activate(null);\n+    }\n+\n+    @Override\n+    public void deactivate() {\n+        super.deactivate();\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "48af48c82562d006b6f2aa35922270f181c885ed"}, "originalPosition": 206}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5ODI2OTc4OA==", "bodyText": "No purpose, but need to keep deactivate due to compiler error\n[ERROR] C:\\Users\\bernd\\openhab-master\\git\\openhab-addons\\bundles\\org.openhab.binding.bmwconnecteddrive\\src\\main\\java\\org\\openhab\\binding\\bmwconnecteddrive\\internal\\discovery\\VehicleDiscovery.java:[46,14] The inherited method org.openhab.core.config.discovery.AbstractDiscoveryService.deactivate() cannot hide the public abstract method in org.openhab.core.thing.binding.ThingHandlerService", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r598269788", "createdAt": "2021-03-21T12:14:47Z", "author": {"login": "weymann"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/discovery/VehicleDiscovery.java", "diffHunk": "@@ -0,0 +1,207 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bmwconnecteddrive.internal.discovery;\n+\n+import static org.openhab.binding.bmwconnecteddrive.internal.ConnectedDriveConstants.SUPPORTED_THING_SET;\n+\n+import java.lang.reflect.Field;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.bmwconnecteddrive.internal.ConnectedDriveConstants;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.discovery.VehiclesContainer;\n+import org.openhab.binding.bmwconnecteddrive.internal.handler.ConnectedDriveBridgeHandler;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Constants;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Converter;\n+import org.openhab.core.config.core.Configuration;\n+import org.openhab.core.config.discovery.AbstractDiscoveryService;\n+import org.openhab.core.config.discovery.DiscoveryResultBuilder;\n+import org.openhab.core.config.discovery.DiscoveryService;\n+import org.openhab.core.thing.ThingUID;\n+import org.openhab.core.thing.binding.ThingHandler;\n+import org.openhab.core.thing.binding.ThingHandlerService;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link VehicleDiscovery} requests data from ConnectedDrive and is identifying the Vehicles after response\n+ *\n+ * @author Bernd Weymann - Initial contribution\n+ */\n+@NonNullByDefault\n+public class VehicleDiscovery extends AbstractDiscoveryService implements DiscoveryService, ThingHandlerService {\n+\n+    private final Logger logger = LoggerFactory.getLogger(VehicleDiscovery.class);\n+    private static final int DISCOVERY_TIMEOUT = 10;\n+    private Optional<ConnectedDriveBridgeHandler> bridgeHandler = Optional.empty();\n+\n+    public VehicleDiscovery() {\n+        super(SUPPORTED_THING_SET, DISCOVERY_TIMEOUT, false);\n+    }\n+\n+    public void onResponse(VehiclesContainer container) {\n+        bridgeHandler.ifPresent(bridge -> {\n+            final ThingUID bridgeUID = bridge.getThing().getUID();\n+            container.vehicles.forEach(vehicle -> {\n+                // the DriveTrain field in the delivered json is defining the Vehicle Type\n+                String vehicleType = vehicle.driveTrain.toLowerCase();\n+                SUPPORTED_THING_SET.forEach(entry -> {\n+                    if (entry.getId().equals(vehicleType)) {\n+                        ThingUID uid = new ThingUID(entry, vehicle.vin, bridgeUID.getId());\n+                        Map<String, String> properties = new HashMap<>();\n+                        // Dealer\n+                        if (vehicle.dealer != null) {\n+                            properties.put(\"dealer\", vehicle.dealer.name);\n+                            properties.put(\"dealerAddress\", vehicle.dealer.street + \" \" + vehicle.dealer.country + \" \"\n+                                    + vehicle.dealer.postalCode + \" \" + vehicle.dealer.city);\n+                            properties.put(\"dealerPhone\", vehicle.dealer.phone);\n+                        }\n+\n+                        // Services & Support\n+                        properties.put(\"servicesActivated\", getObject(vehicle, Constants.ACTIVATED));\n+                        String servicesSupported = getObject(vehicle, Constants.SUPPORTED);\n+                        String servicesNotSupported = getObject(vehicle, Constants.NOT_SUPPORTED);\n+                        if (vehicle.statisticsAvailable) {\n+                            servicesSupported += Constants.STATISTICS;\n+                        } else {\n+                            servicesNotSupported += Constants.STATISTICS;\n+                        }\n+                        properties.put(Constants.SERVICES_SUPPORTED, servicesSupported);\n+                        properties.put(\"servicesNotSupported\", servicesNotSupported);\n+                        properties.put(\"supportBreakdownNumber\", vehicle.breakdownNumber);\n+\n+                        // Vehicle Properties\n+                        if (vehicle.supportedChargingModes != null) {\n+                            properties.put(\"vehicleChargeModes\",\n+                                    String.join(Constants.SPACE, vehicle.supportedChargingModes));\n+                        }\n+                        if (vehicle.hasAlarmSystem) {\n+                            properties.put(\"vehicleAlarmSystem\", \"Available\");\n+                        } else {\n+                            properties.put(\"vehicleAlarmSystem\", \"Not Available\");\n+                        }\n+                        properties.put(\"vehicleBrand\", vehicle.brand);\n+                        properties.put(\"vehicleBodytype\", vehicle.bodytype);\n+                        properties.put(\"vehicleColor\", vehicle.color);\n+                        properties.put(\"vehicleConstructionYear\", Short.toString(vehicle.yearOfConstruction));\n+                        properties.put(\"vehicleDriveTrain\", vehicle.driveTrain);\n+                        properties.put(\"vehicleModel\", vehicle.model);\n+                        if (vehicle.chargingControl != null) {\n+                            properties.put(\"vehicleChargeControl\", Converter.toTitleCase(vehicle.model));\n+                        }\n+\n+                        // Check now if a thing with the same VIN exists\n+                        final AtomicBoolean foundVehicle = new AtomicBoolean(false);\n+                        bridge.getThing().getThings().forEach(vehicleThing -> {\n+                            Configuration c = vehicleThing.getConfiguration();\n+                            if (c.containsKey(ConnectedDriveConstants.VIN)) {\n+                                String thingVIN = c.get(ConnectedDriveConstants.VIN).toString();\n+                                if (vehicle.vin.equals(thingVIN)) {\n+                                    vehicleThing.setProperties(properties);\n+                                    foundVehicle.set(true);\n+                                }\n+                            }\n+                        });\n+\n+                        // Vehicle not found -> trigger discovery\n+                        if (!foundVehicle.get()) {\n+                            // Properties needed for functional THing\n+                            properties.put(ConnectedDriveConstants.VIN, vehicle.vin);\n+                            properties.put(\"refreshInterval\",\n+                                    Integer.toString(ConnectedDriveConstants.DEFAULT_REFRESH_INTERVAL));\n+                            properties.put(\"units\", ConnectedDriveConstants.UNITS_AUTODETECT);\n+                            properties.put(\"imageSize\", Integer.toString(ConnectedDriveConstants.DEFAULT_IMAGE_SIZE));\n+                            properties.put(\"imageViewport\", ConnectedDriveConstants.DEFAULT_IMAGE_VIEWPORT);\n+\n+                            String vehicleLabel = vehicle.brand + \" \" + vehicle.model;\n+                            Map<String, Object> convertedProperties = new HashMap<String, Object>(properties);\n+                            thingDiscovered(DiscoveryResultBuilder.create(uid).withBridge(bridgeUID)\n+                                    .withRepresentationProperty(ConnectedDriveConstants.VIN).withLabel(vehicleLabel)\n+                                    .withProperties(convertedProperties).build());\n+                        }\n+                    }\n+                });\n+            });\n+        });\n+    };\n+\n+    /**\n+     * Get all field names from a DTO with a specific value\n+     * Used to get e.g. all services which are \"ACTIVATED\"\n+     *\n+     * @param DTO Object\n+     * @param compare String which needs to map with the value\n+     * @return String with all field names matching this value separated with Spaces\n+     */\n+    public String getObject(Object dto, String compare) {\n+        StringBuilder buf = new StringBuilder();\n+        for (Field field : dto.getClass().getDeclaredFields()) {\n+            try {\n+                Object value = field.get(dto);\n+                if (compare.equals(value)) {\n+                    buf.append(Converter.capitalizeFirst(field.getName()) + Constants.SPACE);\n+                }\n+            } catch (IllegalArgumentException | IllegalAccessException e) {\n+                logger.debug(\"Field {} not found {}\", compare, e.getMessage());\n+            }\n+        }\n+        return buf.toString();\n+    }\n+\n+    @Override\n+    public void setThingHandler(ThingHandler handler) {\n+        if (handler instanceof ConnectedDriveBridgeHandler) {\n+            bridgeHandler = Optional.of((ConnectedDriveBridgeHandler) handler);\n+            bridgeHandler.get().setDiscoveryService(this);\n+        }\n+    }\n+\n+    @Override\n+    public @Nullable ThingHandler getThingHandler() {\n+        return bridgeHandler.orElse(null);\n+    }\n+\n+    @Override\n+    public int getScanTimeout() {\n+        return DISCOVERY_TIMEOUT;\n+    }\n+\n+    @Override\n+    public boolean isBackgroundDiscoveryEnabled() {\n+        return false;\n+    }\n+\n+    @Override\n+    protected void startScan() {\n+        bridgeHandler.ifPresent(ConnectedDriveBridgeHandler::requestVehicles);\n+    }\n+\n+    @Override\n+    public void abortScan() {\n+        // nothing to abort\n+    }\n+\n+    @Override\n+    public void activate() {\n+        super.activate(null);\n+    }\n+\n+    @Override\n+    public void deactivate() {\n+        super.deactivate();\n+    }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5Nzg3NzU3Ng=="}, "originalCommit": {"oid": "48af48c82562d006b6f2aa35922270f181c885ed"}, "originalPosition": 206}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzc3NjUyMjk5OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/ConnectedDriveBridgeHandler.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0xOVQxODowMjozOFrOI6Loaw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0yMlQyMjo1ODo0NFrOI7YAqQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5Nzg3ODg5MQ==", "bodyText": "What is the reason for requesting all vehicles from the API? Can't you access the bridge's Things?", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r597878891", "createdAt": "2021-03-19T18:02:38Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/ConnectedDriveBridgeHandler.java", "diffHunk": "@@ -0,0 +1,202 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bmwconnecteddrive.internal.handler;\n+\n+import static org.openhab.binding.bmwconnecteddrive.internal.utils.Constants.ANONYMOUS;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Optional;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.bmwconnecteddrive.internal.ConnectedDriveConfiguration;\n+import org.openhab.binding.bmwconnecteddrive.internal.discovery.VehicleDiscovery;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.NetworkError;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.discovery.Dealer;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.discovery.VehiclesContainer;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Constants;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Converter;\n+import org.openhab.core.io.net.http.HttpClientFactory;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseBridgeHandler;\n+import org.openhab.core.thing.binding.ThingHandlerService;\n+import org.openhab.core.types.Command;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonParseException;\n+\n+/**\n+ * The {@link ConnectedDriveBridgeHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Bernd Weymann - Initial contribution\n+ */\n+@NonNullByDefault\n+public class ConnectedDriveBridgeHandler extends BaseBridgeHandler implements StringResponseCallback {\n+    private final Logger logger = LoggerFactory.getLogger(ConnectedDriveBridgeHandler.class);\n+    private HttpClientFactory httpClientFactory;\n+    private Optional<VehicleDiscovery> discoveryService = Optional.empty();\n+    private Optional<ConnectedDriveProxy> proxy = Optional.empty();\n+    private Optional<ConnectedDriveConfiguration> configuration = Optional.empty();\n+    private Optional<ScheduledFuture<?>> initializerJob = Optional.empty();\n+    private Optional<String> troubleshootFingerprint = Optional.empty();\n+\n+    public ConnectedDriveBridgeHandler(Bridge bridge, HttpClientFactory hcf) {\n+        super(bridge);\n+        httpClientFactory = hcf;\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        // no commands available\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        troubleshootFingerprint = Optional.empty();\n+        updateStatus(ThingStatus.UNKNOWN);\n+        configuration = Optional.of(getConfigAs(ConnectedDriveConfiguration.class));\n+        configuration.ifPresentOrElse(config -> {\n+            proxy = Optional.of(new ConnectedDriveProxy(httpClientFactory, config));\n+            // give the system some time to create all predefined Vehicles\n+            initializerJob = Optional.of(scheduler.schedule(this::requestVehicles, 5, TimeUnit.SECONDS));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "48af48c82562d006b6f2aa35922270f181c885ed"}, "originalPosition": 79}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5ODI3NTE0NA==", "bodyText": "It's the only API to check for the bridge. Depending on the response either Bridge goes ONLINE / OFFLINE and debug entry is generated to identify problems.", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r598275144", "createdAt": "2021-03-21T12:53:30Z", "author": {"login": "weymann"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/ConnectedDriveBridgeHandler.java", "diffHunk": "@@ -0,0 +1,202 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bmwconnecteddrive.internal.handler;\n+\n+import static org.openhab.binding.bmwconnecteddrive.internal.utils.Constants.ANONYMOUS;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Optional;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.bmwconnecteddrive.internal.ConnectedDriveConfiguration;\n+import org.openhab.binding.bmwconnecteddrive.internal.discovery.VehicleDiscovery;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.NetworkError;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.discovery.Dealer;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.discovery.VehiclesContainer;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Constants;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Converter;\n+import org.openhab.core.io.net.http.HttpClientFactory;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseBridgeHandler;\n+import org.openhab.core.thing.binding.ThingHandlerService;\n+import org.openhab.core.types.Command;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonParseException;\n+\n+/**\n+ * The {@link ConnectedDriveBridgeHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Bernd Weymann - Initial contribution\n+ */\n+@NonNullByDefault\n+public class ConnectedDriveBridgeHandler extends BaseBridgeHandler implements StringResponseCallback {\n+    private final Logger logger = LoggerFactory.getLogger(ConnectedDriveBridgeHandler.class);\n+    private HttpClientFactory httpClientFactory;\n+    private Optional<VehicleDiscovery> discoveryService = Optional.empty();\n+    private Optional<ConnectedDriveProxy> proxy = Optional.empty();\n+    private Optional<ConnectedDriveConfiguration> configuration = Optional.empty();\n+    private Optional<ScheduledFuture<?>> initializerJob = Optional.empty();\n+    private Optional<String> troubleshootFingerprint = Optional.empty();\n+\n+    public ConnectedDriveBridgeHandler(Bridge bridge, HttpClientFactory hcf) {\n+        super(bridge);\n+        httpClientFactory = hcf;\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        // no commands available\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        troubleshootFingerprint = Optional.empty();\n+        updateStatus(ThingStatus.UNKNOWN);\n+        configuration = Optional.of(getConfigAs(ConnectedDriveConfiguration.class));\n+        configuration.ifPresentOrElse(config -> {\n+            proxy = Optional.of(new ConnectedDriveProxy(httpClientFactory, config));\n+            // give the system some time to create all predefined Vehicles\n+            initializerJob = Optional.of(scheduler.schedule(this::requestVehicles, 5, TimeUnit.SECONDS));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5Nzg3ODg5MQ=="}, "originalCommit": {"oid": "48af48c82562d006b6f2aa35922270f181c885ed"}, "originalPosition": 79}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5ODI3NjI5NA==", "bodyText": "Understood. You could add a comment, that this could by any API request and the purpose is only to check the connectitivity.", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r598276294", "createdAt": "2021-03-21T13:00:55Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/ConnectedDriveBridgeHandler.java", "diffHunk": "@@ -0,0 +1,202 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bmwconnecteddrive.internal.handler;\n+\n+import static org.openhab.binding.bmwconnecteddrive.internal.utils.Constants.ANONYMOUS;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Optional;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.bmwconnecteddrive.internal.ConnectedDriveConfiguration;\n+import org.openhab.binding.bmwconnecteddrive.internal.discovery.VehicleDiscovery;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.NetworkError;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.discovery.Dealer;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.discovery.VehiclesContainer;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Constants;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Converter;\n+import org.openhab.core.io.net.http.HttpClientFactory;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseBridgeHandler;\n+import org.openhab.core.thing.binding.ThingHandlerService;\n+import org.openhab.core.types.Command;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonParseException;\n+\n+/**\n+ * The {@link ConnectedDriveBridgeHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Bernd Weymann - Initial contribution\n+ */\n+@NonNullByDefault\n+public class ConnectedDriveBridgeHandler extends BaseBridgeHandler implements StringResponseCallback {\n+    private final Logger logger = LoggerFactory.getLogger(ConnectedDriveBridgeHandler.class);\n+    private HttpClientFactory httpClientFactory;\n+    private Optional<VehicleDiscovery> discoveryService = Optional.empty();\n+    private Optional<ConnectedDriveProxy> proxy = Optional.empty();\n+    private Optional<ConnectedDriveConfiguration> configuration = Optional.empty();\n+    private Optional<ScheduledFuture<?>> initializerJob = Optional.empty();\n+    private Optional<String> troubleshootFingerprint = Optional.empty();\n+\n+    public ConnectedDriveBridgeHandler(Bridge bridge, HttpClientFactory hcf) {\n+        super(bridge);\n+        httpClientFactory = hcf;\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        // no commands available\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        troubleshootFingerprint = Optional.empty();\n+        updateStatus(ThingStatus.UNKNOWN);\n+        configuration = Optional.of(getConfigAs(ConnectedDriveConfiguration.class));\n+        configuration.ifPresentOrElse(config -> {\n+            proxy = Optional.of(new ConnectedDriveProxy(httpClientFactory, config));\n+            // give the system some time to create all predefined Vehicles\n+            initializerJob = Optional.of(scheduler.schedule(this::requestVehicles, 5, TimeUnit.SECONDS));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5Nzg3ODg5MQ=="}, "originalCommit": {"oid": "48af48c82562d006b6f2aa35922270f181c885ed"}, "originalPosition": 79}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5OTEzMDI4MQ==", "bodyText": "ok", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r599130281", "createdAt": "2021-03-22T22:58:44Z", "author": {"login": "weymann"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/ConnectedDriveBridgeHandler.java", "diffHunk": "@@ -0,0 +1,202 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bmwconnecteddrive.internal.handler;\n+\n+import static org.openhab.binding.bmwconnecteddrive.internal.utils.Constants.ANONYMOUS;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Optional;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.bmwconnecteddrive.internal.ConnectedDriveConfiguration;\n+import org.openhab.binding.bmwconnecteddrive.internal.discovery.VehicleDiscovery;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.NetworkError;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.discovery.Dealer;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.discovery.VehiclesContainer;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Constants;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Converter;\n+import org.openhab.core.io.net.http.HttpClientFactory;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseBridgeHandler;\n+import org.openhab.core.thing.binding.ThingHandlerService;\n+import org.openhab.core.types.Command;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonParseException;\n+\n+/**\n+ * The {@link ConnectedDriveBridgeHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Bernd Weymann - Initial contribution\n+ */\n+@NonNullByDefault\n+public class ConnectedDriveBridgeHandler extends BaseBridgeHandler implements StringResponseCallback {\n+    private final Logger logger = LoggerFactory.getLogger(ConnectedDriveBridgeHandler.class);\n+    private HttpClientFactory httpClientFactory;\n+    private Optional<VehicleDiscovery> discoveryService = Optional.empty();\n+    private Optional<ConnectedDriveProxy> proxy = Optional.empty();\n+    private Optional<ConnectedDriveConfiguration> configuration = Optional.empty();\n+    private Optional<ScheduledFuture<?>> initializerJob = Optional.empty();\n+    private Optional<String> troubleshootFingerprint = Optional.empty();\n+\n+    public ConnectedDriveBridgeHandler(Bridge bridge, HttpClientFactory hcf) {\n+        super(bridge);\n+        httpClientFactory = hcf;\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        // no commands available\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        troubleshootFingerprint = Optional.empty();\n+        updateStatus(ThingStatus.UNKNOWN);\n+        configuration = Optional.of(getConfigAs(ConnectedDriveConfiguration.class));\n+        configuration.ifPresentOrElse(config -> {\n+            proxy = Optional.of(new ConnectedDriveProxy(httpClientFactory, config));\n+            // give the system some time to create all predefined Vehicles\n+            initializerJob = Optional.of(scheduler.schedule(this::requestVehicles, 5, TimeUnit.SECONDS));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5Nzg3ODg5MQ=="}, "originalCommit": {"oid": "48af48c82562d006b6f2aa35922270f181c885ed"}, "originalPosition": 79}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzc3NjUzMDU2OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/dto/Destination.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0xOVQxODowNDo0NFrOI6LtIQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0yMVQxMjo1NToyMVrOI6j1XQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5Nzg4MDA5Nw==", "bodyText": "StringBuilder has better performance when used in loops. In these use cases, you could simply use the plus operator.", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r597880097", "createdAt": "2021-03-19T18:04:44Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/dto/Destination.java", "diffHunk": "@@ -0,0 +1,60 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bmwconnecteddrive.internal.dto;\n+\n+import static org.openhab.binding.bmwconnecteddrive.internal.utils.Constants.*;\n+\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Constants;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Converter;\n+\n+/**\n+ * The {@link Destination} Data Transfer Object\n+ *\n+ * @author Bernd Weymann - Initial contribution\n+ */\n+public class Destination {\n+    public float lat;\n+    public float lon;\n+    public String country;\n+    public String city;\n+    public String street;\n+    public String streetNumber;\n+    public String type;\n+    public String createdAt;\n+\n+    public String getAddress() {\n+        StringBuilder buf = new StringBuilder();\n+        if (street != null) {\n+            buf.append(street);\n+            if (streetNumber != null) {\n+                buf.append(SPACE).append(streetNumber);\n+            }\n+        }\n+        if (city != null) {\n+            if (buf.length() > 0) {\n+                buf.append(COMMA).append(SPACE).append(city);\n+            } else {\n+                buf.append(city);\n+            }\n+        }\n+        if (buf.length() == 0) {\n+            return UNDEF;\n+        } else {\n+            return Converter.toTitleCase(buf.toString());\n+        }\n+    }\n+\n+    public String getCoordinates() {\n+        return new StringBuilder().append(lat).append(Constants.COMMA).append(lon).toString();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "48af48c82562d006b6f2aa35922270f181c885ed"}, "originalPosition": 58}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5ODI3NTQyMQ==", "bodyText": "done", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r598275421", "createdAt": "2021-03-21T12:55:21Z", "author": {"login": "weymann"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/dto/Destination.java", "diffHunk": "@@ -0,0 +1,60 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bmwconnecteddrive.internal.dto;\n+\n+import static org.openhab.binding.bmwconnecteddrive.internal.utils.Constants.*;\n+\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Constants;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Converter;\n+\n+/**\n+ * The {@link Destination} Data Transfer Object\n+ *\n+ * @author Bernd Weymann - Initial contribution\n+ */\n+public class Destination {\n+    public float lat;\n+    public float lon;\n+    public String country;\n+    public String city;\n+    public String street;\n+    public String streetNumber;\n+    public String type;\n+    public String createdAt;\n+\n+    public String getAddress() {\n+        StringBuilder buf = new StringBuilder();\n+        if (street != null) {\n+            buf.append(street);\n+            if (streetNumber != null) {\n+                buf.append(SPACE).append(streetNumber);\n+            }\n+        }\n+        if (city != null) {\n+            if (buf.length() > 0) {\n+                buf.append(COMMA).append(SPACE).append(city);\n+            } else {\n+                buf.append(city);\n+            }\n+        }\n+        if (buf.length() == 0) {\n+            return UNDEF;\n+        } else {\n+            return Converter.toTitleCase(buf.toString());\n+        }\n+    }\n+\n+    public String getCoordinates() {\n+        return new StringBuilder().append(lat).append(Constants.COMMA).append(lon).toString();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5Nzg4MDA5Nw=="}, "originalCommit": {"oid": "48af48c82562d006b6f2aa35922270f181c885ed"}, "originalPosition": 58}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzc3NjUzODA5OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/dto/compat/VehicleAttributesContainer.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0xOVQxODowNjo0MFrOI6LxvA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0yMlQyMjo1OToyOFrOI7YByg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5Nzg4MTI3Ng==", "bodyText": "Can this be removed?", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r597881276", "createdAt": "2021-03-19T18:06:40Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/dto/compat/VehicleAttributesContainer.java", "diffHunk": "@@ -0,0 +1,106 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bmwconnecteddrive.internal.dto.compat;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.status.CBSMessage;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.status.CCMMessage;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.status.Position;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.status.VehicleStatus;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.status.VehicleStatusContainer;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Constants;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Converter;\n+\n+/**\n+ * The {@link VehicleAttributesContainer} Data Transfer Object\n+ *\n+ * @author Bernd Weymann - Initial contribution\n+ */\n+public class VehicleAttributesContainer {\n+    public VehicleAttributes attributesMap;\n+    public VehicleMessages vehicleMessages;\n+\n+    public String transform() {\n+        // create target objects\n+        VehicleStatusContainer vsc = new VehicleStatusContainer();\n+        VehicleStatus vs = new VehicleStatus();\n+        vsc.vehicleStatus = vs;\n+\n+        vs.mileage = attributesMap.mileage;\n+        vs.doorLockState = attributesMap.doorLockState;\n+\n+        vs.doorDriverFront = attributesMap.doorDriverFront;\n+        vs.doorDriverRear = attributesMap.doorDriverRear;\n+        vs.doorPassengerFront = attributesMap.doorPassengerFront;\n+        vs.doorPassengerRear = attributesMap.doorPassengerRear;\n+        vs.hood = attributesMap.hoodState;\n+        vs.trunk = attributesMap.trunkState;\n+\n+        vs.windowDriverFront = attributesMap.winDriverFront;\n+        vs.windowDriverRear = attributesMap.winDriverRear;\n+        vs.windowPassengerFront = attributesMap.winPassengerFront;\n+        vs.windowPassengerRear = attributesMap.winPassengerRear;\n+        vs.sunroof = attributesMap.sunroofState;\n+\n+        vs.remainingFuel = attributesMap.remainingFuel;\n+        vs.remainingRangeElectric = attributesMap.beRemainingRangeElectricKm;\n+        vs.remainingRangeElectricMls = attributesMap.beRemainingRangeElectricMile;\n+        vs.remainingRangeFuel = attributesMap.beRemainingRangeFuelKm;\n+        vs.remainingRangeFuelMls = attributesMap.beRemainingRangeFuelMile;\n+        vs.remainingFuel = attributesMap.remainingFuel;\n+        vs.chargingLevelHv = attributesMap.chargingLevelHv;\n+        vs.chargingStatus = attributesMap.chargingHVStatus;\n+        vs.lastChargingEndReason = attributesMap.lastChargingEndReason;\n+\n+        vs.updateTime = attributesMap.updateTimeConverted;\n+        // vs.internalDataTimeUTC = attributesMap.updateTime;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "48af48c82562d006b6f2aa35922270f181c885ed"}, "originalPosition": 68}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5OTEzMDU3MA==", "bodyText": "Sure", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r599130570", "createdAt": "2021-03-22T22:59:28Z", "author": {"login": "weymann"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/dto/compat/VehicleAttributesContainer.java", "diffHunk": "@@ -0,0 +1,106 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bmwconnecteddrive.internal.dto.compat;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.status.CBSMessage;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.status.CCMMessage;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.status.Position;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.status.VehicleStatus;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.status.VehicleStatusContainer;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Constants;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Converter;\n+\n+/**\n+ * The {@link VehicleAttributesContainer} Data Transfer Object\n+ *\n+ * @author Bernd Weymann - Initial contribution\n+ */\n+public class VehicleAttributesContainer {\n+    public VehicleAttributes attributesMap;\n+    public VehicleMessages vehicleMessages;\n+\n+    public String transform() {\n+        // create target objects\n+        VehicleStatusContainer vsc = new VehicleStatusContainer();\n+        VehicleStatus vs = new VehicleStatus();\n+        vsc.vehicleStatus = vs;\n+\n+        vs.mileage = attributesMap.mileage;\n+        vs.doorLockState = attributesMap.doorLockState;\n+\n+        vs.doorDriverFront = attributesMap.doorDriverFront;\n+        vs.doorDriverRear = attributesMap.doorDriverRear;\n+        vs.doorPassengerFront = attributesMap.doorPassengerFront;\n+        vs.doorPassengerRear = attributesMap.doorPassengerRear;\n+        vs.hood = attributesMap.hoodState;\n+        vs.trunk = attributesMap.trunkState;\n+\n+        vs.windowDriverFront = attributesMap.winDriverFront;\n+        vs.windowDriverRear = attributesMap.winDriverRear;\n+        vs.windowPassengerFront = attributesMap.winPassengerFront;\n+        vs.windowPassengerRear = attributesMap.winPassengerRear;\n+        vs.sunroof = attributesMap.sunroofState;\n+\n+        vs.remainingFuel = attributesMap.remainingFuel;\n+        vs.remainingRangeElectric = attributesMap.beRemainingRangeElectricKm;\n+        vs.remainingRangeElectricMls = attributesMap.beRemainingRangeElectricMile;\n+        vs.remainingRangeFuel = attributesMap.beRemainingRangeFuelKm;\n+        vs.remainingRangeFuelMls = attributesMap.beRemainingRangeFuelMile;\n+        vs.remainingFuel = attributesMap.remainingFuel;\n+        vs.chargingLevelHv = attributesMap.chargingLevelHv;\n+        vs.chargingStatus = attributesMap.chargingHVStatus;\n+        vs.lastChargingEndReason = attributesMap.lastChargingEndReason;\n+\n+        vs.updateTime = attributesMap.updateTimeConverted;\n+        // vs.internalDataTimeUTC = attributesMap.updateTime;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5Nzg4MTI3Ng=="}, "originalCommit": {"oid": "48af48c82562d006b6f2aa35922270f181c885ed"}, "originalPosition": 68}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzc3NjU0NjM3OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/dto/compat/VehicleAttributesContainer.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0xOVQxODowODo1MVrOI6L22Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0yMlQyMzoxOTozNVrOI7YgtA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5Nzg4MjU4NQ==", "bodyText": "DTOs shouldn't have logic. You could move it outside the DTO package.-", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r597882585", "createdAt": "2021-03-19T18:08:51Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/dto/compat/VehicleAttributesContainer.java", "diffHunk": "@@ -0,0 +1,106 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bmwconnecteddrive.internal.dto.compat;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.status.CBSMessage;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.status.CCMMessage;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.status.Position;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.status.VehicleStatus;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.status.VehicleStatusContainer;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Constants;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Converter;\n+\n+/**\n+ * The {@link VehicleAttributesContainer} Data Transfer Object\n+ *\n+ * @author Bernd Weymann - Initial contribution\n+ */\n+public class VehicleAttributesContainer {\n+    public VehicleAttributes attributesMap;\n+    public VehicleMessages vehicleMessages;\n+\n+    public String transform() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "48af48c82562d006b6f2aa35922270f181c885ed"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5OTEzODQ4NA==", "bodyText": "Moved to Converter", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r599138484", "createdAt": "2021-03-22T23:19:35Z", "author": {"login": "weymann"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/dto/compat/VehicleAttributesContainer.java", "diffHunk": "@@ -0,0 +1,106 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bmwconnecteddrive.internal.dto.compat;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.status.CBSMessage;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.status.CCMMessage;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.status.Position;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.status.VehicleStatus;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.status.VehicleStatusContainer;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Constants;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Converter;\n+\n+/**\n+ * The {@link VehicleAttributesContainer} Data Transfer Object\n+ *\n+ * @author Bernd Weymann - Initial contribution\n+ */\n+public class VehicleAttributesContainer {\n+    public VehicleAttributes attributesMap;\n+    public VehicleMessages vehicleMessages;\n+\n+    public String transform() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5Nzg4MjU4NQ=="}, "originalCommit": {"oid": "48af48c82562d006b6f2aa35922270f181c885ed"}, "originalPosition": 35}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzc3NjU0ODMzOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/dto/remote/ExecutionStatus.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0xOVQxODowOToyNFrOI6L4AQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0yMlQyMzoyMDo1OVrOI7Yiow==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5Nzg4Mjg4MQ==", "bodyText": "Can these be removed?", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r597882881", "createdAt": "2021-03-19T18:09:24Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/dto/remote/ExecutionStatus.java", "diffHunk": "@@ -0,0 +1,28 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bmwconnecteddrive.internal.dto.remote;\n+\n+/**\n+ * The {@link ExecutionStatus} Data Transfer Object\n+ *\n+ * @author Bernd Weymann - Initial contribution\n+ */\n+public class ExecutionStatus {\n+    public String serviceType;// \": \"DOOR_UNLOCK\",\n+    public String status;// \": \"EXECUTED\",\n+    public String eventId;// \": \"5639303536333926DA7B9400@bmw.de\",\n+    // public String extendedStatus;// \": {\n+    // public String newDoorStatus;// \": \"INVALID\",\n+    // public String oldDoorStatus;// \": \"INVALID\",\n+    // public String result;// \": \"STATUS_NOT_CHANGED\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "48af48c82562d006b6f2aa35922270f181c885ed"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5OTEzODk3OQ==", "bodyText": "Yes, not used so far", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r599138979", "createdAt": "2021-03-22T23:20:59Z", "author": {"login": "weymann"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/dto/remote/ExecutionStatus.java", "diffHunk": "@@ -0,0 +1,28 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bmwconnecteddrive.internal.dto.remote;\n+\n+/**\n+ * The {@link ExecutionStatus} Data Transfer Object\n+ *\n+ * @author Bernd Weymann - Initial contribution\n+ */\n+public class ExecutionStatus {\n+    public String serviceType;// \": \"DOOR_UNLOCK\",\n+    public String status;// \": \"EXECUTED\",\n+    public String eventId;// \": \"5639303536333926DA7B9400@bmw.de\",\n+    // public String extendedStatus;// \": {\n+    // public String newDoorStatus;// \": \"INVALID\",\n+    // public String oldDoorStatus;// \": \"INVALID\",\n+    // public String result;// \": \"STATUS_NOT_CHANGED\"", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5Nzg4Mjg4MQ=="}, "originalCommit": {"oid": "48af48c82562d006b6f2aa35922270f181c885ed"}, "originalPosition": 27}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzc3NjU1NzYwOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/ConnectedDriveBridgeHandler.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0xOVQxODoxMTo1MFrOI6L9mw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0yMVQxMzoyMDowOVrOI6kC8g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5Nzg4NDMxNQ==", "bodyText": "If I see correctly the config is always present at this location. So, this will never be invoked.", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r597884315", "createdAt": "2021-03-19T18:11:50Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/ConnectedDriveBridgeHandler.java", "diffHunk": "@@ -0,0 +1,202 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bmwconnecteddrive.internal.handler;\n+\n+import static org.openhab.binding.bmwconnecteddrive.internal.utils.Constants.ANONYMOUS;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Optional;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.bmwconnecteddrive.internal.ConnectedDriveConfiguration;\n+import org.openhab.binding.bmwconnecteddrive.internal.discovery.VehicleDiscovery;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.NetworkError;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.discovery.Dealer;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.discovery.VehiclesContainer;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Constants;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Converter;\n+import org.openhab.core.io.net.http.HttpClientFactory;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseBridgeHandler;\n+import org.openhab.core.thing.binding.ThingHandlerService;\n+import org.openhab.core.types.Command;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonParseException;\n+\n+/**\n+ * The {@link ConnectedDriveBridgeHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Bernd Weymann - Initial contribution\n+ */\n+@NonNullByDefault\n+public class ConnectedDriveBridgeHandler extends BaseBridgeHandler implements StringResponseCallback {\n+    private final Logger logger = LoggerFactory.getLogger(ConnectedDriveBridgeHandler.class);\n+    private HttpClientFactory httpClientFactory;\n+    private Optional<VehicleDiscovery> discoveryService = Optional.empty();\n+    private Optional<ConnectedDriveProxy> proxy = Optional.empty();\n+    private Optional<ConnectedDriveConfiguration> configuration = Optional.empty();\n+    private Optional<ScheduledFuture<?>> initializerJob = Optional.empty();\n+    private Optional<String> troubleshootFingerprint = Optional.empty();\n+\n+    public ConnectedDriveBridgeHandler(Bridge bridge, HttpClientFactory hcf) {\n+        super(bridge);\n+        httpClientFactory = hcf;\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        // no commands available\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        troubleshootFingerprint = Optional.empty();\n+        updateStatus(ThingStatus.UNKNOWN);\n+        configuration = Optional.of(getConfigAs(ConnectedDriveConfiguration.class));\n+        configuration.ifPresentOrElse(config -> {\n+            proxy = Optional.of(new ConnectedDriveProxy(httpClientFactory, config));\n+            // give the system some time to create all predefined Vehicles\n+            initializerJob = Optional.of(scheduler.schedule(this::requestVehicles, 5, TimeUnit.SECONDS));\n+        }, () -> {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR);\n+        });", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "48af48c82562d006b6f2aa35922270f181c885ed"}, "originalPosition": 82}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5ODI3NjM2OQ==", "bodyText": "From what I can see deep inside BaseThingHandler.getConfigAs() ... there is a call to ConfigMapper.as returning Nullable which is not handled properly and would be returend by BaseThingHandler. But I agree: As formally BaseThingHandler.getConfigAs is declared as NonNullByDefault that should be fixed within BaseThingHandler. So I agree it can be removed.", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r598276369", "createdAt": "2021-03-21T13:01:33Z", "author": {"login": "ntruchsess"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/ConnectedDriveBridgeHandler.java", "diffHunk": "@@ -0,0 +1,202 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bmwconnecteddrive.internal.handler;\n+\n+import static org.openhab.binding.bmwconnecteddrive.internal.utils.Constants.ANONYMOUS;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Optional;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.bmwconnecteddrive.internal.ConnectedDriveConfiguration;\n+import org.openhab.binding.bmwconnecteddrive.internal.discovery.VehicleDiscovery;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.NetworkError;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.discovery.Dealer;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.discovery.VehiclesContainer;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Constants;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Converter;\n+import org.openhab.core.io.net.http.HttpClientFactory;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseBridgeHandler;\n+import org.openhab.core.thing.binding.ThingHandlerService;\n+import org.openhab.core.types.Command;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonParseException;\n+\n+/**\n+ * The {@link ConnectedDriveBridgeHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Bernd Weymann - Initial contribution\n+ */\n+@NonNullByDefault\n+public class ConnectedDriveBridgeHandler extends BaseBridgeHandler implements StringResponseCallback {\n+    private final Logger logger = LoggerFactory.getLogger(ConnectedDriveBridgeHandler.class);\n+    private HttpClientFactory httpClientFactory;\n+    private Optional<VehicleDiscovery> discoveryService = Optional.empty();\n+    private Optional<ConnectedDriveProxy> proxy = Optional.empty();\n+    private Optional<ConnectedDriveConfiguration> configuration = Optional.empty();\n+    private Optional<ScheduledFuture<?>> initializerJob = Optional.empty();\n+    private Optional<String> troubleshootFingerprint = Optional.empty();\n+\n+    public ConnectedDriveBridgeHandler(Bridge bridge, HttpClientFactory hcf) {\n+        super(bridge);\n+        httpClientFactory = hcf;\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        // no commands available\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        troubleshootFingerprint = Optional.empty();\n+        updateStatus(ThingStatus.UNKNOWN);\n+        configuration = Optional.of(getConfigAs(ConnectedDriveConfiguration.class));\n+        configuration.ifPresentOrElse(config -> {\n+            proxy = Optional.of(new ConnectedDriveProxy(httpClientFactory, config));\n+            // give the system some time to create all predefined Vehicles\n+            initializerJob = Optional.of(scheduler.schedule(this::requestVehicles, 5, TimeUnit.SECONDS));\n+        }, () -> {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR);\n+        });", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5Nzg4NDMxNQ=="}, "originalCommit": {"oid": "48af48c82562d006b6f2aa35922270f181c885ed"}, "originalPosition": 82}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5ODI3NzMzNA==", "bodyText": "Good catch. You could file an issue in openhab-core.", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r598277334", "createdAt": "2021-03-21T13:08:22Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/ConnectedDriveBridgeHandler.java", "diffHunk": "@@ -0,0 +1,202 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bmwconnecteddrive.internal.handler;\n+\n+import static org.openhab.binding.bmwconnecteddrive.internal.utils.Constants.ANONYMOUS;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Optional;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.bmwconnecteddrive.internal.ConnectedDriveConfiguration;\n+import org.openhab.binding.bmwconnecteddrive.internal.discovery.VehicleDiscovery;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.NetworkError;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.discovery.Dealer;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.discovery.VehiclesContainer;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Constants;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Converter;\n+import org.openhab.core.io.net.http.HttpClientFactory;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseBridgeHandler;\n+import org.openhab.core.thing.binding.ThingHandlerService;\n+import org.openhab.core.types.Command;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonParseException;\n+\n+/**\n+ * The {@link ConnectedDriveBridgeHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Bernd Weymann - Initial contribution\n+ */\n+@NonNullByDefault\n+public class ConnectedDriveBridgeHandler extends BaseBridgeHandler implements StringResponseCallback {\n+    private final Logger logger = LoggerFactory.getLogger(ConnectedDriveBridgeHandler.class);\n+    private HttpClientFactory httpClientFactory;\n+    private Optional<VehicleDiscovery> discoveryService = Optional.empty();\n+    private Optional<ConnectedDriveProxy> proxy = Optional.empty();\n+    private Optional<ConnectedDriveConfiguration> configuration = Optional.empty();\n+    private Optional<ScheduledFuture<?>> initializerJob = Optional.empty();\n+    private Optional<String> troubleshootFingerprint = Optional.empty();\n+\n+    public ConnectedDriveBridgeHandler(Bridge bridge, HttpClientFactory hcf) {\n+        super(bridge);\n+        httpClientFactory = hcf;\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        // no commands available\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        troubleshootFingerprint = Optional.empty();\n+        updateStatus(ThingStatus.UNKNOWN);\n+        configuration = Optional.of(getConfigAs(ConnectedDriveConfiguration.class));\n+        configuration.ifPresentOrElse(config -> {\n+            proxy = Optional.of(new ConnectedDriveProxy(httpClientFactory, config));\n+            // give the system some time to create all predefined Vehicles\n+            initializerJob = Optional.of(scheduler.schedule(this::requestVehicles, 5, TimeUnit.SECONDS));\n+        }, () -> {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR);\n+        });", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5Nzg4NDMxNQ=="}, "originalCommit": {"oid": "48af48c82562d006b6f2aa35922270f181c885ed"}, "originalPosition": 82}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5ODI3ODg5OA==", "bodyText": "fixed in weymann#7", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r598278898", "createdAt": "2021-03-21T13:20:09Z", "author": {"login": "ntruchsess"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/ConnectedDriveBridgeHandler.java", "diffHunk": "@@ -0,0 +1,202 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bmwconnecteddrive.internal.handler;\n+\n+import static org.openhab.binding.bmwconnecteddrive.internal.utils.Constants.ANONYMOUS;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Optional;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.bmwconnecteddrive.internal.ConnectedDriveConfiguration;\n+import org.openhab.binding.bmwconnecteddrive.internal.discovery.VehicleDiscovery;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.NetworkError;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.discovery.Dealer;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.discovery.VehiclesContainer;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Constants;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Converter;\n+import org.openhab.core.io.net.http.HttpClientFactory;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseBridgeHandler;\n+import org.openhab.core.thing.binding.ThingHandlerService;\n+import org.openhab.core.types.Command;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonParseException;\n+\n+/**\n+ * The {@link ConnectedDriveBridgeHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Bernd Weymann - Initial contribution\n+ */\n+@NonNullByDefault\n+public class ConnectedDriveBridgeHandler extends BaseBridgeHandler implements StringResponseCallback {\n+    private final Logger logger = LoggerFactory.getLogger(ConnectedDriveBridgeHandler.class);\n+    private HttpClientFactory httpClientFactory;\n+    private Optional<VehicleDiscovery> discoveryService = Optional.empty();\n+    private Optional<ConnectedDriveProxy> proxy = Optional.empty();\n+    private Optional<ConnectedDriveConfiguration> configuration = Optional.empty();\n+    private Optional<ScheduledFuture<?>> initializerJob = Optional.empty();\n+    private Optional<String> troubleshootFingerprint = Optional.empty();\n+\n+    public ConnectedDriveBridgeHandler(Bridge bridge, HttpClientFactory hcf) {\n+        super(bridge);\n+        httpClientFactory = hcf;\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        // no commands available\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        troubleshootFingerprint = Optional.empty();\n+        updateStatus(ThingStatus.UNKNOWN);\n+        configuration = Optional.of(getConfigAs(ConnectedDriveConfiguration.class));\n+        configuration.ifPresentOrElse(config -> {\n+            proxy = Optional.of(new ConnectedDriveProxy(httpClientFactory, config));\n+            // give the system some time to create all predefined Vehicles\n+            initializerJob = Optional.of(scheduler.schedule(this::requestVehicles, 5, TimeUnit.SECONDS));\n+        }, () -> {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR);\n+        });", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5Nzg4NDMxNQ=="}, "originalCommit": {"oid": "48af48c82562d006b6f2aa35922270f181c885ed"}, "originalPosition": 82}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzc3NjU1OTU2OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/ConnectedDriveBridgeHandler.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0xOVQxODoxMjoyNFrOI6L-yA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0yMlQyMzo0NTowM1rOI7ZGFQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5Nzg4NDYxNg==", "bodyText": "Logging to info should be used sparsely e.g. a newly started component or a user file that has been loaded. This could be debug.", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r597884616", "createdAt": "2021-03-19T18:12:24Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/ConnectedDriveBridgeHandler.java", "diffHunk": "@@ -0,0 +1,202 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bmwconnecteddrive.internal.handler;\n+\n+import static org.openhab.binding.bmwconnecteddrive.internal.utils.Constants.ANONYMOUS;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Optional;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.bmwconnecteddrive.internal.ConnectedDriveConfiguration;\n+import org.openhab.binding.bmwconnecteddrive.internal.discovery.VehicleDiscovery;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.NetworkError;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.discovery.Dealer;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.discovery.VehiclesContainer;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Constants;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Converter;\n+import org.openhab.core.io.net.http.HttpClientFactory;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseBridgeHandler;\n+import org.openhab.core.thing.binding.ThingHandlerService;\n+import org.openhab.core.types.Command;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonParseException;\n+\n+/**\n+ * The {@link ConnectedDriveBridgeHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Bernd Weymann - Initial contribution\n+ */\n+@NonNullByDefault\n+public class ConnectedDriveBridgeHandler extends BaseBridgeHandler implements StringResponseCallback {\n+    private final Logger logger = LoggerFactory.getLogger(ConnectedDriveBridgeHandler.class);\n+    private HttpClientFactory httpClientFactory;\n+    private Optional<VehicleDiscovery> discoveryService = Optional.empty();\n+    private Optional<ConnectedDriveProxy> proxy = Optional.empty();\n+    private Optional<ConnectedDriveConfiguration> configuration = Optional.empty();\n+    private Optional<ScheduledFuture<?>> initializerJob = Optional.empty();\n+    private Optional<String> troubleshootFingerprint = Optional.empty();\n+\n+    public ConnectedDriveBridgeHandler(Bridge bridge, HttpClientFactory hcf) {\n+        super(bridge);\n+        httpClientFactory = hcf;\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        // no commands available\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        troubleshootFingerprint = Optional.empty();\n+        updateStatus(ThingStatus.UNKNOWN);\n+        configuration = Optional.of(getConfigAs(ConnectedDriveConfiguration.class));\n+        configuration.ifPresentOrElse(config -> {\n+            proxy = Optional.of(new ConnectedDriveProxy(httpClientFactory, config));\n+            // give the system some time to create all predefined Vehicles\n+            initializerJob = Optional.of(scheduler.schedule(this::requestVehicles, 5, TimeUnit.SECONDS));\n+        }, () -> {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR);\n+        });\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        initializerJob.ifPresent(job -> job.cancel(true));\n+    }\n+\n+    public void requestVehicles() {\n+        proxy.ifPresent(prox -> prox.requestVehicles(this));\n+    }\n+\n+    public String getDiscoveryFingerprint() {\n+        return troubleshootFingerprint.map(fingerprint -> {\n+            VehiclesContainer container = null;\n+            try {\n+                container = Converter.getGson().fromJson(fingerprint, VehiclesContainer.class);\n+            } catch (JsonParseException jpe) {\n+                logger.info(\"Cannot parse fingerprint {}\", jpe.getMessage());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "48af48c82562d006b6f2aa35922270f181c885ed"}, "originalPosition": 100}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5OTE0ODA1Mw==", "bodyText": "Fixed", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r599148053", "createdAt": "2021-03-22T23:45:03Z", "author": {"login": "weymann"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/ConnectedDriveBridgeHandler.java", "diffHunk": "@@ -0,0 +1,202 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bmwconnecteddrive.internal.handler;\n+\n+import static org.openhab.binding.bmwconnecteddrive.internal.utils.Constants.ANONYMOUS;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Optional;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.bmwconnecteddrive.internal.ConnectedDriveConfiguration;\n+import org.openhab.binding.bmwconnecteddrive.internal.discovery.VehicleDiscovery;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.NetworkError;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.discovery.Dealer;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.discovery.VehiclesContainer;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Constants;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Converter;\n+import org.openhab.core.io.net.http.HttpClientFactory;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseBridgeHandler;\n+import org.openhab.core.thing.binding.ThingHandlerService;\n+import org.openhab.core.types.Command;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonParseException;\n+\n+/**\n+ * The {@link ConnectedDriveBridgeHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Bernd Weymann - Initial contribution\n+ */\n+@NonNullByDefault\n+public class ConnectedDriveBridgeHandler extends BaseBridgeHandler implements StringResponseCallback {\n+    private final Logger logger = LoggerFactory.getLogger(ConnectedDriveBridgeHandler.class);\n+    private HttpClientFactory httpClientFactory;\n+    private Optional<VehicleDiscovery> discoveryService = Optional.empty();\n+    private Optional<ConnectedDriveProxy> proxy = Optional.empty();\n+    private Optional<ConnectedDriveConfiguration> configuration = Optional.empty();\n+    private Optional<ScheduledFuture<?>> initializerJob = Optional.empty();\n+    private Optional<String> troubleshootFingerprint = Optional.empty();\n+\n+    public ConnectedDriveBridgeHandler(Bridge bridge, HttpClientFactory hcf) {\n+        super(bridge);\n+        httpClientFactory = hcf;\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        // no commands available\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        troubleshootFingerprint = Optional.empty();\n+        updateStatus(ThingStatus.UNKNOWN);\n+        configuration = Optional.of(getConfigAs(ConnectedDriveConfiguration.class));\n+        configuration.ifPresentOrElse(config -> {\n+            proxy = Optional.of(new ConnectedDriveProxy(httpClientFactory, config));\n+            // give the system some time to create all predefined Vehicles\n+            initializerJob = Optional.of(scheduler.schedule(this::requestVehicles, 5, TimeUnit.SECONDS));\n+        }, () -> {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR);\n+        });\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        initializerJob.ifPresent(job -> job.cancel(true));\n+    }\n+\n+    public void requestVehicles() {\n+        proxy.ifPresent(prox -> prox.requestVehicles(this));\n+    }\n+\n+    public String getDiscoveryFingerprint() {\n+        return troubleshootFingerprint.map(fingerprint -> {\n+            VehiclesContainer container = null;\n+            try {\n+                container = Converter.getGson().fromJson(fingerprint, VehiclesContainer.class);\n+            } catch (JsonParseException jpe) {\n+                logger.info(\"Cannot parse fingerprint {}\", jpe.getMessage());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5Nzg4NDYxNg=="}, "originalCommit": {"oid": "48af48c82562d006b6f2aa35922270f181c885ed"}, "originalPosition": 100}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzc3NjU2NDY0OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/ConnectedDriveBridgeHandler.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0xOVQxODoxMzo0MFrOI6MB6g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0yMlQyMzo0Njo0NVrOI7ZIlw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5Nzg4NTQxOA==", "bodyText": "You could move this block into the try branch.", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r597885418", "createdAt": "2021-03-19T18:13:40Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/ConnectedDriveBridgeHandler.java", "diffHunk": "@@ -0,0 +1,202 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bmwconnecteddrive.internal.handler;\n+\n+import static org.openhab.binding.bmwconnecteddrive.internal.utils.Constants.ANONYMOUS;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Optional;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.bmwconnecteddrive.internal.ConnectedDriveConfiguration;\n+import org.openhab.binding.bmwconnecteddrive.internal.discovery.VehicleDiscovery;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.NetworkError;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.discovery.Dealer;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.discovery.VehiclesContainer;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Constants;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Converter;\n+import org.openhab.core.io.net.http.HttpClientFactory;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseBridgeHandler;\n+import org.openhab.core.thing.binding.ThingHandlerService;\n+import org.openhab.core.types.Command;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonParseException;\n+\n+/**\n+ * The {@link ConnectedDriveBridgeHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Bernd Weymann - Initial contribution\n+ */\n+@NonNullByDefault\n+public class ConnectedDriveBridgeHandler extends BaseBridgeHandler implements StringResponseCallback {\n+    private final Logger logger = LoggerFactory.getLogger(ConnectedDriveBridgeHandler.class);\n+    private HttpClientFactory httpClientFactory;\n+    private Optional<VehicleDiscovery> discoveryService = Optional.empty();\n+    private Optional<ConnectedDriveProxy> proxy = Optional.empty();\n+    private Optional<ConnectedDriveConfiguration> configuration = Optional.empty();\n+    private Optional<ScheduledFuture<?>> initializerJob = Optional.empty();\n+    private Optional<String> troubleshootFingerprint = Optional.empty();\n+\n+    public ConnectedDriveBridgeHandler(Bridge bridge, HttpClientFactory hcf) {\n+        super(bridge);\n+        httpClientFactory = hcf;\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        // no commands available\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        troubleshootFingerprint = Optional.empty();\n+        updateStatus(ThingStatus.UNKNOWN);\n+        configuration = Optional.of(getConfigAs(ConnectedDriveConfiguration.class));\n+        configuration.ifPresentOrElse(config -> {\n+            proxy = Optional.of(new ConnectedDriveProxy(httpClientFactory, config));\n+            // give the system some time to create all predefined Vehicles\n+            initializerJob = Optional.of(scheduler.schedule(this::requestVehicles, 5, TimeUnit.SECONDS));\n+        }, () -> {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR);\n+        });\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        initializerJob.ifPresent(job -> job.cancel(true));\n+    }\n+\n+    public void requestVehicles() {\n+        proxy.ifPresent(prox -> prox.requestVehicles(this));\n+    }\n+\n+    public String getDiscoveryFingerprint() {\n+        return troubleshootFingerprint.map(fingerprint -> {\n+            VehiclesContainer container = null;\n+            try {\n+                container = Converter.getGson().fromJson(fingerprint, VehiclesContainer.class);\n+            } catch (JsonParseException jpe) {\n+                logger.info(\"Cannot parse fingerprint {}\", jpe.getMessage());\n+            }\n+            if (container != null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "48af48c82562d006b6f2aa35922270f181c885ed"}, "originalPosition": 102}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5OTE0ODY5NQ==", "bodyText": "Fixed", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r599148695", "createdAt": "2021-03-22T23:46:45Z", "author": {"login": "weymann"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/ConnectedDriveBridgeHandler.java", "diffHunk": "@@ -0,0 +1,202 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bmwconnecteddrive.internal.handler;\n+\n+import static org.openhab.binding.bmwconnecteddrive.internal.utils.Constants.ANONYMOUS;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Optional;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.bmwconnecteddrive.internal.ConnectedDriveConfiguration;\n+import org.openhab.binding.bmwconnecteddrive.internal.discovery.VehicleDiscovery;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.NetworkError;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.discovery.Dealer;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.discovery.VehiclesContainer;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Constants;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Converter;\n+import org.openhab.core.io.net.http.HttpClientFactory;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseBridgeHandler;\n+import org.openhab.core.thing.binding.ThingHandlerService;\n+import org.openhab.core.types.Command;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonParseException;\n+\n+/**\n+ * The {@link ConnectedDriveBridgeHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Bernd Weymann - Initial contribution\n+ */\n+@NonNullByDefault\n+public class ConnectedDriveBridgeHandler extends BaseBridgeHandler implements StringResponseCallback {\n+    private final Logger logger = LoggerFactory.getLogger(ConnectedDriveBridgeHandler.class);\n+    private HttpClientFactory httpClientFactory;\n+    private Optional<VehicleDiscovery> discoveryService = Optional.empty();\n+    private Optional<ConnectedDriveProxy> proxy = Optional.empty();\n+    private Optional<ConnectedDriveConfiguration> configuration = Optional.empty();\n+    private Optional<ScheduledFuture<?>> initializerJob = Optional.empty();\n+    private Optional<String> troubleshootFingerprint = Optional.empty();\n+\n+    public ConnectedDriveBridgeHandler(Bridge bridge, HttpClientFactory hcf) {\n+        super(bridge);\n+        httpClientFactory = hcf;\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        // no commands available\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        troubleshootFingerprint = Optional.empty();\n+        updateStatus(ThingStatus.UNKNOWN);\n+        configuration = Optional.of(getConfigAs(ConnectedDriveConfiguration.class));\n+        configuration.ifPresentOrElse(config -> {\n+            proxy = Optional.of(new ConnectedDriveProxy(httpClientFactory, config));\n+            // give the system some time to create all predefined Vehicles\n+            initializerJob = Optional.of(scheduler.schedule(this::requestVehicles, 5, TimeUnit.SECONDS));\n+        }, () -> {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR);\n+        });\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        initializerJob.ifPresent(job -> job.cancel(true));\n+    }\n+\n+    public void requestVehicles() {\n+        proxy.ifPresent(prox -> prox.requestVehicles(this));\n+    }\n+\n+    public String getDiscoveryFingerprint() {\n+        return troubleshootFingerprint.map(fingerprint -> {\n+            VehiclesContainer container = null;\n+            try {\n+                container = Converter.getGson().fromJson(fingerprint, VehiclesContainer.class);\n+            } catch (JsonParseException jpe) {\n+                logger.info(\"Cannot parse fingerprint {}\", jpe.getMessage());\n+            }\n+            if (container != null) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5Nzg4NTQxOA=="}, "originalCommit": {"oid": "48af48c82562d006b6f2aa35922270f181c885ed"}, "originalPosition": 102}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzc3NjU3MzA2OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/ConnectedDriveProxy.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0xOVQxODoxNjoxM1rOI6MHVw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0yN1QyMDozODoyMVrOI-3W2A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5Nzg4NjgwNw==", "bodyText": "Is the Thing usable if this exception is rised? You could throw the exception and set the Thing offline with the exception's message.", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r597886807", "createdAt": "2021-03-19T18:16:13Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/ConnectedDriveProxy.java", "diffHunk": "@@ -0,0 +1,314 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bmwconnecteddrive.internal.handler;\n+\n+import static org.openhab.binding.bmwconnecteddrive.internal.utils.HTTPConstants.*;\n+\n+import java.nio.charset.Charset;\n+import java.nio.charset.StandardCharsets;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.client.util.BufferingResponseListener;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.eclipse.jetty.http.HttpField;\n+import org.eclipse.jetty.http.HttpFields;\n+import org.eclipse.jetty.http.HttpHeader;\n+import org.eclipse.jetty.util.MultiMap;\n+import org.eclipse.jetty.util.UrlEncoded;\n+import org.openhab.binding.bmwconnecteddrive.internal.ConnectedDriveConfiguration;\n+import org.openhab.binding.bmwconnecteddrive.internal.VehicleConfiguration;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.NetworkError;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.auth.AuthResponse;\n+import org.openhab.binding.bmwconnecteddrive.internal.handler.simulation.Injector;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.BimmerConstants;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Constants;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Converter;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ImageProperties;\n+import org.openhab.core.io.net.http.HttpClientFactory;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonSyntaxException;\n+\n+/**\n+ * The {@link ConnectedDriveProxy} This class holds the important constants for the BMW Connected Drive Authorization.\n+ * They\n+ * are taken from the Bimmercode from github {@link https://github.com/bimmerconnected/bimmer_connected}\n+ * File defining these constants\n+ * {@link https://github.com/bimmerconnected/bimmer_connected/blob/master/bimmer_connected/account.py}\n+ * https://customer.bmwgroup.com/one/app/oauth.js\n+ *\n+ * @author Bernd Weymann - Initial contribution\n+ * @author Norbert Truchsess - edit & send of charge profile\n+ */\n+@NonNullByDefault\n+public class ConnectedDriveProxy {\n+    private final Logger logger = LoggerFactory.getLogger(ConnectedDriveProxy.class);\n+    private final Token token = new Token();\n+    private final HttpClient httpClient;\n+    private final HttpClient authHttpClient;\n+    private final String legacyAuthUri;\n+    private final ConnectedDriveConfiguration configuration;\n+\n+    /**\n+     * URLs taken from https://github.com/bimmerconnected/bimmer_connected/blob/master/bimmer_connected/const.py\n+     */\n+    final String baseUrl;\n+    final String vehicleUrl;\n+    final String legacyUrl;\n+    final String vehicleStatusAPI = \"/status\";\n+    final String lastTripAPI = \"/statistics/lastTrip\";\n+    final String allTripsAPI = \"/statistics/allTrips\";\n+    final String chargeAPI = \"/chargingprofile\";\n+    final String destinationAPI = \"/destinations\";\n+    final String imageAPI = \"/image\";\n+    final String rangeMapAPI = \"/rangemap\";\n+    final String serviceExecutionAPI = \"/executeService\";\n+    final String serviceExecutionStateAPI = \"/serviceExecutionStatus\";\n+\n+    public ConnectedDriveProxy(HttpClientFactory httpClientFactory, ConnectedDriveConfiguration config) {\n+        httpClient = httpClientFactory.getCommonHttpClient();\n+        authHttpClient = httpClientFactory.createHttpClient(AUTH_HTTP_CLIENT_NAME);\n+        authHttpClient.setFollowRedirects(false);\n+        try {\n+            authHttpClient.start();\n+        } catch (Exception e) {\n+            logger.warn(\"Auth Http Client cannot be started\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "48af48c82562d006b6f2aa35922270f181c885ed"}, "originalPosition": 93}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMjc4OTU5Mg==", "bodyText": "Right. After some thoughts I don't think it's the right place. I moved this into updateToken so if client isn't started it will be tried again for recovery. If updateToken fails correpsonding callback.onError is called and thing will be set to OFFLINE.", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r602789592", "createdAt": "2021-03-27T20:38:21Z", "author": {"login": "weymann"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/ConnectedDriveProxy.java", "diffHunk": "@@ -0,0 +1,314 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bmwconnecteddrive.internal.handler;\n+\n+import static org.openhab.binding.bmwconnecteddrive.internal.utils.HTTPConstants.*;\n+\n+import java.nio.charset.Charset;\n+import java.nio.charset.StandardCharsets;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.client.util.BufferingResponseListener;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.eclipse.jetty.http.HttpField;\n+import org.eclipse.jetty.http.HttpFields;\n+import org.eclipse.jetty.http.HttpHeader;\n+import org.eclipse.jetty.util.MultiMap;\n+import org.eclipse.jetty.util.UrlEncoded;\n+import org.openhab.binding.bmwconnecteddrive.internal.ConnectedDriveConfiguration;\n+import org.openhab.binding.bmwconnecteddrive.internal.VehicleConfiguration;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.NetworkError;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.auth.AuthResponse;\n+import org.openhab.binding.bmwconnecteddrive.internal.handler.simulation.Injector;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.BimmerConstants;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Constants;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Converter;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ImageProperties;\n+import org.openhab.core.io.net.http.HttpClientFactory;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonSyntaxException;\n+\n+/**\n+ * The {@link ConnectedDriveProxy} This class holds the important constants for the BMW Connected Drive Authorization.\n+ * They\n+ * are taken from the Bimmercode from github {@link https://github.com/bimmerconnected/bimmer_connected}\n+ * File defining these constants\n+ * {@link https://github.com/bimmerconnected/bimmer_connected/blob/master/bimmer_connected/account.py}\n+ * https://customer.bmwgroup.com/one/app/oauth.js\n+ *\n+ * @author Bernd Weymann - Initial contribution\n+ * @author Norbert Truchsess - edit & send of charge profile\n+ */\n+@NonNullByDefault\n+public class ConnectedDriveProxy {\n+    private final Logger logger = LoggerFactory.getLogger(ConnectedDriveProxy.class);\n+    private final Token token = new Token();\n+    private final HttpClient httpClient;\n+    private final HttpClient authHttpClient;\n+    private final String legacyAuthUri;\n+    private final ConnectedDriveConfiguration configuration;\n+\n+    /**\n+     * URLs taken from https://github.com/bimmerconnected/bimmer_connected/blob/master/bimmer_connected/const.py\n+     */\n+    final String baseUrl;\n+    final String vehicleUrl;\n+    final String legacyUrl;\n+    final String vehicleStatusAPI = \"/status\";\n+    final String lastTripAPI = \"/statistics/lastTrip\";\n+    final String allTripsAPI = \"/statistics/allTrips\";\n+    final String chargeAPI = \"/chargingprofile\";\n+    final String destinationAPI = \"/destinations\";\n+    final String imageAPI = \"/image\";\n+    final String rangeMapAPI = \"/rangemap\";\n+    final String serviceExecutionAPI = \"/executeService\";\n+    final String serviceExecutionStateAPI = \"/serviceExecutionStatus\";\n+\n+    public ConnectedDriveProxy(HttpClientFactory httpClientFactory, ConnectedDriveConfiguration config) {\n+        httpClient = httpClientFactory.getCommonHttpClient();\n+        authHttpClient = httpClientFactory.createHttpClient(AUTH_HTTP_CLIENT_NAME);\n+        authHttpClient.setFollowRedirects(false);\n+        try {\n+            authHttpClient.start();\n+        } catch (Exception e) {\n+            logger.warn(\"Auth Http Client cannot be started\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5Nzg4NjgwNw=="}, "originalCommit": {"oid": "48af48c82562d006b6f2aa35922270f181c885ed"}, "originalPosition": 93}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzc3NjU3ODgxOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/ConnectedDriveProxy.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0xOVQxODoxNzo0M1rOI6MK1Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0yMlQyMzo1NDoxNFrOI7ZS2w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5Nzg4NzcwMQ==", "bodyText": "Logging to info should be used sparsely e.g. a newly started component or a user file that has been loaded. This could be warn.\nPlease check all.", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r597887701", "createdAt": "2021-03-19T18:17:43Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/ConnectedDriveProxy.java", "diffHunk": "@@ -0,0 +1,314 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bmwconnecteddrive.internal.handler;\n+\n+import static org.openhab.binding.bmwconnecteddrive.internal.utils.HTTPConstants.*;\n+\n+import java.nio.charset.Charset;\n+import java.nio.charset.StandardCharsets;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.client.util.BufferingResponseListener;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.eclipse.jetty.http.HttpField;\n+import org.eclipse.jetty.http.HttpFields;\n+import org.eclipse.jetty.http.HttpHeader;\n+import org.eclipse.jetty.util.MultiMap;\n+import org.eclipse.jetty.util.UrlEncoded;\n+import org.openhab.binding.bmwconnecteddrive.internal.ConnectedDriveConfiguration;\n+import org.openhab.binding.bmwconnecteddrive.internal.VehicleConfiguration;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.NetworkError;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.auth.AuthResponse;\n+import org.openhab.binding.bmwconnecteddrive.internal.handler.simulation.Injector;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.BimmerConstants;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Constants;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Converter;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ImageProperties;\n+import org.openhab.core.io.net.http.HttpClientFactory;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonSyntaxException;\n+\n+/**\n+ * The {@link ConnectedDriveProxy} This class holds the important constants for the BMW Connected Drive Authorization.\n+ * They\n+ * are taken from the Bimmercode from github {@link https://github.com/bimmerconnected/bimmer_connected}\n+ * File defining these constants\n+ * {@link https://github.com/bimmerconnected/bimmer_connected/blob/master/bimmer_connected/account.py}\n+ * https://customer.bmwgroup.com/one/app/oauth.js\n+ *\n+ * @author Bernd Weymann - Initial contribution\n+ * @author Norbert Truchsess - edit & send of charge profile\n+ */\n+@NonNullByDefault\n+public class ConnectedDriveProxy {\n+    private final Logger logger = LoggerFactory.getLogger(ConnectedDriveProxy.class);\n+    private final Token token = new Token();\n+    private final HttpClient httpClient;\n+    private final HttpClient authHttpClient;\n+    private final String legacyAuthUri;\n+    private final ConnectedDriveConfiguration configuration;\n+\n+    /**\n+     * URLs taken from https://github.com/bimmerconnected/bimmer_connected/blob/master/bimmer_connected/const.py\n+     */\n+    final String baseUrl;\n+    final String vehicleUrl;\n+    final String legacyUrl;\n+    final String vehicleStatusAPI = \"/status\";\n+    final String lastTripAPI = \"/statistics/lastTrip\";\n+    final String allTripsAPI = \"/statistics/allTrips\";\n+    final String chargeAPI = \"/chargingprofile\";\n+    final String destinationAPI = \"/destinations\";\n+    final String imageAPI = \"/image\";\n+    final String rangeMapAPI = \"/rangemap\";\n+    final String serviceExecutionAPI = \"/executeService\";\n+    final String serviceExecutionStateAPI = \"/serviceExecutionStatus\";\n+\n+    public ConnectedDriveProxy(HttpClientFactory httpClientFactory, ConnectedDriveConfiguration config) {\n+        httpClient = httpClientFactory.getCommonHttpClient();\n+        authHttpClient = httpClientFactory.createHttpClient(AUTH_HTTP_CLIENT_NAME);\n+        authHttpClient.setFollowRedirects(false);\n+        try {\n+            authHttpClient.start();\n+        } catch (Exception e) {\n+            logger.warn(\"Auth Http Client cannot be started\");\n+        }\n+        configuration = config;\n+\n+        final StringBuilder legacyAuth = new StringBuilder();\n+        legacyAuth.append(\"https://\");\n+        legacyAuth.append(BimmerConstants.AUTH_SERVER_MAP.get(configuration.region));\n+        legacyAuth.append(BimmerConstants.OAUTH_ENDPOINT);\n+        legacyAuthUri = legacyAuth.toString();\n+        vehicleUrl = \"https://\" + getRegionServer() + \"/webapi/v1/user/vehicles\";\n+        baseUrl = vehicleUrl + \"/\";\n+        legacyUrl = \"https://\" + getRegionServer() + \"/api/vehicle/dynamic/v1/\";\n+    }\n+\n+    private synchronized void call(final String url, final boolean post, final @Nullable MultiMap<String> params,\n+            final ResponseCallback callback) {\n+        // only executed in \"simulation mode\"\n+        // SimulationTest.testSimulationOff() assures Injector is off when releasing\n+        if (Injector.isActive()) {\n+            if (url.equals(baseUrl)) {\n+                ((StringResponseCallback) callback).onResponse(Injector.getDiscovery());\n+            } else if (url.endsWith(vehicleStatusAPI)) {\n+                ((StringResponseCallback) callback).onResponse(Injector.getStatus());\n+            } else {\n+                logger.info(\"Simulation of {} not supported\", url);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "48af48c82562d006b6f2aa35922270f181c885ed"}, "originalPosition": 117}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5OTE1MTMyMw==", "bodyText": "It's only used for Simulation purposes, so reduced to debug", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r599151323", "createdAt": "2021-03-22T23:54:14Z", "author": {"login": "weymann"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/ConnectedDriveProxy.java", "diffHunk": "@@ -0,0 +1,314 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bmwconnecteddrive.internal.handler;\n+\n+import static org.openhab.binding.bmwconnecteddrive.internal.utils.HTTPConstants.*;\n+\n+import java.nio.charset.Charset;\n+import java.nio.charset.StandardCharsets;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.client.util.BufferingResponseListener;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.eclipse.jetty.http.HttpField;\n+import org.eclipse.jetty.http.HttpFields;\n+import org.eclipse.jetty.http.HttpHeader;\n+import org.eclipse.jetty.util.MultiMap;\n+import org.eclipse.jetty.util.UrlEncoded;\n+import org.openhab.binding.bmwconnecteddrive.internal.ConnectedDriveConfiguration;\n+import org.openhab.binding.bmwconnecteddrive.internal.VehicleConfiguration;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.NetworkError;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.auth.AuthResponse;\n+import org.openhab.binding.bmwconnecteddrive.internal.handler.simulation.Injector;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.BimmerConstants;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Constants;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Converter;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ImageProperties;\n+import org.openhab.core.io.net.http.HttpClientFactory;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonSyntaxException;\n+\n+/**\n+ * The {@link ConnectedDriveProxy} This class holds the important constants for the BMW Connected Drive Authorization.\n+ * They\n+ * are taken from the Bimmercode from github {@link https://github.com/bimmerconnected/bimmer_connected}\n+ * File defining these constants\n+ * {@link https://github.com/bimmerconnected/bimmer_connected/blob/master/bimmer_connected/account.py}\n+ * https://customer.bmwgroup.com/one/app/oauth.js\n+ *\n+ * @author Bernd Weymann - Initial contribution\n+ * @author Norbert Truchsess - edit & send of charge profile\n+ */\n+@NonNullByDefault\n+public class ConnectedDriveProxy {\n+    private final Logger logger = LoggerFactory.getLogger(ConnectedDriveProxy.class);\n+    private final Token token = new Token();\n+    private final HttpClient httpClient;\n+    private final HttpClient authHttpClient;\n+    private final String legacyAuthUri;\n+    private final ConnectedDriveConfiguration configuration;\n+\n+    /**\n+     * URLs taken from https://github.com/bimmerconnected/bimmer_connected/blob/master/bimmer_connected/const.py\n+     */\n+    final String baseUrl;\n+    final String vehicleUrl;\n+    final String legacyUrl;\n+    final String vehicleStatusAPI = \"/status\";\n+    final String lastTripAPI = \"/statistics/lastTrip\";\n+    final String allTripsAPI = \"/statistics/allTrips\";\n+    final String chargeAPI = \"/chargingprofile\";\n+    final String destinationAPI = \"/destinations\";\n+    final String imageAPI = \"/image\";\n+    final String rangeMapAPI = \"/rangemap\";\n+    final String serviceExecutionAPI = \"/executeService\";\n+    final String serviceExecutionStateAPI = \"/serviceExecutionStatus\";\n+\n+    public ConnectedDriveProxy(HttpClientFactory httpClientFactory, ConnectedDriveConfiguration config) {\n+        httpClient = httpClientFactory.getCommonHttpClient();\n+        authHttpClient = httpClientFactory.createHttpClient(AUTH_HTTP_CLIENT_NAME);\n+        authHttpClient.setFollowRedirects(false);\n+        try {\n+            authHttpClient.start();\n+        } catch (Exception e) {\n+            logger.warn(\"Auth Http Client cannot be started\");\n+        }\n+        configuration = config;\n+\n+        final StringBuilder legacyAuth = new StringBuilder();\n+        legacyAuth.append(\"https://\");\n+        legacyAuth.append(BimmerConstants.AUTH_SERVER_MAP.get(configuration.region));\n+        legacyAuth.append(BimmerConstants.OAUTH_ENDPOINT);\n+        legacyAuthUri = legacyAuth.toString();\n+        vehicleUrl = \"https://\" + getRegionServer() + \"/webapi/v1/user/vehicles\";\n+        baseUrl = vehicleUrl + \"/\";\n+        legacyUrl = \"https://\" + getRegionServer() + \"/api/vehicle/dynamic/v1/\";\n+    }\n+\n+    private synchronized void call(final String url, final boolean post, final @Nullable MultiMap<String> params,\n+            final ResponseCallback callback) {\n+        // only executed in \"simulation mode\"\n+        // SimulationTest.testSimulationOff() assures Injector is off when releasing\n+        if (Injector.isActive()) {\n+            if (url.equals(baseUrl)) {\n+                ((StringResponseCallback) callback).onResponse(Injector.getDiscovery());\n+            } else if (url.endsWith(vehicleStatusAPI)) {\n+                ((StringResponseCallback) callback).onResponse(Injector.getStatus());\n+            } else {\n+                logger.info(\"Simulation of {} not supported\", url);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5Nzg4NzcwMQ=="}, "originalCommit": {"oid": "48af48c82562d006b6f2aa35922270f181c885ed"}, "originalPosition": 117}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzc3NjU4NDg5OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/ConnectedDriveProxy.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0xOVQxODoxOTowOVrOI6MOjg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0yMVQxMzoyOTozOFrOI6kIXg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5Nzg4ODY1NA==", "bodyText": "This applies the charset of the user's JVM. I would expect that the API expects a specific encoding.\nPlease check all.", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r597888654", "createdAt": "2021-03-19T18:19:09Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/ConnectedDriveProxy.java", "diffHunk": "@@ -0,0 +1,314 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bmwconnecteddrive.internal.handler;\n+\n+import static org.openhab.binding.bmwconnecteddrive.internal.utils.HTTPConstants.*;\n+\n+import java.nio.charset.Charset;\n+import java.nio.charset.StandardCharsets;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.client.util.BufferingResponseListener;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.eclipse.jetty.http.HttpField;\n+import org.eclipse.jetty.http.HttpFields;\n+import org.eclipse.jetty.http.HttpHeader;\n+import org.eclipse.jetty.util.MultiMap;\n+import org.eclipse.jetty.util.UrlEncoded;\n+import org.openhab.binding.bmwconnecteddrive.internal.ConnectedDriveConfiguration;\n+import org.openhab.binding.bmwconnecteddrive.internal.VehicleConfiguration;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.NetworkError;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.auth.AuthResponse;\n+import org.openhab.binding.bmwconnecteddrive.internal.handler.simulation.Injector;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.BimmerConstants;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Constants;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Converter;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ImageProperties;\n+import org.openhab.core.io.net.http.HttpClientFactory;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonSyntaxException;\n+\n+/**\n+ * The {@link ConnectedDriveProxy} This class holds the important constants for the BMW Connected Drive Authorization.\n+ * They\n+ * are taken from the Bimmercode from github {@link https://github.com/bimmerconnected/bimmer_connected}\n+ * File defining these constants\n+ * {@link https://github.com/bimmerconnected/bimmer_connected/blob/master/bimmer_connected/account.py}\n+ * https://customer.bmwgroup.com/one/app/oauth.js\n+ *\n+ * @author Bernd Weymann - Initial contribution\n+ * @author Norbert Truchsess - edit & send of charge profile\n+ */\n+@NonNullByDefault\n+public class ConnectedDriveProxy {\n+    private final Logger logger = LoggerFactory.getLogger(ConnectedDriveProxy.class);\n+    private final Token token = new Token();\n+    private final HttpClient httpClient;\n+    private final HttpClient authHttpClient;\n+    private final String legacyAuthUri;\n+    private final ConnectedDriveConfiguration configuration;\n+\n+    /**\n+     * URLs taken from https://github.com/bimmerconnected/bimmer_connected/blob/master/bimmer_connected/const.py\n+     */\n+    final String baseUrl;\n+    final String vehicleUrl;\n+    final String legacyUrl;\n+    final String vehicleStatusAPI = \"/status\";\n+    final String lastTripAPI = \"/statistics/lastTrip\";\n+    final String allTripsAPI = \"/statistics/allTrips\";\n+    final String chargeAPI = \"/chargingprofile\";\n+    final String destinationAPI = \"/destinations\";\n+    final String imageAPI = \"/image\";\n+    final String rangeMapAPI = \"/rangemap\";\n+    final String serviceExecutionAPI = \"/executeService\";\n+    final String serviceExecutionStateAPI = \"/serviceExecutionStatus\";\n+\n+    public ConnectedDriveProxy(HttpClientFactory httpClientFactory, ConnectedDriveConfiguration config) {\n+        httpClient = httpClientFactory.getCommonHttpClient();\n+        authHttpClient = httpClientFactory.createHttpClient(AUTH_HTTP_CLIENT_NAME);\n+        authHttpClient.setFollowRedirects(false);\n+        try {\n+            authHttpClient.start();\n+        } catch (Exception e) {\n+            logger.warn(\"Auth Http Client cannot be started\");\n+        }\n+        configuration = config;\n+\n+        final StringBuilder legacyAuth = new StringBuilder();\n+        legacyAuth.append(\"https://\");\n+        legacyAuth.append(BimmerConstants.AUTH_SERVER_MAP.get(configuration.region));\n+        legacyAuth.append(BimmerConstants.OAUTH_ENDPOINT);\n+        legacyAuthUri = legacyAuth.toString();\n+        vehicleUrl = \"https://\" + getRegionServer() + \"/webapi/v1/user/vehicles\";\n+        baseUrl = vehicleUrl + \"/\";\n+        legacyUrl = \"https://\" + getRegionServer() + \"/api/vehicle/dynamic/v1/\";\n+    }\n+\n+    private synchronized void call(final String url, final boolean post, final @Nullable MultiMap<String> params,\n+            final ResponseCallback callback) {\n+        // only executed in \"simulation mode\"\n+        // SimulationTest.testSimulationOff() assures Injector is off when releasing\n+        if (Injector.isActive()) {\n+            if (url.equals(baseUrl)) {\n+                ((StringResponseCallback) callback).onResponse(Injector.getDiscovery());\n+            } else if (url.endsWith(vehicleStatusAPI)) {\n+                ((StringResponseCallback) callback).onResponse(Injector.getStatus());\n+            } else {\n+                logger.info(\"Simulation of {} not supported\", url);\n+            }\n+            return;\n+        }\n+        final Request req;\n+        final String encoded = params == null || params.isEmpty() ? null\n+                : UrlEncoded.encode(params, Charset.defaultCharset(), false);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "48af48c82562d006b6f2aa35922270f181c885ed"}, "originalPosition": 123}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5ODI4MDI4Ng==", "bodyText": "fixed in weymann#8", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r598280286", "createdAt": "2021-03-21T13:29:38Z", "author": {"login": "ntruchsess"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/ConnectedDriveProxy.java", "diffHunk": "@@ -0,0 +1,314 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bmwconnecteddrive.internal.handler;\n+\n+import static org.openhab.binding.bmwconnecteddrive.internal.utils.HTTPConstants.*;\n+\n+import java.nio.charset.Charset;\n+import java.nio.charset.StandardCharsets;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.client.util.BufferingResponseListener;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.eclipse.jetty.http.HttpField;\n+import org.eclipse.jetty.http.HttpFields;\n+import org.eclipse.jetty.http.HttpHeader;\n+import org.eclipse.jetty.util.MultiMap;\n+import org.eclipse.jetty.util.UrlEncoded;\n+import org.openhab.binding.bmwconnecteddrive.internal.ConnectedDriveConfiguration;\n+import org.openhab.binding.bmwconnecteddrive.internal.VehicleConfiguration;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.NetworkError;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.auth.AuthResponse;\n+import org.openhab.binding.bmwconnecteddrive.internal.handler.simulation.Injector;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.BimmerConstants;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Constants;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Converter;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ImageProperties;\n+import org.openhab.core.io.net.http.HttpClientFactory;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonSyntaxException;\n+\n+/**\n+ * The {@link ConnectedDriveProxy} This class holds the important constants for the BMW Connected Drive Authorization.\n+ * They\n+ * are taken from the Bimmercode from github {@link https://github.com/bimmerconnected/bimmer_connected}\n+ * File defining these constants\n+ * {@link https://github.com/bimmerconnected/bimmer_connected/blob/master/bimmer_connected/account.py}\n+ * https://customer.bmwgroup.com/one/app/oauth.js\n+ *\n+ * @author Bernd Weymann - Initial contribution\n+ * @author Norbert Truchsess - edit & send of charge profile\n+ */\n+@NonNullByDefault\n+public class ConnectedDriveProxy {\n+    private final Logger logger = LoggerFactory.getLogger(ConnectedDriveProxy.class);\n+    private final Token token = new Token();\n+    private final HttpClient httpClient;\n+    private final HttpClient authHttpClient;\n+    private final String legacyAuthUri;\n+    private final ConnectedDriveConfiguration configuration;\n+\n+    /**\n+     * URLs taken from https://github.com/bimmerconnected/bimmer_connected/blob/master/bimmer_connected/const.py\n+     */\n+    final String baseUrl;\n+    final String vehicleUrl;\n+    final String legacyUrl;\n+    final String vehicleStatusAPI = \"/status\";\n+    final String lastTripAPI = \"/statistics/lastTrip\";\n+    final String allTripsAPI = \"/statistics/allTrips\";\n+    final String chargeAPI = \"/chargingprofile\";\n+    final String destinationAPI = \"/destinations\";\n+    final String imageAPI = \"/image\";\n+    final String rangeMapAPI = \"/rangemap\";\n+    final String serviceExecutionAPI = \"/executeService\";\n+    final String serviceExecutionStateAPI = \"/serviceExecutionStatus\";\n+\n+    public ConnectedDriveProxy(HttpClientFactory httpClientFactory, ConnectedDriveConfiguration config) {\n+        httpClient = httpClientFactory.getCommonHttpClient();\n+        authHttpClient = httpClientFactory.createHttpClient(AUTH_HTTP_CLIENT_NAME);\n+        authHttpClient.setFollowRedirects(false);\n+        try {\n+            authHttpClient.start();\n+        } catch (Exception e) {\n+            logger.warn(\"Auth Http Client cannot be started\");\n+        }\n+        configuration = config;\n+\n+        final StringBuilder legacyAuth = new StringBuilder();\n+        legacyAuth.append(\"https://\");\n+        legacyAuth.append(BimmerConstants.AUTH_SERVER_MAP.get(configuration.region));\n+        legacyAuth.append(BimmerConstants.OAUTH_ENDPOINT);\n+        legacyAuthUri = legacyAuth.toString();\n+        vehicleUrl = \"https://\" + getRegionServer() + \"/webapi/v1/user/vehicles\";\n+        baseUrl = vehicleUrl + \"/\";\n+        legacyUrl = \"https://\" + getRegionServer() + \"/api/vehicle/dynamic/v1/\";\n+    }\n+\n+    private synchronized void call(final String url, final boolean post, final @Nullable MultiMap<String> params,\n+            final ResponseCallback callback) {\n+        // only executed in \"simulation mode\"\n+        // SimulationTest.testSimulationOff() assures Injector is off when releasing\n+        if (Injector.isActive()) {\n+            if (url.equals(baseUrl)) {\n+                ((StringResponseCallback) callback).onResponse(Injector.getDiscovery());\n+            } else if (url.endsWith(vehicleStatusAPI)) {\n+                ((StringResponseCallback) callback).onResponse(Injector.getStatus());\n+            } else {\n+                logger.info(\"Simulation of {} not supported\", url);\n+            }\n+            return;\n+        }\n+        final Request req;\n+        final String encoded = params == null || params.isEmpty() ? null\n+                : UrlEncoded.encode(params, Charset.defaultCharset(), false);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5Nzg4ODY1NA=="}, "originalCommit": {"oid": "48af48c82562d006b6f2aa35922270f181c885ed"}, "originalPosition": 123}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzc3NjU5MDIxOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/ConnectedDriveProxy.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0xOVQxODoyMDoyOFrOI6MRyQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0yMVQxMzozMjoxOVrOI6kJsQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5Nzg4OTQ4MQ==", "bodyText": "Please add the package to the imports.", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r597889481", "createdAt": "2021-03-19T18:20:28Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/ConnectedDriveProxy.java", "diffHunk": "@@ -0,0 +1,314 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bmwconnecteddrive.internal.handler;\n+\n+import static org.openhab.binding.bmwconnecteddrive.internal.utils.HTTPConstants.*;\n+\n+import java.nio.charset.Charset;\n+import java.nio.charset.StandardCharsets;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.client.util.BufferingResponseListener;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.eclipse.jetty.http.HttpField;\n+import org.eclipse.jetty.http.HttpFields;\n+import org.eclipse.jetty.http.HttpHeader;\n+import org.eclipse.jetty.util.MultiMap;\n+import org.eclipse.jetty.util.UrlEncoded;\n+import org.openhab.binding.bmwconnecteddrive.internal.ConnectedDriveConfiguration;\n+import org.openhab.binding.bmwconnecteddrive.internal.VehicleConfiguration;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.NetworkError;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.auth.AuthResponse;\n+import org.openhab.binding.bmwconnecteddrive.internal.handler.simulation.Injector;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.BimmerConstants;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Constants;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Converter;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ImageProperties;\n+import org.openhab.core.io.net.http.HttpClientFactory;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonSyntaxException;\n+\n+/**\n+ * The {@link ConnectedDriveProxy} This class holds the important constants for the BMW Connected Drive Authorization.\n+ * They\n+ * are taken from the Bimmercode from github {@link https://github.com/bimmerconnected/bimmer_connected}\n+ * File defining these constants\n+ * {@link https://github.com/bimmerconnected/bimmer_connected/blob/master/bimmer_connected/account.py}\n+ * https://customer.bmwgroup.com/one/app/oauth.js\n+ *\n+ * @author Bernd Weymann - Initial contribution\n+ * @author Norbert Truchsess - edit & send of charge profile\n+ */\n+@NonNullByDefault\n+public class ConnectedDriveProxy {\n+    private final Logger logger = LoggerFactory.getLogger(ConnectedDriveProxy.class);\n+    private final Token token = new Token();\n+    private final HttpClient httpClient;\n+    private final HttpClient authHttpClient;\n+    private final String legacyAuthUri;\n+    private final ConnectedDriveConfiguration configuration;\n+\n+    /**\n+     * URLs taken from https://github.com/bimmerconnected/bimmer_connected/blob/master/bimmer_connected/const.py\n+     */\n+    final String baseUrl;\n+    final String vehicleUrl;\n+    final String legacyUrl;\n+    final String vehicleStatusAPI = \"/status\";\n+    final String lastTripAPI = \"/statistics/lastTrip\";\n+    final String allTripsAPI = \"/statistics/allTrips\";\n+    final String chargeAPI = \"/chargingprofile\";\n+    final String destinationAPI = \"/destinations\";\n+    final String imageAPI = \"/image\";\n+    final String rangeMapAPI = \"/rangemap\";\n+    final String serviceExecutionAPI = \"/executeService\";\n+    final String serviceExecutionStateAPI = \"/serviceExecutionStatus\";\n+\n+    public ConnectedDriveProxy(HttpClientFactory httpClientFactory, ConnectedDriveConfiguration config) {\n+        httpClient = httpClientFactory.getCommonHttpClient();\n+        authHttpClient = httpClientFactory.createHttpClient(AUTH_HTTP_CLIENT_NAME);\n+        authHttpClient.setFollowRedirects(false);\n+        try {\n+            authHttpClient.start();\n+        } catch (Exception e) {\n+            logger.warn(\"Auth Http Client cannot be started\");\n+        }\n+        configuration = config;\n+\n+        final StringBuilder legacyAuth = new StringBuilder();\n+        legacyAuth.append(\"https://\");\n+        legacyAuth.append(BimmerConstants.AUTH_SERVER_MAP.get(configuration.region));\n+        legacyAuth.append(BimmerConstants.OAUTH_ENDPOINT);\n+        legacyAuthUri = legacyAuth.toString();\n+        vehicleUrl = \"https://\" + getRegionServer() + \"/webapi/v1/user/vehicles\";\n+        baseUrl = vehicleUrl + \"/\";\n+        legacyUrl = \"https://\" + getRegionServer() + \"/api/vehicle/dynamic/v1/\";\n+    }\n+\n+    private synchronized void call(final String url, final boolean post, final @Nullable MultiMap<String> params,\n+            final ResponseCallback callback) {\n+        // only executed in \"simulation mode\"\n+        // SimulationTest.testSimulationOff() assures Injector is off when releasing\n+        if (Injector.isActive()) {\n+            if (url.equals(baseUrl)) {\n+                ((StringResponseCallback) callback).onResponse(Injector.getDiscovery());\n+            } else if (url.endsWith(vehicleStatusAPI)) {\n+                ((StringResponseCallback) callback).onResponse(Injector.getStatus());\n+            } else {\n+                logger.info(\"Simulation of {} not supported\", url);\n+            }\n+            return;\n+        }\n+        final Request req;\n+        final String encoded = params == null || params.isEmpty() ? null\n+                : UrlEncoded.encode(params, Charset.defaultCharset(), false);\n+        final String completeUrl;\n+\n+        if (post) {\n+            completeUrl = url;\n+            req = httpClient.POST(url);\n+            if (encoded != null) {\n+                req.content(new StringContentProvider(CONTENT_TYPE_URL_ENCODED, encoded, Charset.defaultCharset()));\n+            }\n+        } else {\n+            completeUrl = encoded == null ? url : url + Constants.QUESTION + encoded;\n+            req = httpClient.newRequest(completeUrl);\n+        }\n+        req.header(HttpHeader.AUTHORIZATION, getToken().getBearerToken());\n+        req.header(HttpHeader.REFERER, BimmerConstants.REFERER_URL);\n+\n+        req.timeout(HTTP_TIMEOUT_SEC, TimeUnit.SECONDS).send(new BufferingResponseListener() {\n+            @NonNullByDefault({})\n+            @Override\n+            public void onComplete(org.eclipse.jetty.client.api.Result result) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "48af48c82562d006b6f2aa35922270f181c885ed"}, "originalPosition": 142}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5ODI4MDYyNQ==", "bodyText": "also fixed in weymann#8", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r598280625", "createdAt": "2021-03-21T13:32:19Z", "author": {"login": "ntruchsess"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/ConnectedDriveProxy.java", "diffHunk": "@@ -0,0 +1,314 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bmwconnecteddrive.internal.handler;\n+\n+import static org.openhab.binding.bmwconnecteddrive.internal.utils.HTTPConstants.*;\n+\n+import java.nio.charset.Charset;\n+import java.nio.charset.StandardCharsets;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.client.util.BufferingResponseListener;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.eclipse.jetty.http.HttpField;\n+import org.eclipse.jetty.http.HttpFields;\n+import org.eclipse.jetty.http.HttpHeader;\n+import org.eclipse.jetty.util.MultiMap;\n+import org.eclipse.jetty.util.UrlEncoded;\n+import org.openhab.binding.bmwconnecteddrive.internal.ConnectedDriveConfiguration;\n+import org.openhab.binding.bmwconnecteddrive.internal.VehicleConfiguration;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.NetworkError;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.auth.AuthResponse;\n+import org.openhab.binding.bmwconnecteddrive.internal.handler.simulation.Injector;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.BimmerConstants;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Constants;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Converter;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ImageProperties;\n+import org.openhab.core.io.net.http.HttpClientFactory;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonSyntaxException;\n+\n+/**\n+ * The {@link ConnectedDriveProxy} This class holds the important constants for the BMW Connected Drive Authorization.\n+ * They\n+ * are taken from the Bimmercode from github {@link https://github.com/bimmerconnected/bimmer_connected}\n+ * File defining these constants\n+ * {@link https://github.com/bimmerconnected/bimmer_connected/blob/master/bimmer_connected/account.py}\n+ * https://customer.bmwgroup.com/one/app/oauth.js\n+ *\n+ * @author Bernd Weymann - Initial contribution\n+ * @author Norbert Truchsess - edit & send of charge profile\n+ */\n+@NonNullByDefault\n+public class ConnectedDriveProxy {\n+    private final Logger logger = LoggerFactory.getLogger(ConnectedDriveProxy.class);\n+    private final Token token = new Token();\n+    private final HttpClient httpClient;\n+    private final HttpClient authHttpClient;\n+    private final String legacyAuthUri;\n+    private final ConnectedDriveConfiguration configuration;\n+\n+    /**\n+     * URLs taken from https://github.com/bimmerconnected/bimmer_connected/blob/master/bimmer_connected/const.py\n+     */\n+    final String baseUrl;\n+    final String vehicleUrl;\n+    final String legacyUrl;\n+    final String vehicleStatusAPI = \"/status\";\n+    final String lastTripAPI = \"/statistics/lastTrip\";\n+    final String allTripsAPI = \"/statistics/allTrips\";\n+    final String chargeAPI = \"/chargingprofile\";\n+    final String destinationAPI = \"/destinations\";\n+    final String imageAPI = \"/image\";\n+    final String rangeMapAPI = \"/rangemap\";\n+    final String serviceExecutionAPI = \"/executeService\";\n+    final String serviceExecutionStateAPI = \"/serviceExecutionStatus\";\n+\n+    public ConnectedDriveProxy(HttpClientFactory httpClientFactory, ConnectedDriveConfiguration config) {\n+        httpClient = httpClientFactory.getCommonHttpClient();\n+        authHttpClient = httpClientFactory.createHttpClient(AUTH_HTTP_CLIENT_NAME);\n+        authHttpClient.setFollowRedirects(false);\n+        try {\n+            authHttpClient.start();\n+        } catch (Exception e) {\n+            logger.warn(\"Auth Http Client cannot be started\");\n+        }\n+        configuration = config;\n+\n+        final StringBuilder legacyAuth = new StringBuilder();\n+        legacyAuth.append(\"https://\");\n+        legacyAuth.append(BimmerConstants.AUTH_SERVER_MAP.get(configuration.region));\n+        legacyAuth.append(BimmerConstants.OAUTH_ENDPOINT);\n+        legacyAuthUri = legacyAuth.toString();\n+        vehicleUrl = \"https://\" + getRegionServer() + \"/webapi/v1/user/vehicles\";\n+        baseUrl = vehicleUrl + \"/\";\n+        legacyUrl = \"https://\" + getRegionServer() + \"/api/vehicle/dynamic/v1/\";\n+    }\n+\n+    private synchronized void call(final String url, final boolean post, final @Nullable MultiMap<String> params,\n+            final ResponseCallback callback) {\n+        // only executed in \"simulation mode\"\n+        // SimulationTest.testSimulationOff() assures Injector is off when releasing\n+        if (Injector.isActive()) {\n+            if (url.equals(baseUrl)) {\n+                ((StringResponseCallback) callback).onResponse(Injector.getDiscovery());\n+            } else if (url.endsWith(vehicleStatusAPI)) {\n+                ((StringResponseCallback) callback).onResponse(Injector.getStatus());\n+            } else {\n+                logger.info(\"Simulation of {} not supported\", url);\n+            }\n+            return;\n+        }\n+        final Request req;\n+        final String encoded = params == null || params.isEmpty() ? null\n+                : UrlEncoded.encode(params, Charset.defaultCharset(), false);\n+        final String completeUrl;\n+\n+        if (post) {\n+            completeUrl = url;\n+            req = httpClient.POST(url);\n+            if (encoded != null) {\n+                req.content(new StringContentProvider(CONTENT_TYPE_URL_ENCODED, encoded, Charset.defaultCharset()));\n+            }\n+        } else {\n+            completeUrl = encoded == null ? url : url + Constants.QUESTION + encoded;\n+            req = httpClient.newRequest(completeUrl);\n+        }\n+        req.header(HttpHeader.AUTHORIZATION, getToken().getBearerToken());\n+        req.header(HttpHeader.REFERER, BimmerConstants.REFERER_URL);\n+\n+        req.timeout(HTTP_TIMEOUT_SEC, TimeUnit.SECONDS).send(new BufferingResponseListener() {\n+            @NonNullByDefault({})\n+            @Override\n+            public void onComplete(org.eclipse.jetty.client.api.Result result) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5Nzg4OTQ4MQ=="}, "originalCommit": {"oid": "48af48c82562d006b6f2aa35922270f181c885ed"}, "originalPosition": 142}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzc3NjU5ODM3OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/ConnectedDriveProxy.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0xOVQxODoyMjozN1rOI6MWkw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0yMlQyMzo1Njo0MlrOI7ZWGw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5Nzg5MDcwNw==", "bodyText": "Are you sure this is always StringResponseCallback?", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r597890707", "createdAt": "2021-03-19T18:22:37Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/ConnectedDriveProxy.java", "diffHunk": "@@ -0,0 +1,314 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bmwconnecteddrive.internal.handler;\n+\n+import static org.openhab.binding.bmwconnecteddrive.internal.utils.HTTPConstants.*;\n+\n+import java.nio.charset.Charset;\n+import java.nio.charset.StandardCharsets;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.client.util.BufferingResponseListener;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.eclipse.jetty.http.HttpField;\n+import org.eclipse.jetty.http.HttpFields;\n+import org.eclipse.jetty.http.HttpHeader;\n+import org.eclipse.jetty.util.MultiMap;\n+import org.eclipse.jetty.util.UrlEncoded;\n+import org.openhab.binding.bmwconnecteddrive.internal.ConnectedDriveConfiguration;\n+import org.openhab.binding.bmwconnecteddrive.internal.VehicleConfiguration;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.NetworkError;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.auth.AuthResponse;\n+import org.openhab.binding.bmwconnecteddrive.internal.handler.simulation.Injector;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.BimmerConstants;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Constants;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Converter;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ImageProperties;\n+import org.openhab.core.io.net.http.HttpClientFactory;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonSyntaxException;\n+\n+/**\n+ * The {@link ConnectedDriveProxy} This class holds the important constants for the BMW Connected Drive Authorization.\n+ * They\n+ * are taken from the Bimmercode from github {@link https://github.com/bimmerconnected/bimmer_connected}\n+ * File defining these constants\n+ * {@link https://github.com/bimmerconnected/bimmer_connected/blob/master/bimmer_connected/account.py}\n+ * https://customer.bmwgroup.com/one/app/oauth.js\n+ *\n+ * @author Bernd Weymann - Initial contribution\n+ * @author Norbert Truchsess - edit & send of charge profile\n+ */\n+@NonNullByDefault\n+public class ConnectedDriveProxy {\n+    private final Logger logger = LoggerFactory.getLogger(ConnectedDriveProxy.class);\n+    private final Token token = new Token();\n+    private final HttpClient httpClient;\n+    private final HttpClient authHttpClient;\n+    private final String legacyAuthUri;\n+    private final ConnectedDriveConfiguration configuration;\n+\n+    /**\n+     * URLs taken from https://github.com/bimmerconnected/bimmer_connected/blob/master/bimmer_connected/const.py\n+     */\n+    final String baseUrl;\n+    final String vehicleUrl;\n+    final String legacyUrl;\n+    final String vehicleStatusAPI = \"/status\";\n+    final String lastTripAPI = \"/statistics/lastTrip\";\n+    final String allTripsAPI = \"/statistics/allTrips\";\n+    final String chargeAPI = \"/chargingprofile\";\n+    final String destinationAPI = \"/destinations\";\n+    final String imageAPI = \"/image\";\n+    final String rangeMapAPI = \"/rangemap\";\n+    final String serviceExecutionAPI = \"/executeService\";\n+    final String serviceExecutionStateAPI = \"/serviceExecutionStatus\";\n+\n+    public ConnectedDriveProxy(HttpClientFactory httpClientFactory, ConnectedDriveConfiguration config) {\n+        httpClient = httpClientFactory.getCommonHttpClient();\n+        authHttpClient = httpClientFactory.createHttpClient(AUTH_HTTP_CLIENT_NAME);\n+        authHttpClient.setFollowRedirects(false);\n+        try {\n+            authHttpClient.start();\n+        } catch (Exception e) {\n+            logger.warn(\"Auth Http Client cannot be started\");\n+        }\n+        configuration = config;\n+\n+        final StringBuilder legacyAuth = new StringBuilder();\n+        legacyAuth.append(\"https://\");\n+        legacyAuth.append(BimmerConstants.AUTH_SERVER_MAP.get(configuration.region));\n+        legacyAuth.append(BimmerConstants.OAUTH_ENDPOINT);\n+        legacyAuthUri = legacyAuth.toString();\n+        vehicleUrl = \"https://\" + getRegionServer() + \"/webapi/v1/user/vehicles\";\n+        baseUrl = vehicleUrl + \"/\";\n+        legacyUrl = \"https://\" + getRegionServer() + \"/api/vehicle/dynamic/v1/\";\n+    }\n+\n+    private synchronized void call(final String url, final boolean post, final @Nullable MultiMap<String> params,\n+            final ResponseCallback callback) {\n+        // only executed in \"simulation mode\"\n+        // SimulationTest.testSimulationOff() assures Injector is off when releasing\n+        if (Injector.isActive()) {\n+            if (url.equals(baseUrl)) {\n+                ((StringResponseCallback) callback).onResponse(Injector.getDiscovery());\n+            } else if (url.endsWith(vehicleStatusAPI)) {\n+                ((StringResponseCallback) callback).onResponse(Injector.getStatus());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "48af48c82562d006b6f2aa35922270f181c885ed"}, "originalPosition": 115}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5OTE1MjE1NQ==", "bodyText": "Yes, due to the URL check I'm sure", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r599152155", "createdAt": "2021-03-22T23:56:42Z", "author": {"login": "weymann"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/ConnectedDriveProxy.java", "diffHunk": "@@ -0,0 +1,314 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bmwconnecteddrive.internal.handler;\n+\n+import static org.openhab.binding.bmwconnecteddrive.internal.utils.HTTPConstants.*;\n+\n+import java.nio.charset.Charset;\n+import java.nio.charset.StandardCharsets;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.client.util.BufferingResponseListener;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.eclipse.jetty.http.HttpField;\n+import org.eclipse.jetty.http.HttpFields;\n+import org.eclipse.jetty.http.HttpHeader;\n+import org.eclipse.jetty.util.MultiMap;\n+import org.eclipse.jetty.util.UrlEncoded;\n+import org.openhab.binding.bmwconnecteddrive.internal.ConnectedDriveConfiguration;\n+import org.openhab.binding.bmwconnecteddrive.internal.VehicleConfiguration;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.NetworkError;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.auth.AuthResponse;\n+import org.openhab.binding.bmwconnecteddrive.internal.handler.simulation.Injector;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.BimmerConstants;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Constants;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Converter;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ImageProperties;\n+import org.openhab.core.io.net.http.HttpClientFactory;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonSyntaxException;\n+\n+/**\n+ * The {@link ConnectedDriveProxy} This class holds the important constants for the BMW Connected Drive Authorization.\n+ * They\n+ * are taken from the Bimmercode from github {@link https://github.com/bimmerconnected/bimmer_connected}\n+ * File defining these constants\n+ * {@link https://github.com/bimmerconnected/bimmer_connected/blob/master/bimmer_connected/account.py}\n+ * https://customer.bmwgroup.com/one/app/oauth.js\n+ *\n+ * @author Bernd Weymann - Initial contribution\n+ * @author Norbert Truchsess - edit & send of charge profile\n+ */\n+@NonNullByDefault\n+public class ConnectedDriveProxy {\n+    private final Logger logger = LoggerFactory.getLogger(ConnectedDriveProxy.class);\n+    private final Token token = new Token();\n+    private final HttpClient httpClient;\n+    private final HttpClient authHttpClient;\n+    private final String legacyAuthUri;\n+    private final ConnectedDriveConfiguration configuration;\n+\n+    /**\n+     * URLs taken from https://github.com/bimmerconnected/bimmer_connected/blob/master/bimmer_connected/const.py\n+     */\n+    final String baseUrl;\n+    final String vehicleUrl;\n+    final String legacyUrl;\n+    final String vehicleStatusAPI = \"/status\";\n+    final String lastTripAPI = \"/statistics/lastTrip\";\n+    final String allTripsAPI = \"/statistics/allTrips\";\n+    final String chargeAPI = \"/chargingprofile\";\n+    final String destinationAPI = \"/destinations\";\n+    final String imageAPI = \"/image\";\n+    final String rangeMapAPI = \"/rangemap\";\n+    final String serviceExecutionAPI = \"/executeService\";\n+    final String serviceExecutionStateAPI = \"/serviceExecutionStatus\";\n+\n+    public ConnectedDriveProxy(HttpClientFactory httpClientFactory, ConnectedDriveConfiguration config) {\n+        httpClient = httpClientFactory.getCommonHttpClient();\n+        authHttpClient = httpClientFactory.createHttpClient(AUTH_HTTP_CLIENT_NAME);\n+        authHttpClient.setFollowRedirects(false);\n+        try {\n+            authHttpClient.start();\n+        } catch (Exception e) {\n+            logger.warn(\"Auth Http Client cannot be started\");\n+        }\n+        configuration = config;\n+\n+        final StringBuilder legacyAuth = new StringBuilder();\n+        legacyAuth.append(\"https://\");\n+        legacyAuth.append(BimmerConstants.AUTH_SERVER_MAP.get(configuration.region));\n+        legacyAuth.append(BimmerConstants.OAUTH_ENDPOINT);\n+        legacyAuthUri = legacyAuth.toString();\n+        vehicleUrl = \"https://\" + getRegionServer() + \"/webapi/v1/user/vehicles\";\n+        baseUrl = vehicleUrl + \"/\";\n+        legacyUrl = \"https://\" + getRegionServer() + \"/api/vehicle/dynamic/v1/\";\n+    }\n+\n+    private synchronized void call(final String url, final boolean post, final @Nullable MultiMap<String> params,\n+            final ResponseCallback callback) {\n+        // only executed in \"simulation mode\"\n+        // SimulationTest.testSimulationOff() assures Injector is off when releasing\n+        if (Injector.isActive()) {\n+            if (url.equals(baseUrl)) {\n+                ((StringResponseCallback) callback).onResponse(Injector.getDiscovery());\n+            } else if (url.endsWith(vehicleStatusAPI)) {\n+                ((StringResponseCallback) callback).onResponse(Injector.getStatus());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5Nzg5MDcwNw=="}, "originalCommit": {"oid": "48af48c82562d006b6f2aa35922270f181c885ed"}, "originalPosition": 115}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzc3NjYwMjg5OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/ConnectedDriveProxy.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0xOVQxODoyMzo1MFrOI6MZcg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0yMVQxMzo0MDo0MFrOI6kONQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5Nzg5MTQ0Mg==", "bodyText": "Better check if it is ByteResponseCallback, in case in the future somebody adds another response callback type.", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r597891442", "createdAt": "2021-03-19T18:23:50Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/ConnectedDriveProxy.java", "diffHunk": "@@ -0,0 +1,314 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bmwconnecteddrive.internal.handler;\n+\n+import static org.openhab.binding.bmwconnecteddrive.internal.utils.HTTPConstants.*;\n+\n+import java.nio.charset.Charset;\n+import java.nio.charset.StandardCharsets;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.client.util.BufferingResponseListener;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.eclipse.jetty.http.HttpField;\n+import org.eclipse.jetty.http.HttpFields;\n+import org.eclipse.jetty.http.HttpHeader;\n+import org.eclipse.jetty.util.MultiMap;\n+import org.eclipse.jetty.util.UrlEncoded;\n+import org.openhab.binding.bmwconnecteddrive.internal.ConnectedDriveConfiguration;\n+import org.openhab.binding.bmwconnecteddrive.internal.VehicleConfiguration;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.NetworkError;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.auth.AuthResponse;\n+import org.openhab.binding.bmwconnecteddrive.internal.handler.simulation.Injector;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.BimmerConstants;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Constants;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Converter;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ImageProperties;\n+import org.openhab.core.io.net.http.HttpClientFactory;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonSyntaxException;\n+\n+/**\n+ * The {@link ConnectedDriveProxy} This class holds the important constants for the BMW Connected Drive Authorization.\n+ * They\n+ * are taken from the Bimmercode from github {@link https://github.com/bimmerconnected/bimmer_connected}\n+ * File defining these constants\n+ * {@link https://github.com/bimmerconnected/bimmer_connected/blob/master/bimmer_connected/account.py}\n+ * https://customer.bmwgroup.com/one/app/oauth.js\n+ *\n+ * @author Bernd Weymann - Initial contribution\n+ * @author Norbert Truchsess - edit & send of charge profile\n+ */\n+@NonNullByDefault\n+public class ConnectedDriveProxy {\n+    private final Logger logger = LoggerFactory.getLogger(ConnectedDriveProxy.class);\n+    private final Token token = new Token();\n+    private final HttpClient httpClient;\n+    private final HttpClient authHttpClient;\n+    private final String legacyAuthUri;\n+    private final ConnectedDriveConfiguration configuration;\n+\n+    /**\n+     * URLs taken from https://github.com/bimmerconnected/bimmer_connected/blob/master/bimmer_connected/const.py\n+     */\n+    final String baseUrl;\n+    final String vehicleUrl;\n+    final String legacyUrl;\n+    final String vehicleStatusAPI = \"/status\";\n+    final String lastTripAPI = \"/statistics/lastTrip\";\n+    final String allTripsAPI = \"/statistics/allTrips\";\n+    final String chargeAPI = \"/chargingprofile\";\n+    final String destinationAPI = \"/destinations\";\n+    final String imageAPI = \"/image\";\n+    final String rangeMapAPI = \"/rangemap\";\n+    final String serviceExecutionAPI = \"/executeService\";\n+    final String serviceExecutionStateAPI = \"/serviceExecutionStatus\";\n+\n+    public ConnectedDriveProxy(HttpClientFactory httpClientFactory, ConnectedDriveConfiguration config) {\n+        httpClient = httpClientFactory.getCommonHttpClient();\n+        authHttpClient = httpClientFactory.createHttpClient(AUTH_HTTP_CLIENT_NAME);\n+        authHttpClient.setFollowRedirects(false);\n+        try {\n+            authHttpClient.start();\n+        } catch (Exception e) {\n+            logger.warn(\"Auth Http Client cannot be started\");\n+        }\n+        configuration = config;\n+\n+        final StringBuilder legacyAuth = new StringBuilder();\n+        legacyAuth.append(\"https://\");\n+        legacyAuth.append(BimmerConstants.AUTH_SERVER_MAP.get(configuration.region));\n+        legacyAuth.append(BimmerConstants.OAUTH_ENDPOINT);\n+        legacyAuthUri = legacyAuth.toString();\n+        vehicleUrl = \"https://\" + getRegionServer() + \"/webapi/v1/user/vehicles\";\n+        baseUrl = vehicleUrl + \"/\";\n+        legacyUrl = \"https://\" + getRegionServer() + \"/api/vehicle/dynamic/v1/\";\n+    }\n+\n+    private synchronized void call(final String url, final boolean post, final @Nullable MultiMap<String> params,\n+            final ResponseCallback callback) {\n+        // only executed in \"simulation mode\"\n+        // SimulationTest.testSimulationOff() assures Injector is off when releasing\n+        if (Injector.isActive()) {\n+            if (url.equals(baseUrl)) {\n+                ((StringResponseCallback) callback).onResponse(Injector.getDiscovery());\n+            } else if (url.endsWith(vehicleStatusAPI)) {\n+                ((StringResponseCallback) callback).onResponse(Injector.getStatus());\n+            } else {\n+                logger.info(\"Simulation of {} not supported\", url);\n+            }\n+            return;\n+        }\n+        final Request req;\n+        final String encoded = params == null || params.isEmpty() ? null\n+                : UrlEncoded.encode(params, Charset.defaultCharset(), false);\n+        final String completeUrl;\n+\n+        if (post) {\n+            completeUrl = url;\n+            req = httpClient.POST(url);\n+            if (encoded != null) {\n+                req.content(new StringContentProvider(CONTENT_TYPE_URL_ENCODED, encoded, Charset.defaultCharset()));\n+            }\n+        } else {\n+            completeUrl = encoded == null ? url : url + Constants.QUESTION + encoded;\n+            req = httpClient.newRequest(completeUrl);\n+        }\n+        req.header(HttpHeader.AUTHORIZATION, getToken().getBearerToken());\n+        req.header(HttpHeader.REFERER, BimmerConstants.REFERER_URL);\n+\n+        req.timeout(HTTP_TIMEOUT_SEC, TimeUnit.SECONDS).send(new BufferingResponseListener() {\n+            @NonNullByDefault({})\n+            @Override\n+            public void onComplete(org.eclipse.jetty.client.api.Result result) {\n+                if (result.getResponse().getStatus() != 200) {\n+                    NetworkError error = new NetworkError();\n+                    error.url = completeUrl;\n+                    error.status = result.getResponse().getStatus();\n+                    if (result.getResponse().getReason() != null) {\n+                        error.reason = result.getResponse().getReason();\n+                    } else {\n+                        error.reason = result.getFailure().getMessage();\n+                    }\n+                    error.params = result.getRequest().getParams().toString();\n+                    logger.debug(\"HTTP Error {}\", error.toString());\n+                    callback.onError(error);\n+                } else {\n+                    if (callback instanceof StringResponseCallback) {\n+                        ((StringResponseCallback) callback).onResponse(getContentAsString());\n+                    } else {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "48af48c82562d006b6f2aa35922270f181c885ed"}, "originalPosition": 158}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5ODI4MTc4MQ==", "bodyText": "fixed in weymann#8", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r598281781", "createdAt": "2021-03-21T13:40:40Z", "author": {"login": "ntruchsess"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/ConnectedDriveProxy.java", "diffHunk": "@@ -0,0 +1,314 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bmwconnecteddrive.internal.handler;\n+\n+import static org.openhab.binding.bmwconnecteddrive.internal.utils.HTTPConstants.*;\n+\n+import java.nio.charset.Charset;\n+import java.nio.charset.StandardCharsets;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.client.util.BufferingResponseListener;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.eclipse.jetty.http.HttpField;\n+import org.eclipse.jetty.http.HttpFields;\n+import org.eclipse.jetty.http.HttpHeader;\n+import org.eclipse.jetty.util.MultiMap;\n+import org.eclipse.jetty.util.UrlEncoded;\n+import org.openhab.binding.bmwconnecteddrive.internal.ConnectedDriveConfiguration;\n+import org.openhab.binding.bmwconnecteddrive.internal.VehicleConfiguration;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.NetworkError;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.auth.AuthResponse;\n+import org.openhab.binding.bmwconnecteddrive.internal.handler.simulation.Injector;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.BimmerConstants;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Constants;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Converter;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ImageProperties;\n+import org.openhab.core.io.net.http.HttpClientFactory;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonSyntaxException;\n+\n+/**\n+ * The {@link ConnectedDriveProxy} This class holds the important constants for the BMW Connected Drive Authorization.\n+ * They\n+ * are taken from the Bimmercode from github {@link https://github.com/bimmerconnected/bimmer_connected}\n+ * File defining these constants\n+ * {@link https://github.com/bimmerconnected/bimmer_connected/blob/master/bimmer_connected/account.py}\n+ * https://customer.bmwgroup.com/one/app/oauth.js\n+ *\n+ * @author Bernd Weymann - Initial contribution\n+ * @author Norbert Truchsess - edit & send of charge profile\n+ */\n+@NonNullByDefault\n+public class ConnectedDriveProxy {\n+    private final Logger logger = LoggerFactory.getLogger(ConnectedDriveProxy.class);\n+    private final Token token = new Token();\n+    private final HttpClient httpClient;\n+    private final HttpClient authHttpClient;\n+    private final String legacyAuthUri;\n+    private final ConnectedDriveConfiguration configuration;\n+\n+    /**\n+     * URLs taken from https://github.com/bimmerconnected/bimmer_connected/blob/master/bimmer_connected/const.py\n+     */\n+    final String baseUrl;\n+    final String vehicleUrl;\n+    final String legacyUrl;\n+    final String vehicleStatusAPI = \"/status\";\n+    final String lastTripAPI = \"/statistics/lastTrip\";\n+    final String allTripsAPI = \"/statistics/allTrips\";\n+    final String chargeAPI = \"/chargingprofile\";\n+    final String destinationAPI = \"/destinations\";\n+    final String imageAPI = \"/image\";\n+    final String rangeMapAPI = \"/rangemap\";\n+    final String serviceExecutionAPI = \"/executeService\";\n+    final String serviceExecutionStateAPI = \"/serviceExecutionStatus\";\n+\n+    public ConnectedDriveProxy(HttpClientFactory httpClientFactory, ConnectedDriveConfiguration config) {\n+        httpClient = httpClientFactory.getCommonHttpClient();\n+        authHttpClient = httpClientFactory.createHttpClient(AUTH_HTTP_CLIENT_NAME);\n+        authHttpClient.setFollowRedirects(false);\n+        try {\n+            authHttpClient.start();\n+        } catch (Exception e) {\n+            logger.warn(\"Auth Http Client cannot be started\");\n+        }\n+        configuration = config;\n+\n+        final StringBuilder legacyAuth = new StringBuilder();\n+        legacyAuth.append(\"https://\");\n+        legacyAuth.append(BimmerConstants.AUTH_SERVER_MAP.get(configuration.region));\n+        legacyAuth.append(BimmerConstants.OAUTH_ENDPOINT);\n+        legacyAuthUri = legacyAuth.toString();\n+        vehicleUrl = \"https://\" + getRegionServer() + \"/webapi/v1/user/vehicles\";\n+        baseUrl = vehicleUrl + \"/\";\n+        legacyUrl = \"https://\" + getRegionServer() + \"/api/vehicle/dynamic/v1/\";\n+    }\n+\n+    private synchronized void call(final String url, final boolean post, final @Nullable MultiMap<String> params,\n+            final ResponseCallback callback) {\n+        // only executed in \"simulation mode\"\n+        // SimulationTest.testSimulationOff() assures Injector is off when releasing\n+        if (Injector.isActive()) {\n+            if (url.equals(baseUrl)) {\n+                ((StringResponseCallback) callback).onResponse(Injector.getDiscovery());\n+            } else if (url.endsWith(vehicleStatusAPI)) {\n+                ((StringResponseCallback) callback).onResponse(Injector.getStatus());\n+            } else {\n+                logger.info(\"Simulation of {} not supported\", url);\n+            }\n+            return;\n+        }\n+        final Request req;\n+        final String encoded = params == null || params.isEmpty() ? null\n+                : UrlEncoded.encode(params, Charset.defaultCharset(), false);\n+        final String completeUrl;\n+\n+        if (post) {\n+            completeUrl = url;\n+            req = httpClient.POST(url);\n+            if (encoded != null) {\n+                req.content(new StringContentProvider(CONTENT_TYPE_URL_ENCODED, encoded, Charset.defaultCharset()));\n+            }\n+        } else {\n+            completeUrl = encoded == null ? url : url + Constants.QUESTION + encoded;\n+            req = httpClient.newRequest(completeUrl);\n+        }\n+        req.header(HttpHeader.AUTHORIZATION, getToken().getBearerToken());\n+        req.header(HttpHeader.REFERER, BimmerConstants.REFERER_URL);\n+\n+        req.timeout(HTTP_TIMEOUT_SEC, TimeUnit.SECONDS).send(new BufferingResponseListener() {\n+            @NonNullByDefault({})\n+            @Override\n+            public void onComplete(org.eclipse.jetty.client.api.Result result) {\n+                if (result.getResponse().getStatus() != 200) {\n+                    NetworkError error = new NetworkError();\n+                    error.url = completeUrl;\n+                    error.status = result.getResponse().getStatus();\n+                    if (result.getResponse().getReason() != null) {\n+                        error.reason = result.getResponse().getReason();\n+                    } else {\n+                        error.reason = result.getFailure().getMessage();\n+                    }\n+                    error.params = result.getRequest().getParams().toString();\n+                    logger.debug(\"HTTP Error {}\", error.toString());\n+                    callback.onError(error);\n+                } else {\n+                    if (callback instanceof StringResponseCallback) {\n+                        ((StringResponseCallback) callback).onResponse(getContentAsString());\n+                    } else {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5Nzg5MTQ0Mg=="}, "originalCommit": {"oid": "48af48c82562d006b6f2aa35922270f181c885ed"}, "originalPosition": 158}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzc3NjYwNzQ5OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/ConnectedDriveProxy.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0xOVQxODoyNToxOVrOI6Mcaw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0yMlQyMzo1OTozNVrOI7ZaNA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5Nzg5MjIwMw==", "bodyText": "Any reason not using getRegionServer() here?", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r597892203", "createdAt": "2021-03-19T18:25:19Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/ConnectedDriveProxy.java", "diffHunk": "@@ -0,0 +1,314 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bmwconnecteddrive.internal.handler;\n+\n+import static org.openhab.binding.bmwconnecteddrive.internal.utils.HTTPConstants.*;\n+\n+import java.nio.charset.Charset;\n+import java.nio.charset.StandardCharsets;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.client.util.BufferingResponseListener;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.eclipse.jetty.http.HttpField;\n+import org.eclipse.jetty.http.HttpFields;\n+import org.eclipse.jetty.http.HttpHeader;\n+import org.eclipse.jetty.util.MultiMap;\n+import org.eclipse.jetty.util.UrlEncoded;\n+import org.openhab.binding.bmwconnecteddrive.internal.ConnectedDriveConfiguration;\n+import org.openhab.binding.bmwconnecteddrive.internal.VehicleConfiguration;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.NetworkError;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.auth.AuthResponse;\n+import org.openhab.binding.bmwconnecteddrive.internal.handler.simulation.Injector;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.BimmerConstants;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Constants;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Converter;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ImageProperties;\n+import org.openhab.core.io.net.http.HttpClientFactory;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonSyntaxException;\n+\n+/**\n+ * The {@link ConnectedDriveProxy} This class holds the important constants for the BMW Connected Drive Authorization.\n+ * They\n+ * are taken from the Bimmercode from github {@link https://github.com/bimmerconnected/bimmer_connected}\n+ * File defining these constants\n+ * {@link https://github.com/bimmerconnected/bimmer_connected/blob/master/bimmer_connected/account.py}\n+ * https://customer.bmwgroup.com/one/app/oauth.js\n+ *\n+ * @author Bernd Weymann - Initial contribution\n+ * @author Norbert Truchsess - edit & send of charge profile\n+ */\n+@NonNullByDefault\n+public class ConnectedDriveProxy {\n+    private final Logger logger = LoggerFactory.getLogger(ConnectedDriveProxy.class);\n+    private final Token token = new Token();\n+    private final HttpClient httpClient;\n+    private final HttpClient authHttpClient;\n+    private final String legacyAuthUri;\n+    private final ConnectedDriveConfiguration configuration;\n+\n+    /**\n+     * URLs taken from https://github.com/bimmerconnected/bimmer_connected/blob/master/bimmer_connected/const.py\n+     */\n+    final String baseUrl;\n+    final String vehicleUrl;\n+    final String legacyUrl;\n+    final String vehicleStatusAPI = \"/status\";\n+    final String lastTripAPI = \"/statistics/lastTrip\";\n+    final String allTripsAPI = \"/statistics/allTrips\";\n+    final String chargeAPI = \"/chargingprofile\";\n+    final String destinationAPI = \"/destinations\";\n+    final String imageAPI = \"/image\";\n+    final String rangeMapAPI = \"/rangemap\";\n+    final String serviceExecutionAPI = \"/executeService\";\n+    final String serviceExecutionStateAPI = \"/serviceExecutionStatus\";\n+\n+    public ConnectedDriveProxy(HttpClientFactory httpClientFactory, ConnectedDriveConfiguration config) {\n+        httpClient = httpClientFactory.getCommonHttpClient();\n+        authHttpClient = httpClientFactory.createHttpClient(AUTH_HTTP_CLIENT_NAME);\n+        authHttpClient.setFollowRedirects(false);\n+        try {\n+            authHttpClient.start();\n+        } catch (Exception e) {\n+            logger.warn(\"Auth Http Client cannot be started\");\n+        }\n+        configuration = config;\n+\n+        final StringBuilder legacyAuth = new StringBuilder();\n+        legacyAuth.append(\"https://\");\n+        legacyAuth.append(BimmerConstants.AUTH_SERVER_MAP.get(configuration.region));\n+        legacyAuth.append(BimmerConstants.OAUTH_ENDPOINT);\n+        legacyAuthUri = legacyAuth.toString();\n+        vehicleUrl = \"https://\" + getRegionServer() + \"/webapi/v1/user/vehicles\";\n+        baseUrl = vehicleUrl + \"/\";\n+        legacyUrl = \"https://\" + getRegionServer() + \"/api/vehicle/dynamic/v1/\";\n+    }\n+\n+    private synchronized void call(final String url, final boolean post, final @Nullable MultiMap<String> params,\n+            final ResponseCallback callback) {\n+        // only executed in \"simulation mode\"\n+        // SimulationTest.testSimulationOff() assures Injector is off when releasing\n+        if (Injector.isActive()) {\n+            if (url.equals(baseUrl)) {\n+                ((StringResponseCallback) callback).onResponse(Injector.getDiscovery());\n+            } else if (url.endsWith(vehicleStatusAPI)) {\n+                ((StringResponseCallback) callback).onResponse(Injector.getStatus());\n+            } else {\n+                logger.info(\"Simulation of {} not supported\", url);\n+            }\n+            return;\n+        }\n+        final Request req;\n+        final String encoded = params == null || params.isEmpty() ? null\n+                : UrlEncoded.encode(params, Charset.defaultCharset(), false);\n+        final String completeUrl;\n+\n+        if (post) {\n+            completeUrl = url;\n+            req = httpClient.POST(url);\n+            if (encoded != null) {\n+                req.content(new StringContentProvider(CONTENT_TYPE_URL_ENCODED, encoded, Charset.defaultCharset()));\n+            }\n+        } else {\n+            completeUrl = encoded == null ? url : url + Constants.QUESTION + encoded;\n+            req = httpClient.newRequest(completeUrl);\n+        }\n+        req.header(HttpHeader.AUTHORIZATION, getToken().getBearerToken());\n+        req.header(HttpHeader.REFERER, BimmerConstants.REFERER_URL);\n+\n+        req.timeout(HTTP_TIMEOUT_SEC, TimeUnit.SECONDS).send(new BufferingResponseListener() {\n+            @NonNullByDefault({})\n+            @Override\n+            public void onComplete(org.eclipse.jetty.client.api.Result result) {\n+                if (result.getResponse().getStatus() != 200) {\n+                    NetworkError error = new NetworkError();\n+                    error.url = completeUrl;\n+                    error.status = result.getResponse().getStatus();\n+                    if (result.getResponse().getReason() != null) {\n+                        error.reason = result.getResponse().getReason();\n+                    } else {\n+                        error.reason = result.getFailure().getMessage();\n+                    }\n+                    error.params = result.getRequest().getParams().toString();\n+                    logger.debug(\"HTTP Error {}\", error.toString());\n+                    callback.onError(error);\n+                } else {\n+                    if (callback instanceof StringResponseCallback) {\n+                        ((StringResponseCallback) callback).onResponse(getContentAsString());\n+                    } else {\n+                        ((ByteResponseCallback) callback).onResponse(getContent());\n+                    }\n+                }\n+            }\n+        });\n+    }\n+\n+    public void get(String url, @Nullable MultiMap<String> params, ResponseCallback callback) {\n+        call(url, false, params, callback);\n+    }\n+\n+    public void post(String url, @Nullable MultiMap<String> params, ResponseCallback callback) {\n+        call(url, true, params, callback);\n+    }\n+\n+    public void requestVehicles(StringResponseCallback callback) {\n+        get(vehicleUrl, null, callback);\n+    }\n+\n+    public void requestVehcileStatus(VehicleConfiguration config, StringResponseCallback callback) {\n+        get(baseUrl + config.vin + vehicleStatusAPI, null, callback);\n+    }\n+\n+    public void requestLegacyVehcileStatus(VehicleConfiguration config, StringResponseCallback callback) {\n+        // see https://github.com/jupe76/bmwcdapi/search?q=dynamic%2Fv1\n+        get(legacyUrl + config.vin + \"?offset=-60\", null, callback);\n+    }\n+\n+    public void requestLastTrip(VehicleConfiguration config, StringResponseCallback callback) {\n+        get(baseUrl + config.vin + lastTripAPI, null, callback);\n+    }\n+\n+    public void requestAllTrips(VehicleConfiguration config, StringResponseCallback callback) {\n+        get(baseUrl + config.vin + allTripsAPI, null, callback);\n+    }\n+\n+    public void requestChargingProfile(VehicleConfiguration config, StringResponseCallback callback) {\n+        get(baseUrl + config.vin + chargeAPI, null, callback);\n+    }\n+\n+    public void requestDestinations(VehicleConfiguration config, StringResponseCallback callback) {\n+        get(baseUrl + config.vin + destinationAPI, null, callback);\n+    }\n+\n+    public void requestRangeMap(VehicleConfiguration config, @Nullable MultiMap<String> params,\n+            StringResponseCallback callback) {\n+        get(baseUrl + config.vin + rangeMapAPI, params, callback);\n+    }\n+\n+    public void requestImage(VehicleConfiguration config, ImageProperties props, ByteResponseCallback callback) {\n+        final String localImageUrl = baseUrl + config.vin + imageAPI;\n+        final MultiMap<String> dataMap = new MultiMap<String>();\n+        dataMap.add(\"width\", Integer.toString(props.size));\n+        dataMap.add(\"height\", Integer.toString(props.size));\n+        dataMap.add(\"view\", props.viewport);\n+        get(localImageUrl, dataMap, callback);\n+    }\n+\n+    private String getRegionServer() {\n+        final String retVal = BimmerConstants.SERVER_MAP.get(configuration.region);\n+        return retVal == null ? Constants.INVALID : retVal;\n+    }\n+\n+    RemoteServiceHandler getRemoteServiceHandler(VehicleHandler vehicleHandler) {\n+        return new RemoteServiceHandler(vehicleHandler, this);\n+    }\n+\n+    // Token handling\n+\n+    /**\n+     * Gets new token if old one is expired or invalid. In case of error the token remains.\n+     * So if token refresh fails the corresponding requests will also fail and update the\n+     * Thing status accordingly.\n+     *\n+     * @return token\n+     */\n+    public Token getToken() {\n+        if (token.isExpired() || !token.isValid()) {\n+            updateToken();\n+        }\n+        return token;\n+    }\n+\n+    /**\n+     * Authorize at BMW Connected Drive Portal and get Token\n+     *\n+     * @return\n+     */\n+    private synchronized void updateToken() {\n+        final Request req = authHttpClient.POST(legacyAuthUri);\n+\n+        req.header(HttpHeader.CONNECTION, KEEP_ALIVE);\n+        req.header(HttpHeader.HOST, BimmerConstants.SERVER_MAP.get(configuration.region));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "48af48c82562d006b6f2aa35922270f181c885ed"}, "originalPosition": 251}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5OTE1MzIwNA==", "bodyText": "No, fixed", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r599153204", "createdAt": "2021-03-22T23:59:35Z", "author": {"login": "weymann"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/ConnectedDriveProxy.java", "diffHunk": "@@ -0,0 +1,314 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bmwconnecteddrive.internal.handler;\n+\n+import static org.openhab.binding.bmwconnecteddrive.internal.utils.HTTPConstants.*;\n+\n+import java.nio.charset.Charset;\n+import java.nio.charset.StandardCharsets;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.client.util.BufferingResponseListener;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.eclipse.jetty.http.HttpField;\n+import org.eclipse.jetty.http.HttpFields;\n+import org.eclipse.jetty.http.HttpHeader;\n+import org.eclipse.jetty.util.MultiMap;\n+import org.eclipse.jetty.util.UrlEncoded;\n+import org.openhab.binding.bmwconnecteddrive.internal.ConnectedDriveConfiguration;\n+import org.openhab.binding.bmwconnecteddrive.internal.VehicleConfiguration;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.NetworkError;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.auth.AuthResponse;\n+import org.openhab.binding.bmwconnecteddrive.internal.handler.simulation.Injector;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.BimmerConstants;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Constants;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Converter;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ImageProperties;\n+import org.openhab.core.io.net.http.HttpClientFactory;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonSyntaxException;\n+\n+/**\n+ * The {@link ConnectedDriveProxy} This class holds the important constants for the BMW Connected Drive Authorization.\n+ * They\n+ * are taken from the Bimmercode from github {@link https://github.com/bimmerconnected/bimmer_connected}\n+ * File defining these constants\n+ * {@link https://github.com/bimmerconnected/bimmer_connected/blob/master/bimmer_connected/account.py}\n+ * https://customer.bmwgroup.com/one/app/oauth.js\n+ *\n+ * @author Bernd Weymann - Initial contribution\n+ * @author Norbert Truchsess - edit & send of charge profile\n+ */\n+@NonNullByDefault\n+public class ConnectedDriveProxy {\n+    private final Logger logger = LoggerFactory.getLogger(ConnectedDriveProxy.class);\n+    private final Token token = new Token();\n+    private final HttpClient httpClient;\n+    private final HttpClient authHttpClient;\n+    private final String legacyAuthUri;\n+    private final ConnectedDriveConfiguration configuration;\n+\n+    /**\n+     * URLs taken from https://github.com/bimmerconnected/bimmer_connected/blob/master/bimmer_connected/const.py\n+     */\n+    final String baseUrl;\n+    final String vehicleUrl;\n+    final String legacyUrl;\n+    final String vehicleStatusAPI = \"/status\";\n+    final String lastTripAPI = \"/statistics/lastTrip\";\n+    final String allTripsAPI = \"/statistics/allTrips\";\n+    final String chargeAPI = \"/chargingprofile\";\n+    final String destinationAPI = \"/destinations\";\n+    final String imageAPI = \"/image\";\n+    final String rangeMapAPI = \"/rangemap\";\n+    final String serviceExecutionAPI = \"/executeService\";\n+    final String serviceExecutionStateAPI = \"/serviceExecutionStatus\";\n+\n+    public ConnectedDriveProxy(HttpClientFactory httpClientFactory, ConnectedDriveConfiguration config) {\n+        httpClient = httpClientFactory.getCommonHttpClient();\n+        authHttpClient = httpClientFactory.createHttpClient(AUTH_HTTP_CLIENT_NAME);\n+        authHttpClient.setFollowRedirects(false);\n+        try {\n+            authHttpClient.start();\n+        } catch (Exception e) {\n+            logger.warn(\"Auth Http Client cannot be started\");\n+        }\n+        configuration = config;\n+\n+        final StringBuilder legacyAuth = new StringBuilder();\n+        legacyAuth.append(\"https://\");\n+        legacyAuth.append(BimmerConstants.AUTH_SERVER_MAP.get(configuration.region));\n+        legacyAuth.append(BimmerConstants.OAUTH_ENDPOINT);\n+        legacyAuthUri = legacyAuth.toString();\n+        vehicleUrl = \"https://\" + getRegionServer() + \"/webapi/v1/user/vehicles\";\n+        baseUrl = vehicleUrl + \"/\";\n+        legacyUrl = \"https://\" + getRegionServer() + \"/api/vehicle/dynamic/v1/\";\n+    }\n+\n+    private synchronized void call(final String url, final boolean post, final @Nullable MultiMap<String> params,\n+            final ResponseCallback callback) {\n+        // only executed in \"simulation mode\"\n+        // SimulationTest.testSimulationOff() assures Injector is off when releasing\n+        if (Injector.isActive()) {\n+            if (url.equals(baseUrl)) {\n+                ((StringResponseCallback) callback).onResponse(Injector.getDiscovery());\n+            } else if (url.endsWith(vehicleStatusAPI)) {\n+                ((StringResponseCallback) callback).onResponse(Injector.getStatus());\n+            } else {\n+                logger.info(\"Simulation of {} not supported\", url);\n+            }\n+            return;\n+        }\n+        final Request req;\n+        final String encoded = params == null || params.isEmpty() ? null\n+                : UrlEncoded.encode(params, Charset.defaultCharset(), false);\n+        final String completeUrl;\n+\n+        if (post) {\n+            completeUrl = url;\n+            req = httpClient.POST(url);\n+            if (encoded != null) {\n+                req.content(new StringContentProvider(CONTENT_TYPE_URL_ENCODED, encoded, Charset.defaultCharset()));\n+            }\n+        } else {\n+            completeUrl = encoded == null ? url : url + Constants.QUESTION + encoded;\n+            req = httpClient.newRequest(completeUrl);\n+        }\n+        req.header(HttpHeader.AUTHORIZATION, getToken().getBearerToken());\n+        req.header(HttpHeader.REFERER, BimmerConstants.REFERER_URL);\n+\n+        req.timeout(HTTP_TIMEOUT_SEC, TimeUnit.SECONDS).send(new BufferingResponseListener() {\n+            @NonNullByDefault({})\n+            @Override\n+            public void onComplete(org.eclipse.jetty.client.api.Result result) {\n+                if (result.getResponse().getStatus() != 200) {\n+                    NetworkError error = new NetworkError();\n+                    error.url = completeUrl;\n+                    error.status = result.getResponse().getStatus();\n+                    if (result.getResponse().getReason() != null) {\n+                        error.reason = result.getResponse().getReason();\n+                    } else {\n+                        error.reason = result.getFailure().getMessage();\n+                    }\n+                    error.params = result.getRequest().getParams().toString();\n+                    logger.debug(\"HTTP Error {}\", error.toString());\n+                    callback.onError(error);\n+                } else {\n+                    if (callback instanceof StringResponseCallback) {\n+                        ((StringResponseCallback) callback).onResponse(getContentAsString());\n+                    } else {\n+                        ((ByteResponseCallback) callback).onResponse(getContent());\n+                    }\n+                }\n+            }\n+        });\n+    }\n+\n+    public void get(String url, @Nullable MultiMap<String> params, ResponseCallback callback) {\n+        call(url, false, params, callback);\n+    }\n+\n+    public void post(String url, @Nullable MultiMap<String> params, ResponseCallback callback) {\n+        call(url, true, params, callback);\n+    }\n+\n+    public void requestVehicles(StringResponseCallback callback) {\n+        get(vehicleUrl, null, callback);\n+    }\n+\n+    public void requestVehcileStatus(VehicleConfiguration config, StringResponseCallback callback) {\n+        get(baseUrl + config.vin + vehicleStatusAPI, null, callback);\n+    }\n+\n+    public void requestLegacyVehcileStatus(VehicleConfiguration config, StringResponseCallback callback) {\n+        // see https://github.com/jupe76/bmwcdapi/search?q=dynamic%2Fv1\n+        get(legacyUrl + config.vin + \"?offset=-60\", null, callback);\n+    }\n+\n+    public void requestLastTrip(VehicleConfiguration config, StringResponseCallback callback) {\n+        get(baseUrl + config.vin + lastTripAPI, null, callback);\n+    }\n+\n+    public void requestAllTrips(VehicleConfiguration config, StringResponseCallback callback) {\n+        get(baseUrl + config.vin + allTripsAPI, null, callback);\n+    }\n+\n+    public void requestChargingProfile(VehicleConfiguration config, StringResponseCallback callback) {\n+        get(baseUrl + config.vin + chargeAPI, null, callback);\n+    }\n+\n+    public void requestDestinations(VehicleConfiguration config, StringResponseCallback callback) {\n+        get(baseUrl + config.vin + destinationAPI, null, callback);\n+    }\n+\n+    public void requestRangeMap(VehicleConfiguration config, @Nullable MultiMap<String> params,\n+            StringResponseCallback callback) {\n+        get(baseUrl + config.vin + rangeMapAPI, params, callback);\n+    }\n+\n+    public void requestImage(VehicleConfiguration config, ImageProperties props, ByteResponseCallback callback) {\n+        final String localImageUrl = baseUrl + config.vin + imageAPI;\n+        final MultiMap<String> dataMap = new MultiMap<String>();\n+        dataMap.add(\"width\", Integer.toString(props.size));\n+        dataMap.add(\"height\", Integer.toString(props.size));\n+        dataMap.add(\"view\", props.viewport);\n+        get(localImageUrl, dataMap, callback);\n+    }\n+\n+    private String getRegionServer() {\n+        final String retVal = BimmerConstants.SERVER_MAP.get(configuration.region);\n+        return retVal == null ? Constants.INVALID : retVal;\n+    }\n+\n+    RemoteServiceHandler getRemoteServiceHandler(VehicleHandler vehicleHandler) {\n+        return new RemoteServiceHandler(vehicleHandler, this);\n+    }\n+\n+    // Token handling\n+\n+    /**\n+     * Gets new token if old one is expired or invalid. In case of error the token remains.\n+     * So if token refresh fails the corresponding requests will also fail and update the\n+     * Thing status accordingly.\n+     *\n+     * @return token\n+     */\n+    public Token getToken() {\n+        if (token.isExpired() || !token.isValid()) {\n+            updateToken();\n+        }\n+        return token;\n+    }\n+\n+    /**\n+     * Authorize at BMW Connected Drive Portal and get Token\n+     *\n+     * @return\n+     */\n+    private synchronized void updateToken() {\n+        final Request req = authHttpClient.POST(legacyAuthUri);\n+\n+        req.header(HttpHeader.CONNECTION, KEEP_ALIVE);\n+        req.header(HttpHeader.HOST, BimmerConstants.SERVER_MAP.get(configuration.region));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5Nzg5MjIwMw=="}, "originalCommit": {"oid": "48af48c82562d006b6f2aa35922270f181c885ed"}, "originalPosition": 251}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzc3NjYxNTk4OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/ConnectedDriveProxy.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0xOVQxODoyNzozMlrOI6MhiQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0yM1QwMDowNTo0MVrOI7ZiGw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5Nzg5MzUxMw==", "bodyText": "You might want to do some validation on the user input. It can be empty if the user forgot to specify the parameter in textual configuration.", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r597893513", "createdAt": "2021-03-19T18:27:32Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/ConnectedDriveProxy.java", "diffHunk": "@@ -0,0 +1,314 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bmwconnecteddrive.internal.handler;\n+\n+import static org.openhab.binding.bmwconnecteddrive.internal.utils.HTTPConstants.*;\n+\n+import java.nio.charset.Charset;\n+import java.nio.charset.StandardCharsets;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.client.util.BufferingResponseListener;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.eclipse.jetty.http.HttpField;\n+import org.eclipse.jetty.http.HttpFields;\n+import org.eclipse.jetty.http.HttpHeader;\n+import org.eclipse.jetty.util.MultiMap;\n+import org.eclipse.jetty.util.UrlEncoded;\n+import org.openhab.binding.bmwconnecteddrive.internal.ConnectedDriveConfiguration;\n+import org.openhab.binding.bmwconnecteddrive.internal.VehicleConfiguration;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.NetworkError;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.auth.AuthResponse;\n+import org.openhab.binding.bmwconnecteddrive.internal.handler.simulation.Injector;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.BimmerConstants;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Constants;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Converter;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ImageProperties;\n+import org.openhab.core.io.net.http.HttpClientFactory;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonSyntaxException;\n+\n+/**\n+ * The {@link ConnectedDriveProxy} This class holds the important constants for the BMW Connected Drive Authorization.\n+ * They\n+ * are taken from the Bimmercode from github {@link https://github.com/bimmerconnected/bimmer_connected}\n+ * File defining these constants\n+ * {@link https://github.com/bimmerconnected/bimmer_connected/blob/master/bimmer_connected/account.py}\n+ * https://customer.bmwgroup.com/one/app/oauth.js\n+ *\n+ * @author Bernd Weymann - Initial contribution\n+ * @author Norbert Truchsess - edit & send of charge profile\n+ */\n+@NonNullByDefault\n+public class ConnectedDriveProxy {\n+    private final Logger logger = LoggerFactory.getLogger(ConnectedDriveProxy.class);\n+    private final Token token = new Token();\n+    private final HttpClient httpClient;\n+    private final HttpClient authHttpClient;\n+    private final String legacyAuthUri;\n+    private final ConnectedDriveConfiguration configuration;\n+\n+    /**\n+     * URLs taken from https://github.com/bimmerconnected/bimmer_connected/blob/master/bimmer_connected/const.py\n+     */\n+    final String baseUrl;\n+    final String vehicleUrl;\n+    final String legacyUrl;\n+    final String vehicleStatusAPI = \"/status\";\n+    final String lastTripAPI = \"/statistics/lastTrip\";\n+    final String allTripsAPI = \"/statistics/allTrips\";\n+    final String chargeAPI = \"/chargingprofile\";\n+    final String destinationAPI = \"/destinations\";\n+    final String imageAPI = \"/image\";\n+    final String rangeMapAPI = \"/rangemap\";\n+    final String serviceExecutionAPI = \"/executeService\";\n+    final String serviceExecutionStateAPI = \"/serviceExecutionStatus\";\n+\n+    public ConnectedDriveProxy(HttpClientFactory httpClientFactory, ConnectedDriveConfiguration config) {\n+        httpClient = httpClientFactory.getCommonHttpClient();\n+        authHttpClient = httpClientFactory.createHttpClient(AUTH_HTTP_CLIENT_NAME);\n+        authHttpClient.setFollowRedirects(false);\n+        try {\n+            authHttpClient.start();\n+        } catch (Exception e) {\n+            logger.warn(\"Auth Http Client cannot be started\");\n+        }\n+        configuration = config;\n+\n+        final StringBuilder legacyAuth = new StringBuilder();\n+        legacyAuth.append(\"https://\");\n+        legacyAuth.append(BimmerConstants.AUTH_SERVER_MAP.get(configuration.region));\n+        legacyAuth.append(BimmerConstants.OAUTH_ENDPOINT);\n+        legacyAuthUri = legacyAuth.toString();\n+        vehicleUrl = \"https://\" + getRegionServer() + \"/webapi/v1/user/vehicles\";\n+        baseUrl = vehicleUrl + \"/\";\n+        legacyUrl = \"https://\" + getRegionServer() + \"/api/vehicle/dynamic/v1/\";\n+    }\n+\n+    private synchronized void call(final String url, final boolean post, final @Nullable MultiMap<String> params,\n+            final ResponseCallback callback) {\n+        // only executed in \"simulation mode\"\n+        // SimulationTest.testSimulationOff() assures Injector is off when releasing\n+        if (Injector.isActive()) {\n+            if (url.equals(baseUrl)) {\n+                ((StringResponseCallback) callback).onResponse(Injector.getDiscovery());\n+            } else if (url.endsWith(vehicleStatusAPI)) {\n+                ((StringResponseCallback) callback).onResponse(Injector.getStatus());\n+            } else {\n+                logger.info(\"Simulation of {} not supported\", url);\n+            }\n+            return;\n+        }\n+        final Request req;\n+        final String encoded = params == null || params.isEmpty() ? null\n+                : UrlEncoded.encode(params, Charset.defaultCharset(), false);\n+        final String completeUrl;\n+\n+        if (post) {\n+            completeUrl = url;\n+            req = httpClient.POST(url);\n+            if (encoded != null) {\n+                req.content(new StringContentProvider(CONTENT_TYPE_URL_ENCODED, encoded, Charset.defaultCharset()));\n+            }\n+        } else {\n+            completeUrl = encoded == null ? url : url + Constants.QUESTION + encoded;\n+            req = httpClient.newRequest(completeUrl);\n+        }\n+        req.header(HttpHeader.AUTHORIZATION, getToken().getBearerToken());\n+        req.header(HttpHeader.REFERER, BimmerConstants.REFERER_URL);\n+\n+        req.timeout(HTTP_TIMEOUT_SEC, TimeUnit.SECONDS).send(new BufferingResponseListener() {\n+            @NonNullByDefault({})\n+            @Override\n+            public void onComplete(org.eclipse.jetty.client.api.Result result) {\n+                if (result.getResponse().getStatus() != 200) {\n+                    NetworkError error = new NetworkError();\n+                    error.url = completeUrl;\n+                    error.status = result.getResponse().getStatus();\n+                    if (result.getResponse().getReason() != null) {\n+                        error.reason = result.getResponse().getReason();\n+                    } else {\n+                        error.reason = result.getFailure().getMessage();\n+                    }\n+                    error.params = result.getRequest().getParams().toString();\n+                    logger.debug(\"HTTP Error {}\", error.toString());\n+                    callback.onError(error);\n+                } else {\n+                    if (callback instanceof StringResponseCallback) {\n+                        ((StringResponseCallback) callback).onResponse(getContentAsString());\n+                    } else {\n+                        ((ByteResponseCallback) callback).onResponse(getContent());\n+                    }\n+                }\n+            }\n+        });\n+    }\n+\n+    public void get(String url, @Nullable MultiMap<String> params, ResponseCallback callback) {\n+        call(url, false, params, callback);\n+    }\n+\n+    public void post(String url, @Nullable MultiMap<String> params, ResponseCallback callback) {\n+        call(url, true, params, callback);\n+    }\n+\n+    public void requestVehicles(StringResponseCallback callback) {\n+        get(vehicleUrl, null, callback);\n+    }\n+\n+    public void requestVehcileStatus(VehicleConfiguration config, StringResponseCallback callback) {\n+        get(baseUrl + config.vin + vehicleStatusAPI, null, callback);\n+    }\n+\n+    public void requestLegacyVehcileStatus(VehicleConfiguration config, StringResponseCallback callback) {\n+        // see https://github.com/jupe76/bmwcdapi/search?q=dynamic%2Fv1\n+        get(legacyUrl + config.vin + \"?offset=-60\", null, callback);\n+    }\n+\n+    public void requestLastTrip(VehicleConfiguration config, StringResponseCallback callback) {\n+        get(baseUrl + config.vin + lastTripAPI, null, callback);\n+    }\n+\n+    public void requestAllTrips(VehicleConfiguration config, StringResponseCallback callback) {\n+        get(baseUrl + config.vin + allTripsAPI, null, callback);\n+    }\n+\n+    public void requestChargingProfile(VehicleConfiguration config, StringResponseCallback callback) {\n+        get(baseUrl + config.vin + chargeAPI, null, callback);\n+    }\n+\n+    public void requestDestinations(VehicleConfiguration config, StringResponseCallback callback) {\n+        get(baseUrl + config.vin + destinationAPI, null, callback);\n+    }\n+\n+    public void requestRangeMap(VehicleConfiguration config, @Nullable MultiMap<String> params,\n+            StringResponseCallback callback) {\n+        get(baseUrl + config.vin + rangeMapAPI, params, callback);\n+    }\n+\n+    public void requestImage(VehicleConfiguration config, ImageProperties props, ByteResponseCallback callback) {\n+        final String localImageUrl = baseUrl + config.vin + imageAPI;\n+        final MultiMap<String> dataMap = new MultiMap<String>();\n+        dataMap.add(\"width\", Integer.toString(props.size));\n+        dataMap.add(\"height\", Integer.toString(props.size));\n+        dataMap.add(\"view\", props.viewport);\n+        get(localImageUrl, dataMap, callback);\n+    }\n+\n+    private String getRegionServer() {\n+        final String retVal = BimmerConstants.SERVER_MAP.get(configuration.region);\n+        return retVal == null ? Constants.INVALID : retVal;\n+    }\n+\n+    RemoteServiceHandler getRemoteServiceHandler(VehicleHandler vehicleHandler) {\n+        return new RemoteServiceHandler(vehicleHandler, this);\n+    }\n+\n+    // Token handling\n+\n+    /**\n+     * Gets new token if old one is expired or invalid. In case of error the token remains.\n+     * So if token refresh fails the corresponding requests will also fail and update the\n+     * Thing status accordingly.\n+     *\n+     * @return token\n+     */\n+    public Token getToken() {\n+        if (token.isExpired() || !token.isValid()) {\n+            updateToken();\n+        }\n+        return token;\n+    }\n+\n+    /**\n+     * Authorize at BMW Connected Drive Portal and get Token\n+     *\n+     * @return\n+     */\n+    private synchronized void updateToken() {\n+        final Request req = authHttpClient.POST(legacyAuthUri);\n+\n+        req.header(HttpHeader.CONNECTION, KEEP_ALIVE);\n+        req.header(HttpHeader.HOST, BimmerConstants.SERVER_MAP.get(configuration.region));\n+        req.header(HttpHeader.AUTHORIZATION, BimmerConstants.AUTHORIZATION_VALUE_MAP.get(configuration.region));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "48af48c82562d006b6f2aa35922270f181c885ed"}, "originalPosition": 252}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5OTE1NTIyNw==", "bodyText": "Applied same handling as getRegionServer", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r599155227", "createdAt": "2021-03-23T00:05:41Z", "author": {"login": "weymann"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/ConnectedDriveProxy.java", "diffHunk": "@@ -0,0 +1,314 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bmwconnecteddrive.internal.handler;\n+\n+import static org.openhab.binding.bmwconnecteddrive.internal.utils.HTTPConstants.*;\n+\n+import java.nio.charset.Charset;\n+import java.nio.charset.StandardCharsets;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.client.util.BufferingResponseListener;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.eclipse.jetty.http.HttpField;\n+import org.eclipse.jetty.http.HttpFields;\n+import org.eclipse.jetty.http.HttpHeader;\n+import org.eclipse.jetty.util.MultiMap;\n+import org.eclipse.jetty.util.UrlEncoded;\n+import org.openhab.binding.bmwconnecteddrive.internal.ConnectedDriveConfiguration;\n+import org.openhab.binding.bmwconnecteddrive.internal.VehicleConfiguration;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.NetworkError;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.auth.AuthResponse;\n+import org.openhab.binding.bmwconnecteddrive.internal.handler.simulation.Injector;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.BimmerConstants;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Constants;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Converter;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ImageProperties;\n+import org.openhab.core.io.net.http.HttpClientFactory;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonSyntaxException;\n+\n+/**\n+ * The {@link ConnectedDriveProxy} This class holds the important constants for the BMW Connected Drive Authorization.\n+ * They\n+ * are taken from the Bimmercode from github {@link https://github.com/bimmerconnected/bimmer_connected}\n+ * File defining these constants\n+ * {@link https://github.com/bimmerconnected/bimmer_connected/blob/master/bimmer_connected/account.py}\n+ * https://customer.bmwgroup.com/one/app/oauth.js\n+ *\n+ * @author Bernd Weymann - Initial contribution\n+ * @author Norbert Truchsess - edit & send of charge profile\n+ */\n+@NonNullByDefault\n+public class ConnectedDriveProxy {\n+    private final Logger logger = LoggerFactory.getLogger(ConnectedDriveProxy.class);\n+    private final Token token = new Token();\n+    private final HttpClient httpClient;\n+    private final HttpClient authHttpClient;\n+    private final String legacyAuthUri;\n+    private final ConnectedDriveConfiguration configuration;\n+\n+    /**\n+     * URLs taken from https://github.com/bimmerconnected/bimmer_connected/blob/master/bimmer_connected/const.py\n+     */\n+    final String baseUrl;\n+    final String vehicleUrl;\n+    final String legacyUrl;\n+    final String vehicleStatusAPI = \"/status\";\n+    final String lastTripAPI = \"/statistics/lastTrip\";\n+    final String allTripsAPI = \"/statistics/allTrips\";\n+    final String chargeAPI = \"/chargingprofile\";\n+    final String destinationAPI = \"/destinations\";\n+    final String imageAPI = \"/image\";\n+    final String rangeMapAPI = \"/rangemap\";\n+    final String serviceExecutionAPI = \"/executeService\";\n+    final String serviceExecutionStateAPI = \"/serviceExecutionStatus\";\n+\n+    public ConnectedDriveProxy(HttpClientFactory httpClientFactory, ConnectedDriveConfiguration config) {\n+        httpClient = httpClientFactory.getCommonHttpClient();\n+        authHttpClient = httpClientFactory.createHttpClient(AUTH_HTTP_CLIENT_NAME);\n+        authHttpClient.setFollowRedirects(false);\n+        try {\n+            authHttpClient.start();\n+        } catch (Exception e) {\n+            logger.warn(\"Auth Http Client cannot be started\");\n+        }\n+        configuration = config;\n+\n+        final StringBuilder legacyAuth = new StringBuilder();\n+        legacyAuth.append(\"https://\");\n+        legacyAuth.append(BimmerConstants.AUTH_SERVER_MAP.get(configuration.region));\n+        legacyAuth.append(BimmerConstants.OAUTH_ENDPOINT);\n+        legacyAuthUri = legacyAuth.toString();\n+        vehicleUrl = \"https://\" + getRegionServer() + \"/webapi/v1/user/vehicles\";\n+        baseUrl = vehicleUrl + \"/\";\n+        legacyUrl = \"https://\" + getRegionServer() + \"/api/vehicle/dynamic/v1/\";\n+    }\n+\n+    private synchronized void call(final String url, final boolean post, final @Nullable MultiMap<String> params,\n+            final ResponseCallback callback) {\n+        // only executed in \"simulation mode\"\n+        // SimulationTest.testSimulationOff() assures Injector is off when releasing\n+        if (Injector.isActive()) {\n+            if (url.equals(baseUrl)) {\n+                ((StringResponseCallback) callback).onResponse(Injector.getDiscovery());\n+            } else if (url.endsWith(vehicleStatusAPI)) {\n+                ((StringResponseCallback) callback).onResponse(Injector.getStatus());\n+            } else {\n+                logger.info(\"Simulation of {} not supported\", url);\n+            }\n+            return;\n+        }\n+        final Request req;\n+        final String encoded = params == null || params.isEmpty() ? null\n+                : UrlEncoded.encode(params, Charset.defaultCharset(), false);\n+        final String completeUrl;\n+\n+        if (post) {\n+            completeUrl = url;\n+            req = httpClient.POST(url);\n+            if (encoded != null) {\n+                req.content(new StringContentProvider(CONTENT_TYPE_URL_ENCODED, encoded, Charset.defaultCharset()));\n+            }\n+        } else {\n+            completeUrl = encoded == null ? url : url + Constants.QUESTION + encoded;\n+            req = httpClient.newRequest(completeUrl);\n+        }\n+        req.header(HttpHeader.AUTHORIZATION, getToken().getBearerToken());\n+        req.header(HttpHeader.REFERER, BimmerConstants.REFERER_URL);\n+\n+        req.timeout(HTTP_TIMEOUT_SEC, TimeUnit.SECONDS).send(new BufferingResponseListener() {\n+            @NonNullByDefault({})\n+            @Override\n+            public void onComplete(org.eclipse.jetty.client.api.Result result) {\n+                if (result.getResponse().getStatus() != 200) {\n+                    NetworkError error = new NetworkError();\n+                    error.url = completeUrl;\n+                    error.status = result.getResponse().getStatus();\n+                    if (result.getResponse().getReason() != null) {\n+                        error.reason = result.getResponse().getReason();\n+                    } else {\n+                        error.reason = result.getFailure().getMessage();\n+                    }\n+                    error.params = result.getRequest().getParams().toString();\n+                    logger.debug(\"HTTP Error {}\", error.toString());\n+                    callback.onError(error);\n+                } else {\n+                    if (callback instanceof StringResponseCallback) {\n+                        ((StringResponseCallback) callback).onResponse(getContentAsString());\n+                    } else {\n+                        ((ByteResponseCallback) callback).onResponse(getContent());\n+                    }\n+                }\n+            }\n+        });\n+    }\n+\n+    public void get(String url, @Nullable MultiMap<String> params, ResponseCallback callback) {\n+        call(url, false, params, callback);\n+    }\n+\n+    public void post(String url, @Nullable MultiMap<String> params, ResponseCallback callback) {\n+        call(url, true, params, callback);\n+    }\n+\n+    public void requestVehicles(StringResponseCallback callback) {\n+        get(vehicleUrl, null, callback);\n+    }\n+\n+    public void requestVehcileStatus(VehicleConfiguration config, StringResponseCallback callback) {\n+        get(baseUrl + config.vin + vehicleStatusAPI, null, callback);\n+    }\n+\n+    public void requestLegacyVehcileStatus(VehicleConfiguration config, StringResponseCallback callback) {\n+        // see https://github.com/jupe76/bmwcdapi/search?q=dynamic%2Fv1\n+        get(legacyUrl + config.vin + \"?offset=-60\", null, callback);\n+    }\n+\n+    public void requestLastTrip(VehicleConfiguration config, StringResponseCallback callback) {\n+        get(baseUrl + config.vin + lastTripAPI, null, callback);\n+    }\n+\n+    public void requestAllTrips(VehicleConfiguration config, StringResponseCallback callback) {\n+        get(baseUrl + config.vin + allTripsAPI, null, callback);\n+    }\n+\n+    public void requestChargingProfile(VehicleConfiguration config, StringResponseCallback callback) {\n+        get(baseUrl + config.vin + chargeAPI, null, callback);\n+    }\n+\n+    public void requestDestinations(VehicleConfiguration config, StringResponseCallback callback) {\n+        get(baseUrl + config.vin + destinationAPI, null, callback);\n+    }\n+\n+    public void requestRangeMap(VehicleConfiguration config, @Nullable MultiMap<String> params,\n+            StringResponseCallback callback) {\n+        get(baseUrl + config.vin + rangeMapAPI, params, callback);\n+    }\n+\n+    public void requestImage(VehicleConfiguration config, ImageProperties props, ByteResponseCallback callback) {\n+        final String localImageUrl = baseUrl + config.vin + imageAPI;\n+        final MultiMap<String> dataMap = new MultiMap<String>();\n+        dataMap.add(\"width\", Integer.toString(props.size));\n+        dataMap.add(\"height\", Integer.toString(props.size));\n+        dataMap.add(\"view\", props.viewport);\n+        get(localImageUrl, dataMap, callback);\n+    }\n+\n+    private String getRegionServer() {\n+        final String retVal = BimmerConstants.SERVER_MAP.get(configuration.region);\n+        return retVal == null ? Constants.INVALID : retVal;\n+    }\n+\n+    RemoteServiceHandler getRemoteServiceHandler(VehicleHandler vehicleHandler) {\n+        return new RemoteServiceHandler(vehicleHandler, this);\n+    }\n+\n+    // Token handling\n+\n+    /**\n+     * Gets new token if old one is expired or invalid. In case of error the token remains.\n+     * So if token refresh fails the corresponding requests will also fail and update the\n+     * Thing status accordingly.\n+     *\n+     * @return token\n+     */\n+    public Token getToken() {\n+        if (token.isExpired() || !token.isValid()) {\n+            updateToken();\n+        }\n+        return token;\n+    }\n+\n+    /**\n+     * Authorize at BMW Connected Drive Portal and get Token\n+     *\n+     * @return\n+     */\n+    private synchronized void updateToken() {\n+        final Request req = authHttpClient.POST(legacyAuthUri);\n+\n+        req.header(HttpHeader.CONNECTION, KEEP_ALIVE);\n+        req.header(HttpHeader.HOST, BimmerConstants.SERVER_MAP.get(configuration.region));\n+        req.header(HttpHeader.AUTHORIZATION, BimmerConstants.AUTHORIZATION_VALUE_MAP.get(configuration.region));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5Nzg5MzUxMw=="}, "originalCommit": {"oid": "48af48c82562d006b6f2aa35922270f181c885ed"}, "originalPosition": 252}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzc3NjYxNzU0OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/ConnectedDriveProxy.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0xOVQxODoyODowMVrOI6Miiw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0yMVQxMzozMzoxMFrOI6kKCQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5Nzg5Mzc3MQ==", "bodyText": "See above. Encoding.", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r597893771", "createdAt": "2021-03-19T18:28:01Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/ConnectedDriveProxy.java", "diffHunk": "@@ -0,0 +1,314 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bmwconnecteddrive.internal.handler;\n+\n+import static org.openhab.binding.bmwconnecteddrive.internal.utils.HTTPConstants.*;\n+\n+import java.nio.charset.Charset;\n+import java.nio.charset.StandardCharsets;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.client.util.BufferingResponseListener;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.eclipse.jetty.http.HttpField;\n+import org.eclipse.jetty.http.HttpFields;\n+import org.eclipse.jetty.http.HttpHeader;\n+import org.eclipse.jetty.util.MultiMap;\n+import org.eclipse.jetty.util.UrlEncoded;\n+import org.openhab.binding.bmwconnecteddrive.internal.ConnectedDriveConfiguration;\n+import org.openhab.binding.bmwconnecteddrive.internal.VehicleConfiguration;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.NetworkError;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.auth.AuthResponse;\n+import org.openhab.binding.bmwconnecteddrive.internal.handler.simulation.Injector;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.BimmerConstants;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Constants;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Converter;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ImageProperties;\n+import org.openhab.core.io.net.http.HttpClientFactory;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonSyntaxException;\n+\n+/**\n+ * The {@link ConnectedDriveProxy} This class holds the important constants for the BMW Connected Drive Authorization.\n+ * They\n+ * are taken from the Bimmercode from github {@link https://github.com/bimmerconnected/bimmer_connected}\n+ * File defining these constants\n+ * {@link https://github.com/bimmerconnected/bimmer_connected/blob/master/bimmer_connected/account.py}\n+ * https://customer.bmwgroup.com/one/app/oauth.js\n+ *\n+ * @author Bernd Weymann - Initial contribution\n+ * @author Norbert Truchsess - edit & send of charge profile\n+ */\n+@NonNullByDefault\n+public class ConnectedDriveProxy {\n+    private final Logger logger = LoggerFactory.getLogger(ConnectedDriveProxy.class);\n+    private final Token token = new Token();\n+    private final HttpClient httpClient;\n+    private final HttpClient authHttpClient;\n+    private final String legacyAuthUri;\n+    private final ConnectedDriveConfiguration configuration;\n+\n+    /**\n+     * URLs taken from https://github.com/bimmerconnected/bimmer_connected/blob/master/bimmer_connected/const.py\n+     */\n+    final String baseUrl;\n+    final String vehicleUrl;\n+    final String legacyUrl;\n+    final String vehicleStatusAPI = \"/status\";\n+    final String lastTripAPI = \"/statistics/lastTrip\";\n+    final String allTripsAPI = \"/statistics/allTrips\";\n+    final String chargeAPI = \"/chargingprofile\";\n+    final String destinationAPI = \"/destinations\";\n+    final String imageAPI = \"/image\";\n+    final String rangeMapAPI = \"/rangemap\";\n+    final String serviceExecutionAPI = \"/executeService\";\n+    final String serviceExecutionStateAPI = \"/serviceExecutionStatus\";\n+\n+    public ConnectedDriveProxy(HttpClientFactory httpClientFactory, ConnectedDriveConfiguration config) {\n+        httpClient = httpClientFactory.getCommonHttpClient();\n+        authHttpClient = httpClientFactory.createHttpClient(AUTH_HTTP_CLIENT_NAME);\n+        authHttpClient.setFollowRedirects(false);\n+        try {\n+            authHttpClient.start();\n+        } catch (Exception e) {\n+            logger.warn(\"Auth Http Client cannot be started\");\n+        }\n+        configuration = config;\n+\n+        final StringBuilder legacyAuth = new StringBuilder();\n+        legacyAuth.append(\"https://\");\n+        legacyAuth.append(BimmerConstants.AUTH_SERVER_MAP.get(configuration.region));\n+        legacyAuth.append(BimmerConstants.OAUTH_ENDPOINT);\n+        legacyAuthUri = legacyAuth.toString();\n+        vehicleUrl = \"https://\" + getRegionServer() + \"/webapi/v1/user/vehicles\";\n+        baseUrl = vehicleUrl + \"/\";\n+        legacyUrl = \"https://\" + getRegionServer() + \"/api/vehicle/dynamic/v1/\";\n+    }\n+\n+    private synchronized void call(final String url, final boolean post, final @Nullable MultiMap<String> params,\n+            final ResponseCallback callback) {\n+        // only executed in \"simulation mode\"\n+        // SimulationTest.testSimulationOff() assures Injector is off when releasing\n+        if (Injector.isActive()) {\n+            if (url.equals(baseUrl)) {\n+                ((StringResponseCallback) callback).onResponse(Injector.getDiscovery());\n+            } else if (url.endsWith(vehicleStatusAPI)) {\n+                ((StringResponseCallback) callback).onResponse(Injector.getStatus());\n+            } else {\n+                logger.info(\"Simulation of {} not supported\", url);\n+            }\n+            return;\n+        }\n+        final Request req;\n+        final String encoded = params == null || params.isEmpty() ? null\n+                : UrlEncoded.encode(params, Charset.defaultCharset(), false);\n+        final String completeUrl;\n+\n+        if (post) {\n+            completeUrl = url;\n+            req = httpClient.POST(url);\n+            if (encoded != null) {\n+                req.content(new StringContentProvider(CONTENT_TYPE_URL_ENCODED, encoded, Charset.defaultCharset()));\n+            }\n+        } else {\n+            completeUrl = encoded == null ? url : url + Constants.QUESTION + encoded;\n+            req = httpClient.newRequest(completeUrl);\n+        }\n+        req.header(HttpHeader.AUTHORIZATION, getToken().getBearerToken());\n+        req.header(HttpHeader.REFERER, BimmerConstants.REFERER_URL);\n+\n+        req.timeout(HTTP_TIMEOUT_SEC, TimeUnit.SECONDS).send(new BufferingResponseListener() {\n+            @NonNullByDefault({})\n+            @Override\n+            public void onComplete(org.eclipse.jetty.client.api.Result result) {\n+                if (result.getResponse().getStatus() != 200) {\n+                    NetworkError error = new NetworkError();\n+                    error.url = completeUrl;\n+                    error.status = result.getResponse().getStatus();\n+                    if (result.getResponse().getReason() != null) {\n+                        error.reason = result.getResponse().getReason();\n+                    } else {\n+                        error.reason = result.getFailure().getMessage();\n+                    }\n+                    error.params = result.getRequest().getParams().toString();\n+                    logger.debug(\"HTTP Error {}\", error.toString());\n+                    callback.onError(error);\n+                } else {\n+                    if (callback instanceof StringResponseCallback) {\n+                        ((StringResponseCallback) callback).onResponse(getContentAsString());\n+                    } else {\n+                        ((ByteResponseCallback) callback).onResponse(getContent());\n+                    }\n+                }\n+            }\n+        });\n+    }\n+\n+    public void get(String url, @Nullable MultiMap<String> params, ResponseCallback callback) {\n+        call(url, false, params, callback);\n+    }\n+\n+    public void post(String url, @Nullable MultiMap<String> params, ResponseCallback callback) {\n+        call(url, true, params, callback);\n+    }\n+\n+    public void requestVehicles(StringResponseCallback callback) {\n+        get(vehicleUrl, null, callback);\n+    }\n+\n+    public void requestVehcileStatus(VehicleConfiguration config, StringResponseCallback callback) {\n+        get(baseUrl + config.vin + vehicleStatusAPI, null, callback);\n+    }\n+\n+    public void requestLegacyVehcileStatus(VehicleConfiguration config, StringResponseCallback callback) {\n+        // see https://github.com/jupe76/bmwcdapi/search?q=dynamic%2Fv1\n+        get(legacyUrl + config.vin + \"?offset=-60\", null, callback);\n+    }\n+\n+    public void requestLastTrip(VehicleConfiguration config, StringResponseCallback callback) {\n+        get(baseUrl + config.vin + lastTripAPI, null, callback);\n+    }\n+\n+    public void requestAllTrips(VehicleConfiguration config, StringResponseCallback callback) {\n+        get(baseUrl + config.vin + allTripsAPI, null, callback);\n+    }\n+\n+    public void requestChargingProfile(VehicleConfiguration config, StringResponseCallback callback) {\n+        get(baseUrl + config.vin + chargeAPI, null, callback);\n+    }\n+\n+    public void requestDestinations(VehicleConfiguration config, StringResponseCallback callback) {\n+        get(baseUrl + config.vin + destinationAPI, null, callback);\n+    }\n+\n+    public void requestRangeMap(VehicleConfiguration config, @Nullable MultiMap<String> params,\n+            StringResponseCallback callback) {\n+        get(baseUrl + config.vin + rangeMapAPI, params, callback);\n+    }\n+\n+    public void requestImage(VehicleConfiguration config, ImageProperties props, ByteResponseCallback callback) {\n+        final String localImageUrl = baseUrl + config.vin + imageAPI;\n+        final MultiMap<String> dataMap = new MultiMap<String>();\n+        dataMap.add(\"width\", Integer.toString(props.size));\n+        dataMap.add(\"height\", Integer.toString(props.size));\n+        dataMap.add(\"view\", props.viewport);\n+        get(localImageUrl, dataMap, callback);\n+    }\n+\n+    private String getRegionServer() {\n+        final String retVal = BimmerConstants.SERVER_MAP.get(configuration.region);\n+        return retVal == null ? Constants.INVALID : retVal;\n+    }\n+\n+    RemoteServiceHandler getRemoteServiceHandler(VehicleHandler vehicleHandler) {\n+        return new RemoteServiceHandler(vehicleHandler, this);\n+    }\n+\n+    // Token handling\n+\n+    /**\n+     * Gets new token if old one is expired or invalid. In case of error the token remains.\n+     * So if token refresh fails the corresponding requests will also fail and update the\n+     * Thing status accordingly.\n+     *\n+     * @return token\n+     */\n+    public Token getToken() {\n+        if (token.isExpired() || !token.isValid()) {\n+            updateToken();\n+        }\n+        return token;\n+    }\n+\n+    /**\n+     * Authorize at BMW Connected Drive Portal and get Token\n+     *\n+     * @return\n+     */\n+    private synchronized void updateToken() {\n+        final Request req = authHttpClient.POST(legacyAuthUri);\n+\n+        req.header(HttpHeader.CONNECTION, KEEP_ALIVE);\n+        req.header(HttpHeader.HOST, BimmerConstants.SERVER_MAP.get(configuration.region));\n+        req.header(HttpHeader.AUTHORIZATION, BimmerConstants.AUTHORIZATION_VALUE_MAP.get(configuration.region));\n+        req.header(CREDENTIALS, BimmerConstants.CREDENTIAL_VALUES);\n+        req.header(HttpHeader.REFERER, BimmerConstants.REFERER_URL);\n+\n+        final MultiMap<String> dataMap = new MultiMap<String>();\n+        dataMap.add(\"grant_type\", \"password\");\n+        dataMap.add(SCOPE, BimmerConstants.SCOPE_VALUES);\n+        dataMap.add(USERNAME, configuration.userName);\n+        dataMap.add(PASSWORD, configuration.password);\n+        req.content(new StringContentProvider(CONTENT_TYPE_URL_ENCODED,\n+                UrlEncoded.encode(dataMap, Charset.defaultCharset(), false), Charset.defaultCharset()));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "48af48c82562d006b6f2aa35922270f181c885ed"}, "originalPosition": 262}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5ODI4MDcxMw==", "bodyText": "fixed in weymann#8", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r598280713", "createdAt": "2021-03-21T13:33:10Z", "author": {"login": "ntruchsess"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/ConnectedDriveProxy.java", "diffHunk": "@@ -0,0 +1,314 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bmwconnecteddrive.internal.handler;\n+\n+import static org.openhab.binding.bmwconnecteddrive.internal.utils.HTTPConstants.*;\n+\n+import java.nio.charset.Charset;\n+import java.nio.charset.StandardCharsets;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.client.util.BufferingResponseListener;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.eclipse.jetty.http.HttpField;\n+import org.eclipse.jetty.http.HttpFields;\n+import org.eclipse.jetty.http.HttpHeader;\n+import org.eclipse.jetty.util.MultiMap;\n+import org.eclipse.jetty.util.UrlEncoded;\n+import org.openhab.binding.bmwconnecteddrive.internal.ConnectedDriveConfiguration;\n+import org.openhab.binding.bmwconnecteddrive.internal.VehicleConfiguration;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.NetworkError;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.auth.AuthResponse;\n+import org.openhab.binding.bmwconnecteddrive.internal.handler.simulation.Injector;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.BimmerConstants;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Constants;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Converter;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ImageProperties;\n+import org.openhab.core.io.net.http.HttpClientFactory;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonSyntaxException;\n+\n+/**\n+ * The {@link ConnectedDriveProxy} This class holds the important constants for the BMW Connected Drive Authorization.\n+ * They\n+ * are taken from the Bimmercode from github {@link https://github.com/bimmerconnected/bimmer_connected}\n+ * File defining these constants\n+ * {@link https://github.com/bimmerconnected/bimmer_connected/blob/master/bimmer_connected/account.py}\n+ * https://customer.bmwgroup.com/one/app/oauth.js\n+ *\n+ * @author Bernd Weymann - Initial contribution\n+ * @author Norbert Truchsess - edit & send of charge profile\n+ */\n+@NonNullByDefault\n+public class ConnectedDriveProxy {\n+    private final Logger logger = LoggerFactory.getLogger(ConnectedDriveProxy.class);\n+    private final Token token = new Token();\n+    private final HttpClient httpClient;\n+    private final HttpClient authHttpClient;\n+    private final String legacyAuthUri;\n+    private final ConnectedDriveConfiguration configuration;\n+\n+    /**\n+     * URLs taken from https://github.com/bimmerconnected/bimmer_connected/blob/master/bimmer_connected/const.py\n+     */\n+    final String baseUrl;\n+    final String vehicleUrl;\n+    final String legacyUrl;\n+    final String vehicleStatusAPI = \"/status\";\n+    final String lastTripAPI = \"/statistics/lastTrip\";\n+    final String allTripsAPI = \"/statistics/allTrips\";\n+    final String chargeAPI = \"/chargingprofile\";\n+    final String destinationAPI = \"/destinations\";\n+    final String imageAPI = \"/image\";\n+    final String rangeMapAPI = \"/rangemap\";\n+    final String serviceExecutionAPI = \"/executeService\";\n+    final String serviceExecutionStateAPI = \"/serviceExecutionStatus\";\n+\n+    public ConnectedDriveProxy(HttpClientFactory httpClientFactory, ConnectedDriveConfiguration config) {\n+        httpClient = httpClientFactory.getCommonHttpClient();\n+        authHttpClient = httpClientFactory.createHttpClient(AUTH_HTTP_CLIENT_NAME);\n+        authHttpClient.setFollowRedirects(false);\n+        try {\n+            authHttpClient.start();\n+        } catch (Exception e) {\n+            logger.warn(\"Auth Http Client cannot be started\");\n+        }\n+        configuration = config;\n+\n+        final StringBuilder legacyAuth = new StringBuilder();\n+        legacyAuth.append(\"https://\");\n+        legacyAuth.append(BimmerConstants.AUTH_SERVER_MAP.get(configuration.region));\n+        legacyAuth.append(BimmerConstants.OAUTH_ENDPOINT);\n+        legacyAuthUri = legacyAuth.toString();\n+        vehicleUrl = \"https://\" + getRegionServer() + \"/webapi/v1/user/vehicles\";\n+        baseUrl = vehicleUrl + \"/\";\n+        legacyUrl = \"https://\" + getRegionServer() + \"/api/vehicle/dynamic/v1/\";\n+    }\n+\n+    private synchronized void call(final String url, final boolean post, final @Nullable MultiMap<String> params,\n+            final ResponseCallback callback) {\n+        // only executed in \"simulation mode\"\n+        // SimulationTest.testSimulationOff() assures Injector is off when releasing\n+        if (Injector.isActive()) {\n+            if (url.equals(baseUrl)) {\n+                ((StringResponseCallback) callback).onResponse(Injector.getDiscovery());\n+            } else if (url.endsWith(vehicleStatusAPI)) {\n+                ((StringResponseCallback) callback).onResponse(Injector.getStatus());\n+            } else {\n+                logger.info(\"Simulation of {} not supported\", url);\n+            }\n+            return;\n+        }\n+        final Request req;\n+        final String encoded = params == null || params.isEmpty() ? null\n+                : UrlEncoded.encode(params, Charset.defaultCharset(), false);\n+        final String completeUrl;\n+\n+        if (post) {\n+            completeUrl = url;\n+            req = httpClient.POST(url);\n+            if (encoded != null) {\n+                req.content(new StringContentProvider(CONTENT_TYPE_URL_ENCODED, encoded, Charset.defaultCharset()));\n+            }\n+        } else {\n+            completeUrl = encoded == null ? url : url + Constants.QUESTION + encoded;\n+            req = httpClient.newRequest(completeUrl);\n+        }\n+        req.header(HttpHeader.AUTHORIZATION, getToken().getBearerToken());\n+        req.header(HttpHeader.REFERER, BimmerConstants.REFERER_URL);\n+\n+        req.timeout(HTTP_TIMEOUT_SEC, TimeUnit.SECONDS).send(new BufferingResponseListener() {\n+            @NonNullByDefault({})\n+            @Override\n+            public void onComplete(org.eclipse.jetty.client.api.Result result) {\n+                if (result.getResponse().getStatus() != 200) {\n+                    NetworkError error = new NetworkError();\n+                    error.url = completeUrl;\n+                    error.status = result.getResponse().getStatus();\n+                    if (result.getResponse().getReason() != null) {\n+                        error.reason = result.getResponse().getReason();\n+                    } else {\n+                        error.reason = result.getFailure().getMessage();\n+                    }\n+                    error.params = result.getRequest().getParams().toString();\n+                    logger.debug(\"HTTP Error {}\", error.toString());\n+                    callback.onError(error);\n+                } else {\n+                    if (callback instanceof StringResponseCallback) {\n+                        ((StringResponseCallback) callback).onResponse(getContentAsString());\n+                    } else {\n+                        ((ByteResponseCallback) callback).onResponse(getContent());\n+                    }\n+                }\n+            }\n+        });\n+    }\n+\n+    public void get(String url, @Nullable MultiMap<String> params, ResponseCallback callback) {\n+        call(url, false, params, callback);\n+    }\n+\n+    public void post(String url, @Nullable MultiMap<String> params, ResponseCallback callback) {\n+        call(url, true, params, callback);\n+    }\n+\n+    public void requestVehicles(StringResponseCallback callback) {\n+        get(vehicleUrl, null, callback);\n+    }\n+\n+    public void requestVehcileStatus(VehicleConfiguration config, StringResponseCallback callback) {\n+        get(baseUrl + config.vin + vehicleStatusAPI, null, callback);\n+    }\n+\n+    public void requestLegacyVehcileStatus(VehicleConfiguration config, StringResponseCallback callback) {\n+        // see https://github.com/jupe76/bmwcdapi/search?q=dynamic%2Fv1\n+        get(legacyUrl + config.vin + \"?offset=-60\", null, callback);\n+    }\n+\n+    public void requestLastTrip(VehicleConfiguration config, StringResponseCallback callback) {\n+        get(baseUrl + config.vin + lastTripAPI, null, callback);\n+    }\n+\n+    public void requestAllTrips(VehicleConfiguration config, StringResponseCallback callback) {\n+        get(baseUrl + config.vin + allTripsAPI, null, callback);\n+    }\n+\n+    public void requestChargingProfile(VehicleConfiguration config, StringResponseCallback callback) {\n+        get(baseUrl + config.vin + chargeAPI, null, callback);\n+    }\n+\n+    public void requestDestinations(VehicleConfiguration config, StringResponseCallback callback) {\n+        get(baseUrl + config.vin + destinationAPI, null, callback);\n+    }\n+\n+    public void requestRangeMap(VehicleConfiguration config, @Nullable MultiMap<String> params,\n+            StringResponseCallback callback) {\n+        get(baseUrl + config.vin + rangeMapAPI, params, callback);\n+    }\n+\n+    public void requestImage(VehicleConfiguration config, ImageProperties props, ByteResponseCallback callback) {\n+        final String localImageUrl = baseUrl + config.vin + imageAPI;\n+        final MultiMap<String> dataMap = new MultiMap<String>();\n+        dataMap.add(\"width\", Integer.toString(props.size));\n+        dataMap.add(\"height\", Integer.toString(props.size));\n+        dataMap.add(\"view\", props.viewport);\n+        get(localImageUrl, dataMap, callback);\n+    }\n+\n+    private String getRegionServer() {\n+        final String retVal = BimmerConstants.SERVER_MAP.get(configuration.region);\n+        return retVal == null ? Constants.INVALID : retVal;\n+    }\n+\n+    RemoteServiceHandler getRemoteServiceHandler(VehicleHandler vehicleHandler) {\n+        return new RemoteServiceHandler(vehicleHandler, this);\n+    }\n+\n+    // Token handling\n+\n+    /**\n+     * Gets new token if old one is expired or invalid. In case of error the token remains.\n+     * So if token refresh fails the corresponding requests will also fail and update the\n+     * Thing status accordingly.\n+     *\n+     * @return token\n+     */\n+    public Token getToken() {\n+        if (token.isExpired() || !token.isValid()) {\n+            updateToken();\n+        }\n+        return token;\n+    }\n+\n+    /**\n+     * Authorize at BMW Connected Drive Portal and get Token\n+     *\n+     * @return\n+     */\n+    private synchronized void updateToken() {\n+        final Request req = authHttpClient.POST(legacyAuthUri);\n+\n+        req.header(HttpHeader.CONNECTION, KEEP_ALIVE);\n+        req.header(HttpHeader.HOST, BimmerConstants.SERVER_MAP.get(configuration.region));\n+        req.header(HttpHeader.AUTHORIZATION, BimmerConstants.AUTHORIZATION_VALUE_MAP.get(configuration.region));\n+        req.header(CREDENTIALS, BimmerConstants.CREDENTIAL_VALUES);\n+        req.header(HttpHeader.REFERER, BimmerConstants.REFERER_URL);\n+\n+        final MultiMap<String> dataMap = new MultiMap<String>();\n+        dataMap.add(\"grant_type\", \"password\");\n+        dataMap.add(SCOPE, BimmerConstants.SCOPE_VALUES);\n+        dataMap.add(USERNAME, configuration.userName);\n+        dataMap.add(PASSWORD, configuration.password);\n+        req.content(new StringContentProvider(CONTENT_TYPE_URL_ENCODED,\n+                UrlEncoded.encode(dataMap, Charset.defaultCharset(), false), Charset.defaultCharset()));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5Nzg5Mzc3MQ=="}, "originalCommit": {"oid": "48af48c82562d006b6f2aa35922270f181c885ed"}, "originalPosition": 262}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzc3NjYyMjExOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/ConnectedDriveProxy.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0xOVQxODoyOTowOFrOI6MlSg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0yMVQxMzozNDo0OVrOI6kK5A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5Nzg5NDQ3NA==", "bodyText": "It seems unreasonable to log the stack trace if the network fails.\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    } catch (InterruptedException | ExecutionException | TimeoutException e) {\n          \n          \n            \n                        logger.debug(\"Authorization exception: {}\", e.getMessage(), e);\n          \n          \n            \n                    } catch (InterruptedException | ExecutionException | TimeoutException e) {\n          \n          \n            \n                        logger.debug(\"Authorization exception: {}\", e.getMessage());", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r597894474", "createdAt": "2021-03-19T18:29:08Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/ConnectedDriveProxy.java", "diffHunk": "@@ -0,0 +1,314 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bmwconnecteddrive.internal.handler;\n+\n+import static org.openhab.binding.bmwconnecteddrive.internal.utils.HTTPConstants.*;\n+\n+import java.nio.charset.Charset;\n+import java.nio.charset.StandardCharsets;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.client.util.BufferingResponseListener;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.eclipse.jetty.http.HttpField;\n+import org.eclipse.jetty.http.HttpFields;\n+import org.eclipse.jetty.http.HttpHeader;\n+import org.eclipse.jetty.util.MultiMap;\n+import org.eclipse.jetty.util.UrlEncoded;\n+import org.openhab.binding.bmwconnecteddrive.internal.ConnectedDriveConfiguration;\n+import org.openhab.binding.bmwconnecteddrive.internal.VehicleConfiguration;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.NetworkError;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.auth.AuthResponse;\n+import org.openhab.binding.bmwconnecteddrive.internal.handler.simulation.Injector;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.BimmerConstants;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Constants;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Converter;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ImageProperties;\n+import org.openhab.core.io.net.http.HttpClientFactory;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonSyntaxException;\n+\n+/**\n+ * The {@link ConnectedDriveProxy} This class holds the important constants for the BMW Connected Drive Authorization.\n+ * They\n+ * are taken from the Bimmercode from github {@link https://github.com/bimmerconnected/bimmer_connected}\n+ * File defining these constants\n+ * {@link https://github.com/bimmerconnected/bimmer_connected/blob/master/bimmer_connected/account.py}\n+ * https://customer.bmwgroup.com/one/app/oauth.js\n+ *\n+ * @author Bernd Weymann - Initial contribution\n+ * @author Norbert Truchsess - edit & send of charge profile\n+ */\n+@NonNullByDefault\n+public class ConnectedDriveProxy {\n+    private final Logger logger = LoggerFactory.getLogger(ConnectedDriveProxy.class);\n+    private final Token token = new Token();\n+    private final HttpClient httpClient;\n+    private final HttpClient authHttpClient;\n+    private final String legacyAuthUri;\n+    private final ConnectedDriveConfiguration configuration;\n+\n+    /**\n+     * URLs taken from https://github.com/bimmerconnected/bimmer_connected/blob/master/bimmer_connected/const.py\n+     */\n+    final String baseUrl;\n+    final String vehicleUrl;\n+    final String legacyUrl;\n+    final String vehicleStatusAPI = \"/status\";\n+    final String lastTripAPI = \"/statistics/lastTrip\";\n+    final String allTripsAPI = \"/statistics/allTrips\";\n+    final String chargeAPI = \"/chargingprofile\";\n+    final String destinationAPI = \"/destinations\";\n+    final String imageAPI = \"/image\";\n+    final String rangeMapAPI = \"/rangemap\";\n+    final String serviceExecutionAPI = \"/executeService\";\n+    final String serviceExecutionStateAPI = \"/serviceExecutionStatus\";\n+\n+    public ConnectedDriveProxy(HttpClientFactory httpClientFactory, ConnectedDriveConfiguration config) {\n+        httpClient = httpClientFactory.getCommonHttpClient();\n+        authHttpClient = httpClientFactory.createHttpClient(AUTH_HTTP_CLIENT_NAME);\n+        authHttpClient.setFollowRedirects(false);\n+        try {\n+            authHttpClient.start();\n+        } catch (Exception e) {\n+            logger.warn(\"Auth Http Client cannot be started\");\n+        }\n+        configuration = config;\n+\n+        final StringBuilder legacyAuth = new StringBuilder();\n+        legacyAuth.append(\"https://\");\n+        legacyAuth.append(BimmerConstants.AUTH_SERVER_MAP.get(configuration.region));\n+        legacyAuth.append(BimmerConstants.OAUTH_ENDPOINT);\n+        legacyAuthUri = legacyAuth.toString();\n+        vehicleUrl = \"https://\" + getRegionServer() + \"/webapi/v1/user/vehicles\";\n+        baseUrl = vehicleUrl + \"/\";\n+        legacyUrl = \"https://\" + getRegionServer() + \"/api/vehicle/dynamic/v1/\";\n+    }\n+\n+    private synchronized void call(final String url, final boolean post, final @Nullable MultiMap<String> params,\n+            final ResponseCallback callback) {\n+        // only executed in \"simulation mode\"\n+        // SimulationTest.testSimulationOff() assures Injector is off when releasing\n+        if (Injector.isActive()) {\n+            if (url.equals(baseUrl)) {\n+                ((StringResponseCallback) callback).onResponse(Injector.getDiscovery());\n+            } else if (url.endsWith(vehicleStatusAPI)) {\n+                ((StringResponseCallback) callback).onResponse(Injector.getStatus());\n+            } else {\n+                logger.info(\"Simulation of {} not supported\", url);\n+            }\n+            return;\n+        }\n+        final Request req;\n+        final String encoded = params == null || params.isEmpty() ? null\n+                : UrlEncoded.encode(params, Charset.defaultCharset(), false);\n+        final String completeUrl;\n+\n+        if (post) {\n+            completeUrl = url;\n+            req = httpClient.POST(url);\n+            if (encoded != null) {\n+                req.content(new StringContentProvider(CONTENT_TYPE_URL_ENCODED, encoded, Charset.defaultCharset()));\n+            }\n+        } else {\n+            completeUrl = encoded == null ? url : url + Constants.QUESTION + encoded;\n+            req = httpClient.newRequest(completeUrl);\n+        }\n+        req.header(HttpHeader.AUTHORIZATION, getToken().getBearerToken());\n+        req.header(HttpHeader.REFERER, BimmerConstants.REFERER_URL);\n+\n+        req.timeout(HTTP_TIMEOUT_SEC, TimeUnit.SECONDS).send(new BufferingResponseListener() {\n+            @NonNullByDefault({})\n+            @Override\n+            public void onComplete(org.eclipse.jetty.client.api.Result result) {\n+                if (result.getResponse().getStatus() != 200) {\n+                    NetworkError error = new NetworkError();\n+                    error.url = completeUrl;\n+                    error.status = result.getResponse().getStatus();\n+                    if (result.getResponse().getReason() != null) {\n+                        error.reason = result.getResponse().getReason();\n+                    } else {\n+                        error.reason = result.getFailure().getMessage();\n+                    }\n+                    error.params = result.getRequest().getParams().toString();\n+                    logger.debug(\"HTTP Error {}\", error.toString());\n+                    callback.onError(error);\n+                } else {\n+                    if (callback instanceof StringResponseCallback) {\n+                        ((StringResponseCallback) callback).onResponse(getContentAsString());\n+                    } else {\n+                        ((ByteResponseCallback) callback).onResponse(getContent());\n+                    }\n+                }\n+            }\n+        });\n+    }\n+\n+    public void get(String url, @Nullable MultiMap<String> params, ResponseCallback callback) {\n+        call(url, false, params, callback);\n+    }\n+\n+    public void post(String url, @Nullable MultiMap<String> params, ResponseCallback callback) {\n+        call(url, true, params, callback);\n+    }\n+\n+    public void requestVehicles(StringResponseCallback callback) {\n+        get(vehicleUrl, null, callback);\n+    }\n+\n+    public void requestVehcileStatus(VehicleConfiguration config, StringResponseCallback callback) {\n+        get(baseUrl + config.vin + vehicleStatusAPI, null, callback);\n+    }\n+\n+    public void requestLegacyVehcileStatus(VehicleConfiguration config, StringResponseCallback callback) {\n+        // see https://github.com/jupe76/bmwcdapi/search?q=dynamic%2Fv1\n+        get(legacyUrl + config.vin + \"?offset=-60\", null, callback);\n+    }\n+\n+    public void requestLastTrip(VehicleConfiguration config, StringResponseCallback callback) {\n+        get(baseUrl + config.vin + lastTripAPI, null, callback);\n+    }\n+\n+    public void requestAllTrips(VehicleConfiguration config, StringResponseCallback callback) {\n+        get(baseUrl + config.vin + allTripsAPI, null, callback);\n+    }\n+\n+    public void requestChargingProfile(VehicleConfiguration config, StringResponseCallback callback) {\n+        get(baseUrl + config.vin + chargeAPI, null, callback);\n+    }\n+\n+    public void requestDestinations(VehicleConfiguration config, StringResponseCallback callback) {\n+        get(baseUrl + config.vin + destinationAPI, null, callback);\n+    }\n+\n+    public void requestRangeMap(VehicleConfiguration config, @Nullable MultiMap<String> params,\n+            StringResponseCallback callback) {\n+        get(baseUrl + config.vin + rangeMapAPI, params, callback);\n+    }\n+\n+    public void requestImage(VehicleConfiguration config, ImageProperties props, ByteResponseCallback callback) {\n+        final String localImageUrl = baseUrl + config.vin + imageAPI;\n+        final MultiMap<String> dataMap = new MultiMap<String>();\n+        dataMap.add(\"width\", Integer.toString(props.size));\n+        dataMap.add(\"height\", Integer.toString(props.size));\n+        dataMap.add(\"view\", props.viewport);\n+        get(localImageUrl, dataMap, callback);\n+    }\n+\n+    private String getRegionServer() {\n+        final String retVal = BimmerConstants.SERVER_MAP.get(configuration.region);\n+        return retVal == null ? Constants.INVALID : retVal;\n+    }\n+\n+    RemoteServiceHandler getRemoteServiceHandler(VehicleHandler vehicleHandler) {\n+        return new RemoteServiceHandler(vehicleHandler, this);\n+    }\n+\n+    // Token handling\n+\n+    /**\n+     * Gets new token if old one is expired or invalid. In case of error the token remains.\n+     * So if token refresh fails the corresponding requests will also fail and update the\n+     * Thing status accordingly.\n+     *\n+     * @return token\n+     */\n+    public Token getToken() {\n+        if (token.isExpired() || !token.isValid()) {\n+            updateToken();\n+        }\n+        return token;\n+    }\n+\n+    /**\n+     * Authorize at BMW Connected Drive Portal and get Token\n+     *\n+     * @return\n+     */\n+    private synchronized void updateToken() {\n+        final Request req = authHttpClient.POST(legacyAuthUri);\n+\n+        req.header(HttpHeader.CONNECTION, KEEP_ALIVE);\n+        req.header(HttpHeader.HOST, BimmerConstants.SERVER_MAP.get(configuration.region));\n+        req.header(HttpHeader.AUTHORIZATION, BimmerConstants.AUTHORIZATION_VALUE_MAP.get(configuration.region));\n+        req.header(CREDENTIALS, BimmerConstants.CREDENTIAL_VALUES);\n+        req.header(HttpHeader.REFERER, BimmerConstants.REFERER_URL);\n+\n+        final MultiMap<String> dataMap = new MultiMap<String>();\n+        dataMap.add(\"grant_type\", \"password\");\n+        dataMap.add(SCOPE, BimmerConstants.SCOPE_VALUES);\n+        dataMap.add(USERNAME, configuration.userName);\n+        dataMap.add(PASSWORD, configuration.password);\n+        req.content(new StringContentProvider(CONTENT_TYPE_URL_ENCODED,\n+                UrlEncoded.encode(dataMap, Charset.defaultCharset(), false), Charset.defaultCharset()));\n+        try {\n+            ContentResponse contentResponse = req.timeout(HTTP_TIMEOUT_SEC, TimeUnit.SECONDS).send();\n+            // Status needs to be 302 - Response is stored in Header\n+            if (contentResponse.getStatus() == 302) {\n+                final HttpFields fields = contentResponse.getHeaders();\n+                final HttpField field = fields.getField(HttpHeader.LOCATION);\n+                tokenFromUrl(field.getValue());\n+            } else if (contentResponse.getStatus() == 200) {\n+                final String stringContent = contentResponse.getContentAsString();\n+                if (stringContent != null && !stringContent.isEmpty()) {\n+                    try {\n+                        final AuthResponse authResponse = Converter.getGson().fromJson(stringContent,\n+                                AuthResponse.class);\n+                        if (authResponse != null) {\n+                            token.setToken(authResponse.accessToken);\n+                            token.setType(authResponse.tokenType);\n+                            token.setExpiration(authResponse.expiresIn);\n+                        } else {\n+                            logger.debug(\"not an Authorization response: {}\", stringContent);\n+                        }\n+                    } catch (JsonSyntaxException jse) {\n+                        logger.debug(\"Authorization response unparsable: {}\", stringContent);\n+                    }\n+                } else {\n+                    logger.debug(\"Authorization response has no content\");\n+                }\n+            } else {\n+                logger.debug(\"Authorization status {} reason {}\", contentResponse.getStatus(),\n+                        contentResponse.getReason());\n+            }\n+        } catch (InterruptedException | ExecutionException | TimeoutException e) {\n+            logger.debug(\"Authorization exception: {}\", e.getMessage(), e);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "48af48c82562d006b6f2aa35922270f181c885ed"}, "originalPosition": 294}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5ODI4MDkzMg==", "bodyText": "fixed in weymann#8", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r598280932", "createdAt": "2021-03-21T13:34:49Z", "author": {"login": "ntruchsess"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/ConnectedDriveProxy.java", "diffHunk": "@@ -0,0 +1,314 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bmwconnecteddrive.internal.handler;\n+\n+import static org.openhab.binding.bmwconnecteddrive.internal.utils.HTTPConstants.*;\n+\n+import java.nio.charset.Charset;\n+import java.nio.charset.StandardCharsets;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.client.util.BufferingResponseListener;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.eclipse.jetty.http.HttpField;\n+import org.eclipse.jetty.http.HttpFields;\n+import org.eclipse.jetty.http.HttpHeader;\n+import org.eclipse.jetty.util.MultiMap;\n+import org.eclipse.jetty.util.UrlEncoded;\n+import org.openhab.binding.bmwconnecteddrive.internal.ConnectedDriveConfiguration;\n+import org.openhab.binding.bmwconnecteddrive.internal.VehicleConfiguration;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.NetworkError;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.auth.AuthResponse;\n+import org.openhab.binding.bmwconnecteddrive.internal.handler.simulation.Injector;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.BimmerConstants;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Constants;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Converter;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ImageProperties;\n+import org.openhab.core.io.net.http.HttpClientFactory;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonSyntaxException;\n+\n+/**\n+ * The {@link ConnectedDriveProxy} This class holds the important constants for the BMW Connected Drive Authorization.\n+ * They\n+ * are taken from the Bimmercode from github {@link https://github.com/bimmerconnected/bimmer_connected}\n+ * File defining these constants\n+ * {@link https://github.com/bimmerconnected/bimmer_connected/blob/master/bimmer_connected/account.py}\n+ * https://customer.bmwgroup.com/one/app/oauth.js\n+ *\n+ * @author Bernd Weymann - Initial contribution\n+ * @author Norbert Truchsess - edit & send of charge profile\n+ */\n+@NonNullByDefault\n+public class ConnectedDriveProxy {\n+    private final Logger logger = LoggerFactory.getLogger(ConnectedDriveProxy.class);\n+    private final Token token = new Token();\n+    private final HttpClient httpClient;\n+    private final HttpClient authHttpClient;\n+    private final String legacyAuthUri;\n+    private final ConnectedDriveConfiguration configuration;\n+\n+    /**\n+     * URLs taken from https://github.com/bimmerconnected/bimmer_connected/blob/master/bimmer_connected/const.py\n+     */\n+    final String baseUrl;\n+    final String vehicleUrl;\n+    final String legacyUrl;\n+    final String vehicleStatusAPI = \"/status\";\n+    final String lastTripAPI = \"/statistics/lastTrip\";\n+    final String allTripsAPI = \"/statistics/allTrips\";\n+    final String chargeAPI = \"/chargingprofile\";\n+    final String destinationAPI = \"/destinations\";\n+    final String imageAPI = \"/image\";\n+    final String rangeMapAPI = \"/rangemap\";\n+    final String serviceExecutionAPI = \"/executeService\";\n+    final String serviceExecutionStateAPI = \"/serviceExecutionStatus\";\n+\n+    public ConnectedDriveProxy(HttpClientFactory httpClientFactory, ConnectedDriveConfiguration config) {\n+        httpClient = httpClientFactory.getCommonHttpClient();\n+        authHttpClient = httpClientFactory.createHttpClient(AUTH_HTTP_CLIENT_NAME);\n+        authHttpClient.setFollowRedirects(false);\n+        try {\n+            authHttpClient.start();\n+        } catch (Exception e) {\n+            logger.warn(\"Auth Http Client cannot be started\");\n+        }\n+        configuration = config;\n+\n+        final StringBuilder legacyAuth = new StringBuilder();\n+        legacyAuth.append(\"https://\");\n+        legacyAuth.append(BimmerConstants.AUTH_SERVER_MAP.get(configuration.region));\n+        legacyAuth.append(BimmerConstants.OAUTH_ENDPOINT);\n+        legacyAuthUri = legacyAuth.toString();\n+        vehicleUrl = \"https://\" + getRegionServer() + \"/webapi/v1/user/vehicles\";\n+        baseUrl = vehicleUrl + \"/\";\n+        legacyUrl = \"https://\" + getRegionServer() + \"/api/vehicle/dynamic/v1/\";\n+    }\n+\n+    private synchronized void call(final String url, final boolean post, final @Nullable MultiMap<String> params,\n+            final ResponseCallback callback) {\n+        // only executed in \"simulation mode\"\n+        // SimulationTest.testSimulationOff() assures Injector is off when releasing\n+        if (Injector.isActive()) {\n+            if (url.equals(baseUrl)) {\n+                ((StringResponseCallback) callback).onResponse(Injector.getDiscovery());\n+            } else if (url.endsWith(vehicleStatusAPI)) {\n+                ((StringResponseCallback) callback).onResponse(Injector.getStatus());\n+            } else {\n+                logger.info(\"Simulation of {} not supported\", url);\n+            }\n+            return;\n+        }\n+        final Request req;\n+        final String encoded = params == null || params.isEmpty() ? null\n+                : UrlEncoded.encode(params, Charset.defaultCharset(), false);\n+        final String completeUrl;\n+\n+        if (post) {\n+            completeUrl = url;\n+            req = httpClient.POST(url);\n+            if (encoded != null) {\n+                req.content(new StringContentProvider(CONTENT_TYPE_URL_ENCODED, encoded, Charset.defaultCharset()));\n+            }\n+        } else {\n+            completeUrl = encoded == null ? url : url + Constants.QUESTION + encoded;\n+            req = httpClient.newRequest(completeUrl);\n+        }\n+        req.header(HttpHeader.AUTHORIZATION, getToken().getBearerToken());\n+        req.header(HttpHeader.REFERER, BimmerConstants.REFERER_URL);\n+\n+        req.timeout(HTTP_TIMEOUT_SEC, TimeUnit.SECONDS).send(new BufferingResponseListener() {\n+            @NonNullByDefault({})\n+            @Override\n+            public void onComplete(org.eclipse.jetty.client.api.Result result) {\n+                if (result.getResponse().getStatus() != 200) {\n+                    NetworkError error = new NetworkError();\n+                    error.url = completeUrl;\n+                    error.status = result.getResponse().getStatus();\n+                    if (result.getResponse().getReason() != null) {\n+                        error.reason = result.getResponse().getReason();\n+                    } else {\n+                        error.reason = result.getFailure().getMessage();\n+                    }\n+                    error.params = result.getRequest().getParams().toString();\n+                    logger.debug(\"HTTP Error {}\", error.toString());\n+                    callback.onError(error);\n+                } else {\n+                    if (callback instanceof StringResponseCallback) {\n+                        ((StringResponseCallback) callback).onResponse(getContentAsString());\n+                    } else {\n+                        ((ByteResponseCallback) callback).onResponse(getContent());\n+                    }\n+                }\n+            }\n+        });\n+    }\n+\n+    public void get(String url, @Nullable MultiMap<String> params, ResponseCallback callback) {\n+        call(url, false, params, callback);\n+    }\n+\n+    public void post(String url, @Nullable MultiMap<String> params, ResponseCallback callback) {\n+        call(url, true, params, callback);\n+    }\n+\n+    public void requestVehicles(StringResponseCallback callback) {\n+        get(vehicleUrl, null, callback);\n+    }\n+\n+    public void requestVehcileStatus(VehicleConfiguration config, StringResponseCallback callback) {\n+        get(baseUrl + config.vin + vehicleStatusAPI, null, callback);\n+    }\n+\n+    public void requestLegacyVehcileStatus(VehicleConfiguration config, StringResponseCallback callback) {\n+        // see https://github.com/jupe76/bmwcdapi/search?q=dynamic%2Fv1\n+        get(legacyUrl + config.vin + \"?offset=-60\", null, callback);\n+    }\n+\n+    public void requestLastTrip(VehicleConfiguration config, StringResponseCallback callback) {\n+        get(baseUrl + config.vin + lastTripAPI, null, callback);\n+    }\n+\n+    public void requestAllTrips(VehicleConfiguration config, StringResponseCallback callback) {\n+        get(baseUrl + config.vin + allTripsAPI, null, callback);\n+    }\n+\n+    public void requestChargingProfile(VehicleConfiguration config, StringResponseCallback callback) {\n+        get(baseUrl + config.vin + chargeAPI, null, callback);\n+    }\n+\n+    public void requestDestinations(VehicleConfiguration config, StringResponseCallback callback) {\n+        get(baseUrl + config.vin + destinationAPI, null, callback);\n+    }\n+\n+    public void requestRangeMap(VehicleConfiguration config, @Nullable MultiMap<String> params,\n+            StringResponseCallback callback) {\n+        get(baseUrl + config.vin + rangeMapAPI, params, callback);\n+    }\n+\n+    public void requestImage(VehicleConfiguration config, ImageProperties props, ByteResponseCallback callback) {\n+        final String localImageUrl = baseUrl + config.vin + imageAPI;\n+        final MultiMap<String> dataMap = new MultiMap<String>();\n+        dataMap.add(\"width\", Integer.toString(props.size));\n+        dataMap.add(\"height\", Integer.toString(props.size));\n+        dataMap.add(\"view\", props.viewport);\n+        get(localImageUrl, dataMap, callback);\n+    }\n+\n+    private String getRegionServer() {\n+        final String retVal = BimmerConstants.SERVER_MAP.get(configuration.region);\n+        return retVal == null ? Constants.INVALID : retVal;\n+    }\n+\n+    RemoteServiceHandler getRemoteServiceHandler(VehicleHandler vehicleHandler) {\n+        return new RemoteServiceHandler(vehicleHandler, this);\n+    }\n+\n+    // Token handling\n+\n+    /**\n+     * Gets new token if old one is expired or invalid. In case of error the token remains.\n+     * So if token refresh fails the corresponding requests will also fail and update the\n+     * Thing status accordingly.\n+     *\n+     * @return token\n+     */\n+    public Token getToken() {\n+        if (token.isExpired() || !token.isValid()) {\n+            updateToken();\n+        }\n+        return token;\n+    }\n+\n+    /**\n+     * Authorize at BMW Connected Drive Portal and get Token\n+     *\n+     * @return\n+     */\n+    private synchronized void updateToken() {\n+        final Request req = authHttpClient.POST(legacyAuthUri);\n+\n+        req.header(HttpHeader.CONNECTION, KEEP_ALIVE);\n+        req.header(HttpHeader.HOST, BimmerConstants.SERVER_MAP.get(configuration.region));\n+        req.header(HttpHeader.AUTHORIZATION, BimmerConstants.AUTHORIZATION_VALUE_MAP.get(configuration.region));\n+        req.header(CREDENTIALS, BimmerConstants.CREDENTIAL_VALUES);\n+        req.header(HttpHeader.REFERER, BimmerConstants.REFERER_URL);\n+\n+        final MultiMap<String> dataMap = new MultiMap<String>();\n+        dataMap.add(\"grant_type\", \"password\");\n+        dataMap.add(SCOPE, BimmerConstants.SCOPE_VALUES);\n+        dataMap.add(USERNAME, configuration.userName);\n+        dataMap.add(PASSWORD, configuration.password);\n+        req.content(new StringContentProvider(CONTENT_TYPE_URL_ENCODED,\n+                UrlEncoded.encode(dataMap, Charset.defaultCharset(), false), Charset.defaultCharset()));\n+        try {\n+            ContentResponse contentResponse = req.timeout(HTTP_TIMEOUT_SEC, TimeUnit.SECONDS).send();\n+            // Status needs to be 302 - Response is stored in Header\n+            if (contentResponse.getStatus() == 302) {\n+                final HttpFields fields = contentResponse.getHeaders();\n+                final HttpField field = fields.getField(HttpHeader.LOCATION);\n+                tokenFromUrl(field.getValue());\n+            } else if (contentResponse.getStatus() == 200) {\n+                final String stringContent = contentResponse.getContentAsString();\n+                if (stringContent != null && !stringContent.isEmpty()) {\n+                    try {\n+                        final AuthResponse authResponse = Converter.getGson().fromJson(stringContent,\n+                                AuthResponse.class);\n+                        if (authResponse != null) {\n+                            token.setToken(authResponse.accessToken);\n+                            token.setType(authResponse.tokenType);\n+                            token.setExpiration(authResponse.expiresIn);\n+                        } else {\n+                            logger.debug(\"not an Authorization response: {}\", stringContent);\n+                        }\n+                    } catch (JsonSyntaxException jse) {\n+                        logger.debug(\"Authorization response unparsable: {}\", stringContent);\n+                    }\n+                } else {\n+                    logger.debug(\"Authorization response has no content\");\n+                }\n+            } else {\n+                logger.debug(\"Authorization status {} reason {}\", contentResponse.getStatus(),\n+                        contentResponse.getReason());\n+            }\n+        } catch (InterruptedException | ExecutionException | TimeoutException e) {\n+            logger.debug(\"Authorization exception: {}\", e.getMessage(), e);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5Nzg5NDQ3NA=="}, "originalCommit": {"oid": "48af48c82562d006b6f2aa35922270f181c885ed"}, "originalPosition": 294}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzc3NjY0Mjk0OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/RemoteServiceHandler.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0xOVQxODozNToyMVrOI6MyjQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0yM1QwMDowODoxMVrOI7ZlpQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5Nzg5Nzg2OQ==", "bodyText": "Please move all fields to the top of the class.", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r597897869", "createdAt": "2021-03-19T18:35:21Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/RemoteServiceHandler.java", "diffHunk": "@@ -0,0 +1,186 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bmwconnecteddrive.internal.handler;\n+\n+import static org.openhab.binding.bmwconnecteddrive.internal.ConnectedDriveConstants.*;\n+\n+import java.util.Optional;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.util.MultiMap;\n+import org.openhab.binding.bmwconnecteddrive.internal.VehicleConfiguration;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.NetworkError;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.remote.ExecutionStatusContainer;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Constants;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Converter;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.HTTPConstants;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonSyntaxException;\n+\n+/**\n+ * The {@link RemoteServiceHandler} handles executions of remote services towards your Vehicle\n+ *\n+ * @see https://github.com/bimmerconnected/bimmer_connected/blob/master/bimmer_connected/remote_services.py\n+ *\n+ * @author Bernd Weymann - Initial contribution\n+ * @author Norbert Truchsess - edit & send of charge profile\n+ */\n+@NonNullByDefault\n+public class RemoteServiceHandler implements StringResponseCallback {\n+    private final Logger logger = LoggerFactory.getLogger(RemoteServiceHandler.class);\n+\n+    // after 60 retries the state update will give up\n+    private static final String SERVICE_TYPE = \"serviceType\";\n+    private static final String DATA = \"data\";\n+    private static final int GIVEUP_COUNTER = 6;\n+    private static final int STATE_UPDATE_SEC = HTTPConstants.HTTP_TIMEOUT_SEC + 1; // regular timeout + 1sec\n+    private int counter = 0;\n+\n+    public enum ExecutionState {\n+        READY,\n+        INITIATED,\n+        PENDING,\n+        DELIVERED,\n+        EXECUTED,\n+        ERROR,\n+    }\n+\n+    public enum RemoteService {\n+        LIGHT_FLASH(REMOTE_SERVICE_LIGHT_FLASH, \"Flash Lights\"),\n+        VEHICLE_FINDER(REMOTE_SERVICE_VEHICLE_FINDER, \"Vehicle Finder\"),\n+        DOOR_LOCK(REMOTE_SERVICE_DOOR_LOCK, \"Door Lock\"),\n+        DOOR_UNLOCK(REMOTE_SERVICE_DOOR_UNLOCK, \"Door Unlock\"),\n+        HORN_BLOW(REMOTE_SERVICE_HORN, \"Horn Blow\"),\n+        CLIMATE_NOW(REMOTE_SERVICE_AIR_CONDITIONING, \"Climate Control\"),\n+        CHARGE_NOW(REMOTE_SERVICE_CHARGE_NOW, \"Start Charging\"),\n+        CHARGING_CONTROL(REMOTE_SERVICE_CHARGING_CONTROL, \"Send Charging Profile\");\n+\n+        private final String command;\n+        private final String label;\n+\n+        RemoteService(final String command, final String label) {\n+            this.command = command;\n+            this.label = label;\n+        }\n+\n+        public String getCommand() {\n+            return command;\n+        }\n+\n+        public String getLabel() {\n+            return label;\n+        }\n+    }\n+\n+    private final ConnectedDriveProxy proxy;\n+    private final VehicleHandler handler;\n+    private Optional<String> serviceExecuting = Optional.empty();\n+\n+    private final String serviceExecutionAPI;\n+    private final String serviceExecutionStateAPI;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "48af48c82562d006b6f2aa35922270f181c885ed"}, "originalPosition": 94}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5OTE1NjEzMw==", "bodyText": "done", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r599156133", "createdAt": "2021-03-23T00:08:11Z", "author": {"login": "weymann"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/RemoteServiceHandler.java", "diffHunk": "@@ -0,0 +1,186 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bmwconnecteddrive.internal.handler;\n+\n+import static org.openhab.binding.bmwconnecteddrive.internal.ConnectedDriveConstants.*;\n+\n+import java.util.Optional;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.util.MultiMap;\n+import org.openhab.binding.bmwconnecteddrive.internal.VehicleConfiguration;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.NetworkError;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.remote.ExecutionStatusContainer;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Constants;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Converter;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.HTTPConstants;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonSyntaxException;\n+\n+/**\n+ * The {@link RemoteServiceHandler} handles executions of remote services towards your Vehicle\n+ *\n+ * @see https://github.com/bimmerconnected/bimmer_connected/blob/master/bimmer_connected/remote_services.py\n+ *\n+ * @author Bernd Weymann - Initial contribution\n+ * @author Norbert Truchsess - edit & send of charge profile\n+ */\n+@NonNullByDefault\n+public class RemoteServiceHandler implements StringResponseCallback {\n+    private final Logger logger = LoggerFactory.getLogger(RemoteServiceHandler.class);\n+\n+    // after 60 retries the state update will give up\n+    private static final String SERVICE_TYPE = \"serviceType\";\n+    private static final String DATA = \"data\";\n+    private static final int GIVEUP_COUNTER = 6;\n+    private static final int STATE_UPDATE_SEC = HTTPConstants.HTTP_TIMEOUT_SEC + 1; // regular timeout + 1sec\n+    private int counter = 0;\n+\n+    public enum ExecutionState {\n+        READY,\n+        INITIATED,\n+        PENDING,\n+        DELIVERED,\n+        EXECUTED,\n+        ERROR,\n+    }\n+\n+    public enum RemoteService {\n+        LIGHT_FLASH(REMOTE_SERVICE_LIGHT_FLASH, \"Flash Lights\"),\n+        VEHICLE_FINDER(REMOTE_SERVICE_VEHICLE_FINDER, \"Vehicle Finder\"),\n+        DOOR_LOCK(REMOTE_SERVICE_DOOR_LOCK, \"Door Lock\"),\n+        DOOR_UNLOCK(REMOTE_SERVICE_DOOR_UNLOCK, \"Door Unlock\"),\n+        HORN_BLOW(REMOTE_SERVICE_HORN, \"Horn Blow\"),\n+        CLIMATE_NOW(REMOTE_SERVICE_AIR_CONDITIONING, \"Climate Control\"),\n+        CHARGE_NOW(REMOTE_SERVICE_CHARGE_NOW, \"Start Charging\"),\n+        CHARGING_CONTROL(REMOTE_SERVICE_CHARGING_CONTROL, \"Send Charging Profile\");\n+\n+        private final String command;\n+        private final String label;\n+\n+        RemoteService(final String command, final String label) {\n+            this.command = command;\n+            this.label = label;\n+        }\n+\n+        public String getCommand() {\n+            return command;\n+        }\n+\n+        public String getLabel() {\n+            return label;\n+        }\n+    }\n+\n+    private final ConnectedDriveProxy proxy;\n+    private final VehicleHandler handler;\n+    private Optional<String> serviceExecuting = Optional.empty();\n+\n+    private final String serviceExecutionAPI;\n+    private final String serviceExecutionStateAPI;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5Nzg5Nzg2OQ=="}, "originalCommit": {"oid": "48af48c82562d006b6f2aa35922270f181c885ed"}, "originalPosition": 94}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzc3NjY0ODQ0OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/RemoteServiceHandler.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0xOVQxODozNjo1MVrOI6M17g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0yN1QyMToyNzo0MFrOI-3o3w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5Nzg5ODczNA==", "bodyText": "You could throw an exception to finish the program flow quickly and set the Thing offline.", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r597898734", "createdAt": "2021-03-19T18:36:51Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/RemoteServiceHandler.java", "diffHunk": "@@ -0,0 +1,186 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bmwconnecteddrive.internal.handler;\n+\n+import static org.openhab.binding.bmwconnecteddrive.internal.ConnectedDriveConstants.*;\n+\n+import java.util.Optional;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.util.MultiMap;\n+import org.openhab.binding.bmwconnecteddrive.internal.VehicleConfiguration;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.NetworkError;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.remote.ExecutionStatusContainer;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Constants;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Converter;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.HTTPConstants;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonSyntaxException;\n+\n+/**\n+ * The {@link RemoteServiceHandler} handles executions of remote services towards your Vehicle\n+ *\n+ * @see https://github.com/bimmerconnected/bimmer_connected/blob/master/bimmer_connected/remote_services.py\n+ *\n+ * @author Bernd Weymann - Initial contribution\n+ * @author Norbert Truchsess - edit & send of charge profile\n+ */\n+@NonNullByDefault\n+public class RemoteServiceHandler implements StringResponseCallback {\n+    private final Logger logger = LoggerFactory.getLogger(RemoteServiceHandler.class);\n+\n+    // after 60 retries the state update will give up\n+    private static final String SERVICE_TYPE = \"serviceType\";\n+    private static final String DATA = \"data\";\n+    private static final int GIVEUP_COUNTER = 6;\n+    private static final int STATE_UPDATE_SEC = HTTPConstants.HTTP_TIMEOUT_SEC + 1; // regular timeout + 1sec\n+    private int counter = 0;\n+\n+    public enum ExecutionState {\n+        READY,\n+        INITIATED,\n+        PENDING,\n+        DELIVERED,\n+        EXECUTED,\n+        ERROR,\n+    }\n+\n+    public enum RemoteService {\n+        LIGHT_FLASH(REMOTE_SERVICE_LIGHT_FLASH, \"Flash Lights\"),\n+        VEHICLE_FINDER(REMOTE_SERVICE_VEHICLE_FINDER, \"Vehicle Finder\"),\n+        DOOR_LOCK(REMOTE_SERVICE_DOOR_LOCK, \"Door Lock\"),\n+        DOOR_UNLOCK(REMOTE_SERVICE_DOOR_UNLOCK, \"Door Unlock\"),\n+        HORN_BLOW(REMOTE_SERVICE_HORN, \"Horn Blow\"),\n+        CLIMATE_NOW(REMOTE_SERVICE_AIR_CONDITIONING, \"Climate Control\"),\n+        CHARGE_NOW(REMOTE_SERVICE_CHARGE_NOW, \"Start Charging\"),\n+        CHARGING_CONTROL(REMOTE_SERVICE_CHARGING_CONTROL, \"Send Charging Profile\");\n+\n+        private final String command;\n+        private final String label;\n+\n+        RemoteService(final String command, final String label) {\n+            this.command = command;\n+            this.label = label;\n+        }\n+\n+        public String getCommand() {\n+            return command;\n+        }\n+\n+        public String getLabel() {\n+            return label;\n+        }\n+    }\n+\n+    private final ConnectedDriveProxy proxy;\n+    private final VehicleHandler handler;\n+    private Optional<String> serviceExecuting = Optional.empty();\n+\n+    private final String serviceExecutionAPI;\n+    private final String serviceExecutionStateAPI;\n+\n+    public RemoteServiceHandler(VehicleHandler vehicleHandler, ConnectedDriveProxy connectedDriveProxy) {\n+        handler = vehicleHandler;\n+        proxy = connectedDriveProxy;\n+        if (handler.getConfiguration().isPresent()) {\n+            final VehicleConfiguration config = handler.getConfiguration().get();\n+            serviceExecutionAPI = proxy.baseUrl + config.vin + proxy.serviceExecutionAPI;\n+            serviceExecutionStateAPI = proxy.baseUrl + config.vin + proxy.serviceExecutionStateAPI;\n+        } else {\n+            serviceExecutionAPI = Constants.INVALID;\n+            serviceExecutionStateAPI = Constants.INVALID;\n+            logger.warn(\"No configuration for VehicleHandler available\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "48af48c82562d006b6f2aa35922270f181c885ed"}, "originalPosition": 106}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMjc5NDIwNw==", "bodyText": "Right, again after looking into this I'm not pleased with this error handling so late. I introduced now checkConfiguration in the BridgeHandler and set it to OFFLINE immediately if config doesn't fit. With this the check in RemoteServiceHandler isn't necessary anymore.", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r602794207", "createdAt": "2021-03-27T21:27:40Z", "author": {"login": "weymann"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/RemoteServiceHandler.java", "diffHunk": "@@ -0,0 +1,186 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bmwconnecteddrive.internal.handler;\n+\n+import static org.openhab.binding.bmwconnecteddrive.internal.ConnectedDriveConstants.*;\n+\n+import java.util.Optional;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.util.MultiMap;\n+import org.openhab.binding.bmwconnecteddrive.internal.VehicleConfiguration;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.NetworkError;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.remote.ExecutionStatusContainer;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Constants;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Converter;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.HTTPConstants;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonSyntaxException;\n+\n+/**\n+ * The {@link RemoteServiceHandler} handles executions of remote services towards your Vehicle\n+ *\n+ * @see https://github.com/bimmerconnected/bimmer_connected/blob/master/bimmer_connected/remote_services.py\n+ *\n+ * @author Bernd Weymann - Initial contribution\n+ * @author Norbert Truchsess - edit & send of charge profile\n+ */\n+@NonNullByDefault\n+public class RemoteServiceHandler implements StringResponseCallback {\n+    private final Logger logger = LoggerFactory.getLogger(RemoteServiceHandler.class);\n+\n+    // after 60 retries the state update will give up\n+    private static final String SERVICE_TYPE = \"serviceType\";\n+    private static final String DATA = \"data\";\n+    private static final int GIVEUP_COUNTER = 6;\n+    private static final int STATE_UPDATE_SEC = HTTPConstants.HTTP_TIMEOUT_SEC + 1; // regular timeout + 1sec\n+    private int counter = 0;\n+\n+    public enum ExecutionState {\n+        READY,\n+        INITIATED,\n+        PENDING,\n+        DELIVERED,\n+        EXECUTED,\n+        ERROR,\n+    }\n+\n+    public enum RemoteService {\n+        LIGHT_FLASH(REMOTE_SERVICE_LIGHT_FLASH, \"Flash Lights\"),\n+        VEHICLE_FINDER(REMOTE_SERVICE_VEHICLE_FINDER, \"Vehicle Finder\"),\n+        DOOR_LOCK(REMOTE_SERVICE_DOOR_LOCK, \"Door Lock\"),\n+        DOOR_UNLOCK(REMOTE_SERVICE_DOOR_UNLOCK, \"Door Unlock\"),\n+        HORN_BLOW(REMOTE_SERVICE_HORN, \"Horn Blow\"),\n+        CLIMATE_NOW(REMOTE_SERVICE_AIR_CONDITIONING, \"Climate Control\"),\n+        CHARGE_NOW(REMOTE_SERVICE_CHARGE_NOW, \"Start Charging\"),\n+        CHARGING_CONTROL(REMOTE_SERVICE_CHARGING_CONTROL, \"Send Charging Profile\");\n+\n+        private final String command;\n+        private final String label;\n+\n+        RemoteService(final String command, final String label) {\n+            this.command = command;\n+            this.label = label;\n+        }\n+\n+        public String getCommand() {\n+            return command;\n+        }\n+\n+        public String getLabel() {\n+            return label;\n+        }\n+    }\n+\n+    private final ConnectedDriveProxy proxy;\n+    private final VehicleHandler handler;\n+    private Optional<String> serviceExecuting = Optional.empty();\n+\n+    private final String serviceExecutionAPI;\n+    private final String serviceExecutionStateAPI;\n+\n+    public RemoteServiceHandler(VehicleHandler vehicleHandler, ConnectedDriveProxy connectedDriveProxy) {\n+        handler = vehicleHandler;\n+        proxy = connectedDriveProxy;\n+        if (handler.getConfiguration().isPresent()) {\n+            final VehicleConfiguration config = handler.getConfiguration().get();\n+            serviceExecutionAPI = proxy.baseUrl + config.vin + proxy.serviceExecutionAPI;\n+            serviceExecutionStateAPI = proxy.baseUrl + config.vin + proxy.serviceExecutionStateAPI;\n+        } else {\n+            serviceExecutionAPI = Constants.INVALID;\n+            serviceExecutionStateAPI = Constants.INVALID;\n+            logger.warn(\"No configuration for VehicleHandler available\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5Nzg5ODczNA=="}, "originalCommit": {"oid": "48af48c82562d006b6f2aa35922270f181c885ed"}, "originalPosition": 106}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzc3NjY1Mjk3OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/RemoteServiceHandler.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0xOVQxODozODowMVrOI6M4og==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0yM1QwMDoxMDoxM1rOI7ZovQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5Nzg5OTQyNg==", "bodyText": "Can you fix the line break?", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r597899426", "createdAt": "2021-03-19T18:38:01Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/RemoteServiceHandler.java", "diffHunk": "@@ -0,0 +1,186 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bmwconnecteddrive.internal.handler;\n+\n+import static org.openhab.binding.bmwconnecteddrive.internal.ConnectedDriveConstants.*;\n+\n+import java.util.Optional;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.util.MultiMap;\n+import org.openhab.binding.bmwconnecteddrive.internal.VehicleConfiguration;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.NetworkError;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.remote.ExecutionStatusContainer;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Constants;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Converter;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.HTTPConstants;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonSyntaxException;\n+\n+/**\n+ * The {@link RemoteServiceHandler} handles executions of remote services towards your Vehicle\n+ *\n+ * @see https://github.com/bimmerconnected/bimmer_connected/blob/master/bimmer_connected/remote_services.py\n+ *\n+ * @author Bernd Weymann - Initial contribution\n+ * @author Norbert Truchsess - edit & send of charge profile\n+ */\n+@NonNullByDefault\n+public class RemoteServiceHandler implements StringResponseCallback {\n+    private final Logger logger = LoggerFactory.getLogger(RemoteServiceHandler.class);\n+\n+    // after 60 retries the state update will give up\n+    private static final String SERVICE_TYPE = \"serviceType\";\n+    private static final String DATA = \"data\";\n+    private static final int GIVEUP_COUNTER = 6;\n+    private static final int STATE_UPDATE_SEC = HTTPConstants.HTTP_TIMEOUT_SEC + 1; // regular timeout + 1sec\n+    private int counter = 0;\n+\n+    public enum ExecutionState {\n+        READY,\n+        INITIATED,\n+        PENDING,\n+        DELIVERED,\n+        EXECUTED,\n+        ERROR,\n+    }\n+\n+    public enum RemoteService {\n+        LIGHT_FLASH(REMOTE_SERVICE_LIGHT_FLASH, \"Flash Lights\"),\n+        VEHICLE_FINDER(REMOTE_SERVICE_VEHICLE_FINDER, \"Vehicle Finder\"),\n+        DOOR_LOCK(REMOTE_SERVICE_DOOR_LOCK, \"Door Lock\"),\n+        DOOR_UNLOCK(REMOTE_SERVICE_DOOR_UNLOCK, \"Door Unlock\"),\n+        HORN_BLOW(REMOTE_SERVICE_HORN, \"Horn Blow\"),\n+        CLIMATE_NOW(REMOTE_SERVICE_AIR_CONDITIONING, \"Climate Control\"),\n+        CHARGE_NOW(REMOTE_SERVICE_CHARGE_NOW, \"Start Charging\"),\n+        CHARGING_CONTROL(REMOTE_SERVICE_CHARGING_CONTROL, \"Send Charging Profile\");\n+\n+        private final String command;\n+        private final String label;\n+\n+        RemoteService(final String command, final String label) {\n+            this.command = command;\n+            this.label = label;\n+        }\n+\n+        public String getCommand() {\n+            return command;\n+        }\n+\n+        public String getLabel() {\n+            return label;\n+        }\n+    }\n+\n+    private final ConnectedDriveProxy proxy;\n+    private final VehicleHandler handler;\n+    private Optional<String> serviceExecuting = Optional.empty();\n+\n+    private final String serviceExecutionAPI;\n+    private final String serviceExecutionStateAPI;\n+\n+    public RemoteServiceHandler(VehicleHandler vehicleHandler, ConnectedDriveProxy connectedDriveProxy) {\n+        handler = vehicleHandler;\n+        proxy = connectedDriveProxy;\n+        if (handler.getConfiguration().isPresent()) {\n+            final VehicleConfiguration config = handler.getConfiguration().get();\n+            serviceExecutionAPI = proxy.baseUrl + config.vin + proxy.serviceExecutionAPI;\n+            serviceExecutionStateAPI = proxy.baseUrl + config.vin + proxy.serviceExecutionStateAPI;\n+        } else {\n+            serviceExecutionAPI = Constants.INVALID;\n+            serviceExecutionStateAPI = Constants.INVALID;\n+            logger.warn(\"No configuration for VehicleHandler available\");\n+        }\n+    }\n+\n+    boolean execute(RemoteService service, String... data) {\n+        synchronized (this) {\n+            if (serviceExecuting.isPresent()) {\n+                // only one service executing\n+                return false;\n+            }\n+            serviceExecuting = Optional.of(service.name());\n+        }\n+        final MultiMap<String> dataMap = new MultiMap<String>();\n+        dataMap.add(SERVICE_TYPE, service.name());\n+        if (data.length > 0) {\n+            dataMap.add(DATA, data[0]);\n+        }\n+        proxy.post(serviceExecutionAPI, dataMap, this);\n+        return true;\n+    }\n+\n+    public void getState() {\n+        synchronized (this) {\n+            serviceExecuting.ifPresentOrElse(service -> {\n+                if (counter >= GIVEUP_COUNTER) {\n+                    logger.warn(\"Giving up updating state for {} after {} times\", service, GIVEUP_COUNTER);\n+                    reset();\n+                    // immediately refresh data\n+                    handler.getData();\n+                }\n+                counter++;\n+                final MultiMap<String> dataMap = new MultiMap<String>();\n+                dataMap.add(SERVICE_TYPE, service);\n+                proxy.get(serviceExecutionStateAPI, dataMap, this);\n+            }, () -> {\n+                logger.warn(\"No Service executed to get state\");\n+            });\n+        }\n+    }\n+\n+    @Override\n+    public void onResponse(@Nullable String result) {\n+        if (result != null) {\n+            try {\n+                ExecutionStatusContainer esc = Converter.getGson().fromJson(result, ExecutionStatusContainer.class);\n+                if (esc != null && esc.executionStatus != null) {\n+                    String status = esc.executionStatus.status;\n+                    synchronized (this) {\n+                        handler.updateRemoteExecutionStatus(serviceExecuting.orElse(null), status);\n+                        if (ExecutionState.EXECUTED.name().equals(status)) {\n+                            // refresh loop ends - update of status handled in the normal refreshInterval. Earlier\n+                            // update\n+                            // doesn't\n+                            // show better results!", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "48af48c82562d006b6f2aa35922270f181c885ed"}, "originalPosition": 159}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5OTE1NjkyNQ==", "bodyText": "Fixed", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r599156925", "createdAt": "2021-03-23T00:10:13Z", "author": {"login": "weymann"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/RemoteServiceHandler.java", "diffHunk": "@@ -0,0 +1,186 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bmwconnecteddrive.internal.handler;\n+\n+import static org.openhab.binding.bmwconnecteddrive.internal.ConnectedDriveConstants.*;\n+\n+import java.util.Optional;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.util.MultiMap;\n+import org.openhab.binding.bmwconnecteddrive.internal.VehicleConfiguration;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.NetworkError;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.remote.ExecutionStatusContainer;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Constants;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Converter;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.HTTPConstants;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonSyntaxException;\n+\n+/**\n+ * The {@link RemoteServiceHandler} handles executions of remote services towards your Vehicle\n+ *\n+ * @see https://github.com/bimmerconnected/bimmer_connected/blob/master/bimmer_connected/remote_services.py\n+ *\n+ * @author Bernd Weymann - Initial contribution\n+ * @author Norbert Truchsess - edit & send of charge profile\n+ */\n+@NonNullByDefault\n+public class RemoteServiceHandler implements StringResponseCallback {\n+    private final Logger logger = LoggerFactory.getLogger(RemoteServiceHandler.class);\n+\n+    // after 60 retries the state update will give up\n+    private static final String SERVICE_TYPE = \"serviceType\";\n+    private static final String DATA = \"data\";\n+    private static final int GIVEUP_COUNTER = 6;\n+    private static final int STATE_UPDATE_SEC = HTTPConstants.HTTP_TIMEOUT_SEC + 1; // regular timeout + 1sec\n+    private int counter = 0;\n+\n+    public enum ExecutionState {\n+        READY,\n+        INITIATED,\n+        PENDING,\n+        DELIVERED,\n+        EXECUTED,\n+        ERROR,\n+    }\n+\n+    public enum RemoteService {\n+        LIGHT_FLASH(REMOTE_SERVICE_LIGHT_FLASH, \"Flash Lights\"),\n+        VEHICLE_FINDER(REMOTE_SERVICE_VEHICLE_FINDER, \"Vehicle Finder\"),\n+        DOOR_LOCK(REMOTE_SERVICE_DOOR_LOCK, \"Door Lock\"),\n+        DOOR_UNLOCK(REMOTE_SERVICE_DOOR_UNLOCK, \"Door Unlock\"),\n+        HORN_BLOW(REMOTE_SERVICE_HORN, \"Horn Blow\"),\n+        CLIMATE_NOW(REMOTE_SERVICE_AIR_CONDITIONING, \"Climate Control\"),\n+        CHARGE_NOW(REMOTE_SERVICE_CHARGE_NOW, \"Start Charging\"),\n+        CHARGING_CONTROL(REMOTE_SERVICE_CHARGING_CONTROL, \"Send Charging Profile\");\n+\n+        private final String command;\n+        private final String label;\n+\n+        RemoteService(final String command, final String label) {\n+            this.command = command;\n+            this.label = label;\n+        }\n+\n+        public String getCommand() {\n+            return command;\n+        }\n+\n+        public String getLabel() {\n+            return label;\n+        }\n+    }\n+\n+    private final ConnectedDriveProxy proxy;\n+    private final VehicleHandler handler;\n+    private Optional<String> serviceExecuting = Optional.empty();\n+\n+    private final String serviceExecutionAPI;\n+    private final String serviceExecutionStateAPI;\n+\n+    public RemoteServiceHandler(VehicleHandler vehicleHandler, ConnectedDriveProxy connectedDriveProxy) {\n+        handler = vehicleHandler;\n+        proxy = connectedDriveProxy;\n+        if (handler.getConfiguration().isPresent()) {\n+            final VehicleConfiguration config = handler.getConfiguration().get();\n+            serviceExecutionAPI = proxy.baseUrl + config.vin + proxy.serviceExecutionAPI;\n+            serviceExecutionStateAPI = proxy.baseUrl + config.vin + proxy.serviceExecutionStateAPI;\n+        } else {\n+            serviceExecutionAPI = Constants.INVALID;\n+            serviceExecutionStateAPI = Constants.INVALID;\n+            logger.warn(\"No configuration for VehicleHandler available\");\n+        }\n+    }\n+\n+    boolean execute(RemoteService service, String... data) {\n+        synchronized (this) {\n+            if (serviceExecuting.isPresent()) {\n+                // only one service executing\n+                return false;\n+            }\n+            serviceExecuting = Optional.of(service.name());\n+        }\n+        final MultiMap<String> dataMap = new MultiMap<String>();\n+        dataMap.add(SERVICE_TYPE, service.name());\n+        if (data.length > 0) {\n+            dataMap.add(DATA, data[0]);\n+        }\n+        proxy.post(serviceExecutionAPI, dataMap, this);\n+        return true;\n+    }\n+\n+    public void getState() {\n+        synchronized (this) {\n+            serviceExecuting.ifPresentOrElse(service -> {\n+                if (counter >= GIVEUP_COUNTER) {\n+                    logger.warn(\"Giving up updating state for {} after {} times\", service, GIVEUP_COUNTER);\n+                    reset();\n+                    // immediately refresh data\n+                    handler.getData();\n+                }\n+                counter++;\n+                final MultiMap<String> dataMap = new MultiMap<String>();\n+                dataMap.add(SERVICE_TYPE, service);\n+                proxy.get(serviceExecutionStateAPI, dataMap, this);\n+            }, () -> {\n+                logger.warn(\"No Service executed to get state\");\n+            });\n+        }\n+    }\n+\n+    @Override\n+    public void onResponse(@Nullable String result) {\n+        if (result != null) {\n+            try {\n+                ExecutionStatusContainer esc = Converter.getGson().fromJson(result, ExecutionStatusContainer.class);\n+                if (esc != null && esc.executionStatus != null) {\n+                    String status = esc.executionStatus.status;\n+                    synchronized (this) {\n+                        handler.updateRemoteExecutionStatus(serviceExecuting.orElse(null), status);\n+                        if (ExecutionState.EXECUTED.name().equals(status)) {\n+                            // refresh loop ends - update of status handled in the normal refreshInterval. Earlier\n+                            // update\n+                            // doesn't\n+                            // show better results!", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5Nzg5OTQyNg=="}, "originalCommit": {"oid": "48af48c82562d006b6f2aa35922270f181c885ed"}, "originalPosition": 159}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzc3NjY1Njk2OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/RemoteServiceHandler.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0xOVQxODozOTowOVrOI6M7Lw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0yMVQxNToxMzo0M1rOI6k-ZQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5NzkwMDA3OQ==", "bodyText": "This should be cancelled if the handler is disposed.", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r597900079", "createdAt": "2021-03-19T18:39:09Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/RemoteServiceHandler.java", "diffHunk": "@@ -0,0 +1,186 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bmwconnecteddrive.internal.handler;\n+\n+import static org.openhab.binding.bmwconnecteddrive.internal.ConnectedDriveConstants.*;\n+\n+import java.util.Optional;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.util.MultiMap;\n+import org.openhab.binding.bmwconnecteddrive.internal.VehicleConfiguration;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.NetworkError;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.remote.ExecutionStatusContainer;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Constants;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Converter;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.HTTPConstants;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonSyntaxException;\n+\n+/**\n+ * The {@link RemoteServiceHandler} handles executions of remote services towards your Vehicle\n+ *\n+ * @see https://github.com/bimmerconnected/bimmer_connected/blob/master/bimmer_connected/remote_services.py\n+ *\n+ * @author Bernd Weymann - Initial contribution\n+ * @author Norbert Truchsess - edit & send of charge profile\n+ */\n+@NonNullByDefault\n+public class RemoteServiceHandler implements StringResponseCallback {\n+    private final Logger logger = LoggerFactory.getLogger(RemoteServiceHandler.class);\n+\n+    // after 60 retries the state update will give up\n+    private static final String SERVICE_TYPE = \"serviceType\";\n+    private static final String DATA = \"data\";\n+    private static final int GIVEUP_COUNTER = 6;\n+    private static final int STATE_UPDATE_SEC = HTTPConstants.HTTP_TIMEOUT_SEC + 1; // regular timeout + 1sec\n+    private int counter = 0;\n+\n+    public enum ExecutionState {\n+        READY,\n+        INITIATED,\n+        PENDING,\n+        DELIVERED,\n+        EXECUTED,\n+        ERROR,\n+    }\n+\n+    public enum RemoteService {\n+        LIGHT_FLASH(REMOTE_SERVICE_LIGHT_FLASH, \"Flash Lights\"),\n+        VEHICLE_FINDER(REMOTE_SERVICE_VEHICLE_FINDER, \"Vehicle Finder\"),\n+        DOOR_LOCK(REMOTE_SERVICE_DOOR_LOCK, \"Door Lock\"),\n+        DOOR_UNLOCK(REMOTE_SERVICE_DOOR_UNLOCK, \"Door Unlock\"),\n+        HORN_BLOW(REMOTE_SERVICE_HORN, \"Horn Blow\"),\n+        CLIMATE_NOW(REMOTE_SERVICE_AIR_CONDITIONING, \"Climate Control\"),\n+        CHARGE_NOW(REMOTE_SERVICE_CHARGE_NOW, \"Start Charging\"),\n+        CHARGING_CONTROL(REMOTE_SERVICE_CHARGING_CONTROL, \"Send Charging Profile\");\n+\n+        private final String command;\n+        private final String label;\n+\n+        RemoteService(final String command, final String label) {\n+            this.command = command;\n+            this.label = label;\n+        }\n+\n+        public String getCommand() {\n+            return command;\n+        }\n+\n+        public String getLabel() {\n+            return label;\n+        }\n+    }\n+\n+    private final ConnectedDriveProxy proxy;\n+    private final VehicleHandler handler;\n+    private Optional<String> serviceExecuting = Optional.empty();\n+\n+    private final String serviceExecutionAPI;\n+    private final String serviceExecutionStateAPI;\n+\n+    public RemoteServiceHandler(VehicleHandler vehicleHandler, ConnectedDriveProxy connectedDriveProxy) {\n+        handler = vehicleHandler;\n+        proxy = connectedDriveProxy;\n+        if (handler.getConfiguration().isPresent()) {\n+            final VehicleConfiguration config = handler.getConfiguration().get();\n+            serviceExecutionAPI = proxy.baseUrl + config.vin + proxy.serviceExecutionAPI;\n+            serviceExecutionStateAPI = proxy.baseUrl + config.vin + proxy.serviceExecutionStateAPI;\n+        } else {\n+            serviceExecutionAPI = Constants.INVALID;\n+            serviceExecutionStateAPI = Constants.INVALID;\n+            logger.warn(\"No configuration for VehicleHandler available\");\n+        }\n+    }\n+\n+    boolean execute(RemoteService service, String... data) {\n+        synchronized (this) {\n+            if (serviceExecuting.isPresent()) {\n+                // only one service executing\n+                return false;\n+            }\n+            serviceExecuting = Optional.of(service.name());\n+        }\n+        final MultiMap<String> dataMap = new MultiMap<String>();\n+        dataMap.add(SERVICE_TYPE, service.name());\n+        if (data.length > 0) {\n+            dataMap.add(DATA, data[0]);\n+        }\n+        proxy.post(serviceExecutionAPI, dataMap, this);\n+        return true;\n+    }\n+\n+    public void getState() {\n+        synchronized (this) {\n+            serviceExecuting.ifPresentOrElse(service -> {\n+                if (counter >= GIVEUP_COUNTER) {\n+                    logger.warn(\"Giving up updating state for {} after {} times\", service, GIVEUP_COUNTER);\n+                    reset();\n+                    // immediately refresh data\n+                    handler.getData();\n+                }\n+                counter++;\n+                final MultiMap<String> dataMap = new MultiMap<String>();\n+                dataMap.add(SERVICE_TYPE, service);\n+                proxy.get(serviceExecutionStateAPI, dataMap, this);\n+            }, () -> {\n+                logger.warn(\"No Service executed to get state\");\n+            });\n+        }\n+    }\n+\n+    @Override\n+    public void onResponse(@Nullable String result) {\n+        if (result != null) {\n+            try {\n+                ExecutionStatusContainer esc = Converter.getGson().fromJson(result, ExecutionStatusContainer.class);\n+                if (esc != null && esc.executionStatus != null) {\n+                    String status = esc.executionStatus.status;\n+                    synchronized (this) {\n+                        handler.updateRemoteExecutionStatus(serviceExecuting.orElse(null), status);\n+                        if (ExecutionState.EXECUTED.name().equals(status)) {\n+                            // refresh loop ends - update of status handled in the normal refreshInterval. Earlier\n+                            // update\n+                            // doesn't\n+                            // show better results!\n+                            reset();\n+                            return;\n+                        }\n+                    }\n+                }\n+            } catch (JsonSyntaxException jse) {\n+                logger.debug(\"RemoteService response is unparseable: {} {}\", result, jse.getMessage());\n+            }\n+        }\n+        // schedule even if no result is present until retries exceeded\n+        handler.getScheduler().schedule(this::getState, STATE_UPDATE_SEC, TimeUnit.SECONDS);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "48af48c82562d006b6f2aa35922270f181c885ed"}, "originalPosition": 170}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5ODI5NDExNw==", "bodyText": "fixed in weymann#9", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r598294117", "createdAt": "2021-03-21T15:13:43Z", "author": {"login": "ntruchsess"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/RemoteServiceHandler.java", "diffHunk": "@@ -0,0 +1,186 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bmwconnecteddrive.internal.handler;\n+\n+import static org.openhab.binding.bmwconnecteddrive.internal.ConnectedDriveConstants.*;\n+\n+import java.util.Optional;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.util.MultiMap;\n+import org.openhab.binding.bmwconnecteddrive.internal.VehicleConfiguration;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.NetworkError;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.remote.ExecutionStatusContainer;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Constants;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Converter;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.HTTPConstants;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonSyntaxException;\n+\n+/**\n+ * The {@link RemoteServiceHandler} handles executions of remote services towards your Vehicle\n+ *\n+ * @see https://github.com/bimmerconnected/bimmer_connected/blob/master/bimmer_connected/remote_services.py\n+ *\n+ * @author Bernd Weymann - Initial contribution\n+ * @author Norbert Truchsess - edit & send of charge profile\n+ */\n+@NonNullByDefault\n+public class RemoteServiceHandler implements StringResponseCallback {\n+    private final Logger logger = LoggerFactory.getLogger(RemoteServiceHandler.class);\n+\n+    // after 60 retries the state update will give up\n+    private static final String SERVICE_TYPE = \"serviceType\";\n+    private static final String DATA = \"data\";\n+    private static final int GIVEUP_COUNTER = 6;\n+    private static final int STATE_UPDATE_SEC = HTTPConstants.HTTP_TIMEOUT_SEC + 1; // regular timeout + 1sec\n+    private int counter = 0;\n+\n+    public enum ExecutionState {\n+        READY,\n+        INITIATED,\n+        PENDING,\n+        DELIVERED,\n+        EXECUTED,\n+        ERROR,\n+    }\n+\n+    public enum RemoteService {\n+        LIGHT_FLASH(REMOTE_SERVICE_LIGHT_FLASH, \"Flash Lights\"),\n+        VEHICLE_FINDER(REMOTE_SERVICE_VEHICLE_FINDER, \"Vehicle Finder\"),\n+        DOOR_LOCK(REMOTE_SERVICE_DOOR_LOCK, \"Door Lock\"),\n+        DOOR_UNLOCK(REMOTE_SERVICE_DOOR_UNLOCK, \"Door Unlock\"),\n+        HORN_BLOW(REMOTE_SERVICE_HORN, \"Horn Blow\"),\n+        CLIMATE_NOW(REMOTE_SERVICE_AIR_CONDITIONING, \"Climate Control\"),\n+        CHARGE_NOW(REMOTE_SERVICE_CHARGE_NOW, \"Start Charging\"),\n+        CHARGING_CONTROL(REMOTE_SERVICE_CHARGING_CONTROL, \"Send Charging Profile\");\n+\n+        private final String command;\n+        private final String label;\n+\n+        RemoteService(final String command, final String label) {\n+            this.command = command;\n+            this.label = label;\n+        }\n+\n+        public String getCommand() {\n+            return command;\n+        }\n+\n+        public String getLabel() {\n+            return label;\n+        }\n+    }\n+\n+    private final ConnectedDriveProxy proxy;\n+    private final VehicleHandler handler;\n+    private Optional<String> serviceExecuting = Optional.empty();\n+\n+    private final String serviceExecutionAPI;\n+    private final String serviceExecutionStateAPI;\n+\n+    public RemoteServiceHandler(VehicleHandler vehicleHandler, ConnectedDriveProxy connectedDriveProxy) {\n+        handler = vehicleHandler;\n+        proxy = connectedDriveProxy;\n+        if (handler.getConfiguration().isPresent()) {\n+            final VehicleConfiguration config = handler.getConfiguration().get();\n+            serviceExecutionAPI = proxy.baseUrl + config.vin + proxy.serviceExecutionAPI;\n+            serviceExecutionStateAPI = proxy.baseUrl + config.vin + proxy.serviceExecutionStateAPI;\n+        } else {\n+            serviceExecutionAPI = Constants.INVALID;\n+            serviceExecutionStateAPI = Constants.INVALID;\n+            logger.warn(\"No configuration for VehicleHandler available\");\n+        }\n+    }\n+\n+    boolean execute(RemoteService service, String... data) {\n+        synchronized (this) {\n+            if (serviceExecuting.isPresent()) {\n+                // only one service executing\n+                return false;\n+            }\n+            serviceExecuting = Optional.of(service.name());\n+        }\n+        final MultiMap<String> dataMap = new MultiMap<String>();\n+        dataMap.add(SERVICE_TYPE, service.name());\n+        if (data.length > 0) {\n+            dataMap.add(DATA, data[0]);\n+        }\n+        proxy.post(serviceExecutionAPI, dataMap, this);\n+        return true;\n+    }\n+\n+    public void getState() {\n+        synchronized (this) {\n+            serviceExecuting.ifPresentOrElse(service -> {\n+                if (counter >= GIVEUP_COUNTER) {\n+                    logger.warn(\"Giving up updating state for {} after {} times\", service, GIVEUP_COUNTER);\n+                    reset();\n+                    // immediately refresh data\n+                    handler.getData();\n+                }\n+                counter++;\n+                final MultiMap<String> dataMap = new MultiMap<String>();\n+                dataMap.add(SERVICE_TYPE, service);\n+                proxy.get(serviceExecutionStateAPI, dataMap, this);\n+            }, () -> {\n+                logger.warn(\"No Service executed to get state\");\n+            });\n+        }\n+    }\n+\n+    @Override\n+    public void onResponse(@Nullable String result) {\n+        if (result != null) {\n+            try {\n+                ExecutionStatusContainer esc = Converter.getGson().fromJson(result, ExecutionStatusContainer.class);\n+                if (esc != null && esc.executionStatus != null) {\n+                    String status = esc.executionStatus.status;\n+                    synchronized (this) {\n+                        handler.updateRemoteExecutionStatus(serviceExecuting.orElse(null), status);\n+                        if (ExecutionState.EXECUTED.name().equals(status)) {\n+                            // refresh loop ends - update of status handled in the normal refreshInterval. Earlier\n+                            // update\n+                            // doesn't\n+                            // show better results!\n+                            reset();\n+                            return;\n+                        }\n+                    }\n+                }\n+            } catch (JsonSyntaxException jse) {\n+                logger.debug(\"RemoteService response is unparseable: {} {}\", result, jse.getMessage());\n+            }\n+        }\n+        // schedule even if no result is present until retries exceeded\n+        handler.getScheduler().schedule(this::getState, STATE_UPDATE_SEC, TimeUnit.SECONDS);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5NzkwMDA3OQ=="}, "originalCommit": {"oid": "48af48c82562d006b6f2aa35922270f181c885ed"}, "originalPosition": 170}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzc3NjY2ODY4OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/VehicleChannelHandler.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0xOVQxODo0MjoyNlrOI6NCUw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0yM1QwMDoxMTo1N1rOI7ZrPg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5NzkwMTkwNw==", "bodyText": "You could make this class abstract. Then, you don't need to implement them here.", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r597901907", "createdAt": "2021-03-19T18:42:26Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/VehicleChannelHandler.java", "diffHunk": "@@ -0,0 +1,532 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bmwconnecteddrive.internal.handler;\n+\n+import static org.openhab.binding.bmwconnecteddrive.internal.ConnectedDriveConstants.*;\n+\n+import java.time.DayOfWeek;\n+import java.time.LocalTime;\n+import java.time.ZoneId;\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.EnumSet;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import javax.measure.quantity.Length;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.binding.bmwconnecteddrive.internal.ConnectedDriveConstants.VehicleType;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.Destination;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.statistics.AllTrips;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.statistics.LastTrip;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.status.CBSMessage;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.status.CCMMessage;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.status.Doors;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.status.Position;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.status.VehicleStatus;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.status.Windows;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileUtils;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileUtils.TimedChannel;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileWrapper;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileWrapper.ProfileKey;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Constants;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Converter;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.RemoteServiceUtils;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.VehicleStatusUtils;\n+import org.openhab.core.library.types.DateTimeType;\n+import org.openhab.core.library.types.DecimalType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.PointType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.library.unit.ImperialUnits;\n+import org.openhab.core.library.unit.MetricPrefix;\n+import org.openhab.core.library.unit.SIUnits;\n+import org.openhab.core.library.unit.Units;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.StateOption;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonSyntaxException;\n+\n+/**\n+ * The {@link VehicleChannelHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Bernd Weymann - Initial contribution\n+ * @author Norbert Truchsess - edit & send of charge profile\n+ */\n+@NonNullByDefault\n+public class VehicleChannelHandler extends BaseThingHandler {\n+    protected final Logger logger = LoggerFactory.getLogger(VehicleChannelHandler.class);\n+    protected boolean imperial = false;\n+    protected boolean hasFuel = false;\n+    protected boolean isElectric = false;\n+    protected boolean isHybrid = false;\n+\n+    // List Interfaces\n+    protected List<CBSMessage> serviceList = new ArrayList<CBSMessage>();\n+    protected String selectedService = Constants.UNDEF;\n+    protected List<CCMMessage> checkControlList = new ArrayList<CCMMessage>();\n+    protected String selectedCC = Constants.UNDEF;\n+    protected List<Destination> destinationList = new ArrayList<Destination>();\n+    protected String selectedDestination = Constants.UNDEF;\n+\n+    protected BMWConnectedDriveOptionProvider optionProvider;\n+\n+    // Data Caches\n+    protected Optional<String> vehicleStatusCache = Optional.empty();\n+    protected Optional<String> lastTripCache = Optional.empty();\n+    protected Optional<String> allTripsCache = Optional.empty();\n+    protected Optional<String> chargeProfileCache = Optional.empty();\n+    protected Optional<String> rangeMapCache = Optional.empty();\n+    protected Optional<String> destinationCache = Optional.empty();\n+    protected Optional<byte[]> imageCache = Optional.empty();\n+\n+    public VehicleChannelHandler(Thing thing, BMWConnectedDriveOptionProvider op, String type, boolean imperial) {\n+        super(thing);\n+        optionProvider = op;\n+\n+        this.imperial = imperial;\n+        hasFuel = type.equals(VehicleType.CONVENTIONAL.toString()) || type.equals(VehicleType.PLUGIN_HYBRID.toString())\n+                || type.equals(VehicleType.ELECTRIC_REX.toString());\n+        isElectric = type.equals(VehicleType.PLUGIN_HYBRID.toString())\n+                || type.equals(VehicleType.ELECTRIC_REX.toString()) || type.equals(VehicleType.ELECTRIC.toString());\n+        isHybrid = hasFuel && isElectric;\n+\n+        setOptions(CHANNEL_GROUP_REMOTE, REMOTE_SERVICE_COMMAND, RemoteServiceUtils.getOptions(isElectric));\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+    }\n+\n+    @Override\n+    public void initialize() {\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "48af48c82562d006b6f2aa35922270f181c885ed"}, "originalPosition": 124}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5OTE1NzU2Ng==", "bodyText": "Sure, fixed", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r599157566", "createdAt": "2021-03-23T00:11:57Z", "author": {"login": "weymann"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/VehicleChannelHandler.java", "diffHunk": "@@ -0,0 +1,532 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bmwconnecteddrive.internal.handler;\n+\n+import static org.openhab.binding.bmwconnecteddrive.internal.ConnectedDriveConstants.*;\n+\n+import java.time.DayOfWeek;\n+import java.time.LocalTime;\n+import java.time.ZoneId;\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.EnumSet;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import javax.measure.quantity.Length;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.binding.bmwconnecteddrive.internal.ConnectedDriveConstants.VehicleType;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.Destination;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.statistics.AllTrips;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.statistics.LastTrip;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.status.CBSMessage;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.status.CCMMessage;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.status.Doors;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.status.Position;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.status.VehicleStatus;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.status.Windows;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileUtils;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileUtils.TimedChannel;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileWrapper;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileWrapper.ProfileKey;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Constants;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Converter;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.RemoteServiceUtils;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.VehicleStatusUtils;\n+import org.openhab.core.library.types.DateTimeType;\n+import org.openhab.core.library.types.DecimalType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.PointType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.library.unit.ImperialUnits;\n+import org.openhab.core.library.unit.MetricPrefix;\n+import org.openhab.core.library.unit.SIUnits;\n+import org.openhab.core.library.unit.Units;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.StateOption;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonSyntaxException;\n+\n+/**\n+ * The {@link VehicleChannelHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Bernd Weymann - Initial contribution\n+ * @author Norbert Truchsess - edit & send of charge profile\n+ */\n+@NonNullByDefault\n+public class VehicleChannelHandler extends BaseThingHandler {\n+    protected final Logger logger = LoggerFactory.getLogger(VehicleChannelHandler.class);\n+    protected boolean imperial = false;\n+    protected boolean hasFuel = false;\n+    protected boolean isElectric = false;\n+    protected boolean isHybrid = false;\n+\n+    // List Interfaces\n+    protected List<CBSMessage> serviceList = new ArrayList<CBSMessage>();\n+    protected String selectedService = Constants.UNDEF;\n+    protected List<CCMMessage> checkControlList = new ArrayList<CCMMessage>();\n+    protected String selectedCC = Constants.UNDEF;\n+    protected List<Destination> destinationList = new ArrayList<Destination>();\n+    protected String selectedDestination = Constants.UNDEF;\n+\n+    protected BMWConnectedDriveOptionProvider optionProvider;\n+\n+    // Data Caches\n+    protected Optional<String> vehicleStatusCache = Optional.empty();\n+    protected Optional<String> lastTripCache = Optional.empty();\n+    protected Optional<String> allTripsCache = Optional.empty();\n+    protected Optional<String> chargeProfileCache = Optional.empty();\n+    protected Optional<String> rangeMapCache = Optional.empty();\n+    protected Optional<String> destinationCache = Optional.empty();\n+    protected Optional<byte[]> imageCache = Optional.empty();\n+\n+    public VehicleChannelHandler(Thing thing, BMWConnectedDriveOptionProvider op, String type, boolean imperial) {\n+        super(thing);\n+        optionProvider = op;\n+\n+        this.imperial = imperial;\n+        hasFuel = type.equals(VehicleType.CONVENTIONAL.toString()) || type.equals(VehicleType.PLUGIN_HYBRID.toString())\n+                || type.equals(VehicleType.ELECTRIC_REX.toString());\n+        isElectric = type.equals(VehicleType.PLUGIN_HYBRID.toString())\n+                || type.equals(VehicleType.ELECTRIC_REX.toString()) || type.equals(VehicleType.ELECTRIC.toString());\n+        isHybrid = hasFuel && isElectric;\n+\n+        setOptions(CHANNEL_GROUP_REMOTE, REMOTE_SERVICE_COMMAND, RemoteServiceUtils.getOptions(isElectric));\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+    }\n+\n+    @Override\n+    public void initialize() {\n+    }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5NzkwMTkwNw=="}, "originalCommit": {"oid": "48af48c82562d006b6f2aa35922270f181c885ed"}, "originalPosition": 124}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzc3NjY5ODQyOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/VehicleChannelHandler.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0xOVQxODo1MDozOFrOI6NUGQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0yM1QyMzoxODowM1rOI8Orew==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5NzkwNjQ1Nw==", "bodyText": "You could make MetricPrefix.KILO(SIUnits.METRE) a constant.", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r597906457", "createdAt": "2021-03-19T18:50:38Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/VehicleChannelHandler.java", "diffHunk": "@@ -0,0 +1,532 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bmwconnecteddrive.internal.handler;\n+\n+import static org.openhab.binding.bmwconnecteddrive.internal.ConnectedDriveConstants.*;\n+\n+import java.time.DayOfWeek;\n+import java.time.LocalTime;\n+import java.time.ZoneId;\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.EnumSet;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import javax.measure.quantity.Length;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.binding.bmwconnecteddrive.internal.ConnectedDriveConstants.VehicleType;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.Destination;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.statistics.AllTrips;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.statistics.LastTrip;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.status.CBSMessage;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.status.CCMMessage;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.status.Doors;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.status.Position;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.status.VehicleStatus;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.status.Windows;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileUtils;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileUtils.TimedChannel;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileWrapper;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileWrapper.ProfileKey;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Constants;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Converter;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.RemoteServiceUtils;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.VehicleStatusUtils;\n+import org.openhab.core.library.types.DateTimeType;\n+import org.openhab.core.library.types.DecimalType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.PointType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.library.unit.ImperialUnits;\n+import org.openhab.core.library.unit.MetricPrefix;\n+import org.openhab.core.library.unit.SIUnits;\n+import org.openhab.core.library.unit.Units;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.StateOption;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonSyntaxException;\n+\n+/**\n+ * The {@link VehicleChannelHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Bernd Weymann - Initial contribution\n+ * @author Norbert Truchsess - edit & send of charge profile\n+ */\n+@NonNullByDefault\n+public class VehicleChannelHandler extends BaseThingHandler {\n+    protected final Logger logger = LoggerFactory.getLogger(VehicleChannelHandler.class);\n+    protected boolean imperial = false;\n+    protected boolean hasFuel = false;\n+    protected boolean isElectric = false;\n+    protected boolean isHybrid = false;\n+\n+    // List Interfaces\n+    protected List<CBSMessage> serviceList = new ArrayList<CBSMessage>();\n+    protected String selectedService = Constants.UNDEF;\n+    protected List<CCMMessage> checkControlList = new ArrayList<CCMMessage>();\n+    protected String selectedCC = Constants.UNDEF;\n+    protected List<Destination> destinationList = new ArrayList<Destination>();\n+    protected String selectedDestination = Constants.UNDEF;\n+\n+    protected BMWConnectedDriveOptionProvider optionProvider;\n+\n+    // Data Caches\n+    protected Optional<String> vehicleStatusCache = Optional.empty();\n+    protected Optional<String> lastTripCache = Optional.empty();\n+    protected Optional<String> allTripsCache = Optional.empty();\n+    protected Optional<String> chargeProfileCache = Optional.empty();\n+    protected Optional<String> rangeMapCache = Optional.empty();\n+    protected Optional<String> destinationCache = Optional.empty();\n+    protected Optional<byte[]> imageCache = Optional.empty();\n+\n+    public VehicleChannelHandler(Thing thing, BMWConnectedDriveOptionProvider op, String type, boolean imperial) {\n+        super(thing);\n+        optionProvider = op;\n+\n+        this.imperial = imperial;\n+        hasFuel = type.equals(VehicleType.CONVENTIONAL.toString()) || type.equals(VehicleType.PLUGIN_HYBRID.toString())\n+                || type.equals(VehicleType.ELECTRIC_REX.toString());\n+        isElectric = type.equals(VehicleType.PLUGIN_HYBRID.toString())\n+                || type.equals(VehicleType.ELECTRIC_REX.toString()) || type.equals(VehicleType.ELECTRIC.toString());\n+        isHybrid = hasFuel && isElectric;\n+\n+        setOptions(CHANNEL_GROUP_REMOTE, REMOTE_SERVICE_COMMAND, RemoteServiceUtils.getOptions(isElectric));\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+    }\n+\n+    @Override\n+    public void initialize() {\n+    }\n+\n+    private void setOptions(final String group, final String id, List<StateOption> options) {\n+        optionProvider.setStateOptions(new ChannelUID(thing.getUID(), group, id), options);\n+    }\n+\n+    protected void updateChannel(final String group, final String id, final State state) {\n+        updateState(new ChannelUID(thing.getUID(), group, id), state);\n+    }\n+\n+    protected void updateCheckControls(List<CCMMessage> ccl) {\n+        if (ccl.size() == 0) {\n+            // No Check Control available - show not active\n+            CCMMessage ccm = new CCMMessage();\n+            ccm.ccmDescriptionLong = Constants.NO_ENTRIES;\n+            ccm.ccmDescriptionShort = Constants.NO_ENTRIES;\n+            ccm.ccmId = -1;\n+            ccm.ccmMileage = -1;\n+            ccl.add(ccm);\n+        }\n+\n+        // add all elements to options\n+        checkControlList = ccl;\n+        List<StateOption> ccmDescriptionOptions = new ArrayList<>();\n+        List<StateOption> ccmDetailsOptions = new ArrayList<>();\n+        List<StateOption> ccmMileageOptions = new ArrayList<>();\n+        boolean isSelectedElementIn = false;\n+        int index = 0;\n+        for (CCMMessage ccEntry : checkControlList) {\n+            ccmDescriptionOptions.add(new StateOption(Integer.toString(index), ccEntry.ccmDescriptionShort));\n+            ccmDetailsOptions.add(new StateOption(Integer.toString(index), ccEntry.ccmDescriptionLong));\n+            ccmMileageOptions.add(new StateOption(Integer.toString(index), Integer.toString(ccEntry.ccmMileage)));\n+            if (selectedCC.equals(ccEntry.ccmDescriptionShort)) {\n+                isSelectedElementIn = true;\n+            }\n+            index++;\n+        }\n+        setOptions(CHANNEL_GROUP_CHECK_CONTROL, NAME, ccmDescriptionOptions);\n+        setOptions(CHANNEL_GROUP_CHECK_CONTROL, DETAILS, ccmDetailsOptions);\n+        setOptions(CHANNEL_GROUP_CHECK_CONTROL, MILEAGE, ccmMileageOptions);\n+\n+        // if current selected item isn't anymore in the list select first entry\n+        if (!isSelectedElementIn) {\n+            selectCheckControl(0);\n+        }\n+    }\n+\n+    protected void selectCheckControl(int index) {\n+        if (index >= 0 && index < checkControlList.size()) {\n+            CCMMessage ccEntry = checkControlList.get(index);\n+            selectedCC = ccEntry.ccmDescriptionShort;\n+            updateChannel(CHANNEL_GROUP_CHECK_CONTROL, NAME, StringType.valueOf(ccEntry.ccmDescriptionShort));\n+            updateChannel(CHANNEL_GROUP_CHECK_CONTROL, DETAILS, StringType.valueOf(ccEntry.ccmDescriptionLong));\n+            updateChannel(CHANNEL_GROUP_CHECK_CONTROL, MILEAGE,\n+                    QuantityType.valueOf(Converter.round(ccEntry.ccmMileage),\n+                            imperial ? ImperialUnits.MILE : MetricPrefix.KILO(SIUnits.METRE)));\n+        }\n+    }\n+\n+    protected void updateServices(List<CBSMessage> sl) {\n+        // if list is empty add \"undefined\" element\n+        if (sl.size() == 0) {\n+            CBSMessage cbsm = new CBSMessage();\n+            cbsm.cbsType = Constants.NO_ENTRIES;\n+            cbsm.cbsDescription = Constants.NO_ENTRIES;\n+            sl.add(cbsm);\n+        }\n+\n+        // add all elements to options\n+        serviceList = sl;\n+        List<StateOption> serviceNameOptions = new ArrayList<>();\n+        List<StateOption> serviceDetailsOptions = new ArrayList<>();\n+        List<StateOption> serviceDateOptions = new ArrayList<>();\n+        List<StateOption> serviceMileageOptions = new ArrayList<>();\n+        boolean isSelectedElementIn = false;\n+        int index = 0;\n+        for (CBSMessage serviceEntry : serviceList) {\n+            // create StateOption with \"value = list index\" and \"label = human readable string\"\n+            serviceNameOptions.add(new StateOption(Integer.toString(index), serviceEntry.getType()));\n+            serviceDetailsOptions.add(new StateOption(Integer.toString(index), serviceEntry.getDescription()));\n+            serviceDateOptions.add(new StateOption(Integer.toString(index), serviceEntry.getDueDate()));\n+            serviceMileageOptions\n+                    .add(new StateOption(Integer.toString(index), Integer.toString(serviceEntry.cbsRemainingMileage)));\n+            if (selectedService.equals(serviceEntry.getType())) {\n+                isSelectedElementIn = true;\n+            }\n+            index++;\n+        }\n+        setOptions(CHANNEL_GROUP_SERVICE, NAME, serviceNameOptions);\n+        setOptions(CHANNEL_GROUP_SERVICE, DETAILS, serviceDetailsOptions);\n+        setOptions(CHANNEL_GROUP_SERVICE, DATE, serviceDateOptions);\n+        setOptions(CHANNEL_GROUP_SERVICE, MILEAGE, serviceMileageOptions);\n+\n+        // if current selected item isn't anymore in the list select first entry\n+        if (!isSelectedElementIn) {\n+            selectService(0);\n+        }\n+    }\n+\n+    protected void selectService(int index) {\n+        if (index >= 0 && index < serviceList.size()) {\n+            CBSMessage serviceEntry = serviceList.get(index);\n+            selectedService = serviceEntry.cbsType;\n+            updateChannel(CHANNEL_GROUP_SERVICE, NAME,\n+                    StringType.valueOf(Converter.toTitleCase(serviceEntry.getType())));\n+            updateChannel(CHANNEL_GROUP_SERVICE, DETAILS,\n+                    StringType.valueOf(Converter.toTitleCase(serviceEntry.getDescription())));\n+            updateChannel(CHANNEL_GROUP_SERVICE, DATE,\n+                    DateTimeType.valueOf(Converter.getLocalDateTime(serviceEntry.getDueDate())));\n+            updateChannel(CHANNEL_GROUP_SERVICE, MILEAGE,\n+                    QuantityType.valueOf(Converter.round(serviceEntry.cbsRemainingMileage),\n+                            imperial ? ImperialUnits.MILE : MetricPrefix.KILO(SIUnits.METRE)));\n+        }\n+    }\n+\n+    protected void updateDestinations(List<Destination> dl) {\n+        // if list is empty add \"undefined\" element\n+        if (dl.size() == 0) {\n+            Destination dest = new Destination();\n+            dest.city = Constants.NO_ENTRIES;\n+            dest.lat = -1;\n+            dest.lon = -1;\n+            dl.add(dest);\n+        }\n+\n+        // add all elements to options\n+        destinationList = dl;\n+        List<StateOption> destinationNameOptions = new ArrayList<>();\n+        List<StateOption> destinationGPSOptions = new ArrayList<>();\n+        boolean isSelectedElementIn = false;\n+        int index = 0;\n+        for (Destination destination : destinationList) {\n+            destinationNameOptions.add(new StateOption(Integer.toString(index), destination.getAddress()));\n+            destinationGPSOptions.add(new StateOption(Integer.toString(index), destination.getCoordinates()));\n+            if (selectedDestination.equals(destination.getAddress())) {\n+                isSelectedElementIn = true;\n+            }\n+            index++;\n+        }\n+        setOptions(CHANNEL_GROUP_DESTINATION, NAME, destinationNameOptions);\n+        setOptions(CHANNEL_GROUP_DESTINATION, GPS, destinationGPSOptions);\n+\n+        // if current selected item isn't anymore in the list select first entry\n+        if (!isSelectedElementIn) {\n+            selectDestination(0);\n+        }\n+    }\n+\n+    protected void selectDestination(int index) {\n+        if (index >= 0 && index < destinationList.size()) {\n+            Destination destinationEntry = destinationList.get(index);\n+            // update selected Item\n+            selectedDestination = destinationEntry.getAddress();\n+            // update coordinates according to new set location\n+            updateChannel(CHANNEL_GROUP_DESTINATION, NAME, StringType.valueOf(destinationEntry.getAddress()));\n+            updateChannel(CHANNEL_GROUP_DESTINATION, GPS, PointType.valueOf(destinationEntry.getCoordinates()));\n+        }\n+    }\n+\n+    protected void updateAllTrips(AllTrips allTrips) {\n+        QuantityType<Length> qtTotalElectric = QuantityType\n+                .valueOf(Converter.round(allTrips.totalElectricDistance.userTotal), MetricPrefix.KILO(SIUnits.METRE));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "48af48c82562d006b6f2aa35922270f181c885ed"}, "originalPosition": 285}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMDAyNTk3OQ==", "bodyText": "Changed for all occurrences", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r600025979", "createdAt": "2021-03-23T23:18:03Z", "author": {"login": "weymann"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/VehicleChannelHandler.java", "diffHunk": "@@ -0,0 +1,532 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bmwconnecteddrive.internal.handler;\n+\n+import static org.openhab.binding.bmwconnecteddrive.internal.ConnectedDriveConstants.*;\n+\n+import java.time.DayOfWeek;\n+import java.time.LocalTime;\n+import java.time.ZoneId;\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.EnumSet;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import javax.measure.quantity.Length;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.binding.bmwconnecteddrive.internal.ConnectedDriveConstants.VehicleType;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.Destination;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.statistics.AllTrips;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.statistics.LastTrip;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.status.CBSMessage;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.status.CCMMessage;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.status.Doors;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.status.Position;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.status.VehicleStatus;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.status.Windows;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileUtils;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileUtils.TimedChannel;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileWrapper;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileWrapper.ProfileKey;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Constants;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Converter;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.RemoteServiceUtils;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.VehicleStatusUtils;\n+import org.openhab.core.library.types.DateTimeType;\n+import org.openhab.core.library.types.DecimalType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.PointType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.library.unit.ImperialUnits;\n+import org.openhab.core.library.unit.MetricPrefix;\n+import org.openhab.core.library.unit.SIUnits;\n+import org.openhab.core.library.unit.Units;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.StateOption;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonSyntaxException;\n+\n+/**\n+ * The {@link VehicleChannelHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Bernd Weymann - Initial contribution\n+ * @author Norbert Truchsess - edit & send of charge profile\n+ */\n+@NonNullByDefault\n+public class VehicleChannelHandler extends BaseThingHandler {\n+    protected final Logger logger = LoggerFactory.getLogger(VehicleChannelHandler.class);\n+    protected boolean imperial = false;\n+    protected boolean hasFuel = false;\n+    protected boolean isElectric = false;\n+    protected boolean isHybrid = false;\n+\n+    // List Interfaces\n+    protected List<CBSMessage> serviceList = new ArrayList<CBSMessage>();\n+    protected String selectedService = Constants.UNDEF;\n+    protected List<CCMMessage> checkControlList = new ArrayList<CCMMessage>();\n+    protected String selectedCC = Constants.UNDEF;\n+    protected List<Destination> destinationList = new ArrayList<Destination>();\n+    protected String selectedDestination = Constants.UNDEF;\n+\n+    protected BMWConnectedDriveOptionProvider optionProvider;\n+\n+    // Data Caches\n+    protected Optional<String> vehicleStatusCache = Optional.empty();\n+    protected Optional<String> lastTripCache = Optional.empty();\n+    protected Optional<String> allTripsCache = Optional.empty();\n+    protected Optional<String> chargeProfileCache = Optional.empty();\n+    protected Optional<String> rangeMapCache = Optional.empty();\n+    protected Optional<String> destinationCache = Optional.empty();\n+    protected Optional<byte[]> imageCache = Optional.empty();\n+\n+    public VehicleChannelHandler(Thing thing, BMWConnectedDriveOptionProvider op, String type, boolean imperial) {\n+        super(thing);\n+        optionProvider = op;\n+\n+        this.imperial = imperial;\n+        hasFuel = type.equals(VehicleType.CONVENTIONAL.toString()) || type.equals(VehicleType.PLUGIN_HYBRID.toString())\n+                || type.equals(VehicleType.ELECTRIC_REX.toString());\n+        isElectric = type.equals(VehicleType.PLUGIN_HYBRID.toString())\n+                || type.equals(VehicleType.ELECTRIC_REX.toString()) || type.equals(VehicleType.ELECTRIC.toString());\n+        isHybrid = hasFuel && isElectric;\n+\n+        setOptions(CHANNEL_GROUP_REMOTE, REMOTE_SERVICE_COMMAND, RemoteServiceUtils.getOptions(isElectric));\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+    }\n+\n+    @Override\n+    public void initialize() {\n+    }\n+\n+    private void setOptions(final String group, final String id, List<StateOption> options) {\n+        optionProvider.setStateOptions(new ChannelUID(thing.getUID(), group, id), options);\n+    }\n+\n+    protected void updateChannel(final String group, final String id, final State state) {\n+        updateState(new ChannelUID(thing.getUID(), group, id), state);\n+    }\n+\n+    protected void updateCheckControls(List<CCMMessage> ccl) {\n+        if (ccl.size() == 0) {\n+            // No Check Control available - show not active\n+            CCMMessage ccm = new CCMMessage();\n+            ccm.ccmDescriptionLong = Constants.NO_ENTRIES;\n+            ccm.ccmDescriptionShort = Constants.NO_ENTRIES;\n+            ccm.ccmId = -1;\n+            ccm.ccmMileage = -1;\n+            ccl.add(ccm);\n+        }\n+\n+        // add all elements to options\n+        checkControlList = ccl;\n+        List<StateOption> ccmDescriptionOptions = new ArrayList<>();\n+        List<StateOption> ccmDetailsOptions = new ArrayList<>();\n+        List<StateOption> ccmMileageOptions = new ArrayList<>();\n+        boolean isSelectedElementIn = false;\n+        int index = 0;\n+        for (CCMMessage ccEntry : checkControlList) {\n+            ccmDescriptionOptions.add(new StateOption(Integer.toString(index), ccEntry.ccmDescriptionShort));\n+            ccmDetailsOptions.add(new StateOption(Integer.toString(index), ccEntry.ccmDescriptionLong));\n+            ccmMileageOptions.add(new StateOption(Integer.toString(index), Integer.toString(ccEntry.ccmMileage)));\n+            if (selectedCC.equals(ccEntry.ccmDescriptionShort)) {\n+                isSelectedElementIn = true;\n+            }\n+            index++;\n+        }\n+        setOptions(CHANNEL_GROUP_CHECK_CONTROL, NAME, ccmDescriptionOptions);\n+        setOptions(CHANNEL_GROUP_CHECK_CONTROL, DETAILS, ccmDetailsOptions);\n+        setOptions(CHANNEL_GROUP_CHECK_CONTROL, MILEAGE, ccmMileageOptions);\n+\n+        // if current selected item isn't anymore in the list select first entry\n+        if (!isSelectedElementIn) {\n+            selectCheckControl(0);\n+        }\n+    }\n+\n+    protected void selectCheckControl(int index) {\n+        if (index >= 0 && index < checkControlList.size()) {\n+            CCMMessage ccEntry = checkControlList.get(index);\n+            selectedCC = ccEntry.ccmDescriptionShort;\n+            updateChannel(CHANNEL_GROUP_CHECK_CONTROL, NAME, StringType.valueOf(ccEntry.ccmDescriptionShort));\n+            updateChannel(CHANNEL_GROUP_CHECK_CONTROL, DETAILS, StringType.valueOf(ccEntry.ccmDescriptionLong));\n+            updateChannel(CHANNEL_GROUP_CHECK_CONTROL, MILEAGE,\n+                    QuantityType.valueOf(Converter.round(ccEntry.ccmMileage),\n+                            imperial ? ImperialUnits.MILE : MetricPrefix.KILO(SIUnits.METRE)));\n+        }\n+    }\n+\n+    protected void updateServices(List<CBSMessage> sl) {\n+        // if list is empty add \"undefined\" element\n+        if (sl.size() == 0) {\n+            CBSMessage cbsm = new CBSMessage();\n+            cbsm.cbsType = Constants.NO_ENTRIES;\n+            cbsm.cbsDescription = Constants.NO_ENTRIES;\n+            sl.add(cbsm);\n+        }\n+\n+        // add all elements to options\n+        serviceList = sl;\n+        List<StateOption> serviceNameOptions = new ArrayList<>();\n+        List<StateOption> serviceDetailsOptions = new ArrayList<>();\n+        List<StateOption> serviceDateOptions = new ArrayList<>();\n+        List<StateOption> serviceMileageOptions = new ArrayList<>();\n+        boolean isSelectedElementIn = false;\n+        int index = 0;\n+        for (CBSMessage serviceEntry : serviceList) {\n+            // create StateOption with \"value = list index\" and \"label = human readable string\"\n+            serviceNameOptions.add(new StateOption(Integer.toString(index), serviceEntry.getType()));\n+            serviceDetailsOptions.add(new StateOption(Integer.toString(index), serviceEntry.getDescription()));\n+            serviceDateOptions.add(new StateOption(Integer.toString(index), serviceEntry.getDueDate()));\n+            serviceMileageOptions\n+                    .add(new StateOption(Integer.toString(index), Integer.toString(serviceEntry.cbsRemainingMileage)));\n+            if (selectedService.equals(serviceEntry.getType())) {\n+                isSelectedElementIn = true;\n+            }\n+            index++;\n+        }\n+        setOptions(CHANNEL_GROUP_SERVICE, NAME, serviceNameOptions);\n+        setOptions(CHANNEL_GROUP_SERVICE, DETAILS, serviceDetailsOptions);\n+        setOptions(CHANNEL_GROUP_SERVICE, DATE, serviceDateOptions);\n+        setOptions(CHANNEL_GROUP_SERVICE, MILEAGE, serviceMileageOptions);\n+\n+        // if current selected item isn't anymore in the list select first entry\n+        if (!isSelectedElementIn) {\n+            selectService(0);\n+        }\n+    }\n+\n+    protected void selectService(int index) {\n+        if (index >= 0 && index < serviceList.size()) {\n+            CBSMessage serviceEntry = serviceList.get(index);\n+            selectedService = serviceEntry.cbsType;\n+            updateChannel(CHANNEL_GROUP_SERVICE, NAME,\n+                    StringType.valueOf(Converter.toTitleCase(serviceEntry.getType())));\n+            updateChannel(CHANNEL_GROUP_SERVICE, DETAILS,\n+                    StringType.valueOf(Converter.toTitleCase(serviceEntry.getDescription())));\n+            updateChannel(CHANNEL_GROUP_SERVICE, DATE,\n+                    DateTimeType.valueOf(Converter.getLocalDateTime(serviceEntry.getDueDate())));\n+            updateChannel(CHANNEL_GROUP_SERVICE, MILEAGE,\n+                    QuantityType.valueOf(Converter.round(serviceEntry.cbsRemainingMileage),\n+                            imperial ? ImperialUnits.MILE : MetricPrefix.KILO(SIUnits.METRE)));\n+        }\n+    }\n+\n+    protected void updateDestinations(List<Destination> dl) {\n+        // if list is empty add \"undefined\" element\n+        if (dl.size() == 0) {\n+            Destination dest = new Destination();\n+            dest.city = Constants.NO_ENTRIES;\n+            dest.lat = -1;\n+            dest.lon = -1;\n+            dl.add(dest);\n+        }\n+\n+        // add all elements to options\n+        destinationList = dl;\n+        List<StateOption> destinationNameOptions = new ArrayList<>();\n+        List<StateOption> destinationGPSOptions = new ArrayList<>();\n+        boolean isSelectedElementIn = false;\n+        int index = 0;\n+        for (Destination destination : destinationList) {\n+            destinationNameOptions.add(new StateOption(Integer.toString(index), destination.getAddress()));\n+            destinationGPSOptions.add(new StateOption(Integer.toString(index), destination.getCoordinates()));\n+            if (selectedDestination.equals(destination.getAddress())) {\n+                isSelectedElementIn = true;\n+            }\n+            index++;\n+        }\n+        setOptions(CHANNEL_GROUP_DESTINATION, NAME, destinationNameOptions);\n+        setOptions(CHANNEL_GROUP_DESTINATION, GPS, destinationGPSOptions);\n+\n+        // if current selected item isn't anymore in the list select first entry\n+        if (!isSelectedElementIn) {\n+            selectDestination(0);\n+        }\n+    }\n+\n+    protected void selectDestination(int index) {\n+        if (index >= 0 && index < destinationList.size()) {\n+            Destination destinationEntry = destinationList.get(index);\n+            // update selected Item\n+            selectedDestination = destinationEntry.getAddress();\n+            // update coordinates according to new set location\n+            updateChannel(CHANNEL_GROUP_DESTINATION, NAME, StringType.valueOf(destinationEntry.getAddress()));\n+            updateChannel(CHANNEL_GROUP_DESTINATION, GPS, PointType.valueOf(destinationEntry.getCoordinates()));\n+        }\n+    }\n+\n+    protected void updateAllTrips(AllTrips allTrips) {\n+        QuantityType<Length> qtTotalElectric = QuantityType\n+                .valueOf(Converter.round(allTrips.totalElectricDistance.userTotal), MetricPrefix.KILO(SIUnits.METRE));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5NzkwNjQ1Nw=="}, "originalCommit": {"oid": "48af48c82562d006b6f2aa35922270f181c885ed"}, "originalPosition": 285}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzc3NjcyMDAzOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.bmwconnecteddrive/README.md", "isResolved": true, "comments": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0xOVQxODo1Njo1MVrOI6NhcQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNC0wM1QxMjo0ODoyOFrOJCjqfQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5NzkwOTg3Mw==", "bodyText": "What is the difference between these channels?", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r597909873", "createdAt": "2021-03-19T18:56:51Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/README.md", "diffHunk": "@@ -0,0 +1,849 @@\n+# BMW ConnectedDrive Binding\n+\n+<img align=\"right\" src=\"./doc/bmw-connected.png\" width=\"150\" height=\"150\"/>\n+\n+The binding provides a connection between [BMW's ConnectedDrive Portal](https://www.bmw-connecteddrive.com/country-region-select/country-region-selection.html) and openHAB.\n+All vehicles connected to an account will be detected by the discovery with the correct type \n+\n+* Conventional Fuel Vehicle\n+* Plugin-Hybrid Electrical Vehicle \n+* Battery Electric Vehicle with Range Extender\n+* Battery Electric Vehicle \n+\n+In addition properties are attached with information and services provided by this vehicle.\n+The provided data depends on \n+\n+1. the [Thing Type](#things) and \n+2. the [Properties](#properties) mentioned in Services\n+\n+Different channel groups are clustering all informations.\n+Check for each group if it's supported for this Vehicle.\n+\n+Please note **this isn't a real-time binding**. \n+If a door is opened the state isn't transmitted and changed immediately. \n+This isn't a flaw in the binding itself because the state in BMW's own ConnectedDrive App is also updated with some delay. \n+\n+## Supported Things\n+\n+### Bridge\n+\n+The bridge establishes the connection between BMW's ConnectedDrive Portal and openHAB.\n+\n+| Name                       | Bridge Type ID | Description                                                |\n+|----------------------------|----------------|------------------------------------------------------------|\n+| BMW ConnectedDrive Account | account        | Access to BMW ConnectedDrive Portal for a specific user    |\n+\n+\n+### Things\n+\n+Four different vehicle types are provided. \n+They differ in the supported channel groups & channels. \n+Conventional Fuel Vehicles have no _Charging Profile_, Electric Vehicles don't provide a _Fuel Range_. \n+For hybrid vehicles in addition to _Fuel and Electric Range_ the _Hybrid Range_ is shown.\n+ \n+| Name                                | Thing Type ID | Supported Channel Groups                               |\n+|-------------------------------------|---------------|--------------------------------------------------------|\n+| BMW Electric Vehicle                | bev           | status, range, location, service, check, charge, image |\n+| BMW Electric Vehicle with REX       | bev_rex       | status, range, location, service, check, charge, image |\n+| BMW Plug-In-Hybrid Electric Vehicle | phev          | status, range, location, service, check, charge, image |\n+| BMW Conventional Vehicle            | conv          | status, range, location, service, check, image         |\n+\n+ \n+#### Properties\n+\n+<img align=\"right\" src=\"./doc/properties.png\" width=\"500\" height=\"225\"/>\n+\n+For each vehicle properties are available. \n+Basically 3 types of information are registered as properties\n+\n+* Informations regarding your dealer with address and phone number\n+* Which services are available / not available\n+* Vehicle properties like color, model type, drive train and construction year\n+\n+In the right picture can see in *Services Activated* e.g. the *DoorLock* and *DoorUnlock* services are mentioned. \n+This ensures channel group [Remote Services](#remote-services) is supporting door lock and unlock remote control.\n+\n+In  *Services Supported* the entry *LastDestination* is mentioned.\n+So it's valid to connect channel group [Last Destinations](#destinations) in order to display and select the last navigation destinations.\n+\n+| Property Key       | Property Value      |  Supported Channel Groups    |\n+|--------------------|---------------------|------------------------------|\n+| servicesSupported  | Statistics          | last-trip, lifetime          |\n+| servicesSupported  | LastDestinations    | destinations                 |\n+| servicesActivated  | _list of services_  | remote                       |\n+\n+\n+## Discovery\n+\n+Auto discovery is starting after the bridge towards BMW's ConnectedDrive is created. \n+A list of your registered vehicles is queried and all found things are added in the inbox.\n+Unique identifier is the *Vehicle Identification Number* (VIN). \n+If a thing is already declared in a  _.things_ configuration, discovery won't highlight it again.\n+Properties will be attached to predefined vehicles if the VIN is matching.\n+\n+## Configuration\n+\n+### Bridge Configuration\n+\n+| Parameter       | Type    | Description                                                        |           \n+|-----------------|---------|--------------------------------------------------------------------|\n+| userName        | text    | BMW ConnectedDrive Username                                       |\n+| password        | text    | BMW ConnectedDrive Password                                       |\n+| region          | text    | Select region in order to connect to the appropriate BMW server.   |\n+\n+The region Configuration has 3 different options\n+\n+* _NORTH_AMERICA_\n+* _CHINA_\n+* _ROW_  (Rest of World)\n+\n+### Thing Configuration\n+\n+Same configuration is needed for all things\n+\n+| Parameter       | Type    | Description                           |           \n+|-----------------|---------|---------------------------------------|\n+| vin             | text    | Vehicle Identification Number (VIN)   |\n+| refreshInterval | integer | Refresh Interval in Minutes           |\n+| units           | text    | Unit Selection. See below.            |\n+| imageSize       | integer | Image Size                            |\n+| imageViewport   | text    | Image Viewport                        |\n+\n+The unit configuration has 3 options\n+\n+* _AUTODETECT_ selects miles for US & UK, kilometer otherwise\n+* _METRIC_ selects directly kilometers\n+* _IMPERIAL_ selects directly miles\n+\n+The _imageVieport_ allows to show the vehicle from different angels.\n+Possible options are \n+\n+* _FRONT_\n+* _REAR_\n+* _SIDE_\n+* _DASHBOARD_\n+* _DRIVERDOOR_\n+\n+## Channels\n+\n+There are many channels available for each vehicle. \n+For better overview they are clustered in different channel groups.\n+They differ for each vehicle type, build-in sensors and activated services.\n+\n+\n+### Thing Channel Groups \n+\n+#### Vehicle Status\n+\n+Reflects overall status of the vehicle.\n+\n+* Channel Group ID is **status**\n+* Available for all vehicles\n+* Read-only values\n+\n+| Channel Label             | Channel ID          | Type          | Description                                    |\n+|---------------------------|---------------------|---------------|------------------------------------------------|\n+| Overall Door Status       | doors               | String        | Combined status for all doors                  |\n+| Overall Window Status     | windows             | String        | Combined status for all windows                |\n+| Doors Locked              | lock                | String        | Status if doors are locked or unlocked         |\n+| Next Service Date         | service-date        | DateTime      | Date of upcoming service                       |\n+| Mileage till Next Service | service-mileage     | Number:Length | Mileage till upcoming service                  |\n+| Check Control             | check-control       | String        | Presence of active warning messages            |\n+| Charging Status           | charge              | String        | Only available for phev, bev_rex and bev       |\n+| Last Status Timestamp     | last-update         | DateTime      | Date and time of last status update            |\n+\n+Overall Door Status values\n+\n+* _Closed_ - all doors closed\n+* _Open_ - at least one door is open\n+* _Undef_ - no door data delivered at all\n+\n+Overall Windows Status values\n+\n+* _Closed_ - all windows closed\n+* _Open_ - at least one window is completely open\n+* _Intermediate_ - at least one window is partially open\n+* _Undef_ - no window data delivered at all\n+\n+Check Control values\n+\n+* _Active_ - at least one warning message is active\n+* _Not Active_ - no warning message is active\n+* _Undef_ - no data for warnings delivered\n+\n+Charging Status values\n+\n+* _Charging_\n+* _Error_\n+* _Finished Fully Charged_\n+* _Finished Not Full_\n+* _Invalid_\n+* _Not Charging_\n+* _Charging Goal reached_\n+* _Waiting For Charging_\n+\n+#### Services\n+\n+Group for all upcoming services with description, service date and/or service mileage.\n+If more than one service is scheduled in the future the channel _name_ contains all future services as options.\n+\n+* Channel Group ID is **service**\n+* Available for all vehicles\n+* Read/Write access\n+\n+| Channel Label                  | Channel ID          | Type           | Access     |\n+|--------------------------------|---------------------|----------------|------------|\n+| Service Name                   | name                | String         | Read/Write |\n+| Service Details                | details             | String         | Read       |\n+| Service Date                   | date                | Number         | Read       |\n+| Mileage till Service           | mileage             | Number:Length  | Read       |\n+\n+#### Check Control\n+\n+Group for all current active CheckControl messages.\n+If more than one message is active the channel _name_ contains all active messages as options.\n+\n+* Channel Group ID is **check**\n+* Available for all vehicles\n+* Read/Write access\n+\n+| Channel Label                   | Channel ID          | Type           | Access     |\n+|---------------------------------|---------------------|----------------|------------|\n+| CheckControl Description        | name                | String         | Read/Write |\n+| CheckControl Details            | details             | String         | Read       |\n+| Mileage Occurrence              | mileage             | Number:Length  | Read       |\n+\n+#### Doors Details\n+\n+Detailed status of all doors and windows.\n+\n+* Channel Group ID is **doors**\n+* Available for all vehicles if corresponding sensors are built-in \n+* Read-only values\n+ \n+| Channel Label              | Channel ID              | Type          | \n+|----------------------------|-------------------------|---------------|\n+| Driver Door                | driver-front            | String        |\n+| Driver Door Rear           | driver-rear             | String        |\n+| Passenger Door             | passenger-front         | String        |\n+| Passenger Door Rear        | passenger-rear          | String        |\n+| Trunk                      | trunk                   | String        |\n+| Hood                       | hood                    | String        |\n+| Driver Window              | win-driver-front        | String        |\n+| Driver Rear Window         | win-driver-rear         | String        |\n+| Passenger Window           | win-passenger-front     | String        |\n+| Passenger Rear Window      | win-passenger-rear      | String        |\n+| Rear Window                | win-rear                | String        |\n+| Sunroof                    | sunroof                 | String        |\n+\n+Possible states\n+\n+* _Undef_ - no status data available\n+* _Invalid_ - this door / window isn't applicable for this vehicle\n+* _Closed_ - the door / window is closed\n+* _Open_ - the door / window is open\n+* _Intermediate_ - window in intermediate position, not applicable for doors\n+\n+#### Range Data\n+\n+Based on vehicle type some channels are present or not. \n+Conventional fuel vehicles don't provide *Electric Range* and battery electric vehicles don't show *Fuel Range*.\n+Hybrid vehicles have both and in addition *Hybrid Range*.\n+See description [Range vs Range Radius](#range-vs-range-radius) to get more information.\n+\n+* Channel Group ID is **range**\n+* Availability according to table\n+* Read-only values\n+\n+| Channel Label         | Channel ID            | Type                 | conv | phev | bev_rex | bev |\n+|-----------------------|-----------------------|----------------------|------|------|---------|-----|\n+| Mileage               | mileage               | Number:Length        |  X   |  X   |    X    |  X  |\n+| Fuel Range            | range-fuel            | Number:Length        |  X   |  X   |    X    |     |\n+| Battery Range         | range-electric        | Number:Length        |      |  X   |    X    |  X  | \n+| Hybrid Range          | range-hybrid          | Number:Length        |      |  X   |    X    |     | \n+| Battery Charge Level  | soc                   | Number:Dimensionless |      |  X   |    X    |  X  |\n+| Remaining Fuel        | remaining-fuel        | Number:Volume        |  X   |  X   |    X    |     | \n+| Fuel Range Radius     | range-radius-fuel     | Number:Length        |  X   |  X   |    X    |     | \n+| Electric Range Radius | range-radius-electric | Number:Length        |      |  X   |    X    |  X  | \n+| Hybrid Range Radius   | range-radius-hybrid   | Number:Length        |      |  X   |    X    |     | \n+\n+\n+#### Charge Profile\n+\n+Charging options with date and time for preferred time windows and charging modes.\n+\n+* Channel Group ID is **charge**\n+* Available for electric and hybrid vehicles\n+* Read/Write access for UI. Use [Charge Profile Actions](#charge-profile-action) in rules\n+* There are 3 timers available. Replace *X* with number 1,2 or 3 to target the correct timer\n+\n+| Channel Label                         | Channel Group ID | Channel ID                | Type     | \n+|---------------------------------------|------------------|---------------------------|----------| \n+| Charging Mode for Profile             | charge           | profile-mode              | String   | \n+| Charging Preferences for Profile      | charge           | profile-prefs             | String   | \n+| Charging Window Start Time            | charge           | window-start              | DateTime | \n+| Charging Window Start Time Hour       | charge           | window-start-hour         | Number   | \n+| Charging Window Start Time Minute     | charge           | window-start-minute       | Number   | ", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "48af48c82562d006b6f2aa35922270f181c885ed"}, "originalPosition": 286}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMjc5NTQ1NQ==", "bodyText": "Hour and Minute are available for editing charging profile. I'm thinking now about removing the channel with DateTimeType because it holds redundant information.", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r602795455", "createdAt": "2021-03-27T21:39:57Z", "author": {"login": "weymann"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/README.md", "diffHunk": "@@ -0,0 +1,849 @@\n+# BMW ConnectedDrive Binding\n+\n+<img align=\"right\" src=\"./doc/bmw-connected.png\" width=\"150\" height=\"150\"/>\n+\n+The binding provides a connection between [BMW's ConnectedDrive Portal](https://www.bmw-connecteddrive.com/country-region-select/country-region-selection.html) and openHAB.\n+All vehicles connected to an account will be detected by the discovery with the correct type \n+\n+* Conventional Fuel Vehicle\n+* Plugin-Hybrid Electrical Vehicle \n+* Battery Electric Vehicle with Range Extender\n+* Battery Electric Vehicle \n+\n+In addition properties are attached with information and services provided by this vehicle.\n+The provided data depends on \n+\n+1. the [Thing Type](#things) and \n+2. the [Properties](#properties) mentioned in Services\n+\n+Different channel groups are clustering all informations.\n+Check for each group if it's supported for this Vehicle.\n+\n+Please note **this isn't a real-time binding**. \n+If a door is opened the state isn't transmitted and changed immediately. \n+This isn't a flaw in the binding itself because the state in BMW's own ConnectedDrive App is also updated with some delay. \n+\n+## Supported Things\n+\n+### Bridge\n+\n+The bridge establishes the connection between BMW's ConnectedDrive Portal and openHAB.\n+\n+| Name                       | Bridge Type ID | Description                                                |\n+|----------------------------|----------------|------------------------------------------------------------|\n+| BMW ConnectedDrive Account | account        | Access to BMW ConnectedDrive Portal for a specific user    |\n+\n+\n+### Things\n+\n+Four different vehicle types are provided. \n+They differ in the supported channel groups & channels. \n+Conventional Fuel Vehicles have no _Charging Profile_, Electric Vehicles don't provide a _Fuel Range_. \n+For hybrid vehicles in addition to _Fuel and Electric Range_ the _Hybrid Range_ is shown.\n+ \n+| Name                                | Thing Type ID | Supported Channel Groups                               |\n+|-------------------------------------|---------------|--------------------------------------------------------|\n+| BMW Electric Vehicle                | bev           | status, range, location, service, check, charge, image |\n+| BMW Electric Vehicle with REX       | bev_rex       | status, range, location, service, check, charge, image |\n+| BMW Plug-In-Hybrid Electric Vehicle | phev          | status, range, location, service, check, charge, image |\n+| BMW Conventional Vehicle            | conv          | status, range, location, service, check, image         |\n+\n+ \n+#### Properties\n+\n+<img align=\"right\" src=\"./doc/properties.png\" width=\"500\" height=\"225\"/>\n+\n+For each vehicle properties are available. \n+Basically 3 types of information are registered as properties\n+\n+* Informations regarding your dealer with address and phone number\n+* Which services are available / not available\n+* Vehicle properties like color, model type, drive train and construction year\n+\n+In the right picture can see in *Services Activated* e.g. the *DoorLock* and *DoorUnlock* services are mentioned. \n+This ensures channel group [Remote Services](#remote-services) is supporting door lock and unlock remote control.\n+\n+In  *Services Supported* the entry *LastDestination* is mentioned.\n+So it's valid to connect channel group [Last Destinations](#destinations) in order to display and select the last navigation destinations.\n+\n+| Property Key       | Property Value      |  Supported Channel Groups    |\n+|--------------------|---------------------|------------------------------|\n+| servicesSupported  | Statistics          | last-trip, lifetime          |\n+| servicesSupported  | LastDestinations    | destinations                 |\n+| servicesActivated  | _list of services_  | remote                       |\n+\n+\n+## Discovery\n+\n+Auto discovery is starting after the bridge towards BMW's ConnectedDrive is created. \n+A list of your registered vehicles is queried and all found things are added in the inbox.\n+Unique identifier is the *Vehicle Identification Number* (VIN). \n+If a thing is already declared in a  _.things_ configuration, discovery won't highlight it again.\n+Properties will be attached to predefined vehicles if the VIN is matching.\n+\n+## Configuration\n+\n+### Bridge Configuration\n+\n+| Parameter       | Type    | Description                                                        |           \n+|-----------------|---------|--------------------------------------------------------------------|\n+| userName        | text    | BMW ConnectedDrive Username                                       |\n+| password        | text    | BMW ConnectedDrive Password                                       |\n+| region          | text    | Select region in order to connect to the appropriate BMW server.   |\n+\n+The region Configuration has 3 different options\n+\n+* _NORTH_AMERICA_\n+* _CHINA_\n+* _ROW_  (Rest of World)\n+\n+### Thing Configuration\n+\n+Same configuration is needed for all things\n+\n+| Parameter       | Type    | Description                           |           \n+|-----------------|---------|---------------------------------------|\n+| vin             | text    | Vehicle Identification Number (VIN)   |\n+| refreshInterval | integer | Refresh Interval in Minutes           |\n+| units           | text    | Unit Selection. See below.            |\n+| imageSize       | integer | Image Size                            |\n+| imageViewport   | text    | Image Viewport                        |\n+\n+The unit configuration has 3 options\n+\n+* _AUTODETECT_ selects miles for US & UK, kilometer otherwise\n+* _METRIC_ selects directly kilometers\n+* _IMPERIAL_ selects directly miles\n+\n+The _imageVieport_ allows to show the vehicle from different angels.\n+Possible options are \n+\n+* _FRONT_\n+* _REAR_\n+* _SIDE_\n+* _DASHBOARD_\n+* _DRIVERDOOR_\n+\n+## Channels\n+\n+There are many channels available for each vehicle. \n+For better overview they are clustered in different channel groups.\n+They differ for each vehicle type, build-in sensors and activated services.\n+\n+\n+### Thing Channel Groups \n+\n+#### Vehicle Status\n+\n+Reflects overall status of the vehicle.\n+\n+* Channel Group ID is **status**\n+* Available for all vehicles\n+* Read-only values\n+\n+| Channel Label             | Channel ID          | Type          | Description                                    |\n+|---------------------------|---------------------|---------------|------------------------------------------------|\n+| Overall Door Status       | doors               | String        | Combined status for all doors                  |\n+| Overall Window Status     | windows             | String        | Combined status for all windows                |\n+| Doors Locked              | lock                | String        | Status if doors are locked or unlocked         |\n+| Next Service Date         | service-date        | DateTime      | Date of upcoming service                       |\n+| Mileage till Next Service | service-mileage     | Number:Length | Mileage till upcoming service                  |\n+| Check Control             | check-control       | String        | Presence of active warning messages            |\n+| Charging Status           | charge              | String        | Only available for phev, bev_rex and bev       |\n+| Last Status Timestamp     | last-update         | DateTime      | Date and time of last status update            |\n+\n+Overall Door Status values\n+\n+* _Closed_ - all doors closed\n+* _Open_ - at least one door is open\n+* _Undef_ - no door data delivered at all\n+\n+Overall Windows Status values\n+\n+* _Closed_ - all windows closed\n+* _Open_ - at least one window is completely open\n+* _Intermediate_ - at least one window is partially open\n+* _Undef_ - no window data delivered at all\n+\n+Check Control values\n+\n+* _Active_ - at least one warning message is active\n+* _Not Active_ - no warning message is active\n+* _Undef_ - no data for warnings delivered\n+\n+Charging Status values\n+\n+* _Charging_\n+* _Error_\n+* _Finished Fully Charged_\n+* _Finished Not Full_\n+* _Invalid_\n+* _Not Charging_\n+* _Charging Goal reached_\n+* _Waiting For Charging_\n+\n+#### Services\n+\n+Group for all upcoming services with description, service date and/or service mileage.\n+If more than one service is scheduled in the future the channel _name_ contains all future services as options.\n+\n+* Channel Group ID is **service**\n+* Available for all vehicles\n+* Read/Write access\n+\n+| Channel Label                  | Channel ID          | Type           | Access     |\n+|--------------------------------|---------------------|----------------|------------|\n+| Service Name                   | name                | String         | Read/Write |\n+| Service Details                | details             | String         | Read       |\n+| Service Date                   | date                | Number         | Read       |\n+| Mileage till Service           | mileage             | Number:Length  | Read       |\n+\n+#### Check Control\n+\n+Group for all current active CheckControl messages.\n+If more than one message is active the channel _name_ contains all active messages as options.\n+\n+* Channel Group ID is **check**\n+* Available for all vehicles\n+* Read/Write access\n+\n+| Channel Label                   | Channel ID          | Type           | Access     |\n+|---------------------------------|---------------------|----------------|------------|\n+| CheckControl Description        | name                | String         | Read/Write |\n+| CheckControl Details            | details             | String         | Read       |\n+| Mileage Occurrence              | mileage             | Number:Length  | Read       |\n+\n+#### Doors Details\n+\n+Detailed status of all doors and windows.\n+\n+* Channel Group ID is **doors**\n+* Available for all vehicles if corresponding sensors are built-in \n+* Read-only values\n+ \n+| Channel Label              | Channel ID              | Type          | \n+|----------------------------|-------------------------|---------------|\n+| Driver Door                | driver-front            | String        |\n+| Driver Door Rear           | driver-rear             | String        |\n+| Passenger Door             | passenger-front         | String        |\n+| Passenger Door Rear        | passenger-rear          | String        |\n+| Trunk                      | trunk                   | String        |\n+| Hood                       | hood                    | String        |\n+| Driver Window              | win-driver-front        | String        |\n+| Driver Rear Window         | win-driver-rear         | String        |\n+| Passenger Window           | win-passenger-front     | String        |\n+| Passenger Rear Window      | win-passenger-rear      | String        |\n+| Rear Window                | win-rear                | String        |\n+| Sunroof                    | sunroof                 | String        |\n+\n+Possible states\n+\n+* _Undef_ - no status data available\n+* _Invalid_ - this door / window isn't applicable for this vehicle\n+* _Closed_ - the door / window is closed\n+* _Open_ - the door / window is open\n+* _Intermediate_ - window in intermediate position, not applicable for doors\n+\n+#### Range Data\n+\n+Based on vehicle type some channels are present or not. \n+Conventional fuel vehicles don't provide *Electric Range* and battery electric vehicles don't show *Fuel Range*.\n+Hybrid vehicles have both and in addition *Hybrid Range*.\n+See description [Range vs Range Radius](#range-vs-range-radius) to get more information.\n+\n+* Channel Group ID is **range**\n+* Availability according to table\n+* Read-only values\n+\n+| Channel Label         | Channel ID            | Type                 | conv | phev | bev_rex | bev |\n+|-----------------------|-----------------------|----------------------|------|------|---------|-----|\n+| Mileage               | mileage               | Number:Length        |  X   |  X   |    X    |  X  |\n+| Fuel Range            | range-fuel            | Number:Length        |  X   |  X   |    X    |     |\n+| Battery Range         | range-electric        | Number:Length        |      |  X   |    X    |  X  | \n+| Hybrid Range          | range-hybrid          | Number:Length        |      |  X   |    X    |     | \n+| Battery Charge Level  | soc                   | Number:Dimensionless |      |  X   |    X    |  X  |\n+| Remaining Fuel        | remaining-fuel        | Number:Volume        |  X   |  X   |    X    |     | \n+| Fuel Range Radius     | range-radius-fuel     | Number:Length        |  X   |  X   |    X    |     | \n+| Electric Range Radius | range-radius-electric | Number:Length        |      |  X   |    X    |  X  | \n+| Hybrid Range Radius   | range-radius-hybrid   | Number:Length        |      |  X   |    X    |     | \n+\n+\n+#### Charge Profile\n+\n+Charging options with date and time for preferred time windows and charging modes.\n+\n+* Channel Group ID is **charge**\n+* Available for electric and hybrid vehicles\n+* Read/Write access for UI. Use [Charge Profile Actions](#charge-profile-action) in rules\n+* There are 3 timers available. Replace *X* with number 1,2 or 3 to target the correct timer\n+\n+| Channel Label                         | Channel Group ID | Channel ID                | Type     | \n+|---------------------------------------|------------------|---------------------------|----------| \n+| Charging Mode for Profile             | charge           | profile-mode              | String   | \n+| Charging Preferences for Profile      | charge           | profile-prefs             | String   | \n+| Charging Window Start Time            | charge           | window-start              | DateTime | \n+| Charging Window Start Time Hour       | charge           | window-start-hour         | Number   | \n+| Charging Window Start Time Minute     | charge           | window-start-minute       | Number   | ", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5NzkwOTg3Mw=="}, "originalCommit": {"oid": "48af48c82562d006b6f2aa35922270f181c885ed"}, "originalPosition": 286}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMjg1NTUxMw==", "bodyText": "Wouldn't it be more reasonable to keep the DateTime Channel?", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r602855513", "createdAt": "2021-03-28T09:28:46Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/README.md", "diffHunk": "@@ -0,0 +1,849 @@\n+# BMW ConnectedDrive Binding\n+\n+<img align=\"right\" src=\"./doc/bmw-connected.png\" width=\"150\" height=\"150\"/>\n+\n+The binding provides a connection between [BMW's ConnectedDrive Portal](https://www.bmw-connecteddrive.com/country-region-select/country-region-selection.html) and openHAB.\n+All vehicles connected to an account will be detected by the discovery with the correct type \n+\n+* Conventional Fuel Vehicle\n+* Plugin-Hybrid Electrical Vehicle \n+* Battery Electric Vehicle with Range Extender\n+* Battery Electric Vehicle \n+\n+In addition properties are attached with information and services provided by this vehicle.\n+The provided data depends on \n+\n+1. the [Thing Type](#things) and \n+2. the [Properties](#properties) mentioned in Services\n+\n+Different channel groups are clustering all informations.\n+Check for each group if it's supported for this Vehicle.\n+\n+Please note **this isn't a real-time binding**. \n+If a door is opened the state isn't transmitted and changed immediately. \n+This isn't a flaw in the binding itself because the state in BMW's own ConnectedDrive App is also updated with some delay. \n+\n+## Supported Things\n+\n+### Bridge\n+\n+The bridge establishes the connection between BMW's ConnectedDrive Portal and openHAB.\n+\n+| Name                       | Bridge Type ID | Description                                                |\n+|----------------------------|----------------|------------------------------------------------------------|\n+| BMW ConnectedDrive Account | account        | Access to BMW ConnectedDrive Portal for a specific user    |\n+\n+\n+### Things\n+\n+Four different vehicle types are provided. \n+They differ in the supported channel groups & channels. \n+Conventional Fuel Vehicles have no _Charging Profile_, Electric Vehicles don't provide a _Fuel Range_. \n+For hybrid vehicles in addition to _Fuel and Electric Range_ the _Hybrid Range_ is shown.\n+ \n+| Name                                | Thing Type ID | Supported Channel Groups                               |\n+|-------------------------------------|---------------|--------------------------------------------------------|\n+| BMW Electric Vehicle                | bev           | status, range, location, service, check, charge, image |\n+| BMW Electric Vehicle with REX       | bev_rex       | status, range, location, service, check, charge, image |\n+| BMW Plug-In-Hybrid Electric Vehicle | phev          | status, range, location, service, check, charge, image |\n+| BMW Conventional Vehicle            | conv          | status, range, location, service, check, image         |\n+\n+ \n+#### Properties\n+\n+<img align=\"right\" src=\"./doc/properties.png\" width=\"500\" height=\"225\"/>\n+\n+For each vehicle properties are available. \n+Basically 3 types of information are registered as properties\n+\n+* Informations regarding your dealer with address and phone number\n+* Which services are available / not available\n+* Vehicle properties like color, model type, drive train and construction year\n+\n+In the right picture can see in *Services Activated* e.g. the *DoorLock* and *DoorUnlock* services are mentioned. \n+This ensures channel group [Remote Services](#remote-services) is supporting door lock and unlock remote control.\n+\n+In  *Services Supported* the entry *LastDestination* is mentioned.\n+So it's valid to connect channel group [Last Destinations](#destinations) in order to display and select the last navigation destinations.\n+\n+| Property Key       | Property Value      |  Supported Channel Groups    |\n+|--------------------|---------------------|------------------------------|\n+| servicesSupported  | Statistics          | last-trip, lifetime          |\n+| servicesSupported  | LastDestinations    | destinations                 |\n+| servicesActivated  | _list of services_  | remote                       |\n+\n+\n+## Discovery\n+\n+Auto discovery is starting after the bridge towards BMW's ConnectedDrive is created. \n+A list of your registered vehicles is queried and all found things are added in the inbox.\n+Unique identifier is the *Vehicle Identification Number* (VIN). \n+If a thing is already declared in a  _.things_ configuration, discovery won't highlight it again.\n+Properties will be attached to predefined vehicles if the VIN is matching.\n+\n+## Configuration\n+\n+### Bridge Configuration\n+\n+| Parameter       | Type    | Description                                                        |           \n+|-----------------|---------|--------------------------------------------------------------------|\n+| userName        | text    | BMW ConnectedDrive Username                                       |\n+| password        | text    | BMW ConnectedDrive Password                                       |\n+| region          | text    | Select region in order to connect to the appropriate BMW server.   |\n+\n+The region Configuration has 3 different options\n+\n+* _NORTH_AMERICA_\n+* _CHINA_\n+* _ROW_  (Rest of World)\n+\n+### Thing Configuration\n+\n+Same configuration is needed for all things\n+\n+| Parameter       | Type    | Description                           |           \n+|-----------------|---------|---------------------------------------|\n+| vin             | text    | Vehicle Identification Number (VIN)   |\n+| refreshInterval | integer | Refresh Interval in Minutes           |\n+| units           | text    | Unit Selection. See below.            |\n+| imageSize       | integer | Image Size                            |\n+| imageViewport   | text    | Image Viewport                        |\n+\n+The unit configuration has 3 options\n+\n+* _AUTODETECT_ selects miles for US & UK, kilometer otherwise\n+* _METRIC_ selects directly kilometers\n+* _IMPERIAL_ selects directly miles\n+\n+The _imageVieport_ allows to show the vehicle from different angels.\n+Possible options are \n+\n+* _FRONT_\n+* _REAR_\n+* _SIDE_\n+* _DASHBOARD_\n+* _DRIVERDOOR_\n+\n+## Channels\n+\n+There are many channels available for each vehicle. \n+For better overview they are clustered in different channel groups.\n+They differ for each vehicle type, build-in sensors and activated services.\n+\n+\n+### Thing Channel Groups \n+\n+#### Vehicle Status\n+\n+Reflects overall status of the vehicle.\n+\n+* Channel Group ID is **status**\n+* Available for all vehicles\n+* Read-only values\n+\n+| Channel Label             | Channel ID          | Type          | Description                                    |\n+|---------------------------|---------------------|---------------|------------------------------------------------|\n+| Overall Door Status       | doors               | String        | Combined status for all doors                  |\n+| Overall Window Status     | windows             | String        | Combined status for all windows                |\n+| Doors Locked              | lock                | String        | Status if doors are locked or unlocked         |\n+| Next Service Date         | service-date        | DateTime      | Date of upcoming service                       |\n+| Mileage till Next Service | service-mileage     | Number:Length | Mileage till upcoming service                  |\n+| Check Control             | check-control       | String        | Presence of active warning messages            |\n+| Charging Status           | charge              | String        | Only available for phev, bev_rex and bev       |\n+| Last Status Timestamp     | last-update         | DateTime      | Date and time of last status update            |\n+\n+Overall Door Status values\n+\n+* _Closed_ - all doors closed\n+* _Open_ - at least one door is open\n+* _Undef_ - no door data delivered at all\n+\n+Overall Windows Status values\n+\n+* _Closed_ - all windows closed\n+* _Open_ - at least one window is completely open\n+* _Intermediate_ - at least one window is partially open\n+* _Undef_ - no window data delivered at all\n+\n+Check Control values\n+\n+* _Active_ - at least one warning message is active\n+* _Not Active_ - no warning message is active\n+* _Undef_ - no data for warnings delivered\n+\n+Charging Status values\n+\n+* _Charging_\n+* _Error_\n+* _Finished Fully Charged_\n+* _Finished Not Full_\n+* _Invalid_\n+* _Not Charging_\n+* _Charging Goal reached_\n+* _Waiting For Charging_\n+\n+#### Services\n+\n+Group for all upcoming services with description, service date and/or service mileage.\n+If more than one service is scheduled in the future the channel _name_ contains all future services as options.\n+\n+* Channel Group ID is **service**\n+* Available for all vehicles\n+* Read/Write access\n+\n+| Channel Label                  | Channel ID          | Type           | Access     |\n+|--------------------------------|---------------------|----------------|------------|\n+| Service Name                   | name                | String         | Read/Write |\n+| Service Details                | details             | String         | Read       |\n+| Service Date                   | date                | Number         | Read       |\n+| Mileage till Service           | mileage             | Number:Length  | Read       |\n+\n+#### Check Control\n+\n+Group for all current active CheckControl messages.\n+If more than one message is active the channel _name_ contains all active messages as options.\n+\n+* Channel Group ID is **check**\n+* Available for all vehicles\n+* Read/Write access\n+\n+| Channel Label                   | Channel ID          | Type           | Access     |\n+|---------------------------------|---------------------|----------------|------------|\n+| CheckControl Description        | name                | String         | Read/Write |\n+| CheckControl Details            | details             | String         | Read       |\n+| Mileage Occurrence              | mileage             | Number:Length  | Read       |\n+\n+#### Doors Details\n+\n+Detailed status of all doors and windows.\n+\n+* Channel Group ID is **doors**\n+* Available for all vehicles if corresponding sensors are built-in \n+* Read-only values\n+ \n+| Channel Label              | Channel ID              | Type          | \n+|----------------------------|-------------------------|---------------|\n+| Driver Door                | driver-front            | String        |\n+| Driver Door Rear           | driver-rear             | String        |\n+| Passenger Door             | passenger-front         | String        |\n+| Passenger Door Rear        | passenger-rear          | String        |\n+| Trunk                      | trunk                   | String        |\n+| Hood                       | hood                    | String        |\n+| Driver Window              | win-driver-front        | String        |\n+| Driver Rear Window         | win-driver-rear         | String        |\n+| Passenger Window           | win-passenger-front     | String        |\n+| Passenger Rear Window      | win-passenger-rear      | String        |\n+| Rear Window                | win-rear                | String        |\n+| Sunroof                    | sunroof                 | String        |\n+\n+Possible states\n+\n+* _Undef_ - no status data available\n+* _Invalid_ - this door / window isn't applicable for this vehicle\n+* _Closed_ - the door / window is closed\n+* _Open_ - the door / window is open\n+* _Intermediate_ - window in intermediate position, not applicable for doors\n+\n+#### Range Data\n+\n+Based on vehicle type some channels are present or not. \n+Conventional fuel vehicles don't provide *Electric Range* and battery electric vehicles don't show *Fuel Range*.\n+Hybrid vehicles have both and in addition *Hybrid Range*.\n+See description [Range vs Range Radius](#range-vs-range-radius) to get more information.\n+\n+* Channel Group ID is **range**\n+* Availability according to table\n+* Read-only values\n+\n+| Channel Label         | Channel ID            | Type                 | conv | phev | bev_rex | bev |\n+|-----------------------|-----------------------|----------------------|------|------|---------|-----|\n+| Mileage               | mileage               | Number:Length        |  X   |  X   |    X    |  X  |\n+| Fuel Range            | range-fuel            | Number:Length        |  X   |  X   |    X    |     |\n+| Battery Range         | range-electric        | Number:Length        |      |  X   |    X    |  X  | \n+| Hybrid Range          | range-hybrid          | Number:Length        |      |  X   |    X    |     | \n+| Battery Charge Level  | soc                   | Number:Dimensionless |      |  X   |    X    |  X  |\n+| Remaining Fuel        | remaining-fuel        | Number:Volume        |  X   |  X   |    X    |     | \n+| Fuel Range Radius     | range-radius-fuel     | Number:Length        |  X   |  X   |    X    |     | \n+| Electric Range Radius | range-radius-electric | Number:Length        |      |  X   |    X    |  X  | \n+| Hybrid Range Radius   | range-radius-hybrid   | Number:Length        |      |  X   |    X    |     | \n+\n+\n+#### Charge Profile\n+\n+Charging options with date and time for preferred time windows and charging modes.\n+\n+* Channel Group ID is **charge**\n+* Available for electric and hybrid vehicles\n+* Read/Write access for UI. Use [Charge Profile Actions](#charge-profile-action) in rules\n+* There are 3 timers available. Replace *X* with number 1,2 or 3 to target the correct timer\n+\n+| Channel Label                         | Channel Group ID | Channel ID                | Type     | \n+|---------------------------------------|------------------|---------------------------|----------| \n+| Charging Mode for Profile             | charge           | profile-mode              | String   | \n+| Charging Preferences for Profile      | charge           | profile-prefs             | String   | \n+| Charging Window Start Time            | charge           | window-start              | DateTime | \n+| Charging Window Start Time Hour       | charge           | window-start-hour         | Number   | \n+| Charging Window Start Time Minute     | charge           | window-start-minute       | Number   | ", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5NzkwOTg3Mw=="}, "originalCommit": {"oid": "48af48c82562d006b6f2aa35922270f181c885ed"}, "originalPosition": 286}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMjg2MzY2NA==", "bodyText": "Generaly speaking I agree on keeping the DateTime-Channel (needs to be included in the command-handling-code though). I did introduce the minute and hour channels because you cannot easily update a dateTime from a simple sitemap (From my understanding you can do using a minute and hour-item plus a rule).\nYou can do direct updates of a DateTime-Channel using a standard OH3-widget. The usability of the stock widget is not really good, but I'd expect this widget can easily be improved independent from this particular usecase.", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r602863664", "createdAt": "2021-03-28T10:53:35Z", "author": {"login": "ntruchsess"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/README.md", "diffHunk": "@@ -0,0 +1,849 @@\n+# BMW ConnectedDrive Binding\n+\n+<img align=\"right\" src=\"./doc/bmw-connected.png\" width=\"150\" height=\"150\"/>\n+\n+The binding provides a connection between [BMW's ConnectedDrive Portal](https://www.bmw-connecteddrive.com/country-region-select/country-region-selection.html) and openHAB.\n+All vehicles connected to an account will be detected by the discovery with the correct type \n+\n+* Conventional Fuel Vehicle\n+* Plugin-Hybrid Electrical Vehicle \n+* Battery Electric Vehicle with Range Extender\n+* Battery Electric Vehicle \n+\n+In addition properties are attached with information and services provided by this vehicle.\n+The provided data depends on \n+\n+1. the [Thing Type](#things) and \n+2. the [Properties](#properties) mentioned in Services\n+\n+Different channel groups are clustering all informations.\n+Check for each group if it's supported for this Vehicle.\n+\n+Please note **this isn't a real-time binding**. \n+If a door is opened the state isn't transmitted and changed immediately. \n+This isn't a flaw in the binding itself because the state in BMW's own ConnectedDrive App is also updated with some delay. \n+\n+## Supported Things\n+\n+### Bridge\n+\n+The bridge establishes the connection between BMW's ConnectedDrive Portal and openHAB.\n+\n+| Name                       | Bridge Type ID | Description                                                |\n+|----------------------------|----------------|------------------------------------------------------------|\n+| BMW ConnectedDrive Account | account        | Access to BMW ConnectedDrive Portal for a specific user    |\n+\n+\n+### Things\n+\n+Four different vehicle types are provided. \n+They differ in the supported channel groups & channels. \n+Conventional Fuel Vehicles have no _Charging Profile_, Electric Vehicles don't provide a _Fuel Range_. \n+For hybrid vehicles in addition to _Fuel and Electric Range_ the _Hybrid Range_ is shown.\n+ \n+| Name                                | Thing Type ID | Supported Channel Groups                               |\n+|-------------------------------------|---------------|--------------------------------------------------------|\n+| BMW Electric Vehicle                | bev           | status, range, location, service, check, charge, image |\n+| BMW Electric Vehicle with REX       | bev_rex       | status, range, location, service, check, charge, image |\n+| BMW Plug-In-Hybrid Electric Vehicle | phev          | status, range, location, service, check, charge, image |\n+| BMW Conventional Vehicle            | conv          | status, range, location, service, check, image         |\n+\n+ \n+#### Properties\n+\n+<img align=\"right\" src=\"./doc/properties.png\" width=\"500\" height=\"225\"/>\n+\n+For each vehicle properties are available. \n+Basically 3 types of information are registered as properties\n+\n+* Informations regarding your dealer with address and phone number\n+* Which services are available / not available\n+* Vehicle properties like color, model type, drive train and construction year\n+\n+In the right picture can see in *Services Activated* e.g. the *DoorLock* and *DoorUnlock* services are mentioned. \n+This ensures channel group [Remote Services](#remote-services) is supporting door lock and unlock remote control.\n+\n+In  *Services Supported* the entry *LastDestination* is mentioned.\n+So it's valid to connect channel group [Last Destinations](#destinations) in order to display and select the last navigation destinations.\n+\n+| Property Key       | Property Value      |  Supported Channel Groups    |\n+|--------------------|---------------------|------------------------------|\n+| servicesSupported  | Statistics          | last-trip, lifetime          |\n+| servicesSupported  | LastDestinations    | destinations                 |\n+| servicesActivated  | _list of services_  | remote                       |\n+\n+\n+## Discovery\n+\n+Auto discovery is starting after the bridge towards BMW's ConnectedDrive is created. \n+A list of your registered vehicles is queried and all found things are added in the inbox.\n+Unique identifier is the *Vehicle Identification Number* (VIN). \n+If a thing is already declared in a  _.things_ configuration, discovery won't highlight it again.\n+Properties will be attached to predefined vehicles if the VIN is matching.\n+\n+## Configuration\n+\n+### Bridge Configuration\n+\n+| Parameter       | Type    | Description                                                        |           \n+|-----------------|---------|--------------------------------------------------------------------|\n+| userName        | text    | BMW ConnectedDrive Username                                       |\n+| password        | text    | BMW ConnectedDrive Password                                       |\n+| region          | text    | Select region in order to connect to the appropriate BMW server.   |\n+\n+The region Configuration has 3 different options\n+\n+* _NORTH_AMERICA_\n+* _CHINA_\n+* _ROW_  (Rest of World)\n+\n+### Thing Configuration\n+\n+Same configuration is needed for all things\n+\n+| Parameter       | Type    | Description                           |           \n+|-----------------|---------|---------------------------------------|\n+| vin             | text    | Vehicle Identification Number (VIN)   |\n+| refreshInterval | integer | Refresh Interval in Minutes           |\n+| units           | text    | Unit Selection. See below.            |\n+| imageSize       | integer | Image Size                            |\n+| imageViewport   | text    | Image Viewport                        |\n+\n+The unit configuration has 3 options\n+\n+* _AUTODETECT_ selects miles for US & UK, kilometer otherwise\n+* _METRIC_ selects directly kilometers\n+* _IMPERIAL_ selects directly miles\n+\n+The _imageVieport_ allows to show the vehicle from different angels.\n+Possible options are \n+\n+* _FRONT_\n+* _REAR_\n+* _SIDE_\n+* _DASHBOARD_\n+* _DRIVERDOOR_\n+\n+## Channels\n+\n+There are many channels available for each vehicle. \n+For better overview they are clustered in different channel groups.\n+They differ for each vehicle type, build-in sensors and activated services.\n+\n+\n+### Thing Channel Groups \n+\n+#### Vehicle Status\n+\n+Reflects overall status of the vehicle.\n+\n+* Channel Group ID is **status**\n+* Available for all vehicles\n+* Read-only values\n+\n+| Channel Label             | Channel ID          | Type          | Description                                    |\n+|---------------------------|---------------------|---------------|------------------------------------------------|\n+| Overall Door Status       | doors               | String        | Combined status for all doors                  |\n+| Overall Window Status     | windows             | String        | Combined status for all windows                |\n+| Doors Locked              | lock                | String        | Status if doors are locked or unlocked         |\n+| Next Service Date         | service-date        | DateTime      | Date of upcoming service                       |\n+| Mileage till Next Service | service-mileage     | Number:Length | Mileage till upcoming service                  |\n+| Check Control             | check-control       | String        | Presence of active warning messages            |\n+| Charging Status           | charge              | String        | Only available for phev, bev_rex and bev       |\n+| Last Status Timestamp     | last-update         | DateTime      | Date and time of last status update            |\n+\n+Overall Door Status values\n+\n+* _Closed_ - all doors closed\n+* _Open_ - at least one door is open\n+* _Undef_ - no door data delivered at all\n+\n+Overall Windows Status values\n+\n+* _Closed_ - all windows closed\n+* _Open_ - at least one window is completely open\n+* _Intermediate_ - at least one window is partially open\n+* _Undef_ - no window data delivered at all\n+\n+Check Control values\n+\n+* _Active_ - at least one warning message is active\n+* _Not Active_ - no warning message is active\n+* _Undef_ - no data for warnings delivered\n+\n+Charging Status values\n+\n+* _Charging_\n+* _Error_\n+* _Finished Fully Charged_\n+* _Finished Not Full_\n+* _Invalid_\n+* _Not Charging_\n+* _Charging Goal reached_\n+* _Waiting For Charging_\n+\n+#### Services\n+\n+Group for all upcoming services with description, service date and/or service mileage.\n+If more than one service is scheduled in the future the channel _name_ contains all future services as options.\n+\n+* Channel Group ID is **service**\n+* Available for all vehicles\n+* Read/Write access\n+\n+| Channel Label                  | Channel ID          | Type           | Access     |\n+|--------------------------------|---------------------|----------------|------------|\n+| Service Name                   | name                | String         | Read/Write |\n+| Service Details                | details             | String         | Read       |\n+| Service Date                   | date                | Number         | Read       |\n+| Mileage till Service           | mileage             | Number:Length  | Read       |\n+\n+#### Check Control\n+\n+Group for all current active CheckControl messages.\n+If more than one message is active the channel _name_ contains all active messages as options.\n+\n+* Channel Group ID is **check**\n+* Available for all vehicles\n+* Read/Write access\n+\n+| Channel Label                   | Channel ID          | Type           | Access     |\n+|---------------------------------|---------------------|----------------|------------|\n+| CheckControl Description        | name                | String         | Read/Write |\n+| CheckControl Details            | details             | String         | Read       |\n+| Mileage Occurrence              | mileage             | Number:Length  | Read       |\n+\n+#### Doors Details\n+\n+Detailed status of all doors and windows.\n+\n+* Channel Group ID is **doors**\n+* Available for all vehicles if corresponding sensors are built-in \n+* Read-only values\n+ \n+| Channel Label              | Channel ID              | Type          | \n+|----------------------------|-------------------------|---------------|\n+| Driver Door                | driver-front            | String        |\n+| Driver Door Rear           | driver-rear             | String        |\n+| Passenger Door             | passenger-front         | String        |\n+| Passenger Door Rear        | passenger-rear          | String        |\n+| Trunk                      | trunk                   | String        |\n+| Hood                       | hood                    | String        |\n+| Driver Window              | win-driver-front        | String        |\n+| Driver Rear Window         | win-driver-rear         | String        |\n+| Passenger Window           | win-passenger-front     | String        |\n+| Passenger Rear Window      | win-passenger-rear      | String        |\n+| Rear Window                | win-rear                | String        |\n+| Sunroof                    | sunroof                 | String        |\n+\n+Possible states\n+\n+* _Undef_ - no status data available\n+* _Invalid_ - this door / window isn't applicable for this vehicle\n+* _Closed_ - the door / window is closed\n+* _Open_ - the door / window is open\n+* _Intermediate_ - window in intermediate position, not applicable for doors\n+\n+#### Range Data\n+\n+Based on vehicle type some channels are present or not. \n+Conventional fuel vehicles don't provide *Electric Range* and battery electric vehicles don't show *Fuel Range*.\n+Hybrid vehicles have both and in addition *Hybrid Range*.\n+See description [Range vs Range Radius](#range-vs-range-radius) to get more information.\n+\n+* Channel Group ID is **range**\n+* Availability according to table\n+* Read-only values\n+\n+| Channel Label         | Channel ID            | Type                 | conv | phev | bev_rex | bev |\n+|-----------------------|-----------------------|----------------------|------|------|---------|-----|\n+| Mileage               | mileage               | Number:Length        |  X   |  X   |    X    |  X  |\n+| Fuel Range            | range-fuel            | Number:Length        |  X   |  X   |    X    |     |\n+| Battery Range         | range-electric        | Number:Length        |      |  X   |    X    |  X  | \n+| Hybrid Range          | range-hybrid          | Number:Length        |      |  X   |    X    |     | \n+| Battery Charge Level  | soc                   | Number:Dimensionless |      |  X   |    X    |  X  |\n+| Remaining Fuel        | remaining-fuel        | Number:Volume        |  X   |  X   |    X    |     | \n+| Fuel Range Radius     | range-radius-fuel     | Number:Length        |  X   |  X   |    X    |     | \n+| Electric Range Radius | range-radius-electric | Number:Length        |      |  X   |    X    |  X  | \n+| Hybrid Range Radius   | range-radius-hybrid   | Number:Length        |      |  X   |    X    |     | \n+\n+\n+#### Charge Profile\n+\n+Charging options with date and time for preferred time windows and charging modes.\n+\n+* Channel Group ID is **charge**\n+* Available for electric and hybrid vehicles\n+* Read/Write access for UI. Use [Charge Profile Actions](#charge-profile-action) in rules\n+* There are 3 timers available. Replace *X* with number 1,2 or 3 to target the correct timer\n+\n+| Channel Label                         | Channel Group ID | Channel ID                | Type     | \n+|---------------------------------------|------------------|---------------------------|----------| \n+| Charging Mode for Profile             | charge           | profile-mode              | String   | \n+| Charging Preferences for Profile      | charge           | profile-prefs             | String   | \n+| Charging Window Start Time            | charge           | window-start              | DateTime | \n+| Charging Window Start Time Hour       | charge           | window-start-hour         | Number   | \n+| Charging Window Start Time Minute     | charge           | window-start-minute       | Number   | ", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5NzkwOTg3Mw=="}, "originalCommit": {"oid": "48af48c82562d006b6f2aa35922270f181c885ed"}, "originalPosition": 286}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwNTc3MjU0MQ==", "bodyText": "What's your suggestion @ntruchsess ? Shall we remove hour & minute channels?\nIn OH3 UI you're able to define some options so you can put in e.g. hourly adaptions. Manual text input I didn't see so far", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r605772541", "createdAt": "2021-04-01T16:00:52Z", "author": {"login": "weymann"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/README.md", "diffHunk": "@@ -0,0 +1,849 @@\n+# BMW ConnectedDrive Binding\n+\n+<img align=\"right\" src=\"./doc/bmw-connected.png\" width=\"150\" height=\"150\"/>\n+\n+The binding provides a connection between [BMW's ConnectedDrive Portal](https://www.bmw-connecteddrive.com/country-region-select/country-region-selection.html) and openHAB.\n+All vehicles connected to an account will be detected by the discovery with the correct type \n+\n+* Conventional Fuel Vehicle\n+* Plugin-Hybrid Electrical Vehicle \n+* Battery Electric Vehicle with Range Extender\n+* Battery Electric Vehicle \n+\n+In addition properties are attached with information and services provided by this vehicle.\n+The provided data depends on \n+\n+1. the [Thing Type](#things) and \n+2. the [Properties](#properties) mentioned in Services\n+\n+Different channel groups are clustering all informations.\n+Check for each group if it's supported for this Vehicle.\n+\n+Please note **this isn't a real-time binding**. \n+If a door is opened the state isn't transmitted and changed immediately. \n+This isn't a flaw in the binding itself because the state in BMW's own ConnectedDrive App is also updated with some delay. \n+\n+## Supported Things\n+\n+### Bridge\n+\n+The bridge establishes the connection between BMW's ConnectedDrive Portal and openHAB.\n+\n+| Name                       | Bridge Type ID | Description                                                |\n+|----------------------------|----------------|------------------------------------------------------------|\n+| BMW ConnectedDrive Account | account        | Access to BMW ConnectedDrive Portal for a specific user    |\n+\n+\n+### Things\n+\n+Four different vehicle types are provided. \n+They differ in the supported channel groups & channels. \n+Conventional Fuel Vehicles have no _Charging Profile_, Electric Vehicles don't provide a _Fuel Range_. \n+For hybrid vehicles in addition to _Fuel and Electric Range_ the _Hybrid Range_ is shown.\n+ \n+| Name                                | Thing Type ID | Supported Channel Groups                               |\n+|-------------------------------------|---------------|--------------------------------------------------------|\n+| BMW Electric Vehicle                | bev           | status, range, location, service, check, charge, image |\n+| BMW Electric Vehicle with REX       | bev_rex       | status, range, location, service, check, charge, image |\n+| BMW Plug-In-Hybrid Electric Vehicle | phev          | status, range, location, service, check, charge, image |\n+| BMW Conventional Vehicle            | conv          | status, range, location, service, check, image         |\n+\n+ \n+#### Properties\n+\n+<img align=\"right\" src=\"./doc/properties.png\" width=\"500\" height=\"225\"/>\n+\n+For each vehicle properties are available. \n+Basically 3 types of information are registered as properties\n+\n+* Informations regarding your dealer with address and phone number\n+* Which services are available / not available\n+* Vehicle properties like color, model type, drive train and construction year\n+\n+In the right picture can see in *Services Activated* e.g. the *DoorLock* and *DoorUnlock* services are mentioned. \n+This ensures channel group [Remote Services](#remote-services) is supporting door lock and unlock remote control.\n+\n+In  *Services Supported* the entry *LastDestination* is mentioned.\n+So it's valid to connect channel group [Last Destinations](#destinations) in order to display and select the last navigation destinations.\n+\n+| Property Key       | Property Value      |  Supported Channel Groups    |\n+|--------------------|---------------------|------------------------------|\n+| servicesSupported  | Statistics          | last-trip, lifetime          |\n+| servicesSupported  | LastDestinations    | destinations                 |\n+| servicesActivated  | _list of services_  | remote                       |\n+\n+\n+## Discovery\n+\n+Auto discovery is starting after the bridge towards BMW's ConnectedDrive is created. \n+A list of your registered vehicles is queried and all found things are added in the inbox.\n+Unique identifier is the *Vehicle Identification Number* (VIN). \n+If a thing is already declared in a  _.things_ configuration, discovery won't highlight it again.\n+Properties will be attached to predefined vehicles if the VIN is matching.\n+\n+## Configuration\n+\n+### Bridge Configuration\n+\n+| Parameter       | Type    | Description                                                        |           \n+|-----------------|---------|--------------------------------------------------------------------|\n+| userName        | text    | BMW ConnectedDrive Username                                       |\n+| password        | text    | BMW ConnectedDrive Password                                       |\n+| region          | text    | Select region in order to connect to the appropriate BMW server.   |\n+\n+The region Configuration has 3 different options\n+\n+* _NORTH_AMERICA_\n+* _CHINA_\n+* _ROW_  (Rest of World)\n+\n+### Thing Configuration\n+\n+Same configuration is needed for all things\n+\n+| Parameter       | Type    | Description                           |           \n+|-----------------|---------|---------------------------------------|\n+| vin             | text    | Vehicle Identification Number (VIN)   |\n+| refreshInterval | integer | Refresh Interval in Minutes           |\n+| units           | text    | Unit Selection. See below.            |\n+| imageSize       | integer | Image Size                            |\n+| imageViewport   | text    | Image Viewport                        |\n+\n+The unit configuration has 3 options\n+\n+* _AUTODETECT_ selects miles for US & UK, kilometer otherwise\n+* _METRIC_ selects directly kilometers\n+* _IMPERIAL_ selects directly miles\n+\n+The _imageVieport_ allows to show the vehicle from different angels.\n+Possible options are \n+\n+* _FRONT_\n+* _REAR_\n+* _SIDE_\n+* _DASHBOARD_\n+* _DRIVERDOOR_\n+\n+## Channels\n+\n+There are many channels available for each vehicle. \n+For better overview they are clustered in different channel groups.\n+They differ for each vehicle type, build-in sensors and activated services.\n+\n+\n+### Thing Channel Groups \n+\n+#### Vehicle Status\n+\n+Reflects overall status of the vehicle.\n+\n+* Channel Group ID is **status**\n+* Available for all vehicles\n+* Read-only values\n+\n+| Channel Label             | Channel ID          | Type          | Description                                    |\n+|---------------------------|---------------------|---------------|------------------------------------------------|\n+| Overall Door Status       | doors               | String        | Combined status for all doors                  |\n+| Overall Window Status     | windows             | String        | Combined status for all windows                |\n+| Doors Locked              | lock                | String        | Status if doors are locked or unlocked         |\n+| Next Service Date         | service-date        | DateTime      | Date of upcoming service                       |\n+| Mileage till Next Service | service-mileage     | Number:Length | Mileage till upcoming service                  |\n+| Check Control             | check-control       | String        | Presence of active warning messages            |\n+| Charging Status           | charge              | String        | Only available for phev, bev_rex and bev       |\n+| Last Status Timestamp     | last-update         | DateTime      | Date and time of last status update            |\n+\n+Overall Door Status values\n+\n+* _Closed_ - all doors closed\n+* _Open_ - at least one door is open\n+* _Undef_ - no door data delivered at all\n+\n+Overall Windows Status values\n+\n+* _Closed_ - all windows closed\n+* _Open_ - at least one window is completely open\n+* _Intermediate_ - at least one window is partially open\n+* _Undef_ - no window data delivered at all\n+\n+Check Control values\n+\n+* _Active_ - at least one warning message is active\n+* _Not Active_ - no warning message is active\n+* _Undef_ - no data for warnings delivered\n+\n+Charging Status values\n+\n+* _Charging_\n+* _Error_\n+* _Finished Fully Charged_\n+* _Finished Not Full_\n+* _Invalid_\n+* _Not Charging_\n+* _Charging Goal reached_\n+* _Waiting For Charging_\n+\n+#### Services\n+\n+Group for all upcoming services with description, service date and/or service mileage.\n+If more than one service is scheduled in the future the channel _name_ contains all future services as options.\n+\n+* Channel Group ID is **service**\n+* Available for all vehicles\n+* Read/Write access\n+\n+| Channel Label                  | Channel ID          | Type           | Access     |\n+|--------------------------------|---------------------|----------------|------------|\n+| Service Name                   | name                | String         | Read/Write |\n+| Service Details                | details             | String         | Read       |\n+| Service Date                   | date                | Number         | Read       |\n+| Mileage till Service           | mileage             | Number:Length  | Read       |\n+\n+#### Check Control\n+\n+Group for all current active CheckControl messages.\n+If more than one message is active the channel _name_ contains all active messages as options.\n+\n+* Channel Group ID is **check**\n+* Available for all vehicles\n+* Read/Write access\n+\n+| Channel Label                   | Channel ID          | Type           | Access     |\n+|---------------------------------|---------------------|----------------|------------|\n+| CheckControl Description        | name                | String         | Read/Write |\n+| CheckControl Details            | details             | String         | Read       |\n+| Mileage Occurrence              | mileage             | Number:Length  | Read       |\n+\n+#### Doors Details\n+\n+Detailed status of all doors and windows.\n+\n+* Channel Group ID is **doors**\n+* Available for all vehicles if corresponding sensors are built-in \n+* Read-only values\n+ \n+| Channel Label              | Channel ID              | Type          | \n+|----------------------------|-------------------------|---------------|\n+| Driver Door                | driver-front            | String        |\n+| Driver Door Rear           | driver-rear             | String        |\n+| Passenger Door             | passenger-front         | String        |\n+| Passenger Door Rear        | passenger-rear          | String        |\n+| Trunk                      | trunk                   | String        |\n+| Hood                       | hood                    | String        |\n+| Driver Window              | win-driver-front        | String        |\n+| Driver Rear Window         | win-driver-rear         | String        |\n+| Passenger Window           | win-passenger-front     | String        |\n+| Passenger Rear Window      | win-passenger-rear      | String        |\n+| Rear Window                | win-rear                | String        |\n+| Sunroof                    | sunroof                 | String        |\n+\n+Possible states\n+\n+* _Undef_ - no status data available\n+* _Invalid_ - this door / window isn't applicable for this vehicle\n+* _Closed_ - the door / window is closed\n+* _Open_ - the door / window is open\n+* _Intermediate_ - window in intermediate position, not applicable for doors\n+\n+#### Range Data\n+\n+Based on vehicle type some channels are present or not. \n+Conventional fuel vehicles don't provide *Electric Range* and battery electric vehicles don't show *Fuel Range*.\n+Hybrid vehicles have both and in addition *Hybrid Range*.\n+See description [Range vs Range Radius](#range-vs-range-radius) to get more information.\n+\n+* Channel Group ID is **range**\n+* Availability according to table\n+* Read-only values\n+\n+| Channel Label         | Channel ID            | Type                 | conv | phev | bev_rex | bev |\n+|-----------------------|-----------------------|----------------------|------|------|---------|-----|\n+| Mileage               | mileage               | Number:Length        |  X   |  X   |    X    |  X  |\n+| Fuel Range            | range-fuel            | Number:Length        |  X   |  X   |    X    |     |\n+| Battery Range         | range-electric        | Number:Length        |      |  X   |    X    |  X  | \n+| Hybrid Range          | range-hybrid          | Number:Length        |      |  X   |    X    |     | \n+| Battery Charge Level  | soc                   | Number:Dimensionless |      |  X   |    X    |  X  |\n+| Remaining Fuel        | remaining-fuel        | Number:Volume        |  X   |  X   |    X    |     | \n+| Fuel Range Radius     | range-radius-fuel     | Number:Length        |  X   |  X   |    X    |     | \n+| Electric Range Radius | range-radius-electric | Number:Length        |      |  X   |    X    |  X  | \n+| Hybrid Range Radius   | range-radius-hybrid   | Number:Length        |      |  X   |    X    |     | \n+\n+\n+#### Charge Profile\n+\n+Charging options with date and time for preferred time windows and charging modes.\n+\n+* Channel Group ID is **charge**\n+* Available for electric and hybrid vehicles\n+* Read/Write access for UI. Use [Charge Profile Actions](#charge-profile-action) in rules\n+* There are 3 timers available. Replace *X* with number 1,2 or 3 to target the correct timer\n+\n+| Channel Label                         | Channel Group ID | Channel ID                | Type     | \n+|---------------------------------------|------------------|---------------------------|----------| \n+| Charging Mode for Profile             | charge           | profile-mode              | String   | \n+| Charging Preferences for Profile      | charge           | profile-prefs             | String   | \n+| Charging Window Start Time            | charge           | window-start              | DateTime | \n+| Charging Window Start Time Hour       | charge           | window-start-hour         | Number   | \n+| Charging Window Start Time Minute     | charge           | window-start-minute       | Number   | ", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5NzkwOTg3Mw=="}, "originalCommit": {"oid": "48af48c82562d006b6f2aa35922270f181c885ed"}, "originalPosition": 286}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwNjY1Mjg4Mg==", "bodyText": "I suggest keeping the editable DateTime-channels and remove the hour and minute channels\nOne can do manual text-input in the OH3 UI. Here is an example that combines formated output and manual input:\n- component: oh-list-card\n  config:\n    mediaList: true\n  slots:\n    default:\n      - component: oh-list-item\n        config:\n          subtitle: =dayjs(items.SomeDateTimeItem.state).format('HH:mm')\n          title: ATestItem\n          icon: oh:time\n      - component: oh-input\n        config:\n          type: time\n          inputmode: text\n          placeholder: hh:mm\n          sendButton: true\n          validate: true\n          item: SomeDateTimeItem\n          outline: false\n\n\nthe redering of oh-input, type time is platform-dependent (on Android you get the native clock-style time-edit widget, in Chromium on Linux it results in a simple text-input). This is not very pretty, but so far it works and I'm pretty sure it can (and will) be improved.", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r606652882", "createdAt": "2021-04-03T11:22:57Z", "author": {"login": "ntruchsess"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/README.md", "diffHunk": "@@ -0,0 +1,849 @@\n+# BMW ConnectedDrive Binding\n+\n+<img align=\"right\" src=\"./doc/bmw-connected.png\" width=\"150\" height=\"150\"/>\n+\n+The binding provides a connection between [BMW's ConnectedDrive Portal](https://www.bmw-connecteddrive.com/country-region-select/country-region-selection.html) and openHAB.\n+All vehicles connected to an account will be detected by the discovery with the correct type \n+\n+* Conventional Fuel Vehicle\n+* Plugin-Hybrid Electrical Vehicle \n+* Battery Electric Vehicle with Range Extender\n+* Battery Electric Vehicle \n+\n+In addition properties are attached with information and services provided by this vehicle.\n+The provided data depends on \n+\n+1. the [Thing Type](#things) and \n+2. the [Properties](#properties) mentioned in Services\n+\n+Different channel groups are clustering all informations.\n+Check for each group if it's supported for this Vehicle.\n+\n+Please note **this isn't a real-time binding**. \n+If a door is opened the state isn't transmitted and changed immediately. \n+This isn't a flaw in the binding itself because the state in BMW's own ConnectedDrive App is also updated with some delay. \n+\n+## Supported Things\n+\n+### Bridge\n+\n+The bridge establishes the connection between BMW's ConnectedDrive Portal and openHAB.\n+\n+| Name                       | Bridge Type ID | Description                                                |\n+|----------------------------|----------------|------------------------------------------------------------|\n+| BMW ConnectedDrive Account | account        | Access to BMW ConnectedDrive Portal for a specific user    |\n+\n+\n+### Things\n+\n+Four different vehicle types are provided. \n+They differ in the supported channel groups & channels. \n+Conventional Fuel Vehicles have no _Charging Profile_, Electric Vehicles don't provide a _Fuel Range_. \n+For hybrid vehicles in addition to _Fuel and Electric Range_ the _Hybrid Range_ is shown.\n+ \n+| Name                                | Thing Type ID | Supported Channel Groups                               |\n+|-------------------------------------|---------------|--------------------------------------------------------|\n+| BMW Electric Vehicle                | bev           | status, range, location, service, check, charge, image |\n+| BMW Electric Vehicle with REX       | bev_rex       | status, range, location, service, check, charge, image |\n+| BMW Plug-In-Hybrid Electric Vehicle | phev          | status, range, location, service, check, charge, image |\n+| BMW Conventional Vehicle            | conv          | status, range, location, service, check, image         |\n+\n+ \n+#### Properties\n+\n+<img align=\"right\" src=\"./doc/properties.png\" width=\"500\" height=\"225\"/>\n+\n+For each vehicle properties are available. \n+Basically 3 types of information are registered as properties\n+\n+* Informations regarding your dealer with address and phone number\n+* Which services are available / not available\n+* Vehicle properties like color, model type, drive train and construction year\n+\n+In the right picture can see in *Services Activated* e.g. the *DoorLock* and *DoorUnlock* services are mentioned. \n+This ensures channel group [Remote Services](#remote-services) is supporting door lock and unlock remote control.\n+\n+In  *Services Supported* the entry *LastDestination* is mentioned.\n+So it's valid to connect channel group [Last Destinations](#destinations) in order to display and select the last navigation destinations.\n+\n+| Property Key       | Property Value      |  Supported Channel Groups    |\n+|--------------------|---------------------|------------------------------|\n+| servicesSupported  | Statistics          | last-trip, lifetime          |\n+| servicesSupported  | LastDestinations    | destinations                 |\n+| servicesActivated  | _list of services_  | remote                       |\n+\n+\n+## Discovery\n+\n+Auto discovery is starting after the bridge towards BMW's ConnectedDrive is created. \n+A list of your registered vehicles is queried and all found things are added in the inbox.\n+Unique identifier is the *Vehicle Identification Number* (VIN). \n+If a thing is already declared in a  _.things_ configuration, discovery won't highlight it again.\n+Properties will be attached to predefined vehicles if the VIN is matching.\n+\n+## Configuration\n+\n+### Bridge Configuration\n+\n+| Parameter       | Type    | Description                                                        |           \n+|-----------------|---------|--------------------------------------------------------------------|\n+| userName        | text    | BMW ConnectedDrive Username                                       |\n+| password        | text    | BMW ConnectedDrive Password                                       |\n+| region          | text    | Select region in order to connect to the appropriate BMW server.   |\n+\n+The region Configuration has 3 different options\n+\n+* _NORTH_AMERICA_\n+* _CHINA_\n+* _ROW_  (Rest of World)\n+\n+### Thing Configuration\n+\n+Same configuration is needed for all things\n+\n+| Parameter       | Type    | Description                           |           \n+|-----------------|---------|---------------------------------------|\n+| vin             | text    | Vehicle Identification Number (VIN)   |\n+| refreshInterval | integer | Refresh Interval in Minutes           |\n+| units           | text    | Unit Selection. See below.            |\n+| imageSize       | integer | Image Size                            |\n+| imageViewport   | text    | Image Viewport                        |\n+\n+The unit configuration has 3 options\n+\n+* _AUTODETECT_ selects miles for US & UK, kilometer otherwise\n+* _METRIC_ selects directly kilometers\n+* _IMPERIAL_ selects directly miles\n+\n+The _imageVieport_ allows to show the vehicle from different angels.\n+Possible options are \n+\n+* _FRONT_\n+* _REAR_\n+* _SIDE_\n+* _DASHBOARD_\n+* _DRIVERDOOR_\n+\n+## Channels\n+\n+There are many channels available for each vehicle. \n+For better overview they are clustered in different channel groups.\n+They differ for each vehicle type, build-in sensors and activated services.\n+\n+\n+### Thing Channel Groups \n+\n+#### Vehicle Status\n+\n+Reflects overall status of the vehicle.\n+\n+* Channel Group ID is **status**\n+* Available for all vehicles\n+* Read-only values\n+\n+| Channel Label             | Channel ID          | Type          | Description                                    |\n+|---------------------------|---------------------|---------------|------------------------------------------------|\n+| Overall Door Status       | doors               | String        | Combined status for all doors                  |\n+| Overall Window Status     | windows             | String        | Combined status for all windows                |\n+| Doors Locked              | lock                | String        | Status if doors are locked or unlocked         |\n+| Next Service Date         | service-date        | DateTime      | Date of upcoming service                       |\n+| Mileage till Next Service | service-mileage     | Number:Length | Mileage till upcoming service                  |\n+| Check Control             | check-control       | String        | Presence of active warning messages            |\n+| Charging Status           | charge              | String        | Only available for phev, bev_rex and bev       |\n+| Last Status Timestamp     | last-update         | DateTime      | Date and time of last status update            |\n+\n+Overall Door Status values\n+\n+* _Closed_ - all doors closed\n+* _Open_ - at least one door is open\n+* _Undef_ - no door data delivered at all\n+\n+Overall Windows Status values\n+\n+* _Closed_ - all windows closed\n+* _Open_ - at least one window is completely open\n+* _Intermediate_ - at least one window is partially open\n+* _Undef_ - no window data delivered at all\n+\n+Check Control values\n+\n+* _Active_ - at least one warning message is active\n+* _Not Active_ - no warning message is active\n+* _Undef_ - no data for warnings delivered\n+\n+Charging Status values\n+\n+* _Charging_\n+* _Error_\n+* _Finished Fully Charged_\n+* _Finished Not Full_\n+* _Invalid_\n+* _Not Charging_\n+* _Charging Goal reached_\n+* _Waiting For Charging_\n+\n+#### Services\n+\n+Group for all upcoming services with description, service date and/or service mileage.\n+If more than one service is scheduled in the future the channel _name_ contains all future services as options.\n+\n+* Channel Group ID is **service**\n+* Available for all vehicles\n+* Read/Write access\n+\n+| Channel Label                  | Channel ID          | Type           | Access     |\n+|--------------------------------|---------------------|----------------|------------|\n+| Service Name                   | name                | String         | Read/Write |\n+| Service Details                | details             | String         | Read       |\n+| Service Date                   | date                | Number         | Read       |\n+| Mileage till Service           | mileage             | Number:Length  | Read       |\n+\n+#### Check Control\n+\n+Group for all current active CheckControl messages.\n+If more than one message is active the channel _name_ contains all active messages as options.\n+\n+* Channel Group ID is **check**\n+* Available for all vehicles\n+* Read/Write access\n+\n+| Channel Label                   | Channel ID          | Type           | Access     |\n+|---------------------------------|---------------------|----------------|------------|\n+| CheckControl Description        | name                | String         | Read/Write |\n+| CheckControl Details            | details             | String         | Read       |\n+| Mileage Occurrence              | mileage             | Number:Length  | Read       |\n+\n+#### Doors Details\n+\n+Detailed status of all doors and windows.\n+\n+* Channel Group ID is **doors**\n+* Available for all vehicles if corresponding sensors are built-in \n+* Read-only values\n+ \n+| Channel Label              | Channel ID              | Type          | \n+|----------------------------|-------------------------|---------------|\n+| Driver Door                | driver-front            | String        |\n+| Driver Door Rear           | driver-rear             | String        |\n+| Passenger Door             | passenger-front         | String        |\n+| Passenger Door Rear        | passenger-rear          | String        |\n+| Trunk                      | trunk                   | String        |\n+| Hood                       | hood                    | String        |\n+| Driver Window              | win-driver-front        | String        |\n+| Driver Rear Window         | win-driver-rear         | String        |\n+| Passenger Window           | win-passenger-front     | String        |\n+| Passenger Rear Window      | win-passenger-rear      | String        |\n+| Rear Window                | win-rear                | String        |\n+| Sunroof                    | sunroof                 | String        |\n+\n+Possible states\n+\n+* _Undef_ - no status data available\n+* _Invalid_ - this door / window isn't applicable for this vehicle\n+* _Closed_ - the door / window is closed\n+* _Open_ - the door / window is open\n+* _Intermediate_ - window in intermediate position, not applicable for doors\n+\n+#### Range Data\n+\n+Based on vehicle type some channels are present or not. \n+Conventional fuel vehicles don't provide *Electric Range* and battery electric vehicles don't show *Fuel Range*.\n+Hybrid vehicles have both and in addition *Hybrid Range*.\n+See description [Range vs Range Radius](#range-vs-range-radius) to get more information.\n+\n+* Channel Group ID is **range**\n+* Availability according to table\n+* Read-only values\n+\n+| Channel Label         | Channel ID            | Type                 | conv | phev | bev_rex | bev |\n+|-----------------------|-----------------------|----------------------|------|------|---------|-----|\n+| Mileage               | mileage               | Number:Length        |  X   |  X   |    X    |  X  |\n+| Fuel Range            | range-fuel            | Number:Length        |  X   |  X   |    X    |     |\n+| Battery Range         | range-electric        | Number:Length        |      |  X   |    X    |  X  | \n+| Hybrid Range          | range-hybrid          | Number:Length        |      |  X   |    X    |     | \n+| Battery Charge Level  | soc                   | Number:Dimensionless |      |  X   |    X    |  X  |\n+| Remaining Fuel        | remaining-fuel        | Number:Volume        |  X   |  X   |    X    |     | \n+| Fuel Range Radius     | range-radius-fuel     | Number:Length        |  X   |  X   |    X    |     | \n+| Electric Range Radius | range-radius-electric | Number:Length        |      |  X   |    X    |  X  | \n+| Hybrid Range Radius   | range-radius-hybrid   | Number:Length        |      |  X   |    X    |     | \n+\n+\n+#### Charge Profile\n+\n+Charging options with date and time for preferred time windows and charging modes.\n+\n+* Channel Group ID is **charge**\n+* Available for electric and hybrid vehicles\n+* Read/Write access for UI. Use [Charge Profile Actions](#charge-profile-action) in rules\n+* There are 3 timers available. Replace *X* with number 1,2 or 3 to target the correct timer\n+\n+| Channel Label                         | Channel Group ID | Channel ID                | Type     | \n+|---------------------------------------|------------------|---------------------------|----------| \n+| Charging Mode for Profile             | charge           | profile-mode              | String   | \n+| Charging Preferences for Profile      | charge           | profile-prefs             | String   | \n+| Charging Window Start Time            | charge           | window-start              | DateTime | \n+| Charging Window Start Time Hour       | charge           | window-start-hour         | Number   | \n+| Charging Window Start Time Minute     | charge           | window-start-minute       | Number   | ", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5NzkwOTg3Mw=="}, "originalCommit": {"oid": "48af48c82562d006b6f2aa35922270f181c885ed"}, "originalPosition": 286}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwNjY2MDgzMQ==", "bodyText": "please see PR weymann#13 (simplifies the editable DateTimeType-channel, removes the minute- and hour-based channels", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r606660831", "createdAt": "2021-04-03T12:45:15Z", "author": {"login": "ntruchsess"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/README.md", "diffHunk": "@@ -0,0 +1,849 @@\n+# BMW ConnectedDrive Binding\n+\n+<img align=\"right\" src=\"./doc/bmw-connected.png\" width=\"150\" height=\"150\"/>\n+\n+The binding provides a connection between [BMW's ConnectedDrive Portal](https://www.bmw-connecteddrive.com/country-region-select/country-region-selection.html) and openHAB.\n+All vehicles connected to an account will be detected by the discovery with the correct type \n+\n+* Conventional Fuel Vehicle\n+* Plugin-Hybrid Electrical Vehicle \n+* Battery Electric Vehicle with Range Extender\n+* Battery Electric Vehicle \n+\n+In addition properties are attached with information and services provided by this vehicle.\n+The provided data depends on \n+\n+1. the [Thing Type](#things) and \n+2. the [Properties](#properties) mentioned in Services\n+\n+Different channel groups are clustering all informations.\n+Check for each group if it's supported for this Vehicle.\n+\n+Please note **this isn't a real-time binding**. \n+If a door is opened the state isn't transmitted and changed immediately. \n+This isn't a flaw in the binding itself because the state in BMW's own ConnectedDrive App is also updated with some delay. \n+\n+## Supported Things\n+\n+### Bridge\n+\n+The bridge establishes the connection between BMW's ConnectedDrive Portal and openHAB.\n+\n+| Name                       | Bridge Type ID | Description                                                |\n+|----------------------------|----------------|------------------------------------------------------------|\n+| BMW ConnectedDrive Account | account        | Access to BMW ConnectedDrive Portal for a specific user    |\n+\n+\n+### Things\n+\n+Four different vehicle types are provided. \n+They differ in the supported channel groups & channels. \n+Conventional Fuel Vehicles have no _Charging Profile_, Electric Vehicles don't provide a _Fuel Range_. \n+For hybrid vehicles in addition to _Fuel and Electric Range_ the _Hybrid Range_ is shown.\n+ \n+| Name                                | Thing Type ID | Supported Channel Groups                               |\n+|-------------------------------------|---------------|--------------------------------------------------------|\n+| BMW Electric Vehicle                | bev           | status, range, location, service, check, charge, image |\n+| BMW Electric Vehicle with REX       | bev_rex       | status, range, location, service, check, charge, image |\n+| BMW Plug-In-Hybrid Electric Vehicle | phev          | status, range, location, service, check, charge, image |\n+| BMW Conventional Vehicle            | conv          | status, range, location, service, check, image         |\n+\n+ \n+#### Properties\n+\n+<img align=\"right\" src=\"./doc/properties.png\" width=\"500\" height=\"225\"/>\n+\n+For each vehicle properties are available. \n+Basically 3 types of information are registered as properties\n+\n+* Informations regarding your dealer with address and phone number\n+* Which services are available / not available\n+* Vehicle properties like color, model type, drive train and construction year\n+\n+In the right picture can see in *Services Activated* e.g. the *DoorLock* and *DoorUnlock* services are mentioned. \n+This ensures channel group [Remote Services](#remote-services) is supporting door lock and unlock remote control.\n+\n+In  *Services Supported* the entry *LastDestination* is mentioned.\n+So it's valid to connect channel group [Last Destinations](#destinations) in order to display and select the last navigation destinations.\n+\n+| Property Key       | Property Value      |  Supported Channel Groups    |\n+|--------------------|---------------------|------------------------------|\n+| servicesSupported  | Statistics          | last-trip, lifetime          |\n+| servicesSupported  | LastDestinations    | destinations                 |\n+| servicesActivated  | _list of services_  | remote                       |\n+\n+\n+## Discovery\n+\n+Auto discovery is starting after the bridge towards BMW's ConnectedDrive is created. \n+A list of your registered vehicles is queried and all found things are added in the inbox.\n+Unique identifier is the *Vehicle Identification Number* (VIN). \n+If a thing is already declared in a  _.things_ configuration, discovery won't highlight it again.\n+Properties will be attached to predefined vehicles if the VIN is matching.\n+\n+## Configuration\n+\n+### Bridge Configuration\n+\n+| Parameter       | Type    | Description                                                        |           \n+|-----------------|---------|--------------------------------------------------------------------|\n+| userName        | text    | BMW ConnectedDrive Username                                       |\n+| password        | text    | BMW ConnectedDrive Password                                       |\n+| region          | text    | Select region in order to connect to the appropriate BMW server.   |\n+\n+The region Configuration has 3 different options\n+\n+* _NORTH_AMERICA_\n+* _CHINA_\n+* _ROW_  (Rest of World)\n+\n+### Thing Configuration\n+\n+Same configuration is needed for all things\n+\n+| Parameter       | Type    | Description                           |           \n+|-----------------|---------|---------------------------------------|\n+| vin             | text    | Vehicle Identification Number (VIN)   |\n+| refreshInterval | integer | Refresh Interval in Minutes           |\n+| units           | text    | Unit Selection. See below.            |\n+| imageSize       | integer | Image Size                            |\n+| imageViewport   | text    | Image Viewport                        |\n+\n+The unit configuration has 3 options\n+\n+* _AUTODETECT_ selects miles for US & UK, kilometer otherwise\n+* _METRIC_ selects directly kilometers\n+* _IMPERIAL_ selects directly miles\n+\n+The _imageVieport_ allows to show the vehicle from different angels.\n+Possible options are \n+\n+* _FRONT_\n+* _REAR_\n+* _SIDE_\n+* _DASHBOARD_\n+* _DRIVERDOOR_\n+\n+## Channels\n+\n+There are many channels available for each vehicle. \n+For better overview they are clustered in different channel groups.\n+They differ for each vehicle type, build-in sensors and activated services.\n+\n+\n+### Thing Channel Groups \n+\n+#### Vehicle Status\n+\n+Reflects overall status of the vehicle.\n+\n+* Channel Group ID is **status**\n+* Available for all vehicles\n+* Read-only values\n+\n+| Channel Label             | Channel ID          | Type          | Description                                    |\n+|---------------------------|---------------------|---------------|------------------------------------------------|\n+| Overall Door Status       | doors               | String        | Combined status for all doors                  |\n+| Overall Window Status     | windows             | String        | Combined status for all windows                |\n+| Doors Locked              | lock                | String        | Status if doors are locked or unlocked         |\n+| Next Service Date         | service-date        | DateTime      | Date of upcoming service                       |\n+| Mileage till Next Service | service-mileage     | Number:Length | Mileage till upcoming service                  |\n+| Check Control             | check-control       | String        | Presence of active warning messages            |\n+| Charging Status           | charge              | String        | Only available for phev, bev_rex and bev       |\n+| Last Status Timestamp     | last-update         | DateTime      | Date and time of last status update            |\n+\n+Overall Door Status values\n+\n+* _Closed_ - all doors closed\n+* _Open_ - at least one door is open\n+* _Undef_ - no door data delivered at all\n+\n+Overall Windows Status values\n+\n+* _Closed_ - all windows closed\n+* _Open_ - at least one window is completely open\n+* _Intermediate_ - at least one window is partially open\n+* _Undef_ - no window data delivered at all\n+\n+Check Control values\n+\n+* _Active_ - at least one warning message is active\n+* _Not Active_ - no warning message is active\n+* _Undef_ - no data for warnings delivered\n+\n+Charging Status values\n+\n+* _Charging_\n+* _Error_\n+* _Finished Fully Charged_\n+* _Finished Not Full_\n+* _Invalid_\n+* _Not Charging_\n+* _Charging Goal reached_\n+* _Waiting For Charging_\n+\n+#### Services\n+\n+Group for all upcoming services with description, service date and/or service mileage.\n+If more than one service is scheduled in the future the channel _name_ contains all future services as options.\n+\n+* Channel Group ID is **service**\n+* Available for all vehicles\n+* Read/Write access\n+\n+| Channel Label                  | Channel ID          | Type           | Access     |\n+|--------------------------------|---------------------|----------------|------------|\n+| Service Name                   | name                | String         | Read/Write |\n+| Service Details                | details             | String         | Read       |\n+| Service Date                   | date                | Number         | Read       |\n+| Mileage till Service           | mileage             | Number:Length  | Read       |\n+\n+#### Check Control\n+\n+Group for all current active CheckControl messages.\n+If more than one message is active the channel _name_ contains all active messages as options.\n+\n+* Channel Group ID is **check**\n+* Available for all vehicles\n+* Read/Write access\n+\n+| Channel Label                   | Channel ID          | Type           | Access     |\n+|---------------------------------|---------------------|----------------|------------|\n+| CheckControl Description        | name                | String         | Read/Write |\n+| CheckControl Details            | details             | String         | Read       |\n+| Mileage Occurrence              | mileage             | Number:Length  | Read       |\n+\n+#### Doors Details\n+\n+Detailed status of all doors and windows.\n+\n+* Channel Group ID is **doors**\n+* Available for all vehicles if corresponding sensors are built-in \n+* Read-only values\n+ \n+| Channel Label              | Channel ID              | Type          | \n+|----------------------------|-------------------------|---------------|\n+| Driver Door                | driver-front            | String        |\n+| Driver Door Rear           | driver-rear             | String        |\n+| Passenger Door             | passenger-front         | String        |\n+| Passenger Door Rear        | passenger-rear          | String        |\n+| Trunk                      | trunk                   | String        |\n+| Hood                       | hood                    | String        |\n+| Driver Window              | win-driver-front        | String        |\n+| Driver Rear Window         | win-driver-rear         | String        |\n+| Passenger Window           | win-passenger-front     | String        |\n+| Passenger Rear Window      | win-passenger-rear      | String        |\n+| Rear Window                | win-rear                | String        |\n+| Sunroof                    | sunroof                 | String        |\n+\n+Possible states\n+\n+* _Undef_ - no status data available\n+* _Invalid_ - this door / window isn't applicable for this vehicle\n+* _Closed_ - the door / window is closed\n+* _Open_ - the door / window is open\n+* _Intermediate_ - window in intermediate position, not applicable for doors\n+\n+#### Range Data\n+\n+Based on vehicle type some channels are present or not. \n+Conventional fuel vehicles don't provide *Electric Range* and battery electric vehicles don't show *Fuel Range*.\n+Hybrid vehicles have both and in addition *Hybrid Range*.\n+See description [Range vs Range Radius](#range-vs-range-radius) to get more information.\n+\n+* Channel Group ID is **range**\n+* Availability according to table\n+* Read-only values\n+\n+| Channel Label         | Channel ID            | Type                 | conv | phev | bev_rex | bev |\n+|-----------------------|-----------------------|----------------------|------|------|---------|-----|\n+| Mileage               | mileage               | Number:Length        |  X   |  X   |    X    |  X  |\n+| Fuel Range            | range-fuel            | Number:Length        |  X   |  X   |    X    |     |\n+| Battery Range         | range-electric        | Number:Length        |      |  X   |    X    |  X  | \n+| Hybrid Range          | range-hybrid          | Number:Length        |      |  X   |    X    |     | \n+| Battery Charge Level  | soc                   | Number:Dimensionless |      |  X   |    X    |  X  |\n+| Remaining Fuel        | remaining-fuel        | Number:Volume        |  X   |  X   |    X    |     | \n+| Fuel Range Radius     | range-radius-fuel     | Number:Length        |  X   |  X   |    X    |     | \n+| Electric Range Radius | range-radius-electric | Number:Length        |      |  X   |    X    |  X  | \n+| Hybrid Range Radius   | range-radius-hybrid   | Number:Length        |      |  X   |    X    |     | \n+\n+\n+#### Charge Profile\n+\n+Charging options with date and time for preferred time windows and charging modes.\n+\n+* Channel Group ID is **charge**\n+* Available for electric and hybrid vehicles\n+* Read/Write access for UI. Use [Charge Profile Actions](#charge-profile-action) in rules\n+* There are 3 timers available. Replace *X* with number 1,2 or 3 to target the correct timer\n+\n+| Channel Label                         | Channel Group ID | Channel ID                | Type     | \n+|---------------------------------------|------------------|---------------------------|----------| \n+| Charging Mode for Profile             | charge           | profile-mode              | String   | \n+| Charging Preferences for Profile      | charge           | profile-prefs             | String   | \n+| Charging Window Start Time            | charge           | window-start              | DateTime | \n+| Charging Window Start Time Hour       | charge           | window-start-hour         | Number   | \n+| Charging Window Start Time Minute     | charge           | window-start-minute       | Number   | ", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5NzkwOTg3Mw=="}, "originalCommit": {"oid": "48af48c82562d006b6f2aa35922270f181c885ed"}, "originalPosition": 286}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwNjY2MTI0NQ==", "bodyText": "I think for the days-channels that also might be simplified using an editable StringListType-Channel instead of 7 OnOffType-channels per week. Implementation in the binding is pretty straightforward, but I do not have a working OH3-UI widget-based example for that yet.", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r606661245", "createdAt": "2021-04-03T12:48:28Z", "author": {"login": "ntruchsess"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/README.md", "diffHunk": "@@ -0,0 +1,849 @@\n+# BMW ConnectedDrive Binding\n+\n+<img align=\"right\" src=\"./doc/bmw-connected.png\" width=\"150\" height=\"150\"/>\n+\n+The binding provides a connection between [BMW's ConnectedDrive Portal](https://www.bmw-connecteddrive.com/country-region-select/country-region-selection.html) and openHAB.\n+All vehicles connected to an account will be detected by the discovery with the correct type \n+\n+* Conventional Fuel Vehicle\n+* Plugin-Hybrid Electrical Vehicle \n+* Battery Electric Vehicle with Range Extender\n+* Battery Electric Vehicle \n+\n+In addition properties are attached with information and services provided by this vehicle.\n+The provided data depends on \n+\n+1. the [Thing Type](#things) and \n+2. the [Properties](#properties) mentioned in Services\n+\n+Different channel groups are clustering all informations.\n+Check for each group if it's supported for this Vehicle.\n+\n+Please note **this isn't a real-time binding**. \n+If a door is opened the state isn't transmitted and changed immediately. \n+This isn't a flaw in the binding itself because the state in BMW's own ConnectedDrive App is also updated with some delay. \n+\n+## Supported Things\n+\n+### Bridge\n+\n+The bridge establishes the connection between BMW's ConnectedDrive Portal and openHAB.\n+\n+| Name                       | Bridge Type ID | Description                                                |\n+|----------------------------|----------------|------------------------------------------------------------|\n+| BMW ConnectedDrive Account | account        | Access to BMW ConnectedDrive Portal for a specific user    |\n+\n+\n+### Things\n+\n+Four different vehicle types are provided. \n+They differ in the supported channel groups & channels. \n+Conventional Fuel Vehicles have no _Charging Profile_, Electric Vehicles don't provide a _Fuel Range_. \n+For hybrid vehicles in addition to _Fuel and Electric Range_ the _Hybrid Range_ is shown.\n+ \n+| Name                                | Thing Type ID | Supported Channel Groups                               |\n+|-------------------------------------|---------------|--------------------------------------------------------|\n+| BMW Electric Vehicle                | bev           | status, range, location, service, check, charge, image |\n+| BMW Electric Vehicle with REX       | bev_rex       | status, range, location, service, check, charge, image |\n+| BMW Plug-In-Hybrid Electric Vehicle | phev          | status, range, location, service, check, charge, image |\n+| BMW Conventional Vehicle            | conv          | status, range, location, service, check, image         |\n+\n+ \n+#### Properties\n+\n+<img align=\"right\" src=\"./doc/properties.png\" width=\"500\" height=\"225\"/>\n+\n+For each vehicle properties are available. \n+Basically 3 types of information are registered as properties\n+\n+* Informations regarding your dealer with address and phone number\n+* Which services are available / not available\n+* Vehicle properties like color, model type, drive train and construction year\n+\n+In the right picture can see in *Services Activated* e.g. the *DoorLock* and *DoorUnlock* services are mentioned. \n+This ensures channel group [Remote Services](#remote-services) is supporting door lock and unlock remote control.\n+\n+In  *Services Supported* the entry *LastDestination* is mentioned.\n+So it's valid to connect channel group [Last Destinations](#destinations) in order to display and select the last navigation destinations.\n+\n+| Property Key       | Property Value      |  Supported Channel Groups    |\n+|--------------------|---------------------|------------------------------|\n+| servicesSupported  | Statistics          | last-trip, lifetime          |\n+| servicesSupported  | LastDestinations    | destinations                 |\n+| servicesActivated  | _list of services_  | remote                       |\n+\n+\n+## Discovery\n+\n+Auto discovery is starting after the bridge towards BMW's ConnectedDrive is created. \n+A list of your registered vehicles is queried and all found things are added in the inbox.\n+Unique identifier is the *Vehicle Identification Number* (VIN). \n+If a thing is already declared in a  _.things_ configuration, discovery won't highlight it again.\n+Properties will be attached to predefined vehicles if the VIN is matching.\n+\n+## Configuration\n+\n+### Bridge Configuration\n+\n+| Parameter       | Type    | Description                                                        |           \n+|-----------------|---------|--------------------------------------------------------------------|\n+| userName        | text    | BMW ConnectedDrive Username                                       |\n+| password        | text    | BMW ConnectedDrive Password                                       |\n+| region          | text    | Select region in order to connect to the appropriate BMW server.   |\n+\n+The region Configuration has 3 different options\n+\n+* _NORTH_AMERICA_\n+* _CHINA_\n+* _ROW_  (Rest of World)\n+\n+### Thing Configuration\n+\n+Same configuration is needed for all things\n+\n+| Parameter       | Type    | Description                           |           \n+|-----------------|---------|---------------------------------------|\n+| vin             | text    | Vehicle Identification Number (VIN)   |\n+| refreshInterval | integer | Refresh Interval in Minutes           |\n+| units           | text    | Unit Selection. See below.            |\n+| imageSize       | integer | Image Size                            |\n+| imageViewport   | text    | Image Viewport                        |\n+\n+The unit configuration has 3 options\n+\n+* _AUTODETECT_ selects miles for US & UK, kilometer otherwise\n+* _METRIC_ selects directly kilometers\n+* _IMPERIAL_ selects directly miles\n+\n+The _imageVieport_ allows to show the vehicle from different angels.\n+Possible options are \n+\n+* _FRONT_\n+* _REAR_\n+* _SIDE_\n+* _DASHBOARD_\n+* _DRIVERDOOR_\n+\n+## Channels\n+\n+There are many channels available for each vehicle. \n+For better overview they are clustered in different channel groups.\n+They differ for each vehicle type, build-in sensors and activated services.\n+\n+\n+### Thing Channel Groups \n+\n+#### Vehicle Status\n+\n+Reflects overall status of the vehicle.\n+\n+* Channel Group ID is **status**\n+* Available for all vehicles\n+* Read-only values\n+\n+| Channel Label             | Channel ID          | Type          | Description                                    |\n+|---------------------------|---------------------|---------------|------------------------------------------------|\n+| Overall Door Status       | doors               | String        | Combined status for all doors                  |\n+| Overall Window Status     | windows             | String        | Combined status for all windows                |\n+| Doors Locked              | lock                | String        | Status if doors are locked or unlocked         |\n+| Next Service Date         | service-date        | DateTime      | Date of upcoming service                       |\n+| Mileage till Next Service | service-mileage     | Number:Length | Mileage till upcoming service                  |\n+| Check Control             | check-control       | String        | Presence of active warning messages            |\n+| Charging Status           | charge              | String        | Only available for phev, bev_rex and bev       |\n+| Last Status Timestamp     | last-update         | DateTime      | Date and time of last status update            |\n+\n+Overall Door Status values\n+\n+* _Closed_ - all doors closed\n+* _Open_ - at least one door is open\n+* _Undef_ - no door data delivered at all\n+\n+Overall Windows Status values\n+\n+* _Closed_ - all windows closed\n+* _Open_ - at least one window is completely open\n+* _Intermediate_ - at least one window is partially open\n+* _Undef_ - no window data delivered at all\n+\n+Check Control values\n+\n+* _Active_ - at least one warning message is active\n+* _Not Active_ - no warning message is active\n+* _Undef_ - no data for warnings delivered\n+\n+Charging Status values\n+\n+* _Charging_\n+* _Error_\n+* _Finished Fully Charged_\n+* _Finished Not Full_\n+* _Invalid_\n+* _Not Charging_\n+* _Charging Goal reached_\n+* _Waiting For Charging_\n+\n+#### Services\n+\n+Group for all upcoming services with description, service date and/or service mileage.\n+If more than one service is scheduled in the future the channel _name_ contains all future services as options.\n+\n+* Channel Group ID is **service**\n+* Available for all vehicles\n+* Read/Write access\n+\n+| Channel Label                  | Channel ID          | Type           | Access     |\n+|--------------------------------|---------------------|----------------|------------|\n+| Service Name                   | name                | String         | Read/Write |\n+| Service Details                | details             | String         | Read       |\n+| Service Date                   | date                | Number         | Read       |\n+| Mileage till Service           | mileage             | Number:Length  | Read       |\n+\n+#### Check Control\n+\n+Group for all current active CheckControl messages.\n+If more than one message is active the channel _name_ contains all active messages as options.\n+\n+* Channel Group ID is **check**\n+* Available for all vehicles\n+* Read/Write access\n+\n+| Channel Label                   | Channel ID          | Type           | Access     |\n+|---------------------------------|---------------------|----------------|------------|\n+| CheckControl Description        | name                | String         | Read/Write |\n+| CheckControl Details            | details             | String         | Read       |\n+| Mileage Occurrence              | mileage             | Number:Length  | Read       |\n+\n+#### Doors Details\n+\n+Detailed status of all doors and windows.\n+\n+* Channel Group ID is **doors**\n+* Available for all vehicles if corresponding sensors are built-in \n+* Read-only values\n+ \n+| Channel Label              | Channel ID              | Type          | \n+|----------------------------|-------------------------|---------------|\n+| Driver Door                | driver-front            | String        |\n+| Driver Door Rear           | driver-rear             | String        |\n+| Passenger Door             | passenger-front         | String        |\n+| Passenger Door Rear        | passenger-rear          | String        |\n+| Trunk                      | trunk                   | String        |\n+| Hood                       | hood                    | String        |\n+| Driver Window              | win-driver-front        | String        |\n+| Driver Rear Window         | win-driver-rear         | String        |\n+| Passenger Window           | win-passenger-front     | String        |\n+| Passenger Rear Window      | win-passenger-rear      | String        |\n+| Rear Window                | win-rear                | String        |\n+| Sunroof                    | sunroof                 | String        |\n+\n+Possible states\n+\n+* _Undef_ - no status data available\n+* _Invalid_ - this door / window isn't applicable for this vehicle\n+* _Closed_ - the door / window is closed\n+* _Open_ - the door / window is open\n+* _Intermediate_ - window in intermediate position, not applicable for doors\n+\n+#### Range Data\n+\n+Based on vehicle type some channels are present or not. \n+Conventional fuel vehicles don't provide *Electric Range* and battery electric vehicles don't show *Fuel Range*.\n+Hybrid vehicles have both and in addition *Hybrid Range*.\n+See description [Range vs Range Radius](#range-vs-range-radius) to get more information.\n+\n+* Channel Group ID is **range**\n+* Availability according to table\n+* Read-only values\n+\n+| Channel Label         | Channel ID            | Type                 | conv | phev | bev_rex | bev |\n+|-----------------------|-----------------------|----------------------|------|------|---------|-----|\n+| Mileage               | mileage               | Number:Length        |  X   |  X   |    X    |  X  |\n+| Fuel Range            | range-fuel            | Number:Length        |  X   |  X   |    X    |     |\n+| Battery Range         | range-electric        | Number:Length        |      |  X   |    X    |  X  | \n+| Hybrid Range          | range-hybrid          | Number:Length        |      |  X   |    X    |     | \n+| Battery Charge Level  | soc                   | Number:Dimensionless |      |  X   |    X    |  X  |\n+| Remaining Fuel        | remaining-fuel        | Number:Volume        |  X   |  X   |    X    |     | \n+| Fuel Range Radius     | range-radius-fuel     | Number:Length        |  X   |  X   |    X    |     | \n+| Electric Range Radius | range-radius-electric | Number:Length        |      |  X   |    X    |  X  | \n+| Hybrid Range Radius   | range-radius-hybrid   | Number:Length        |      |  X   |    X    |     | \n+\n+\n+#### Charge Profile\n+\n+Charging options with date and time for preferred time windows and charging modes.\n+\n+* Channel Group ID is **charge**\n+* Available for electric and hybrid vehicles\n+* Read/Write access for UI. Use [Charge Profile Actions](#charge-profile-action) in rules\n+* There are 3 timers available. Replace *X* with number 1,2 or 3 to target the correct timer\n+\n+| Channel Label                         | Channel Group ID | Channel ID                | Type     | \n+|---------------------------------------|------------------|---------------------------|----------| \n+| Charging Mode for Profile             | charge           | profile-mode              | String   | \n+| Charging Preferences for Profile      | charge           | profile-prefs             | String   | \n+| Charging Window Start Time            | charge           | window-start              | DateTime | \n+| Charging Window Start Time Hour       | charge           | window-start-hour         | Number   | \n+| Charging Window Start Time Minute     | charge           | window-start-minute       | Number   | ", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5NzkwOTg3Mw=="}, "originalCommit": {"oid": "48af48c82562d006b6f2aa35922270f181c885ed"}, "originalPosition": 286}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzc3NjczNzMwOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/VehicleChannelHandler.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0xOVQxOTowMTo0NlrOI6NsGQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0yNVQyMTo1MTo1NlrOI9-0fA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5NzkxMjYwMQ==", "bodyText": "Why not using your Converter method?", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r597912601", "createdAt": "2021-03-19T19:01:46Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/VehicleChannelHandler.java", "diffHunk": "@@ -0,0 +1,532 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bmwconnecteddrive.internal.handler;\n+\n+import static org.openhab.binding.bmwconnecteddrive.internal.ConnectedDriveConstants.*;\n+\n+import java.time.DayOfWeek;\n+import java.time.LocalTime;\n+import java.time.ZoneId;\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.EnumSet;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import javax.measure.quantity.Length;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.binding.bmwconnecteddrive.internal.ConnectedDriveConstants.VehicleType;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.Destination;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.statistics.AllTrips;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.statistics.LastTrip;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.status.CBSMessage;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.status.CCMMessage;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.status.Doors;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.status.Position;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.status.VehicleStatus;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.status.Windows;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileUtils;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileUtils.TimedChannel;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileWrapper;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileWrapper.ProfileKey;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Constants;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Converter;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.RemoteServiceUtils;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.VehicleStatusUtils;\n+import org.openhab.core.library.types.DateTimeType;\n+import org.openhab.core.library.types.DecimalType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.PointType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.library.unit.ImperialUnits;\n+import org.openhab.core.library.unit.MetricPrefix;\n+import org.openhab.core.library.unit.SIUnits;\n+import org.openhab.core.library.unit.Units;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.StateOption;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonSyntaxException;\n+\n+/**\n+ * The {@link VehicleChannelHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Bernd Weymann - Initial contribution\n+ * @author Norbert Truchsess - edit & send of charge profile\n+ */\n+@NonNullByDefault\n+public class VehicleChannelHandler extends BaseThingHandler {\n+    protected final Logger logger = LoggerFactory.getLogger(VehicleChannelHandler.class);\n+    protected boolean imperial = false;\n+    protected boolean hasFuel = false;\n+    protected boolean isElectric = false;\n+    protected boolean isHybrid = false;\n+\n+    // List Interfaces\n+    protected List<CBSMessage> serviceList = new ArrayList<CBSMessage>();\n+    protected String selectedService = Constants.UNDEF;\n+    protected List<CCMMessage> checkControlList = new ArrayList<CCMMessage>();\n+    protected String selectedCC = Constants.UNDEF;\n+    protected List<Destination> destinationList = new ArrayList<Destination>();\n+    protected String selectedDestination = Constants.UNDEF;\n+\n+    protected BMWConnectedDriveOptionProvider optionProvider;\n+\n+    // Data Caches\n+    protected Optional<String> vehicleStatusCache = Optional.empty();\n+    protected Optional<String> lastTripCache = Optional.empty();\n+    protected Optional<String> allTripsCache = Optional.empty();\n+    protected Optional<String> chargeProfileCache = Optional.empty();\n+    protected Optional<String> rangeMapCache = Optional.empty();\n+    protected Optional<String> destinationCache = Optional.empty();\n+    protected Optional<byte[]> imageCache = Optional.empty();\n+\n+    public VehicleChannelHandler(Thing thing, BMWConnectedDriveOptionProvider op, String type, boolean imperial) {\n+        super(thing);\n+        optionProvider = op;\n+\n+        this.imperial = imperial;\n+        hasFuel = type.equals(VehicleType.CONVENTIONAL.toString()) || type.equals(VehicleType.PLUGIN_HYBRID.toString())\n+                || type.equals(VehicleType.ELECTRIC_REX.toString());\n+        isElectric = type.equals(VehicleType.PLUGIN_HYBRID.toString())\n+                || type.equals(VehicleType.ELECTRIC_REX.toString()) || type.equals(VehicleType.ELECTRIC.toString());\n+        isHybrid = hasFuel && isElectric;\n+\n+        setOptions(CHANNEL_GROUP_REMOTE, REMOTE_SERVICE_COMMAND, RemoteServiceUtils.getOptions(isElectric));\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+    }\n+\n+    @Override\n+    public void initialize() {\n+    }\n+\n+    private void setOptions(final String group, final String id, List<StateOption> options) {\n+        optionProvider.setStateOptions(new ChannelUID(thing.getUID(), group, id), options);\n+    }\n+\n+    protected void updateChannel(final String group, final String id, final State state) {\n+        updateState(new ChannelUID(thing.getUID(), group, id), state);\n+    }\n+\n+    protected void updateCheckControls(List<CCMMessage> ccl) {\n+        if (ccl.size() == 0) {\n+            // No Check Control available - show not active\n+            CCMMessage ccm = new CCMMessage();\n+            ccm.ccmDescriptionLong = Constants.NO_ENTRIES;\n+            ccm.ccmDescriptionShort = Constants.NO_ENTRIES;\n+            ccm.ccmId = -1;\n+            ccm.ccmMileage = -1;\n+            ccl.add(ccm);\n+        }\n+\n+        // add all elements to options\n+        checkControlList = ccl;\n+        List<StateOption> ccmDescriptionOptions = new ArrayList<>();\n+        List<StateOption> ccmDetailsOptions = new ArrayList<>();\n+        List<StateOption> ccmMileageOptions = new ArrayList<>();\n+        boolean isSelectedElementIn = false;\n+        int index = 0;\n+        for (CCMMessage ccEntry : checkControlList) {\n+            ccmDescriptionOptions.add(new StateOption(Integer.toString(index), ccEntry.ccmDescriptionShort));\n+            ccmDetailsOptions.add(new StateOption(Integer.toString(index), ccEntry.ccmDescriptionLong));\n+            ccmMileageOptions.add(new StateOption(Integer.toString(index), Integer.toString(ccEntry.ccmMileage)));\n+            if (selectedCC.equals(ccEntry.ccmDescriptionShort)) {\n+                isSelectedElementIn = true;\n+            }\n+            index++;\n+        }\n+        setOptions(CHANNEL_GROUP_CHECK_CONTROL, NAME, ccmDescriptionOptions);\n+        setOptions(CHANNEL_GROUP_CHECK_CONTROL, DETAILS, ccmDetailsOptions);\n+        setOptions(CHANNEL_GROUP_CHECK_CONTROL, MILEAGE, ccmMileageOptions);\n+\n+        // if current selected item isn't anymore in the list select first entry\n+        if (!isSelectedElementIn) {\n+            selectCheckControl(0);\n+        }\n+    }\n+\n+    protected void selectCheckControl(int index) {\n+        if (index >= 0 && index < checkControlList.size()) {\n+            CCMMessage ccEntry = checkControlList.get(index);\n+            selectedCC = ccEntry.ccmDescriptionShort;\n+            updateChannel(CHANNEL_GROUP_CHECK_CONTROL, NAME, StringType.valueOf(ccEntry.ccmDescriptionShort));\n+            updateChannel(CHANNEL_GROUP_CHECK_CONTROL, DETAILS, StringType.valueOf(ccEntry.ccmDescriptionLong));\n+            updateChannel(CHANNEL_GROUP_CHECK_CONTROL, MILEAGE,\n+                    QuantityType.valueOf(Converter.round(ccEntry.ccmMileage),\n+                            imperial ? ImperialUnits.MILE : MetricPrefix.KILO(SIUnits.METRE)));\n+        }\n+    }\n+\n+    protected void updateServices(List<CBSMessage> sl) {\n+        // if list is empty add \"undefined\" element\n+        if (sl.size() == 0) {\n+            CBSMessage cbsm = new CBSMessage();\n+            cbsm.cbsType = Constants.NO_ENTRIES;\n+            cbsm.cbsDescription = Constants.NO_ENTRIES;\n+            sl.add(cbsm);\n+        }\n+\n+        // add all elements to options\n+        serviceList = sl;\n+        List<StateOption> serviceNameOptions = new ArrayList<>();\n+        List<StateOption> serviceDetailsOptions = new ArrayList<>();\n+        List<StateOption> serviceDateOptions = new ArrayList<>();\n+        List<StateOption> serviceMileageOptions = new ArrayList<>();\n+        boolean isSelectedElementIn = false;\n+        int index = 0;\n+        for (CBSMessage serviceEntry : serviceList) {\n+            // create StateOption with \"value = list index\" and \"label = human readable string\"\n+            serviceNameOptions.add(new StateOption(Integer.toString(index), serviceEntry.getType()));\n+            serviceDetailsOptions.add(new StateOption(Integer.toString(index), serviceEntry.getDescription()));\n+            serviceDateOptions.add(new StateOption(Integer.toString(index), serviceEntry.getDueDate()));\n+            serviceMileageOptions\n+                    .add(new StateOption(Integer.toString(index), Integer.toString(serviceEntry.cbsRemainingMileage)));\n+            if (selectedService.equals(serviceEntry.getType())) {\n+                isSelectedElementIn = true;\n+            }\n+            index++;\n+        }\n+        setOptions(CHANNEL_GROUP_SERVICE, NAME, serviceNameOptions);\n+        setOptions(CHANNEL_GROUP_SERVICE, DETAILS, serviceDetailsOptions);\n+        setOptions(CHANNEL_GROUP_SERVICE, DATE, serviceDateOptions);\n+        setOptions(CHANNEL_GROUP_SERVICE, MILEAGE, serviceMileageOptions);\n+\n+        // if current selected item isn't anymore in the list select first entry\n+        if (!isSelectedElementIn) {\n+            selectService(0);\n+        }\n+    }\n+\n+    protected void selectService(int index) {\n+        if (index >= 0 && index < serviceList.size()) {\n+            CBSMessage serviceEntry = serviceList.get(index);\n+            selectedService = serviceEntry.cbsType;\n+            updateChannel(CHANNEL_GROUP_SERVICE, NAME,\n+                    StringType.valueOf(Converter.toTitleCase(serviceEntry.getType())));\n+            updateChannel(CHANNEL_GROUP_SERVICE, DETAILS,\n+                    StringType.valueOf(Converter.toTitleCase(serviceEntry.getDescription())));\n+            updateChannel(CHANNEL_GROUP_SERVICE, DATE,\n+                    DateTimeType.valueOf(Converter.getLocalDateTime(serviceEntry.getDueDate())));\n+            updateChannel(CHANNEL_GROUP_SERVICE, MILEAGE,\n+                    QuantityType.valueOf(Converter.round(serviceEntry.cbsRemainingMileage),\n+                            imperial ? ImperialUnits.MILE : MetricPrefix.KILO(SIUnits.METRE)));\n+        }\n+    }\n+\n+    protected void updateDestinations(List<Destination> dl) {\n+        // if list is empty add \"undefined\" element\n+        if (dl.size() == 0) {\n+            Destination dest = new Destination();\n+            dest.city = Constants.NO_ENTRIES;\n+            dest.lat = -1;\n+            dest.lon = -1;\n+            dl.add(dest);\n+        }\n+\n+        // add all elements to options\n+        destinationList = dl;\n+        List<StateOption> destinationNameOptions = new ArrayList<>();\n+        List<StateOption> destinationGPSOptions = new ArrayList<>();\n+        boolean isSelectedElementIn = false;\n+        int index = 0;\n+        for (Destination destination : destinationList) {\n+            destinationNameOptions.add(new StateOption(Integer.toString(index), destination.getAddress()));\n+            destinationGPSOptions.add(new StateOption(Integer.toString(index), destination.getCoordinates()));\n+            if (selectedDestination.equals(destination.getAddress())) {\n+                isSelectedElementIn = true;\n+            }\n+            index++;\n+        }\n+        setOptions(CHANNEL_GROUP_DESTINATION, NAME, destinationNameOptions);\n+        setOptions(CHANNEL_GROUP_DESTINATION, GPS, destinationGPSOptions);\n+\n+        // if current selected item isn't anymore in the list select first entry\n+        if (!isSelectedElementIn) {\n+            selectDestination(0);\n+        }\n+    }\n+\n+    protected void selectDestination(int index) {\n+        if (index >= 0 && index < destinationList.size()) {\n+            Destination destinationEntry = destinationList.get(index);\n+            // update selected Item\n+            selectedDestination = destinationEntry.getAddress();\n+            // update coordinates according to new set location\n+            updateChannel(CHANNEL_GROUP_DESTINATION, NAME, StringType.valueOf(destinationEntry.getAddress()));\n+            updateChannel(CHANNEL_GROUP_DESTINATION, GPS, PointType.valueOf(destinationEntry.getCoordinates()));\n+        }\n+    }\n+\n+    protected void updateAllTrips(AllTrips allTrips) {\n+        QuantityType<Length> qtTotalElectric = QuantityType\n+                .valueOf(Converter.round(allTrips.totalElectricDistance.userTotal), MetricPrefix.KILO(SIUnits.METRE));\n+        QuantityType<Length> qtLongestElectricRange = QuantityType\n+                .valueOf(Converter.round(allTrips.chargecycleRange.userHigh), MetricPrefix.KILO(SIUnits.METRE));\n+        QuantityType<Length> qtDistanceSinceCharge = QuantityType.valueOf(\n+                Converter.round(allTrips.chargecycleRange.userCurrentChargeCycle), MetricPrefix.KILO(SIUnits.METRE));\n+\n+        updateChannel(CHANNEL_GROUP_LIFETIME, TOTAL_DRIVEN_DISTANCE,\n+                imperial ? Converter.getMiles(qtTotalElectric) : qtTotalElectric);\n+        updateChannel(CHANNEL_GROUP_LIFETIME, SINGLE_LONGEST_DISTANCE,\n+                imperial ? Converter.getMiles(qtLongestElectricRange) : qtLongestElectricRange);\n+        updateChannel(CHANNEL_GROUP_LAST_TRIP, DISTANCE_SINCE_CHARGING,\n+                imperial ? Converter.getMiles(qtDistanceSinceCharge) : qtDistanceSinceCharge);\n+\n+        // Conversion from kwh/100km to kwh/10mi has to be done manually\n+        double avgConsumotion = imperial ? allTrips.avgElectricConsumption.userAverage * Converter.MILES_TO_KM_RATIO\n+                : allTrips.avgElectricConsumption.userAverage;\n+        double avgCombinedConsumption = imperial\n+                ? allTrips.avgCombinedConsumption.userAverage * Converter.MILES_TO_KM_RATIO\n+                : allTrips.avgCombinedConsumption.userAverage;\n+        double avgRecuperation = imperial ? allTrips.avgRecuperation.userAverage * Converter.MILES_TO_KM_RATIO\n+                : allTrips.avgRecuperation.userAverage;\n+\n+        updateChannel(CHANNEL_GROUP_LIFETIME, AVG_CONSUMPTION,\n+                QuantityType.valueOf(Converter.round(avgConsumotion), Units.KILOWATT_HOUR));\n+        updateChannel(CHANNEL_GROUP_LIFETIME, AVG_COMBINED_CONSUMPTION,\n+                QuantityType.valueOf(Converter.round(avgCombinedConsumption), Units.LITRE));\n+        updateChannel(CHANNEL_GROUP_LIFETIME, AVG_RECUPERATION,\n+                QuantityType.valueOf(Converter.round(avgRecuperation), Units.KILOWATT_HOUR));\n+    }\n+\n+    protected void updateLastTrip(LastTrip trip) {\n+        // Whyever the Last Trip DateTime is delivered without offest - so LocalTime\n+        updateChannel(CHANNEL_GROUP_LAST_TRIP, DATE,\n+                DateTimeType.valueOf(Converter.getLocalDateTimeWithoutOffest(trip.date)));\n+        updateChannel(CHANNEL_GROUP_LAST_TRIP, DURATION, QuantityType.valueOf(trip.duration, Units.MINUTE));\n+\n+        QuantityType<Length> qtTotalDistance = QuantityType.valueOf(Converter.round(trip.totalDistance),\n+                MetricPrefix.KILO(SIUnits.METRE));\n+        updateChannel(CHANNEL_GROUP_LAST_TRIP, DISTANCE,\n+                imperial ? Converter.getMiles(qtTotalDistance) : qtTotalDistance);\n+\n+        // Conversion from kwh/100km to kwh/10mi has to be done manually\n+        double avgConsumtption = imperial ? trip.avgElectricConsumption * Converter.MILES_TO_KM_RATIO\n+                : trip.avgElectricConsumption;\n+        double avgCombinedConsumption = imperial ? trip.avgCombinedConsumption * Converter.MILES_TO_KM_RATIO\n+                : trip.avgCombinedConsumption;\n+        double avgRecuperation = imperial ? trip.avgRecuperation * Converter.MILES_TO_KM_RATIO : trip.avgRecuperation;\n+\n+        updateChannel(CHANNEL_GROUP_LAST_TRIP, AVG_CONSUMPTION,\n+                QuantityType.valueOf(Converter.round(avgConsumtption), Units.KILOWATT_HOUR));\n+        updateChannel(CHANNEL_GROUP_LAST_TRIP, AVG_COMBINED_CONSUMPTION,\n+                QuantityType.valueOf(Converter.round(avgCombinedConsumption), Units.LITRE));\n+        updateChannel(CHANNEL_GROUP_LAST_TRIP, AVG_RECUPERATION,\n+                QuantityType.valueOf(Converter.round(avgRecuperation), Units.KILOWATT_HOUR));\n+    }\n+\n+    protected void updateChargeProfileFromContent(String content) {\n+        ChargeProfileWrapper.fromJson(content).ifPresent(this::updateChargeProfile);\n+    }\n+\n+    protected void updateChargeProfile(ChargeProfileWrapper wrapper) {\n+        updateChannel(CHANNEL_GROUP_CHARGE, CHARGE_PROFILE_PREFERENCE,\n+                StringType.valueOf(Converter.toTitleCase(wrapper.getPreference())));\n+        updateChannel(CHANNEL_GROUP_CHARGE, CHARGE_PROFILE_MODE,\n+                StringType.valueOf(Converter.toTitleCase(wrapper.getMode())));\n+        final Boolean climate = wrapper.isEnabled(ProfileKey.CLIMATE);\n+        updateChannel(CHANNEL_GROUP_CHARGE, CHARGE_PROFILE_CLIMATE,\n+                climate == null ? UnDefType.UNDEF : OnOffType.from(climate));\n+        updateTimedState(wrapper, ProfileKey.WINDOWSTART);\n+        updateTimedState(wrapper, ProfileKey.WINDOWEND);\n+        updateTimedState(wrapper, ProfileKey.TIMER1);\n+        updateTimedState(wrapper, ProfileKey.TIMER2);\n+        updateTimedState(wrapper, ProfileKey.TIMER3);\n+        updateTimedState(wrapper, ProfileKey.OVERRIDE);\n+    }\n+\n+    protected void updateTimedState(ChargeProfileWrapper profile, ProfileKey key) {\n+        final TimedChannel timed = ChargeProfileUtils.getTimedChannel(key);\n+        if (timed != null) {\n+            final LocalTime time = profile.getTime(key);\n+            updateChannel(CHANNEL_GROUP_CHARGE, timed.time, time == null ? UnDefType.UNDEF\n+                    : new DateTimeType(ZonedDateTime.of(Constants.EPOCH_DAY, time, ZoneId.systemDefault())));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "48af48c82562d006b6f2aa35922270f181c885ed"}, "originalPosition": 366}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMDAzNzA5Mw==", "bodyText": "Checked the code and there's only this occurrence of DateTime creation. Do you think it's benefical to provide a helper function?", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r600037093", "createdAt": "2021-03-23T23:48:23Z", "author": {"login": "weymann"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/VehicleChannelHandler.java", "diffHunk": "@@ -0,0 +1,532 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bmwconnecteddrive.internal.handler;\n+\n+import static org.openhab.binding.bmwconnecteddrive.internal.ConnectedDriveConstants.*;\n+\n+import java.time.DayOfWeek;\n+import java.time.LocalTime;\n+import java.time.ZoneId;\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.EnumSet;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import javax.measure.quantity.Length;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.binding.bmwconnecteddrive.internal.ConnectedDriveConstants.VehicleType;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.Destination;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.statistics.AllTrips;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.statistics.LastTrip;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.status.CBSMessage;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.status.CCMMessage;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.status.Doors;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.status.Position;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.status.VehicleStatus;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.status.Windows;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileUtils;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileUtils.TimedChannel;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileWrapper;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileWrapper.ProfileKey;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Constants;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Converter;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.RemoteServiceUtils;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.VehicleStatusUtils;\n+import org.openhab.core.library.types.DateTimeType;\n+import org.openhab.core.library.types.DecimalType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.PointType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.library.unit.ImperialUnits;\n+import org.openhab.core.library.unit.MetricPrefix;\n+import org.openhab.core.library.unit.SIUnits;\n+import org.openhab.core.library.unit.Units;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.StateOption;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonSyntaxException;\n+\n+/**\n+ * The {@link VehicleChannelHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Bernd Weymann - Initial contribution\n+ * @author Norbert Truchsess - edit & send of charge profile\n+ */\n+@NonNullByDefault\n+public class VehicleChannelHandler extends BaseThingHandler {\n+    protected final Logger logger = LoggerFactory.getLogger(VehicleChannelHandler.class);\n+    protected boolean imperial = false;\n+    protected boolean hasFuel = false;\n+    protected boolean isElectric = false;\n+    protected boolean isHybrid = false;\n+\n+    // List Interfaces\n+    protected List<CBSMessage> serviceList = new ArrayList<CBSMessage>();\n+    protected String selectedService = Constants.UNDEF;\n+    protected List<CCMMessage> checkControlList = new ArrayList<CCMMessage>();\n+    protected String selectedCC = Constants.UNDEF;\n+    protected List<Destination> destinationList = new ArrayList<Destination>();\n+    protected String selectedDestination = Constants.UNDEF;\n+\n+    protected BMWConnectedDriveOptionProvider optionProvider;\n+\n+    // Data Caches\n+    protected Optional<String> vehicleStatusCache = Optional.empty();\n+    protected Optional<String> lastTripCache = Optional.empty();\n+    protected Optional<String> allTripsCache = Optional.empty();\n+    protected Optional<String> chargeProfileCache = Optional.empty();\n+    protected Optional<String> rangeMapCache = Optional.empty();\n+    protected Optional<String> destinationCache = Optional.empty();\n+    protected Optional<byte[]> imageCache = Optional.empty();\n+\n+    public VehicleChannelHandler(Thing thing, BMWConnectedDriveOptionProvider op, String type, boolean imperial) {\n+        super(thing);\n+        optionProvider = op;\n+\n+        this.imperial = imperial;\n+        hasFuel = type.equals(VehicleType.CONVENTIONAL.toString()) || type.equals(VehicleType.PLUGIN_HYBRID.toString())\n+                || type.equals(VehicleType.ELECTRIC_REX.toString());\n+        isElectric = type.equals(VehicleType.PLUGIN_HYBRID.toString())\n+                || type.equals(VehicleType.ELECTRIC_REX.toString()) || type.equals(VehicleType.ELECTRIC.toString());\n+        isHybrid = hasFuel && isElectric;\n+\n+        setOptions(CHANNEL_GROUP_REMOTE, REMOTE_SERVICE_COMMAND, RemoteServiceUtils.getOptions(isElectric));\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+    }\n+\n+    @Override\n+    public void initialize() {\n+    }\n+\n+    private void setOptions(final String group, final String id, List<StateOption> options) {\n+        optionProvider.setStateOptions(new ChannelUID(thing.getUID(), group, id), options);\n+    }\n+\n+    protected void updateChannel(final String group, final String id, final State state) {\n+        updateState(new ChannelUID(thing.getUID(), group, id), state);\n+    }\n+\n+    protected void updateCheckControls(List<CCMMessage> ccl) {\n+        if (ccl.size() == 0) {\n+            // No Check Control available - show not active\n+            CCMMessage ccm = new CCMMessage();\n+            ccm.ccmDescriptionLong = Constants.NO_ENTRIES;\n+            ccm.ccmDescriptionShort = Constants.NO_ENTRIES;\n+            ccm.ccmId = -1;\n+            ccm.ccmMileage = -1;\n+            ccl.add(ccm);\n+        }\n+\n+        // add all elements to options\n+        checkControlList = ccl;\n+        List<StateOption> ccmDescriptionOptions = new ArrayList<>();\n+        List<StateOption> ccmDetailsOptions = new ArrayList<>();\n+        List<StateOption> ccmMileageOptions = new ArrayList<>();\n+        boolean isSelectedElementIn = false;\n+        int index = 0;\n+        for (CCMMessage ccEntry : checkControlList) {\n+            ccmDescriptionOptions.add(new StateOption(Integer.toString(index), ccEntry.ccmDescriptionShort));\n+            ccmDetailsOptions.add(new StateOption(Integer.toString(index), ccEntry.ccmDescriptionLong));\n+            ccmMileageOptions.add(new StateOption(Integer.toString(index), Integer.toString(ccEntry.ccmMileage)));\n+            if (selectedCC.equals(ccEntry.ccmDescriptionShort)) {\n+                isSelectedElementIn = true;\n+            }\n+            index++;\n+        }\n+        setOptions(CHANNEL_GROUP_CHECK_CONTROL, NAME, ccmDescriptionOptions);\n+        setOptions(CHANNEL_GROUP_CHECK_CONTROL, DETAILS, ccmDetailsOptions);\n+        setOptions(CHANNEL_GROUP_CHECK_CONTROL, MILEAGE, ccmMileageOptions);\n+\n+        // if current selected item isn't anymore in the list select first entry\n+        if (!isSelectedElementIn) {\n+            selectCheckControl(0);\n+        }\n+    }\n+\n+    protected void selectCheckControl(int index) {\n+        if (index >= 0 && index < checkControlList.size()) {\n+            CCMMessage ccEntry = checkControlList.get(index);\n+            selectedCC = ccEntry.ccmDescriptionShort;\n+            updateChannel(CHANNEL_GROUP_CHECK_CONTROL, NAME, StringType.valueOf(ccEntry.ccmDescriptionShort));\n+            updateChannel(CHANNEL_GROUP_CHECK_CONTROL, DETAILS, StringType.valueOf(ccEntry.ccmDescriptionLong));\n+            updateChannel(CHANNEL_GROUP_CHECK_CONTROL, MILEAGE,\n+                    QuantityType.valueOf(Converter.round(ccEntry.ccmMileage),\n+                            imperial ? ImperialUnits.MILE : MetricPrefix.KILO(SIUnits.METRE)));\n+        }\n+    }\n+\n+    protected void updateServices(List<CBSMessage> sl) {\n+        // if list is empty add \"undefined\" element\n+        if (sl.size() == 0) {\n+            CBSMessage cbsm = new CBSMessage();\n+            cbsm.cbsType = Constants.NO_ENTRIES;\n+            cbsm.cbsDescription = Constants.NO_ENTRIES;\n+            sl.add(cbsm);\n+        }\n+\n+        // add all elements to options\n+        serviceList = sl;\n+        List<StateOption> serviceNameOptions = new ArrayList<>();\n+        List<StateOption> serviceDetailsOptions = new ArrayList<>();\n+        List<StateOption> serviceDateOptions = new ArrayList<>();\n+        List<StateOption> serviceMileageOptions = new ArrayList<>();\n+        boolean isSelectedElementIn = false;\n+        int index = 0;\n+        for (CBSMessage serviceEntry : serviceList) {\n+            // create StateOption with \"value = list index\" and \"label = human readable string\"\n+            serviceNameOptions.add(new StateOption(Integer.toString(index), serviceEntry.getType()));\n+            serviceDetailsOptions.add(new StateOption(Integer.toString(index), serviceEntry.getDescription()));\n+            serviceDateOptions.add(new StateOption(Integer.toString(index), serviceEntry.getDueDate()));\n+            serviceMileageOptions\n+                    .add(new StateOption(Integer.toString(index), Integer.toString(serviceEntry.cbsRemainingMileage)));\n+            if (selectedService.equals(serviceEntry.getType())) {\n+                isSelectedElementIn = true;\n+            }\n+            index++;\n+        }\n+        setOptions(CHANNEL_GROUP_SERVICE, NAME, serviceNameOptions);\n+        setOptions(CHANNEL_GROUP_SERVICE, DETAILS, serviceDetailsOptions);\n+        setOptions(CHANNEL_GROUP_SERVICE, DATE, serviceDateOptions);\n+        setOptions(CHANNEL_GROUP_SERVICE, MILEAGE, serviceMileageOptions);\n+\n+        // if current selected item isn't anymore in the list select first entry\n+        if (!isSelectedElementIn) {\n+            selectService(0);\n+        }\n+    }\n+\n+    protected void selectService(int index) {\n+        if (index >= 0 && index < serviceList.size()) {\n+            CBSMessage serviceEntry = serviceList.get(index);\n+            selectedService = serviceEntry.cbsType;\n+            updateChannel(CHANNEL_GROUP_SERVICE, NAME,\n+                    StringType.valueOf(Converter.toTitleCase(serviceEntry.getType())));\n+            updateChannel(CHANNEL_GROUP_SERVICE, DETAILS,\n+                    StringType.valueOf(Converter.toTitleCase(serviceEntry.getDescription())));\n+            updateChannel(CHANNEL_GROUP_SERVICE, DATE,\n+                    DateTimeType.valueOf(Converter.getLocalDateTime(serviceEntry.getDueDate())));\n+            updateChannel(CHANNEL_GROUP_SERVICE, MILEAGE,\n+                    QuantityType.valueOf(Converter.round(serviceEntry.cbsRemainingMileage),\n+                            imperial ? ImperialUnits.MILE : MetricPrefix.KILO(SIUnits.METRE)));\n+        }\n+    }\n+\n+    protected void updateDestinations(List<Destination> dl) {\n+        // if list is empty add \"undefined\" element\n+        if (dl.size() == 0) {\n+            Destination dest = new Destination();\n+            dest.city = Constants.NO_ENTRIES;\n+            dest.lat = -1;\n+            dest.lon = -1;\n+            dl.add(dest);\n+        }\n+\n+        // add all elements to options\n+        destinationList = dl;\n+        List<StateOption> destinationNameOptions = new ArrayList<>();\n+        List<StateOption> destinationGPSOptions = new ArrayList<>();\n+        boolean isSelectedElementIn = false;\n+        int index = 0;\n+        for (Destination destination : destinationList) {\n+            destinationNameOptions.add(new StateOption(Integer.toString(index), destination.getAddress()));\n+            destinationGPSOptions.add(new StateOption(Integer.toString(index), destination.getCoordinates()));\n+            if (selectedDestination.equals(destination.getAddress())) {\n+                isSelectedElementIn = true;\n+            }\n+            index++;\n+        }\n+        setOptions(CHANNEL_GROUP_DESTINATION, NAME, destinationNameOptions);\n+        setOptions(CHANNEL_GROUP_DESTINATION, GPS, destinationGPSOptions);\n+\n+        // if current selected item isn't anymore in the list select first entry\n+        if (!isSelectedElementIn) {\n+            selectDestination(0);\n+        }\n+    }\n+\n+    protected void selectDestination(int index) {\n+        if (index >= 0 && index < destinationList.size()) {\n+            Destination destinationEntry = destinationList.get(index);\n+            // update selected Item\n+            selectedDestination = destinationEntry.getAddress();\n+            // update coordinates according to new set location\n+            updateChannel(CHANNEL_GROUP_DESTINATION, NAME, StringType.valueOf(destinationEntry.getAddress()));\n+            updateChannel(CHANNEL_GROUP_DESTINATION, GPS, PointType.valueOf(destinationEntry.getCoordinates()));\n+        }\n+    }\n+\n+    protected void updateAllTrips(AllTrips allTrips) {\n+        QuantityType<Length> qtTotalElectric = QuantityType\n+                .valueOf(Converter.round(allTrips.totalElectricDistance.userTotal), MetricPrefix.KILO(SIUnits.METRE));\n+        QuantityType<Length> qtLongestElectricRange = QuantityType\n+                .valueOf(Converter.round(allTrips.chargecycleRange.userHigh), MetricPrefix.KILO(SIUnits.METRE));\n+        QuantityType<Length> qtDistanceSinceCharge = QuantityType.valueOf(\n+                Converter.round(allTrips.chargecycleRange.userCurrentChargeCycle), MetricPrefix.KILO(SIUnits.METRE));\n+\n+        updateChannel(CHANNEL_GROUP_LIFETIME, TOTAL_DRIVEN_DISTANCE,\n+                imperial ? Converter.getMiles(qtTotalElectric) : qtTotalElectric);\n+        updateChannel(CHANNEL_GROUP_LIFETIME, SINGLE_LONGEST_DISTANCE,\n+                imperial ? Converter.getMiles(qtLongestElectricRange) : qtLongestElectricRange);\n+        updateChannel(CHANNEL_GROUP_LAST_TRIP, DISTANCE_SINCE_CHARGING,\n+                imperial ? Converter.getMiles(qtDistanceSinceCharge) : qtDistanceSinceCharge);\n+\n+        // Conversion from kwh/100km to kwh/10mi has to be done manually\n+        double avgConsumotion = imperial ? allTrips.avgElectricConsumption.userAverage * Converter.MILES_TO_KM_RATIO\n+                : allTrips.avgElectricConsumption.userAverage;\n+        double avgCombinedConsumption = imperial\n+                ? allTrips.avgCombinedConsumption.userAverage * Converter.MILES_TO_KM_RATIO\n+                : allTrips.avgCombinedConsumption.userAverage;\n+        double avgRecuperation = imperial ? allTrips.avgRecuperation.userAverage * Converter.MILES_TO_KM_RATIO\n+                : allTrips.avgRecuperation.userAverage;\n+\n+        updateChannel(CHANNEL_GROUP_LIFETIME, AVG_CONSUMPTION,\n+                QuantityType.valueOf(Converter.round(avgConsumotion), Units.KILOWATT_HOUR));\n+        updateChannel(CHANNEL_GROUP_LIFETIME, AVG_COMBINED_CONSUMPTION,\n+                QuantityType.valueOf(Converter.round(avgCombinedConsumption), Units.LITRE));\n+        updateChannel(CHANNEL_GROUP_LIFETIME, AVG_RECUPERATION,\n+                QuantityType.valueOf(Converter.round(avgRecuperation), Units.KILOWATT_HOUR));\n+    }\n+\n+    protected void updateLastTrip(LastTrip trip) {\n+        // Whyever the Last Trip DateTime is delivered without offest - so LocalTime\n+        updateChannel(CHANNEL_GROUP_LAST_TRIP, DATE,\n+                DateTimeType.valueOf(Converter.getLocalDateTimeWithoutOffest(trip.date)));\n+        updateChannel(CHANNEL_GROUP_LAST_TRIP, DURATION, QuantityType.valueOf(trip.duration, Units.MINUTE));\n+\n+        QuantityType<Length> qtTotalDistance = QuantityType.valueOf(Converter.round(trip.totalDistance),\n+                MetricPrefix.KILO(SIUnits.METRE));\n+        updateChannel(CHANNEL_GROUP_LAST_TRIP, DISTANCE,\n+                imperial ? Converter.getMiles(qtTotalDistance) : qtTotalDistance);\n+\n+        // Conversion from kwh/100km to kwh/10mi has to be done manually\n+        double avgConsumtption = imperial ? trip.avgElectricConsumption * Converter.MILES_TO_KM_RATIO\n+                : trip.avgElectricConsumption;\n+        double avgCombinedConsumption = imperial ? trip.avgCombinedConsumption * Converter.MILES_TO_KM_RATIO\n+                : trip.avgCombinedConsumption;\n+        double avgRecuperation = imperial ? trip.avgRecuperation * Converter.MILES_TO_KM_RATIO : trip.avgRecuperation;\n+\n+        updateChannel(CHANNEL_GROUP_LAST_TRIP, AVG_CONSUMPTION,\n+                QuantityType.valueOf(Converter.round(avgConsumtption), Units.KILOWATT_HOUR));\n+        updateChannel(CHANNEL_GROUP_LAST_TRIP, AVG_COMBINED_CONSUMPTION,\n+                QuantityType.valueOf(Converter.round(avgCombinedConsumption), Units.LITRE));\n+        updateChannel(CHANNEL_GROUP_LAST_TRIP, AVG_RECUPERATION,\n+                QuantityType.valueOf(Converter.round(avgRecuperation), Units.KILOWATT_HOUR));\n+    }\n+\n+    protected void updateChargeProfileFromContent(String content) {\n+        ChargeProfileWrapper.fromJson(content).ifPresent(this::updateChargeProfile);\n+    }\n+\n+    protected void updateChargeProfile(ChargeProfileWrapper wrapper) {\n+        updateChannel(CHANNEL_GROUP_CHARGE, CHARGE_PROFILE_PREFERENCE,\n+                StringType.valueOf(Converter.toTitleCase(wrapper.getPreference())));\n+        updateChannel(CHANNEL_GROUP_CHARGE, CHARGE_PROFILE_MODE,\n+                StringType.valueOf(Converter.toTitleCase(wrapper.getMode())));\n+        final Boolean climate = wrapper.isEnabled(ProfileKey.CLIMATE);\n+        updateChannel(CHANNEL_GROUP_CHARGE, CHARGE_PROFILE_CLIMATE,\n+                climate == null ? UnDefType.UNDEF : OnOffType.from(climate));\n+        updateTimedState(wrapper, ProfileKey.WINDOWSTART);\n+        updateTimedState(wrapper, ProfileKey.WINDOWEND);\n+        updateTimedState(wrapper, ProfileKey.TIMER1);\n+        updateTimedState(wrapper, ProfileKey.TIMER2);\n+        updateTimedState(wrapper, ProfileKey.TIMER3);\n+        updateTimedState(wrapper, ProfileKey.OVERRIDE);\n+    }\n+\n+    protected void updateTimedState(ChargeProfileWrapper profile, ProfileKey key) {\n+        final TimedChannel timed = ChargeProfileUtils.getTimedChannel(key);\n+        if (timed != null) {\n+            final LocalTime time = profile.getTime(key);\n+            updateChannel(CHANNEL_GROUP_CHARGE, timed.time, time == null ? UnDefType.UNDEF\n+                    : new DateTimeType(ZonedDateTime.of(Constants.EPOCH_DAY, time, ZoneId.systemDefault())));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5NzkxMjYwMQ=="}, "originalCommit": {"oid": "48af48c82562d006b6f2aa35922270f181c885ed"}, "originalPosition": 366}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMTg2MzI5Mg==", "bodyText": "I thought there was already a suiting method in the Converter class. Never mind.", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r601863292", "createdAt": "2021-03-25T21:51:56Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/VehicleChannelHandler.java", "diffHunk": "@@ -0,0 +1,532 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bmwconnecteddrive.internal.handler;\n+\n+import static org.openhab.binding.bmwconnecteddrive.internal.ConnectedDriveConstants.*;\n+\n+import java.time.DayOfWeek;\n+import java.time.LocalTime;\n+import java.time.ZoneId;\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.EnumSet;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import javax.measure.quantity.Length;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.binding.bmwconnecteddrive.internal.ConnectedDriveConstants.VehicleType;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.Destination;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.statistics.AllTrips;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.statistics.LastTrip;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.status.CBSMessage;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.status.CCMMessage;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.status.Doors;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.status.Position;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.status.VehicleStatus;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.status.Windows;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileUtils;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileUtils.TimedChannel;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileWrapper;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileWrapper.ProfileKey;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Constants;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Converter;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.RemoteServiceUtils;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.VehicleStatusUtils;\n+import org.openhab.core.library.types.DateTimeType;\n+import org.openhab.core.library.types.DecimalType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.PointType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.library.unit.ImperialUnits;\n+import org.openhab.core.library.unit.MetricPrefix;\n+import org.openhab.core.library.unit.SIUnits;\n+import org.openhab.core.library.unit.Units;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.StateOption;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonSyntaxException;\n+\n+/**\n+ * The {@link VehicleChannelHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Bernd Weymann - Initial contribution\n+ * @author Norbert Truchsess - edit & send of charge profile\n+ */\n+@NonNullByDefault\n+public class VehicleChannelHandler extends BaseThingHandler {\n+    protected final Logger logger = LoggerFactory.getLogger(VehicleChannelHandler.class);\n+    protected boolean imperial = false;\n+    protected boolean hasFuel = false;\n+    protected boolean isElectric = false;\n+    protected boolean isHybrid = false;\n+\n+    // List Interfaces\n+    protected List<CBSMessage> serviceList = new ArrayList<CBSMessage>();\n+    protected String selectedService = Constants.UNDEF;\n+    protected List<CCMMessage> checkControlList = new ArrayList<CCMMessage>();\n+    protected String selectedCC = Constants.UNDEF;\n+    protected List<Destination> destinationList = new ArrayList<Destination>();\n+    protected String selectedDestination = Constants.UNDEF;\n+\n+    protected BMWConnectedDriveOptionProvider optionProvider;\n+\n+    // Data Caches\n+    protected Optional<String> vehicleStatusCache = Optional.empty();\n+    protected Optional<String> lastTripCache = Optional.empty();\n+    protected Optional<String> allTripsCache = Optional.empty();\n+    protected Optional<String> chargeProfileCache = Optional.empty();\n+    protected Optional<String> rangeMapCache = Optional.empty();\n+    protected Optional<String> destinationCache = Optional.empty();\n+    protected Optional<byte[]> imageCache = Optional.empty();\n+\n+    public VehicleChannelHandler(Thing thing, BMWConnectedDriveOptionProvider op, String type, boolean imperial) {\n+        super(thing);\n+        optionProvider = op;\n+\n+        this.imperial = imperial;\n+        hasFuel = type.equals(VehicleType.CONVENTIONAL.toString()) || type.equals(VehicleType.PLUGIN_HYBRID.toString())\n+                || type.equals(VehicleType.ELECTRIC_REX.toString());\n+        isElectric = type.equals(VehicleType.PLUGIN_HYBRID.toString())\n+                || type.equals(VehicleType.ELECTRIC_REX.toString()) || type.equals(VehicleType.ELECTRIC.toString());\n+        isHybrid = hasFuel && isElectric;\n+\n+        setOptions(CHANNEL_GROUP_REMOTE, REMOTE_SERVICE_COMMAND, RemoteServiceUtils.getOptions(isElectric));\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+    }\n+\n+    @Override\n+    public void initialize() {\n+    }\n+\n+    private void setOptions(final String group, final String id, List<StateOption> options) {\n+        optionProvider.setStateOptions(new ChannelUID(thing.getUID(), group, id), options);\n+    }\n+\n+    protected void updateChannel(final String group, final String id, final State state) {\n+        updateState(new ChannelUID(thing.getUID(), group, id), state);\n+    }\n+\n+    protected void updateCheckControls(List<CCMMessage> ccl) {\n+        if (ccl.size() == 0) {\n+            // No Check Control available - show not active\n+            CCMMessage ccm = new CCMMessage();\n+            ccm.ccmDescriptionLong = Constants.NO_ENTRIES;\n+            ccm.ccmDescriptionShort = Constants.NO_ENTRIES;\n+            ccm.ccmId = -1;\n+            ccm.ccmMileage = -1;\n+            ccl.add(ccm);\n+        }\n+\n+        // add all elements to options\n+        checkControlList = ccl;\n+        List<StateOption> ccmDescriptionOptions = new ArrayList<>();\n+        List<StateOption> ccmDetailsOptions = new ArrayList<>();\n+        List<StateOption> ccmMileageOptions = new ArrayList<>();\n+        boolean isSelectedElementIn = false;\n+        int index = 0;\n+        for (CCMMessage ccEntry : checkControlList) {\n+            ccmDescriptionOptions.add(new StateOption(Integer.toString(index), ccEntry.ccmDescriptionShort));\n+            ccmDetailsOptions.add(new StateOption(Integer.toString(index), ccEntry.ccmDescriptionLong));\n+            ccmMileageOptions.add(new StateOption(Integer.toString(index), Integer.toString(ccEntry.ccmMileage)));\n+            if (selectedCC.equals(ccEntry.ccmDescriptionShort)) {\n+                isSelectedElementIn = true;\n+            }\n+            index++;\n+        }\n+        setOptions(CHANNEL_GROUP_CHECK_CONTROL, NAME, ccmDescriptionOptions);\n+        setOptions(CHANNEL_GROUP_CHECK_CONTROL, DETAILS, ccmDetailsOptions);\n+        setOptions(CHANNEL_GROUP_CHECK_CONTROL, MILEAGE, ccmMileageOptions);\n+\n+        // if current selected item isn't anymore in the list select first entry\n+        if (!isSelectedElementIn) {\n+            selectCheckControl(0);\n+        }\n+    }\n+\n+    protected void selectCheckControl(int index) {\n+        if (index >= 0 && index < checkControlList.size()) {\n+            CCMMessage ccEntry = checkControlList.get(index);\n+            selectedCC = ccEntry.ccmDescriptionShort;\n+            updateChannel(CHANNEL_GROUP_CHECK_CONTROL, NAME, StringType.valueOf(ccEntry.ccmDescriptionShort));\n+            updateChannel(CHANNEL_GROUP_CHECK_CONTROL, DETAILS, StringType.valueOf(ccEntry.ccmDescriptionLong));\n+            updateChannel(CHANNEL_GROUP_CHECK_CONTROL, MILEAGE,\n+                    QuantityType.valueOf(Converter.round(ccEntry.ccmMileage),\n+                            imperial ? ImperialUnits.MILE : MetricPrefix.KILO(SIUnits.METRE)));\n+        }\n+    }\n+\n+    protected void updateServices(List<CBSMessage> sl) {\n+        // if list is empty add \"undefined\" element\n+        if (sl.size() == 0) {\n+            CBSMessage cbsm = new CBSMessage();\n+            cbsm.cbsType = Constants.NO_ENTRIES;\n+            cbsm.cbsDescription = Constants.NO_ENTRIES;\n+            sl.add(cbsm);\n+        }\n+\n+        // add all elements to options\n+        serviceList = sl;\n+        List<StateOption> serviceNameOptions = new ArrayList<>();\n+        List<StateOption> serviceDetailsOptions = new ArrayList<>();\n+        List<StateOption> serviceDateOptions = new ArrayList<>();\n+        List<StateOption> serviceMileageOptions = new ArrayList<>();\n+        boolean isSelectedElementIn = false;\n+        int index = 0;\n+        for (CBSMessage serviceEntry : serviceList) {\n+            // create StateOption with \"value = list index\" and \"label = human readable string\"\n+            serviceNameOptions.add(new StateOption(Integer.toString(index), serviceEntry.getType()));\n+            serviceDetailsOptions.add(new StateOption(Integer.toString(index), serviceEntry.getDescription()));\n+            serviceDateOptions.add(new StateOption(Integer.toString(index), serviceEntry.getDueDate()));\n+            serviceMileageOptions\n+                    .add(new StateOption(Integer.toString(index), Integer.toString(serviceEntry.cbsRemainingMileage)));\n+            if (selectedService.equals(serviceEntry.getType())) {\n+                isSelectedElementIn = true;\n+            }\n+            index++;\n+        }\n+        setOptions(CHANNEL_GROUP_SERVICE, NAME, serviceNameOptions);\n+        setOptions(CHANNEL_GROUP_SERVICE, DETAILS, serviceDetailsOptions);\n+        setOptions(CHANNEL_GROUP_SERVICE, DATE, serviceDateOptions);\n+        setOptions(CHANNEL_GROUP_SERVICE, MILEAGE, serviceMileageOptions);\n+\n+        // if current selected item isn't anymore in the list select first entry\n+        if (!isSelectedElementIn) {\n+            selectService(0);\n+        }\n+    }\n+\n+    protected void selectService(int index) {\n+        if (index >= 0 && index < serviceList.size()) {\n+            CBSMessage serviceEntry = serviceList.get(index);\n+            selectedService = serviceEntry.cbsType;\n+            updateChannel(CHANNEL_GROUP_SERVICE, NAME,\n+                    StringType.valueOf(Converter.toTitleCase(serviceEntry.getType())));\n+            updateChannel(CHANNEL_GROUP_SERVICE, DETAILS,\n+                    StringType.valueOf(Converter.toTitleCase(serviceEntry.getDescription())));\n+            updateChannel(CHANNEL_GROUP_SERVICE, DATE,\n+                    DateTimeType.valueOf(Converter.getLocalDateTime(serviceEntry.getDueDate())));\n+            updateChannel(CHANNEL_GROUP_SERVICE, MILEAGE,\n+                    QuantityType.valueOf(Converter.round(serviceEntry.cbsRemainingMileage),\n+                            imperial ? ImperialUnits.MILE : MetricPrefix.KILO(SIUnits.METRE)));\n+        }\n+    }\n+\n+    protected void updateDestinations(List<Destination> dl) {\n+        // if list is empty add \"undefined\" element\n+        if (dl.size() == 0) {\n+            Destination dest = new Destination();\n+            dest.city = Constants.NO_ENTRIES;\n+            dest.lat = -1;\n+            dest.lon = -1;\n+            dl.add(dest);\n+        }\n+\n+        // add all elements to options\n+        destinationList = dl;\n+        List<StateOption> destinationNameOptions = new ArrayList<>();\n+        List<StateOption> destinationGPSOptions = new ArrayList<>();\n+        boolean isSelectedElementIn = false;\n+        int index = 0;\n+        for (Destination destination : destinationList) {\n+            destinationNameOptions.add(new StateOption(Integer.toString(index), destination.getAddress()));\n+            destinationGPSOptions.add(new StateOption(Integer.toString(index), destination.getCoordinates()));\n+            if (selectedDestination.equals(destination.getAddress())) {\n+                isSelectedElementIn = true;\n+            }\n+            index++;\n+        }\n+        setOptions(CHANNEL_GROUP_DESTINATION, NAME, destinationNameOptions);\n+        setOptions(CHANNEL_GROUP_DESTINATION, GPS, destinationGPSOptions);\n+\n+        // if current selected item isn't anymore in the list select first entry\n+        if (!isSelectedElementIn) {\n+            selectDestination(0);\n+        }\n+    }\n+\n+    protected void selectDestination(int index) {\n+        if (index >= 0 && index < destinationList.size()) {\n+            Destination destinationEntry = destinationList.get(index);\n+            // update selected Item\n+            selectedDestination = destinationEntry.getAddress();\n+            // update coordinates according to new set location\n+            updateChannel(CHANNEL_GROUP_DESTINATION, NAME, StringType.valueOf(destinationEntry.getAddress()));\n+            updateChannel(CHANNEL_GROUP_DESTINATION, GPS, PointType.valueOf(destinationEntry.getCoordinates()));\n+        }\n+    }\n+\n+    protected void updateAllTrips(AllTrips allTrips) {\n+        QuantityType<Length> qtTotalElectric = QuantityType\n+                .valueOf(Converter.round(allTrips.totalElectricDistance.userTotal), MetricPrefix.KILO(SIUnits.METRE));\n+        QuantityType<Length> qtLongestElectricRange = QuantityType\n+                .valueOf(Converter.round(allTrips.chargecycleRange.userHigh), MetricPrefix.KILO(SIUnits.METRE));\n+        QuantityType<Length> qtDistanceSinceCharge = QuantityType.valueOf(\n+                Converter.round(allTrips.chargecycleRange.userCurrentChargeCycle), MetricPrefix.KILO(SIUnits.METRE));\n+\n+        updateChannel(CHANNEL_GROUP_LIFETIME, TOTAL_DRIVEN_DISTANCE,\n+                imperial ? Converter.getMiles(qtTotalElectric) : qtTotalElectric);\n+        updateChannel(CHANNEL_GROUP_LIFETIME, SINGLE_LONGEST_DISTANCE,\n+                imperial ? Converter.getMiles(qtLongestElectricRange) : qtLongestElectricRange);\n+        updateChannel(CHANNEL_GROUP_LAST_TRIP, DISTANCE_SINCE_CHARGING,\n+                imperial ? Converter.getMiles(qtDistanceSinceCharge) : qtDistanceSinceCharge);\n+\n+        // Conversion from kwh/100km to kwh/10mi has to be done manually\n+        double avgConsumotion = imperial ? allTrips.avgElectricConsumption.userAverage * Converter.MILES_TO_KM_RATIO\n+                : allTrips.avgElectricConsumption.userAverage;\n+        double avgCombinedConsumption = imperial\n+                ? allTrips.avgCombinedConsumption.userAverage * Converter.MILES_TO_KM_RATIO\n+                : allTrips.avgCombinedConsumption.userAverage;\n+        double avgRecuperation = imperial ? allTrips.avgRecuperation.userAverage * Converter.MILES_TO_KM_RATIO\n+                : allTrips.avgRecuperation.userAverage;\n+\n+        updateChannel(CHANNEL_GROUP_LIFETIME, AVG_CONSUMPTION,\n+                QuantityType.valueOf(Converter.round(avgConsumotion), Units.KILOWATT_HOUR));\n+        updateChannel(CHANNEL_GROUP_LIFETIME, AVG_COMBINED_CONSUMPTION,\n+                QuantityType.valueOf(Converter.round(avgCombinedConsumption), Units.LITRE));\n+        updateChannel(CHANNEL_GROUP_LIFETIME, AVG_RECUPERATION,\n+                QuantityType.valueOf(Converter.round(avgRecuperation), Units.KILOWATT_HOUR));\n+    }\n+\n+    protected void updateLastTrip(LastTrip trip) {\n+        // Whyever the Last Trip DateTime is delivered without offest - so LocalTime\n+        updateChannel(CHANNEL_GROUP_LAST_TRIP, DATE,\n+                DateTimeType.valueOf(Converter.getLocalDateTimeWithoutOffest(trip.date)));\n+        updateChannel(CHANNEL_GROUP_LAST_TRIP, DURATION, QuantityType.valueOf(trip.duration, Units.MINUTE));\n+\n+        QuantityType<Length> qtTotalDistance = QuantityType.valueOf(Converter.round(trip.totalDistance),\n+                MetricPrefix.KILO(SIUnits.METRE));\n+        updateChannel(CHANNEL_GROUP_LAST_TRIP, DISTANCE,\n+                imperial ? Converter.getMiles(qtTotalDistance) : qtTotalDistance);\n+\n+        // Conversion from kwh/100km to kwh/10mi has to be done manually\n+        double avgConsumtption = imperial ? trip.avgElectricConsumption * Converter.MILES_TO_KM_RATIO\n+                : trip.avgElectricConsumption;\n+        double avgCombinedConsumption = imperial ? trip.avgCombinedConsumption * Converter.MILES_TO_KM_RATIO\n+                : trip.avgCombinedConsumption;\n+        double avgRecuperation = imperial ? trip.avgRecuperation * Converter.MILES_TO_KM_RATIO : trip.avgRecuperation;\n+\n+        updateChannel(CHANNEL_GROUP_LAST_TRIP, AVG_CONSUMPTION,\n+                QuantityType.valueOf(Converter.round(avgConsumtption), Units.KILOWATT_HOUR));\n+        updateChannel(CHANNEL_GROUP_LAST_TRIP, AVG_COMBINED_CONSUMPTION,\n+                QuantityType.valueOf(Converter.round(avgCombinedConsumption), Units.LITRE));\n+        updateChannel(CHANNEL_GROUP_LAST_TRIP, AVG_RECUPERATION,\n+                QuantityType.valueOf(Converter.round(avgRecuperation), Units.KILOWATT_HOUR));\n+    }\n+\n+    protected void updateChargeProfileFromContent(String content) {\n+        ChargeProfileWrapper.fromJson(content).ifPresent(this::updateChargeProfile);\n+    }\n+\n+    protected void updateChargeProfile(ChargeProfileWrapper wrapper) {\n+        updateChannel(CHANNEL_GROUP_CHARGE, CHARGE_PROFILE_PREFERENCE,\n+                StringType.valueOf(Converter.toTitleCase(wrapper.getPreference())));\n+        updateChannel(CHANNEL_GROUP_CHARGE, CHARGE_PROFILE_MODE,\n+                StringType.valueOf(Converter.toTitleCase(wrapper.getMode())));\n+        final Boolean climate = wrapper.isEnabled(ProfileKey.CLIMATE);\n+        updateChannel(CHANNEL_GROUP_CHARGE, CHARGE_PROFILE_CLIMATE,\n+                climate == null ? UnDefType.UNDEF : OnOffType.from(climate));\n+        updateTimedState(wrapper, ProfileKey.WINDOWSTART);\n+        updateTimedState(wrapper, ProfileKey.WINDOWEND);\n+        updateTimedState(wrapper, ProfileKey.TIMER1);\n+        updateTimedState(wrapper, ProfileKey.TIMER2);\n+        updateTimedState(wrapper, ProfileKey.TIMER3);\n+        updateTimedState(wrapper, ProfileKey.OVERRIDE);\n+    }\n+\n+    protected void updateTimedState(ChargeProfileWrapper profile, ProfileKey key) {\n+        final TimedChannel timed = ChargeProfileUtils.getTimedChannel(key);\n+        if (timed != null) {\n+            final LocalTime time = profile.getTime(key);\n+            updateChannel(CHANNEL_GROUP_CHARGE, timed.time, time == null ? UnDefType.UNDEF\n+                    : new DateTimeType(ZonedDateTime.of(Constants.EPOCH_DAY, time, ZoneId.systemDefault())));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5NzkxMjYwMQ=="}, "originalCommit": {"oid": "48af48c82562d006b6f2aa35922270f181c885ed"}, "originalPosition": 366}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4356, "cost": 1, "resetAt": "2021-11-13T12:10:21Z"}}}