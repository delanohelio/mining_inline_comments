{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTM4MzIwMzU3", "number": 9347, "title": "[MyQ] Initial commit of the MyQ binding for OH3", "bodyText": "Signed-off-by: Dan Cunningham dan@digitaldan.com\nThis introduces a new MyQ binding for openHAB to replace the 1.x version.   Feedback welcome.\nThis will replace the 1.x myq binding referenced in #6179", "createdAt": "2020-12-12T17:20:17Z", "url": "https://github.com/openhab/openhab-addons/pull/9347", "merged": true, "mergeCommit": {"oid": "42edf53a5a9b918c2a45dc5d85fa9258858b167c"}, "closed": true, "closedAt": "2021-02-26T22:50:25Z", "author": {"login": "digitaldan"}, "timelineItems": {"totalCount": 20, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdpeOUFgBqjQxNDgzMjYzMDE=", "endCursor": "Y3Vyc29yOnYyOpPPAAABd-CIzfAFqTYwMDAxMDAyOQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "df398a6aa33db0a0c6780a43aa744e112f48967a", "author": {"user": {"login": "computergeek1507", "name": "Scott H."}}, "url": "https://github.com/openhab/openhab-addons/commit/df398a6aa33db0a0c6780a43aa744e112f48967a", "committedDate": "2020-12-24T21:19:35Z", "message": "lights are 'lamp' in myq api"}, "afterCommit": {"oid": "60c6511faa1e1fcbd41f73e9e8958a14616a024b", "author": {"user": {"login": "digitaldan", "name": "Dan Cunningham"}}, "url": "https://github.com/openhab/openhab-addons/commit/60c6511faa1e1fcbd41f73e9e8958a14616a024b", "committedDate": "2020-12-24T05:55:18Z", "message": "remove whitespace\n\nSigned-off-by: Dan Cunningham <dan@digitaldan.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU4ODIxNjc2", "url": "https://github.com/openhab/openhab-addons/pull/9347#pullrequestreview-558821676", "createdAt": "2020-12-25T14:43:51Z", "commit": {"oid": "60c6511faa1e1fcbd41f73e9e8958a14616a024b"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yNVQxNDo0Mzo1MVrOILdAyA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yNVQxNDo0Mzo1MVrOILdAyA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODg4MDU4NA==", "bodyText": "To make the binding compile, you need to rebase your branch and set the version to the upcoming openHAB version: 3.1.0-SNAPSHOT.\nHere are the commands for rebasing your branch:\nIf not already done, add the upstream openHAB addon repo as a remote to your local repo and fetch it:\ngit remote add upstream https://github.com/openhab/openhab-addons.git\ngit fetch upstream\n\nThen, you can rebase your PR's branch onto main:\ngit rebase upstream/main\n\nFinally force-push the rebased branch to this PR's branch:\ngit push origin [your branch name of this PR] --force-with-lease", "url": "https://github.com/openhab/openhab-addons/pull/9347#discussion_r548880584", "createdAt": "2020-12-25T14:43:51Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.myq/pom.xml", "diffHunk": "@@ -0,0 +1,17 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<project xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns=\"http://maven.apache.org/POM/4.0.0\"\n+  xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n+\n+  <modelVersion>4.0.0</modelVersion>\n+\n+  <parent>\n+    <groupId>org.openhab.addons.bundles</groupId>\n+    <artifactId>org.openhab.addons.reactor.bundles</artifactId>\n+    <version>3.0.0-SNAPSHOT</version>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "60c6511faa1e1fcbd41f73e9e8958a14616a024b"}, "originalPosition": 10}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "1f966586c2904d90280b0a6a4436abfba0960fb5", "author": {"user": {"login": "digitaldan", "name": "Dan Cunningham"}}, "url": "https://github.com/openhab/openhab-addons/commit/1f966586c2904d90280b0a6a4436abfba0960fb5", "committedDate": "2020-12-26T04:31:35Z", "message": "Fix typos\n\nSigned-off-by: Dan Cunningham <dan@digitaldan.com>"}, "afterCommit": {"oid": "a07ac454f04e8480ca72705a8bcb520ff4db1d48", "author": {"user": {"login": "digitaldan", "name": "Dan Cunningham"}}, "url": "https://github.com/openhab/openhab-addons/commit/a07ac454f04e8480ca72705a8bcb520ff4db1d48", "committedDate": "2020-12-26T05:09:25Z", "message": "Signed-off-by: Dan Cunningham dan@digitaldan.com\n\nThis introduces a new MyQ binding for openHAB 3.x to replace the 1.x version mentioned in #6179. Feedback welcome."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "a07ac454f04e8480ca72705a8bcb520ff4db1d48", "author": {"user": {"login": "digitaldan", "name": "Dan Cunningham"}}, "url": "https://github.com/openhab/openhab-addons/commit/a07ac454f04e8480ca72705a8bcb520ff4db1d48", "committedDate": "2020-12-26T05:09:25Z", "message": "Signed-off-by: Dan Cunningham dan@digitaldan.com\n\nThis introduces a new MyQ binding for openHAB 3.x to replace the 1.x version mentioned in #6179. Feedback welcome."}, "afterCommit": {"oid": "b8d83d9fc9302866aeee3db0b32d99012d9a3a3d", "author": {"user": {"login": "digitaldan", "name": "Dan Cunningham"}}, "url": "https://github.com/openhab/openhab-addons/commit/b8d83d9fc9302866aeee3db0b32d99012d9a3a3d", "committedDate": "2020-12-26T06:17:59Z", "message": "This introduces a new MyQ binding for openHAB 3.x to replace the 1.x version mentioned in #6179. Feedback welcome.\n\nSigned-off-by: Dan Cunningham <dan@digitaldan.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTYzMDEwODAy", "url": "https://github.com/openhab/openhab-addons/pull/9347#pullrequestreview-563010802", "createdAt": "2021-01-06T20:15:38Z", "commit": {"oid": "b5c229bfaec596e8fe209df3946faf55db8b6b9d"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNlQyMDoxNTozOFrOIPU0vQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNlQyMDoyOTozMFrOIPVLEA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mjk0MDczMw==", "bodyText": "Same for below.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            ThingTypeUID:`account`\n          \n          \n            \n            ThingTypeUID: `account`", "url": "https://github.com/openhab/openhab-addons/pull/9347#discussion_r552940733", "createdAt": "2021-01-06T20:15:38Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.myq/README.md", "diffHunk": "@@ -0,0 +1,71 @@\n+# MyQ Binding\n+\n+This binding integrates with the [The Chamberlain Group MyQ](https://www.myq.com) cloud service. It allows monitoring and control over [MyQ](https://www.myq.com) enabled garage doors manufactured by LiftMaster, Chamberlain and Craftsman.\n+\n+## Supported Things\n+\n+### Account\n+\n+This represents the MyQ cloud account and uses the same credentials needed when using the MyQ mobile application.\n+\n+ThingTypeUID:`account`", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b5c229bfaec596e8fe209df3946faf55db8b6b9d"}, "originalPosition": 11}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mjk0MDgwNQ==", "bodyText": "Same for below.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            This represents a garage door associated with an account.  Multiple garage doors are supported.\n          \n          \n            \n            This represents a garage door associated with an account. Multiple garage doors are supported.", "url": "https://github.com/openhab/openhab-addons/pull/9347#discussion_r552940805", "createdAt": "2021-01-06T20:15:49Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.myq/README.md", "diffHunk": "@@ -0,0 +1,71 @@\n+# MyQ Binding\n+\n+This binding integrates with the [The Chamberlain Group MyQ](https://www.myq.com) cloud service. It allows monitoring and control over [MyQ](https://www.myq.com) enabled garage doors manufactured by LiftMaster, Chamberlain and Craftsman.\n+\n+## Supported Things\n+\n+### Account\n+\n+This represents the MyQ cloud account and uses the same credentials needed when using the MyQ mobile application.\n+\n+ThingTypeUID:`account`\n+\n+### Garage Door\n+\n+This represents a garage door associated with an account.  Multiple garage doors are supported.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b5c229bfaec596e8fe209df3946faf55db8b6b9d"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mjk0MTU1MQ==", "bodyText": "Is there any reason why these are two separate channels? What's the difference to the switch channel?", "url": "https://github.com/openhab/openhab-addons/pull/9347#discussion_r552941551", "createdAt": "2021-01-06T20:17:33Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.myq/README.md", "diffHunk": "@@ -0,0 +1,71 @@\n+# MyQ Binding\n+\n+This binding integrates with the [The Chamberlain Group MyQ](https://www.myq.com) cloud service. It allows monitoring and control over [MyQ](https://www.myq.com) enabled garage doors manufactured by LiftMaster, Chamberlain and Craftsman.\n+\n+## Supported Things\n+\n+### Account\n+\n+This represents the MyQ cloud account and uses the same credentials needed when using the MyQ mobile application.\n+\n+ThingTypeUID:`account`\n+\n+### Garage Door\n+\n+This represents a garage door associated with an account.  Multiple garage doors are supported.\n+\n+ThingTypeUID:`garagedoor`\n+\n+### Lamp\n+\n+This represents a lamp associated with an account.  Multiple lamps are supported.\n+\n+ThingTypeUID:`lamp`\n+\n+## Discovery\n+\n+Once an account has been added, garage doors and lamps will automatically be discovered and added to the inbox.\n+\n+## Channels\n+\n+| Channel       | Item Type     | Thing Type       | Description              |\n+|---------------|---------------|------------------|--------------------------|\n+| status        | String        | garagedoor, lamp | Status of the device     |\n+| switch        | Switch        | garagedoor, lamp | ON (open), OFF (close)   |\n+| contact       | Contact       | garagedoor       | Open, Closed             |\n+| rollershutter | Rollershutter | garagedoor       | UP (open), DOWN (closed) |", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b5c229bfaec596e8fe209df3946faf55db8b6b9d"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mjk0MTY3Nw==", "bodyText": "Can you mention which state the user can expect?", "url": "https://github.com/openhab/openhab-addons/pull/9347#discussion_r552941677", "createdAt": "2021-01-06T20:17:52Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.myq/README.md", "diffHunk": "@@ -0,0 +1,71 @@\n+# MyQ Binding\n+\n+This binding integrates with the [The Chamberlain Group MyQ](https://www.myq.com) cloud service. It allows monitoring and control over [MyQ](https://www.myq.com) enabled garage doors manufactured by LiftMaster, Chamberlain and Craftsman.\n+\n+## Supported Things\n+\n+### Account\n+\n+This represents the MyQ cloud account and uses the same credentials needed when using the MyQ mobile application.\n+\n+ThingTypeUID:`account`\n+\n+### Garage Door\n+\n+This represents a garage door associated with an account.  Multiple garage doors are supported.\n+\n+ThingTypeUID:`garagedoor`\n+\n+### Lamp\n+\n+This represents a lamp associated with an account.  Multiple lamps are supported.\n+\n+ThingTypeUID:`lamp`\n+\n+## Discovery\n+\n+Once an account has been added, garage doors and lamps will automatically be discovered and added to the inbox.\n+\n+## Channels\n+\n+| Channel       | Item Type     | Thing Type       | Description              |\n+|---------------|---------------|------------------|--------------------------|\n+| status        | String        | garagedoor, lamp | Status of the device     |", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b5c229bfaec596e8fe209df3946faf55db8b6b9d"}, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mjk0MTg5Ng==", "bodyText": "The features.xml doesn't need a license header.", "url": "https://github.com/openhab/openhab-addons/pull/9347#discussion_r552941896", "createdAt": "2021-01-06T20:18:30Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.myq/src/main/feature/feature.xml", "diffHunk": "@@ -0,0 +1,23 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<!--\n+\n+\tCopyright (c) 2010-2020 Contributors to the openHAB project\n+\n+\tSee the NOTICE file(s) distributed with this work for additional\n+\tinformation.\n+\n+\tThis program and the accompanying materials are made available under the\n+\tterms of the Eclipse Public License 2.0 which is available at\n+\thttp://www.eclipse.org/legal/epl-2.0\n+\n+\tSPDX-License-Identifier: EPL-2.0\n+\n+-->", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b5c229bfaec596e8fe209df3946faf55db8b6b9d"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mjk0MjU4NQ==", "bodyText": "You could use ThingHandlerService which would make this code unnecessary. The documentation for this is not yet merged, but available in the PR: https://github.com/openhab/openhab-docs/pull/1262/files#diff-c4a4d8725430bc2ea046182bfc73ac51349d989c7f6a8a6fa3001a226a09ad98R932", "url": "https://github.com/openhab/openhab-addons/pull/9347#discussion_r552942585", "createdAt": "2021-01-06T20:20:13Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.myq/src/main/java/org/openhab/binding/myq/internal/MyQHandlerFactory.java", "diffHunk": "@@ -0,0 +1,95 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.myq.internal;\n+\n+import static org.openhab.binding.myq.internal.MyQBindingConstants.*;\n+\n+import java.util.Hashtable;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.openhab.binding.myq.internal.handler.MyQAccountHandler;\n+import org.openhab.binding.myq.internal.handler.MyQGarageDoorHandler;\n+import org.openhab.binding.myq.internal.handler.MyQLampHandler;\n+import org.openhab.core.config.discovery.DiscoveryService;\n+import org.openhab.core.io.net.http.HttpClientFactory;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingTypeUID;\n+import org.openhab.core.thing.ThingUID;\n+import org.openhab.core.thing.binding.BaseThingHandlerFactory;\n+import org.openhab.core.thing.binding.ThingHandler;\n+import org.openhab.core.thing.binding.ThingHandlerFactory;\n+import org.osgi.framework.ServiceRegistration;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Reference;\n+\n+/**\n+ * The {@link MyQHandlerFactory} is responsible for creating things and thing\n+ * handlers.\n+ *\n+ * @author Dan Cunningham - Initial contribution\n+ */\n+@NonNullByDefault\n+@Component(configurationPid = \"binding.myq\", service = ThingHandlerFactory.class)\n+public class MyQHandlerFactory extends BaseThingHandlerFactory {\n+    private final Map<ThingUID, ServiceRegistration<?>> discoveryServiceRegs = new ConcurrentHashMap<>();\n+    private final HttpClient httpClient;\n+\n+    @Activate\n+    public MyQHandlerFactory(final @Reference HttpClientFactory httpClientFactory) {\n+        this.httpClient = httpClientFactory.getCommonHttpClient();\n+    }\n+\n+    @Override\n+    public boolean supportsThingType(ThingTypeUID thingTypeUID) {\n+        return SUPPORTED_THING_TYPES_UIDS.contains(thingTypeUID);\n+    }\n+\n+    @Override\n+    protected @Nullable ThingHandler createHandler(Thing thing) {\n+        ThingTypeUID thingTypeUID = thing.getThingTypeUID();\n+\n+        if (THING_TYPE_ACCOUNT.equals(thingTypeUID)) {\n+            MyQDiscoveryService discoveryService = new MyQDiscoveryService();\n+            MyQAccountHandler accountHandler = new MyQAccountHandler((Bridge) thing, httpClient, discoveryService);\n+            discoveryServiceRegs.put(accountHandler.getThing().getUID(), bundleContext\n+                    .registerService(DiscoveryService.class.getName(), discoveryService, new Hashtable<>()));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b5c229bfaec596e8fe209df3946faf55db8b6b9d"}, "originalPosition": 71}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mjk0MzAyNQ==", "bodyText": "Primitive types should be used where possible.\nIt's good practice to append the unit to the field name e.g. TIMEOUT_SEC.\nCan these be static final?\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private Integer normalRefreshInterval = 60;\n          \n          \n            \n                private Integer rapidRefreshInterval = 5;\n          \n          \n            \n                private int normalRefreshInterval = 60;\n          \n          \n            \n                private int rapidRefreshInterval = 5;", "url": "https://github.com/openhab/openhab-addons/pull/9347#discussion_r552943025", "createdAt": "2021-01-06T20:21:17Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.myq/src/main/java/org/openhab/binding/myq/internal/handler/MyQAccountHandler.java", "diffHunk": "@@ -0,0 +1,330 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.myq.internal.handler;\n+\n+import static org.openhab.binding.myq.internal.MyQBindingConstants.*;\n+\n+import java.util.Random;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentProvider;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.client.api.Result;\n+import org.eclipse.jetty.client.util.BufferingResponseListener;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.eclipse.jetty.http.HttpMethod;\n+import org.eclipse.jetty.http.HttpStatus;\n+import org.openhab.binding.myq.internal.MyQConfiguration;\n+import org.openhab.binding.myq.internal.MyQDiscoveryService;\n+import org.openhab.binding.myq.internal.dto.AccountDTO;\n+import org.openhab.binding.myq.internal.dto.ActionDTO;\n+import org.openhab.binding.myq.internal.dto.DevicesDTO;\n+import org.openhab.binding.myq.internal.dto.LoginRequestDTO;\n+import org.openhab.binding.myq.internal.dto.LoginResponseDTO;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.ThingTypeUID;\n+import org.openhab.core.thing.ThingUID;\n+import org.openhab.core.thing.binding.BaseBridgeHandler;\n+import org.openhab.core.thing.binding.ThingHandler;\n+import org.openhab.core.types.Command;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.FieldNamingPolicy;\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+\n+/**\n+ * The {@link MyQAccountHandler} is responsible for communicating with the MyQ API based on an account.\n+ *\n+ * @author Dan Cunningham - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MyQAccountHandler extends BaseBridgeHandler {\n+    private static final String BASE_URL = \"https://api.myqdevice.com/api\";\n+    private final Logger logger = LoggerFactory.getLogger(MyQAccountHandler.class);\n+    private final Gson gsonUpperCase = new GsonBuilder().setFieldNamingPolicy(FieldNamingPolicy.UPPER_CAMEL_CASE)\n+            .create();\n+    private final Gson gsonLowerCase = new GsonBuilder()\n+            .setFieldNamingPolicy(FieldNamingPolicy.LOWER_CASE_WITH_UNDERSCORES).create();\n+    private @Nullable Future<?> normalPollFuture;\n+    private @Nullable Future<?> rapidPollFuture;\n+    private @Nullable String securityToken;\n+    private @Nullable AccountDTO account;\n+    private MyQDiscoveryService discoveryService;\n+    private Integer normalRefreshInterval = 60;\n+    private Integer rapidRefreshInterval = 5;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b5c229bfaec596e8fe209df3946faf55db8b6b9d"}, "originalPosition": 76}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mjk0NTg1NQ==", "bodyText": "When using the ThingHandlerService, you could set a reference to the discovery service in ThingHandlerService.setThingHandler() to make it acccessible here.", "url": "https://github.com/openhab/openhab-addons/pull/9347#discussion_r552945855", "createdAt": "2021-01-06T20:28:07Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.myq/src/main/java/org/openhab/binding/myq/internal/handler/MyQAccountHandler.java", "diffHunk": "@@ -0,0 +1,330 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.myq.internal.handler;\n+\n+import static org.openhab.binding.myq.internal.MyQBindingConstants.*;\n+\n+import java.util.Random;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentProvider;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.client.api.Result;\n+import org.eclipse.jetty.client.util.BufferingResponseListener;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.eclipse.jetty.http.HttpMethod;\n+import org.eclipse.jetty.http.HttpStatus;\n+import org.openhab.binding.myq.internal.MyQConfiguration;\n+import org.openhab.binding.myq.internal.MyQDiscoveryService;\n+import org.openhab.binding.myq.internal.dto.AccountDTO;\n+import org.openhab.binding.myq.internal.dto.ActionDTO;\n+import org.openhab.binding.myq.internal.dto.DevicesDTO;\n+import org.openhab.binding.myq.internal.dto.LoginRequestDTO;\n+import org.openhab.binding.myq.internal.dto.LoginResponseDTO;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.ThingTypeUID;\n+import org.openhab.core.thing.ThingUID;\n+import org.openhab.core.thing.binding.BaseBridgeHandler;\n+import org.openhab.core.thing.binding.ThingHandler;\n+import org.openhab.core.types.Command;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.FieldNamingPolicy;\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+\n+/**\n+ * The {@link MyQAccountHandler} is responsible for communicating with the MyQ API based on an account.\n+ *\n+ * @author Dan Cunningham - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MyQAccountHandler extends BaseBridgeHandler {\n+    private static final String BASE_URL = \"https://api.myqdevice.com/api\";\n+    private final Logger logger = LoggerFactory.getLogger(MyQAccountHandler.class);\n+    private final Gson gsonUpperCase = new GsonBuilder().setFieldNamingPolicy(FieldNamingPolicy.UPPER_CAMEL_CASE)\n+            .create();\n+    private final Gson gsonLowerCase = new GsonBuilder()\n+            .setFieldNamingPolicy(FieldNamingPolicy.LOWER_CASE_WITH_UNDERSCORES).create();\n+    private @Nullable Future<?> normalPollFuture;\n+    private @Nullable Future<?> rapidPollFuture;\n+    private @Nullable String securityToken;\n+    private @Nullable AccountDTO account;\n+    private MyQDiscoveryService discoveryService;\n+    private Integer normalRefreshInterval = 60;\n+    private Integer rapidRefreshInterval = 5;\n+    private HttpClient httpClient;\n+    private String username = \"\";\n+    private String password = \"\";\n+    private String userAgent = \"\";\n+\n+    public MyQAccountHandler(Bridge bridge, HttpClient httpClient, MyQDiscoveryService discoveryService) {\n+        super(bridge);\n+        this.httpClient = httpClient;\n+        this.discoveryService = discoveryService;\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        MyQConfiguration config = getConfigAs(MyQConfiguration.class);\n+        normalRefreshInterval = config.refreshInterval;\n+        username = config.username;\n+        password = config.password;\n+        // MyQ can get picky about blocking user agents apparently\n+        userAgent = MyQAccountHandler.randomString(40);\n+        securityToken = null;\n+        updateStatus(ThingStatus.UNKNOWN);\n+        restartPolls(false);\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        stopPolls();\n+    }\n+\n+    /**\n+     * Sends an action to the MyQ API\n+     *\n+     * @param serialNumber\n+     * @param action\n+     */\n+    public void sendAction(String serialNumber, String action) {\n+        AccountDTO localAccount = account;\n+        if (localAccount != null) {\n+            try {\n+                HttpResult result = sendRequest(\n+                        String.format(\"%s/v5.1/Accounts/%s/Devices/%s/actions\", BASE_URL, localAccount.account.id,\n+                                serialNumber),\n+                        HttpMethod.PUT, securityToken,\n+                        new StringContentProvider(gsonLowerCase.toJson(new ActionDTO(action))), \"application/json\");\n+                if (HttpStatus.isSuccess(result.responseCode)) {\n+                    restartPolls(true);\n+                } else {\n+                    logger.debug(\"Failed to send action {} : {}\", action, result.content);\n+                }\n+            } catch (InterruptedException e) {\n+            }\n+        }\n+    }\n+\n+    private void stopPolls() {\n+        stopNormalPoll();\n+        stopRapidPoll();\n+    }\n+\n+    private synchronized void stopNormalPoll() {\n+        stopFuture(normalPollFuture);\n+        normalPollFuture = null;\n+    }\n+\n+    private synchronized void stopRapidPoll() {\n+        stopFuture(rapidPollFuture);\n+        rapidPollFuture = null;\n+    }\n+\n+    private void stopFuture(@Nullable Future<?> future) {\n+        if (future != null) {\n+            future.cancel(true);\n+        }\n+    }\n+\n+    private synchronized void restartPolls(boolean rapid) {\n+        stopPolls();\n+        if (rapid) {\n+            normalPollFuture = scheduler.scheduleWithFixedDelay(this::normalPoll, 35, normalRefreshInterval,\n+                    TimeUnit.SECONDS);\n+            rapidPollFuture = scheduler.scheduleWithFixedDelay(this::rapidPoll, 3, rapidRefreshInterval,\n+                    TimeUnit.SECONDS);\n+        } else {\n+            normalPollFuture = scheduler.scheduleWithFixedDelay(this::normalPoll, 0, normalRefreshInterval,\n+                    TimeUnit.SECONDS);\n+        }\n+    }\n+\n+    private void normalPoll() {\n+        stopRapidPoll();\n+        fetchData();\n+    }\n+\n+    private void rapidPoll() {\n+        fetchData();\n+    }\n+\n+    private synchronized void fetchData() {\n+        try {\n+            if (securityToken == null) {\n+                login();\n+                if (securityToken != null) {\n+                    getAccount();\n+                }\n+            }\n+\n+            if (securityToken != null) {\n+                getDevices();\n+            }\n+        } catch (InterruptedException e) {\n+        }\n+    }\n+\n+    private void login() throws InterruptedException {\n+        HttpResult result = sendRequest(BASE_URL + \"/v5/Login\", HttpMethod.POST, null,\n+                new StringContentProvider(gsonUpperCase.toJson(new LoginRequestDTO(username, password))),\n+                \"application/json\");\n+        if (HttpStatus.isSuccess(result.responseCode)) {\n+            LoginResponseDTO loginResponse = gsonUpperCase.fromJson(result.content, LoginResponseDTO.class);\n+            if (loginResponse != null) {\n+                securityToken = loginResponse.securityToken;\n+                updateStatus(ThingStatus.ONLINE);\n+            } else {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, \"Invalid Response Body\");\n+            }\n+        } else {\n+            handleErrorResponse(result);\n+            if (thing.getStatusInfo().getStatusDetail() == ThingStatusDetail.CONFIGURATION_ERROR) {\n+                // bad credentials, stop trying to login\n+                stopPolls();\n+            }\n+        }\n+    }\n+\n+    private void getAccount() throws InterruptedException {\n+        HttpResult result = sendRequest(BASE_URL + \"/v5/My?expand=account\", HttpMethod.GET, securityToken, null, null);\n+        if (HttpStatus.isSuccess(result.responseCode)) {\n+            account = gsonUpperCase.fromJson(result.content, AccountDTO.class);\n+        } else {\n+            handleErrorResponse(result);\n+        }\n+    }\n+\n+    private void getDevices() throws InterruptedException {\n+        AccountDTO localAccount = account;\n+        if (localAccount == null) {\n+            return;\n+        }\n+        HttpResult result = sendRequest(String.format(\"%s/v5.1/Accounts/%s/Devices\", BASE_URL, localAccount.account.id),\n+                HttpMethod.GET, securityToken, null, null);\n+        if (HttpStatus.isSuccess(result.responseCode)) {\n+            if (getThing().getStatus() != ThingStatus.ONLINE) {\n+                updateStatus(ThingStatus.ONLINE);\n+            }\n+            DevicesDTO devices = gsonLowerCase.fromJson(result.content, DevicesDTO.class);\n+            if (devices != null) {\n+                devices.items.forEach(device -> {\n+                    ThingTypeUID thingTypeUID = new ThingTypeUID(BINDING_ID, device.deviceFamily);\n+                    if (SUPPORTED_DISCOVERY_THING_TYPES_UIDS.contains(thingTypeUID)) {\n+                        String id = device.serialNumber.toLowerCase();\n+                        for (Thing thing : getThing().getThings()) {\n+                            // support both upper and lower case serialIds\n+                            if (thing.getUID().getId().toLowerCase().equals(id)) {\n+                                ThingHandler handler = thing.getHandler();\n+                                if (handler != null) {\n+                                    ((MyQDeviceHandler) handler).handleDeviceUpdate(device);\n+                                }\n+                                return;\n+                            }\n+                        }\n+                        // did not find a thing, add it to the inbox\n+                        ThingUID thingUID = new ThingUID(thingTypeUID, getThing().getUID(), id);\n+                        discoveryService.deviceDiscovered(thingUID, getThing().getUID(), device.name);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b5c229bfaec596e8fe209df3946faf55db8b6b9d"}, "originalPosition": 253}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mjk0NjQ0OA==", "bodyText": "Are you logging the stack trace by intention?", "url": "https://github.com/openhab/openhab-addons/pull/9347#discussion_r552946448", "createdAt": "2021-01-06T20:29:30Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.myq/src/main/java/org/openhab/binding/myq/internal/handler/MyQAccountHandler.java", "diffHunk": "@@ -0,0 +1,330 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.myq.internal.handler;\n+\n+import static org.openhab.binding.myq.internal.MyQBindingConstants.*;\n+\n+import java.util.Random;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentProvider;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.client.api.Result;\n+import org.eclipse.jetty.client.util.BufferingResponseListener;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.eclipse.jetty.http.HttpMethod;\n+import org.eclipse.jetty.http.HttpStatus;\n+import org.openhab.binding.myq.internal.MyQConfiguration;\n+import org.openhab.binding.myq.internal.MyQDiscoveryService;\n+import org.openhab.binding.myq.internal.dto.AccountDTO;\n+import org.openhab.binding.myq.internal.dto.ActionDTO;\n+import org.openhab.binding.myq.internal.dto.DevicesDTO;\n+import org.openhab.binding.myq.internal.dto.LoginRequestDTO;\n+import org.openhab.binding.myq.internal.dto.LoginResponseDTO;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.ThingTypeUID;\n+import org.openhab.core.thing.ThingUID;\n+import org.openhab.core.thing.binding.BaseBridgeHandler;\n+import org.openhab.core.thing.binding.ThingHandler;\n+import org.openhab.core.types.Command;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.FieldNamingPolicy;\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+\n+/**\n+ * The {@link MyQAccountHandler} is responsible for communicating with the MyQ API based on an account.\n+ *\n+ * @author Dan Cunningham - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MyQAccountHandler extends BaseBridgeHandler {\n+    private static final String BASE_URL = \"https://api.myqdevice.com/api\";\n+    private final Logger logger = LoggerFactory.getLogger(MyQAccountHandler.class);\n+    private final Gson gsonUpperCase = new GsonBuilder().setFieldNamingPolicy(FieldNamingPolicy.UPPER_CAMEL_CASE)\n+            .create();\n+    private final Gson gsonLowerCase = new GsonBuilder()\n+            .setFieldNamingPolicy(FieldNamingPolicy.LOWER_CASE_WITH_UNDERSCORES).create();\n+    private @Nullable Future<?> normalPollFuture;\n+    private @Nullable Future<?> rapidPollFuture;\n+    private @Nullable String securityToken;\n+    private @Nullable AccountDTO account;\n+    private MyQDiscoveryService discoveryService;\n+    private Integer normalRefreshInterval = 60;\n+    private Integer rapidRefreshInterval = 5;\n+    private HttpClient httpClient;\n+    private String username = \"\";\n+    private String password = \"\";\n+    private String userAgent = \"\";\n+\n+    public MyQAccountHandler(Bridge bridge, HttpClient httpClient, MyQDiscoveryService discoveryService) {\n+        super(bridge);\n+        this.httpClient = httpClient;\n+        this.discoveryService = discoveryService;\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        MyQConfiguration config = getConfigAs(MyQConfiguration.class);\n+        normalRefreshInterval = config.refreshInterval;\n+        username = config.username;\n+        password = config.password;\n+        // MyQ can get picky about blocking user agents apparently\n+        userAgent = MyQAccountHandler.randomString(40);\n+        securityToken = null;\n+        updateStatus(ThingStatus.UNKNOWN);\n+        restartPolls(false);\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        stopPolls();\n+    }\n+\n+    /**\n+     * Sends an action to the MyQ API\n+     *\n+     * @param serialNumber\n+     * @param action\n+     */\n+    public void sendAction(String serialNumber, String action) {\n+        AccountDTO localAccount = account;\n+        if (localAccount != null) {\n+            try {\n+                HttpResult result = sendRequest(\n+                        String.format(\"%s/v5.1/Accounts/%s/Devices/%s/actions\", BASE_URL, localAccount.account.id,\n+                                serialNumber),\n+                        HttpMethod.PUT, securityToken,\n+                        new StringContentProvider(gsonLowerCase.toJson(new ActionDTO(action))), \"application/json\");\n+                if (HttpStatus.isSuccess(result.responseCode)) {\n+                    restartPolls(true);\n+                } else {\n+                    logger.debug(\"Failed to send action {} : {}\", action, result.content);\n+                }\n+            } catch (InterruptedException e) {\n+            }\n+        }\n+    }\n+\n+    private void stopPolls() {\n+        stopNormalPoll();\n+        stopRapidPoll();\n+    }\n+\n+    private synchronized void stopNormalPoll() {\n+        stopFuture(normalPollFuture);\n+        normalPollFuture = null;\n+    }\n+\n+    private synchronized void stopRapidPoll() {\n+        stopFuture(rapidPollFuture);\n+        rapidPollFuture = null;\n+    }\n+\n+    private void stopFuture(@Nullable Future<?> future) {\n+        if (future != null) {\n+            future.cancel(true);\n+        }\n+    }\n+\n+    private synchronized void restartPolls(boolean rapid) {\n+        stopPolls();\n+        if (rapid) {\n+            normalPollFuture = scheduler.scheduleWithFixedDelay(this::normalPoll, 35, normalRefreshInterval,\n+                    TimeUnit.SECONDS);\n+            rapidPollFuture = scheduler.scheduleWithFixedDelay(this::rapidPoll, 3, rapidRefreshInterval,\n+                    TimeUnit.SECONDS);\n+        } else {\n+            normalPollFuture = scheduler.scheduleWithFixedDelay(this::normalPoll, 0, normalRefreshInterval,\n+                    TimeUnit.SECONDS);\n+        }\n+    }\n+\n+    private void normalPoll() {\n+        stopRapidPoll();\n+        fetchData();\n+    }\n+\n+    private void rapidPoll() {\n+        fetchData();\n+    }\n+\n+    private synchronized void fetchData() {\n+        try {\n+            if (securityToken == null) {\n+                login();\n+                if (securityToken != null) {\n+                    getAccount();\n+                }\n+            }\n+\n+            if (securityToken != null) {\n+                getDevices();\n+            }\n+        } catch (InterruptedException e) {\n+        }\n+    }\n+\n+    private void login() throws InterruptedException {\n+        HttpResult result = sendRequest(BASE_URL + \"/v5/Login\", HttpMethod.POST, null,\n+                new StringContentProvider(gsonUpperCase.toJson(new LoginRequestDTO(username, password))),\n+                \"application/json\");\n+        if (HttpStatus.isSuccess(result.responseCode)) {\n+            LoginResponseDTO loginResponse = gsonUpperCase.fromJson(result.content, LoginResponseDTO.class);\n+            if (loginResponse != null) {\n+                securityToken = loginResponse.securityToken;\n+                updateStatus(ThingStatus.ONLINE);\n+            } else {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, \"Invalid Response Body\");\n+            }\n+        } else {\n+            handleErrorResponse(result);\n+            if (thing.getStatusInfo().getStatusDetail() == ThingStatusDetail.CONFIGURATION_ERROR) {\n+                // bad credentials, stop trying to login\n+                stopPolls();\n+            }\n+        }\n+    }\n+\n+    private void getAccount() throws InterruptedException {\n+        HttpResult result = sendRequest(BASE_URL + \"/v5/My?expand=account\", HttpMethod.GET, securityToken, null, null);\n+        if (HttpStatus.isSuccess(result.responseCode)) {\n+            account = gsonUpperCase.fromJson(result.content, AccountDTO.class);\n+        } else {\n+            handleErrorResponse(result);\n+        }\n+    }\n+\n+    private void getDevices() throws InterruptedException {\n+        AccountDTO localAccount = account;\n+        if (localAccount == null) {\n+            return;\n+        }\n+        HttpResult result = sendRequest(String.format(\"%s/v5.1/Accounts/%s/Devices\", BASE_URL, localAccount.account.id),\n+                HttpMethod.GET, securityToken, null, null);\n+        if (HttpStatus.isSuccess(result.responseCode)) {\n+            if (getThing().getStatus() != ThingStatus.ONLINE) {\n+                updateStatus(ThingStatus.ONLINE);\n+            }\n+            DevicesDTO devices = gsonLowerCase.fromJson(result.content, DevicesDTO.class);\n+            if (devices != null) {\n+                devices.items.forEach(device -> {\n+                    ThingTypeUID thingTypeUID = new ThingTypeUID(BINDING_ID, device.deviceFamily);\n+                    if (SUPPORTED_DISCOVERY_THING_TYPES_UIDS.contains(thingTypeUID)) {\n+                        String id = device.serialNumber.toLowerCase();\n+                        for (Thing thing : getThing().getThings()) {\n+                            // support both upper and lower case serialIds\n+                            if (thing.getUID().getId().toLowerCase().equals(id)) {\n+                                ThingHandler handler = thing.getHandler();\n+                                if (handler != null) {\n+                                    ((MyQDeviceHandler) handler).handleDeviceUpdate(device);\n+                                }\n+                                return;\n+                            }\n+                        }\n+                        // did not find a thing, add it to the inbox\n+                        ThingUID thingUID = new ThingUID(thingTypeUID, getThing().getUID(), id);\n+                        discoveryService.deviceDiscovered(thingUID, getThing().getUID(), device.name);\n+                    }\n+                });\n+            }\n+        } else {\n+            handleErrorResponse(result);\n+        }\n+    }\n+\n+    private synchronized HttpResult sendRequest(String url, HttpMethod method, @Nullable String token,\n+            @Nullable ContentProvider content, @Nullable String contentType) throws InterruptedException {\n+        try {\n+            Request request = httpClient.newRequest(url).method(method)\n+                    .header(\"MyQApplicationId\", \"JVM/G9Nwih5BwKgNCjLxiFUQxQijAebyyg8QUHr7JOrP+tuPb8iHfRHKwTmDzHOu\")\n+                    .header(\"ApiVersion\", \"5.1\").header(\"BrandId\", \"2\").header(\"Culture\", \"en\").agent(userAgent)\n+                    .timeout(10, TimeUnit.SECONDS);\n+            if (token != null) {\n+                request = request.header(\"SecurityToken\", token);\n+            }\n+            if (content != null & contentType != null) {\n+                request = request.content(content, contentType);\n+            }\n+            // use asyc jetty as the API service will response with a 401 error when credentials are wrong,\n+            // but not a WWW-Authenticate header which causes Jetty to throw a generic execution exception which\n+            // prevents us from knowing the response code\n+            logger.trace(\"Sending {} to {}\", request.getMethod(), request.getURI());\n+            final CompletableFuture<HttpResult> futureResult = new CompletableFuture<>();\n+            request.send(new BufferingResponseListener() {\n+                @NonNullByDefault({})\n+                @Override\n+                public void onComplete(Result result) {\n+                    futureResult.complete(new HttpResult(result.getResponse().getStatus(), getContentAsString()));\n+                }\n+            });\n+            HttpResult result = futureResult.get();\n+            logger.trace(\"Account Response - status: {} content: {}\", result.responseCode, result.content);\n+            return result;\n+        } catch (ExecutionException e) {\n+            logger.debug(\"request failed\", e);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b5c229bfaec596e8fe209df3946faf55db8b6b9d"}, "originalPosition": 291}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTcxMTA1MTA4", "url": "https://github.com/openhab/openhab-addons/pull/9347#pullrequestreview-571105108", "createdAt": "2021-01-19T10:29:03Z", "commit": {"oid": "bddbad680c579f681166de9de5a4aa2f6f76bee9"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xOVQxMDoyOTowM1rOIWIH7w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xOVQxMDoyOTowM1rOIWIH7w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MDA3MjY4Nw==", "bodyText": "If I see correctly this method does the (background) discovery of devices. So, it's better to move this into the discovery service. Then, you won't have a problem with the depdendencies of handler and discovery service either.", "url": "https://github.com/openhab/openhab-addons/pull/9347#discussion_r560072687", "createdAt": "2021-01-19T10:29:03Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.myq/src/main/java/org/openhab/binding/myq/internal/handler/MyQAccountHandler.java", "diffHunk": "@@ -0,0 +1,329 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.myq.internal.handler;\n+\n+import static org.openhab.binding.myq.internal.MyQBindingConstants.*;\n+\n+import java.util.Random;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentProvider;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.client.api.Result;\n+import org.eclipse.jetty.client.util.BufferingResponseListener;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.eclipse.jetty.http.HttpMethod;\n+import org.eclipse.jetty.http.HttpStatus;\n+import org.openhab.binding.myq.internal.MyQConfiguration;\n+import org.openhab.binding.myq.internal.MyQDiscoveryService;\n+import org.openhab.binding.myq.internal.dto.AccountDTO;\n+import org.openhab.binding.myq.internal.dto.ActionDTO;\n+import org.openhab.binding.myq.internal.dto.DevicesDTO;\n+import org.openhab.binding.myq.internal.dto.LoginRequestDTO;\n+import org.openhab.binding.myq.internal.dto.LoginResponseDTO;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.ThingTypeUID;\n+import org.openhab.core.thing.ThingUID;\n+import org.openhab.core.thing.binding.BaseBridgeHandler;\n+import org.openhab.core.thing.binding.ThingHandler;\n+import org.openhab.core.types.Command;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.FieldNamingPolicy;\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+\n+/**\n+ * The {@link MyQAccountHandler} is responsible for communicating with the MyQ API based on an account.\n+ *\n+ * @author Dan Cunningham - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MyQAccountHandler extends BaseBridgeHandler {\n+    private static final String BASE_URL = \"https://api.myqdevice.com/api\";\n+    private static final Integer RAPID_REFRESH_SECONDS = 5;\n+    private final Logger logger = LoggerFactory.getLogger(MyQAccountHandler.class);\n+    private final Gson gsonUpperCase = new GsonBuilder().setFieldNamingPolicy(FieldNamingPolicy.UPPER_CAMEL_CASE)\n+            .create();\n+    private final Gson gsonLowerCase = new GsonBuilder()\n+            .setFieldNamingPolicy(FieldNamingPolicy.LOWER_CASE_WITH_UNDERSCORES).create();\n+    private @Nullable Future<?> normalPollFuture;\n+    private @Nullable Future<?> rapidPollFuture;\n+    private @Nullable String securityToken;\n+    private @Nullable AccountDTO account;\n+    private Integer normalRefreshSeconds = 60;\n+    private MyQDiscoveryService discoveryService;\n+    private HttpClient httpClient;\n+    private String username = \"\";\n+    private String password = \"\";\n+    private String userAgent = \"\";\n+\n+    public MyQAccountHandler(Bridge bridge, HttpClient httpClient, MyQDiscoveryService discoveryService) {\n+        super(bridge);\n+        this.httpClient = httpClient;\n+        this.discoveryService = discoveryService;\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        MyQConfiguration config = getConfigAs(MyQConfiguration.class);\n+        normalRefreshSeconds = config.refreshInterval;\n+        username = config.username;\n+        password = config.password;\n+        // MyQ can get picky about blocking user agents apparently\n+        userAgent = MyQAccountHandler.randomString(40);\n+        securityToken = null;\n+        updateStatus(ThingStatus.UNKNOWN);\n+        restartPolls(false);\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        stopPolls();\n+    }\n+\n+    /**\n+     * Sends an action to the MyQ API\n+     *\n+     * @param serialNumber\n+     * @param action\n+     */\n+    public void sendAction(String serialNumber, String action) {\n+        AccountDTO localAccount = account;\n+        if (localAccount != null) {\n+            try {\n+                HttpResult result = sendRequest(\n+                        String.format(\"%s/v5.1/Accounts/%s/Devices/%s/actions\", BASE_URL, localAccount.account.id,\n+                                serialNumber),\n+                        HttpMethod.PUT, securityToken,\n+                        new StringContentProvider(gsonLowerCase.toJson(new ActionDTO(action))), \"application/json\");\n+                if (HttpStatus.isSuccess(result.responseCode)) {\n+                    restartPolls(true);\n+                } else {\n+                    logger.debug(\"Failed to send action {} : {}\", action, result.content);\n+                }\n+            } catch (InterruptedException e) {\n+            }\n+        }\n+    }\n+\n+    private void stopPolls() {\n+        stopNormalPoll();\n+        stopRapidPoll();\n+    }\n+\n+    private synchronized void stopNormalPoll() {\n+        stopFuture(normalPollFuture);\n+        normalPollFuture = null;\n+    }\n+\n+    private synchronized void stopRapidPoll() {\n+        stopFuture(rapidPollFuture);\n+        rapidPollFuture = null;\n+    }\n+\n+    private void stopFuture(@Nullable Future<?> future) {\n+        if (future != null) {\n+            future.cancel(true);\n+        }\n+    }\n+\n+    private synchronized void restartPolls(boolean rapid) {\n+        stopPolls();\n+        if (rapid) {\n+            normalPollFuture = scheduler.scheduleWithFixedDelay(this::normalPoll, 35, normalRefreshSeconds,\n+                    TimeUnit.SECONDS);\n+            rapidPollFuture = scheduler.scheduleWithFixedDelay(this::rapidPoll, 3, RAPID_REFRESH_SECONDS,\n+                    TimeUnit.SECONDS);\n+        } else {\n+            normalPollFuture = scheduler.scheduleWithFixedDelay(this::normalPoll, 0, normalRefreshSeconds,\n+                    TimeUnit.SECONDS);\n+        }\n+    }\n+\n+    private void normalPoll() {\n+        stopRapidPoll();\n+        fetchData();\n+    }\n+\n+    private void rapidPoll() {\n+        fetchData();\n+    }\n+\n+    private synchronized void fetchData() {\n+        try {\n+            if (securityToken == null) {\n+                login();\n+                if (securityToken != null) {\n+                    getAccount();\n+                }\n+            }\n+\n+            if (securityToken != null) {\n+                getDevices();\n+            }\n+        } catch (InterruptedException e) {\n+        }\n+    }\n+\n+    private void login() throws InterruptedException {\n+        HttpResult result = sendRequest(BASE_URL + \"/v5/Login\", HttpMethod.POST, null,\n+                new StringContentProvider(gsonUpperCase.toJson(new LoginRequestDTO(username, password))),\n+                \"application/json\");\n+        if (HttpStatus.isSuccess(result.responseCode)) {\n+            LoginResponseDTO loginResponse = gsonUpperCase.fromJson(result.content, LoginResponseDTO.class);\n+            if (loginResponse != null) {\n+                securityToken = loginResponse.securityToken;\n+                updateStatus(ThingStatus.ONLINE);\n+            } else {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, \"Invalid Response Body\");\n+            }\n+        } else {\n+            handleErrorResponse(result);\n+            if (thing.getStatusInfo().getStatusDetail() == ThingStatusDetail.CONFIGURATION_ERROR) {\n+                // bad credentials, stop trying to login\n+                stopPolls();\n+            }\n+        }\n+    }\n+\n+    private void getAccount() throws InterruptedException {\n+        HttpResult result = sendRequest(BASE_URL + \"/v5/My?expand=account\", HttpMethod.GET, securityToken, null, null);\n+        if (HttpStatus.isSuccess(result.responseCode)) {\n+            account = gsonUpperCase.fromJson(result.content, AccountDTO.class);\n+        } else {\n+            handleErrorResponse(result);\n+        }\n+    }\n+\n+    private void getDevices() throws InterruptedException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bddbad680c579f681166de9de5a4aa2f6f76bee9"}, "originalPosition": 224}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTc0MTkwODI0", "url": "https://github.com/openhab/openhab-addons/pull/9347#pullrequestreview-574190824", "createdAt": "2021-01-22T11:50:49Z", "commit": {"oid": "552b0f45cf19218af421fcabb93f4d8e4e012e88"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yMlQxMTo1MDo1MFrOIYhKVg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yMlQxMTo1MDo1MFrOIYhKVg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MjU4MDA1NA==", "bodyText": "You're using the id as a unique identifier.  However the convention is that the user can give it any name allowed. So it should not be used as identifier. You should check here on the property serialNumber.", "url": "https://github.com/openhab/openhab-addons/pull/9347#discussion_r562580054", "createdAt": "2021-01-22T11:50:50Z", "author": {"login": "Hilbrand"}, "path": "bundles/org.openhab.binding.myq/src/main/java/org/openhab/binding/myq/internal/handler/MyQAccountHandler.java", "diffHunk": "@@ -107,6 +109,24 @@ public void dispose() {\n         stopPolls();\n     }\n \n+    @Override\n+    public Collection<Class<? extends ThingHandlerService>> getServices() {\n+        return Collections.singleton(MyQDiscoveryService.class);\n+    }\n+\n+    @Override\n+    public void childHandlerInitialized(ThingHandler childHandler, Thing childThing) {\n+        DevicesDTO localDeviceCaches = devicesCache;\n+        if (localDeviceCaches != null) {\n+            DeviceDTO device = localDeviceCaches.items.stream()\n+                    .filter(d -> childHandler.getThing().getUID().getId().equalsIgnoreCase(d.serialNumber)).findFirst()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "552b0f45cf19218af421fcabb93f4d8e4e012e88"}, "originalPosition": 62}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTc0NDUyMzE3", "url": "https://github.com/openhab/openhab-addons/pull/9347#pullrequestreview-574452317", "createdAt": "2021-01-22T17:08:59Z", "commit": {"oid": "c497131432b338000225deb426ef06c0ee54bd6f"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yMlQxNzowODo1OVrOIYtJpA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yMlQxNzowODo1OVrOIYtJpA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2Mjc3NjQ4NA==", "bodyText": "In general it's not recommend to get the configuration everytime. I would suggest to make a method getSerialNumber() on the handler and also use equalsIgnoreCase. Something like:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                        if (thing.getConfiguration().as(MyQDeviceConfiguration.class).serialNumber.toLowerCase()\n          \n          \n            \n                                                .equals(deviceSerial)) {\n          \n          \n            \n                                        if (((MyQDeviceHandler) thing.getHandler()).getSerialNumber().equalsIgnoreCase(deviceSerial)) {", "url": "https://github.com/openhab/openhab-addons/pull/9347#discussion_r562776484", "createdAt": "2021-01-22T17:08:59Z", "author": {"login": "Hilbrand"}, "path": "bundles/org.openhab.binding.myq/src/main/java/org/openhab/binding/myq/internal/handler/MyQAccountHandler.java", "diffHunk": "@@ -267,10 +269,11 @@ private void getDevices() throws InterruptedException {\n                 devices.items.forEach(device -> {\n                     ThingTypeUID thingTypeUID = new ThingTypeUID(BINDING_ID, device.deviceFamily);\n                     if (SUPPORTED_DISCOVERY_THING_TYPES_UIDS.contains(thingTypeUID)) {\n-                        String id = device.serialNumber.toLowerCase();\n+                        String deviceSerial = device.serialNumber.toLowerCase();\n                         for (Thing thing : getThing().getThings()) {\n                             // support both upper and lower case serialIds\n-                            if (thing.getUID().getId().toLowerCase().equals(id)) {\n+                            if (thing.getConfiguration().as(MyQDeviceConfiguration.class).serialNumber.toLowerCase()\n+                                    .equals(deviceSerial)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c497131432b338000225deb426ef06c0ee54bd6f"}, "originalPosition": 53}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7c5daf34ac54a1ce6b0e76d699ec27c5abf3ad96", "author": {"user": {"login": "digitaldan", "name": "Dan Cunningham"}}, "url": "https://github.com/openhab/openhab-addons/commit/7c5daf34ac54a1ce6b0e76d699ec27c5abf3ad96", "committedDate": "2021-01-23T16:27:17Z", "message": "Rebase with main, update license headers\n\nSigned-off-by: Dan Cunningham <dan@digitaldan.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "9fc47348e790415c340036192a833858eaffd4f0", "author": {"user": {"login": "digitaldan", "name": "Dan Cunningham"}}, "url": "https://github.com/openhab/openhab-addons/commit/9fc47348e790415c340036192a833858eaffd4f0", "committedDate": "2021-01-22T18:08:06Z", "message": "Optimize matching serialnumber to things\n\nSigned-off-by: Dan Cunningham <dan@digitaldan.com>"}, "afterCommit": {"oid": "7c5daf34ac54a1ce6b0e76d699ec27c5abf3ad96", "author": {"user": {"login": "digitaldan", "name": "Dan Cunningham"}}, "url": "https://github.com/openhab/openhab-addons/commit/7c5daf34ac54a1ce6b0e76d699ec27c5abf3ad96", "committedDate": "2021-01-23T16:27:17Z", "message": "Rebase with main, update license headers\n\nSigned-off-by: Dan Cunningham <dan@digitaldan.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTc1NjYyNzk0", "url": "https://github.com/openhab/openhab-addons/pull/9347#pullrequestreview-575662794", "createdAt": "2021-01-25T17:57:15Z", "commit": {"oid": "7c5daf34ac54a1ce6b0e76d699ec27c5abf3ad96"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yNVQxNzo1NzoxNVrOIZzbRw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yNVQxODowNjowM1rOIZzx2Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MzkyNzg3OQ==", "bodyText": "Unchecked exceptions don't need to be declared in throws.", "url": "https://github.com/openhab/openhab-addons/pull/9347#discussion_r563927879", "createdAt": "2021-01-25T17:57:15Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.myq/src/main/java/org/openhab/binding/myq/internal/MyQDiscoveryService.java", "diffHunk": "@@ -0,0 +1,96 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.myq.internal;\n+\n+import static org.openhab.binding.myq.internal.MyQBindingConstants.BINDING_ID;\n+\n+import java.util.Set;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.myq.internal.dto.DevicesDTO;\n+import org.openhab.binding.myq.internal.handler.MyQAccountHandler;\n+import org.openhab.core.config.discovery.AbstractDiscoveryService;\n+import org.openhab.core.config.discovery.DiscoveryResult;\n+import org.openhab.core.config.discovery.DiscoveryResultBuilder;\n+import org.openhab.core.config.discovery.DiscoveryService;\n+import org.openhab.core.thing.ThingTypeUID;\n+import org.openhab.core.thing.ThingUID;\n+import org.openhab.core.thing.binding.ThingHandler;\n+import org.openhab.core.thing.binding.ThingHandlerService;\n+\n+/**\n+ * The {@link MyQDiscoveryService} is responsible for discovering MyQ things\n+ *\n+ * @author Dan Cunningham - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MyQDiscoveryService extends AbstractDiscoveryService implements DiscoveryService, ThingHandlerService {\n+    public MyQDiscoveryService() throws IllegalArgumentException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7c5daf34ac54a1ce6b0e76d699ec27c5abf3ad96"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MzkyODA4Ng==", "bodyText": "Please move fields to the top of the class.", "url": "https://github.com/openhab/openhab-addons/pull/9347#discussion_r563928086", "createdAt": "2021-01-25T17:57:26Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.myq/src/main/java/org/openhab/binding/myq/internal/MyQDiscoveryService.java", "diffHunk": "@@ -0,0 +1,96 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.myq.internal;\n+\n+import static org.openhab.binding.myq.internal.MyQBindingConstants.BINDING_ID;\n+\n+import java.util.Set;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.myq.internal.dto.DevicesDTO;\n+import org.openhab.binding.myq.internal.handler.MyQAccountHandler;\n+import org.openhab.core.config.discovery.AbstractDiscoveryService;\n+import org.openhab.core.config.discovery.DiscoveryResult;\n+import org.openhab.core.config.discovery.DiscoveryResultBuilder;\n+import org.openhab.core.config.discovery.DiscoveryService;\n+import org.openhab.core.thing.ThingTypeUID;\n+import org.openhab.core.thing.ThingUID;\n+import org.openhab.core.thing.binding.ThingHandler;\n+import org.openhab.core.thing.binding.ThingHandlerService;\n+\n+/**\n+ * The {@link MyQDiscoveryService} is responsible for discovering MyQ things\n+ *\n+ * @author Dan Cunningham - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MyQDiscoveryService extends AbstractDiscoveryService implements DiscoveryService, ThingHandlerService {\n+    public MyQDiscoveryService() throws IllegalArgumentException {\n+        super(SUPPORTED_DISCOVERY_THING_TYPES_UIDS, 1, true);\n+    }\n+\n+    private static final Set<ThingTypeUID> SUPPORTED_DISCOVERY_THING_TYPES_UIDS = Set\n+            .of(MyQBindingConstants.THING_TYPE_GARAGEDOOR, MyQBindingConstants.THING_TYPE_LAMP);\n+\n+    private @Nullable MyQAccountHandler accountHandler;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7c5daf34ac54a1ce6b0e76d699ec27c5abf3ad96"}, "originalPosition": 46}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MzkyODg2MA==", "bodyText": "There's a predefined constant for the serial number.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                            .withProperty(\"serialNumber\", thingUID.getId())\n          \n          \n            \n                                            .withProperty(Thing.PROPERTY_SERIAL_NUMBER, thingUID.getId())", "url": "https://github.com/openhab/openhab-addons/pull/9347#discussion_r563928860", "createdAt": "2021-01-25T17:58:14Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.myq/src/main/java/org/openhab/binding/myq/internal/MyQDiscoveryService.java", "diffHunk": "@@ -0,0 +1,96 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.myq.internal;\n+\n+import static org.openhab.binding.myq.internal.MyQBindingConstants.BINDING_ID;\n+\n+import java.util.Set;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.myq.internal.dto.DevicesDTO;\n+import org.openhab.binding.myq.internal.handler.MyQAccountHandler;\n+import org.openhab.core.config.discovery.AbstractDiscoveryService;\n+import org.openhab.core.config.discovery.DiscoveryResult;\n+import org.openhab.core.config.discovery.DiscoveryResultBuilder;\n+import org.openhab.core.config.discovery.DiscoveryService;\n+import org.openhab.core.thing.ThingTypeUID;\n+import org.openhab.core.thing.ThingUID;\n+import org.openhab.core.thing.binding.ThingHandler;\n+import org.openhab.core.thing.binding.ThingHandlerService;\n+\n+/**\n+ * The {@link MyQDiscoveryService} is responsible for discovering MyQ things\n+ *\n+ * @author Dan Cunningham - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MyQDiscoveryService extends AbstractDiscoveryService implements DiscoveryService, ThingHandlerService {\n+    public MyQDiscoveryService() throws IllegalArgumentException {\n+        super(SUPPORTED_DISCOVERY_THING_TYPES_UIDS, 1, true);\n+    }\n+\n+    private static final Set<ThingTypeUID> SUPPORTED_DISCOVERY_THING_TYPES_UIDS = Set\n+            .of(MyQBindingConstants.THING_TYPE_GARAGEDOOR, MyQBindingConstants.THING_TYPE_LAMP);\n+\n+    private @Nullable MyQAccountHandler accountHandler;\n+\n+    @Override\n+    public Set<ThingTypeUID> getSupportedThingTypes() {\n+        return SUPPORTED_DISCOVERY_THING_TYPES_UIDS;\n+    }\n+\n+    @Override\n+    public void startScan() {\n+        MyQAccountHandler accountHandler = this.accountHandler;\n+        if (accountHandler != null) {\n+            DevicesDTO devices = accountHandler.devicesCache();\n+            if (devices != null) {\n+                devices.items.forEach(device -> {\n+                    ThingTypeUID thingTypeUID = new ThingTypeUID(BINDING_ID, device.deviceFamily);\n+                    if (SUPPORTED_DISCOVERY_THING_TYPES_UIDS.contains(thingTypeUID)) {\n+                        ThingUID thingUID = new ThingUID(thingTypeUID, accountHandler.getThing().getUID(),\n+                                device.serialNumber.toLowerCase());\n+                        DiscoveryResult result = DiscoveryResultBuilder.create(thingUID).withLabel(\"MyQ \" + device.name)\n+                                .withProperty(\"serialNumber\", thingUID.getId())", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7c5daf34ac54a1ce6b0e76d699ec27c5abf3ad96"}, "originalPosition": 65}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MzkzMjAxMQ==", "bodyText": "The child handler can be of different type if the user made a mistake in the textual configuration. And syntactical sugar:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    if (localDeviceCaches != null) {\n          \n          \n            \n                        DeviceDTO device = localDeviceCaches.items.stream()\n          \n          \n            \n                                .filter(d -> ((MyQDeviceHandler) childHandler).getSerialNumber().equalsIgnoreCase(d.serialNumber))\n          \n          \n            \n                                .findFirst().orElse(null);\n          \n          \n            \n                        if (device != null) {\n          \n          \n            \n                            ((MyQDeviceHandler) childHandler).handleDeviceUpdate(device);\n          \n          \n            \n                        }\n          \n          \n            \n                    if (localDeviceCaches != null && childHandler instanceof MyQDeviceHandler) {\n          \n          \n            \n                        MyQDeviceHandler handler = (MyQDeviceHandler) childHandler;\n          \n          \n            \n                        localDeviceCaches.items.stream()\n          \n          \n            \n                                .filter(d -> ((MyQDeviceHandler) childHandler).getSerialNumber().equalsIgnoreCase(d.serialNumber))\n          \n          \n            \n                                .findFirst().ifPresent(handler::handleDeviceUpdate);", "url": "https://github.com/openhab/openhab-addons/pull/9347#discussion_r563932011", "createdAt": "2021-01-25T18:03:17Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.myq/src/main/java/org/openhab/binding/myq/internal/handler/MyQAccountHandler.java", "diffHunk": "@@ -0,0 +1,352 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.myq.internal.handler;\n+\n+import static org.openhab.binding.myq.internal.MyQBindingConstants.*;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Random;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentProvider;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.client.api.Result;\n+import org.eclipse.jetty.client.util.BufferingResponseListener;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.eclipse.jetty.http.HttpMethod;\n+import org.eclipse.jetty.http.HttpStatus;\n+import org.openhab.binding.myq.internal.MyQDiscoveryService;\n+import org.openhab.binding.myq.internal.config.MyQAccountConfiguration;\n+import org.openhab.binding.myq.internal.dto.AccountDTO;\n+import org.openhab.binding.myq.internal.dto.ActionDTO;\n+import org.openhab.binding.myq.internal.dto.DeviceDTO;\n+import org.openhab.binding.myq.internal.dto.DevicesDTO;\n+import org.openhab.binding.myq.internal.dto.LoginRequestDTO;\n+import org.openhab.binding.myq.internal.dto.LoginResponseDTO;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.ThingTypeUID;\n+import org.openhab.core.thing.binding.BaseBridgeHandler;\n+import org.openhab.core.thing.binding.ThingHandler;\n+import org.openhab.core.thing.binding.ThingHandlerService;\n+import org.openhab.core.types.Command;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.FieldNamingPolicy;\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+\n+/**\n+ * The {@link MyQAccountHandler} is responsible for communicating with the MyQ API based on an account.\n+ *\n+ * @author Dan Cunningham - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MyQAccountHandler extends BaseBridgeHandler {\n+    private static final String BASE_URL = \"https://api.myqdevice.com/api\";\n+    private static final Integer RAPID_REFRESH_SECONDS = 5;\n+    private final Logger logger = LoggerFactory.getLogger(MyQAccountHandler.class);\n+    private final Gson gsonUpperCase = new GsonBuilder().setFieldNamingPolicy(FieldNamingPolicy.UPPER_CAMEL_CASE)\n+            .create();\n+    private final Gson gsonLowerCase = new GsonBuilder()\n+            .setFieldNamingPolicy(FieldNamingPolicy.LOWER_CASE_WITH_UNDERSCORES).create();\n+    private @Nullable Future<?> normalPollFuture;\n+    private @Nullable Future<?> rapidPollFuture;\n+    private @Nullable String securityToken;\n+    private @Nullable AccountDTO account;\n+    private @Nullable DevicesDTO devicesCache;\n+    private Integer normalRefreshSeconds = 60;\n+    private HttpClient httpClient;\n+    private String username = \"\";\n+    private String password = \"\";\n+    private String userAgent = \"\";\n+\n+    public MyQAccountHandler(Bridge bridge, HttpClient httpClient) {\n+        super(bridge);\n+        this.httpClient = httpClient;\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        MyQAccountConfiguration config = getConfigAs(MyQAccountConfiguration.class);\n+        normalRefreshSeconds = config.refreshInterval;\n+        username = config.username;\n+        password = config.password;\n+        // MyQ can get picky about blocking user agents apparently\n+        userAgent = MyQAccountHandler.randomString(40);\n+        securityToken = null;\n+        updateStatus(ThingStatus.UNKNOWN);\n+        restartPolls(false);\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        stopPolls();\n+    }\n+\n+    @Override\n+    public Collection<Class<? extends ThingHandlerService>> getServices() {\n+        return Collections.singleton(MyQDiscoveryService.class);\n+    }\n+\n+    @Override\n+    public void childHandlerInitialized(ThingHandler childHandler, Thing childThing) {\n+        DevicesDTO localDeviceCaches = devicesCache;\n+        if (localDeviceCaches != null) {\n+            DeviceDTO device = localDeviceCaches.items.stream()\n+                    .filter(d -> ((MyQDeviceHandler) childHandler).getSerialNumber().equalsIgnoreCase(d.serialNumber))\n+                    .findFirst().orElse(null);\n+            if (device != null) {\n+                ((MyQDeviceHandler) childHandler).handleDeviceUpdate(device);\n+            }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7c5daf34ac54a1ce6b0e76d699ec27c5abf3ad96"}, "originalPosition": 126}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MzkzMzY1Nw==", "bodyText": "This seems the same code as in line 126. Can you make it re-useable?", "url": "https://github.com/openhab/openhab-addons/pull/9347#discussion_r563933657", "createdAt": "2021-01-25T18:06:03Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.myq/src/main/java/org/openhab/binding/myq/internal/handler/MyQAccountHandler.java", "diffHunk": "@@ -0,0 +1,352 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.myq.internal.handler;\n+\n+import static org.openhab.binding.myq.internal.MyQBindingConstants.*;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Random;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentProvider;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.client.api.Result;\n+import org.eclipse.jetty.client.util.BufferingResponseListener;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.eclipse.jetty.http.HttpMethod;\n+import org.eclipse.jetty.http.HttpStatus;\n+import org.openhab.binding.myq.internal.MyQDiscoveryService;\n+import org.openhab.binding.myq.internal.config.MyQAccountConfiguration;\n+import org.openhab.binding.myq.internal.dto.AccountDTO;\n+import org.openhab.binding.myq.internal.dto.ActionDTO;\n+import org.openhab.binding.myq.internal.dto.DeviceDTO;\n+import org.openhab.binding.myq.internal.dto.DevicesDTO;\n+import org.openhab.binding.myq.internal.dto.LoginRequestDTO;\n+import org.openhab.binding.myq.internal.dto.LoginResponseDTO;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.ThingTypeUID;\n+import org.openhab.core.thing.binding.BaseBridgeHandler;\n+import org.openhab.core.thing.binding.ThingHandler;\n+import org.openhab.core.thing.binding.ThingHandlerService;\n+import org.openhab.core.types.Command;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.FieldNamingPolicy;\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+\n+/**\n+ * The {@link MyQAccountHandler} is responsible for communicating with the MyQ API based on an account.\n+ *\n+ * @author Dan Cunningham - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MyQAccountHandler extends BaseBridgeHandler {\n+    private static final String BASE_URL = \"https://api.myqdevice.com/api\";\n+    private static final Integer RAPID_REFRESH_SECONDS = 5;\n+    private final Logger logger = LoggerFactory.getLogger(MyQAccountHandler.class);\n+    private final Gson gsonUpperCase = new GsonBuilder().setFieldNamingPolicy(FieldNamingPolicy.UPPER_CAMEL_CASE)\n+            .create();\n+    private final Gson gsonLowerCase = new GsonBuilder()\n+            .setFieldNamingPolicy(FieldNamingPolicy.LOWER_CASE_WITH_UNDERSCORES).create();\n+    private @Nullable Future<?> normalPollFuture;\n+    private @Nullable Future<?> rapidPollFuture;\n+    private @Nullable String securityToken;\n+    private @Nullable AccountDTO account;\n+    private @Nullable DevicesDTO devicesCache;\n+    private Integer normalRefreshSeconds = 60;\n+    private HttpClient httpClient;\n+    private String username = \"\";\n+    private String password = \"\";\n+    private String userAgent = \"\";\n+\n+    public MyQAccountHandler(Bridge bridge, HttpClient httpClient) {\n+        super(bridge);\n+        this.httpClient = httpClient;\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        MyQAccountConfiguration config = getConfigAs(MyQAccountConfiguration.class);\n+        normalRefreshSeconds = config.refreshInterval;\n+        username = config.username;\n+        password = config.password;\n+        // MyQ can get picky about blocking user agents apparently\n+        userAgent = MyQAccountHandler.randomString(40);\n+        securityToken = null;\n+        updateStatus(ThingStatus.UNKNOWN);\n+        restartPolls(false);\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        stopPolls();\n+    }\n+\n+    @Override\n+    public Collection<Class<? extends ThingHandlerService>> getServices() {\n+        return Collections.singleton(MyQDiscoveryService.class);\n+    }\n+\n+    @Override\n+    public void childHandlerInitialized(ThingHandler childHandler, Thing childThing) {\n+        DevicesDTO localDeviceCaches = devicesCache;\n+        if (localDeviceCaches != null) {\n+            DeviceDTO device = localDeviceCaches.items.stream()\n+                    .filter(d -> ((MyQDeviceHandler) childHandler).getSerialNumber().equalsIgnoreCase(d.serialNumber))\n+                    .findFirst().orElse(null);\n+            if (device != null) {\n+                ((MyQDeviceHandler) childHandler).handleDeviceUpdate(device);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Sends an action to the MyQ API\n+     *\n+     * @param serialNumber\n+     * @param action\n+     */\n+    public void sendAction(String serialNumber, String action) {\n+        AccountDTO localAccount = account;\n+        if (localAccount != null) {\n+            try {\n+                HttpResult result = sendRequest(\n+                        String.format(\"%s/v5.1/Accounts/%s/Devices/%s/actions\", BASE_URL, localAccount.account.id,\n+                                serialNumber),\n+                        HttpMethod.PUT, securityToken,\n+                        new StringContentProvider(gsonLowerCase.toJson(new ActionDTO(action))), \"application/json\");\n+                if (HttpStatus.isSuccess(result.responseCode)) {\n+                    restartPolls(true);\n+                } else {\n+                    logger.debug(\"Failed to send action {} : {}\", action, result.content);\n+                }\n+            } catch (InterruptedException e) {\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Last known state of MyQ Devices\n+     *\n+     * @return cached MyQ devices\n+     */\n+    public @Nullable DevicesDTO devicesCache() {\n+        return devicesCache;\n+    }\n+\n+    private void stopPolls() {\n+        stopNormalPoll();\n+        stopRapidPoll();\n+    }\n+\n+    private synchronized void stopNormalPoll() {\n+        stopFuture(normalPollFuture);\n+        normalPollFuture = null;\n+    }\n+\n+    private synchronized void stopRapidPoll() {\n+        stopFuture(rapidPollFuture);\n+        rapidPollFuture = null;\n+    }\n+\n+    private void stopFuture(@Nullable Future<?> future) {\n+        if (future != null) {\n+            future.cancel(true);\n+        }\n+    }\n+\n+    private synchronized void restartPolls(boolean rapid) {\n+        stopPolls();\n+        if (rapid) {\n+            normalPollFuture = scheduler.scheduleWithFixedDelay(this::normalPoll, 35, normalRefreshSeconds,\n+                    TimeUnit.SECONDS);\n+            rapidPollFuture = scheduler.scheduleWithFixedDelay(this::rapidPoll, 3, RAPID_REFRESH_SECONDS,\n+                    TimeUnit.SECONDS);\n+        } else {\n+            normalPollFuture = scheduler.scheduleWithFixedDelay(this::normalPoll, 0, normalRefreshSeconds,\n+                    TimeUnit.SECONDS);\n+        }\n+    }\n+\n+    private void normalPoll() {\n+        stopRapidPoll();\n+        fetchData();\n+    }\n+\n+    private void rapidPoll() {\n+        fetchData();\n+    }\n+\n+    private synchronized void fetchData() {\n+        try {\n+            if (securityToken == null) {\n+                login();\n+                if (securityToken != null) {\n+                    getAccount();\n+                }\n+            }\n+\n+            if (securityToken != null) {\n+                getDevices();\n+            }\n+        } catch (InterruptedException e) {\n+        }\n+    }\n+\n+    private void login() throws InterruptedException {\n+        HttpResult result = sendRequest(BASE_URL + \"/v5/Login\", HttpMethod.POST, null,\n+                new StringContentProvider(gsonUpperCase.toJson(new LoginRequestDTO(username, password))),\n+                \"application/json\");\n+        if (HttpStatus.isSuccess(result.responseCode)) {\n+            LoginResponseDTO loginResponse = gsonUpperCase.fromJson(result.content, LoginResponseDTO.class);\n+            if (loginResponse != null) {\n+                securityToken = loginResponse.securityToken;\n+                updateStatus(ThingStatus.ONLINE);\n+            } else {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, \"Invalid Response Body\");\n+            }\n+        } else {\n+            handleErrorResponse(result);\n+            if (thing.getStatusInfo().getStatusDetail() == ThingStatusDetail.CONFIGURATION_ERROR) {\n+                // bad credentials, stop trying to login\n+                stopPolls();\n+            }\n+        }\n+    }\n+\n+    private void getAccount() throws InterruptedException {\n+        HttpResult result = sendRequest(BASE_URL + \"/v5/My?expand=account\", HttpMethod.GET, securityToken, null, null);\n+        if (HttpStatus.isSuccess(result.responseCode)) {\n+            account = gsonUpperCase.fromJson(result.content, AccountDTO.class);\n+        } else {\n+            handleErrorResponse(result);\n+        }\n+    }\n+\n+    private void getDevices() throws InterruptedException {\n+        AccountDTO localAccount = account;\n+        if (localAccount == null) {\n+            return;\n+        }\n+        HttpResult result = sendRequest(String.format(\"%s/v5.1/Accounts/%s/Devices\", BASE_URL, localAccount.account.id),\n+                HttpMethod.GET, securityToken, null, null);\n+        if (HttpStatus.isSuccess(result.responseCode)) {\n+            if (getThing().getStatus() != ThingStatus.ONLINE) {\n+                updateStatus(ThingStatus.ONLINE);\n+            }\n+            DevicesDTO devices = gsonLowerCase.fromJson(result.content, DevicesDTO.class);\n+            if (devices != null) {\n+                devicesCache = devices;\n+                devices.items.forEach(device -> {\n+                    ThingTypeUID thingTypeUID = new ThingTypeUID(BINDING_ID, device.deviceFamily);\n+                    if (SUPPORTED_DISCOVERY_THING_TYPES_UIDS.contains(thingTypeUID)) {\n+                        for (Thing thing : getThing().getThings()) {\n+                            ThingHandler handler = thing.getHandler();\n+                            if (handler != null && ((MyQDeviceHandler) handler).getSerialNumber()\n+                                    .equalsIgnoreCase(device.serialNumber)) {\n+                                ((MyQDeviceHandler) handler).handleDeviceUpdate(device);\n+                            }\n+                        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7c5daf34ac54a1ce6b0e76d699ec27c5abf3ad96"}, "originalPosition": 276}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "91b6ef130c28d176cb9d33653a01b9c053142d36", "author": {"user": {"login": "digitaldan", "name": "Dan Cunningham"}}, "url": "https://github.com/openhab/openhab-addons/commit/91b6ef130c28d176cb9d33653a01b9c053142d36", "committedDate": "2021-01-25T20:09:47Z", "message": "Small PR cleanups\n\nSigned-off-by: Dan Cunningham <dan@digitaldan.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "44ab5f44c3abb7d3c2ec57944b39fef091f31f56", "author": {"user": {"login": "digitaldan", "name": "Dan Cunningham"}}, "url": "https://github.com/openhab/openhab-addons/commit/44ab5f44c3abb7d3c2ec57944b39fef091f31f56", "committedDate": "2021-01-25T20:11:38Z", "message": "One last small PR cleanup\n\nSigned-off-by: Dan Cunningham <dan@digitaldan.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "37eb721dd5eaa1316fcdf433de624cb1c060450d", "author": {"user": {"login": "digitaldan", "name": "Dan Cunningham"}}, "url": "https://github.com/openhab/openhab-addons/commit/37eb721dd5eaa1316fcdf433de624cb1c060450d", "committedDate": "2021-01-30T18:38:31Z", "message": "Syntactical sugar\n\nSigned-off-by: Dan Cunningham <dan@digitaldan.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTc5ODAzNzc5", "url": "https://github.com/openhab/openhab-addons/pull/9347#pullrequestreview-579803779", "createdAt": "2021-01-30T20:02:50Z", "commit": {"oid": "37eb721dd5eaa1316fcdf433de624cb1c060450d"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTgzMDg0Nzk3", "url": "https://github.com/openhab/openhab-addons/pull/9347#pullrequestreview-583084797", "createdAt": "2021-02-04T07:01:23Z", "commit": {"oid": "37eb721dd5eaa1316fcdf433de624cb1c060450d"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0wNFQwNzowMToyM1rOIflTZw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0wNFQwNzowMjozOVrOIflVEQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTk4Nzk0Mw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    StringBuffer sb = new StringBuffer(length);\n          \n          \n            \n                    StringBuilder sb = new StringBuilder(length);", "url": "https://github.com/openhab/openhab-addons/pull/9347#discussion_r569987943", "createdAt": "2021-02-04T07:01:23Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.myq/src/main/java/org/openhab/binding/myq/internal/handler/MyQAccountHandler.java", "diffHunk": "@@ -0,0 +1,349 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.myq.internal.handler;\n+\n+import static org.openhab.binding.myq.internal.MyQBindingConstants.*;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Random;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentProvider;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.client.api.Result;\n+import org.eclipse.jetty.client.util.BufferingResponseListener;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.eclipse.jetty.http.HttpMethod;\n+import org.eclipse.jetty.http.HttpStatus;\n+import org.openhab.binding.myq.internal.MyQDiscoveryService;\n+import org.openhab.binding.myq.internal.config.MyQAccountConfiguration;\n+import org.openhab.binding.myq.internal.dto.AccountDTO;\n+import org.openhab.binding.myq.internal.dto.ActionDTO;\n+import org.openhab.binding.myq.internal.dto.DevicesDTO;\n+import org.openhab.binding.myq.internal.dto.LoginRequestDTO;\n+import org.openhab.binding.myq.internal.dto.LoginResponseDTO;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.ThingTypeUID;\n+import org.openhab.core.thing.binding.BaseBridgeHandler;\n+import org.openhab.core.thing.binding.ThingHandler;\n+import org.openhab.core.thing.binding.ThingHandlerService;\n+import org.openhab.core.types.Command;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.FieldNamingPolicy;\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+\n+/**\n+ * The {@link MyQAccountHandler} is responsible for communicating with the MyQ API based on an account.\n+ *\n+ * @author Dan Cunningham - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MyQAccountHandler extends BaseBridgeHandler {\n+    private static final String BASE_URL = \"https://api.myqdevice.com/api\";\n+    private static final Integer RAPID_REFRESH_SECONDS = 5;\n+    private final Logger logger = LoggerFactory.getLogger(MyQAccountHandler.class);\n+    private final Gson gsonUpperCase = new GsonBuilder().setFieldNamingPolicy(FieldNamingPolicy.UPPER_CAMEL_CASE)\n+            .create();\n+    private final Gson gsonLowerCase = new GsonBuilder()\n+            .setFieldNamingPolicy(FieldNamingPolicy.LOWER_CASE_WITH_UNDERSCORES).create();\n+    private @Nullable Future<?> normalPollFuture;\n+    private @Nullable Future<?> rapidPollFuture;\n+    private @Nullable String securityToken;\n+    private @Nullable AccountDTO account;\n+    private @Nullable DevicesDTO devicesCache;\n+    private Integer normalRefreshSeconds = 60;\n+    private HttpClient httpClient;\n+    private String username = \"\";\n+    private String password = \"\";\n+    private String userAgent = \"\";\n+\n+    public MyQAccountHandler(Bridge bridge, HttpClient httpClient) {\n+        super(bridge);\n+        this.httpClient = httpClient;\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        MyQAccountConfiguration config = getConfigAs(MyQAccountConfiguration.class);\n+        normalRefreshSeconds = config.refreshInterval;\n+        username = config.username;\n+        password = config.password;\n+        // MyQ can get picky about blocking user agents apparently\n+        userAgent = MyQAccountHandler.randomString(40);\n+        securityToken = null;\n+        updateStatus(ThingStatus.UNKNOWN);\n+        restartPolls(false);\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        stopPolls();\n+    }\n+\n+    @Override\n+    public Collection<Class<? extends ThingHandlerService>> getServices() {\n+        return Collections.singleton(MyQDiscoveryService.class);\n+    }\n+\n+    @Override\n+    public void childHandlerInitialized(ThingHandler childHandler, Thing childThing) {\n+        DevicesDTO localDeviceCaches = devicesCache;\n+        if (localDeviceCaches != null && childHandler instanceof MyQDeviceHandler) {\n+            MyQDeviceHandler handler = (MyQDeviceHandler) childHandler;\n+            localDeviceCaches.items.stream()\n+                    .filter(d -> ((MyQDeviceHandler) childHandler).getSerialNumber().equalsIgnoreCase(d.serialNumber))\n+                    .findFirst().ifPresent(handler::handleDeviceUpdate);\n+        }\n+    }\n+\n+    /**\n+     * Sends an action to the MyQ API\n+     *\n+     * @param serialNumber\n+     * @param action\n+     */\n+    public void sendAction(String serialNumber, String action) {\n+        AccountDTO localAccount = account;\n+        if (localAccount != null) {\n+            try {\n+                HttpResult result = sendRequest(\n+                        String.format(\"%s/v5.1/Accounts/%s/Devices/%s/actions\", BASE_URL, localAccount.account.id,\n+                                serialNumber),\n+                        HttpMethod.PUT, securityToken,\n+                        new StringContentProvider(gsonLowerCase.toJson(new ActionDTO(action))), \"application/json\");\n+                if (HttpStatus.isSuccess(result.responseCode)) {\n+                    restartPolls(true);\n+                } else {\n+                    logger.debug(\"Failed to send action {} : {}\", action, result.content);\n+                }\n+            } catch (InterruptedException e) {\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Last known state of MyQ Devices\n+     *\n+     * @return cached MyQ devices\n+     */\n+    public @Nullable DevicesDTO devicesCache() {\n+        return devicesCache;\n+    }\n+\n+    private void stopPolls() {\n+        stopNormalPoll();\n+        stopRapidPoll();\n+    }\n+\n+    private synchronized void stopNormalPoll() {\n+        stopFuture(normalPollFuture);\n+        normalPollFuture = null;\n+    }\n+\n+    private synchronized void stopRapidPoll() {\n+        stopFuture(rapidPollFuture);\n+        rapidPollFuture = null;\n+    }\n+\n+    private void stopFuture(@Nullable Future<?> future) {\n+        if (future != null) {\n+            future.cancel(true);\n+        }\n+    }\n+\n+    private synchronized void restartPolls(boolean rapid) {\n+        stopPolls();\n+        if (rapid) {\n+            normalPollFuture = scheduler.scheduleWithFixedDelay(this::normalPoll, 35, normalRefreshSeconds,\n+                    TimeUnit.SECONDS);\n+            rapidPollFuture = scheduler.scheduleWithFixedDelay(this::rapidPoll, 3, RAPID_REFRESH_SECONDS,\n+                    TimeUnit.SECONDS);\n+        } else {\n+            normalPollFuture = scheduler.scheduleWithFixedDelay(this::normalPoll, 0, normalRefreshSeconds,\n+                    TimeUnit.SECONDS);\n+        }\n+    }\n+\n+    private void normalPoll() {\n+        stopRapidPoll();\n+        fetchData();\n+    }\n+\n+    private void rapidPoll() {\n+        fetchData();\n+    }\n+\n+    private synchronized void fetchData() {\n+        try {\n+            if (securityToken == null) {\n+                login();\n+                if (securityToken != null) {\n+                    getAccount();\n+                }\n+            }\n+\n+            if (securityToken != null) {\n+                getDevices();\n+            }\n+        } catch (InterruptedException e) {\n+        }\n+    }\n+\n+    private void login() throws InterruptedException {\n+        HttpResult result = sendRequest(BASE_URL + \"/v5/Login\", HttpMethod.POST, null,\n+                new StringContentProvider(gsonUpperCase.toJson(new LoginRequestDTO(username, password))),\n+                \"application/json\");\n+        if (HttpStatus.isSuccess(result.responseCode)) {\n+            LoginResponseDTO loginResponse = gsonUpperCase.fromJson(result.content, LoginResponseDTO.class);\n+            if (loginResponse != null) {\n+                securityToken = loginResponse.securityToken;\n+                updateStatus(ThingStatus.ONLINE);\n+            } else {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, \"Invalid Response Body\");\n+            }\n+        } else {\n+            handleErrorResponse(result);\n+            if (thing.getStatusInfo().getStatusDetail() == ThingStatusDetail.CONFIGURATION_ERROR) {\n+                // bad credentials, stop trying to login\n+                stopPolls();\n+            }\n+        }\n+    }\n+\n+    private void getAccount() throws InterruptedException {\n+        HttpResult result = sendRequest(BASE_URL + \"/v5/My?expand=account\", HttpMethod.GET, securityToken, null, null);\n+        if (HttpStatus.isSuccess(result.responseCode)) {\n+            account = gsonUpperCase.fromJson(result.content, AccountDTO.class);\n+        } else {\n+            handleErrorResponse(result);\n+        }\n+    }\n+\n+    private void getDevices() throws InterruptedException {\n+        AccountDTO localAccount = account;\n+        if (localAccount == null) {\n+            return;\n+        }\n+        HttpResult result = sendRequest(String.format(\"%s/v5.1/Accounts/%s/Devices\", BASE_URL, localAccount.account.id),\n+                HttpMethod.GET, securityToken, null, null);\n+        if (HttpStatus.isSuccess(result.responseCode)) {\n+            if (getThing().getStatus() != ThingStatus.ONLINE) {\n+                updateStatus(ThingStatus.ONLINE);\n+            }\n+            DevicesDTO devices = gsonLowerCase.fromJson(result.content, DevicesDTO.class);\n+            if (devices != null) {\n+                devicesCache = devices;\n+                devices.items.forEach(device -> {\n+                    ThingTypeUID thingTypeUID = new ThingTypeUID(BINDING_ID, device.deviceFamily);\n+                    if (SUPPORTED_DISCOVERY_THING_TYPES_UIDS.contains(thingTypeUID)) {\n+                        for (Thing thing : getThing().getThings()) {\n+                            ThingHandler handler = thing.getHandler();\n+                            if (handler != null && ((MyQDeviceHandler) handler).getSerialNumber()\n+                                    .equalsIgnoreCase(device.serialNumber)) {\n+                                ((MyQDeviceHandler) handler).handleDeviceUpdate(device);\n+                            }\n+                        }\n+                    }\n+                });\n+            }\n+        } else {\n+            handleErrorResponse(result);\n+        }\n+    }\n+\n+    private synchronized HttpResult sendRequest(String url, HttpMethod method, @Nullable String token,\n+            @Nullable ContentProvider content, @Nullable String contentType) throws InterruptedException {\n+        try {\n+            Request request = httpClient.newRequest(url).method(method)\n+                    .header(\"MyQApplicationId\", \"JVM/G9Nwih5BwKgNCjLxiFUQxQijAebyyg8QUHr7JOrP+tuPb8iHfRHKwTmDzHOu\")\n+                    .header(\"ApiVersion\", \"5.1\").header(\"BrandId\", \"2\").header(\"Culture\", \"en\").agent(userAgent)\n+                    .timeout(10, TimeUnit.SECONDS);\n+            if (token != null) {\n+                request = request.header(\"SecurityToken\", token);\n+            }\n+            if (content != null & contentType != null) {\n+                request = request.content(content, contentType);\n+            }\n+            // use asyc jetty as the API service will response with a 401 error when credentials are wrong,\n+            // but not a WWW-Authenticate header which causes Jetty to throw a generic execution exception which\n+            // prevents us from knowing the response code\n+            logger.trace(\"Sending {} to {}\", request.getMethod(), request.getURI());\n+            final CompletableFuture<HttpResult> futureResult = new CompletableFuture<>();\n+            request.send(new BufferingResponseListener() {\n+                @NonNullByDefault({})\n+                @Override\n+                public void onComplete(Result result) {\n+                    futureResult.complete(new HttpResult(result.getResponse().getStatus(), getContentAsString()));\n+                }\n+            });\n+            HttpResult result = futureResult.get();\n+            logger.trace(\"Account Response - status: {} content: {}\", result.responseCode, result.content);\n+            return result;\n+        } catch (ExecutionException e) {\n+            return new HttpResult(0, e.getMessage());\n+        }\n+    }\n+\n+    private void handleErrorResponse(HttpResult result) {\n+        if (HttpStatus.isSuccess(result.responseCode)) {\n+            return;\n+        }\n+        if (result.responseCode == HttpStatus.UNAUTHORIZED_401) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"Unauthorized - Check Credentials\");\n+            securityToken = null;\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                    \"Invalid Response \" + result.content);\n+        }\n+    }\n+\n+    public static class HttpResult {\n+        public final int responseCode;\n+        public @Nullable String content;\n+\n+        public HttpResult(int responseCode, @Nullable String content) {\n+            this.responseCode = responseCode;\n+            this.content = content;\n+        }\n+    }\n+\n+    private static String randomString(int length) {\n+        int low = 97; // a-z\n+        int high = 122; // A-Z\n+        StringBuffer sb = new StringBuffer(length);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "37eb721dd5eaa1316fcdf433de624cb1c060450d"}, "originalPosition": 342}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTk4ODM2OQ==", "bodyText": "You should catch the JsonSyntaxException that is thrown here.", "url": "https://github.com/openhab/openhab-addons/pull/9347#discussion_r569988369", "createdAt": "2021-02-04T07:02:39Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.myq/src/main/java/org/openhab/binding/myq/internal/handler/MyQAccountHandler.java", "diffHunk": "@@ -0,0 +1,349 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.myq.internal.handler;\n+\n+import static org.openhab.binding.myq.internal.MyQBindingConstants.*;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Random;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentProvider;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.client.api.Result;\n+import org.eclipse.jetty.client.util.BufferingResponseListener;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.eclipse.jetty.http.HttpMethod;\n+import org.eclipse.jetty.http.HttpStatus;\n+import org.openhab.binding.myq.internal.MyQDiscoveryService;\n+import org.openhab.binding.myq.internal.config.MyQAccountConfiguration;\n+import org.openhab.binding.myq.internal.dto.AccountDTO;\n+import org.openhab.binding.myq.internal.dto.ActionDTO;\n+import org.openhab.binding.myq.internal.dto.DevicesDTO;\n+import org.openhab.binding.myq.internal.dto.LoginRequestDTO;\n+import org.openhab.binding.myq.internal.dto.LoginResponseDTO;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.ThingTypeUID;\n+import org.openhab.core.thing.binding.BaseBridgeHandler;\n+import org.openhab.core.thing.binding.ThingHandler;\n+import org.openhab.core.thing.binding.ThingHandlerService;\n+import org.openhab.core.types.Command;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.FieldNamingPolicy;\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+\n+/**\n+ * The {@link MyQAccountHandler} is responsible for communicating with the MyQ API based on an account.\n+ *\n+ * @author Dan Cunningham - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MyQAccountHandler extends BaseBridgeHandler {\n+    private static final String BASE_URL = \"https://api.myqdevice.com/api\";\n+    private static final Integer RAPID_REFRESH_SECONDS = 5;\n+    private final Logger logger = LoggerFactory.getLogger(MyQAccountHandler.class);\n+    private final Gson gsonUpperCase = new GsonBuilder().setFieldNamingPolicy(FieldNamingPolicy.UPPER_CAMEL_CASE)\n+            .create();\n+    private final Gson gsonLowerCase = new GsonBuilder()\n+            .setFieldNamingPolicy(FieldNamingPolicy.LOWER_CASE_WITH_UNDERSCORES).create();\n+    private @Nullable Future<?> normalPollFuture;\n+    private @Nullable Future<?> rapidPollFuture;\n+    private @Nullable String securityToken;\n+    private @Nullable AccountDTO account;\n+    private @Nullable DevicesDTO devicesCache;\n+    private Integer normalRefreshSeconds = 60;\n+    private HttpClient httpClient;\n+    private String username = \"\";\n+    private String password = \"\";\n+    private String userAgent = \"\";\n+\n+    public MyQAccountHandler(Bridge bridge, HttpClient httpClient) {\n+        super(bridge);\n+        this.httpClient = httpClient;\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        MyQAccountConfiguration config = getConfigAs(MyQAccountConfiguration.class);\n+        normalRefreshSeconds = config.refreshInterval;\n+        username = config.username;\n+        password = config.password;\n+        // MyQ can get picky about blocking user agents apparently\n+        userAgent = MyQAccountHandler.randomString(40);\n+        securityToken = null;\n+        updateStatus(ThingStatus.UNKNOWN);\n+        restartPolls(false);\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        stopPolls();\n+    }\n+\n+    @Override\n+    public Collection<Class<? extends ThingHandlerService>> getServices() {\n+        return Collections.singleton(MyQDiscoveryService.class);\n+    }\n+\n+    @Override\n+    public void childHandlerInitialized(ThingHandler childHandler, Thing childThing) {\n+        DevicesDTO localDeviceCaches = devicesCache;\n+        if (localDeviceCaches != null && childHandler instanceof MyQDeviceHandler) {\n+            MyQDeviceHandler handler = (MyQDeviceHandler) childHandler;\n+            localDeviceCaches.items.stream()\n+                    .filter(d -> ((MyQDeviceHandler) childHandler).getSerialNumber().equalsIgnoreCase(d.serialNumber))\n+                    .findFirst().ifPresent(handler::handleDeviceUpdate);\n+        }\n+    }\n+\n+    /**\n+     * Sends an action to the MyQ API\n+     *\n+     * @param serialNumber\n+     * @param action\n+     */\n+    public void sendAction(String serialNumber, String action) {\n+        AccountDTO localAccount = account;\n+        if (localAccount != null) {\n+            try {\n+                HttpResult result = sendRequest(\n+                        String.format(\"%s/v5.1/Accounts/%s/Devices/%s/actions\", BASE_URL, localAccount.account.id,\n+                                serialNumber),\n+                        HttpMethod.PUT, securityToken,\n+                        new StringContentProvider(gsonLowerCase.toJson(new ActionDTO(action))), \"application/json\");\n+                if (HttpStatus.isSuccess(result.responseCode)) {\n+                    restartPolls(true);\n+                } else {\n+                    logger.debug(\"Failed to send action {} : {}\", action, result.content);\n+                }\n+            } catch (InterruptedException e) {\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Last known state of MyQ Devices\n+     *\n+     * @return cached MyQ devices\n+     */\n+    public @Nullable DevicesDTO devicesCache() {\n+        return devicesCache;\n+    }\n+\n+    private void stopPolls() {\n+        stopNormalPoll();\n+        stopRapidPoll();\n+    }\n+\n+    private synchronized void stopNormalPoll() {\n+        stopFuture(normalPollFuture);\n+        normalPollFuture = null;\n+    }\n+\n+    private synchronized void stopRapidPoll() {\n+        stopFuture(rapidPollFuture);\n+        rapidPollFuture = null;\n+    }\n+\n+    private void stopFuture(@Nullable Future<?> future) {\n+        if (future != null) {\n+            future.cancel(true);\n+        }\n+    }\n+\n+    private synchronized void restartPolls(boolean rapid) {\n+        stopPolls();\n+        if (rapid) {\n+            normalPollFuture = scheduler.scheduleWithFixedDelay(this::normalPoll, 35, normalRefreshSeconds,\n+                    TimeUnit.SECONDS);\n+            rapidPollFuture = scheduler.scheduleWithFixedDelay(this::rapidPoll, 3, RAPID_REFRESH_SECONDS,\n+                    TimeUnit.SECONDS);\n+        } else {\n+            normalPollFuture = scheduler.scheduleWithFixedDelay(this::normalPoll, 0, normalRefreshSeconds,\n+                    TimeUnit.SECONDS);\n+        }\n+    }\n+\n+    private void normalPoll() {\n+        stopRapidPoll();\n+        fetchData();\n+    }\n+\n+    private void rapidPoll() {\n+        fetchData();\n+    }\n+\n+    private synchronized void fetchData() {\n+        try {\n+            if (securityToken == null) {\n+                login();\n+                if (securityToken != null) {\n+                    getAccount();\n+                }\n+            }\n+\n+            if (securityToken != null) {\n+                getDevices();\n+            }\n+        } catch (InterruptedException e) {\n+        }\n+    }\n+\n+    private void login() throws InterruptedException {\n+        HttpResult result = sendRequest(BASE_URL + \"/v5/Login\", HttpMethod.POST, null,\n+                new StringContentProvider(gsonUpperCase.toJson(new LoginRequestDTO(username, password))),\n+                \"application/json\");\n+        if (HttpStatus.isSuccess(result.responseCode)) {\n+            LoginResponseDTO loginResponse = gsonUpperCase.fromJson(result.content, LoginResponseDTO.class);\n+            if (loginResponse != null) {\n+                securityToken = loginResponse.securityToken;\n+                updateStatus(ThingStatus.ONLINE);\n+            } else {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, \"Invalid Response Body\");\n+            }\n+        } else {\n+            handleErrorResponse(result);\n+            if (thing.getStatusInfo().getStatusDetail() == ThingStatusDetail.CONFIGURATION_ERROR) {\n+                // bad credentials, stop trying to login\n+                stopPolls();\n+            }\n+        }\n+    }\n+\n+    private void getAccount() throws InterruptedException {\n+        HttpResult result = sendRequest(BASE_URL + \"/v5/My?expand=account\", HttpMethod.GET, securityToken, null, null);\n+        if (HttpStatus.isSuccess(result.responseCode)) {\n+            account = gsonUpperCase.fromJson(result.content, AccountDTO.class);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "37eb721dd5eaa1316fcdf433de624cb1c060450d"}, "originalPosition": 244}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "91d947fe61764299806e2217d9cb16b180e8d124", "author": {"user": null}, "url": "https://github.com/openhab/openhab-addons/commit/91d947fe61764299806e2217d9cb16b180e8d124", "committedDate": "2021-02-15T21:15:29Z", "message": "Updated error handling\n\nSigned-off-by: Dan <dan@MacBook-Pro.digitaldan.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "483f62de83c7e0b6a59ff7aa113f011a034c716b", "author": {"user": {"login": "digitaldan", "name": "Dan Cunningham"}}, "url": "https://github.com/openhab/openhab-addons/commit/483f62de83c7e0b6a59ff7aa113f011a034c716b", "committedDate": "2021-02-20T18:57:30Z", "message": "Spelling mistake\n\nSigned-off-by: Dan Cunningham <dan@digitaldan.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "283d5e63c25558b7e64fd2f8deb6e73e9b2a2fda", "author": {"user": {"login": "digitaldan", "name": "Dan Cunningham"}}, "url": "https://github.com/openhab/openhab-addons/commit/283d5e63c25558b7e64fd2f8deb6e73e9b2a2fda", "committedDate": "2021-02-18T22:55:24Z", "message": "Spelling mistake"}, "afterCommit": {"oid": "483f62de83c7e0b6a59ff7aa113f011a034c716b", "author": {"user": {"login": "digitaldan", "name": "Dan Cunningham"}}, "url": "https://github.com/openhab/openhab-addons/commit/483f62de83c7e0b6a59ff7aa113f011a034c716b", "committedDate": "2021-02-20T18:57:30Z", "message": "Spelling mistake\n\nSigned-off-by: Dan Cunningham <dan@digitaldan.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjAwMDEwMDI5", "url": "https://github.com/openhab/openhab-addons/pull/9347#pullrequestreview-600010029", "createdAt": "2021-02-26T22:49:58Z", "commit": {"oid": "483f62de83c7e0b6a59ff7aa113f011a034c716b"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3750, "cost": 1, "resetAt": "2021-10-28T20:13:43Z"}}}