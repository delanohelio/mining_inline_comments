{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDExNzM1NjA2", "number": 7509, "title": "[lcn] Add LCN binding", "bodyText": "Migrates the Local Control Network Binding from OH1 to OH2.\nCloses #108\nSigned-off-by: Fabian Wolter git@fabian-wolter.de", "createdAt": "2020-04-30T17:35:09Z", "url": "https://github.com/openhab/openhab-addons/pull/7509", "merged": true, "mergeCommit": {"oid": "0ae2319ddc3564f690215c31e941fbe3803b06d0"}, "closed": true, "closedAt": "2020-06-17T19:20:30Z", "author": {"login": "fwolter"}, "timelineItems": {"totalCount": 26, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcmyoZfgH2gAyNDExNzM1NjA2OmFiNDRiZDg5Y2RlNDllMGJlMzNmZTk3MTYxNTdhMGY4M2QzNzYzMjg=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcsO5bigFqTQzMjcwMzg3MQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "ab44bd89cde49e0be33fe9716157a0f83d376328", "author": {"user": {"login": "fwolter", "name": "Fabian Wolter"}}, "url": "https://github.com/openhab/openhab-addons/commit/ab44bd89cde49e0be33fe9716157a0f83d376328", "committedDate": "2020-05-31T21:34:35Z", "message": "[lcn] Add LCN binding\n\nMigrates the Local Control Network Binding from OH1 to OH2.\n\nCloses #108\n\nSigned-off-by: Fabian Wolter <github@fabian-wolter.de>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a0d78733a4c71137dc0e12ae39072904caf1ab6e", "author": {"user": {"login": "fwolter", "name": "Fabian Wolter"}}, "url": "https://github.com/openhab/openhab-addons/commit/a0d78733a4c71137dc0e12ae39072904caf1ab6e", "committedDate": "2020-05-31T21:34:50Z", "message": "Minor improvements\n\nSigned-off-by: Fabian Wolter <github@fabian-wolter.de>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e30dc55c9fa422439f89c1222dba4b63aace3f9a", "author": {"user": {"login": "fwolter", "name": "Fabian Wolter"}}, "url": "https://github.com/openhab/openhab-addons/commit/e30dc55c9fa422439f89c1222dba4b63aace3f9a", "committedDate": "2020-05-31T21:34:50Z", "message": "Improve discovery\n\nSigned-off-by: Fabian Wolter <github@fabian-wolter.de>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f6c8d4f8d969cbbfa051f03b747f630902ea29ab", "author": {"user": {"login": "fwolter", "name": "Fabian Wolter"}}, "url": "https://github.com/openhab/openhab-addons/commit/f6c8d4f8d969cbbfa051f03b747f630902ea29ab", "committedDate": "2020-06-02T21:23:37Z", "message": "Fix formatting and improve LcnModuleHandler lifecycle\n\nSigned-off-by: Fabian Wolter <github@fabian-wolter.de>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "dbe413f2f442645719b349fb40ffb7d2e2ca997e", "author": {"user": {"login": "fwolter", "name": "Fabian Wolter"}}, "url": "https://github.com/openhab/openhab-addons/commit/dbe413f2f442645719b349fb40ffb7d2e2ca997e", "committedDate": "2020-06-06T13:23:08Z", "message": "Reviewed own code\n\nSigned-off-by: Fabian Wolter <github@fabian-wolter.de>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ce02f433e5d4071dbebb9ee68da0e22895887b6b", "author": {"user": {"login": "fwolter", "name": "Fabian Wolter"}}, "url": "https://github.com/openhab/openhab-addons/commit/ce02f433e5d4071dbebb9ee68da0e22895887b6b", "committedDate": "2020-06-06T19:17:33Z", "message": "Remove test project\n\nSigned-off-by: Fabian Wolter <github@fabian-wolter.de>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI1ODQ2NzU1", "url": "https://github.com/openhab/openhab-addons/pull/7509#pullrequestreview-425846755", "createdAt": "2020-06-07T19:27:35Z", "commit": {"oid": "ce02f433e5d4071dbebb9ee68da0e22895887b6b"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 24, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wN1QxOToyNzozNlrOGgLX-Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wN1QyMTowMjo0NFrOGgL1qg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjM5Mzk3Nw==", "bodyText": "please remove, this is not really LCN specific and Paper UI will anyhow be gone soon.", "url": "https://github.com/openhab/openhab-addons/pull/7509#discussion_r436393977", "createdAt": "2020-06-07T19:27:36Z", "author": {"login": "kaikreuzer"}, "path": "bundles/org.openhab.binding.lcn/README.md", "diffHunk": "@@ -0,0 +1,597 @@\n+# LCN Binding\n+\n+[Local Control Network (LCN)](http://www.lcn.eu) is a building automation system for small and very large installations.\n+It is capable of controlling lights, shutters, access control etc. and can process data from several sensor types.\n+It has been introduced in 1992.\n+\n+A broad range of glass key panels, displays, remote controls, sensors and in- and outputs exist.  \n+The system can handle up to 30,000 bus members, called modules.\n+LCN modules are available for DIN rail and in-wall mounting and feature versatile interfaces. The bus modules and most of the accessories are developed, manufactured and assembled in Germany.\n+\n+Bus members are inter-connected via a free wire in the standard NYM cable. Wireless components are available, though.\n+\n+![Illustration of the LCN product family](doc/overview.jpg)\n+\n+This binding uses TCP/IP to access the LCN bus via the software LCN-PCHK (Windows/Linux) or the DIN rail device LCN-PKE.\n+**This means 1 unused LCN-PCHK license or a LCN-PKE is required**\n+\n+It is recommended to configure *Thing*s in [Paper UI](https://www.openhab.org/docs/configuration/paperui.html) and *Item*s in text files.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ce02f433e5d4071dbebb9ee68da0e22895887b6b"}, "originalPosition": 18}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjM5Mzk5NA==", "bodyText": "remove", "url": "https://github.com/openhab/openhab-addons/pull/7509#discussion_r436393994", "createdAt": "2020-06-07T19:27:45Z", "author": {"login": "kaikreuzer"}, "path": "bundles/org.openhab.binding.lcn/README.md", "diffHunk": "@@ -0,0 +1,597 @@\n+# LCN Binding\n+\n+[Local Control Network (LCN)](http://www.lcn.eu) is a building automation system for small and very large installations.\n+It is capable of controlling lights, shutters, access control etc. and can process data from several sensor types.\n+It has been introduced in 1992.\n+\n+A broad range of glass key panels, displays, remote controls, sensors and in- and outputs exist.  \n+The system can handle up to 30,000 bus members, called modules.\n+LCN modules are available for DIN rail and in-wall mounting and feature versatile interfaces. The bus modules and most of the accessories are developed, manufactured and assembled in Germany.\n+\n+Bus members are inter-connected via a free wire in the standard NYM cable. Wireless components are available, though.\n+\n+![Illustration of the LCN product family](doc/overview.jpg)\n+\n+This binding uses TCP/IP to access the LCN bus via the software LCN-PCHK (Windows/Linux) or the DIN rail device LCN-PKE.\n+**This means 1 unused LCN-PCHK license or a LCN-PKE is required**\n+\n+It is recommended to configure *Thing*s in [Paper UI](https://www.openhab.org/docs/configuration/paperui.html) and *Item*s in text files.\n+*Channel*s and *Link*s are configured automatically, then.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ce02f433e5d4071dbebb9ee68da0e22895887b6b"}, "originalPosition": 19}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjM5NDA4Mw==", "bodyText": "Can you also somewhere here provide the Thing type IDs?", "url": "https://github.com/openhab/openhab-addons/pull/7509#discussion_r436394083", "createdAt": "2020-06-07T19:29:07Z", "author": {"login": "kaikreuzer"}, "path": "bundles/org.openhab.binding.lcn/README.md", "diffHunk": "@@ -0,0 +1,597 @@\n+# LCN Binding\n+\n+[Local Control Network (LCN)](http://www.lcn.eu) is a building automation system for small and very large installations.\n+It is capable of controlling lights, shutters, access control etc. and can process data from several sensor types.\n+It has been introduced in 1992.\n+\n+A broad range of glass key panels, displays, remote controls, sensors and in- and outputs exist.  \n+The system can handle up to 30,000 bus members, called modules.\n+LCN modules are available for DIN rail and in-wall mounting and feature versatile interfaces. The bus modules and most of the accessories are developed, manufactured and assembled in Germany.\n+\n+Bus members are inter-connected via a free wire in the standard NYM cable. Wireless components are available, though.\n+\n+![Illustration of the LCN product family](doc/overview.jpg)\n+\n+This binding uses TCP/IP to access the LCN bus via the software LCN-PCHK (Windows/Linux) or the DIN rail device LCN-PKE.\n+**This means 1 unused LCN-PCHK license or a LCN-PKE is required**\n+\n+It is recommended to configure *Thing*s in [Paper UI](https://www.openhab.org/docs/configuration/paperui.html) and *Item*s in text files.\n+*Channel*s and *Link*s are configured automatically, then.\n+\n+## LCN Overview\n+\n+LCN modules and their connecting peripherals are explained in the following.\n+\n+### LCN Modules\n+\n+Active LCN components connected to the LCN bus are called *LCN modules*.\n+LCN modules are addressed by their numeric id: Valid range is 5..254\n+\n+In larger buildings, a second topologic layer is added: *segments*.\n+Valid range is 5..128 or 0 (= no segments exist) or 3 (= target all segments)\n+\n+LCN modules within the **same** segment can be grouped: Valid range is 5..254 or 3 (= target all groups)\n+\n+### LCN Firmware Versions\n+\n+Each LCN module has a feature-set based on its firmware version.\n+This version is written as follows: \\[year since 1990\\]\\[month\\]\\[day\\]\n+\n+Each component is written in hexadecimal with 2 characters. Examples:\n+\n+- 090101 = 1. january 1990\n+- 0D0C01 = 1. december 2003\n+- 170206 = 6. feb. 2013\n+\n+### LCN Dimmer Outputs\n+\n+LCN modules support 2 to 4 dimmer output ports (number depends on firmware version).\n+If the module hardware type doesn't feature physical dimmer outputs, the outputs can still be used as virtual.\n+\n+Status values are always in percent.\n+Modules since 170206 have a 0.5%-steps resolution. Older modules have a 2%-steps resolution.\n+\n+The time it takes the output port to reach its setpoint is called *ramp*.\n+\n+### LCN Variables\n+\n+LCN modules support:\n+\n+- 3 or 12 (since 170206) analog variables for general purpose\n+- 2 regulators with configurable setpoints\n+- 5 or 4x4 (since 170206) thresholds (trigger levels)\n+- 4 S0-input counters (since 170206, LCN-BU4L must be connected)\n+\n+### LCN Regulators (additions to variables)\n+\n+LCN modules have 2 regulators.\n+Each one has a setpoint and uses one variable as its value source.\n+A regulator can be locked, so that the target actuator keeps switched off, also if the value source is in control range.\n+\n+### LCN Thresholds\n+\n+LCN modules since firmware 170206 have 4 threshold registers. Each threshold register comprises 4 thresholds.\n+\n+A threshold register uses one variable as its value source (see [LCN Variables](#lcn-variables)).\n+Arbitrary LCN commands can be send into the bus, when the value-source falls below a threshold or exceeds one.\n+A threshold can be locked, so that the configured LCN command is not fired, also if the value source passes the threshold.\n+\n+### LCN Relays\n+\n+LCN modules support 8 relays. If no hardware relays are connected, the relays can still be used as virtual.\n+\n+### LCN Binary Sensors\n+\n+LCN modules support 8 binary sensors (e.g. motion detectors; hardware periphery must be connected).\n+  \n+### LCN LEDs (legacy name: *lamps*)\n+\n+12x multi-state variables can be used for logic operations or visualization (hardware periphery must be connected).\n+\n+Values: OFF, ON, BLINK, FLICKER\n+\n+### LCN Logic Operations (legacy name: *sums*)\n+\n+4x multi-state variables each representing the result of a logic operation of the associated LEDs.\n+\n+Values: NOT (all LEDs off), OR (some LEDs on), AND (all LEDs on)\n+\n+### LCN Keys\n+\n+LCN keys are data-points in the module with bound commands.\n+LCN modules support 3 (\"A-C\") or 4 (\"A-D\") key-tables (number depends on firmware version).\n+\n+Each key-table holds 8 keys. Examples: A1, A7, D8\n+\n+Each key has 3 command types: HIT(press), MAKE(long press), BREAK(long press release)\n+\n+These keys can be locked. The bound (LCN-)commands cannot be executed, then.\n+\n+### LCN Access Control & Remote Controls\n+\n+LCN can interface several transponder readers and finger print sensors, used for access control.\n+\n+Remote controls can not only be used for triggering commands, but also for access control, by evaluating the transmitted serial number.\n+\n+## Supported Things\n+\n+### Thing: LCN Module", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ce02f433e5d4071dbebb9ee68da0e22895887b6b"}, "originalPosition": 118}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjM5NDEzNw==", "bodyText": "Do not add any screenshots with Paper UI, this will be outdated very soon!", "url": "https://github.com/openhab/openhab-addons/pull/7509#discussion_r436394137", "createdAt": "2020-06-07T19:29:58Z", "author": {"login": "kaikreuzer"}, "path": "bundles/org.openhab.binding.lcn/README.md", "diffHunk": "@@ -0,0 +1,597 @@\n+# LCN Binding\n+\n+[Local Control Network (LCN)](http://www.lcn.eu) is a building automation system for small and very large installations.\n+It is capable of controlling lights, shutters, access control etc. and can process data from several sensor types.\n+It has been introduced in 1992.\n+\n+A broad range of glass key panels, displays, remote controls, sensors and in- and outputs exist.  \n+The system can handle up to 30,000 bus members, called modules.\n+LCN modules are available for DIN rail and in-wall mounting and feature versatile interfaces. The bus modules and most of the accessories are developed, manufactured and assembled in Germany.\n+\n+Bus members are inter-connected via a free wire in the standard NYM cable. Wireless components are available, though.\n+\n+![Illustration of the LCN product family](doc/overview.jpg)\n+\n+This binding uses TCP/IP to access the LCN bus via the software LCN-PCHK (Windows/Linux) or the DIN rail device LCN-PKE.\n+**This means 1 unused LCN-PCHK license or a LCN-PKE is required**\n+\n+It is recommended to configure *Thing*s in [Paper UI](https://www.openhab.org/docs/configuration/paperui.html) and *Item*s in text files.\n+*Channel*s and *Link*s are configured automatically, then.\n+\n+## LCN Overview\n+\n+LCN modules and their connecting peripherals are explained in the following.\n+\n+### LCN Modules\n+\n+Active LCN components connected to the LCN bus are called *LCN modules*.\n+LCN modules are addressed by their numeric id: Valid range is 5..254\n+\n+In larger buildings, a second topologic layer is added: *segments*.\n+Valid range is 5..128 or 0 (= no segments exist) or 3 (= target all segments)\n+\n+LCN modules within the **same** segment can be grouped: Valid range is 5..254 or 3 (= target all groups)\n+\n+### LCN Firmware Versions\n+\n+Each LCN module has a feature-set based on its firmware version.\n+This version is written as follows: \\[year since 1990\\]\\[month\\]\\[day\\]\n+\n+Each component is written in hexadecimal with 2 characters. Examples:\n+\n+- 090101 = 1. january 1990\n+- 0D0C01 = 1. december 2003\n+- 170206 = 6. feb. 2013\n+\n+### LCN Dimmer Outputs\n+\n+LCN modules support 2 to 4 dimmer output ports (number depends on firmware version).\n+If the module hardware type doesn't feature physical dimmer outputs, the outputs can still be used as virtual.\n+\n+Status values are always in percent.\n+Modules since 170206 have a 0.5%-steps resolution. Older modules have a 2%-steps resolution.\n+\n+The time it takes the output port to reach its setpoint is called *ramp*.\n+\n+### LCN Variables\n+\n+LCN modules support:\n+\n+- 3 or 12 (since 170206) analog variables for general purpose\n+- 2 regulators with configurable setpoints\n+- 5 or 4x4 (since 170206) thresholds (trigger levels)\n+- 4 S0-input counters (since 170206, LCN-BU4L must be connected)\n+\n+### LCN Regulators (additions to variables)\n+\n+LCN modules have 2 regulators.\n+Each one has a setpoint and uses one variable as its value source.\n+A regulator can be locked, so that the target actuator keeps switched off, also if the value source is in control range.\n+\n+### LCN Thresholds\n+\n+LCN modules since firmware 170206 have 4 threshold registers. Each threshold register comprises 4 thresholds.\n+\n+A threshold register uses one variable as its value source (see [LCN Variables](#lcn-variables)).\n+Arbitrary LCN commands can be send into the bus, when the value-source falls below a threshold or exceeds one.\n+A threshold can be locked, so that the configured LCN command is not fired, also if the value source passes the threshold.\n+\n+### LCN Relays\n+\n+LCN modules support 8 relays. If no hardware relays are connected, the relays can still be used as virtual.\n+\n+### LCN Binary Sensors\n+\n+LCN modules support 8 binary sensors (e.g. motion detectors; hardware periphery must be connected).\n+  \n+### LCN LEDs (legacy name: *lamps*)\n+\n+12x multi-state variables can be used for logic operations or visualization (hardware periphery must be connected).\n+\n+Values: OFF, ON, BLINK, FLICKER\n+\n+### LCN Logic Operations (legacy name: *sums*)\n+\n+4x multi-state variables each representing the result of a logic operation of the associated LEDs.\n+\n+Values: NOT (all LEDs off), OR (some LEDs on), AND (all LEDs on)\n+\n+### LCN Keys\n+\n+LCN keys are data-points in the module with bound commands.\n+LCN modules support 3 (\"A-C\") or 4 (\"A-D\") key-tables (number depends on firmware version).\n+\n+Each key-table holds 8 keys. Examples: A1, A7, D8\n+\n+Each key has 3 command types: HIT(press), MAKE(long press), BREAK(long press release)\n+\n+These keys can be locked. The bound (LCN-)commands cannot be executed, then.\n+\n+### LCN Access Control & Remote Controls\n+\n+LCN can interface several transponder readers and finger print sensors, used for access control.\n+\n+Remote controls can not only be used for triggering commands, but also for access control, by evaluating the transmitted serial number.\n+\n+## Supported Things\n+\n+### Thing: LCN Module\n+\n+Any LCN module that should be controlled or visualized, need to be added to openHAB as a *Thing*.\n+\n+LCN modules with firmware versions 120612 (2008) and 170602 (2013) were tested with this binding.\n+No known features/changes that need special handling were added until now (2020).\n+Modules with older and newer firmware should work, too.\n+The module hardware types (e.g. LCN-SH, LCN-HU, LCN-UPP, ...) are compatible to each other and can therefore be handled all in the same way.\n+\n+### Thing: LCN PCK Gateway\n+\n+PCK is the protocol spoken over TCP/IP with a PCK gateway to communicate with the LCN bus.\n+Examples for PCK gateways are the *LCN-PCHK* software running on Windows or Linux and the DIN rail mounting device *LCN-PKE*.\n+\n+For each LCN bus, interfaced to openHAB, a PCK gateway needs to be added to openHAB as a *Thing*.\n+\n+Several PCK gateways can be added to openHAB to control multiple LCN busses in distinct locations. \n+\n+The minimum recommended version is LCN-PCHK 2.8 (older versions will also work, but lack some functionality).\n+Visit [https://www.lcn.eu](https://www.lcn.eu) for updates.\n+\n+### Thing: LCN Group\n+\n+LCN modules can be assigned to groups with the programming software *LCN-PRO*.\n+\n+To send commands to an LCN group, the group needs to be added to openHAB as a *Thing*.\n+\n+One LCN module within the group is used to represent the status of the whole group.\n+For example, when a Dimmer Output is controlled via a LCN group *Thing*, openHAB will always visualize the state of the Dimmer Output of the chosen module. The states of the other modules in the group are ignored for visualization.\n+\n+## Discovery\n+\n+### Discover LCN Modules\n+\n+Basic data of LCN modules can be read out automatically by openHAB.\n+Click on one of the check marks to add the LCN modules to openHAB:\n+\n+![Paper UI screenshot, showing the discovery result for LCN modules](doc/module_discovery.png)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ce02f433e5d4071dbebb9ee68da0e22895887b6b"}, "originalPosition": 155}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjM5NDIwMw==", "bodyText": "Don't refer to special UI elements such a \"refresh button\". Try to formulate in an abstract way.", "url": "https://github.com/openhab/openhab-addons/pull/7509#discussion_r436394203", "createdAt": "2020-06-07T19:30:34Z", "author": {"login": "kaikreuzer"}, "path": "bundles/org.openhab.binding.lcn/README.md", "diffHunk": "@@ -0,0 +1,597 @@\n+# LCN Binding\n+\n+[Local Control Network (LCN)](http://www.lcn.eu) is a building automation system for small and very large installations.\n+It is capable of controlling lights, shutters, access control etc. and can process data from several sensor types.\n+It has been introduced in 1992.\n+\n+A broad range of glass key panels, displays, remote controls, sensors and in- and outputs exist.  \n+The system can handle up to 30,000 bus members, called modules.\n+LCN modules are available for DIN rail and in-wall mounting and feature versatile interfaces. The bus modules and most of the accessories are developed, manufactured and assembled in Germany.\n+\n+Bus members are inter-connected via a free wire in the standard NYM cable. Wireless components are available, though.\n+\n+![Illustration of the LCN product family](doc/overview.jpg)\n+\n+This binding uses TCP/IP to access the LCN bus via the software LCN-PCHK (Windows/Linux) or the DIN rail device LCN-PKE.\n+**This means 1 unused LCN-PCHK license or a LCN-PKE is required**\n+\n+It is recommended to configure *Thing*s in [Paper UI](https://www.openhab.org/docs/configuration/paperui.html) and *Item*s in text files.\n+*Channel*s and *Link*s are configured automatically, then.\n+\n+## LCN Overview\n+\n+LCN modules and their connecting peripherals are explained in the following.\n+\n+### LCN Modules\n+\n+Active LCN components connected to the LCN bus are called *LCN modules*.\n+LCN modules are addressed by their numeric id: Valid range is 5..254\n+\n+In larger buildings, a second topologic layer is added: *segments*.\n+Valid range is 5..128 or 0 (= no segments exist) or 3 (= target all segments)\n+\n+LCN modules within the **same** segment can be grouped: Valid range is 5..254 or 3 (= target all groups)\n+\n+### LCN Firmware Versions\n+\n+Each LCN module has a feature-set based on its firmware version.\n+This version is written as follows: \\[year since 1990\\]\\[month\\]\\[day\\]\n+\n+Each component is written in hexadecimal with 2 characters. Examples:\n+\n+- 090101 = 1. january 1990\n+- 0D0C01 = 1. december 2003\n+- 170206 = 6. feb. 2013\n+\n+### LCN Dimmer Outputs\n+\n+LCN modules support 2 to 4 dimmer output ports (number depends on firmware version).\n+If the module hardware type doesn't feature physical dimmer outputs, the outputs can still be used as virtual.\n+\n+Status values are always in percent.\n+Modules since 170206 have a 0.5%-steps resolution. Older modules have a 2%-steps resolution.\n+\n+The time it takes the output port to reach its setpoint is called *ramp*.\n+\n+### LCN Variables\n+\n+LCN modules support:\n+\n+- 3 or 12 (since 170206) analog variables for general purpose\n+- 2 regulators with configurable setpoints\n+- 5 or 4x4 (since 170206) thresholds (trigger levels)\n+- 4 S0-input counters (since 170206, LCN-BU4L must be connected)\n+\n+### LCN Regulators (additions to variables)\n+\n+LCN modules have 2 regulators.\n+Each one has a setpoint and uses one variable as its value source.\n+A regulator can be locked, so that the target actuator keeps switched off, also if the value source is in control range.\n+\n+### LCN Thresholds\n+\n+LCN modules since firmware 170206 have 4 threshold registers. Each threshold register comprises 4 thresholds.\n+\n+A threshold register uses one variable as its value source (see [LCN Variables](#lcn-variables)).\n+Arbitrary LCN commands can be send into the bus, when the value-source falls below a threshold or exceeds one.\n+A threshold can be locked, so that the configured LCN command is not fired, also if the value source passes the threshold.\n+\n+### LCN Relays\n+\n+LCN modules support 8 relays. If no hardware relays are connected, the relays can still be used as virtual.\n+\n+### LCN Binary Sensors\n+\n+LCN modules support 8 binary sensors (e.g. motion detectors; hardware periphery must be connected).\n+  \n+### LCN LEDs (legacy name: *lamps*)\n+\n+12x multi-state variables can be used for logic operations or visualization (hardware periphery must be connected).\n+\n+Values: OFF, ON, BLINK, FLICKER\n+\n+### LCN Logic Operations (legacy name: *sums*)\n+\n+4x multi-state variables each representing the result of a logic operation of the associated LEDs.\n+\n+Values: NOT (all LEDs off), OR (some LEDs on), AND (all LEDs on)\n+\n+### LCN Keys\n+\n+LCN keys are data-points in the module with bound commands.\n+LCN modules support 3 (\"A-C\") or 4 (\"A-D\") key-tables (number depends on firmware version).\n+\n+Each key-table holds 8 keys. Examples: A1, A7, D8\n+\n+Each key has 3 command types: HIT(press), MAKE(long press), BREAK(long press release)\n+\n+These keys can be locked. The bound (LCN-)commands cannot be executed, then.\n+\n+### LCN Access Control & Remote Controls\n+\n+LCN can interface several transponder readers and finger print sensors, used for access control.\n+\n+Remote controls can not only be used for triggering commands, but also for access control, by evaluating the transmitted serial number.\n+\n+## Supported Things\n+\n+### Thing: LCN Module\n+\n+Any LCN module that should be controlled or visualized, need to be added to openHAB as a *Thing*.\n+\n+LCN modules with firmware versions 120612 (2008) and 170602 (2013) were tested with this binding.\n+No known features/changes that need special handling were added until now (2020).\n+Modules with older and newer firmware should work, too.\n+The module hardware types (e.g. LCN-SH, LCN-HU, LCN-UPP, ...) are compatible to each other and can therefore be handled all in the same way.\n+\n+### Thing: LCN PCK Gateway\n+\n+PCK is the protocol spoken over TCP/IP with a PCK gateway to communicate with the LCN bus.\n+Examples for PCK gateways are the *LCN-PCHK* software running on Windows or Linux and the DIN rail mounting device *LCN-PKE*.\n+\n+For each LCN bus, interfaced to openHAB, a PCK gateway needs to be added to openHAB as a *Thing*.\n+\n+Several PCK gateways can be added to openHAB to control multiple LCN busses in distinct locations. \n+\n+The minimum recommended version is LCN-PCHK 2.8 (older versions will also work, but lack some functionality).\n+Visit [https://www.lcn.eu](https://www.lcn.eu) for updates.\n+\n+### Thing: LCN Group\n+\n+LCN modules can be assigned to groups with the programming software *LCN-PRO*.\n+\n+To send commands to an LCN group, the group needs to be added to openHAB as a *Thing*.\n+\n+One LCN module within the group is used to represent the status of the whole group.\n+For example, when a Dimmer Output is controlled via a LCN group *Thing*, openHAB will always visualize the state of the Dimmer Output of the chosen module. The states of the other modules in the group are ignored for visualization.\n+\n+## Discovery\n+\n+### Discover LCN Modules\n+\n+Basic data of LCN modules can be read out automatically by openHAB.\n+Click on one of the check marks to add the LCN modules to openHAB:\n+\n+![Paper UI screenshot, showing the discovery result for LCN modules](doc/module_discovery.png)\n+\n+If not all LCN modules get listed on the first run, click on the refresh button to start another scan.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ce02f433e5d4071dbebb9ee68da0e22895887b6b"}, "originalPosition": 157}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjM5NDMwNQ==", "bodyText": "remove", "url": "https://github.com/openhab/openhab-addons/pull/7509#discussion_r436394305", "createdAt": "2020-06-07T19:31:56Z", "author": {"login": "kaikreuzer"}, "path": "bundles/org.openhab.binding.lcn/README.md", "diffHunk": "@@ -0,0 +1,597 @@\n+# LCN Binding\n+\n+[Local Control Network (LCN)](http://www.lcn.eu) is a building automation system for small and very large installations.\n+It is capable of controlling lights, shutters, access control etc. and can process data from several sensor types.\n+It has been introduced in 1992.\n+\n+A broad range of glass key panels, displays, remote controls, sensors and in- and outputs exist.  \n+The system can handle up to 30,000 bus members, called modules.\n+LCN modules are available for DIN rail and in-wall mounting and feature versatile interfaces. The bus modules and most of the accessories are developed, manufactured and assembled in Germany.\n+\n+Bus members are inter-connected via a free wire in the standard NYM cable. Wireless components are available, though.\n+\n+![Illustration of the LCN product family](doc/overview.jpg)\n+\n+This binding uses TCP/IP to access the LCN bus via the software LCN-PCHK (Windows/Linux) or the DIN rail device LCN-PKE.\n+**This means 1 unused LCN-PCHK license or a LCN-PKE is required**\n+\n+It is recommended to configure *Thing*s in [Paper UI](https://www.openhab.org/docs/configuration/paperui.html) and *Item*s in text files.\n+*Channel*s and *Link*s are configured automatically, then.\n+\n+## LCN Overview\n+\n+LCN modules and their connecting peripherals are explained in the following.\n+\n+### LCN Modules\n+\n+Active LCN components connected to the LCN bus are called *LCN modules*.\n+LCN modules are addressed by their numeric id: Valid range is 5..254\n+\n+In larger buildings, a second topologic layer is added: *segments*.\n+Valid range is 5..128 or 0 (= no segments exist) or 3 (= target all segments)\n+\n+LCN modules within the **same** segment can be grouped: Valid range is 5..254 or 3 (= target all groups)\n+\n+### LCN Firmware Versions\n+\n+Each LCN module has a feature-set based on its firmware version.\n+This version is written as follows: \\[year since 1990\\]\\[month\\]\\[day\\]\n+\n+Each component is written in hexadecimal with 2 characters. Examples:\n+\n+- 090101 = 1. january 1990\n+- 0D0C01 = 1. december 2003\n+- 170206 = 6. feb. 2013\n+\n+### LCN Dimmer Outputs\n+\n+LCN modules support 2 to 4 dimmer output ports (number depends on firmware version).\n+If the module hardware type doesn't feature physical dimmer outputs, the outputs can still be used as virtual.\n+\n+Status values are always in percent.\n+Modules since 170206 have a 0.5%-steps resolution. Older modules have a 2%-steps resolution.\n+\n+The time it takes the output port to reach its setpoint is called *ramp*.\n+\n+### LCN Variables\n+\n+LCN modules support:\n+\n+- 3 or 12 (since 170206) analog variables for general purpose\n+- 2 regulators with configurable setpoints\n+- 5 or 4x4 (since 170206) thresholds (trigger levels)\n+- 4 S0-input counters (since 170206, LCN-BU4L must be connected)\n+\n+### LCN Regulators (additions to variables)\n+\n+LCN modules have 2 regulators.\n+Each one has a setpoint and uses one variable as its value source.\n+A regulator can be locked, so that the target actuator keeps switched off, also if the value source is in control range.\n+\n+### LCN Thresholds\n+\n+LCN modules since firmware 170206 have 4 threshold registers. Each threshold register comprises 4 thresholds.\n+\n+A threshold register uses one variable as its value source (see [LCN Variables](#lcn-variables)).\n+Arbitrary LCN commands can be send into the bus, when the value-source falls below a threshold or exceeds one.\n+A threshold can be locked, so that the configured LCN command is not fired, also if the value source passes the threshold.\n+\n+### LCN Relays\n+\n+LCN modules support 8 relays. If no hardware relays are connected, the relays can still be used as virtual.\n+\n+### LCN Binary Sensors\n+\n+LCN modules support 8 binary sensors (e.g. motion detectors; hardware periphery must be connected).\n+  \n+### LCN LEDs (legacy name: *lamps*)\n+\n+12x multi-state variables can be used for logic operations or visualization (hardware periphery must be connected).\n+\n+Values: OFF, ON, BLINK, FLICKER\n+\n+### LCN Logic Operations (legacy name: *sums*)\n+\n+4x multi-state variables each representing the result of a logic operation of the associated LEDs.\n+\n+Values: NOT (all LEDs off), OR (some LEDs on), AND (all LEDs on)\n+\n+### LCN Keys\n+\n+LCN keys are data-points in the module with bound commands.\n+LCN modules support 3 (\"A-C\") or 4 (\"A-D\") key-tables (number depends on firmware version).\n+\n+Each key-table holds 8 keys. Examples: A1, A7, D8\n+\n+Each key has 3 command types: HIT(press), MAKE(long press), BREAK(long press release)\n+\n+These keys can be locked. The bound (LCN-)commands cannot be executed, then.\n+\n+### LCN Access Control & Remote Controls\n+\n+LCN can interface several transponder readers and finger print sensors, used for access control.\n+\n+Remote controls can not only be used for triggering commands, but also for access control, by evaluating the transmitted serial number.\n+\n+## Supported Things\n+\n+### Thing: LCN Module\n+\n+Any LCN module that should be controlled or visualized, need to be added to openHAB as a *Thing*.\n+\n+LCN modules with firmware versions 120612 (2008) and 170602 (2013) were tested with this binding.\n+No known features/changes that need special handling were added until now (2020).\n+Modules with older and newer firmware should work, too.\n+The module hardware types (e.g. LCN-SH, LCN-HU, LCN-UPP, ...) are compatible to each other and can therefore be handled all in the same way.\n+\n+### Thing: LCN PCK Gateway\n+\n+PCK is the protocol spoken over TCP/IP with a PCK gateway to communicate with the LCN bus.\n+Examples for PCK gateways are the *LCN-PCHK* software running on Windows or Linux and the DIN rail mounting device *LCN-PKE*.\n+\n+For each LCN bus, interfaced to openHAB, a PCK gateway needs to be added to openHAB as a *Thing*.\n+\n+Several PCK gateways can be added to openHAB to control multiple LCN busses in distinct locations. \n+\n+The minimum recommended version is LCN-PCHK 2.8 (older versions will also work, but lack some functionality).\n+Visit [https://www.lcn.eu](https://www.lcn.eu) for updates.\n+\n+### Thing: LCN Group\n+\n+LCN modules can be assigned to groups with the programming software *LCN-PRO*.\n+\n+To send commands to an LCN group, the group needs to be added to openHAB as a *Thing*.\n+\n+One LCN module within the group is used to represent the status of the whole group.\n+For example, when a Dimmer Output is controlled via a LCN group *Thing*, openHAB will always visualize the state of the Dimmer Output of the chosen module. The states of the other modules in the group are ignored for visualization.\n+\n+## Discovery\n+\n+### Discover LCN Modules\n+\n+Basic data of LCN modules can be read out automatically by openHAB.\n+Click on one of the check marks to add the LCN modules to openHAB:\n+\n+![Paper UI screenshot, showing the discovery result for LCN modules](doc/module_discovery.png)\n+\n+If not all LCN modules get listed on the first run, click on the refresh button to start another scan.\n+\n+When adding a module by discovery, the new *Thing*'s UID will be the module's serial number.\n+\n+### Discover PCK Gateways\n+\n+PCK gateways in the LAN can be found automatically by openHAB. This is done by UDP multicast messages on port 4220.\n+The discovery works only if the firewall of the PCK gateway is not configured too strictly.\n+This means on Windows PCs, that the network must be configured as 'private' and not as 'public'.\n+Also, some network switches may block multicast packets.\n+Unfortunately, *LCN-PCHK* listens only on the first network interface of the computer for discovery packets.\n+If your PCK gateway has multiple network interfaces, *LCN-PCHK* may listen on the wrong interface and fails to respond to the discovery request.\n+\n+Discovery has successfully been tested with LCN-PCHK 3.2.2 running on a Raspberry Pi with Raspbian and openHAB running on Windows 10.\n+See the following screenshot:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ce02f433e5d4071dbebb9ee68da0e22895887b6b"}, "originalPosition": 171}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjM5NDM3MQ==", "bodyText": "remove", "url": "https://github.com/openhab/openhab-addons/pull/7509#discussion_r436394371", "createdAt": "2020-06-07T19:32:36Z", "author": {"login": "kaikreuzer"}, "path": "bundles/org.openhab.binding.lcn/README.md", "diffHunk": "@@ -0,0 +1,597 @@\n+# LCN Binding\n+\n+[Local Control Network (LCN)](http://www.lcn.eu) is a building automation system for small and very large installations.\n+It is capable of controlling lights, shutters, access control etc. and can process data from several sensor types.\n+It has been introduced in 1992.\n+\n+A broad range of glass key panels, displays, remote controls, sensors and in- and outputs exist.  \n+The system can handle up to 30,000 bus members, called modules.\n+LCN modules are available for DIN rail and in-wall mounting and feature versatile interfaces. The bus modules and most of the accessories are developed, manufactured and assembled in Germany.\n+\n+Bus members are inter-connected via a free wire in the standard NYM cable. Wireless components are available, though.\n+\n+![Illustration of the LCN product family](doc/overview.jpg)\n+\n+This binding uses TCP/IP to access the LCN bus via the software LCN-PCHK (Windows/Linux) or the DIN rail device LCN-PKE.\n+**This means 1 unused LCN-PCHK license or a LCN-PKE is required**\n+\n+It is recommended to configure *Thing*s in [Paper UI](https://www.openhab.org/docs/configuration/paperui.html) and *Item*s in text files.\n+*Channel*s and *Link*s are configured automatically, then.\n+\n+## LCN Overview\n+\n+LCN modules and their connecting peripherals are explained in the following.\n+\n+### LCN Modules\n+\n+Active LCN components connected to the LCN bus are called *LCN modules*.\n+LCN modules are addressed by their numeric id: Valid range is 5..254\n+\n+In larger buildings, a second topologic layer is added: *segments*.\n+Valid range is 5..128 or 0 (= no segments exist) or 3 (= target all segments)\n+\n+LCN modules within the **same** segment can be grouped: Valid range is 5..254 or 3 (= target all groups)\n+\n+### LCN Firmware Versions\n+\n+Each LCN module has a feature-set based on its firmware version.\n+This version is written as follows: \\[year since 1990\\]\\[month\\]\\[day\\]\n+\n+Each component is written in hexadecimal with 2 characters. Examples:\n+\n+- 090101 = 1. january 1990\n+- 0D0C01 = 1. december 2003\n+- 170206 = 6. feb. 2013\n+\n+### LCN Dimmer Outputs\n+\n+LCN modules support 2 to 4 dimmer output ports (number depends on firmware version).\n+If the module hardware type doesn't feature physical dimmer outputs, the outputs can still be used as virtual.\n+\n+Status values are always in percent.\n+Modules since 170206 have a 0.5%-steps resolution. Older modules have a 2%-steps resolution.\n+\n+The time it takes the output port to reach its setpoint is called *ramp*.\n+\n+### LCN Variables\n+\n+LCN modules support:\n+\n+- 3 or 12 (since 170206) analog variables for general purpose\n+- 2 regulators with configurable setpoints\n+- 5 or 4x4 (since 170206) thresholds (trigger levels)\n+- 4 S0-input counters (since 170206, LCN-BU4L must be connected)\n+\n+### LCN Regulators (additions to variables)\n+\n+LCN modules have 2 regulators.\n+Each one has a setpoint and uses one variable as its value source.\n+A regulator can be locked, so that the target actuator keeps switched off, also if the value source is in control range.\n+\n+### LCN Thresholds\n+\n+LCN modules since firmware 170206 have 4 threshold registers. Each threshold register comprises 4 thresholds.\n+\n+A threshold register uses one variable as its value source (see [LCN Variables](#lcn-variables)).\n+Arbitrary LCN commands can be send into the bus, when the value-source falls below a threshold or exceeds one.\n+A threshold can be locked, so that the configured LCN command is not fired, also if the value source passes the threshold.\n+\n+### LCN Relays\n+\n+LCN modules support 8 relays. If no hardware relays are connected, the relays can still be used as virtual.\n+\n+### LCN Binary Sensors\n+\n+LCN modules support 8 binary sensors (e.g. motion detectors; hardware periphery must be connected).\n+  \n+### LCN LEDs (legacy name: *lamps*)\n+\n+12x multi-state variables can be used for logic operations or visualization (hardware periphery must be connected).\n+\n+Values: OFF, ON, BLINK, FLICKER\n+\n+### LCN Logic Operations (legacy name: *sums*)\n+\n+4x multi-state variables each representing the result of a logic operation of the associated LEDs.\n+\n+Values: NOT (all LEDs off), OR (some LEDs on), AND (all LEDs on)\n+\n+### LCN Keys\n+\n+LCN keys are data-points in the module with bound commands.\n+LCN modules support 3 (\"A-C\") or 4 (\"A-D\") key-tables (number depends on firmware version).\n+\n+Each key-table holds 8 keys. Examples: A1, A7, D8\n+\n+Each key has 3 command types: HIT(press), MAKE(long press), BREAK(long press release)\n+\n+These keys can be locked. The bound (LCN-)commands cannot be executed, then.\n+\n+### LCN Access Control & Remote Controls\n+\n+LCN can interface several transponder readers and finger print sensors, used for access control.\n+\n+Remote controls can not only be used for triggering commands, but also for access control, by evaluating the transmitted serial number.\n+\n+## Supported Things\n+\n+### Thing: LCN Module\n+\n+Any LCN module that should be controlled or visualized, need to be added to openHAB as a *Thing*.\n+\n+LCN modules with firmware versions 120612 (2008) and 170602 (2013) were tested with this binding.\n+No known features/changes that need special handling were added until now (2020).\n+Modules with older and newer firmware should work, too.\n+The module hardware types (e.g. LCN-SH, LCN-HU, LCN-UPP, ...) are compatible to each other and can therefore be handled all in the same way.\n+\n+### Thing: LCN PCK Gateway\n+\n+PCK is the protocol spoken over TCP/IP with a PCK gateway to communicate with the LCN bus.\n+Examples for PCK gateways are the *LCN-PCHK* software running on Windows or Linux and the DIN rail mounting device *LCN-PKE*.\n+\n+For each LCN bus, interfaced to openHAB, a PCK gateway needs to be added to openHAB as a *Thing*.\n+\n+Several PCK gateways can be added to openHAB to control multiple LCN busses in distinct locations. \n+\n+The minimum recommended version is LCN-PCHK 2.8 (older versions will also work, but lack some functionality).\n+Visit [https://www.lcn.eu](https://www.lcn.eu) for updates.\n+\n+### Thing: LCN Group\n+\n+LCN modules can be assigned to groups with the programming software *LCN-PRO*.\n+\n+To send commands to an LCN group, the group needs to be added to openHAB as a *Thing*.\n+\n+One LCN module within the group is used to represent the status of the whole group.\n+For example, when a Dimmer Output is controlled via a LCN group *Thing*, openHAB will always visualize the state of the Dimmer Output of the chosen module. The states of the other modules in the group are ignored for visualization.\n+\n+## Discovery\n+\n+### Discover LCN Modules\n+\n+Basic data of LCN modules can be read out automatically by openHAB.\n+Click on one of the check marks to add the LCN modules to openHAB:\n+\n+![Paper UI screenshot, showing the discovery result for LCN modules](doc/module_discovery.png)\n+\n+If not all LCN modules get listed on the first run, click on the refresh button to start another scan.\n+\n+When adding a module by discovery, the new *Thing*'s UID will be the module's serial number.\n+\n+### Discover PCK Gateways\n+\n+PCK gateways in the LAN can be found automatically by openHAB. This is done by UDP multicast messages on port 4220.\n+The discovery works only if the firewall of the PCK gateway is not configured too strictly.\n+This means on Windows PCs, that the network must be configured as 'private' and not as 'public'.\n+Also, some network switches may block multicast packets.\n+Unfortunately, *LCN-PCHK* listens only on the first network interface of the computer for discovery packets.\n+If your PCK gateway has multiple network interfaces, *LCN-PCHK* may listen on the wrong interface and fails to respond to the discovery request.\n+\n+Discovery has successfully been tested with LCN-PCHK 3.2.2 running on a Raspberry Pi with Raspbian and openHAB running on Windows 10.\n+See the following screenshot:\n+\n+![Paper UI screenshot, showing the discovery result for PCK gateways](doc/pck_discovery.png)\n+\n+If discovery fails, you can add a PCK gateway manually. See [Thing: PCK Gateway](#thing-lcn-pck-gateway).\n+\n+Please be aware that you **have to configure** username, password and the dimmer output resolution also if you use discovery.\n+See [Thing: PCK Gateway](#thing-lcn-pck-gateway).\n+\n+When adding a PCK gateway by discovery, the new *Thing*'s UID is the MAC address of the device, running the PCK gateway.\n+\n+## Thing Configuration\n+\n+### Configure LCN-PCHK/-PKE Connection\n+\n+Click on the plus symbol under Configuration/Things in Paper UI. Select \"Add manually\".", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ce02f433e5d4071dbebb9ee68da0e22895887b6b"}, "originalPosition": 186}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjM5NDQ2NA==", "bodyText": "Please check the readme of other bindings here: Common practice is to provide a table that lists the parameters with a description, a flag if they are mandatory and their type.", "url": "https://github.com/openhab/openhab-addons/pull/7509#discussion_r436394464", "createdAt": "2020-06-07T19:33:38Z", "author": {"login": "kaikreuzer"}, "path": "bundles/org.openhab.binding.lcn/README.md", "diffHunk": "@@ -0,0 +1,597 @@\n+# LCN Binding\n+\n+[Local Control Network (LCN)](http://www.lcn.eu) is a building automation system for small and very large installations.\n+It is capable of controlling lights, shutters, access control etc. and can process data from several sensor types.\n+It has been introduced in 1992.\n+\n+A broad range of glass key panels, displays, remote controls, sensors and in- and outputs exist.  \n+The system can handle up to 30,000 bus members, called modules.\n+LCN modules are available for DIN rail and in-wall mounting and feature versatile interfaces. The bus modules and most of the accessories are developed, manufactured and assembled in Germany.\n+\n+Bus members are inter-connected via a free wire in the standard NYM cable. Wireless components are available, though.\n+\n+![Illustration of the LCN product family](doc/overview.jpg)\n+\n+This binding uses TCP/IP to access the LCN bus via the software LCN-PCHK (Windows/Linux) or the DIN rail device LCN-PKE.\n+**This means 1 unused LCN-PCHK license or a LCN-PKE is required**\n+\n+It is recommended to configure *Thing*s in [Paper UI](https://www.openhab.org/docs/configuration/paperui.html) and *Item*s in text files.\n+*Channel*s and *Link*s are configured automatically, then.\n+\n+## LCN Overview\n+\n+LCN modules and their connecting peripherals are explained in the following.\n+\n+### LCN Modules\n+\n+Active LCN components connected to the LCN bus are called *LCN modules*.\n+LCN modules are addressed by their numeric id: Valid range is 5..254\n+\n+In larger buildings, a second topologic layer is added: *segments*.\n+Valid range is 5..128 or 0 (= no segments exist) or 3 (= target all segments)\n+\n+LCN modules within the **same** segment can be grouped: Valid range is 5..254 or 3 (= target all groups)\n+\n+### LCN Firmware Versions\n+\n+Each LCN module has a feature-set based on its firmware version.\n+This version is written as follows: \\[year since 1990\\]\\[month\\]\\[day\\]\n+\n+Each component is written in hexadecimal with 2 characters. Examples:\n+\n+- 090101 = 1. january 1990\n+- 0D0C01 = 1. december 2003\n+- 170206 = 6. feb. 2013\n+\n+### LCN Dimmer Outputs\n+\n+LCN modules support 2 to 4 dimmer output ports (number depends on firmware version).\n+If the module hardware type doesn't feature physical dimmer outputs, the outputs can still be used as virtual.\n+\n+Status values are always in percent.\n+Modules since 170206 have a 0.5%-steps resolution. Older modules have a 2%-steps resolution.\n+\n+The time it takes the output port to reach its setpoint is called *ramp*.\n+\n+### LCN Variables\n+\n+LCN modules support:\n+\n+- 3 or 12 (since 170206) analog variables for general purpose\n+- 2 regulators with configurable setpoints\n+- 5 or 4x4 (since 170206) thresholds (trigger levels)\n+- 4 S0-input counters (since 170206, LCN-BU4L must be connected)\n+\n+### LCN Regulators (additions to variables)\n+\n+LCN modules have 2 regulators.\n+Each one has a setpoint and uses one variable as its value source.\n+A regulator can be locked, so that the target actuator keeps switched off, also if the value source is in control range.\n+\n+### LCN Thresholds\n+\n+LCN modules since firmware 170206 have 4 threshold registers. Each threshold register comprises 4 thresholds.\n+\n+A threshold register uses one variable as its value source (see [LCN Variables](#lcn-variables)).\n+Arbitrary LCN commands can be send into the bus, when the value-source falls below a threshold or exceeds one.\n+A threshold can be locked, so that the configured LCN command is not fired, also if the value source passes the threshold.\n+\n+### LCN Relays\n+\n+LCN modules support 8 relays. If no hardware relays are connected, the relays can still be used as virtual.\n+\n+### LCN Binary Sensors\n+\n+LCN modules support 8 binary sensors (e.g. motion detectors; hardware periphery must be connected).\n+  \n+### LCN LEDs (legacy name: *lamps*)\n+\n+12x multi-state variables can be used for logic operations or visualization (hardware periphery must be connected).\n+\n+Values: OFF, ON, BLINK, FLICKER\n+\n+### LCN Logic Operations (legacy name: *sums*)\n+\n+4x multi-state variables each representing the result of a logic operation of the associated LEDs.\n+\n+Values: NOT (all LEDs off), OR (some LEDs on), AND (all LEDs on)\n+\n+### LCN Keys\n+\n+LCN keys are data-points in the module with bound commands.\n+LCN modules support 3 (\"A-C\") or 4 (\"A-D\") key-tables (number depends on firmware version).\n+\n+Each key-table holds 8 keys. Examples: A1, A7, D8\n+\n+Each key has 3 command types: HIT(press), MAKE(long press), BREAK(long press release)\n+\n+These keys can be locked. The bound (LCN-)commands cannot be executed, then.\n+\n+### LCN Access Control & Remote Controls\n+\n+LCN can interface several transponder readers and finger print sensors, used for access control.\n+\n+Remote controls can not only be used for triggering commands, but also for access control, by evaluating the transmitted serial number.\n+\n+## Supported Things\n+\n+### Thing: LCN Module\n+\n+Any LCN module that should be controlled or visualized, need to be added to openHAB as a *Thing*.\n+\n+LCN modules with firmware versions 120612 (2008) and 170602 (2013) were tested with this binding.\n+No known features/changes that need special handling were added until now (2020).\n+Modules with older and newer firmware should work, too.\n+The module hardware types (e.g. LCN-SH, LCN-HU, LCN-UPP, ...) are compatible to each other and can therefore be handled all in the same way.\n+\n+### Thing: LCN PCK Gateway\n+\n+PCK is the protocol spoken over TCP/IP with a PCK gateway to communicate with the LCN bus.\n+Examples for PCK gateways are the *LCN-PCHK* software running on Windows or Linux and the DIN rail mounting device *LCN-PKE*.\n+\n+For each LCN bus, interfaced to openHAB, a PCK gateway needs to be added to openHAB as a *Thing*.\n+\n+Several PCK gateways can be added to openHAB to control multiple LCN busses in distinct locations. \n+\n+The minimum recommended version is LCN-PCHK 2.8 (older versions will also work, but lack some functionality).\n+Visit [https://www.lcn.eu](https://www.lcn.eu) for updates.\n+\n+### Thing: LCN Group\n+\n+LCN modules can be assigned to groups with the programming software *LCN-PRO*.\n+\n+To send commands to an LCN group, the group needs to be added to openHAB as a *Thing*.\n+\n+One LCN module within the group is used to represent the status of the whole group.\n+For example, when a Dimmer Output is controlled via a LCN group *Thing*, openHAB will always visualize the state of the Dimmer Output of the chosen module. The states of the other modules in the group are ignored for visualization.\n+\n+## Discovery\n+\n+### Discover LCN Modules\n+\n+Basic data of LCN modules can be read out automatically by openHAB.\n+Click on one of the check marks to add the LCN modules to openHAB:\n+\n+![Paper UI screenshot, showing the discovery result for LCN modules](doc/module_discovery.png)\n+\n+If not all LCN modules get listed on the first run, click on the refresh button to start another scan.\n+\n+When adding a module by discovery, the new *Thing*'s UID will be the module's serial number.\n+\n+### Discover PCK Gateways\n+\n+PCK gateways in the LAN can be found automatically by openHAB. This is done by UDP multicast messages on port 4220.\n+The discovery works only if the firewall of the PCK gateway is not configured too strictly.\n+This means on Windows PCs, that the network must be configured as 'private' and not as 'public'.\n+Also, some network switches may block multicast packets.\n+Unfortunately, *LCN-PCHK* listens only on the first network interface of the computer for discovery packets.\n+If your PCK gateway has multiple network interfaces, *LCN-PCHK* may listen on the wrong interface and fails to respond to the discovery request.\n+\n+Discovery has successfully been tested with LCN-PCHK 3.2.2 running on a Raspberry Pi with Raspbian and openHAB running on Windows 10.\n+See the following screenshot:\n+\n+![Paper UI screenshot, showing the discovery result for PCK gateways](doc/pck_discovery.png)\n+\n+If discovery fails, you can add a PCK gateway manually. See [Thing: PCK Gateway](#thing-lcn-pck-gateway).\n+\n+Please be aware that you **have to configure** username, password and the dimmer output resolution also if you use discovery.\n+See [Thing: PCK Gateway](#thing-lcn-pck-gateway).\n+\n+When adding a PCK gateway by discovery, the new *Thing*'s UID is the MAC address of the device, running the PCK gateway.\n+\n+## Thing Configuration\n+\n+### Configure LCN-PCHK/-PKE Connection\n+\n+Click on the plus symbol under Configuration/Things in Paper UI. Select \"Add manually\".\n+When adding a PCK gateway manually, the *hostname/IP address*, *port* and *username* and *password* need to be configured.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ce02f433e5d4071dbebb9ee68da0e22895887b6b"}, "originalPosition": 187}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjM5NDYwMQ==", "bodyText": "It might make sense to merge the \"Thing configuration\" with the \"supported things\" section above, since you require a sub-section for each thing type anyhow.", "url": "https://github.com/openhab/openhab-addons/pull/7509#discussion_r436394601", "createdAt": "2020-06-07T19:35:19Z", "author": {"login": "kaikreuzer"}, "path": "bundles/org.openhab.binding.lcn/README.md", "diffHunk": "@@ -0,0 +1,597 @@\n+# LCN Binding\n+\n+[Local Control Network (LCN)](http://www.lcn.eu) is a building automation system for small and very large installations.\n+It is capable of controlling lights, shutters, access control etc. and can process data from several sensor types.\n+It has been introduced in 1992.\n+\n+A broad range of glass key panels, displays, remote controls, sensors and in- and outputs exist.  \n+The system can handle up to 30,000 bus members, called modules.\n+LCN modules are available for DIN rail and in-wall mounting and feature versatile interfaces. The bus modules and most of the accessories are developed, manufactured and assembled in Germany.\n+\n+Bus members are inter-connected via a free wire in the standard NYM cable. Wireless components are available, though.\n+\n+![Illustration of the LCN product family](doc/overview.jpg)\n+\n+This binding uses TCP/IP to access the LCN bus via the software LCN-PCHK (Windows/Linux) or the DIN rail device LCN-PKE.\n+**This means 1 unused LCN-PCHK license or a LCN-PKE is required**\n+\n+It is recommended to configure *Thing*s in [Paper UI](https://www.openhab.org/docs/configuration/paperui.html) and *Item*s in text files.\n+*Channel*s and *Link*s are configured automatically, then.\n+\n+## LCN Overview\n+\n+LCN modules and their connecting peripherals are explained in the following.\n+\n+### LCN Modules\n+\n+Active LCN components connected to the LCN bus are called *LCN modules*.\n+LCN modules are addressed by their numeric id: Valid range is 5..254\n+\n+In larger buildings, a second topologic layer is added: *segments*.\n+Valid range is 5..128 or 0 (= no segments exist) or 3 (= target all segments)\n+\n+LCN modules within the **same** segment can be grouped: Valid range is 5..254 or 3 (= target all groups)\n+\n+### LCN Firmware Versions\n+\n+Each LCN module has a feature-set based on its firmware version.\n+This version is written as follows: \\[year since 1990\\]\\[month\\]\\[day\\]\n+\n+Each component is written in hexadecimal with 2 characters. Examples:\n+\n+- 090101 = 1. january 1990\n+- 0D0C01 = 1. december 2003\n+- 170206 = 6. feb. 2013\n+\n+### LCN Dimmer Outputs\n+\n+LCN modules support 2 to 4 dimmer output ports (number depends on firmware version).\n+If the module hardware type doesn't feature physical dimmer outputs, the outputs can still be used as virtual.\n+\n+Status values are always in percent.\n+Modules since 170206 have a 0.5%-steps resolution. Older modules have a 2%-steps resolution.\n+\n+The time it takes the output port to reach its setpoint is called *ramp*.\n+\n+### LCN Variables\n+\n+LCN modules support:\n+\n+- 3 or 12 (since 170206) analog variables for general purpose\n+- 2 regulators with configurable setpoints\n+- 5 or 4x4 (since 170206) thresholds (trigger levels)\n+- 4 S0-input counters (since 170206, LCN-BU4L must be connected)\n+\n+### LCN Regulators (additions to variables)\n+\n+LCN modules have 2 regulators.\n+Each one has a setpoint and uses one variable as its value source.\n+A regulator can be locked, so that the target actuator keeps switched off, also if the value source is in control range.\n+\n+### LCN Thresholds\n+\n+LCN modules since firmware 170206 have 4 threshold registers. Each threshold register comprises 4 thresholds.\n+\n+A threshold register uses one variable as its value source (see [LCN Variables](#lcn-variables)).\n+Arbitrary LCN commands can be send into the bus, when the value-source falls below a threshold or exceeds one.\n+A threshold can be locked, so that the configured LCN command is not fired, also if the value source passes the threshold.\n+\n+### LCN Relays\n+\n+LCN modules support 8 relays. If no hardware relays are connected, the relays can still be used as virtual.\n+\n+### LCN Binary Sensors\n+\n+LCN modules support 8 binary sensors (e.g. motion detectors; hardware periphery must be connected).\n+  \n+### LCN LEDs (legacy name: *lamps*)\n+\n+12x multi-state variables can be used for logic operations or visualization (hardware periphery must be connected).\n+\n+Values: OFF, ON, BLINK, FLICKER\n+\n+### LCN Logic Operations (legacy name: *sums*)\n+\n+4x multi-state variables each representing the result of a logic operation of the associated LEDs.\n+\n+Values: NOT (all LEDs off), OR (some LEDs on), AND (all LEDs on)\n+\n+### LCN Keys\n+\n+LCN keys are data-points in the module with bound commands.\n+LCN modules support 3 (\"A-C\") or 4 (\"A-D\") key-tables (number depends on firmware version).\n+\n+Each key-table holds 8 keys. Examples: A1, A7, D8\n+\n+Each key has 3 command types: HIT(press), MAKE(long press), BREAK(long press release)\n+\n+These keys can be locked. The bound (LCN-)commands cannot be executed, then.\n+\n+### LCN Access Control & Remote Controls\n+\n+LCN can interface several transponder readers and finger print sensors, used for access control.\n+\n+Remote controls can not only be used for triggering commands, but also for access control, by evaluating the transmitted serial number.\n+\n+## Supported Things\n+\n+### Thing: LCN Module\n+\n+Any LCN module that should be controlled or visualized, need to be added to openHAB as a *Thing*.\n+\n+LCN modules with firmware versions 120612 (2008) and 170602 (2013) were tested with this binding.\n+No known features/changes that need special handling were added until now (2020).\n+Modules with older and newer firmware should work, too.\n+The module hardware types (e.g. LCN-SH, LCN-HU, LCN-UPP, ...) are compatible to each other and can therefore be handled all in the same way.\n+\n+### Thing: LCN PCK Gateway\n+\n+PCK is the protocol spoken over TCP/IP with a PCK gateway to communicate with the LCN bus.\n+Examples for PCK gateways are the *LCN-PCHK* software running on Windows or Linux and the DIN rail mounting device *LCN-PKE*.\n+\n+For each LCN bus, interfaced to openHAB, a PCK gateway needs to be added to openHAB as a *Thing*.\n+\n+Several PCK gateways can be added to openHAB to control multiple LCN busses in distinct locations. \n+\n+The minimum recommended version is LCN-PCHK 2.8 (older versions will also work, but lack some functionality).\n+Visit [https://www.lcn.eu](https://www.lcn.eu) for updates.\n+\n+### Thing: LCN Group\n+\n+LCN modules can be assigned to groups with the programming software *LCN-PRO*.\n+\n+To send commands to an LCN group, the group needs to be added to openHAB as a *Thing*.\n+\n+One LCN module within the group is used to represent the status of the whole group.\n+For example, when a Dimmer Output is controlled via a LCN group *Thing*, openHAB will always visualize the state of the Dimmer Output of the chosen module. The states of the other modules in the group are ignored for visualization.\n+\n+## Discovery\n+\n+### Discover LCN Modules\n+\n+Basic data of LCN modules can be read out automatically by openHAB.\n+Click on one of the check marks to add the LCN modules to openHAB:\n+\n+![Paper UI screenshot, showing the discovery result for LCN modules](doc/module_discovery.png)\n+\n+If not all LCN modules get listed on the first run, click on the refresh button to start another scan.\n+\n+When adding a module by discovery, the new *Thing*'s UID will be the module's serial number.\n+\n+### Discover PCK Gateways\n+\n+PCK gateways in the LAN can be found automatically by openHAB. This is done by UDP multicast messages on port 4220.\n+The discovery works only if the firewall of the PCK gateway is not configured too strictly.\n+This means on Windows PCs, that the network must be configured as 'private' and not as 'public'.\n+Also, some network switches may block multicast packets.\n+Unfortunately, *LCN-PCHK* listens only on the first network interface of the computer for discovery packets.\n+If your PCK gateway has multiple network interfaces, *LCN-PCHK* may listen on the wrong interface and fails to respond to the discovery request.\n+\n+Discovery has successfully been tested with LCN-PCHK 3.2.2 running on a Raspberry Pi with Raspbian and openHAB running on Windows 10.\n+See the following screenshot:\n+\n+![Paper UI screenshot, showing the discovery result for PCK gateways](doc/pck_discovery.png)\n+\n+If discovery fails, you can add a PCK gateway manually. See [Thing: PCK Gateway](#thing-lcn-pck-gateway).\n+\n+Please be aware that you **have to configure** username, password and the dimmer output resolution also if you use discovery.\n+See [Thing: PCK Gateway](#thing-lcn-pck-gateway).\n+\n+When adding a PCK gateway by discovery, the new *Thing*'s UID is the MAC address of the device, running the PCK gateway.\n+\n+## Thing Configuration\n+\n+### Configure LCN-PCHK/-PKE Connection", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ce02f433e5d4071dbebb9ee68da0e22895887b6b"}, "originalPosition": 184}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjM5NDg2OQ==", "bodyText": "Could you mention here, which channels (all?) are available on which Thing types (modules/groups/etc)?", "url": "https://github.com/openhab/openhab-addons/pull/7509#discussion_r436394869", "createdAt": "2020-06-07T19:37:33Z", "author": {"login": "kaikreuzer"}, "path": "bundles/org.openhab.binding.lcn/README.md", "diffHunk": "@@ -0,0 +1,597 @@\n+# LCN Binding\n+\n+[Local Control Network (LCN)](http://www.lcn.eu) is a building automation system for small and very large installations.\n+It is capable of controlling lights, shutters, access control etc. and can process data from several sensor types.\n+It has been introduced in 1992.\n+\n+A broad range of glass key panels, displays, remote controls, sensors and in- and outputs exist.  \n+The system can handle up to 30,000 bus members, called modules.\n+LCN modules are available for DIN rail and in-wall mounting and feature versatile interfaces. The bus modules and most of the accessories are developed, manufactured and assembled in Germany.\n+\n+Bus members are inter-connected via a free wire in the standard NYM cable. Wireless components are available, though.\n+\n+![Illustration of the LCN product family](doc/overview.jpg)\n+\n+This binding uses TCP/IP to access the LCN bus via the software LCN-PCHK (Windows/Linux) or the DIN rail device LCN-PKE.\n+**This means 1 unused LCN-PCHK license or a LCN-PKE is required**\n+\n+It is recommended to configure *Thing*s in [Paper UI](https://www.openhab.org/docs/configuration/paperui.html) and *Item*s in text files.\n+*Channel*s and *Link*s are configured automatically, then.\n+\n+## LCN Overview\n+\n+LCN modules and their connecting peripherals are explained in the following.\n+\n+### LCN Modules\n+\n+Active LCN components connected to the LCN bus are called *LCN modules*.\n+LCN modules are addressed by their numeric id: Valid range is 5..254\n+\n+In larger buildings, a second topologic layer is added: *segments*.\n+Valid range is 5..128 or 0 (= no segments exist) or 3 (= target all segments)\n+\n+LCN modules within the **same** segment can be grouped: Valid range is 5..254 or 3 (= target all groups)\n+\n+### LCN Firmware Versions\n+\n+Each LCN module has a feature-set based on its firmware version.\n+This version is written as follows: \\[year since 1990\\]\\[month\\]\\[day\\]\n+\n+Each component is written in hexadecimal with 2 characters. Examples:\n+\n+- 090101 = 1. january 1990\n+- 0D0C01 = 1. december 2003\n+- 170206 = 6. feb. 2013\n+\n+### LCN Dimmer Outputs\n+\n+LCN modules support 2 to 4 dimmer output ports (number depends on firmware version).\n+If the module hardware type doesn't feature physical dimmer outputs, the outputs can still be used as virtual.\n+\n+Status values are always in percent.\n+Modules since 170206 have a 0.5%-steps resolution. Older modules have a 2%-steps resolution.\n+\n+The time it takes the output port to reach its setpoint is called *ramp*.\n+\n+### LCN Variables\n+\n+LCN modules support:\n+\n+- 3 or 12 (since 170206) analog variables for general purpose\n+- 2 regulators with configurable setpoints\n+- 5 or 4x4 (since 170206) thresholds (trigger levels)\n+- 4 S0-input counters (since 170206, LCN-BU4L must be connected)\n+\n+### LCN Regulators (additions to variables)\n+\n+LCN modules have 2 regulators.\n+Each one has a setpoint and uses one variable as its value source.\n+A regulator can be locked, so that the target actuator keeps switched off, also if the value source is in control range.\n+\n+### LCN Thresholds\n+\n+LCN modules since firmware 170206 have 4 threshold registers. Each threshold register comprises 4 thresholds.\n+\n+A threshold register uses one variable as its value source (see [LCN Variables](#lcn-variables)).\n+Arbitrary LCN commands can be send into the bus, when the value-source falls below a threshold or exceeds one.\n+A threshold can be locked, so that the configured LCN command is not fired, also if the value source passes the threshold.\n+\n+### LCN Relays\n+\n+LCN modules support 8 relays. If no hardware relays are connected, the relays can still be used as virtual.\n+\n+### LCN Binary Sensors\n+\n+LCN modules support 8 binary sensors (e.g. motion detectors; hardware periphery must be connected).\n+  \n+### LCN LEDs (legacy name: *lamps*)\n+\n+12x multi-state variables can be used for logic operations or visualization (hardware periphery must be connected).\n+\n+Values: OFF, ON, BLINK, FLICKER\n+\n+### LCN Logic Operations (legacy name: *sums*)\n+\n+4x multi-state variables each representing the result of a logic operation of the associated LEDs.\n+\n+Values: NOT (all LEDs off), OR (some LEDs on), AND (all LEDs on)\n+\n+### LCN Keys\n+\n+LCN keys are data-points in the module with bound commands.\n+LCN modules support 3 (\"A-C\") or 4 (\"A-D\") key-tables (number depends on firmware version).\n+\n+Each key-table holds 8 keys. Examples: A1, A7, D8\n+\n+Each key has 3 command types: HIT(press), MAKE(long press), BREAK(long press release)\n+\n+These keys can be locked. The bound (LCN-)commands cannot be executed, then.\n+\n+### LCN Access Control & Remote Controls\n+\n+LCN can interface several transponder readers and finger print sensors, used for access control.\n+\n+Remote controls can not only be used for triggering commands, but also for access control, by evaluating the transmitted serial number.\n+\n+## Supported Things\n+\n+### Thing: LCN Module\n+\n+Any LCN module that should be controlled or visualized, need to be added to openHAB as a *Thing*.\n+\n+LCN modules with firmware versions 120612 (2008) and 170602 (2013) were tested with this binding.\n+No known features/changes that need special handling were added until now (2020).\n+Modules with older and newer firmware should work, too.\n+The module hardware types (e.g. LCN-SH, LCN-HU, LCN-UPP, ...) are compatible to each other and can therefore be handled all in the same way.\n+\n+### Thing: LCN PCK Gateway\n+\n+PCK is the protocol spoken over TCP/IP with a PCK gateway to communicate with the LCN bus.\n+Examples for PCK gateways are the *LCN-PCHK* software running on Windows or Linux and the DIN rail mounting device *LCN-PKE*.\n+\n+For each LCN bus, interfaced to openHAB, a PCK gateway needs to be added to openHAB as a *Thing*.\n+\n+Several PCK gateways can be added to openHAB to control multiple LCN busses in distinct locations. \n+\n+The minimum recommended version is LCN-PCHK 2.8 (older versions will also work, but lack some functionality).\n+Visit [https://www.lcn.eu](https://www.lcn.eu) for updates.\n+\n+### Thing: LCN Group\n+\n+LCN modules can be assigned to groups with the programming software *LCN-PRO*.\n+\n+To send commands to an LCN group, the group needs to be added to openHAB as a *Thing*.\n+\n+One LCN module within the group is used to represent the status of the whole group.\n+For example, when a Dimmer Output is controlled via a LCN group *Thing*, openHAB will always visualize the state of the Dimmer Output of the chosen module. The states of the other modules in the group are ignored for visualization.\n+\n+## Discovery\n+\n+### Discover LCN Modules\n+\n+Basic data of LCN modules can be read out automatically by openHAB.\n+Click on one of the check marks to add the LCN modules to openHAB:\n+\n+![Paper UI screenshot, showing the discovery result for LCN modules](doc/module_discovery.png)\n+\n+If not all LCN modules get listed on the first run, click on the refresh button to start another scan.\n+\n+When adding a module by discovery, the new *Thing*'s UID will be the module's serial number.\n+\n+### Discover PCK Gateways\n+\n+PCK gateways in the LAN can be found automatically by openHAB. This is done by UDP multicast messages on port 4220.\n+The discovery works only if the firewall of the PCK gateway is not configured too strictly.\n+This means on Windows PCs, that the network must be configured as 'private' and not as 'public'.\n+Also, some network switches may block multicast packets.\n+Unfortunately, *LCN-PCHK* listens only on the first network interface of the computer for discovery packets.\n+If your PCK gateway has multiple network interfaces, *LCN-PCHK* may listen on the wrong interface and fails to respond to the discovery request.\n+\n+Discovery has successfully been tested with LCN-PCHK 3.2.2 running on a Raspberry Pi with Raspbian and openHAB running on Windows 10.\n+See the following screenshot:\n+\n+![Paper UI screenshot, showing the discovery result for PCK gateways](doc/pck_discovery.png)\n+\n+If discovery fails, you can add a PCK gateway manually. See [Thing: PCK Gateway](#thing-lcn-pck-gateway).\n+\n+Please be aware that you **have to configure** username, password and the dimmer output resolution also if you use discovery.\n+See [Thing: PCK Gateway](#thing-lcn-pck-gateway).\n+\n+When adding a PCK gateway by discovery, the new *Thing*'s UID is the MAC address of the device, running the PCK gateway.\n+\n+## Thing Configuration\n+\n+### Configure LCN-PCHK/-PKE Connection\n+\n+Click on the plus symbol under Configuration/Things in Paper UI. Select \"Add manually\".\n+When adding a PCK gateway manually, the *hostname/IP address*, *port* and *username* and *password* need to be configured.\n+\n+> **IMPORTANT:** You need to configure the dimmer output resolution. This setting is valid for the **whole** LCN bus.<br />\n+The setting is either 0-50 steps or 0-200 steps.\n+It **has to be the same** as in the parameterizing software **LCN-PRO** under Options/Settings/Expert Settings.\n+See the following screenshot.\n+\n+![LCN-PRO screenshot, showing the 50 or 200 steps for the dimmer outputs](doc/LCN-PRO_output_steps.png)\n+\n+When using a wrong dimmer output setting, dimming the outputs will result in unintended behavior.\n+\n+### Add LCN Module Manually\n+\n+Click on the plus symbol under Configuration/Things in Paper UI. Select \"Add manually\". \n+Now you can configure the *module ID* and the *segment ID* (0 if no segments are used).\n+After confirming, the new module should show up under Configuration/Things.\n+\n+openHAB's discovery function can be used to add LCN modules automatically.\n+See [Discover LCN Modules](#discover-lcn-modules).\n+\n+### Add LCN Group\n+\n+Click on the plus symbol under Configuration/Things in Paper UI. Select \"Add manually\".\n+Now you can configure the *group number*, as previously configured in the programming software *LCN-PRO*.\n+If you use segments, you need to configure the segment ID of the modules within the group. Enter 0, if you have no segments.\n+Lastly, you have to configure the *module ID* of any module within the group.\n+This module will be used for visualization, as representative for all modules within the group.\n+\n+## Supported LCN Features and openHAB Channels\n+\n+The following table lists all features of LCN and their mappings to openHAB *Channel*s.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ce02f433e5d4071dbebb9ee68da0e22895887b6b"}, "originalPosition": 217}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjM5NTIyMg==", "bodyText": "It is unusual to have this as a trigger and not as a state. Can I assume that this is because it is just a one-time event that is sent from LCN and there isn't a chance to determine the battery state (e.g. by receiving it in a fixed interval or by actively polling it)?", "url": "https://github.com/openhab/openhab-addons/pull/7509#discussion_r436395222", "createdAt": "2020-06-07T19:41:18Z", "author": {"login": "kaikreuzer"}, "path": "bundles/org.openhab.binding.lcn/README.md", "diffHunk": "@@ -0,0 +1,597 @@\n+# LCN Binding\n+\n+[Local Control Network (LCN)](http://www.lcn.eu) is a building automation system for small and very large installations.\n+It is capable of controlling lights, shutters, access control etc. and can process data from several sensor types.\n+It has been introduced in 1992.\n+\n+A broad range of glass key panels, displays, remote controls, sensors and in- and outputs exist.  \n+The system can handle up to 30,000 bus members, called modules.\n+LCN modules are available for DIN rail and in-wall mounting and feature versatile interfaces. The bus modules and most of the accessories are developed, manufactured and assembled in Germany.\n+\n+Bus members are inter-connected via a free wire in the standard NYM cable. Wireless components are available, though.\n+\n+![Illustration of the LCN product family](doc/overview.jpg)\n+\n+This binding uses TCP/IP to access the LCN bus via the software LCN-PCHK (Windows/Linux) or the DIN rail device LCN-PKE.\n+**This means 1 unused LCN-PCHK license or a LCN-PKE is required**\n+\n+It is recommended to configure *Thing*s in [Paper UI](https://www.openhab.org/docs/configuration/paperui.html) and *Item*s in text files.\n+*Channel*s and *Link*s are configured automatically, then.\n+\n+## LCN Overview\n+\n+LCN modules and their connecting peripherals are explained in the following.\n+\n+### LCN Modules\n+\n+Active LCN components connected to the LCN bus are called *LCN modules*.\n+LCN modules are addressed by their numeric id: Valid range is 5..254\n+\n+In larger buildings, a second topologic layer is added: *segments*.\n+Valid range is 5..128 or 0 (= no segments exist) or 3 (= target all segments)\n+\n+LCN modules within the **same** segment can be grouped: Valid range is 5..254 or 3 (= target all groups)\n+\n+### LCN Firmware Versions\n+\n+Each LCN module has a feature-set based on its firmware version.\n+This version is written as follows: \\[year since 1990\\]\\[month\\]\\[day\\]\n+\n+Each component is written in hexadecimal with 2 characters. Examples:\n+\n+- 090101 = 1. january 1990\n+- 0D0C01 = 1. december 2003\n+- 170206 = 6. feb. 2013\n+\n+### LCN Dimmer Outputs\n+\n+LCN modules support 2 to 4 dimmer output ports (number depends on firmware version).\n+If the module hardware type doesn't feature physical dimmer outputs, the outputs can still be used as virtual.\n+\n+Status values are always in percent.\n+Modules since 170206 have a 0.5%-steps resolution. Older modules have a 2%-steps resolution.\n+\n+The time it takes the output port to reach its setpoint is called *ramp*.\n+\n+### LCN Variables\n+\n+LCN modules support:\n+\n+- 3 or 12 (since 170206) analog variables for general purpose\n+- 2 regulators with configurable setpoints\n+- 5 or 4x4 (since 170206) thresholds (trigger levels)\n+- 4 S0-input counters (since 170206, LCN-BU4L must be connected)\n+\n+### LCN Regulators (additions to variables)\n+\n+LCN modules have 2 regulators.\n+Each one has a setpoint and uses one variable as its value source.\n+A regulator can be locked, so that the target actuator keeps switched off, also if the value source is in control range.\n+\n+### LCN Thresholds\n+\n+LCN modules since firmware 170206 have 4 threshold registers. Each threshold register comprises 4 thresholds.\n+\n+A threshold register uses one variable as its value source (see [LCN Variables](#lcn-variables)).\n+Arbitrary LCN commands can be send into the bus, when the value-source falls below a threshold or exceeds one.\n+A threshold can be locked, so that the configured LCN command is not fired, also if the value source passes the threshold.\n+\n+### LCN Relays\n+\n+LCN modules support 8 relays. If no hardware relays are connected, the relays can still be used as virtual.\n+\n+### LCN Binary Sensors\n+\n+LCN modules support 8 binary sensors (e.g. motion detectors; hardware periphery must be connected).\n+  \n+### LCN LEDs (legacy name: *lamps*)\n+\n+12x multi-state variables can be used for logic operations or visualization (hardware periphery must be connected).\n+\n+Values: OFF, ON, BLINK, FLICKER\n+\n+### LCN Logic Operations (legacy name: *sums*)\n+\n+4x multi-state variables each representing the result of a logic operation of the associated LEDs.\n+\n+Values: NOT (all LEDs off), OR (some LEDs on), AND (all LEDs on)\n+\n+### LCN Keys\n+\n+LCN keys are data-points in the module with bound commands.\n+LCN modules support 3 (\"A-C\") or 4 (\"A-D\") key-tables (number depends on firmware version).\n+\n+Each key-table holds 8 keys. Examples: A1, A7, D8\n+\n+Each key has 3 command types: HIT(press), MAKE(long press), BREAK(long press release)\n+\n+These keys can be locked. The bound (LCN-)commands cannot be executed, then.\n+\n+### LCN Access Control & Remote Controls\n+\n+LCN can interface several transponder readers and finger print sensors, used for access control.\n+\n+Remote controls can not only be used for triggering commands, but also for access control, by evaluating the transmitted serial number.\n+\n+## Supported Things\n+\n+### Thing: LCN Module\n+\n+Any LCN module that should be controlled or visualized, need to be added to openHAB as a *Thing*.\n+\n+LCN modules with firmware versions 120612 (2008) and 170602 (2013) were tested with this binding.\n+No known features/changes that need special handling were added until now (2020).\n+Modules with older and newer firmware should work, too.\n+The module hardware types (e.g. LCN-SH, LCN-HU, LCN-UPP, ...) are compatible to each other and can therefore be handled all in the same way.\n+\n+### Thing: LCN PCK Gateway\n+\n+PCK is the protocol spoken over TCP/IP with a PCK gateway to communicate with the LCN bus.\n+Examples for PCK gateways are the *LCN-PCHK* software running on Windows or Linux and the DIN rail mounting device *LCN-PKE*.\n+\n+For each LCN bus, interfaced to openHAB, a PCK gateway needs to be added to openHAB as a *Thing*.\n+\n+Several PCK gateways can be added to openHAB to control multiple LCN busses in distinct locations. \n+\n+The minimum recommended version is LCN-PCHK 2.8 (older versions will also work, but lack some functionality).\n+Visit [https://www.lcn.eu](https://www.lcn.eu) for updates.\n+\n+### Thing: LCN Group\n+\n+LCN modules can be assigned to groups with the programming software *LCN-PRO*.\n+\n+To send commands to an LCN group, the group needs to be added to openHAB as a *Thing*.\n+\n+One LCN module within the group is used to represent the status of the whole group.\n+For example, when a Dimmer Output is controlled via a LCN group *Thing*, openHAB will always visualize the state of the Dimmer Output of the chosen module. The states of the other modules in the group are ignored for visualization.\n+\n+## Discovery\n+\n+### Discover LCN Modules\n+\n+Basic data of LCN modules can be read out automatically by openHAB.\n+Click on one of the check marks to add the LCN modules to openHAB:\n+\n+![Paper UI screenshot, showing the discovery result for LCN modules](doc/module_discovery.png)\n+\n+If not all LCN modules get listed on the first run, click on the refresh button to start another scan.\n+\n+When adding a module by discovery, the new *Thing*'s UID will be the module's serial number.\n+\n+### Discover PCK Gateways\n+\n+PCK gateways in the LAN can be found automatically by openHAB. This is done by UDP multicast messages on port 4220.\n+The discovery works only if the firewall of the PCK gateway is not configured too strictly.\n+This means on Windows PCs, that the network must be configured as 'private' and not as 'public'.\n+Also, some network switches may block multicast packets.\n+Unfortunately, *LCN-PCHK* listens only on the first network interface of the computer for discovery packets.\n+If your PCK gateway has multiple network interfaces, *LCN-PCHK* may listen on the wrong interface and fails to respond to the discovery request.\n+\n+Discovery has successfully been tested with LCN-PCHK 3.2.2 running on a Raspberry Pi with Raspbian and openHAB running on Windows 10.\n+See the following screenshot:\n+\n+![Paper UI screenshot, showing the discovery result for PCK gateways](doc/pck_discovery.png)\n+\n+If discovery fails, you can add a PCK gateway manually. See [Thing: PCK Gateway](#thing-lcn-pck-gateway).\n+\n+Please be aware that you **have to configure** username, password and the dimmer output resolution also if you use discovery.\n+See [Thing: PCK Gateway](#thing-lcn-pck-gateway).\n+\n+When adding a PCK gateway by discovery, the new *Thing*'s UID is the MAC address of the device, running the PCK gateway.\n+\n+## Thing Configuration\n+\n+### Configure LCN-PCHK/-PKE Connection\n+\n+Click on the plus symbol under Configuration/Things in Paper UI. Select \"Add manually\".\n+When adding a PCK gateway manually, the *hostname/IP address*, *port* and *username* and *password* need to be configured.\n+\n+> **IMPORTANT:** You need to configure the dimmer output resolution. This setting is valid for the **whole** LCN bus.<br />\n+The setting is either 0-50 steps or 0-200 steps.\n+It **has to be the same** as in the parameterizing software **LCN-PRO** under Options/Settings/Expert Settings.\n+See the following screenshot.\n+\n+![LCN-PRO screenshot, showing the 50 or 200 steps for the dimmer outputs](doc/LCN-PRO_output_steps.png)\n+\n+When using a wrong dimmer output setting, dimming the outputs will result in unintended behavior.\n+\n+### Add LCN Module Manually\n+\n+Click on the plus symbol under Configuration/Things in Paper UI. Select \"Add manually\". \n+Now you can configure the *module ID* and the *segment ID* (0 if no segments are used).\n+After confirming, the new module should show up under Configuration/Things.\n+\n+openHAB's discovery function can be used to add LCN modules automatically.\n+See [Discover LCN Modules](#discover-lcn-modules).\n+\n+### Add LCN Group\n+\n+Click on the plus symbol under Configuration/Things in Paper UI. Select \"Add manually\".\n+Now you can configure the *group number*, as previously configured in the programming software *LCN-PRO*.\n+If you use segments, you need to configure the segment ID of the modules within the group. Enter 0, if you have no segments.\n+Lastly, you have to configure the *module ID* of any module within the group.\n+This module will be used for visualization, as representative for all modules within the group.\n+\n+## Supported LCN Features and openHAB Channels\n+\n+The following table lists all features of LCN and their mappings to openHAB *Channel*s.\n+\n+Although, there are many **Not implemented** entries, the vast majority of LCN features can be used with openHAB:<br />\n+If a special command is needed, the [Hit Key](#hit-key) action (German: \"Sende Taste\") can be used to hit a module's key virtually and execute an arbitrary command.\n+\n+| LCN Feature (English)           | LCN Feature (German)             | Channel                | IDs  | Type                           | Description                                                                                                                   |\n+|---------------------------------|----------------------------------|------------------------|------|--------------------------------|-------------------------------------------------------------------------------------------------------------------------------|\n+| Dimmer Output Control Single    | Ausgang                          | output                 | 1-4  | Dimmer, Switch                 | Sets the dimming value of an output with a given ramp.                                                                        |\n+| Relay                           | Relais                           | relay                  | 1-8  | Switch                         | Controls a relay and visualizes its state.                                                                                    |\n+| Visualize Binary Sensor         | Bin\u00e4rsensor anzeigen             | binarysensor           | 1-8  | Contact                        | Visualizes the state of a binary sensor.                                                                                      |\n+| LED Control                     | LED-Steuerung                    | led                    | 1-12 | Text (ON, OFF, BLINK, FLICKER) | Controls an LED and visualizes its current state.                                                                             |\n+| Visualize Logic Operations      | Logik Funktion anzeigen          | logic                  | 1-4  | Text (NOT, OR, AND)            | Visualizes the result of the logic operation.                                                                                 |\n+| Motor/Shutter on Dimmer Outputs | Motor/Rollladen an Ausg\u00e4ngen     | rollershutteroutput    | 1-4  | Rollershutter                  | Control roller shutters on dimmer outputs                                                                                     |\n+| Motor/Shutter on Relays         | Motor/Rollladen an Relais        | rollershutterrelay     | 1-4  | Rollershutter                  | Control roller shutters on relays                                                                                             |\n+| Variables                       | Variable anzeigen                | variable               | 1-12 | Number                         | Sets and visualizes the value of a variable.                                                                                  |\n+| Regulator Set Setpoint          | Regler Sollwert \u00e4ndern           | rvarsetpoint           | 1-2  | Number                         | Sets and visualizes the setpoint of a regulator.                                                                              |\n+| Regulator Lock                  | Regler sperren                   | rvarlock               | 1-2  | Switch                         | Locks a regulator and visualizes its locking state.                                                                           |\n+| Set Thresholds in Register 1    | Schwellwert in Register 1 \u00e4ndern | thresholdregister1     | 1-4  | Number                         | Sets and visualizes a threshold in the given threshold register.                                                              |\n+| Set Thresholds in Register 2    | Schwellwert in Register 2 \u00e4ndern | thresholdregister2     | 1-4  | Number                         | Sets and visualizes a threshold in the given threshold register.                                                              |\n+| Set Thresholds in Register 3    | Schwellwert in Register 3 \u00e4ndern | thresholdregister3     | 1-4  | Number                         | Sets and visualizes a threshold in the given threshold register.                                                              |\n+| Set Thresholds in Register 4    | Schwellwert in Register 4 \u00e4ndern | thresholdregister4     | 1-4  | Number                         | Sets and visualizes a threshold in the given threshold register.                                                              |\n+| Visualize S0 Counters           | S0-Z\u00e4hler anzeigen               | s0input                | 1-4  | Number                         | Visualizes the value of a S0 counter.                                                                                         |\n+| Lock Keys Table A               | Sperre Tastentabelle A           | keylocktablea          | 1-8  | Switch                         | Locks a key on the given key table and visualizes its state.                                                                  |\n+| Lock Keys Table B               | Sperre Tastentabelle B           | keylocktableb          | 1-8  | Switch                         | Locks a key on the given key table and visualizes its state.                                                                  |\n+| Lock Keys Table C               | Sperre Tastentabelle C           | keylocktablec          | 1-8  | Switch                         | Locks a key on the given key table and visualizes its state.                                                                  |\n+| Lock Keys Table D               | Sperre Tastentabelle D           | keylocktabled          | 1-8  | Switch                         | Locks a key on the given key table and visualizes its state.                                                                  |\n+| Dimmer Output Flicker           | Ausgang: Flackern                | N/A                    | N/A  | N/A                            | Action \"flickerOutput\": Let a dimmer output flicker for a given count of flashes.                                             |\n+| Dynamic Text                    | Dynamischer Text                 | N/A                    | N/A  | N/A                            | Action: \"sendDynamicText\": Sends custom text to an LCN-GTxD display.                                                          |\n+| Send Keys                       | Sende Tasten                     | N/A                    | N/A  | N/A                            | Action: \"hitKey\": Hits a key of a key table in an LCN module. Can be used to execute commands, not supported by this binding. |\n+| Dimmer Output Control Multiple  | Mehrere Ausg\u00e4nge steuern         | output                 | 1-4  | Dimmer, Switch                 | Control multiple outputs simultaneously. See below.                                                                           |\n+| Transponder                     | Transponder                      | code#transponder       |      | Trigger                        | Receive transponder messages                                                                                                  |\n+| Remote Control                  | Fernbedienung                    | code#remotecontrolkey  |      | Trigger                        | Receive commands from remote control                                                                                          |\n+| Access Control                  | Zutrittskontrolle                | code#remotecontrolcode |      | Trigger                        | Receive serial numbers from remote control                                                                                    |\n+| Remote Control Battery Low      | Fernbedienung Batterie schwach   | code#remotecontrolbatterylow | | Trigger                       | Triggered when the sending remote control has a low battery                                                                   |", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ce02f433e5d4071dbebb9ee68da0e22895887b6b"}, "originalPosition": 250}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjM5NzA4Nw==", "bodyText": "What's the purpose of the NullScheduledFuture here? Couldn't you simply leave it uninitialized (null)?", "url": "https://github.com/openhab/openhab-addons/pull/7509#discussion_r436397087", "createdAt": "2020-06-07T20:05:38Z", "author": {"login": "kaikreuzer"}, "path": "bundles/org.openhab.binding.lcn/src/main/java/org/openhab/binding/lcn/internal/LcnModuleDiscoveryService.java", "diffHunk": "@@ -0,0 +1,246 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.lcn.internal;\n+\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Queue;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentLinkedQueue;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.config.discovery.AbstractDiscoveryService;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResultBuilder;\n+import org.eclipse.smarthome.config.discovery.DiscoveryService;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.thing.ThingUID;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.openhab.binding.lcn.internal.common.LcnAddrMod;\n+import org.openhab.binding.lcn.internal.common.NullScheduledFuture;\n+import org.openhab.binding.lcn.internal.connection.Connection;\n+import org.openhab.binding.lcn.internal.subhandler.LcnModuleMetaAckSubHandler;\n+import org.openhab.binding.lcn.internal.subhandler.LcnModuleMetaFirmwareSubHandler;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Scans all LCN segments for LCN modules.\n+ *\n+ * Scan approach:\n+ * 1. Send \"Leerkomando\" to the broadcast address with request for Ack set\n+ * 2. For every received Ack, send the following requests to the module:\n+ * - serial number request (SN)\n+ * - module's name first part request (NM1)\n+ * - module's name second part request (NM2)\n+ * 3. When all three messages have been received, fire thingDiscovered()\n+ *\n+ * @author Fabian Wolter - Initial Contribution\n+ */\n+@NonNullByDefault\n+public class LcnModuleDiscoveryService extends AbstractDiscoveryService\n+        implements DiscoveryService, ThingHandlerService {\n+    private final Logger logger = LoggerFactory.getLogger(LcnModuleDiscoveryService.class);\n+    private static final Pattern NAME_PATTERN = Pattern\n+            .compile(\"=M(?<segId>\\\\d{3})(?<modId>\\\\d{3}).N(?<part>[1-2]{1})(?<name>.*)\");\n+    private static final int MODULE_NAME_PART_COUNT = 2;\n+    private static final int DISCOVERY_TIMEOUT_SEC = 90;\n+    private static final int ACK_TIMEOUT_MS = 1000;\n+    private static final Set<ThingTypeUID> SUPPORTED_THING_TYPES_UIDS = Collections\n+            .unmodifiableSet(Stream.of(LcnBindingConstants.THING_TYPE_MODULE).collect(Collectors.toSet()));\n+    private @Nullable PckGatewayHandler bridgeHandler;\n+    private Map<LcnAddrMod, Map<Integer, String>> moduleNames = Collections.synchronizedMap(new HashMap<>());\n+    private Map<LcnAddrMod, DiscoveryResultBuilder> discoveryResultBuilders = Collections\n+            .synchronizedMap(new HashMap<>());\n+    private List<LcnAddrMod> successfullyDiscovered = new LinkedList<>();\n+    private Queue<@Nullable LcnAddrMod> serialNumberRequestQueue = new ConcurrentLinkedQueue<>();\n+    private Queue<@Nullable LcnAddrMod> moduleNameRequestQueue = new ConcurrentLinkedQueue<>();\n+    private volatile ScheduledFuture<?> queueProcessor = NullScheduledFuture.getInstance();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ce02f433e5d4071dbebb9ee68da0e22895887b6b"}, "originalPosition": 78}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjM5NzEwNA==", "bodyText": "dito", "url": "https://github.com/openhab/openhab-addons/pull/7509#discussion_r436397104", "createdAt": "2020-06-07T20:05:43Z", "author": {"login": "kaikreuzer"}, "path": "bundles/org.openhab.binding.lcn/src/main/java/org/openhab/binding/lcn/internal/LcnModuleDiscoveryService.java", "diffHunk": "@@ -0,0 +1,246 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.lcn.internal;\n+\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Queue;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentLinkedQueue;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.config.discovery.AbstractDiscoveryService;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResultBuilder;\n+import org.eclipse.smarthome.config.discovery.DiscoveryService;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.thing.ThingUID;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.openhab.binding.lcn.internal.common.LcnAddrMod;\n+import org.openhab.binding.lcn.internal.common.NullScheduledFuture;\n+import org.openhab.binding.lcn.internal.connection.Connection;\n+import org.openhab.binding.lcn.internal.subhandler.LcnModuleMetaAckSubHandler;\n+import org.openhab.binding.lcn.internal.subhandler.LcnModuleMetaFirmwareSubHandler;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Scans all LCN segments for LCN modules.\n+ *\n+ * Scan approach:\n+ * 1. Send \"Leerkomando\" to the broadcast address with request for Ack set\n+ * 2. For every received Ack, send the following requests to the module:\n+ * - serial number request (SN)\n+ * - module's name first part request (NM1)\n+ * - module's name second part request (NM2)\n+ * 3. When all three messages have been received, fire thingDiscovered()\n+ *\n+ * @author Fabian Wolter - Initial Contribution\n+ */\n+@NonNullByDefault\n+public class LcnModuleDiscoveryService extends AbstractDiscoveryService\n+        implements DiscoveryService, ThingHandlerService {\n+    private final Logger logger = LoggerFactory.getLogger(LcnModuleDiscoveryService.class);\n+    private static final Pattern NAME_PATTERN = Pattern\n+            .compile(\"=M(?<segId>\\\\d{3})(?<modId>\\\\d{3}).N(?<part>[1-2]{1})(?<name>.*)\");\n+    private static final int MODULE_NAME_PART_COUNT = 2;\n+    private static final int DISCOVERY_TIMEOUT_SEC = 90;\n+    private static final int ACK_TIMEOUT_MS = 1000;\n+    private static final Set<ThingTypeUID> SUPPORTED_THING_TYPES_UIDS = Collections\n+            .unmodifiableSet(Stream.of(LcnBindingConstants.THING_TYPE_MODULE).collect(Collectors.toSet()));\n+    private @Nullable PckGatewayHandler bridgeHandler;\n+    private Map<LcnAddrMod, Map<Integer, String>> moduleNames = Collections.synchronizedMap(new HashMap<>());\n+    private Map<LcnAddrMod, DiscoveryResultBuilder> discoveryResultBuilders = Collections\n+            .synchronizedMap(new HashMap<>());\n+    private List<LcnAddrMod> successfullyDiscovered = new LinkedList<>();\n+    private Queue<@Nullable LcnAddrMod> serialNumberRequestQueue = new ConcurrentLinkedQueue<>();\n+    private Queue<@Nullable LcnAddrMod> moduleNameRequestQueue = new ConcurrentLinkedQueue<>();\n+    private volatile ScheduledFuture<?> queueProcessor = NullScheduledFuture.getInstance();\n+    private ScheduledFuture<?> builderTask = NullScheduledFuture.getInstance();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ce02f433e5d4071dbebb9ee68da0e22895887b6b"}, "originalPosition": 79}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjM5NzI1Ng==", "bodyText": "Can this be removed by adapting the code?", "url": "https://github.com/openhab/openhab-addons/pull/7509#discussion_r436397256", "createdAt": "2020-06-07T20:07:31Z", "author": {"login": "kaikreuzer"}, "path": "bundles/org.openhab.binding.lcn/src/main/java/org/openhab/binding/lcn/internal/LcnModuleDiscoveryService.java", "diffHunk": "@@ -0,0 +1,246 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.lcn.internal;\n+\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Queue;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentLinkedQueue;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.config.discovery.AbstractDiscoveryService;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResultBuilder;\n+import org.eclipse.smarthome.config.discovery.DiscoveryService;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.thing.ThingUID;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.openhab.binding.lcn.internal.common.LcnAddrMod;\n+import org.openhab.binding.lcn.internal.common.NullScheduledFuture;\n+import org.openhab.binding.lcn.internal.connection.Connection;\n+import org.openhab.binding.lcn.internal.subhandler.LcnModuleMetaAckSubHandler;\n+import org.openhab.binding.lcn.internal.subhandler.LcnModuleMetaFirmwareSubHandler;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Scans all LCN segments for LCN modules.\n+ *\n+ * Scan approach:\n+ * 1. Send \"Leerkomando\" to the broadcast address with request for Ack set\n+ * 2. For every received Ack, send the following requests to the module:\n+ * - serial number request (SN)\n+ * - module's name first part request (NM1)\n+ * - module's name second part request (NM2)\n+ * 3. When all three messages have been received, fire thingDiscovered()\n+ *\n+ * @author Fabian Wolter - Initial Contribution\n+ */\n+@NonNullByDefault\n+public class LcnModuleDiscoveryService extends AbstractDiscoveryService\n+        implements DiscoveryService, ThingHandlerService {\n+    private final Logger logger = LoggerFactory.getLogger(LcnModuleDiscoveryService.class);\n+    private static final Pattern NAME_PATTERN = Pattern\n+            .compile(\"=M(?<segId>\\\\d{3})(?<modId>\\\\d{3}).N(?<part>[1-2]{1})(?<name>.*)\");\n+    private static final int MODULE_NAME_PART_COUNT = 2;\n+    private static final int DISCOVERY_TIMEOUT_SEC = 90;\n+    private static final int ACK_TIMEOUT_MS = 1000;\n+    private static final Set<ThingTypeUID> SUPPORTED_THING_TYPES_UIDS = Collections\n+            .unmodifiableSet(Stream.of(LcnBindingConstants.THING_TYPE_MODULE).collect(Collectors.toSet()));\n+    private @Nullable PckGatewayHandler bridgeHandler;\n+    private Map<LcnAddrMod, Map<Integer, String>> moduleNames = Collections.synchronizedMap(new HashMap<>());\n+    private Map<LcnAddrMod, DiscoveryResultBuilder> discoveryResultBuilders = Collections\n+            .synchronizedMap(new HashMap<>());\n+    private List<LcnAddrMod> successfullyDiscovered = new LinkedList<>();\n+    private Queue<@Nullable LcnAddrMod> serialNumberRequestQueue = new ConcurrentLinkedQueue<>();\n+    private Queue<@Nullable LcnAddrMod> moduleNameRequestQueue = new ConcurrentLinkedQueue<>();\n+    private volatile ScheduledFuture<?> queueProcessor = NullScheduledFuture.getInstance();\n+    private ScheduledFuture<?> builderTask = NullScheduledFuture.getInstance();\n+\n+    public LcnModuleDiscoveryService() {\n+        super(SUPPORTED_THING_TYPES_UIDS, DISCOVERY_TIMEOUT_SEC, false);\n+    }\n+\n+    @Override\n+    public void setThingHandler(@Nullable ThingHandler handler) {\n+        if (handler instanceof PckGatewayHandler) {\n+            this.bridgeHandler = (PckGatewayHandler) handler;\n+        }\n+    }\n+\n+    @Override\n+    public @Nullable ThingHandler getThingHandler() {\n+        return bridgeHandler;\n+    }\n+\n+    @Override\n+    public void deactivate() {\n+        super.deactivate();\n+        stopScan();\n+    }\n+\n+    @SuppressWarnings({ \"unused\", \"null\" })", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ce02f433e5d4071dbebb9ee68da0e22895887b6b"}, "originalPosition": 103}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjM5NzgzNg==", "bodyText": "It isn't really a configuration error, i.e. some mistake of the user, is it?\nThose are rather severe software issues, so you could consider throwing an IllegalStateException here.", "url": "https://github.com/openhab/openhab-addons/pull/7509#discussion_r436397836", "createdAt": "2020-06-07T20:14:31Z", "author": {"login": "kaikreuzer"}, "path": "bundles/org.openhab.binding.lcn/src/main/java/org/openhab/binding/lcn/internal/LcnModuleHandler.java", "diffHunk": "@@ -0,0 +1,411 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.lcn.internal;\n+\n+import java.lang.reflect.InvocationTargetException;\n+import java.nio.ByteBuffer;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+import java.util.Optional;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.HSBType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StopMoveType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.library.types.UpDownType;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.lcn.internal.common.DimmerOutputCommand;\n+import org.openhab.binding.lcn.internal.common.LcnAddr;\n+import org.openhab.binding.lcn.internal.common.LcnAddrMod;\n+import org.openhab.binding.lcn.internal.common.LcnChannelGroup;\n+import org.openhab.binding.lcn.internal.common.LcnException;\n+import org.openhab.binding.lcn.internal.connection.Connection;\n+import org.openhab.binding.lcn.internal.connection.ModInfo;\n+import org.openhab.binding.lcn.internal.converter.AbstractVariableValueConverter;\n+import org.openhab.binding.lcn.internal.converter.AngleConverter;\n+import org.openhab.binding.lcn.internal.converter.Co2Converter;\n+import org.openhab.binding.lcn.internal.converter.CurrentConverter;\n+import org.openhab.binding.lcn.internal.converter.EnergyConverter;\n+import org.openhab.binding.lcn.internal.converter.IdentityConverter;\n+import org.openhab.binding.lcn.internal.converter.LightConverter;\n+import org.openhab.binding.lcn.internal.converter.PowerConverter;\n+import org.openhab.binding.lcn.internal.converter.TemperatureConverter;\n+import org.openhab.binding.lcn.internal.converter.VoltageConverter;\n+import org.openhab.binding.lcn.internal.converter.WindspeedConverter;\n+import org.openhab.binding.lcn.internal.subhandler.AbstractLcnModuleSubHandler;\n+import org.openhab.binding.lcn.internal.subhandler.LcnModuleMetaAckSubHandler;\n+import org.openhab.binding.lcn.internal.subhandler.LcnModuleMetaFirmwareSubHandler;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link LcnModuleHandler} is responsible for handling commands, which are\n+ * sent to or received from one of the channels.\n+ *\n+ * @author Fabian Wolter - Initial contribution\n+ */\n+@NonNullByDefault\n+public class LcnModuleHandler extends BaseThingHandler {\n+    private final Logger logger = LoggerFactory.getLogger(LcnModuleHandler.class);\n+    private @Nullable LcnAddrMod moduleAddress;\n+    private Map<LcnChannelGroup, @Nullable AbstractLcnModuleSubHandler> subHandlers;\n+    private List<AbstractLcnModuleSubHandler> metadataSubHandlers;\n+    private Map<ChannelUID, @Nullable AbstractVariableValueConverter> converters;\n+\n+    public LcnModuleHandler(Thing thing) {\n+        super(thing);\n+\n+        subHandlers = Collections.synchronizedMap(new HashMap<>());\n+        metadataSubHandlers = Collections.synchronizedList(new LinkedList<>());\n+        converters = Collections.synchronizedMap(new HashMap<>());\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        LcnModuleConfiguration localConfig = getConfigAs(LcnModuleConfiguration.class);\n+        LcnAddrMod localModuleAddress = moduleAddress = new LcnAddrMod(localConfig.segmentId, localConfig.moduleId);\n+\n+        try {\n+            // create sub handlers\n+            ModInfo info = getPckGatewayHandler().getModInfo(localModuleAddress);\n+            for (LcnChannelGroup type : LcnChannelGroup.values()) {\n+                AbstractLcnModuleSubHandler newHandler = type.getSubHandlerClass()\n+                        .getDeclaredConstructor(LcnModuleHandler.class, ModInfo.class).newInstance(this, info);\n+\n+                subHandlers.put(type, newHandler);\n+            }\n+\n+            // meta sub handlers, which are not assigned to a channel group\n+            metadataSubHandlers.add(new LcnModuleMetaAckSubHandler(this, info));\n+            metadataSubHandlers.add(new LcnModuleMetaFirmwareSubHandler(this, info));\n+\n+            // initialize variable value converters\n+            for (Channel channel : thing.getChannels()) {\n+                Object unitObject = channel.getConfiguration().get(\"unit\");\n+                Object parameterObject = channel.getConfiguration().get(\"parameter\");\n+\n+                if (unitObject instanceof String) {\n+                    switch ((String) unitObject) {\n+                        case \"temperature\":\n+                            converters.put(channel.getUID(), new TemperatureConverter());\n+                            break;\n+                        case \"light\":\n+                            converters.put(channel.getUID(), new LightConverter());\n+                            break;\n+                        case \"co2\":\n+                            converters.put(channel.getUID(), new Co2Converter());\n+                            break;\n+                        case \"power\":\n+                            converters.put(channel.getUID(), new PowerConverter(parameterObject));\n+                            break;\n+                        case \"energy\":\n+                            converters.put(channel.getUID(), new EnergyConverter(parameterObject));\n+                            break;\n+                        case \"current\":\n+                            converters.put(channel.getUID(), new CurrentConverter());\n+                            break;\n+                        case \"voltage\":\n+                            converters.put(channel.getUID(), new VoltageConverter());\n+                            break;\n+                        case \"angle\":\n+                            converters.put(channel.getUID(), new AngleConverter());\n+                            break;\n+                        case \"windspeed\":\n+                            converters.put(channel.getUID(), new WindspeedConverter());\n+                            break;\n+                    }\n+                }\n+            }\n+\n+            // module is assumed as online, when the corresponding Bridge (PckGatewayHandler) is online.\n+            updateStatus(ThingStatus.ONLINE);\n+        } catch (LcnException | InstantiationException | IllegalAccessException | IllegalArgumentException\n+                | InvocationTargetException | NoSuchMethodException | SecurityException e) {\n+            logger.warn(\"Failed to initialize handler: {}: {}: {}\", localModuleAddress, e.getClass().getSimpleName(),\n+                    e.getMessage());\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, e.getMessage());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ce02f433e5d4071dbebb9ee68da0e22895887b6b"}, "originalPosition": 156}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjM5NzkzNw==", "bodyText": "why is this needed?", "url": "https://github.com/openhab/openhab-addons/pull/7509#discussion_r436397937", "createdAt": "2020-06-07T20:15:44Z", "author": {"login": "kaikreuzer"}, "path": "bundles/org.openhab.binding.lcn/src/main/java/org/openhab/binding/lcn/internal/LcnModuleHandler.java", "diffHunk": "@@ -0,0 +1,411 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.lcn.internal;\n+\n+import java.lang.reflect.InvocationTargetException;\n+import java.nio.ByteBuffer;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+import java.util.Optional;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.HSBType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StopMoveType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.library.types.UpDownType;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.lcn.internal.common.DimmerOutputCommand;\n+import org.openhab.binding.lcn.internal.common.LcnAddr;\n+import org.openhab.binding.lcn.internal.common.LcnAddrMod;\n+import org.openhab.binding.lcn.internal.common.LcnChannelGroup;\n+import org.openhab.binding.lcn.internal.common.LcnException;\n+import org.openhab.binding.lcn.internal.connection.Connection;\n+import org.openhab.binding.lcn.internal.connection.ModInfo;\n+import org.openhab.binding.lcn.internal.converter.AbstractVariableValueConverter;\n+import org.openhab.binding.lcn.internal.converter.AngleConverter;\n+import org.openhab.binding.lcn.internal.converter.Co2Converter;\n+import org.openhab.binding.lcn.internal.converter.CurrentConverter;\n+import org.openhab.binding.lcn.internal.converter.EnergyConverter;\n+import org.openhab.binding.lcn.internal.converter.IdentityConverter;\n+import org.openhab.binding.lcn.internal.converter.LightConverter;\n+import org.openhab.binding.lcn.internal.converter.PowerConverter;\n+import org.openhab.binding.lcn.internal.converter.TemperatureConverter;\n+import org.openhab.binding.lcn.internal.converter.VoltageConverter;\n+import org.openhab.binding.lcn.internal.converter.WindspeedConverter;\n+import org.openhab.binding.lcn.internal.subhandler.AbstractLcnModuleSubHandler;\n+import org.openhab.binding.lcn.internal.subhandler.LcnModuleMetaAckSubHandler;\n+import org.openhab.binding.lcn.internal.subhandler.LcnModuleMetaFirmwareSubHandler;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link LcnModuleHandler} is responsible for handling commands, which are\n+ * sent to or received from one of the channels.\n+ *\n+ * @author Fabian Wolter - Initial contribution\n+ */\n+@NonNullByDefault\n+public class LcnModuleHandler extends BaseThingHandler {\n+    private final Logger logger = LoggerFactory.getLogger(LcnModuleHandler.class);\n+    private @Nullable LcnAddrMod moduleAddress;\n+    private Map<LcnChannelGroup, @Nullable AbstractLcnModuleSubHandler> subHandlers;\n+    private List<AbstractLcnModuleSubHandler> metadataSubHandlers;\n+    private Map<ChannelUID, @Nullable AbstractVariableValueConverter> converters;\n+\n+    public LcnModuleHandler(Thing thing) {\n+        super(thing);\n+\n+        subHandlers = Collections.synchronizedMap(new HashMap<>());\n+        metadataSubHandlers = Collections.synchronizedList(new LinkedList<>());\n+        converters = Collections.synchronizedMap(new HashMap<>());\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        LcnModuleConfiguration localConfig = getConfigAs(LcnModuleConfiguration.class);\n+        LcnAddrMod localModuleAddress = moduleAddress = new LcnAddrMod(localConfig.segmentId, localConfig.moduleId);\n+\n+        try {\n+            // create sub handlers\n+            ModInfo info = getPckGatewayHandler().getModInfo(localModuleAddress);\n+            for (LcnChannelGroup type : LcnChannelGroup.values()) {\n+                AbstractLcnModuleSubHandler newHandler = type.getSubHandlerClass()\n+                        .getDeclaredConstructor(LcnModuleHandler.class, ModInfo.class).newInstance(this, info);\n+\n+                subHandlers.put(type, newHandler);\n+            }\n+\n+            // meta sub handlers, which are not assigned to a channel group\n+            metadataSubHandlers.add(new LcnModuleMetaAckSubHandler(this, info));\n+            metadataSubHandlers.add(new LcnModuleMetaFirmwareSubHandler(this, info));\n+\n+            // initialize variable value converters\n+            for (Channel channel : thing.getChannels()) {\n+                Object unitObject = channel.getConfiguration().get(\"unit\");\n+                Object parameterObject = channel.getConfiguration().get(\"parameter\");\n+\n+                if (unitObject instanceof String) {\n+                    switch ((String) unitObject) {\n+                        case \"temperature\":\n+                            converters.put(channel.getUID(), new TemperatureConverter());\n+                            break;\n+                        case \"light\":\n+                            converters.put(channel.getUID(), new LightConverter());\n+                            break;\n+                        case \"co2\":\n+                            converters.put(channel.getUID(), new Co2Converter());\n+                            break;\n+                        case \"power\":\n+                            converters.put(channel.getUID(), new PowerConverter(parameterObject));\n+                            break;\n+                        case \"energy\":\n+                            converters.put(channel.getUID(), new EnergyConverter(parameterObject));\n+                            break;\n+                        case \"current\":\n+                            converters.put(channel.getUID(), new CurrentConverter());\n+                            break;\n+                        case \"voltage\":\n+                            converters.put(channel.getUID(), new VoltageConverter());\n+                            break;\n+                        case \"angle\":\n+                            converters.put(channel.getUID(), new AngleConverter());\n+                            break;\n+                        case \"windspeed\":\n+                            converters.put(channel.getUID(), new WindspeedConverter());\n+                            break;\n+                    }\n+                }\n+            }\n+\n+            // module is assumed as online, when the corresponding Bridge (PckGatewayHandler) is online.\n+            updateStatus(ThingStatus.ONLINE);\n+        } catch (LcnException | InstantiationException | IllegalAccessException | IllegalArgumentException\n+                | InvocationTargetException | NoSuchMethodException | SecurityException e) {\n+            logger.warn(\"Failed to initialize handler: {}: {}: {}\", localModuleAddress, e.getClass().getSimpleName(),\n+                    e.getMessage());\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, e.getMessage());\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUid, Command command) {\n+        try {\n+            String groupId = channelUid.getGroupId();\n+\n+            if (!channelUid.isInGroup()) {\n+                return;\n+            }\n+\n+            if (groupId == null) {\n+                throw new LcnException(\"Group ID is null\");\n+            }\n+\n+            LcnChannelGroup channelGroup = LcnChannelGroup.valueOf(groupId.toUpperCase());\n+            AbstractLcnModuleSubHandler subHandler = subHandlers.get(channelGroup);\n+\n+            if (subHandler == null) {\n+                throw new LcnException(\"Sub Handler not found for: \" + channelGroup);\n+            }\n+\n+            Optional<Integer> number = channelUidToChannelNumber(channelUid, channelGroup);\n+\n+            if (command instanceof RefreshType) {\n+                number.ifPresent(n -> subHandler.handleRefresh(channelGroup, n));\n+                subHandler.handleRefresh(channelUid.getIdWithoutGroup());\n+            } else if (command instanceof OnOffType) {\n+                subHandler.handleCommandOnOff(castCommand(command), channelGroup, number.get());\n+            } else if (command instanceof DimmerOutputCommand) {\n+                subHandler.handleCommandDimmerOutput(castCommand(command), number.get());\n+            } else if (command instanceof PercentType && number.isPresent()) {\n+                subHandler.handleCommandPercent(castCommand(command), channelGroup, number.get());\n+            } else if (command instanceof HSBType) {\n+                subHandler.handleCommandHsb(castCommand(command), channelUid.getIdWithoutGroup());\n+            } else if (command instanceof PercentType) {\n+                subHandler.handleCommandPercent(castCommand(command), channelGroup, channelUid.getIdWithoutGroup());\n+            } else if (command instanceof StringType) {\n+                subHandler.handleCommandString(castCommand(command), number.get());\n+            } else if (command instanceof DecimalType) {\n+                DecimalType decimalType = castCommand(command);\n+                DecimalType nativeValue = getConverter(channelUid).onCommandFromItem(decimalType.doubleValue());\n+                subHandler.handleCommandDecimal(nativeValue, channelGroup, number.get());\n+            } else if (command instanceof QuantityType) {\n+                QuantityType<?> quantityType = castCommand(command);\n+                DecimalType nativeValue = getConverter(channelUid).onCommandFromItem(quantityType);\n+                subHandler.handleCommandDecimal(nativeValue, channelGroup, number.get());\n+            } else if (command instanceof UpDownType) {\n+                subHandler.handleCommandUpDown(castCommand(command), channelGroup, number.get());\n+            } else if (command instanceof StopMoveType) {\n+                subHandler.handleCommandStopMove(castCommand(command), channelGroup, number.get());\n+            } else {\n+                throw new LcnException(\"Unsupported command type\");\n+            }\n+        } catch (IllegalArgumentException | NoSuchElementException | LcnException e) {\n+            logger.warn(\"{}: Failed to handle command {}: {}\", channelUid, command.getClass().getSimpleName(),\n+                    e.getMessage());\n+        }\n+    }\n+\n+    @NonNullByDefault({}) // getOrDefault()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ce02f433e5d4071dbebb9ee68da0e22895887b6b"}, "originalPosition": 218}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjM5ODUzMw==", "bodyText": "I'd think this helper class can be removed - see my comments above in the discovery service.", "url": "https://github.com/openhab/openhab-addons/pull/7509#discussion_r436398533", "createdAt": "2020-06-07T20:22:42Z", "author": {"login": "kaikreuzer"}, "path": "bundles/org.openhab.binding.lcn/src/main/java/org/openhab/binding/lcn/internal/common/NullScheduledFuture.java", "diffHunk": "@@ -0,0 +1,80 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.lcn.internal.common;\n+\n+import java.util.concurrent.Delayed;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+\n+/**\n+ * Empty ScheduledFuture, used for initialization.\n+ *\n+ * @author Fabian Wolter - Initial Contribution\n+ */\n+@NonNullByDefault\n+public class NullScheduledFuture implements ScheduledFuture<Object> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ce02f433e5d4071dbebb9ee68da0e22895887b6b"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjM5OTAwMg==", "bodyText": "As this seems to be an optional parameter, it should be defined that a default of 1000 is used, if it is not provided and the logging here could just be debug level.", "url": "https://github.com/openhab/openhab-addons/pull/7509#discussion_r436399002", "createdAt": "2020-06-07T20:29:34Z", "author": {"login": "kaikreuzer"}, "path": "bundles/org.openhab.binding.lcn/src/main/java/org/openhab/binding/lcn/internal/converter/AbstractS0Converter.java", "diffHunk": "@@ -0,0 +1,52 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.lcn.internal.converter;\n+\n+import java.math.BigDecimal;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Base class for S0 counter value converters.\n+ *\n+ * @author Fabian Wolter - Initial Contribution\n+ */\n+@NonNullByDefault\n+public abstract class AbstractS0Converter extends AbstractVariableValueConverter {\n+    private final Logger logger = LoggerFactory.getLogger(AbstractS0Converter.class);\n+    protected double pulsesPerKwh;\n+\n+    public AbstractS0Converter(@Nullable Object parameter) {\n+        if (parameter == null) {\n+            pulsesPerKwh = 1000;\n+            logger.info(\"Pulses per kWh not set. Assuming 1000 imp./kWh.\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ce02f433e5d4071dbebb9ee68da0e22895887b6b"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQwMDk1OA==", "bodyText": "Should you add the default of 1000 here?", "url": "https://github.com/openhab/openhab-addons/pull/7509#discussion_r436400958", "createdAt": "2020-06-07T20:55:17Z", "author": {"login": "kaikreuzer"}, "path": "bundles/org.openhab.binding.lcn/src/main/resources/ESH-INF/config/config.xml", "diffHunk": "@@ -0,0 +1,101 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<config-description:config-descriptions\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:config-description=\"https://openhab.org/schemas/config-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/config-description/v1.0.0\n+\thttps://openhab.org/schemas/config-description-1.0.0.xsd\">\n+\n+\t<config-description uri=\"thing-type:lcn:pckGateway\">\n+\t\t<parameter name=\"hostname\" type=\"text\" required=\"true\">\n+\t\t\t<label>Hostname</label>\n+\t\t\t<description>The hostname or the IP address of the PCK gateway</description>\n+\t\t\t<context>network-address</context>\n+\t\t\t<required>true</required>\n+\t\t</parameter>\n+\t\t<parameter name=\"port\" type=\"integer\" required=\"true\" min=\"1\" max=\"65535\">\n+\t\t\t<label>Port</label>\n+\t\t\t<description>The IP port of the PCK gateway</description>\n+\t\t\t<default>4114</default>\n+\t\t\t<required>true</required>\n+\t\t</parameter>\n+\t\t<parameter name=\"username\" type=\"text\" required=\"true\">\n+\t\t\t<label>Username</label>\n+\t\t\t<description>The login username of the PCK gateway</description>\n+\t\t\t<required>true</required>\n+\t\t</parameter>\n+\t\t<parameter name=\"password\" type=\"text\" required=\"true\">\n+\t\t\t<label>Password</label>\n+\t\t\t<description>The login password of the PCK gateway</description>\n+\t\t\t<context>password</context>\n+\t\t</parameter>\n+\t\t<parameter name=\"mode\" type=\"text\" required=\"true\">\n+\t\t\t<label>Dimming Mode</label>\n+\t\t\t<description><![CDATA[<strong>IMPORTANT:</strong> Dimming range of all modules. Must be the same value as configured in LCN-PRO (Options/Settings/Expert Settings). If you <em>only</em> have modules with firmware newer than Feb. 2013, you probably want to choose 0 - 200.]]></description>\n+\t\t\t<default>native200</default>\n+\t\t\t<options>\n+\t\t\t\t<option value=\"native50\">0 - 50</option>\n+\t\t\t\t<option value=\"native200\">0 - 200</option>\n+\t\t\t</options>\n+\t\t\t<required>true</required>\n+\t\t</parameter>\n+\t\t<parameter name=\"timeoutMs\" type=\"integer\" required=\"true\" unit=\"ms\">\n+\t\t\t<label>Connection Timeout</label>\n+\t\t\t<description>Period after which an LCN command is resent, when no acknowledge has been received (in ms).</description>\n+\t\t\t<default>3500</default>\n+\t\t\t<required>true</required>\n+\t\t</parameter>\n+\t</config-description>\n+\n+\t<config-description uri=\"thing-type:lcn:module\">\n+\t\t<parameter name=\"moduleId\" type=\"integer\" required=\"true\" min=\"5\" max=\"254\">\n+\t\t\t<label>Module ID</label>\n+\t\t\t<description>The module ID, configured in LCN-PRO</description>\n+\t\t</parameter>\n+\t\t<parameter name=\"segmentId\" type=\"integer\" required=\"true\" min=\"0\" max=\"128\">\n+\t\t\t<label>Segment ID</label>\n+\t\t\t<description>The segment ID the module is in (0 if no segments are present)</description>\n+\t\t</parameter>\n+\t</config-description>\n+\n+\t<config-description uri=\"thing-type:lcn:group\">\n+\t\t<parameter name=\"groupId\" type=\"integer\" required=\"true\" min=\"3\" max=\"254\">\n+\t\t\t<label>Group Number</label>\n+\t\t\t<description>The group number, configured in LCN-PRO</description>\n+\t\t</parameter>\n+\t\t<parameter name=\"moduleId\" type=\"integer\" required=\"true\" min=\"5\" max=\"254\">\n+\t\t\t<label>Module ID</label>\n+\t\t\t<description>The module ID of any module in the group. The state of this module is used for visualization of the\n+\t\t\t\tgroup as representative for all modules.</description>\n+\t\t</parameter>\n+\t\t<parameter name=\"segmentId\" type=\"integer\" required=\"true\" min=\"0\" max=\"128\">\n+\t\t\t<label>Segment ID</label>\n+\t\t\t<description>The segment ID of all modules in this group (0 if no segments are present)</description>\n+\t\t\t<default>0</default>\n+\t\t</parameter>\n+\t</config-description>\n+\n+\t<config-description uri=\"channel-type:lcn:variable\">\n+\t\t<parameter name=\"unit\" type=\"text\" required=\"true\">\n+\t\t\t<label>Unit</label>\n+\t\t\t<description>Unit of the sensor</description>\n+\t\t\t<default>native</default>\n+\t\t\t<options>\n+\t\t\t\t<option value=\"native\">LCN Native</option>\n+\t\t\t\t<option value=\"temperature\">Temperature (\u00b0C or \u00b0F)</option>\n+\t\t\t\t<option value=\"light\">Light (Lux)</option>\n+\t\t\t\t<option value=\"co2\">CO\u2082 (ppm)</option>\n+\t\t\t\t<option value=\"power\">Power (W)</option>\n+\t\t\t\t<option value=\"energy\">Energy (kWh)</option>\n+\t\t\t\t<option value=\"current\">Current (mA)</option>\n+\t\t\t\t<option value=\"voltage\">Voltage (V)</option>\n+\t\t\t\t<option value=\"angle\">Angle (\u00b0)</option>\n+\t\t\t\t<option value=\"windspeed\">Windspeed (m/s)</option>\n+\t\t\t</options>\n+\t\t\t<required>true</required>\n+\t\t</parameter>\n+\t\t<parameter name=\"parameter\" type=\"integer\" min=\"1\">", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ce02f433e5d4071dbebb9ee68da0e22895887b6b"}, "originalPosition": 96}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQwMTA4OA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\t<item-type>Roller Shutter</item-type>\n          \n          \n            \n            \t\t<item-type>Rollershutter</item-type>", "url": "https://github.com/openhab/openhab-addons/pull/7509#discussion_r436401088", "createdAt": "2020-06-07T20:56:51Z", "author": {"login": "kaikreuzer"}, "path": "bundles/org.openhab.binding.lcn/src/main/resources/ESH-INF/thing/thing-types.xml", "diffHunk": "@@ -0,0 +1,637 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"lcn\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\n+\t<bridge-type id=\"pckGateway\">\n+\t\t<label>LCN-PCHK Gateway</label>\n+\t\t<description>An LCN gateway speaking the PCK language. E.g. LCN-PCHK software or the DIN rail device LCN-PKE.</description>\n+\n+\t\t<config-description-ref uri=\"thing-type:lcn:pckGateway\"/>\n+\t</bridge-type>\n+\n+\t<thing-type id=\"module\">\n+\t\t<supported-bridge-type-refs>\n+\t\t\t<bridge-type-ref id=\"pckGateway\"/>\n+\t\t</supported-bridge-type-refs>\n+\n+\t\t<label>LCN Module</label>\n+\t\t<description>An LCN bus module, e.g. LCN-UPP, LCN-SH, LCN-HU</description>\n+\n+\t\t<channel-groups>\n+\t\t\t<channel-group typeId=\"outputs\" id=\"output\"/>\n+\t\t\t<channel-group typeId=\"rollershutteroutputs\" id=\"rollershutteroutput\"/>\n+\t\t\t<channel-group typeId=\"leds\" id=\"led\"/>\n+\t\t\t<channel-group typeId=\"relays\" id=\"relay\"/>\n+\t\t\t<channel-group typeId=\"rollershutterrelays\" id=\"rollershutterrelay\"/>\n+\t\t\t<channel-group typeId=\"logics\" id=\"logic\"/>\n+\t\t\t<channel-group typeId=\"binarysensors\" id=\"binarysensor\"/>\n+\t\t\t<channel-group typeId=\"variables\" id=\"variable\"/>\n+\t\t\t<channel-group typeId=\"rvarsetpoints\" id=\"rvarsetpoint\"/>\n+\t\t\t<channel-group typeId=\"rvarlocks\" id=\"rvarlock\"/>\n+\t\t\t<channel-group typeId=\"thresholdregisters1\" id=\"thresholdregister1\"/>\n+\t\t\t<channel-group typeId=\"thresholdregisters2\" id=\"thresholdregister2\"/>\n+\t\t\t<channel-group typeId=\"thresholdregisters3\" id=\"thresholdregister3\"/>\n+\t\t\t<channel-group typeId=\"thresholdregisters4\" id=\"thresholdregister4\"/>\n+\t\t\t<channel-group typeId=\"s0inputs\" id=\"s0input\"/>\n+\t\t\t<channel-group typeId=\"keyslocktablea\" id=\"keylocktablea\"/>\n+\t\t\t<channel-group typeId=\"keyslocktableb\" id=\"keylocktableb\"/>\n+\t\t\t<channel-group typeId=\"keyslocktablec\" id=\"keylocktablec\"/>\n+\t\t\t<channel-group typeId=\"keyslocktabled\" id=\"keylocktabled\"/>\n+\t\t\t<channel-group typeId=\"codes\" id=\"code\"/>\n+\t\t</channel-groups>\n+\n+\t\t<config-description-ref uri=\"thing-type:lcn:module\"/>\n+\t</thing-type>\n+\n+\t<thing-type id=\"group\">\n+\t\t<supported-bridge-type-refs>\n+\t\t\t<bridge-type-ref id=\"pckGateway\"/>\n+\t\t</supported-bridge-type-refs>\n+\n+\t\t<label>LCN Group</label>\n+\t\t<description>An LCN group with multiple modules, configured in LCN-PRO</description>\n+\n+\t\t<channel-groups>\n+\t\t\t<channel-group typeId=\"outputs\" id=\"output\"/>\n+\t\t\t<channel-group typeId=\"rollershutteroutputs\" id=\"rollershutteroutput\"/>\n+\t\t\t<channel-group typeId=\"leds\" id=\"led\"/>\n+\t\t\t<channel-group typeId=\"relays\" id=\"relay\"/>\n+\t\t\t<channel-group typeId=\"rollershutterrelays\" id=\"rollershutterrelay\"/>\n+\t\t\t<channel-group typeId=\"logics\" id=\"logic\"/>\n+\t\t\t<channel-group typeId=\"binarysensors\" id=\"binarysensor\"/>\n+\t\t\t<channel-group typeId=\"variables\" id=\"variable\"/>\n+\t\t\t<channel-group typeId=\"rvarsetpoints\" id=\"rvarsetpoint\"/>\n+\t\t\t<channel-group typeId=\"rvarlocks\" id=\"rvarlock\"/>\n+\t\t\t<channel-group typeId=\"thresholdregisters1\" id=\"thresholdregister1\"/>\n+\t\t\t<channel-group typeId=\"thresholdregisters2\" id=\"thresholdregister2\"/>\n+\t\t\t<channel-group typeId=\"thresholdregisters3\" id=\"thresholdregister3\"/>\n+\t\t\t<channel-group typeId=\"thresholdregisters4\" id=\"thresholdregister4\"/>\n+\t\t\t<channel-group typeId=\"s0inputs\" id=\"s0input\"/>\n+\t\t\t<channel-group typeId=\"keyslocktablea\" id=\"keylocktablea\"/>\n+\t\t\t<channel-group typeId=\"keyslocktableb\" id=\"keylocktableb\"/>\n+\t\t\t<channel-group typeId=\"keyslocktablec\" id=\"keylocktablec\"/>\n+\t\t\t<channel-group typeId=\"keyslocktabled\" id=\"keylocktabled\"/>\n+\t\t\t<channel-group typeId=\"codes\" id=\"code\"/>\n+\t\t</channel-groups>\n+\n+\t\t<config-description-ref uri=\"thing-type:lcn:group\"/>\n+\t</thing-type>\n+\n+\t<channel-type id=\"output\" advanced=\"true\">\n+\t\t<item-type>Dimmer</item-type>\n+\t\t<label>Output</label>\n+\t\t<autoUpdatePolicy>veto</autoUpdatePolicy>\n+\t</channel-type>\n+\n+\t<channel-type id=\"color\" advanced=\"true\">\n+\t\t<item-type>Color</item-type>\n+\t\t<label>Color</label>\n+\t\t<autoUpdatePolicy>veto</autoUpdatePolicy>\n+\t</channel-type>\n+\n+\t<channel-group-type id=\"outputs\">\n+\t\t<label>Dimmer Outputs</label>\n+\t\t<channels>\n+\t\t\t<channel typeId=\"output\" id=\"1\">\n+\t\t\t\t<label>Output 1</label>\n+\t\t\t</channel>\n+\t\t\t<channel typeId=\"output\" id=\"2\">\n+\t\t\t\t<label>Output 2</label>\n+\t\t\t</channel>\n+\t\t\t<channel typeId=\"output\" id=\"3\">\n+\t\t\t\t<label>Output 3</label>\n+\t\t\t</channel>\n+\t\t\t<channel typeId=\"output\" id=\"4\">\n+\t\t\t\t<label>Output 4</label>\n+\t\t\t</channel>\n+\t\t\t<channel typeId=\"color\" id=\"color\">\n+\t\t\t\t<label>RGB Color Control (Outputs 1-3)</label>\n+\t\t\t</channel>\n+\t\t</channels>\n+\t</channel-group-type>\n+\n+\t<channel-type id=\"relay\" advanced=\"true\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Relay</label>\n+\t\t<autoUpdatePolicy>veto</autoUpdatePolicy>\n+\t</channel-type>\n+\n+\t<channel-group-type id=\"relays\">\n+\t\t<label>Relays</label>\n+\t\t<channels>\n+\t\t\t<channel typeId=\"relay\" id=\"1\">\n+\t\t\t\t<label>Relay 1</label>\n+\t\t\t</channel>\n+\t\t\t<channel typeId=\"relay\" id=\"2\">\n+\t\t\t\t<label>Relay 2</label>\n+\t\t\t</channel>\n+\t\t\t<channel typeId=\"relay\" id=\"3\">\n+\t\t\t\t<label>Relay 3</label>\n+\t\t\t</channel>\n+\t\t\t<channel typeId=\"relay\" id=\"4\">\n+\t\t\t\t<label>Relay 4</label>\n+\t\t\t</channel>\n+\t\t\t<channel typeId=\"relay\" id=\"5\">\n+\t\t\t\t<label>Relay 5</label>\n+\t\t\t</channel>\n+\t\t\t<channel typeId=\"relay\" id=\"6\">\n+\t\t\t\t<label>Relay 6</label>\n+\t\t\t</channel>\n+\t\t\t<channel typeId=\"relay\" id=\"7\">\n+\t\t\t\t<label>Relay 7</label>\n+\t\t\t</channel>\n+\t\t\t<channel typeId=\"relay\" id=\"8\">\n+\t\t\t\t<label>Relay 8</label>\n+\t\t\t</channel>\n+\t\t</channels>\n+\t</channel-group-type>\n+\n+\t<channel-type id=\"rollershutter\" advanced=\"true\">\n+\t\t<item-type>Roller Shutter</item-type>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ce02f433e5d4071dbebb9ee68da0e22895887b6b"}, "originalPosition": 151}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQwMTIzNg==", "bodyText": "Channel labels should be as short as possible, best <20 chars, 2-3 words only to fit on small screens.\nCan you come up with something better? (e.g. \"Shutter 1-2\" or something along these lines)", "url": "https://github.com/openhab/openhab-addons/pull/7509#discussion_r436401236", "createdAt": "2020-06-07T20:58:54Z", "author": {"login": "kaikreuzer"}, "path": "bundles/org.openhab.binding.lcn/src/main/resources/ESH-INF/thing/thing-types.xml", "diffHunk": "@@ -0,0 +1,637 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"lcn\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\n+\t<bridge-type id=\"pckGateway\">\n+\t\t<label>LCN-PCHK Gateway</label>\n+\t\t<description>An LCN gateway speaking the PCK language. E.g. LCN-PCHK software or the DIN rail device LCN-PKE.</description>\n+\n+\t\t<config-description-ref uri=\"thing-type:lcn:pckGateway\"/>\n+\t</bridge-type>\n+\n+\t<thing-type id=\"module\">\n+\t\t<supported-bridge-type-refs>\n+\t\t\t<bridge-type-ref id=\"pckGateway\"/>\n+\t\t</supported-bridge-type-refs>\n+\n+\t\t<label>LCN Module</label>\n+\t\t<description>An LCN bus module, e.g. LCN-UPP, LCN-SH, LCN-HU</description>\n+\n+\t\t<channel-groups>\n+\t\t\t<channel-group typeId=\"outputs\" id=\"output\"/>\n+\t\t\t<channel-group typeId=\"rollershutteroutputs\" id=\"rollershutteroutput\"/>\n+\t\t\t<channel-group typeId=\"leds\" id=\"led\"/>\n+\t\t\t<channel-group typeId=\"relays\" id=\"relay\"/>\n+\t\t\t<channel-group typeId=\"rollershutterrelays\" id=\"rollershutterrelay\"/>\n+\t\t\t<channel-group typeId=\"logics\" id=\"logic\"/>\n+\t\t\t<channel-group typeId=\"binarysensors\" id=\"binarysensor\"/>\n+\t\t\t<channel-group typeId=\"variables\" id=\"variable\"/>\n+\t\t\t<channel-group typeId=\"rvarsetpoints\" id=\"rvarsetpoint\"/>\n+\t\t\t<channel-group typeId=\"rvarlocks\" id=\"rvarlock\"/>\n+\t\t\t<channel-group typeId=\"thresholdregisters1\" id=\"thresholdregister1\"/>\n+\t\t\t<channel-group typeId=\"thresholdregisters2\" id=\"thresholdregister2\"/>\n+\t\t\t<channel-group typeId=\"thresholdregisters3\" id=\"thresholdregister3\"/>\n+\t\t\t<channel-group typeId=\"thresholdregisters4\" id=\"thresholdregister4\"/>\n+\t\t\t<channel-group typeId=\"s0inputs\" id=\"s0input\"/>\n+\t\t\t<channel-group typeId=\"keyslocktablea\" id=\"keylocktablea\"/>\n+\t\t\t<channel-group typeId=\"keyslocktableb\" id=\"keylocktableb\"/>\n+\t\t\t<channel-group typeId=\"keyslocktablec\" id=\"keylocktablec\"/>\n+\t\t\t<channel-group typeId=\"keyslocktabled\" id=\"keylocktabled\"/>\n+\t\t\t<channel-group typeId=\"codes\" id=\"code\"/>\n+\t\t</channel-groups>\n+\n+\t\t<config-description-ref uri=\"thing-type:lcn:module\"/>\n+\t</thing-type>\n+\n+\t<thing-type id=\"group\">\n+\t\t<supported-bridge-type-refs>\n+\t\t\t<bridge-type-ref id=\"pckGateway\"/>\n+\t\t</supported-bridge-type-refs>\n+\n+\t\t<label>LCN Group</label>\n+\t\t<description>An LCN group with multiple modules, configured in LCN-PRO</description>\n+\n+\t\t<channel-groups>\n+\t\t\t<channel-group typeId=\"outputs\" id=\"output\"/>\n+\t\t\t<channel-group typeId=\"rollershutteroutputs\" id=\"rollershutteroutput\"/>\n+\t\t\t<channel-group typeId=\"leds\" id=\"led\"/>\n+\t\t\t<channel-group typeId=\"relays\" id=\"relay\"/>\n+\t\t\t<channel-group typeId=\"rollershutterrelays\" id=\"rollershutterrelay\"/>\n+\t\t\t<channel-group typeId=\"logics\" id=\"logic\"/>\n+\t\t\t<channel-group typeId=\"binarysensors\" id=\"binarysensor\"/>\n+\t\t\t<channel-group typeId=\"variables\" id=\"variable\"/>\n+\t\t\t<channel-group typeId=\"rvarsetpoints\" id=\"rvarsetpoint\"/>\n+\t\t\t<channel-group typeId=\"rvarlocks\" id=\"rvarlock\"/>\n+\t\t\t<channel-group typeId=\"thresholdregisters1\" id=\"thresholdregister1\"/>\n+\t\t\t<channel-group typeId=\"thresholdregisters2\" id=\"thresholdregister2\"/>\n+\t\t\t<channel-group typeId=\"thresholdregisters3\" id=\"thresholdregister3\"/>\n+\t\t\t<channel-group typeId=\"thresholdregisters4\" id=\"thresholdregister4\"/>\n+\t\t\t<channel-group typeId=\"s0inputs\" id=\"s0input\"/>\n+\t\t\t<channel-group typeId=\"keyslocktablea\" id=\"keylocktablea\"/>\n+\t\t\t<channel-group typeId=\"keyslocktableb\" id=\"keylocktableb\"/>\n+\t\t\t<channel-group typeId=\"keyslocktablec\" id=\"keylocktablec\"/>\n+\t\t\t<channel-group typeId=\"keyslocktabled\" id=\"keylocktabled\"/>\n+\t\t\t<channel-group typeId=\"codes\" id=\"code\"/>\n+\t\t</channel-groups>\n+\n+\t\t<config-description-ref uri=\"thing-type:lcn:group\"/>\n+\t</thing-type>\n+\n+\t<channel-type id=\"output\" advanced=\"true\">\n+\t\t<item-type>Dimmer</item-type>\n+\t\t<label>Output</label>\n+\t\t<autoUpdatePolicy>veto</autoUpdatePolicy>\n+\t</channel-type>\n+\n+\t<channel-type id=\"color\" advanced=\"true\">\n+\t\t<item-type>Color</item-type>\n+\t\t<label>Color</label>\n+\t\t<autoUpdatePolicy>veto</autoUpdatePolicy>\n+\t</channel-type>\n+\n+\t<channel-group-type id=\"outputs\">\n+\t\t<label>Dimmer Outputs</label>\n+\t\t<channels>\n+\t\t\t<channel typeId=\"output\" id=\"1\">\n+\t\t\t\t<label>Output 1</label>\n+\t\t\t</channel>\n+\t\t\t<channel typeId=\"output\" id=\"2\">\n+\t\t\t\t<label>Output 2</label>\n+\t\t\t</channel>\n+\t\t\t<channel typeId=\"output\" id=\"3\">\n+\t\t\t\t<label>Output 3</label>\n+\t\t\t</channel>\n+\t\t\t<channel typeId=\"output\" id=\"4\">\n+\t\t\t\t<label>Output 4</label>\n+\t\t\t</channel>\n+\t\t\t<channel typeId=\"color\" id=\"color\">\n+\t\t\t\t<label>RGB Color Control (Outputs 1-3)</label>\n+\t\t\t</channel>\n+\t\t</channels>\n+\t</channel-group-type>\n+\n+\t<channel-type id=\"relay\" advanced=\"true\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Relay</label>\n+\t\t<autoUpdatePolicy>veto</autoUpdatePolicy>\n+\t</channel-type>\n+\n+\t<channel-group-type id=\"relays\">\n+\t\t<label>Relays</label>\n+\t\t<channels>\n+\t\t\t<channel typeId=\"relay\" id=\"1\">\n+\t\t\t\t<label>Relay 1</label>\n+\t\t\t</channel>\n+\t\t\t<channel typeId=\"relay\" id=\"2\">\n+\t\t\t\t<label>Relay 2</label>\n+\t\t\t</channel>\n+\t\t\t<channel typeId=\"relay\" id=\"3\">\n+\t\t\t\t<label>Relay 3</label>\n+\t\t\t</channel>\n+\t\t\t<channel typeId=\"relay\" id=\"4\">\n+\t\t\t\t<label>Relay 4</label>\n+\t\t\t</channel>\n+\t\t\t<channel typeId=\"relay\" id=\"5\">\n+\t\t\t\t<label>Relay 5</label>\n+\t\t\t</channel>\n+\t\t\t<channel typeId=\"relay\" id=\"6\">\n+\t\t\t\t<label>Relay 6</label>\n+\t\t\t</channel>\n+\t\t\t<channel typeId=\"relay\" id=\"7\">\n+\t\t\t\t<label>Relay 7</label>\n+\t\t\t</channel>\n+\t\t\t<channel typeId=\"relay\" id=\"8\">\n+\t\t\t\t<label>Relay 8</label>\n+\t\t\t</channel>\n+\t\t</channels>\n+\t</channel-group-type>\n+\n+\t<channel-type id=\"rollershutter\" advanced=\"true\">\n+\t\t<item-type>Roller Shutter</item-type>\n+\t\t<label>Roller Shutter</label>\n+\t\t<autoUpdatePolicy>veto</autoUpdatePolicy>\n+\t</channel-type>\n+\n+\t<channel-group-type id=\"rollershutterrelays\">\n+\t\t<label>Roller Shutter on Relays</label>\n+\t\t<channels>\n+\t\t\t<channel typeId=\"rollershutter\" id=\"1\">\n+\t\t\t\t<label>Roller Shutter on Relay 1-2</label>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ce02f433e5d4071dbebb9ee68da0e22895887b6b"}, "originalPosition": 160}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQwMTI0Mw==", "bodyText": "please shorten", "url": "https://github.com/openhab/openhab-addons/pull/7509#discussion_r436401243", "createdAt": "2020-06-07T20:59:06Z", "author": {"login": "kaikreuzer"}, "path": "bundles/org.openhab.binding.lcn/src/main/resources/ESH-INF/thing/thing-types.xml", "diffHunk": "@@ -0,0 +1,637 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"lcn\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\n+\t<bridge-type id=\"pckGateway\">\n+\t\t<label>LCN-PCHK Gateway</label>\n+\t\t<description>An LCN gateway speaking the PCK language. E.g. LCN-PCHK software or the DIN rail device LCN-PKE.</description>\n+\n+\t\t<config-description-ref uri=\"thing-type:lcn:pckGateway\"/>\n+\t</bridge-type>\n+\n+\t<thing-type id=\"module\">\n+\t\t<supported-bridge-type-refs>\n+\t\t\t<bridge-type-ref id=\"pckGateway\"/>\n+\t\t</supported-bridge-type-refs>\n+\n+\t\t<label>LCN Module</label>\n+\t\t<description>An LCN bus module, e.g. LCN-UPP, LCN-SH, LCN-HU</description>\n+\n+\t\t<channel-groups>\n+\t\t\t<channel-group typeId=\"outputs\" id=\"output\"/>\n+\t\t\t<channel-group typeId=\"rollershutteroutputs\" id=\"rollershutteroutput\"/>\n+\t\t\t<channel-group typeId=\"leds\" id=\"led\"/>\n+\t\t\t<channel-group typeId=\"relays\" id=\"relay\"/>\n+\t\t\t<channel-group typeId=\"rollershutterrelays\" id=\"rollershutterrelay\"/>\n+\t\t\t<channel-group typeId=\"logics\" id=\"logic\"/>\n+\t\t\t<channel-group typeId=\"binarysensors\" id=\"binarysensor\"/>\n+\t\t\t<channel-group typeId=\"variables\" id=\"variable\"/>\n+\t\t\t<channel-group typeId=\"rvarsetpoints\" id=\"rvarsetpoint\"/>\n+\t\t\t<channel-group typeId=\"rvarlocks\" id=\"rvarlock\"/>\n+\t\t\t<channel-group typeId=\"thresholdregisters1\" id=\"thresholdregister1\"/>\n+\t\t\t<channel-group typeId=\"thresholdregisters2\" id=\"thresholdregister2\"/>\n+\t\t\t<channel-group typeId=\"thresholdregisters3\" id=\"thresholdregister3\"/>\n+\t\t\t<channel-group typeId=\"thresholdregisters4\" id=\"thresholdregister4\"/>\n+\t\t\t<channel-group typeId=\"s0inputs\" id=\"s0input\"/>\n+\t\t\t<channel-group typeId=\"keyslocktablea\" id=\"keylocktablea\"/>\n+\t\t\t<channel-group typeId=\"keyslocktableb\" id=\"keylocktableb\"/>\n+\t\t\t<channel-group typeId=\"keyslocktablec\" id=\"keylocktablec\"/>\n+\t\t\t<channel-group typeId=\"keyslocktabled\" id=\"keylocktabled\"/>\n+\t\t\t<channel-group typeId=\"codes\" id=\"code\"/>\n+\t\t</channel-groups>\n+\n+\t\t<config-description-ref uri=\"thing-type:lcn:module\"/>\n+\t</thing-type>\n+\n+\t<thing-type id=\"group\">\n+\t\t<supported-bridge-type-refs>\n+\t\t\t<bridge-type-ref id=\"pckGateway\"/>\n+\t\t</supported-bridge-type-refs>\n+\n+\t\t<label>LCN Group</label>\n+\t\t<description>An LCN group with multiple modules, configured in LCN-PRO</description>\n+\n+\t\t<channel-groups>\n+\t\t\t<channel-group typeId=\"outputs\" id=\"output\"/>\n+\t\t\t<channel-group typeId=\"rollershutteroutputs\" id=\"rollershutteroutput\"/>\n+\t\t\t<channel-group typeId=\"leds\" id=\"led\"/>\n+\t\t\t<channel-group typeId=\"relays\" id=\"relay\"/>\n+\t\t\t<channel-group typeId=\"rollershutterrelays\" id=\"rollershutterrelay\"/>\n+\t\t\t<channel-group typeId=\"logics\" id=\"logic\"/>\n+\t\t\t<channel-group typeId=\"binarysensors\" id=\"binarysensor\"/>\n+\t\t\t<channel-group typeId=\"variables\" id=\"variable\"/>\n+\t\t\t<channel-group typeId=\"rvarsetpoints\" id=\"rvarsetpoint\"/>\n+\t\t\t<channel-group typeId=\"rvarlocks\" id=\"rvarlock\"/>\n+\t\t\t<channel-group typeId=\"thresholdregisters1\" id=\"thresholdregister1\"/>\n+\t\t\t<channel-group typeId=\"thresholdregisters2\" id=\"thresholdregister2\"/>\n+\t\t\t<channel-group typeId=\"thresholdregisters3\" id=\"thresholdregister3\"/>\n+\t\t\t<channel-group typeId=\"thresholdregisters4\" id=\"thresholdregister4\"/>\n+\t\t\t<channel-group typeId=\"s0inputs\" id=\"s0input\"/>\n+\t\t\t<channel-group typeId=\"keyslocktablea\" id=\"keylocktablea\"/>\n+\t\t\t<channel-group typeId=\"keyslocktableb\" id=\"keylocktableb\"/>\n+\t\t\t<channel-group typeId=\"keyslocktablec\" id=\"keylocktablec\"/>\n+\t\t\t<channel-group typeId=\"keyslocktabled\" id=\"keylocktabled\"/>\n+\t\t\t<channel-group typeId=\"codes\" id=\"code\"/>\n+\t\t</channel-groups>\n+\n+\t\t<config-description-ref uri=\"thing-type:lcn:group\"/>\n+\t</thing-type>\n+\n+\t<channel-type id=\"output\" advanced=\"true\">\n+\t\t<item-type>Dimmer</item-type>\n+\t\t<label>Output</label>\n+\t\t<autoUpdatePolicy>veto</autoUpdatePolicy>\n+\t</channel-type>\n+\n+\t<channel-type id=\"color\" advanced=\"true\">\n+\t\t<item-type>Color</item-type>\n+\t\t<label>Color</label>\n+\t\t<autoUpdatePolicy>veto</autoUpdatePolicy>\n+\t</channel-type>\n+\n+\t<channel-group-type id=\"outputs\">\n+\t\t<label>Dimmer Outputs</label>\n+\t\t<channels>\n+\t\t\t<channel typeId=\"output\" id=\"1\">\n+\t\t\t\t<label>Output 1</label>\n+\t\t\t</channel>\n+\t\t\t<channel typeId=\"output\" id=\"2\">\n+\t\t\t\t<label>Output 2</label>\n+\t\t\t</channel>\n+\t\t\t<channel typeId=\"output\" id=\"3\">\n+\t\t\t\t<label>Output 3</label>\n+\t\t\t</channel>\n+\t\t\t<channel typeId=\"output\" id=\"4\">\n+\t\t\t\t<label>Output 4</label>\n+\t\t\t</channel>\n+\t\t\t<channel typeId=\"color\" id=\"color\">\n+\t\t\t\t<label>RGB Color Control (Outputs 1-3)</label>\n+\t\t\t</channel>\n+\t\t</channels>\n+\t</channel-group-type>\n+\n+\t<channel-type id=\"relay\" advanced=\"true\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Relay</label>\n+\t\t<autoUpdatePolicy>veto</autoUpdatePolicy>\n+\t</channel-type>\n+\n+\t<channel-group-type id=\"relays\">\n+\t\t<label>Relays</label>\n+\t\t<channels>\n+\t\t\t<channel typeId=\"relay\" id=\"1\">\n+\t\t\t\t<label>Relay 1</label>\n+\t\t\t</channel>\n+\t\t\t<channel typeId=\"relay\" id=\"2\">\n+\t\t\t\t<label>Relay 2</label>\n+\t\t\t</channel>\n+\t\t\t<channel typeId=\"relay\" id=\"3\">\n+\t\t\t\t<label>Relay 3</label>\n+\t\t\t</channel>\n+\t\t\t<channel typeId=\"relay\" id=\"4\">\n+\t\t\t\t<label>Relay 4</label>\n+\t\t\t</channel>\n+\t\t\t<channel typeId=\"relay\" id=\"5\">\n+\t\t\t\t<label>Relay 5</label>\n+\t\t\t</channel>\n+\t\t\t<channel typeId=\"relay\" id=\"6\">\n+\t\t\t\t<label>Relay 6</label>\n+\t\t\t</channel>\n+\t\t\t<channel typeId=\"relay\" id=\"7\">\n+\t\t\t\t<label>Relay 7</label>\n+\t\t\t</channel>\n+\t\t\t<channel typeId=\"relay\" id=\"8\">\n+\t\t\t\t<label>Relay 8</label>\n+\t\t\t</channel>\n+\t\t</channels>\n+\t</channel-group-type>\n+\n+\t<channel-type id=\"rollershutter\" advanced=\"true\">\n+\t\t<item-type>Roller Shutter</item-type>\n+\t\t<label>Roller Shutter</label>\n+\t\t<autoUpdatePolicy>veto</autoUpdatePolicy>\n+\t</channel-type>\n+\n+\t<channel-group-type id=\"rollershutterrelays\">\n+\t\t<label>Roller Shutter on Relays</label>\n+\t\t<channels>\n+\t\t\t<channel typeId=\"rollershutter\" id=\"1\">\n+\t\t\t\t<label>Roller Shutter on Relay 1-2</label>\n+\t\t\t</channel>\n+\t\t\t<channel typeId=\"rollershutter\" id=\"2\">\n+\t\t\t\t<label>Roller Shutter on Relay 3-4</label>\n+\t\t\t</channel>\n+\t\t\t<channel typeId=\"rollershutter\" id=\"3\">\n+\t\t\t\t<label>Roller Shutter on Relay 5-6</label>\n+\t\t\t</channel>\n+\t\t\t<channel typeId=\"rollershutter\" id=\"4\">\n+\t\t\t\t<label>Roller Shutter on Relay 7-8</label>\n+\t\t\t</channel>\n+\t\t</channels>\n+\t</channel-group-type>\n+\n+\t<channel-group-type id=\"rollershutteroutputs\">\n+\t\t<label>Roller Shutter on Dimmer Outputs</label>\n+\t\t<channels>\n+\t\t\t<channel typeId=\"rollershutter\" id=\"1\">\n+\t\t\t\t<label>Roller Shutter on Dimmer Output 1-2</label>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ce02f433e5d4071dbebb9ee68da0e22895887b6b"}, "originalPosition": 178}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQwMTM5OQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\t\t\t<label>Threshold 5 (only before Feb. 2013)</label>\n          \n          \n            \n            \t\t\t\t<label>Threshold 5</label>\n          \n      \n    \n    \n  \n\nPut the explanation into a <description> tag.", "url": "https://github.com/openhab/openhab-addons/pull/7509#discussion_r436401399", "createdAt": "2020-06-07T21:00:43Z", "author": {"login": "kaikreuzer"}, "path": "bundles/org.openhab.binding.lcn/src/main/resources/ESH-INF/thing/thing-types.xml", "diffHunk": "@@ -0,0 +1,637 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"lcn\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\n+\t<bridge-type id=\"pckGateway\">\n+\t\t<label>LCN-PCHK Gateway</label>\n+\t\t<description>An LCN gateway speaking the PCK language. E.g. LCN-PCHK software or the DIN rail device LCN-PKE.</description>\n+\n+\t\t<config-description-ref uri=\"thing-type:lcn:pckGateway\"/>\n+\t</bridge-type>\n+\n+\t<thing-type id=\"module\">\n+\t\t<supported-bridge-type-refs>\n+\t\t\t<bridge-type-ref id=\"pckGateway\"/>\n+\t\t</supported-bridge-type-refs>\n+\n+\t\t<label>LCN Module</label>\n+\t\t<description>An LCN bus module, e.g. LCN-UPP, LCN-SH, LCN-HU</description>\n+\n+\t\t<channel-groups>\n+\t\t\t<channel-group typeId=\"outputs\" id=\"output\"/>\n+\t\t\t<channel-group typeId=\"rollershutteroutputs\" id=\"rollershutteroutput\"/>\n+\t\t\t<channel-group typeId=\"leds\" id=\"led\"/>\n+\t\t\t<channel-group typeId=\"relays\" id=\"relay\"/>\n+\t\t\t<channel-group typeId=\"rollershutterrelays\" id=\"rollershutterrelay\"/>\n+\t\t\t<channel-group typeId=\"logics\" id=\"logic\"/>\n+\t\t\t<channel-group typeId=\"binarysensors\" id=\"binarysensor\"/>\n+\t\t\t<channel-group typeId=\"variables\" id=\"variable\"/>\n+\t\t\t<channel-group typeId=\"rvarsetpoints\" id=\"rvarsetpoint\"/>\n+\t\t\t<channel-group typeId=\"rvarlocks\" id=\"rvarlock\"/>\n+\t\t\t<channel-group typeId=\"thresholdregisters1\" id=\"thresholdregister1\"/>\n+\t\t\t<channel-group typeId=\"thresholdregisters2\" id=\"thresholdregister2\"/>\n+\t\t\t<channel-group typeId=\"thresholdregisters3\" id=\"thresholdregister3\"/>\n+\t\t\t<channel-group typeId=\"thresholdregisters4\" id=\"thresholdregister4\"/>\n+\t\t\t<channel-group typeId=\"s0inputs\" id=\"s0input\"/>\n+\t\t\t<channel-group typeId=\"keyslocktablea\" id=\"keylocktablea\"/>\n+\t\t\t<channel-group typeId=\"keyslocktableb\" id=\"keylocktableb\"/>\n+\t\t\t<channel-group typeId=\"keyslocktablec\" id=\"keylocktablec\"/>\n+\t\t\t<channel-group typeId=\"keyslocktabled\" id=\"keylocktabled\"/>\n+\t\t\t<channel-group typeId=\"codes\" id=\"code\"/>\n+\t\t</channel-groups>\n+\n+\t\t<config-description-ref uri=\"thing-type:lcn:module\"/>\n+\t</thing-type>\n+\n+\t<thing-type id=\"group\">\n+\t\t<supported-bridge-type-refs>\n+\t\t\t<bridge-type-ref id=\"pckGateway\"/>\n+\t\t</supported-bridge-type-refs>\n+\n+\t\t<label>LCN Group</label>\n+\t\t<description>An LCN group with multiple modules, configured in LCN-PRO</description>\n+\n+\t\t<channel-groups>\n+\t\t\t<channel-group typeId=\"outputs\" id=\"output\"/>\n+\t\t\t<channel-group typeId=\"rollershutteroutputs\" id=\"rollershutteroutput\"/>\n+\t\t\t<channel-group typeId=\"leds\" id=\"led\"/>\n+\t\t\t<channel-group typeId=\"relays\" id=\"relay\"/>\n+\t\t\t<channel-group typeId=\"rollershutterrelays\" id=\"rollershutterrelay\"/>\n+\t\t\t<channel-group typeId=\"logics\" id=\"logic\"/>\n+\t\t\t<channel-group typeId=\"binarysensors\" id=\"binarysensor\"/>\n+\t\t\t<channel-group typeId=\"variables\" id=\"variable\"/>\n+\t\t\t<channel-group typeId=\"rvarsetpoints\" id=\"rvarsetpoint\"/>\n+\t\t\t<channel-group typeId=\"rvarlocks\" id=\"rvarlock\"/>\n+\t\t\t<channel-group typeId=\"thresholdregisters1\" id=\"thresholdregister1\"/>\n+\t\t\t<channel-group typeId=\"thresholdregisters2\" id=\"thresholdregister2\"/>\n+\t\t\t<channel-group typeId=\"thresholdregisters3\" id=\"thresholdregister3\"/>\n+\t\t\t<channel-group typeId=\"thresholdregisters4\" id=\"thresholdregister4\"/>\n+\t\t\t<channel-group typeId=\"s0inputs\" id=\"s0input\"/>\n+\t\t\t<channel-group typeId=\"keyslocktablea\" id=\"keylocktablea\"/>\n+\t\t\t<channel-group typeId=\"keyslocktableb\" id=\"keylocktableb\"/>\n+\t\t\t<channel-group typeId=\"keyslocktablec\" id=\"keylocktablec\"/>\n+\t\t\t<channel-group typeId=\"keyslocktabled\" id=\"keylocktabled\"/>\n+\t\t\t<channel-group typeId=\"codes\" id=\"code\"/>\n+\t\t</channel-groups>\n+\n+\t\t<config-description-ref uri=\"thing-type:lcn:group\"/>\n+\t</thing-type>\n+\n+\t<channel-type id=\"output\" advanced=\"true\">\n+\t\t<item-type>Dimmer</item-type>\n+\t\t<label>Output</label>\n+\t\t<autoUpdatePolicy>veto</autoUpdatePolicy>\n+\t</channel-type>\n+\n+\t<channel-type id=\"color\" advanced=\"true\">\n+\t\t<item-type>Color</item-type>\n+\t\t<label>Color</label>\n+\t\t<autoUpdatePolicy>veto</autoUpdatePolicy>\n+\t</channel-type>\n+\n+\t<channel-group-type id=\"outputs\">\n+\t\t<label>Dimmer Outputs</label>\n+\t\t<channels>\n+\t\t\t<channel typeId=\"output\" id=\"1\">\n+\t\t\t\t<label>Output 1</label>\n+\t\t\t</channel>\n+\t\t\t<channel typeId=\"output\" id=\"2\">\n+\t\t\t\t<label>Output 2</label>\n+\t\t\t</channel>\n+\t\t\t<channel typeId=\"output\" id=\"3\">\n+\t\t\t\t<label>Output 3</label>\n+\t\t\t</channel>\n+\t\t\t<channel typeId=\"output\" id=\"4\">\n+\t\t\t\t<label>Output 4</label>\n+\t\t\t</channel>\n+\t\t\t<channel typeId=\"color\" id=\"color\">\n+\t\t\t\t<label>RGB Color Control (Outputs 1-3)</label>\n+\t\t\t</channel>\n+\t\t</channels>\n+\t</channel-group-type>\n+\n+\t<channel-type id=\"relay\" advanced=\"true\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Relay</label>\n+\t\t<autoUpdatePolicy>veto</autoUpdatePolicy>\n+\t</channel-type>\n+\n+\t<channel-group-type id=\"relays\">\n+\t\t<label>Relays</label>\n+\t\t<channels>\n+\t\t\t<channel typeId=\"relay\" id=\"1\">\n+\t\t\t\t<label>Relay 1</label>\n+\t\t\t</channel>\n+\t\t\t<channel typeId=\"relay\" id=\"2\">\n+\t\t\t\t<label>Relay 2</label>\n+\t\t\t</channel>\n+\t\t\t<channel typeId=\"relay\" id=\"3\">\n+\t\t\t\t<label>Relay 3</label>\n+\t\t\t</channel>\n+\t\t\t<channel typeId=\"relay\" id=\"4\">\n+\t\t\t\t<label>Relay 4</label>\n+\t\t\t</channel>\n+\t\t\t<channel typeId=\"relay\" id=\"5\">\n+\t\t\t\t<label>Relay 5</label>\n+\t\t\t</channel>\n+\t\t\t<channel typeId=\"relay\" id=\"6\">\n+\t\t\t\t<label>Relay 6</label>\n+\t\t\t</channel>\n+\t\t\t<channel typeId=\"relay\" id=\"7\">\n+\t\t\t\t<label>Relay 7</label>\n+\t\t\t</channel>\n+\t\t\t<channel typeId=\"relay\" id=\"8\">\n+\t\t\t\t<label>Relay 8</label>\n+\t\t\t</channel>\n+\t\t</channels>\n+\t</channel-group-type>\n+\n+\t<channel-type id=\"rollershutter\" advanced=\"true\">\n+\t\t<item-type>Roller Shutter</item-type>\n+\t\t<label>Roller Shutter</label>\n+\t\t<autoUpdatePolicy>veto</autoUpdatePolicy>\n+\t</channel-type>\n+\n+\t<channel-group-type id=\"rollershutterrelays\">\n+\t\t<label>Roller Shutter on Relays</label>\n+\t\t<channels>\n+\t\t\t<channel typeId=\"rollershutter\" id=\"1\">\n+\t\t\t\t<label>Roller Shutter on Relay 1-2</label>\n+\t\t\t</channel>\n+\t\t\t<channel typeId=\"rollershutter\" id=\"2\">\n+\t\t\t\t<label>Roller Shutter on Relay 3-4</label>\n+\t\t\t</channel>\n+\t\t\t<channel typeId=\"rollershutter\" id=\"3\">\n+\t\t\t\t<label>Roller Shutter on Relay 5-6</label>\n+\t\t\t</channel>\n+\t\t\t<channel typeId=\"rollershutter\" id=\"4\">\n+\t\t\t\t<label>Roller Shutter on Relay 7-8</label>\n+\t\t\t</channel>\n+\t\t</channels>\n+\t</channel-group-type>\n+\n+\t<channel-group-type id=\"rollershutteroutputs\">\n+\t\t<label>Roller Shutter on Dimmer Outputs</label>\n+\t\t<channels>\n+\t\t\t<channel typeId=\"rollershutter\" id=\"1\">\n+\t\t\t\t<label>Roller Shutter on Dimmer Output 1-2</label>\n+\t\t\t</channel>\n+\t\t</channels>\n+\t</channel-group-type>\n+\n+\t<channel-type id=\"led\" advanced=\"true\">\n+\t\t<item-type>String</item-type>\n+\t\t<label>LED</label>\n+\t\t<state>\n+\t\t\t<options>\n+\t\t\t\t<option value=\"OFF\">Off</option>\n+\t\t\t\t<option value=\"ON\">On</option>\n+\t\t\t\t<option value=\"BLINK\">Blink</option>\n+\t\t\t\t<option value=\"FLICKER\">Flicker</option>\n+\t\t\t</options>\n+\t\t</state>\n+\t\t<autoUpdatePolicy>veto</autoUpdatePolicy>\n+\t</channel-type>\n+\n+\t<channel-group-type id=\"leds\">\n+\t\t<label>LEDs</label>\n+\t\t<channels>\n+\t\t\t<channel typeId=\"led\" id=\"1\">\n+\t\t\t\t<label>LED 1</label>\n+\t\t\t</channel>\n+\t\t\t<channel typeId=\"led\" id=\"2\">\n+\t\t\t\t<label>LED 2</label>\n+\t\t\t</channel>\n+\t\t\t<channel typeId=\"led\" id=\"3\">\n+\t\t\t\t<label>LED 3</label>\n+\t\t\t</channel>\n+\t\t\t<channel typeId=\"led\" id=\"4\">\n+\t\t\t\t<label>LED 4</label>\n+\t\t\t</channel>\n+\t\t\t<channel typeId=\"led\" id=\"5\">\n+\t\t\t\t<label>LED 5</label>\n+\t\t\t</channel>\n+\t\t\t<channel typeId=\"led\" id=\"6\">\n+\t\t\t\t<label>LED 6</label>\n+\t\t\t</channel>\n+\t\t\t<channel typeId=\"led\" id=\"7\">\n+\t\t\t\t<label>LED 7</label>\n+\t\t\t</channel>\n+\t\t\t<channel typeId=\"led\" id=\"8\">\n+\t\t\t\t<label>LED 8</label>\n+\t\t\t</channel>\n+\t\t\t<channel typeId=\"led\" id=\"9\">\n+\t\t\t\t<label>LED 9</label>\n+\t\t\t</channel>\n+\t\t\t<channel typeId=\"led\" id=\"10\">\n+\t\t\t\t<label>LED 10</label>\n+\t\t\t</channel>\n+\t\t\t<channel typeId=\"led\" id=\"11\">\n+\t\t\t\t<label>LED 11</label>\n+\t\t\t</channel>\n+\t\t\t<channel typeId=\"led\" id=\"12\">\n+\t\t\t\t<label>LED 12</label>\n+\t\t\t</channel>\n+\t\t</channels>\n+\t</channel-group-type>\n+\n+\t<channel-type id=\"logic\" advanced=\"true\">\n+\t\t<item-type>String</item-type>\n+\t\t<label>Logic Operation</label>\n+\t\t<state readOnly=\"true\">\n+\t\t\t<options>\n+\t\t\t\t<option value=\"NOT\">Not (not fulfilled)</option>\n+\t\t\t\t<option value=\"OR\">Or (partly fulfilled)</option>\n+\t\t\t\t<option value=\"AND\">And (fulfilled)</option>\n+\t\t\t</options>\n+\t\t</state>\n+\t\t<autoUpdatePolicy>veto</autoUpdatePolicy>\n+\t</channel-type>\n+\n+\t<channel-group-type id=\"logics\">\n+\t\t<label>Logic Operations</label>\n+\t\t<channels>\n+\t\t\t<channel typeId=\"logic\" id=\"1\">\n+\t\t\t\t<label>Logic Operation 1</label>\n+\t\t\t</channel>\n+\t\t\t<channel typeId=\"logic\" id=\"2\">\n+\t\t\t\t<label>Logic Operation 2</label>\n+\t\t\t</channel>\n+\t\t\t<channel typeId=\"logic\" id=\"3\">\n+\t\t\t\t<label>Logic Operation 3</label>\n+\t\t\t</channel>\n+\t\t\t<channel typeId=\"logic\" id=\"4\">\n+\t\t\t\t<label>Logic Operation 4</label>\n+\t\t\t</channel>\n+\t\t</channels>\n+\t</channel-group-type>\n+\n+\t<channel-type id=\"binarysensor\" advanced=\"true\">\n+\t\t<item-type>Contact</item-type>\n+\t\t<label>Binary Sensor</label>\n+\t\t<autoUpdatePolicy>veto</autoUpdatePolicy>\n+\t</channel-type>\n+\n+\t<channel-group-type id=\"binarysensors\">\n+\t\t<label>Binary Sensors</label>\n+\t\t<channels>\n+\t\t\t<channel typeId=\"binarysensor\" id=\"1\">\n+\t\t\t\t<label>Binary Sensor 1</label>\n+\t\t\t</channel>\n+\t\t\t<channel typeId=\"binarysensor\" id=\"2\">\n+\t\t\t\t<label>Binary Sensor 2</label>\n+\t\t\t</channel>\n+\t\t\t<channel typeId=\"binarysensor\" id=\"3\">\n+\t\t\t\t<label>Binary Sensor 3</label>\n+\t\t\t</channel>\n+\t\t\t<channel typeId=\"binarysensor\" id=\"4\">\n+\t\t\t\t<label>Binary Sensor 4</label>\n+\t\t\t</channel>\n+\t\t\t<channel typeId=\"binarysensor\" id=\"5\">\n+\t\t\t\t<label>Binary Sensor 5</label>\n+\t\t\t</channel>\n+\t\t\t<channel typeId=\"binarysensor\" id=\"6\">\n+\t\t\t\t<label>Binary Sensor 6</label>\n+\t\t\t</channel>\n+\t\t\t<channel typeId=\"binarysensor\" id=\"7\">\n+\t\t\t\t<label>Binary Sensor 7</label>\n+\t\t\t</channel>\n+\t\t\t<channel typeId=\"binarysensor\" id=\"8\">\n+\t\t\t\t<label>Binary Sensor 8</label>\n+\t\t\t</channel>\n+\t\t</channels>\n+\t</channel-group-type>\n+\n+\t<channel-type id=\"variable\" advanced=\"true\">\n+\t\t<item-type>Number</item-type>\n+\t\t<label>Variable</label>\n+\t\t<autoUpdatePolicy>veto</autoUpdatePolicy>\n+\t\t<config-description-ref uri=\"channel-type:lcn:variable\"/>\n+\t</channel-type>\n+\n+\t<channel-group-type id=\"variables\">\n+\t\t<label>Variables</label>\n+\t\t<channels>\n+\t\t\t<channel typeId=\"variable\" id=\"1\">\n+\t\t\t\t<label>Variable 1 or TVar</label>\n+\t\t\t</channel>\n+\t\t\t<channel typeId=\"variable\" id=\"2\">\n+\t\t\t\t<label>Variable 2</label>\n+\t\t\t</channel>\n+\t\t\t<channel typeId=\"variable\" id=\"3\">\n+\t\t\t\t<label>Variable 3</label>\n+\t\t\t</channel>\n+\t\t\t<channel typeId=\"variable\" id=\"4\">\n+\t\t\t\t<label>Variable 4</label>\n+\t\t\t</channel>\n+\t\t\t<channel typeId=\"variable\" id=\"5\">\n+\t\t\t\t<label>Variable 5</label>\n+\t\t\t</channel>\n+\t\t\t<channel typeId=\"variable\" id=\"6\">\n+\t\t\t\t<label>Variable 6</label>\n+\t\t\t</channel>\n+\t\t\t<channel typeId=\"variable\" id=\"7\">\n+\t\t\t\t<label>Variable 7</label>\n+\t\t\t</channel>\n+\t\t\t<channel typeId=\"variable\" id=\"8\">\n+\t\t\t\t<label>Variable 8</label>\n+\t\t\t</channel>\n+\t\t\t<channel typeId=\"variable\" id=\"9\">\n+\t\t\t\t<label>Variable 9</label>\n+\t\t\t</channel>\n+\t\t\t<channel typeId=\"variable\" id=\"10\">\n+\t\t\t\t<label>Variable 10</label>\n+\t\t\t</channel>\n+\t\t\t<channel typeId=\"variable\" id=\"11\">\n+\t\t\t\t<label>Variable 11</label>\n+\t\t\t</channel>\n+\t\t\t<channel typeId=\"variable\" id=\"12\">\n+\t\t\t\t<label>Variable 12</label>\n+\t\t\t</channel>\n+\t\t</channels>\n+\t</channel-group-type>\n+\n+\t<channel-group-type id=\"rvarsetpoints\">\n+\t\t<label>RVar Setpoints</label>\n+\t\t<channels>\n+\t\t\t<channel typeId=\"variable\" id=\"1\">\n+\t\t\t\t<label>R1Var Setpoint</label>\n+\t\t\t</channel>\n+\t\t\t<channel typeId=\"variable\" id=\"2\">\n+\t\t\t\t<label>R2Var Setpoint</label>\n+\t\t\t</channel>\n+\t\t</channels>\n+\t</channel-group-type>\n+\n+\t<channel-type id=\"rvarlock\" advanced=\"true\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>RVar Lock State</label>\n+\t\t<autoUpdatePolicy>veto</autoUpdatePolicy>\n+\t</channel-type>\n+\n+\t<channel-group-type id=\"rvarlocks\">\n+\t\t<label>RVar Lock State</label>\n+\t\t<channels>\n+\t\t\t<channel typeId=\"rvarlock\" id=\"1\">\n+\t\t\t\t<label>R1Var Lock</label>\n+\t\t\t</channel>\n+\t\t\t<channel typeId=\"rvarlock\" id=\"2\">\n+\t\t\t\t<label>R2Var Lock</label>\n+\t\t\t</channel>\n+\t\t</channels>\n+\t</channel-group-type>\n+\n+\t<channel-group-type id=\"thresholdregisters1\">\n+\t\t<label>Threshold Register 1</label>\n+\t\t<channels>\n+\t\t\t<channel typeId=\"variable\" id=\"1\">\n+\t\t\t\t<label>Threshold 1</label>\n+\t\t\t</channel>\n+\t\t\t<channel typeId=\"variable\" id=\"2\">\n+\t\t\t\t<label>Threshold 2</label>\n+\t\t\t</channel>\n+\t\t\t<channel typeId=\"variable\" id=\"3\">\n+\t\t\t\t<label>Threshold 3</label>\n+\t\t\t</channel>\n+\t\t\t<channel typeId=\"variable\" id=\"4\">\n+\t\t\t\t<label>Threshold 4</label>\n+\t\t\t</channel>\n+\t\t\t<channel typeId=\"variable\" id=\"5\">\n+\t\t\t\t<label>Threshold 5 (only before Feb. 2013)</label>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ce02f433e5d4071dbebb9ee68da0e22895887b6b"}, "originalPosition": 401}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQwMTU3OA==", "bodyText": "Please note that your binding is expected to quickly provide state updates after receiving commands, if you go for a veto here.\nIs that really the case for all the channels where you have put \"veto\"?", "url": "https://github.com/openhab/openhab-addons/pull/7509#discussion_r436401578", "createdAt": "2020-06-07T21:02:44Z", "author": {"login": "kaikreuzer"}, "path": "bundles/org.openhab.binding.lcn/src/main/resources/ESH-INF/thing/thing-types.xml", "diffHunk": "@@ -0,0 +1,637 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"lcn\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\n+\t<bridge-type id=\"pckGateway\">\n+\t\t<label>LCN-PCHK Gateway</label>\n+\t\t<description>An LCN gateway speaking the PCK language. E.g. LCN-PCHK software or the DIN rail device LCN-PKE.</description>\n+\n+\t\t<config-description-ref uri=\"thing-type:lcn:pckGateway\"/>\n+\t</bridge-type>\n+\n+\t<thing-type id=\"module\">\n+\t\t<supported-bridge-type-refs>\n+\t\t\t<bridge-type-ref id=\"pckGateway\"/>\n+\t\t</supported-bridge-type-refs>\n+\n+\t\t<label>LCN Module</label>\n+\t\t<description>An LCN bus module, e.g. LCN-UPP, LCN-SH, LCN-HU</description>\n+\n+\t\t<channel-groups>\n+\t\t\t<channel-group typeId=\"outputs\" id=\"output\"/>\n+\t\t\t<channel-group typeId=\"rollershutteroutputs\" id=\"rollershutteroutput\"/>\n+\t\t\t<channel-group typeId=\"leds\" id=\"led\"/>\n+\t\t\t<channel-group typeId=\"relays\" id=\"relay\"/>\n+\t\t\t<channel-group typeId=\"rollershutterrelays\" id=\"rollershutterrelay\"/>\n+\t\t\t<channel-group typeId=\"logics\" id=\"logic\"/>\n+\t\t\t<channel-group typeId=\"binarysensors\" id=\"binarysensor\"/>\n+\t\t\t<channel-group typeId=\"variables\" id=\"variable\"/>\n+\t\t\t<channel-group typeId=\"rvarsetpoints\" id=\"rvarsetpoint\"/>\n+\t\t\t<channel-group typeId=\"rvarlocks\" id=\"rvarlock\"/>\n+\t\t\t<channel-group typeId=\"thresholdregisters1\" id=\"thresholdregister1\"/>\n+\t\t\t<channel-group typeId=\"thresholdregisters2\" id=\"thresholdregister2\"/>\n+\t\t\t<channel-group typeId=\"thresholdregisters3\" id=\"thresholdregister3\"/>\n+\t\t\t<channel-group typeId=\"thresholdregisters4\" id=\"thresholdregister4\"/>\n+\t\t\t<channel-group typeId=\"s0inputs\" id=\"s0input\"/>\n+\t\t\t<channel-group typeId=\"keyslocktablea\" id=\"keylocktablea\"/>\n+\t\t\t<channel-group typeId=\"keyslocktableb\" id=\"keylocktableb\"/>\n+\t\t\t<channel-group typeId=\"keyslocktablec\" id=\"keylocktablec\"/>\n+\t\t\t<channel-group typeId=\"keyslocktabled\" id=\"keylocktabled\"/>\n+\t\t\t<channel-group typeId=\"codes\" id=\"code\"/>\n+\t\t</channel-groups>\n+\n+\t\t<config-description-ref uri=\"thing-type:lcn:module\"/>\n+\t</thing-type>\n+\n+\t<thing-type id=\"group\">\n+\t\t<supported-bridge-type-refs>\n+\t\t\t<bridge-type-ref id=\"pckGateway\"/>\n+\t\t</supported-bridge-type-refs>\n+\n+\t\t<label>LCN Group</label>\n+\t\t<description>An LCN group with multiple modules, configured in LCN-PRO</description>\n+\n+\t\t<channel-groups>\n+\t\t\t<channel-group typeId=\"outputs\" id=\"output\"/>\n+\t\t\t<channel-group typeId=\"rollershutteroutputs\" id=\"rollershutteroutput\"/>\n+\t\t\t<channel-group typeId=\"leds\" id=\"led\"/>\n+\t\t\t<channel-group typeId=\"relays\" id=\"relay\"/>\n+\t\t\t<channel-group typeId=\"rollershutterrelays\" id=\"rollershutterrelay\"/>\n+\t\t\t<channel-group typeId=\"logics\" id=\"logic\"/>\n+\t\t\t<channel-group typeId=\"binarysensors\" id=\"binarysensor\"/>\n+\t\t\t<channel-group typeId=\"variables\" id=\"variable\"/>\n+\t\t\t<channel-group typeId=\"rvarsetpoints\" id=\"rvarsetpoint\"/>\n+\t\t\t<channel-group typeId=\"rvarlocks\" id=\"rvarlock\"/>\n+\t\t\t<channel-group typeId=\"thresholdregisters1\" id=\"thresholdregister1\"/>\n+\t\t\t<channel-group typeId=\"thresholdregisters2\" id=\"thresholdregister2\"/>\n+\t\t\t<channel-group typeId=\"thresholdregisters3\" id=\"thresholdregister3\"/>\n+\t\t\t<channel-group typeId=\"thresholdregisters4\" id=\"thresholdregister4\"/>\n+\t\t\t<channel-group typeId=\"s0inputs\" id=\"s0input\"/>\n+\t\t\t<channel-group typeId=\"keyslocktablea\" id=\"keylocktablea\"/>\n+\t\t\t<channel-group typeId=\"keyslocktableb\" id=\"keylocktableb\"/>\n+\t\t\t<channel-group typeId=\"keyslocktablec\" id=\"keylocktablec\"/>\n+\t\t\t<channel-group typeId=\"keyslocktabled\" id=\"keylocktabled\"/>\n+\t\t\t<channel-group typeId=\"codes\" id=\"code\"/>\n+\t\t</channel-groups>\n+\n+\t\t<config-description-ref uri=\"thing-type:lcn:group\"/>\n+\t</thing-type>\n+\n+\t<channel-type id=\"output\" advanced=\"true\">\n+\t\t<item-type>Dimmer</item-type>\n+\t\t<label>Output</label>\n+\t\t<autoUpdatePolicy>veto</autoUpdatePolicy>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ce02f433e5d4071dbebb9ee68da0e22895887b6b"}, "originalPosition": 84}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI2NDcxNzcy", "url": "https://github.com/openhab/openhab-addons/pull/7509#pullrequestreview-426471772", "createdAt": "2020-06-08T17:43:14Z", "commit": {"oid": "ce02f433e5d4071dbebb9ee68da0e22895887b6b"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 38, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOFQxNzo0MzoxNFrOGgpN4A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOFQyMDoxMjoxOVrOGguqeg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjg4MjkxMg==", "bodyText": "the other methods throw LcnException instead of a IllegalArgumentException. Why is this one different?", "url": "https://github.com/openhab/openhab-addons/pull/7509#discussion_r436882912", "createdAt": "2020-06-08T17:43:14Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.lcn/src/main/java/org/openhab/binding/lcn/internal/common/PckGenerator.java", "diffHunk": "@@ -0,0 +1,779 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.lcn.internal.common;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.binding.lcn.internal.LcnBindingConstants;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Helpers to generate LCN-PCK commands.\n+ * <p>\n+ * LCN-PCK is the command-syntax used by LCN-PCHK to send and receive LCN commands.\n+ *\n+ * @author Tobias J\u00fcttner - Initial Contribution\n+ * @author Fabian Wolter - Migration to OH2\n+ */\n+@NonNullByDefault\n+public final class PckGenerator {\n+    private static final Logger LOGGER = LoggerFactory.getLogger(PckGenerator.class);\n+    /** Termination character after a PCK message */\n+    public static final String TERMINATION = \"\\n\";\n+\n+    /**\n+     * Generates a keep-alive.\n+     * LCN-PCHK will close the connection if it does not receive any commands from\n+     * an open {@link Connection} for a specific period (10 minutes by default).\n+     *\n+     * @param counter the current ping's id (optional, but \"best practice\"). Should start with 1\n+     * @return the PCK command as text\n+     */\n+    public static String ping(int counter) {\n+        return String.format(\"^ping%d\", counter);\n+    }\n+\n+    /**\n+     * Generates a PCK command that will set the LCN-PCHK connection's operation mode.\n+     * This influences how output-port commands and status are interpreted and must be\n+     * in sync with the LCN bus.\n+     *\n+     * @param dimMode see {@link LcnDefs.OutputPortDimMode}\n+     * @param statusMode see {@link LcnDefs.OutputPortStatusMode}\n+     * @return the PCK command as text\n+     */\n+    public static String setOperationMode(LcnDefs.OutputPortDimMode dimMode, LcnDefs.OutputPortStatusMode statusMode) {\n+        return \"!OM\" + (dimMode == LcnDefs.OutputPortDimMode.NATIVE200 ? \"1\" : \"0\")\n+                + (statusMode == LcnDefs.OutputPortStatusMode.PERCENT ? \"P\" : \"N\");\n+    }\n+\n+    /**\n+     * Generates a PCK address header.\n+     * Used for commands to LCN modules and groups.\n+     *\n+     * @param addr the target's address (module or group)\n+     * @param localSegId the local segment id where the physical bus connection is located\n+     * @param wantsAck true to claim an acknowledge / receipt from the target\n+     * @return the PCK address header as text\n+     */\n+    public static String generateAddressHeader(LcnAddr addr, int localSegId, boolean wantsAck) {\n+        return String.format(\">%s%03d%03d%s\", addr.isGroup() ? \"G\" : \"M\", addr.getPhysicalSegmentId(localSegId),\n+                addr.getId(), wantsAck ? \"!\" : \".\");\n+    }\n+\n+    /**\n+     * Generates a scan-command for LCN segment-couplers.\n+     * Used to detect the local segment (where the physical bus connection is located).\n+     *\n+     * @return the PCK command (without address header) as text\n+     */\n+    public static String segmentCouplerScan() {\n+        return \"SK\";\n+    }\n+\n+    /**\n+     * Generates a firmware/serial-number request.\n+     *\n+     * @return the PCK command (without address header) as text\n+     */\n+    public static String requestSn() {\n+        return \"SN\";\n+    }\n+\n+    /**\n+     * Generates a command to request a part of a name of a module.\n+     *\n+     * @param partNumber 0..1\n+     * @return the PCK command (without address header) as text\n+     */\n+    public static String requestModuleName(int partNumber) {\n+        return \"NMN\" + (partNumber + 1);\n+    }\n+\n+    /**\n+     * Generates an output-port status request.\n+     *\n+     * @param outputId 0..3\n+     * @return the PCK command (without address header) as text\n+     * @throws LcnException if out of range\n+     */\n+    public static String requestOutputStatus(int outputId) throws LcnException {\n+        if (outputId < 0 || outputId > 3) {\n+            throw new LcnException();\n+        }\n+        return String.format(\"SMA%d\", outputId + 1);\n+    }\n+\n+    /**\n+     * Generates a dim command for a single output-port.\n+     *\n+     * @param outputId 0..3\n+     * @param percent 0..100\n+     * @param rampMs ramp in milliseconds\n+     * @return the PCK command (without address header) as text\n+     * @throws LcnException if out of range\n+     */\n+    public static String dimOutput(int outputId, double percent, int rampMs) throws LcnException {\n+        if (outputId < 0 || outputId > 3) {\n+            throw new LcnException();\n+        }\n+        int rampNative = PckGenerator.timeToRampValue(rampMs);\n+        int n = (int) Math.round(percent * 2);\n+        if ((n % 2) == 0) { // Use the percent command (supported by all LCN-PCHK versions)\n+            return String.format(\"A%dDI%03d%03d\", outputId + 1, n / 2, rampNative);\n+        } else { // We have a \".5\" value. Use the native command (supported since LCN-PCHK 2.3)\n+            return String.format(\"O%dDI%03d%03d\", outputId + 1, n, rampNative);\n+        }\n+    }\n+\n+    /**\n+     * Generates a dim command for all output-ports.\n+     *\n+     * Attention: This command is supported since module firmware version 180501 AND LCN-PCHK 2.61\n+     *\n+     * @param firstPercent dimmer value of the first output 0..100\n+     * @param secondPercent dimmer value of the first output 0..100\n+     * @param thirdPercent dimmer value of the first output 0..100\n+     * @param fourthPercent dimmer value of the first output 0..100\n+     * @param rampMs ramp in milliseconds\n+     * @return the PCK command (without address header) as text\n+     */\n+    public static String dimAllOutputs(double firstPercent, double secondPercent, double thirdPercent,\n+            double fourthPercent, int rampMs) {\n+        long n1 = Math.round(firstPercent * 2);\n+        long n2 = Math.round(secondPercent * 2);\n+        long n3 = Math.round(thirdPercent * 2);\n+        long n4 = Math.round(fourthPercent * 2);\n+\n+        return String.format(\"OY%03d%03d%03d%03d%03d\", n1, n2, n3, n4, timeToRampValue(rampMs));\n+    }\n+\n+    /**\n+     * Generates a control command for switching all outputs ON or OFF with a fixed ramp of 0.5s.\n+     *\n+     * @param percent 0..100\n+     * @returnthe PCK command (without address header) as text\n+     */\n+    public static String controlAllOutputs(double percent) {\n+        return String.format(\"AH%03d\", Math.round(percent));\n+    }\n+\n+    /**\n+     * Generates a control command for switching dimmer output 1 and 2 both ON or OFF with a fixed ramp of 0.5s or\n+     * without ramp.\n+     *\n+     * @param on true, if outputs shall be switched on\n+     * @param ramp true, if the ramp shall be 0.5s, else 0s\n+     * @return the PCK command (without address header) as text\n+     */\n+    public static String controlOutputs12(boolean on, boolean ramp) {\n+        int commandByte;\n+        if (on) {\n+            commandByte = ramp ? 0xC8 : 0xFD;\n+        } else {\n+            commandByte = ramp ? 0x00 : 0xFC;\n+        }\n+        return String.format(\"X2%03d%03d%03d\", 1, commandByte, commandByte);\n+    }\n+\n+    /**\n+     * Generates a dim command for setting the brightness of dimmer output 1 and 2 with a fixed ramp of 0.5s.\n+     *\n+     * @param percent brightness of both outputs 0..100\n+     * @return the PCK command (without address header) as text\n+     */\n+    public static String dimOutputs12(double percent) {\n+        long localPercent = Math.round(percent);\n+        return String.format(\"AY%03d%03d\", localPercent, localPercent);\n+    }\n+\n+    /**\n+     * Let an output flicker.\n+     *\n+     * @param outputId output id 0..3\n+     * @param depth flicker depth, the higher the deeper 0..2\n+     * @param ramp the flicker speed 0..2\n+     * @param count number of flashes 1..15\n+     * @return the PCK command (without address header) as text\n+     * @throws LcnException when the input values are out of range\n+     */\n+    public static String flickerOutput(int outputId, int depth, int ramp, int count) throws LcnException {\n+        if (outputId < 0 || outputId > 3) {\n+            throw new LcnException(\"Output number out of range\");\n+        }\n+        if (count < 1 || count > 15) {\n+            throw new LcnException(\"Number of flashes out of range\");\n+        }\n+        String depthString;\n+        switch (depth) {\n+            case 0:\n+                depthString = \"G\";\n+                break;\n+            case 1:\n+                depthString = \"M\";\n+                break;\n+            case 2:\n+                depthString = \"S\";\n+                break;\n+            default:\n+                throw new LcnException(\"Depth out of range\");\n+        }\n+        String rampString;\n+        switch (ramp) {\n+            case 0:\n+                rampString = \"L\";\n+                break;\n+            case 1:\n+                rampString = \"M\";\n+                break;\n+            case 2:\n+                rampString = \"S\";\n+                break;\n+            default:\n+                throw new LcnException(\"Ramp out of range\");\n+        }\n+        return String.format(\"A%dFL%s%s%02d\", outputId + 1, depthString, rampString, count);\n+    }\n+\n+    /**\n+     * Generates a command to change the value of an output-port.\n+     *\n+     * @param outputId 0..3\n+     * @param percent -100..100\n+     * @return the PCK command (without address header) as text\n+     * @throws LcnException if out of range\n+     */\n+    public static String relOutput(int outputId, double percent) throws LcnException {\n+        if (outputId < 0 || outputId > 3) {\n+            throw new LcnException();\n+        }\n+        int n = (int) Math.round(percent * 2);\n+        if ((n % 2) == 0) { // Use the percent command (supported by all LCN-PCHK versions)\n+            return String.format(\"A%d%s%03d\", outputId + 1, percent >= 0 ? \"AD\" : \"SB\", Math.abs(n / 2));\n+        } else { // We have a \".5\" value. Use the native command (supported since LCN-PCHK 2.3)\n+            return String.format(\"O%d%s%03d\", outputId + 1, percent >= 0 ? \"AD\" : \"SB\", Math.abs(n));\n+        }\n+    }\n+\n+    /**\n+     * Generates a command that toggles a single output-port (on->off, off->on).\n+     *\n+     * @param outputId 0..3\n+     * @param ramp see {@link PckGenerator#timeToRampValue(int)}\n+     * @return the PCK command (without address header) as text\n+     * @throws LcnException if out of range\n+     */\n+    public static String toggleOutput(int outputId, int ramp) throws LcnException {\n+        if (outputId < 0 || outputId > 3) {\n+            throw new LcnException();\n+        }\n+        return String.format(\"A%dTA%03d\", outputId + 1, ramp);\n+    }\n+\n+    /**\n+     * Generates a command that toggles all output-ports (on->off, off->on).\n+     *\n+     * @param ramp see {@link PckGenerator#timeToRampValue(int)}\n+     * @return the PCK command (without address header) as text\n+     */\n+    public static String toggleAllOutputs(int ramp) {\n+        return String.format(\"AU%03d\", ramp);\n+    }\n+\n+    /**\n+     * Generates a relays-status request.\n+     *\n+     * @return the PCK command (without address header) as text\n+     */\n+    public static String requestRelaysStatus() {\n+        return \"SMR\";\n+    }\n+\n+    /**\n+     * Generates a command to control relays.\n+     *\n+     * @param states the 8 modifiers for the relay states\n+     * @return the PCK command (without address header) as text\n+     * @throws LcnException if out of range\n+     */\n+    public static String controlRelays(LcnDefs.RelayStateModifier[] states) throws LcnException {\n+        if (states.length != 8) {\n+            throw new LcnException();\n+        }\n+        String ret = \"R8\";\n+        for (int i = 0; i < 8; ++i) {\n+            switch (states[i]) {\n+                case ON:\n+                    ret += \"1\";\n+                    break;\n+                case OFF:\n+                    ret += \"0\";\n+                    break;\n+                case TOGGLE:\n+                    ret += \"U\";\n+                    break;\n+                case NOCHANGE:\n+                    ret += \"-\";\n+                    break;\n+                default:\n+                    throw new LcnException();\n+            }\n+        }\n+        return ret;\n+    }\n+\n+    /**\n+     * Generates a binary-sensors status request.\n+     *\n+     * @return the PCK command (without address header) as text\n+     */\n+    public static String requestBinSensorsStatus() {\n+        return \"SMB\";\n+    }\n+\n+    /**\n+     * Generates a command that sets a variable absolute.\n+     *\n+     * @param number regulator number 0..1\n+     * @param value the absolute value to set\n+     * @return the PCK command (without address header) as text\n+     * @throws LcnException\n+     */\n+    public static String setSetpointAbsolute(int number, int value) {\n+        int internalValue = value;\n+        // Set absolute (not in PCK yet)\n+        int b1 = number << 6; // 01000000\n+        b1 |= 0x20; // xx10xxxx (set absolute)\n+        if (value < 1000) {\n+            internalValue = 1000 - internalValue;\n+            b1 |= 8;\n+        } else {\n+            internalValue -= 1000;\n+        }\n+        b1 |= (internalValue >> 8) & 0x0f; // xxxx1111\n+        int b2 = internalValue & 0xff;\n+        return String.format(\"X2%03d%03d%03d\", 30, b1, b2);\n+    }\n+\n+    /**\n+     * Generates a command to change the value of a variable.\n+     *\n+     * @param variable the target variable to change\n+     * @param type the reference-point\n+     * @param value the native LCN value to add/subtract (can be negative)\n+     * @return the PCK command (without address header) as text\n+     * @throws LcnException if command is not supported\n+     */\n+    public static String setVariableRelative(Variable variable, LcnDefs.RelVarRef type, int value) {\n+        if (variable.getNumber() == 0) {\n+            // Old command for variable 1 / T-var (compatible with all modules)\n+            return String.format(\"Z%s%d\", value >= 0 ? \"A\" : \"S\", Math.abs(value));\n+        } else { // New command for variable 1-12 (compatible with all modules, since LCN-PCHK 2.8)\n+            return String.format(\"Z%s%03d%d\", value >= 0 ? \"+\" : \"-\", variable.getNumber() + 1, Math.abs(value));\n+        }\n+    }\n+\n+    /**\n+     * Generates a command the change the value of a regulator setpoint relative.\n+     *\n+     * @param number 0..1\n+     * @param type relative to the current or to the programmed value\n+     * @param value the relative value -4000..+4000\n+     * @return the PCK command (without address header) as text\n+     */\n+    public static String setSetpointRelative(int number, LcnDefs.RelVarRef type, int value) {\n+        return String.format(\"RE%sS%s%s%d\", number == 0 ? \"A\" : \"B\", type == LcnDefs.RelVarRef.CURRENT ? \"A\" : \"P\",\n+                value >= 0 ? \"+\" : \"-\", Math.abs(value));\n+    }\n+\n+    /**\n+     * Generates a command the change the value of a threshold relative.\n+     *\n+     * @param variable the threshold to change\n+     * @param type relative to the current or to the programmed value\n+     * @param value the relative value -4000..+4000\n+     * @param is2013 true, if the LCN module's firmware is equal to or newer than 2013\n+     * @return the PCK command (without address header) as text\n+     */\n+    public static String setThresholdRelative(Variable variable, LcnDefs.RelVarRef type, int value, boolean is2013)\n+            throws LcnException {\n+        if (is2013) { // New command for registers 1-4 (since 170206, LCN-PCHK 2.8)\n+            return String.format(\"SS%s%04d%sR%d%d\", type == LcnDefs.RelVarRef.CURRENT ? \"R\" : \"E\", Math.abs(value),\n+                    value >= 0 ? \"A\" : \"S\", variable.getNumber() + 1, variable.getThresholdNumber().get() + 1);\n+        } else if (variable.getNumber() == 0) { // Old command for register 1 (before 170206)\n+            return String.format(\"SS%s%04d%s%s%s%s%s%s\", type == LcnDefs.RelVarRef.CURRENT ? \"R\" : \"E\", Math.abs(value),\n+                    value >= 0 ? \"A\" : \"S\", variable.getThresholdNumber().get() == 0 ? \"1\" : \"0\",\n+                    variable.getThresholdNumber().get() == 1 ? \"1\" : \"0\",\n+                    variable.getThresholdNumber().get() == 2 ? \"1\" : \"0\",\n+                    variable.getThresholdNumber().get() == 3 ? \"1\" : \"0\",\n+                    variable.getThresholdNumber().get() == 4 ? \"1\" : \"0\");\n+        } else {\n+            throw new LcnException(\n+                    \"Module does not have threshold register \" + (variable.getThresholdNumber().get() + 1));\n+        }\n+    }\n+\n+    /**\n+     * Generates a variable value request.\n+     *\n+     * @param variable the variable to request\n+     * @param firmwareVersion the target module's firmware version\n+     * @return the PCK command (without address header) as text\n+     * @throws LcnException if command is not supported\n+     */\n+    public static String requestVarStatus(Variable variable, int firmwareVersion) throws LcnException {\n+        if (firmwareVersion >= LcnBindingConstants.FIRMWARE_2013) {\n+            int id = variable.getNumber();\n+            switch (variable.getType()) {\n+                case UNKNOWN:\n+                    throw new LcnException(\"Variable unknown\");\n+                case VARIABLE:\n+                    return String.format(\"MWT%03d\", id + 1);\n+                case REGULATOR:\n+                    return String.format(\"MWS%03d\", id + 1);\n+                case THRESHOLD:\n+                    return String.format(\"SE%03d\", id + 1); // Whole register\n+                case S0INPUT:\n+                    return String.format(\"MWC%03d\", id + 1);\n+            }\n+            throw new LcnException(\"Unsupported variable type: \" + variable);\n+        } else {\n+            switch (variable) {\n+                case VARIABLE1:\n+                    return \"MWV\";\n+                case VARIABLE2:\n+                    return \"MWTA\";\n+                case VARIABLE3:\n+                    return \"MWTB\";\n+                case RVARSETPOINT1:\n+                    return \"MWSA\";\n+                case RVARSETPOINT2:\n+                    return \"MWSB\";\n+                case THRESHOLDREGISTER11:\n+                case THRESHOLDREGISTER12:\n+                case THRESHOLDREGISTER13:\n+                case THRESHOLDREGISTER14:\n+                case THRESHOLDREGISTER15:\n+                    return \"SL1\"; // Whole register\n+                default:\n+                    throw new LcnException(\"Unsupported variable type: \" + variable);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Generates a request for LED and logic-operations states.\n+     *\n+     * @return the PCK command (without address header) as text\n+     */\n+    public static String requestLedsAndLogicOpsStatus() {\n+        return \"SMT\";\n+    }\n+\n+    /**\n+     * Generates a command to the set the state of a single LED.\n+     *\n+     * @param ledId 0..11\n+     * @param state the state to set\n+     * @return the PCK command (without address header) as text\n+     * @throws LcnException if out of range\n+     */\n+    public static String controlLed(int ledId, LcnDefs.LedStatus state) throws LcnException {\n+        if (ledId < 0 || ledId > 11) {\n+            throw new LcnException();\n+        }\n+        return String.format(\"LA%03d%s\", ledId + 1, state == LcnDefs.LedStatus.OFF ? \"A\"\n+                : state == LcnDefs.LedStatus.ON ? \"E\" : state == LcnDefs.LedStatus.BLINK ? \"B\" : \"F\");\n+    }\n+\n+    /**\n+     * Generates a command to send LCN keys.\n+     *\n+     * @param cmds the 4 concrete commands to send for the tables (A-D)\n+     * @param keys the tables' 8 key-states (true means \"send\")\n+     * @return the PCK command (without address header) as text\n+     * @throws IllegalArgumentException if out of range\n+     */\n+    public static String sendKeys(LcnDefs.SendKeyCommand[] cmds, boolean[] keys) throws LcnException {\n+        if (cmds.length != 4 || keys.length != 8) {\n+            throw new LcnException();\n+        }\n+        String ret = \"TS\";\n+        for (int i = 0; i < 4; ++i) {\n+            switch (cmds[i]) {\n+                case HIT:\n+                    ret += \"K\";\n+                    break;\n+                case MAKE:\n+                    ret += \"L\";\n+                    break;\n+                case BREAK:\n+                    ret += \"O\";\n+                    break;\n+                case DONTSEND:\n+                    // By skipping table D (if it is not used), we use the old command\n+                    // for table A-C which is compatible with older LCN modules\n+                    if (i < 3) {\n+                        ret += \"-\";\n+                    }\n+                    break;\n+                default:\n+                    throw new LcnException();\n+            }\n+        }\n+        for (int i = 0; i < 8; ++i) {\n+            ret += keys[i] ? \"1\" : \"0\";\n+        }\n+        return ret;\n+    }\n+\n+    /**\n+     * Generates a command to send LCN keys deferred / delayed.\n+     *\n+     * @param tableId 0(A)..3(D)\n+     * @param time the delay time\n+     * @param timeUnit the time unit\n+     * @param keys the key-states (true means \"send\")\n+     * @return the PCK command (without address header) as text\n+     * @throws LcnException if out of range\n+     */\n+    public static String sendKeysHitDefered(int tableId, int time, LcnDefs.TimeUnit timeUnit, boolean[] keys)\n+            throws LcnException {\n+        if (tableId < 0 || tableId > 3 || keys.length != 8) {\n+            throw new IllegalArgumentException();\n+        }\n+        String ret = \"TV\";\n+        switch (tableId) {\n+            case 0:\n+                ret += \"A\";\n+                break;\n+            case 1:\n+                ret += \"B\";\n+                break;\n+            case 2:\n+                ret += \"C\";\n+                break;\n+            case 3:\n+                ret += \"D\";\n+                break;\n+            default:\n+                throw new LcnException();\n+        }\n+        ret += String.format(\"%03d\", time);\n+        switch (timeUnit) {\n+            case SECONDS:\n+                if (time < 1 || time > 60) {\n+                    throw new LcnException();\n+                }\n+                ret += \"S\";\n+                break;\n+            case MINUTES:\n+                if (time < 1 || time > 90) {\n+                    throw new LcnException();\n+                }\n+                ret += \"M\";\n+                break;\n+            case HOURS:\n+                if (time < 1 || time > 50) {\n+                    throw new LcnException();\n+                }\n+                ret += \"H\";\n+                break;\n+            case DAYS:\n+                if (time < 1 || time > 45) {\n+                    throw new LcnException();\n+                }\n+                ret += \"D\";\n+                break;\n+            default:\n+                throw new LcnException();\n+        }\n+        for (int i = 0; i < 8; ++i) {\n+            ret += keys[i] ? \"1\" : \"0\";\n+        }\n+        return ret;\n+    }\n+\n+    /**\n+     * Generates a request for key-lock states.\n+     * Always requests table A-D. Supported since LCN-PCHK 2.8.\n+     *\n+     * @return the PCK command (without address header) as text\n+     */\n+    public static String requestKeyLocksStatus() {\n+        return \"STX\";\n+    }\n+\n+    /**\n+     * Generates a command to lock keys.\n+     *\n+     * @param tableId 0(A)..3(D)\n+     * @param states the 8 key-lock modifiers\n+     * @return the PCK command (without address header) as text\n+     * @throws LcnException if out of range\n+     */\n+    public static String lockKeys(int tableId, LcnDefs.KeyLockStateModifier[] states) throws LcnException {\n+        if (tableId < 0 || tableId > 3 || states.length != 8) {\n+            throw new LcnException();\n+        }\n+        String ret = String.format(\"TX%s\", tableId == 0 ? \"A\" : tableId == 1 ? \"B\" : tableId == 2 ? \"C\" : \"D\");\n+        for (int i = 0; i < 8; ++i) {\n+            switch (states[i]) {\n+                case ON:\n+                    ret += \"1\";\n+                    break;\n+                case OFF:\n+                    ret += \"0\";\n+                    break;\n+                case TOGGLE:\n+                    ret += \"U\";\n+                    break;\n+                case NOCHANGE:\n+                    ret += \"-\";\n+                    break;\n+                default:\n+                    throw new LcnException();\n+            }\n+        }\n+        return ret;\n+    }\n+\n+    /**\n+     * Generates a command to lock keys for table A temporary.\n+     * There is no hardware-support for locking tables B-D.\n+     *\n+     * @param time the lock time\n+     * @param timeUnit the time unit\n+     * @param keys the 8 key-lock states (true means lock)\n+     * @return the PCK command (without address header) as text\n+     * @throws LcnException if out of range\n+     */\n+    public static String lockKeyTabATemporary(int time, LcnDefs.TimeUnit timeUnit, boolean[] keys) throws LcnException {\n+        if (keys.length != 8) {\n+            throw new IllegalArgumentException();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ce02f433e5d4071dbebb9ee68da0e22895887b6b"}, "originalPosition": 663}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjg4NjE4NQ==", "bodyText": "The java compiler can't optimize string concatenation in a loop so you should just use a StringBuilder directly here.", "url": "https://github.com/openhab/openhab-addons/pull/7509#discussion_r436886185", "createdAt": "2020-06-08T17:48:54Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.lcn/src/main/java/org/openhab/binding/lcn/internal/common/PckGenerator.java", "diffHunk": "@@ -0,0 +1,779 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.lcn.internal.common;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.binding.lcn.internal.LcnBindingConstants;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Helpers to generate LCN-PCK commands.\n+ * <p>\n+ * LCN-PCK is the command-syntax used by LCN-PCHK to send and receive LCN commands.\n+ *\n+ * @author Tobias J\u00fcttner - Initial Contribution\n+ * @author Fabian Wolter - Migration to OH2\n+ */\n+@NonNullByDefault\n+public final class PckGenerator {\n+    private static final Logger LOGGER = LoggerFactory.getLogger(PckGenerator.class);\n+    /** Termination character after a PCK message */\n+    public static final String TERMINATION = \"\\n\";\n+\n+    /**\n+     * Generates a keep-alive.\n+     * LCN-PCHK will close the connection if it does not receive any commands from\n+     * an open {@link Connection} for a specific period (10 minutes by default).\n+     *\n+     * @param counter the current ping's id (optional, but \"best practice\"). Should start with 1\n+     * @return the PCK command as text\n+     */\n+    public static String ping(int counter) {\n+        return String.format(\"^ping%d\", counter);\n+    }\n+\n+    /**\n+     * Generates a PCK command that will set the LCN-PCHK connection's operation mode.\n+     * This influences how output-port commands and status are interpreted and must be\n+     * in sync with the LCN bus.\n+     *\n+     * @param dimMode see {@link LcnDefs.OutputPortDimMode}\n+     * @param statusMode see {@link LcnDefs.OutputPortStatusMode}\n+     * @return the PCK command as text\n+     */\n+    public static String setOperationMode(LcnDefs.OutputPortDimMode dimMode, LcnDefs.OutputPortStatusMode statusMode) {\n+        return \"!OM\" + (dimMode == LcnDefs.OutputPortDimMode.NATIVE200 ? \"1\" : \"0\")\n+                + (statusMode == LcnDefs.OutputPortStatusMode.PERCENT ? \"P\" : \"N\");\n+    }\n+\n+    /**\n+     * Generates a PCK address header.\n+     * Used for commands to LCN modules and groups.\n+     *\n+     * @param addr the target's address (module or group)\n+     * @param localSegId the local segment id where the physical bus connection is located\n+     * @param wantsAck true to claim an acknowledge / receipt from the target\n+     * @return the PCK address header as text\n+     */\n+    public static String generateAddressHeader(LcnAddr addr, int localSegId, boolean wantsAck) {\n+        return String.format(\">%s%03d%03d%s\", addr.isGroup() ? \"G\" : \"M\", addr.getPhysicalSegmentId(localSegId),\n+                addr.getId(), wantsAck ? \"!\" : \".\");\n+    }\n+\n+    /**\n+     * Generates a scan-command for LCN segment-couplers.\n+     * Used to detect the local segment (where the physical bus connection is located).\n+     *\n+     * @return the PCK command (without address header) as text\n+     */\n+    public static String segmentCouplerScan() {\n+        return \"SK\";\n+    }\n+\n+    /**\n+     * Generates a firmware/serial-number request.\n+     *\n+     * @return the PCK command (without address header) as text\n+     */\n+    public static String requestSn() {\n+        return \"SN\";\n+    }\n+\n+    /**\n+     * Generates a command to request a part of a name of a module.\n+     *\n+     * @param partNumber 0..1\n+     * @return the PCK command (without address header) as text\n+     */\n+    public static String requestModuleName(int partNumber) {\n+        return \"NMN\" + (partNumber + 1);\n+    }\n+\n+    /**\n+     * Generates an output-port status request.\n+     *\n+     * @param outputId 0..3\n+     * @return the PCK command (without address header) as text\n+     * @throws LcnException if out of range\n+     */\n+    public static String requestOutputStatus(int outputId) throws LcnException {\n+        if (outputId < 0 || outputId > 3) {\n+            throw new LcnException();\n+        }\n+        return String.format(\"SMA%d\", outputId + 1);\n+    }\n+\n+    /**\n+     * Generates a dim command for a single output-port.\n+     *\n+     * @param outputId 0..3\n+     * @param percent 0..100\n+     * @param rampMs ramp in milliseconds\n+     * @return the PCK command (without address header) as text\n+     * @throws LcnException if out of range\n+     */\n+    public static String dimOutput(int outputId, double percent, int rampMs) throws LcnException {\n+        if (outputId < 0 || outputId > 3) {\n+            throw new LcnException();\n+        }\n+        int rampNative = PckGenerator.timeToRampValue(rampMs);\n+        int n = (int) Math.round(percent * 2);\n+        if ((n % 2) == 0) { // Use the percent command (supported by all LCN-PCHK versions)\n+            return String.format(\"A%dDI%03d%03d\", outputId + 1, n / 2, rampNative);\n+        } else { // We have a \".5\" value. Use the native command (supported since LCN-PCHK 2.3)\n+            return String.format(\"O%dDI%03d%03d\", outputId + 1, n, rampNative);\n+        }\n+    }\n+\n+    /**\n+     * Generates a dim command for all output-ports.\n+     *\n+     * Attention: This command is supported since module firmware version 180501 AND LCN-PCHK 2.61\n+     *\n+     * @param firstPercent dimmer value of the first output 0..100\n+     * @param secondPercent dimmer value of the first output 0..100\n+     * @param thirdPercent dimmer value of the first output 0..100\n+     * @param fourthPercent dimmer value of the first output 0..100\n+     * @param rampMs ramp in milliseconds\n+     * @return the PCK command (without address header) as text\n+     */\n+    public static String dimAllOutputs(double firstPercent, double secondPercent, double thirdPercent,\n+            double fourthPercent, int rampMs) {\n+        long n1 = Math.round(firstPercent * 2);\n+        long n2 = Math.round(secondPercent * 2);\n+        long n3 = Math.round(thirdPercent * 2);\n+        long n4 = Math.round(fourthPercent * 2);\n+\n+        return String.format(\"OY%03d%03d%03d%03d%03d\", n1, n2, n3, n4, timeToRampValue(rampMs));\n+    }\n+\n+    /**\n+     * Generates a control command for switching all outputs ON or OFF with a fixed ramp of 0.5s.\n+     *\n+     * @param percent 0..100\n+     * @returnthe PCK command (without address header) as text\n+     */\n+    public static String controlAllOutputs(double percent) {\n+        return String.format(\"AH%03d\", Math.round(percent));\n+    }\n+\n+    /**\n+     * Generates a control command for switching dimmer output 1 and 2 both ON or OFF with a fixed ramp of 0.5s or\n+     * without ramp.\n+     *\n+     * @param on true, if outputs shall be switched on\n+     * @param ramp true, if the ramp shall be 0.5s, else 0s\n+     * @return the PCK command (without address header) as text\n+     */\n+    public static String controlOutputs12(boolean on, boolean ramp) {\n+        int commandByte;\n+        if (on) {\n+            commandByte = ramp ? 0xC8 : 0xFD;\n+        } else {\n+            commandByte = ramp ? 0x00 : 0xFC;\n+        }\n+        return String.format(\"X2%03d%03d%03d\", 1, commandByte, commandByte);\n+    }\n+\n+    /**\n+     * Generates a dim command for setting the brightness of dimmer output 1 and 2 with a fixed ramp of 0.5s.\n+     *\n+     * @param percent brightness of both outputs 0..100\n+     * @return the PCK command (without address header) as text\n+     */\n+    public static String dimOutputs12(double percent) {\n+        long localPercent = Math.round(percent);\n+        return String.format(\"AY%03d%03d\", localPercent, localPercent);\n+    }\n+\n+    /**\n+     * Let an output flicker.\n+     *\n+     * @param outputId output id 0..3\n+     * @param depth flicker depth, the higher the deeper 0..2\n+     * @param ramp the flicker speed 0..2\n+     * @param count number of flashes 1..15\n+     * @return the PCK command (without address header) as text\n+     * @throws LcnException when the input values are out of range\n+     */\n+    public static String flickerOutput(int outputId, int depth, int ramp, int count) throws LcnException {\n+        if (outputId < 0 || outputId > 3) {\n+            throw new LcnException(\"Output number out of range\");\n+        }\n+        if (count < 1 || count > 15) {\n+            throw new LcnException(\"Number of flashes out of range\");\n+        }\n+        String depthString;\n+        switch (depth) {\n+            case 0:\n+                depthString = \"G\";\n+                break;\n+            case 1:\n+                depthString = \"M\";\n+                break;\n+            case 2:\n+                depthString = \"S\";\n+                break;\n+            default:\n+                throw new LcnException(\"Depth out of range\");\n+        }\n+        String rampString;\n+        switch (ramp) {\n+            case 0:\n+                rampString = \"L\";\n+                break;\n+            case 1:\n+                rampString = \"M\";\n+                break;\n+            case 2:\n+                rampString = \"S\";\n+                break;\n+            default:\n+                throw new LcnException(\"Ramp out of range\");\n+        }\n+        return String.format(\"A%dFL%s%s%02d\", outputId + 1, depthString, rampString, count);\n+    }\n+\n+    /**\n+     * Generates a command to change the value of an output-port.\n+     *\n+     * @param outputId 0..3\n+     * @param percent -100..100\n+     * @return the PCK command (without address header) as text\n+     * @throws LcnException if out of range\n+     */\n+    public static String relOutput(int outputId, double percent) throws LcnException {\n+        if (outputId < 0 || outputId > 3) {\n+            throw new LcnException();\n+        }\n+        int n = (int) Math.round(percent * 2);\n+        if ((n % 2) == 0) { // Use the percent command (supported by all LCN-PCHK versions)\n+            return String.format(\"A%d%s%03d\", outputId + 1, percent >= 0 ? \"AD\" : \"SB\", Math.abs(n / 2));\n+        } else { // We have a \".5\" value. Use the native command (supported since LCN-PCHK 2.3)\n+            return String.format(\"O%d%s%03d\", outputId + 1, percent >= 0 ? \"AD\" : \"SB\", Math.abs(n));\n+        }\n+    }\n+\n+    /**\n+     * Generates a command that toggles a single output-port (on->off, off->on).\n+     *\n+     * @param outputId 0..3\n+     * @param ramp see {@link PckGenerator#timeToRampValue(int)}\n+     * @return the PCK command (without address header) as text\n+     * @throws LcnException if out of range\n+     */\n+    public static String toggleOutput(int outputId, int ramp) throws LcnException {\n+        if (outputId < 0 || outputId > 3) {\n+            throw new LcnException();\n+        }\n+        return String.format(\"A%dTA%03d\", outputId + 1, ramp);\n+    }\n+\n+    /**\n+     * Generates a command that toggles all output-ports (on->off, off->on).\n+     *\n+     * @param ramp see {@link PckGenerator#timeToRampValue(int)}\n+     * @return the PCK command (without address header) as text\n+     */\n+    public static String toggleAllOutputs(int ramp) {\n+        return String.format(\"AU%03d\", ramp);\n+    }\n+\n+    /**\n+     * Generates a relays-status request.\n+     *\n+     * @return the PCK command (without address header) as text\n+     */\n+    public static String requestRelaysStatus() {\n+        return \"SMR\";\n+    }\n+\n+    /**\n+     * Generates a command to control relays.\n+     *\n+     * @param states the 8 modifiers for the relay states\n+     * @return the PCK command (without address header) as text\n+     * @throws LcnException if out of range\n+     */\n+    public static String controlRelays(LcnDefs.RelayStateModifier[] states) throws LcnException {\n+        if (states.length != 8) {\n+            throw new LcnException();\n+        }\n+        String ret = \"R8\";\n+        for (int i = 0; i < 8; ++i) {\n+            switch (states[i]) {\n+                case ON:\n+                    ret += \"1\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ce02f433e5d4071dbebb9ee68da0e22895887b6b"}, "originalPosition": 317}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjg4NjQ4OQ==", "bodyText": "Use a StringBuilder here.", "url": "https://github.com/openhab/openhab-addons/pull/7509#discussion_r436886489", "createdAt": "2020-06-08T17:49:25Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.lcn/src/main/java/org/openhab/binding/lcn/internal/common/PckGenerator.java", "diffHunk": "@@ -0,0 +1,779 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.lcn.internal.common;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.binding.lcn.internal.LcnBindingConstants;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Helpers to generate LCN-PCK commands.\n+ * <p>\n+ * LCN-PCK is the command-syntax used by LCN-PCHK to send and receive LCN commands.\n+ *\n+ * @author Tobias J\u00fcttner - Initial Contribution\n+ * @author Fabian Wolter - Migration to OH2\n+ */\n+@NonNullByDefault\n+public final class PckGenerator {\n+    private static final Logger LOGGER = LoggerFactory.getLogger(PckGenerator.class);\n+    /** Termination character after a PCK message */\n+    public static final String TERMINATION = \"\\n\";\n+\n+    /**\n+     * Generates a keep-alive.\n+     * LCN-PCHK will close the connection if it does not receive any commands from\n+     * an open {@link Connection} for a specific period (10 minutes by default).\n+     *\n+     * @param counter the current ping's id (optional, but \"best practice\"). Should start with 1\n+     * @return the PCK command as text\n+     */\n+    public static String ping(int counter) {\n+        return String.format(\"^ping%d\", counter);\n+    }\n+\n+    /**\n+     * Generates a PCK command that will set the LCN-PCHK connection's operation mode.\n+     * This influences how output-port commands and status are interpreted and must be\n+     * in sync with the LCN bus.\n+     *\n+     * @param dimMode see {@link LcnDefs.OutputPortDimMode}\n+     * @param statusMode see {@link LcnDefs.OutputPortStatusMode}\n+     * @return the PCK command as text\n+     */\n+    public static String setOperationMode(LcnDefs.OutputPortDimMode dimMode, LcnDefs.OutputPortStatusMode statusMode) {\n+        return \"!OM\" + (dimMode == LcnDefs.OutputPortDimMode.NATIVE200 ? \"1\" : \"0\")\n+                + (statusMode == LcnDefs.OutputPortStatusMode.PERCENT ? \"P\" : \"N\");\n+    }\n+\n+    /**\n+     * Generates a PCK address header.\n+     * Used for commands to LCN modules and groups.\n+     *\n+     * @param addr the target's address (module or group)\n+     * @param localSegId the local segment id where the physical bus connection is located\n+     * @param wantsAck true to claim an acknowledge / receipt from the target\n+     * @return the PCK address header as text\n+     */\n+    public static String generateAddressHeader(LcnAddr addr, int localSegId, boolean wantsAck) {\n+        return String.format(\">%s%03d%03d%s\", addr.isGroup() ? \"G\" : \"M\", addr.getPhysicalSegmentId(localSegId),\n+                addr.getId(), wantsAck ? \"!\" : \".\");\n+    }\n+\n+    /**\n+     * Generates a scan-command for LCN segment-couplers.\n+     * Used to detect the local segment (where the physical bus connection is located).\n+     *\n+     * @return the PCK command (without address header) as text\n+     */\n+    public static String segmentCouplerScan() {\n+        return \"SK\";\n+    }\n+\n+    /**\n+     * Generates a firmware/serial-number request.\n+     *\n+     * @return the PCK command (without address header) as text\n+     */\n+    public static String requestSn() {\n+        return \"SN\";\n+    }\n+\n+    /**\n+     * Generates a command to request a part of a name of a module.\n+     *\n+     * @param partNumber 0..1\n+     * @return the PCK command (without address header) as text\n+     */\n+    public static String requestModuleName(int partNumber) {\n+        return \"NMN\" + (partNumber + 1);\n+    }\n+\n+    /**\n+     * Generates an output-port status request.\n+     *\n+     * @param outputId 0..3\n+     * @return the PCK command (without address header) as text\n+     * @throws LcnException if out of range\n+     */\n+    public static String requestOutputStatus(int outputId) throws LcnException {\n+        if (outputId < 0 || outputId > 3) {\n+            throw new LcnException();\n+        }\n+        return String.format(\"SMA%d\", outputId + 1);\n+    }\n+\n+    /**\n+     * Generates a dim command for a single output-port.\n+     *\n+     * @param outputId 0..3\n+     * @param percent 0..100\n+     * @param rampMs ramp in milliseconds\n+     * @return the PCK command (without address header) as text\n+     * @throws LcnException if out of range\n+     */\n+    public static String dimOutput(int outputId, double percent, int rampMs) throws LcnException {\n+        if (outputId < 0 || outputId > 3) {\n+            throw new LcnException();\n+        }\n+        int rampNative = PckGenerator.timeToRampValue(rampMs);\n+        int n = (int) Math.round(percent * 2);\n+        if ((n % 2) == 0) { // Use the percent command (supported by all LCN-PCHK versions)\n+            return String.format(\"A%dDI%03d%03d\", outputId + 1, n / 2, rampNative);\n+        } else { // We have a \".5\" value. Use the native command (supported since LCN-PCHK 2.3)\n+            return String.format(\"O%dDI%03d%03d\", outputId + 1, n, rampNative);\n+        }\n+    }\n+\n+    /**\n+     * Generates a dim command for all output-ports.\n+     *\n+     * Attention: This command is supported since module firmware version 180501 AND LCN-PCHK 2.61\n+     *\n+     * @param firstPercent dimmer value of the first output 0..100\n+     * @param secondPercent dimmer value of the first output 0..100\n+     * @param thirdPercent dimmer value of the first output 0..100\n+     * @param fourthPercent dimmer value of the first output 0..100\n+     * @param rampMs ramp in milliseconds\n+     * @return the PCK command (without address header) as text\n+     */\n+    public static String dimAllOutputs(double firstPercent, double secondPercent, double thirdPercent,\n+            double fourthPercent, int rampMs) {\n+        long n1 = Math.round(firstPercent * 2);\n+        long n2 = Math.round(secondPercent * 2);\n+        long n3 = Math.round(thirdPercent * 2);\n+        long n4 = Math.round(fourthPercent * 2);\n+\n+        return String.format(\"OY%03d%03d%03d%03d%03d\", n1, n2, n3, n4, timeToRampValue(rampMs));\n+    }\n+\n+    /**\n+     * Generates a control command for switching all outputs ON or OFF with a fixed ramp of 0.5s.\n+     *\n+     * @param percent 0..100\n+     * @returnthe PCK command (without address header) as text\n+     */\n+    public static String controlAllOutputs(double percent) {\n+        return String.format(\"AH%03d\", Math.round(percent));\n+    }\n+\n+    /**\n+     * Generates a control command for switching dimmer output 1 and 2 both ON or OFF with a fixed ramp of 0.5s or\n+     * without ramp.\n+     *\n+     * @param on true, if outputs shall be switched on\n+     * @param ramp true, if the ramp shall be 0.5s, else 0s\n+     * @return the PCK command (without address header) as text\n+     */\n+    public static String controlOutputs12(boolean on, boolean ramp) {\n+        int commandByte;\n+        if (on) {\n+            commandByte = ramp ? 0xC8 : 0xFD;\n+        } else {\n+            commandByte = ramp ? 0x00 : 0xFC;\n+        }\n+        return String.format(\"X2%03d%03d%03d\", 1, commandByte, commandByte);\n+    }\n+\n+    /**\n+     * Generates a dim command for setting the brightness of dimmer output 1 and 2 with a fixed ramp of 0.5s.\n+     *\n+     * @param percent brightness of both outputs 0..100\n+     * @return the PCK command (without address header) as text\n+     */\n+    public static String dimOutputs12(double percent) {\n+        long localPercent = Math.round(percent);\n+        return String.format(\"AY%03d%03d\", localPercent, localPercent);\n+    }\n+\n+    /**\n+     * Let an output flicker.\n+     *\n+     * @param outputId output id 0..3\n+     * @param depth flicker depth, the higher the deeper 0..2\n+     * @param ramp the flicker speed 0..2\n+     * @param count number of flashes 1..15\n+     * @return the PCK command (without address header) as text\n+     * @throws LcnException when the input values are out of range\n+     */\n+    public static String flickerOutput(int outputId, int depth, int ramp, int count) throws LcnException {\n+        if (outputId < 0 || outputId > 3) {\n+            throw new LcnException(\"Output number out of range\");\n+        }\n+        if (count < 1 || count > 15) {\n+            throw new LcnException(\"Number of flashes out of range\");\n+        }\n+        String depthString;\n+        switch (depth) {\n+            case 0:\n+                depthString = \"G\";\n+                break;\n+            case 1:\n+                depthString = \"M\";\n+                break;\n+            case 2:\n+                depthString = \"S\";\n+                break;\n+            default:\n+                throw new LcnException(\"Depth out of range\");\n+        }\n+        String rampString;\n+        switch (ramp) {\n+            case 0:\n+                rampString = \"L\";\n+                break;\n+            case 1:\n+                rampString = \"M\";\n+                break;\n+            case 2:\n+                rampString = \"S\";\n+                break;\n+            default:\n+                throw new LcnException(\"Ramp out of range\");\n+        }\n+        return String.format(\"A%dFL%s%s%02d\", outputId + 1, depthString, rampString, count);\n+    }\n+\n+    /**\n+     * Generates a command to change the value of an output-port.\n+     *\n+     * @param outputId 0..3\n+     * @param percent -100..100\n+     * @return the PCK command (without address header) as text\n+     * @throws LcnException if out of range\n+     */\n+    public static String relOutput(int outputId, double percent) throws LcnException {\n+        if (outputId < 0 || outputId > 3) {\n+            throw new LcnException();\n+        }\n+        int n = (int) Math.round(percent * 2);\n+        if ((n % 2) == 0) { // Use the percent command (supported by all LCN-PCHK versions)\n+            return String.format(\"A%d%s%03d\", outputId + 1, percent >= 0 ? \"AD\" : \"SB\", Math.abs(n / 2));\n+        } else { // We have a \".5\" value. Use the native command (supported since LCN-PCHK 2.3)\n+            return String.format(\"O%d%s%03d\", outputId + 1, percent >= 0 ? \"AD\" : \"SB\", Math.abs(n));\n+        }\n+    }\n+\n+    /**\n+     * Generates a command that toggles a single output-port (on->off, off->on).\n+     *\n+     * @param outputId 0..3\n+     * @param ramp see {@link PckGenerator#timeToRampValue(int)}\n+     * @return the PCK command (without address header) as text\n+     * @throws LcnException if out of range\n+     */\n+    public static String toggleOutput(int outputId, int ramp) throws LcnException {\n+        if (outputId < 0 || outputId > 3) {\n+            throw new LcnException();\n+        }\n+        return String.format(\"A%dTA%03d\", outputId + 1, ramp);\n+    }\n+\n+    /**\n+     * Generates a command that toggles all output-ports (on->off, off->on).\n+     *\n+     * @param ramp see {@link PckGenerator#timeToRampValue(int)}\n+     * @return the PCK command (without address header) as text\n+     */\n+    public static String toggleAllOutputs(int ramp) {\n+        return String.format(\"AU%03d\", ramp);\n+    }\n+\n+    /**\n+     * Generates a relays-status request.\n+     *\n+     * @return the PCK command (without address header) as text\n+     */\n+    public static String requestRelaysStatus() {\n+        return \"SMR\";\n+    }\n+\n+    /**\n+     * Generates a command to control relays.\n+     *\n+     * @param states the 8 modifiers for the relay states\n+     * @return the PCK command (without address header) as text\n+     * @throws LcnException if out of range\n+     */\n+    public static String controlRelays(LcnDefs.RelayStateModifier[] states) throws LcnException {\n+        if (states.length != 8) {\n+            throw new LcnException();\n+        }\n+        String ret = \"R8\";\n+        for (int i = 0; i < 8; ++i) {\n+            switch (states[i]) {\n+                case ON:\n+                    ret += \"1\";\n+                    break;\n+                case OFF:\n+                    ret += \"0\";\n+                    break;\n+                case TOGGLE:\n+                    ret += \"U\";\n+                    break;\n+                case NOCHANGE:\n+                    ret += \"-\";\n+                    break;\n+                default:\n+                    throw new LcnException();\n+            }\n+        }\n+        return ret;\n+    }\n+\n+    /**\n+     * Generates a binary-sensors status request.\n+     *\n+     * @return the PCK command (without address header) as text\n+     */\n+    public static String requestBinSensorsStatus() {\n+        return \"SMB\";\n+    }\n+\n+    /**\n+     * Generates a command that sets a variable absolute.\n+     *\n+     * @param number regulator number 0..1\n+     * @param value the absolute value to set\n+     * @return the PCK command (without address header) as text\n+     * @throws LcnException\n+     */\n+    public static String setSetpointAbsolute(int number, int value) {\n+        int internalValue = value;\n+        // Set absolute (not in PCK yet)\n+        int b1 = number << 6; // 01000000\n+        b1 |= 0x20; // xx10xxxx (set absolute)\n+        if (value < 1000) {\n+            internalValue = 1000 - internalValue;\n+            b1 |= 8;\n+        } else {\n+            internalValue -= 1000;\n+        }\n+        b1 |= (internalValue >> 8) & 0x0f; // xxxx1111\n+        int b2 = internalValue & 0xff;\n+        return String.format(\"X2%03d%03d%03d\", 30, b1, b2);\n+    }\n+\n+    /**\n+     * Generates a command to change the value of a variable.\n+     *\n+     * @param variable the target variable to change\n+     * @param type the reference-point\n+     * @param value the native LCN value to add/subtract (can be negative)\n+     * @return the PCK command (without address header) as text\n+     * @throws LcnException if command is not supported\n+     */\n+    public static String setVariableRelative(Variable variable, LcnDefs.RelVarRef type, int value) {\n+        if (variable.getNumber() == 0) {\n+            // Old command for variable 1 / T-var (compatible with all modules)\n+            return String.format(\"Z%s%d\", value >= 0 ? \"A\" : \"S\", Math.abs(value));\n+        } else { // New command for variable 1-12 (compatible with all modules, since LCN-PCHK 2.8)\n+            return String.format(\"Z%s%03d%d\", value >= 0 ? \"+\" : \"-\", variable.getNumber() + 1, Math.abs(value));\n+        }\n+    }\n+\n+    /**\n+     * Generates a command the change the value of a regulator setpoint relative.\n+     *\n+     * @param number 0..1\n+     * @param type relative to the current or to the programmed value\n+     * @param value the relative value -4000..+4000\n+     * @return the PCK command (without address header) as text\n+     */\n+    public static String setSetpointRelative(int number, LcnDefs.RelVarRef type, int value) {\n+        return String.format(\"RE%sS%s%s%d\", number == 0 ? \"A\" : \"B\", type == LcnDefs.RelVarRef.CURRENT ? \"A\" : \"P\",\n+                value >= 0 ? \"+\" : \"-\", Math.abs(value));\n+    }\n+\n+    /**\n+     * Generates a command the change the value of a threshold relative.\n+     *\n+     * @param variable the threshold to change\n+     * @param type relative to the current or to the programmed value\n+     * @param value the relative value -4000..+4000\n+     * @param is2013 true, if the LCN module's firmware is equal to or newer than 2013\n+     * @return the PCK command (without address header) as text\n+     */\n+    public static String setThresholdRelative(Variable variable, LcnDefs.RelVarRef type, int value, boolean is2013)\n+            throws LcnException {\n+        if (is2013) { // New command for registers 1-4 (since 170206, LCN-PCHK 2.8)\n+            return String.format(\"SS%s%04d%sR%d%d\", type == LcnDefs.RelVarRef.CURRENT ? \"R\" : \"E\", Math.abs(value),\n+                    value >= 0 ? \"A\" : \"S\", variable.getNumber() + 1, variable.getThresholdNumber().get() + 1);\n+        } else if (variable.getNumber() == 0) { // Old command for register 1 (before 170206)\n+            return String.format(\"SS%s%04d%s%s%s%s%s%s\", type == LcnDefs.RelVarRef.CURRENT ? \"R\" : \"E\", Math.abs(value),\n+                    value >= 0 ? \"A\" : \"S\", variable.getThresholdNumber().get() == 0 ? \"1\" : \"0\",\n+                    variable.getThresholdNumber().get() == 1 ? \"1\" : \"0\",\n+                    variable.getThresholdNumber().get() == 2 ? \"1\" : \"0\",\n+                    variable.getThresholdNumber().get() == 3 ? \"1\" : \"0\",\n+                    variable.getThresholdNumber().get() == 4 ? \"1\" : \"0\");\n+        } else {\n+            throw new LcnException(\n+                    \"Module does not have threshold register \" + (variable.getThresholdNumber().get() + 1));\n+        }\n+    }\n+\n+    /**\n+     * Generates a variable value request.\n+     *\n+     * @param variable the variable to request\n+     * @param firmwareVersion the target module's firmware version\n+     * @return the PCK command (without address header) as text\n+     * @throws LcnException if command is not supported\n+     */\n+    public static String requestVarStatus(Variable variable, int firmwareVersion) throws LcnException {\n+        if (firmwareVersion >= LcnBindingConstants.FIRMWARE_2013) {\n+            int id = variable.getNumber();\n+            switch (variable.getType()) {\n+                case UNKNOWN:\n+                    throw new LcnException(\"Variable unknown\");\n+                case VARIABLE:\n+                    return String.format(\"MWT%03d\", id + 1);\n+                case REGULATOR:\n+                    return String.format(\"MWS%03d\", id + 1);\n+                case THRESHOLD:\n+                    return String.format(\"SE%03d\", id + 1); // Whole register\n+                case S0INPUT:\n+                    return String.format(\"MWC%03d\", id + 1);\n+            }\n+            throw new LcnException(\"Unsupported variable type: \" + variable);\n+        } else {\n+            switch (variable) {\n+                case VARIABLE1:\n+                    return \"MWV\";\n+                case VARIABLE2:\n+                    return \"MWTA\";\n+                case VARIABLE3:\n+                    return \"MWTB\";\n+                case RVARSETPOINT1:\n+                    return \"MWSA\";\n+                case RVARSETPOINT2:\n+                    return \"MWSB\";\n+                case THRESHOLDREGISTER11:\n+                case THRESHOLDREGISTER12:\n+                case THRESHOLDREGISTER13:\n+                case THRESHOLDREGISTER14:\n+                case THRESHOLDREGISTER15:\n+                    return \"SL1\"; // Whole register\n+                default:\n+                    throw new LcnException(\"Unsupported variable type: \" + variable);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Generates a request for LED and logic-operations states.\n+     *\n+     * @return the PCK command (without address header) as text\n+     */\n+    public static String requestLedsAndLogicOpsStatus() {\n+        return \"SMT\";\n+    }\n+\n+    /**\n+     * Generates a command to the set the state of a single LED.\n+     *\n+     * @param ledId 0..11\n+     * @param state the state to set\n+     * @return the PCK command (without address header) as text\n+     * @throws LcnException if out of range\n+     */\n+    public static String controlLed(int ledId, LcnDefs.LedStatus state) throws LcnException {\n+        if (ledId < 0 || ledId > 11) {\n+            throw new LcnException();\n+        }\n+        return String.format(\"LA%03d%s\", ledId + 1, state == LcnDefs.LedStatus.OFF ? \"A\"\n+                : state == LcnDefs.LedStatus.ON ? \"E\" : state == LcnDefs.LedStatus.BLINK ? \"B\" : \"F\");\n+    }\n+\n+    /**\n+     * Generates a command to send LCN keys.\n+     *\n+     * @param cmds the 4 concrete commands to send for the tables (A-D)\n+     * @param keys the tables' 8 key-states (true means \"send\")\n+     * @return the PCK command (without address header) as text\n+     * @throws IllegalArgumentException if out of range\n+     */\n+    public static String sendKeys(LcnDefs.SendKeyCommand[] cmds, boolean[] keys) throws LcnException {\n+        if (cmds.length != 4 || keys.length != 8) {\n+            throw new LcnException();\n+        }\n+        String ret = \"TS\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ce02f433e5d4071dbebb9ee68da0e22895887b6b"}, "originalPosition": 511}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjg4ODM0OA==", "bodyText": "here too", "url": "https://github.com/openhab/openhab-addons/pull/7509#discussion_r436888348", "createdAt": "2020-06-08T17:52:38Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.lcn/src/main/java/org/openhab/binding/lcn/internal/common/PckGenerator.java", "diffHunk": "@@ -0,0 +1,779 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.lcn.internal.common;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.binding.lcn.internal.LcnBindingConstants;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Helpers to generate LCN-PCK commands.\n+ * <p>\n+ * LCN-PCK is the command-syntax used by LCN-PCHK to send and receive LCN commands.\n+ *\n+ * @author Tobias J\u00fcttner - Initial Contribution\n+ * @author Fabian Wolter - Migration to OH2\n+ */\n+@NonNullByDefault\n+public final class PckGenerator {\n+    private static final Logger LOGGER = LoggerFactory.getLogger(PckGenerator.class);\n+    /** Termination character after a PCK message */\n+    public static final String TERMINATION = \"\\n\";\n+\n+    /**\n+     * Generates a keep-alive.\n+     * LCN-PCHK will close the connection if it does not receive any commands from\n+     * an open {@link Connection} for a specific period (10 minutes by default).\n+     *\n+     * @param counter the current ping's id (optional, but \"best practice\"). Should start with 1\n+     * @return the PCK command as text\n+     */\n+    public static String ping(int counter) {\n+        return String.format(\"^ping%d\", counter);\n+    }\n+\n+    /**\n+     * Generates a PCK command that will set the LCN-PCHK connection's operation mode.\n+     * This influences how output-port commands and status are interpreted and must be\n+     * in sync with the LCN bus.\n+     *\n+     * @param dimMode see {@link LcnDefs.OutputPortDimMode}\n+     * @param statusMode see {@link LcnDefs.OutputPortStatusMode}\n+     * @return the PCK command as text\n+     */\n+    public static String setOperationMode(LcnDefs.OutputPortDimMode dimMode, LcnDefs.OutputPortStatusMode statusMode) {\n+        return \"!OM\" + (dimMode == LcnDefs.OutputPortDimMode.NATIVE200 ? \"1\" : \"0\")\n+                + (statusMode == LcnDefs.OutputPortStatusMode.PERCENT ? \"P\" : \"N\");\n+    }\n+\n+    /**\n+     * Generates a PCK address header.\n+     * Used for commands to LCN modules and groups.\n+     *\n+     * @param addr the target's address (module or group)\n+     * @param localSegId the local segment id where the physical bus connection is located\n+     * @param wantsAck true to claim an acknowledge / receipt from the target\n+     * @return the PCK address header as text\n+     */\n+    public static String generateAddressHeader(LcnAddr addr, int localSegId, boolean wantsAck) {\n+        return String.format(\">%s%03d%03d%s\", addr.isGroup() ? \"G\" : \"M\", addr.getPhysicalSegmentId(localSegId),\n+                addr.getId(), wantsAck ? \"!\" : \".\");\n+    }\n+\n+    /**\n+     * Generates a scan-command for LCN segment-couplers.\n+     * Used to detect the local segment (where the physical bus connection is located).\n+     *\n+     * @return the PCK command (without address header) as text\n+     */\n+    public static String segmentCouplerScan() {\n+        return \"SK\";\n+    }\n+\n+    /**\n+     * Generates a firmware/serial-number request.\n+     *\n+     * @return the PCK command (without address header) as text\n+     */\n+    public static String requestSn() {\n+        return \"SN\";\n+    }\n+\n+    /**\n+     * Generates a command to request a part of a name of a module.\n+     *\n+     * @param partNumber 0..1\n+     * @return the PCK command (without address header) as text\n+     */\n+    public static String requestModuleName(int partNumber) {\n+        return \"NMN\" + (partNumber + 1);\n+    }\n+\n+    /**\n+     * Generates an output-port status request.\n+     *\n+     * @param outputId 0..3\n+     * @return the PCK command (without address header) as text\n+     * @throws LcnException if out of range\n+     */\n+    public static String requestOutputStatus(int outputId) throws LcnException {\n+        if (outputId < 0 || outputId > 3) {\n+            throw new LcnException();\n+        }\n+        return String.format(\"SMA%d\", outputId + 1);\n+    }\n+\n+    /**\n+     * Generates a dim command for a single output-port.\n+     *\n+     * @param outputId 0..3\n+     * @param percent 0..100\n+     * @param rampMs ramp in milliseconds\n+     * @return the PCK command (without address header) as text\n+     * @throws LcnException if out of range\n+     */\n+    public static String dimOutput(int outputId, double percent, int rampMs) throws LcnException {\n+        if (outputId < 0 || outputId > 3) {\n+            throw new LcnException();\n+        }\n+        int rampNative = PckGenerator.timeToRampValue(rampMs);\n+        int n = (int) Math.round(percent * 2);\n+        if ((n % 2) == 0) { // Use the percent command (supported by all LCN-PCHK versions)\n+            return String.format(\"A%dDI%03d%03d\", outputId + 1, n / 2, rampNative);\n+        } else { // We have a \".5\" value. Use the native command (supported since LCN-PCHK 2.3)\n+            return String.format(\"O%dDI%03d%03d\", outputId + 1, n, rampNative);\n+        }\n+    }\n+\n+    /**\n+     * Generates a dim command for all output-ports.\n+     *\n+     * Attention: This command is supported since module firmware version 180501 AND LCN-PCHK 2.61\n+     *\n+     * @param firstPercent dimmer value of the first output 0..100\n+     * @param secondPercent dimmer value of the first output 0..100\n+     * @param thirdPercent dimmer value of the first output 0..100\n+     * @param fourthPercent dimmer value of the first output 0..100\n+     * @param rampMs ramp in milliseconds\n+     * @return the PCK command (without address header) as text\n+     */\n+    public static String dimAllOutputs(double firstPercent, double secondPercent, double thirdPercent,\n+            double fourthPercent, int rampMs) {\n+        long n1 = Math.round(firstPercent * 2);\n+        long n2 = Math.round(secondPercent * 2);\n+        long n3 = Math.round(thirdPercent * 2);\n+        long n4 = Math.round(fourthPercent * 2);\n+\n+        return String.format(\"OY%03d%03d%03d%03d%03d\", n1, n2, n3, n4, timeToRampValue(rampMs));\n+    }\n+\n+    /**\n+     * Generates a control command for switching all outputs ON or OFF with a fixed ramp of 0.5s.\n+     *\n+     * @param percent 0..100\n+     * @returnthe PCK command (without address header) as text\n+     */\n+    public static String controlAllOutputs(double percent) {\n+        return String.format(\"AH%03d\", Math.round(percent));\n+    }\n+\n+    /**\n+     * Generates a control command for switching dimmer output 1 and 2 both ON or OFF with a fixed ramp of 0.5s or\n+     * without ramp.\n+     *\n+     * @param on true, if outputs shall be switched on\n+     * @param ramp true, if the ramp shall be 0.5s, else 0s\n+     * @return the PCK command (without address header) as text\n+     */\n+    public static String controlOutputs12(boolean on, boolean ramp) {\n+        int commandByte;\n+        if (on) {\n+            commandByte = ramp ? 0xC8 : 0xFD;\n+        } else {\n+            commandByte = ramp ? 0x00 : 0xFC;\n+        }\n+        return String.format(\"X2%03d%03d%03d\", 1, commandByte, commandByte);\n+    }\n+\n+    /**\n+     * Generates a dim command for setting the brightness of dimmer output 1 and 2 with a fixed ramp of 0.5s.\n+     *\n+     * @param percent brightness of both outputs 0..100\n+     * @return the PCK command (without address header) as text\n+     */\n+    public static String dimOutputs12(double percent) {\n+        long localPercent = Math.round(percent);\n+        return String.format(\"AY%03d%03d\", localPercent, localPercent);\n+    }\n+\n+    /**\n+     * Let an output flicker.\n+     *\n+     * @param outputId output id 0..3\n+     * @param depth flicker depth, the higher the deeper 0..2\n+     * @param ramp the flicker speed 0..2\n+     * @param count number of flashes 1..15\n+     * @return the PCK command (without address header) as text\n+     * @throws LcnException when the input values are out of range\n+     */\n+    public static String flickerOutput(int outputId, int depth, int ramp, int count) throws LcnException {\n+        if (outputId < 0 || outputId > 3) {\n+            throw new LcnException(\"Output number out of range\");\n+        }\n+        if (count < 1 || count > 15) {\n+            throw new LcnException(\"Number of flashes out of range\");\n+        }\n+        String depthString;\n+        switch (depth) {\n+            case 0:\n+                depthString = \"G\";\n+                break;\n+            case 1:\n+                depthString = \"M\";\n+                break;\n+            case 2:\n+                depthString = \"S\";\n+                break;\n+            default:\n+                throw new LcnException(\"Depth out of range\");\n+        }\n+        String rampString;\n+        switch (ramp) {\n+            case 0:\n+                rampString = \"L\";\n+                break;\n+            case 1:\n+                rampString = \"M\";\n+                break;\n+            case 2:\n+                rampString = \"S\";\n+                break;\n+            default:\n+                throw new LcnException(\"Ramp out of range\");\n+        }\n+        return String.format(\"A%dFL%s%s%02d\", outputId + 1, depthString, rampString, count);\n+    }\n+\n+    /**\n+     * Generates a command to change the value of an output-port.\n+     *\n+     * @param outputId 0..3\n+     * @param percent -100..100\n+     * @return the PCK command (without address header) as text\n+     * @throws LcnException if out of range\n+     */\n+    public static String relOutput(int outputId, double percent) throws LcnException {\n+        if (outputId < 0 || outputId > 3) {\n+            throw new LcnException();\n+        }\n+        int n = (int) Math.round(percent * 2);\n+        if ((n % 2) == 0) { // Use the percent command (supported by all LCN-PCHK versions)\n+            return String.format(\"A%d%s%03d\", outputId + 1, percent >= 0 ? \"AD\" : \"SB\", Math.abs(n / 2));\n+        } else { // We have a \".5\" value. Use the native command (supported since LCN-PCHK 2.3)\n+            return String.format(\"O%d%s%03d\", outputId + 1, percent >= 0 ? \"AD\" : \"SB\", Math.abs(n));\n+        }\n+    }\n+\n+    /**\n+     * Generates a command that toggles a single output-port (on->off, off->on).\n+     *\n+     * @param outputId 0..3\n+     * @param ramp see {@link PckGenerator#timeToRampValue(int)}\n+     * @return the PCK command (without address header) as text\n+     * @throws LcnException if out of range\n+     */\n+    public static String toggleOutput(int outputId, int ramp) throws LcnException {\n+        if (outputId < 0 || outputId > 3) {\n+            throw new LcnException();\n+        }\n+        return String.format(\"A%dTA%03d\", outputId + 1, ramp);\n+    }\n+\n+    /**\n+     * Generates a command that toggles all output-ports (on->off, off->on).\n+     *\n+     * @param ramp see {@link PckGenerator#timeToRampValue(int)}\n+     * @return the PCK command (without address header) as text\n+     */\n+    public static String toggleAllOutputs(int ramp) {\n+        return String.format(\"AU%03d\", ramp);\n+    }\n+\n+    /**\n+     * Generates a relays-status request.\n+     *\n+     * @return the PCK command (without address header) as text\n+     */\n+    public static String requestRelaysStatus() {\n+        return \"SMR\";\n+    }\n+\n+    /**\n+     * Generates a command to control relays.\n+     *\n+     * @param states the 8 modifiers for the relay states\n+     * @return the PCK command (without address header) as text\n+     * @throws LcnException if out of range\n+     */\n+    public static String controlRelays(LcnDefs.RelayStateModifier[] states) throws LcnException {\n+        if (states.length != 8) {\n+            throw new LcnException();\n+        }\n+        String ret = \"R8\";\n+        for (int i = 0; i < 8; ++i) {\n+            switch (states[i]) {\n+                case ON:\n+                    ret += \"1\";\n+                    break;\n+                case OFF:\n+                    ret += \"0\";\n+                    break;\n+                case TOGGLE:\n+                    ret += \"U\";\n+                    break;\n+                case NOCHANGE:\n+                    ret += \"-\";\n+                    break;\n+                default:\n+                    throw new LcnException();\n+            }\n+        }\n+        return ret;\n+    }\n+\n+    /**\n+     * Generates a binary-sensors status request.\n+     *\n+     * @return the PCK command (without address header) as text\n+     */\n+    public static String requestBinSensorsStatus() {\n+        return \"SMB\";\n+    }\n+\n+    /**\n+     * Generates a command that sets a variable absolute.\n+     *\n+     * @param number regulator number 0..1\n+     * @param value the absolute value to set\n+     * @return the PCK command (without address header) as text\n+     * @throws LcnException\n+     */\n+    public static String setSetpointAbsolute(int number, int value) {\n+        int internalValue = value;\n+        // Set absolute (not in PCK yet)\n+        int b1 = number << 6; // 01000000\n+        b1 |= 0x20; // xx10xxxx (set absolute)\n+        if (value < 1000) {\n+            internalValue = 1000 - internalValue;\n+            b1 |= 8;\n+        } else {\n+            internalValue -= 1000;\n+        }\n+        b1 |= (internalValue >> 8) & 0x0f; // xxxx1111\n+        int b2 = internalValue & 0xff;\n+        return String.format(\"X2%03d%03d%03d\", 30, b1, b2);\n+    }\n+\n+    /**\n+     * Generates a command to change the value of a variable.\n+     *\n+     * @param variable the target variable to change\n+     * @param type the reference-point\n+     * @param value the native LCN value to add/subtract (can be negative)\n+     * @return the PCK command (without address header) as text\n+     * @throws LcnException if command is not supported\n+     */\n+    public static String setVariableRelative(Variable variable, LcnDefs.RelVarRef type, int value) {\n+        if (variable.getNumber() == 0) {\n+            // Old command for variable 1 / T-var (compatible with all modules)\n+            return String.format(\"Z%s%d\", value >= 0 ? \"A\" : \"S\", Math.abs(value));\n+        } else { // New command for variable 1-12 (compatible with all modules, since LCN-PCHK 2.8)\n+            return String.format(\"Z%s%03d%d\", value >= 0 ? \"+\" : \"-\", variable.getNumber() + 1, Math.abs(value));\n+        }\n+    }\n+\n+    /**\n+     * Generates a command the change the value of a regulator setpoint relative.\n+     *\n+     * @param number 0..1\n+     * @param type relative to the current or to the programmed value\n+     * @param value the relative value -4000..+4000\n+     * @return the PCK command (without address header) as text\n+     */\n+    public static String setSetpointRelative(int number, LcnDefs.RelVarRef type, int value) {\n+        return String.format(\"RE%sS%s%s%d\", number == 0 ? \"A\" : \"B\", type == LcnDefs.RelVarRef.CURRENT ? \"A\" : \"P\",\n+                value >= 0 ? \"+\" : \"-\", Math.abs(value));\n+    }\n+\n+    /**\n+     * Generates a command the change the value of a threshold relative.\n+     *\n+     * @param variable the threshold to change\n+     * @param type relative to the current or to the programmed value\n+     * @param value the relative value -4000..+4000\n+     * @param is2013 true, if the LCN module's firmware is equal to or newer than 2013\n+     * @return the PCK command (without address header) as text\n+     */\n+    public static String setThresholdRelative(Variable variable, LcnDefs.RelVarRef type, int value, boolean is2013)\n+            throws LcnException {\n+        if (is2013) { // New command for registers 1-4 (since 170206, LCN-PCHK 2.8)\n+            return String.format(\"SS%s%04d%sR%d%d\", type == LcnDefs.RelVarRef.CURRENT ? \"R\" : \"E\", Math.abs(value),\n+                    value >= 0 ? \"A\" : \"S\", variable.getNumber() + 1, variable.getThresholdNumber().get() + 1);\n+        } else if (variable.getNumber() == 0) { // Old command for register 1 (before 170206)\n+            return String.format(\"SS%s%04d%s%s%s%s%s%s\", type == LcnDefs.RelVarRef.CURRENT ? \"R\" : \"E\", Math.abs(value),\n+                    value >= 0 ? \"A\" : \"S\", variable.getThresholdNumber().get() == 0 ? \"1\" : \"0\",\n+                    variable.getThresholdNumber().get() == 1 ? \"1\" : \"0\",\n+                    variable.getThresholdNumber().get() == 2 ? \"1\" : \"0\",\n+                    variable.getThresholdNumber().get() == 3 ? \"1\" : \"0\",\n+                    variable.getThresholdNumber().get() == 4 ? \"1\" : \"0\");\n+        } else {\n+            throw new LcnException(\n+                    \"Module does not have threshold register \" + (variable.getThresholdNumber().get() + 1));\n+        }\n+    }\n+\n+    /**\n+     * Generates a variable value request.\n+     *\n+     * @param variable the variable to request\n+     * @param firmwareVersion the target module's firmware version\n+     * @return the PCK command (without address header) as text\n+     * @throws LcnException if command is not supported\n+     */\n+    public static String requestVarStatus(Variable variable, int firmwareVersion) throws LcnException {\n+        if (firmwareVersion >= LcnBindingConstants.FIRMWARE_2013) {\n+            int id = variable.getNumber();\n+            switch (variable.getType()) {\n+                case UNKNOWN:\n+                    throw new LcnException(\"Variable unknown\");\n+                case VARIABLE:\n+                    return String.format(\"MWT%03d\", id + 1);\n+                case REGULATOR:\n+                    return String.format(\"MWS%03d\", id + 1);\n+                case THRESHOLD:\n+                    return String.format(\"SE%03d\", id + 1); // Whole register\n+                case S0INPUT:\n+                    return String.format(\"MWC%03d\", id + 1);\n+            }\n+            throw new LcnException(\"Unsupported variable type: \" + variable);\n+        } else {\n+            switch (variable) {\n+                case VARIABLE1:\n+                    return \"MWV\";\n+                case VARIABLE2:\n+                    return \"MWTA\";\n+                case VARIABLE3:\n+                    return \"MWTB\";\n+                case RVARSETPOINT1:\n+                    return \"MWSA\";\n+                case RVARSETPOINT2:\n+                    return \"MWSB\";\n+                case THRESHOLDREGISTER11:\n+                case THRESHOLDREGISTER12:\n+                case THRESHOLDREGISTER13:\n+                case THRESHOLDREGISTER14:\n+                case THRESHOLDREGISTER15:\n+                    return \"SL1\"; // Whole register\n+                default:\n+                    throw new LcnException(\"Unsupported variable type: \" + variable);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Generates a request for LED and logic-operations states.\n+     *\n+     * @return the PCK command (without address header) as text\n+     */\n+    public static String requestLedsAndLogicOpsStatus() {\n+        return \"SMT\";\n+    }\n+\n+    /**\n+     * Generates a command to the set the state of a single LED.\n+     *\n+     * @param ledId 0..11\n+     * @param state the state to set\n+     * @return the PCK command (without address header) as text\n+     * @throws LcnException if out of range\n+     */\n+    public static String controlLed(int ledId, LcnDefs.LedStatus state) throws LcnException {\n+        if (ledId < 0 || ledId > 11) {\n+            throw new LcnException();\n+        }\n+        return String.format(\"LA%03d%s\", ledId + 1, state == LcnDefs.LedStatus.OFF ? \"A\"\n+                : state == LcnDefs.LedStatus.ON ? \"E\" : state == LcnDefs.LedStatus.BLINK ? \"B\" : \"F\");\n+    }\n+\n+    /**\n+     * Generates a command to send LCN keys.\n+     *\n+     * @param cmds the 4 concrete commands to send for the tables (A-D)\n+     * @param keys the tables' 8 key-states (true means \"send\")\n+     * @return the PCK command (without address header) as text\n+     * @throws IllegalArgumentException if out of range\n+     */\n+    public static String sendKeys(LcnDefs.SendKeyCommand[] cmds, boolean[] keys) throws LcnException {\n+        if (cmds.length != 4 || keys.length != 8) {\n+            throw new LcnException();\n+        }\n+        String ret = \"TS\";\n+        for (int i = 0; i < 4; ++i) {\n+            switch (cmds[i]) {\n+                case HIT:\n+                    ret += \"K\";\n+                    break;\n+                case MAKE:\n+                    ret += \"L\";\n+                    break;\n+                case BREAK:\n+                    ret += \"O\";\n+                    break;\n+                case DONTSEND:\n+                    // By skipping table D (if it is not used), we use the old command\n+                    // for table A-C which is compatible with older LCN modules\n+                    if (i < 3) {\n+                        ret += \"-\";\n+                    }\n+                    break;\n+                default:\n+                    throw new LcnException();\n+            }\n+        }\n+        for (int i = 0; i < 8; ++i) {\n+            ret += keys[i] ? \"1\" : \"0\";\n+        }\n+        return ret;\n+    }\n+\n+    /**\n+     * Generates a command to send LCN keys deferred / delayed.\n+     *\n+     * @param tableId 0(A)..3(D)\n+     * @param time the delay time\n+     * @param timeUnit the time unit\n+     * @param keys the key-states (true means \"send\")\n+     * @return the PCK command (without address header) as text\n+     * @throws LcnException if out of range\n+     */\n+    public static String sendKeysHitDefered(int tableId, int time, LcnDefs.TimeUnit timeUnit, boolean[] keys)\n+            throws LcnException {\n+        if (tableId < 0 || tableId > 3 || keys.length != 8) {\n+            throw new IllegalArgumentException();\n+        }\n+        String ret = \"TV\";\n+        switch (tableId) {\n+            case 0:\n+                ret += \"A\";\n+                break;\n+            case 1:\n+                ret += \"B\";\n+                break;\n+            case 2:\n+                ret += \"C\";\n+                break;\n+            case 3:\n+                ret += \"D\";\n+                break;\n+            default:\n+                throw new LcnException();\n+        }\n+        ret += String.format(\"%03d\", time);\n+        switch (timeUnit) {\n+            case SECONDS:\n+                if (time < 1 || time > 60) {\n+                    throw new LcnException();\n+                }\n+                ret += \"S\";\n+                break;\n+            case MINUTES:\n+                if (time < 1 || time > 90) {\n+                    throw new LcnException();\n+                }\n+                ret += \"M\";\n+                break;\n+            case HOURS:\n+                if (time < 1 || time > 50) {\n+                    throw new LcnException();\n+                }\n+                ret += \"H\";\n+                break;\n+            case DAYS:\n+                if (time < 1 || time > 45) {\n+                    throw new LcnException();\n+                }\n+                ret += \"D\";\n+                break;\n+            default:\n+                throw new LcnException();\n+        }\n+        for (int i = 0; i < 8; ++i) {\n+            ret += keys[i] ? \"1\" : \"0\";\n+        }\n+        return ret;\n+    }\n+\n+    /**\n+     * Generates a request for key-lock states.\n+     * Always requests table A-D. Supported since LCN-PCHK 2.8.\n+     *\n+     * @return the PCK command (without address header) as text\n+     */\n+    public static String requestKeyLocksStatus() {\n+        return \"STX\";\n+    }\n+\n+    /**\n+     * Generates a command to lock keys.\n+     *\n+     * @param tableId 0(A)..3(D)\n+     * @param states the 8 key-lock modifiers\n+     * @return the PCK command (without address header) as text\n+     * @throws LcnException if out of range\n+     */\n+    public static String lockKeys(int tableId, LcnDefs.KeyLockStateModifier[] states) throws LcnException {\n+        if (tableId < 0 || tableId > 3 || states.length != 8) {\n+            throw new LcnException();\n+        }\n+        String ret = String.format(\"TX%s\", tableId == 0 ? \"A\" : tableId == 1 ? \"B\" : tableId == 2 ? \"C\" : \"D\");\n+        for (int i = 0; i < 8; ++i) {\n+            switch (states[i]) {\n+                case ON:\n+                    ret += \"1\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ce02f433e5d4071dbebb9ee68da0e22895887b6b"}, "originalPosition": 633}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjg4ODU5Ng==", "bodyText": "and here", "url": "https://github.com/openhab/openhab-addons/pull/7509#discussion_r436888596", "createdAt": "2020-06-08T17:53:05Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.lcn/src/main/java/org/openhab/binding/lcn/internal/common/PckGenerator.java", "diffHunk": "@@ -0,0 +1,779 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.lcn.internal.common;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.binding.lcn.internal.LcnBindingConstants;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Helpers to generate LCN-PCK commands.\n+ * <p>\n+ * LCN-PCK is the command-syntax used by LCN-PCHK to send and receive LCN commands.\n+ *\n+ * @author Tobias J\u00fcttner - Initial Contribution\n+ * @author Fabian Wolter - Migration to OH2\n+ */\n+@NonNullByDefault\n+public final class PckGenerator {\n+    private static final Logger LOGGER = LoggerFactory.getLogger(PckGenerator.class);\n+    /** Termination character after a PCK message */\n+    public static final String TERMINATION = \"\\n\";\n+\n+    /**\n+     * Generates a keep-alive.\n+     * LCN-PCHK will close the connection if it does not receive any commands from\n+     * an open {@link Connection} for a specific period (10 minutes by default).\n+     *\n+     * @param counter the current ping's id (optional, but \"best practice\"). Should start with 1\n+     * @return the PCK command as text\n+     */\n+    public static String ping(int counter) {\n+        return String.format(\"^ping%d\", counter);\n+    }\n+\n+    /**\n+     * Generates a PCK command that will set the LCN-PCHK connection's operation mode.\n+     * This influences how output-port commands and status are interpreted and must be\n+     * in sync with the LCN bus.\n+     *\n+     * @param dimMode see {@link LcnDefs.OutputPortDimMode}\n+     * @param statusMode see {@link LcnDefs.OutputPortStatusMode}\n+     * @return the PCK command as text\n+     */\n+    public static String setOperationMode(LcnDefs.OutputPortDimMode dimMode, LcnDefs.OutputPortStatusMode statusMode) {\n+        return \"!OM\" + (dimMode == LcnDefs.OutputPortDimMode.NATIVE200 ? \"1\" : \"0\")\n+                + (statusMode == LcnDefs.OutputPortStatusMode.PERCENT ? \"P\" : \"N\");\n+    }\n+\n+    /**\n+     * Generates a PCK address header.\n+     * Used for commands to LCN modules and groups.\n+     *\n+     * @param addr the target's address (module or group)\n+     * @param localSegId the local segment id where the physical bus connection is located\n+     * @param wantsAck true to claim an acknowledge / receipt from the target\n+     * @return the PCK address header as text\n+     */\n+    public static String generateAddressHeader(LcnAddr addr, int localSegId, boolean wantsAck) {\n+        return String.format(\">%s%03d%03d%s\", addr.isGroup() ? \"G\" : \"M\", addr.getPhysicalSegmentId(localSegId),\n+                addr.getId(), wantsAck ? \"!\" : \".\");\n+    }\n+\n+    /**\n+     * Generates a scan-command for LCN segment-couplers.\n+     * Used to detect the local segment (where the physical bus connection is located).\n+     *\n+     * @return the PCK command (without address header) as text\n+     */\n+    public static String segmentCouplerScan() {\n+        return \"SK\";\n+    }\n+\n+    /**\n+     * Generates a firmware/serial-number request.\n+     *\n+     * @return the PCK command (without address header) as text\n+     */\n+    public static String requestSn() {\n+        return \"SN\";\n+    }\n+\n+    /**\n+     * Generates a command to request a part of a name of a module.\n+     *\n+     * @param partNumber 0..1\n+     * @return the PCK command (without address header) as text\n+     */\n+    public static String requestModuleName(int partNumber) {\n+        return \"NMN\" + (partNumber + 1);\n+    }\n+\n+    /**\n+     * Generates an output-port status request.\n+     *\n+     * @param outputId 0..3\n+     * @return the PCK command (without address header) as text\n+     * @throws LcnException if out of range\n+     */\n+    public static String requestOutputStatus(int outputId) throws LcnException {\n+        if (outputId < 0 || outputId > 3) {\n+            throw new LcnException();\n+        }\n+        return String.format(\"SMA%d\", outputId + 1);\n+    }\n+\n+    /**\n+     * Generates a dim command for a single output-port.\n+     *\n+     * @param outputId 0..3\n+     * @param percent 0..100\n+     * @param rampMs ramp in milliseconds\n+     * @return the PCK command (without address header) as text\n+     * @throws LcnException if out of range\n+     */\n+    public static String dimOutput(int outputId, double percent, int rampMs) throws LcnException {\n+        if (outputId < 0 || outputId > 3) {\n+            throw new LcnException();\n+        }\n+        int rampNative = PckGenerator.timeToRampValue(rampMs);\n+        int n = (int) Math.round(percent * 2);\n+        if ((n % 2) == 0) { // Use the percent command (supported by all LCN-PCHK versions)\n+            return String.format(\"A%dDI%03d%03d\", outputId + 1, n / 2, rampNative);\n+        } else { // We have a \".5\" value. Use the native command (supported since LCN-PCHK 2.3)\n+            return String.format(\"O%dDI%03d%03d\", outputId + 1, n, rampNative);\n+        }\n+    }\n+\n+    /**\n+     * Generates a dim command for all output-ports.\n+     *\n+     * Attention: This command is supported since module firmware version 180501 AND LCN-PCHK 2.61\n+     *\n+     * @param firstPercent dimmer value of the first output 0..100\n+     * @param secondPercent dimmer value of the first output 0..100\n+     * @param thirdPercent dimmer value of the first output 0..100\n+     * @param fourthPercent dimmer value of the first output 0..100\n+     * @param rampMs ramp in milliseconds\n+     * @return the PCK command (without address header) as text\n+     */\n+    public static String dimAllOutputs(double firstPercent, double secondPercent, double thirdPercent,\n+            double fourthPercent, int rampMs) {\n+        long n1 = Math.round(firstPercent * 2);\n+        long n2 = Math.round(secondPercent * 2);\n+        long n3 = Math.round(thirdPercent * 2);\n+        long n4 = Math.round(fourthPercent * 2);\n+\n+        return String.format(\"OY%03d%03d%03d%03d%03d\", n1, n2, n3, n4, timeToRampValue(rampMs));\n+    }\n+\n+    /**\n+     * Generates a control command for switching all outputs ON or OFF with a fixed ramp of 0.5s.\n+     *\n+     * @param percent 0..100\n+     * @returnthe PCK command (without address header) as text\n+     */\n+    public static String controlAllOutputs(double percent) {\n+        return String.format(\"AH%03d\", Math.round(percent));\n+    }\n+\n+    /**\n+     * Generates a control command for switching dimmer output 1 and 2 both ON or OFF with a fixed ramp of 0.5s or\n+     * without ramp.\n+     *\n+     * @param on true, if outputs shall be switched on\n+     * @param ramp true, if the ramp shall be 0.5s, else 0s\n+     * @return the PCK command (without address header) as text\n+     */\n+    public static String controlOutputs12(boolean on, boolean ramp) {\n+        int commandByte;\n+        if (on) {\n+            commandByte = ramp ? 0xC8 : 0xFD;\n+        } else {\n+            commandByte = ramp ? 0x00 : 0xFC;\n+        }\n+        return String.format(\"X2%03d%03d%03d\", 1, commandByte, commandByte);\n+    }\n+\n+    /**\n+     * Generates a dim command for setting the brightness of dimmer output 1 and 2 with a fixed ramp of 0.5s.\n+     *\n+     * @param percent brightness of both outputs 0..100\n+     * @return the PCK command (without address header) as text\n+     */\n+    public static String dimOutputs12(double percent) {\n+        long localPercent = Math.round(percent);\n+        return String.format(\"AY%03d%03d\", localPercent, localPercent);\n+    }\n+\n+    /**\n+     * Let an output flicker.\n+     *\n+     * @param outputId output id 0..3\n+     * @param depth flicker depth, the higher the deeper 0..2\n+     * @param ramp the flicker speed 0..2\n+     * @param count number of flashes 1..15\n+     * @return the PCK command (without address header) as text\n+     * @throws LcnException when the input values are out of range\n+     */\n+    public static String flickerOutput(int outputId, int depth, int ramp, int count) throws LcnException {\n+        if (outputId < 0 || outputId > 3) {\n+            throw new LcnException(\"Output number out of range\");\n+        }\n+        if (count < 1 || count > 15) {\n+            throw new LcnException(\"Number of flashes out of range\");\n+        }\n+        String depthString;\n+        switch (depth) {\n+            case 0:\n+                depthString = \"G\";\n+                break;\n+            case 1:\n+                depthString = \"M\";\n+                break;\n+            case 2:\n+                depthString = \"S\";\n+                break;\n+            default:\n+                throw new LcnException(\"Depth out of range\");\n+        }\n+        String rampString;\n+        switch (ramp) {\n+            case 0:\n+                rampString = \"L\";\n+                break;\n+            case 1:\n+                rampString = \"M\";\n+                break;\n+            case 2:\n+                rampString = \"S\";\n+                break;\n+            default:\n+                throw new LcnException(\"Ramp out of range\");\n+        }\n+        return String.format(\"A%dFL%s%s%02d\", outputId + 1, depthString, rampString, count);\n+    }\n+\n+    /**\n+     * Generates a command to change the value of an output-port.\n+     *\n+     * @param outputId 0..3\n+     * @param percent -100..100\n+     * @return the PCK command (without address header) as text\n+     * @throws LcnException if out of range\n+     */\n+    public static String relOutput(int outputId, double percent) throws LcnException {\n+        if (outputId < 0 || outputId > 3) {\n+            throw new LcnException();\n+        }\n+        int n = (int) Math.round(percent * 2);\n+        if ((n % 2) == 0) { // Use the percent command (supported by all LCN-PCHK versions)\n+            return String.format(\"A%d%s%03d\", outputId + 1, percent >= 0 ? \"AD\" : \"SB\", Math.abs(n / 2));\n+        } else { // We have a \".5\" value. Use the native command (supported since LCN-PCHK 2.3)\n+            return String.format(\"O%d%s%03d\", outputId + 1, percent >= 0 ? \"AD\" : \"SB\", Math.abs(n));\n+        }\n+    }\n+\n+    /**\n+     * Generates a command that toggles a single output-port (on->off, off->on).\n+     *\n+     * @param outputId 0..3\n+     * @param ramp see {@link PckGenerator#timeToRampValue(int)}\n+     * @return the PCK command (without address header) as text\n+     * @throws LcnException if out of range\n+     */\n+    public static String toggleOutput(int outputId, int ramp) throws LcnException {\n+        if (outputId < 0 || outputId > 3) {\n+            throw new LcnException();\n+        }\n+        return String.format(\"A%dTA%03d\", outputId + 1, ramp);\n+    }\n+\n+    /**\n+     * Generates a command that toggles all output-ports (on->off, off->on).\n+     *\n+     * @param ramp see {@link PckGenerator#timeToRampValue(int)}\n+     * @return the PCK command (without address header) as text\n+     */\n+    public static String toggleAllOutputs(int ramp) {\n+        return String.format(\"AU%03d\", ramp);\n+    }\n+\n+    /**\n+     * Generates a relays-status request.\n+     *\n+     * @return the PCK command (without address header) as text\n+     */\n+    public static String requestRelaysStatus() {\n+        return \"SMR\";\n+    }\n+\n+    /**\n+     * Generates a command to control relays.\n+     *\n+     * @param states the 8 modifiers for the relay states\n+     * @return the PCK command (without address header) as text\n+     * @throws LcnException if out of range\n+     */\n+    public static String controlRelays(LcnDefs.RelayStateModifier[] states) throws LcnException {\n+        if (states.length != 8) {\n+            throw new LcnException();\n+        }\n+        String ret = \"R8\";\n+        for (int i = 0; i < 8; ++i) {\n+            switch (states[i]) {\n+                case ON:\n+                    ret += \"1\";\n+                    break;\n+                case OFF:\n+                    ret += \"0\";\n+                    break;\n+                case TOGGLE:\n+                    ret += \"U\";\n+                    break;\n+                case NOCHANGE:\n+                    ret += \"-\";\n+                    break;\n+                default:\n+                    throw new LcnException();\n+            }\n+        }\n+        return ret;\n+    }\n+\n+    /**\n+     * Generates a binary-sensors status request.\n+     *\n+     * @return the PCK command (without address header) as text\n+     */\n+    public static String requestBinSensorsStatus() {\n+        return \"SMB\";\n+    }\n+\n+    /**\n+     * Generates a command that sets a variable absolute.\n+     *\n+     * @param number regulator number 0..1\n+     * @param value the absolute value to set\n+     * @return the PCK command (without address header) as text\n+     * @throws LcnException\n+     */\n+    public static String setSetpointAbsolute(int number, int value) {\n+        int internalValue = value;\n+        // Set absolute (not in PCK yet)\n+        int b1 = number << 6; // 01000000\n+        b1 |= 0x20; // xx10xxxx (set absolute)\n+        if (value < 1000) {\n+            internalValue = 1000 - internalValue;\n+            b1 |= 8;\n+        } else {\n+            internalValue -= 1000;\n+        }\n+        b1 |= (internalValue >> 8) & 0x0f; // xxxx1111\n+        int b2 = internalValue & 0xff;\n+        return String.format(\"X2%03d%03d%03d\", 30, b1, b2);\n+    }\n+\n+    /**\n+     * Generates a command to change the value of a variable.\n+     *\n+     * @param variable the target variable to change\n+     * @param type the reference-point\n+     * @param value the native LCN value to add/subtract (can be negative)\n+     * @return the PCK command (without address header) as text\n+     * @throws LcnException if command is not supported\n+     */\n+    public static String setVariableRelative(Variable variable, LcnDefs.RelVarRef type, int value) {\n+        if (variable.getNumber() == 0) {\n+            // Old command for variable 1 / T-var (compatible with all modules)\n+            return String.format(\"Z%s%d\", value >= 0 ? \"A\" : \"S\", Math.abs(value));\n+        } else { // New command for variable 1-12 (compatible with all modules, since LCN-PCHK 2.8)\n+            return String.format(\"Z%s%03d%d\", value >= 0 ? \"+\" : \"-\", variable.getNumber() + 1, Math.abs(value));\n+        }\n+    }\n+\n+    /**\n+     * Generates a command the change the value of a regulator setpoint relative.\n+     *\n+     * @param number 0..1\n+     * @param type relative to the current or to the programmed value\n+     * @param value the relative value -4000..+4000\n+     * @return the PCK command (without address header) as text\n+     */\n+    public static String setSetpointRelative(int number, LcnDefs.RelVarRef type, int value) {\n+        return String.format(\"RE%sS%s%s%d\", number == 0 ? \"A\" : \"B\", type == LcnDefs.RelVarRef.CURRENT ? \"A\" : \"P\",\n+                value >= 0 ? \"+\" : \"-\", Math.abs(value));\n+    }\n+\n+    /**\n+     * Generates a command the change the value of a threshold relative.\n+     *\n+     * @param variable the threshold to change\n+     * @param type relative to the current or to the programmed value\n+     * @param value the relative value -4000..+4000\n+     * @param is2013 true, if the LCN module's firmware is equal to or newer than 2013\n+     * @return the PCK command (without address header) as text\n+     */\n+    public static String setThresholdRelative(Variable variable, LcnDefs.RelVarRef type, int value, boolean is2013)\n+            throws LcnException {\n+        if (is2013) { // New command for registers 1-4 (since 170206, LCN-PCHK 2.8)\n+            return String.format(\"SS%s%04d%sR%d%d\", type == LcnDefs.RelVarRef.CURRENT ? \"R\" : \"E\", Math.abs(value),\n+                    value >= 0 ? \"A\" : \"S\", variable.getNumber() + 1, variable.getThresholdNumber().get() + 1);\n+        } else if (variable.getNumber() == 0) { // Old command for register 1 (before 170206)\n+            return String.format(\"SS%s%04d%s%s%s%s%s%s\", type == LcnDefs.RelVarRef.CURRENT ? \"R\" : \"E\", Math.abs(value),\n+                    value >= 0 ? \"A\" : \"S\", variable.getThresholdNumber().get() == 0 ? \"1\" : \"0\",\n+                    variable.getThresholdNumber().get() == 1 ? \"1\" : \"0\",\n+                    variable.getThresholdNumber().get() == 2 ? \"1\" : \"0\",\n+                    variable.getThresholdNumber().get() == 3 ? \"1\" : \"0\",\n+                    variable.getThresholdNumber().get() == 4 ? \"1\" : \"0\");\n+        } else {\n+            throw new LcnException(\n+                    \"Module does not have threshold register \" + (variable.getThresholdNumber().get() + 1));\n+        }\n+    }\n+\n+    /**\n+     * Generates a variable value request.\n+     *\n+     * @param variable the variable to request\n+     * @param firmwareVersion the target module's firmware version\n+     * @return the PCK command (without address header) as text\n+     * @throws LcnException if command is not supported\n+     */\n+    public static String requestVarStatus(Variable variable, int firmwareVersion) throws LcnException {\n+        if (firmwareVersion >= LcnBindingConstants.FIRMWARE_2013) {\n+            int id = variable.getNumber();\n+            switch (variable.getType()) {\n+                case UNKNOWN:\n+                    throw new LcnException(\"Variable unknown\");\n+                case VARIABLE:\n+                    return String.format(\"MWT%03d\", id + 1);\n+                case REGULATOR:\n+                    return String.format(\"MWS%03d\", id + 1);\n+                case THRESHOLD:\n+                    return String.format(\"SE%03d\", id + 1); // Whole register\n+                case S0INPUT:\n+                    return String.format(\"MWC%03d\", id + 1);\n+            }\n+            throw new LcnException(\"Unsupported variable type: \" + variable);\n+        } else {\n+            switch (variable) {\n+                case VARIABLE1:\n+                    return \"MWV\";\n+                case VARIABLE2:\n+                    return \"MWTA\";\n+                case VARIABLE3:\n+                    return \"MWTB\";\n+                case RVARSETPOINT1:\n+                    return \"MWSA\";\n+                case RVARSETPOINT2:\n+                    return \"MWSB\";\n+                case THRESHOLDREGISTER11:\n+                case THRESHOLDREGISTER12:\n+                case THRESHOLDREGISTER13:\n+                case THRESHOLDREGISTER14:\n+                case THRESHOLDREGISTER15:\n+                    return \"SL1\"; // Whole register\n+                default:\n+                    throw new LcnException(\"Unsupported variable type: \" + variable);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Generates a request for LED and logic-operations states.\n+     *\n+     * @return the PCK command (without address header) as text\n+     */\n+    public static String requestLedsAndLogicOpsStatus() {\n+        return \"SMT\";\n+    }\n+\n+    /**\n+     * Generates a command to the set the state of a single LED.\n+     *\n+     * @param ledId 0..11\n+     * @param state the state to set\n+     * @return the PCK command (without address header) as text\n+     * @throws LcnException if out of range\n+     */\n+    public static String controlLed(int ledId, LcnDefs.LedStatus state) throws LcnException {\n+        if (ledId < 0 || ledId > 11) {\n+            throw new LcnException();\n+        }\n+        return String.format(\"LA%03d%s\", ledId + 1, state == LcnDefs.LedStatus.OFF ? \"A\"\n+                : state == LcnDefs.LedStatus.ON ? \"E\" : state == LcnDefs.LedStatus.BLINK ? \"B\" : \"F\");\n+    }\n+\n+    /**\n+     * Generates a command to send LCN keys.\n+     *\n+     * @param cmds the 4 concrete commands to send for the tables (A-D)\n+     * @param keys the tables' 8 key-states (true means \"send\")\n+     * @return the PCK command (without address header) as text\n+     * @throws IllegalArgumentException if out of range\n+     */\n+    public static String sendKeys(LcnDefs.SendKeyCommand[] cmds, boolean[] keys) throws LcnException {\n+        if (cmds.length != 4 || keys.length != 8) {\n+            throw new LcnException();\n+        }\n+        String ret = \"TS\";\n+        for (int i = 0; i < 4; ++i) {\n+            switch (cmds[i]) {\n+                case HIT:\n+                    ret += \"K\";\n+                    break;\n+                case MAKE:\n+                    ret += \"L\";\n+                    break;\n+                case BREAK:\n+                    ret += \"O\";\n+                    break;\n+                case DONTSEND:\n+                    // By skipping table D (if it is not used), we use the old command\n+                    // for table A-C which is compatible with older LCN modules\n+                    if (i < 3) {\n+                        ret += \"-\";\n+                    }\n+                    break;\n+                default:\n+                    throw new LcnException();\n+            }\n+        }\n+        for (int i = 0; i < 8; ++i) {\n+            ret += keys[i] ? \"1\" : \"0\";\n+        }\n+        return ret;\n+    }\n+\n+    /**\n+     * Generates a command to send LCN keys deferred / delayed.\n+     *\n+     * @param tableId 0(A)..3(D)\n+     * @param time the delay time\n+     * @param timeUnit the time unit\n+     * @param keys the key-states (true means \"send\")\n+     * @return the PCK command (without address header) as text\n+     * @throws LcnException if out of range\n+     */\n+    public static String sendKeysHitDefered(int tableId, int time, LcnDefs.TimeUnit timeUnit, boolean[] keys)\n+            throws LcnException {\n+        if (tableId < 0 || tableId > 3 || keys.length != 8) {\n+            throw new IllegalArgumentException();\n+        }\n+        String ret = \"TV\";\n+        switch (tableId) {\n+            case 0:\n+                ret += \"A\";\n+                break;\n+            case 1:\n+                ret += \"B\";\n+                break;\n+            case 2:\n+                ret += \"C\";\n+                break;\n+            case 3:\n+                ret += \"D\";\n+                break;\n+            default:\n+                throw new LcnException();\n+        }\n+        ret += String.format(\"%03d\", time);\n+        switch (timeUnit) {\n+            case SECONDS:\n+                if (time < 1 || time > 60) {\n+                    throw new LcnException();\n+                }\n+                ret += \"S\";\n+                break;\n+            case MINUTES:\n+                if (time < 1 || time > 90) {\n+                    throw new LcnException();\n+                }\n+                ret += \"M\";\n+                break;\n+            case HOURS:\n+                if (time < 1 || time > 50) {\n+                    throw new LcnException();\n+                }\n+                ret += \"H\";\n+                break;\n+            case DAYS:\n+                if (time < 1 || time > 45) {\n+                    throw new LcnException();\n+                }\n+                ret += \"D\";\n+                break;\n+            default:\n+                throw new LcnException();\n+        }\n+        for (int i = 0; i < 8; ++i) {\n+            ret += keys[i] ? \"1\" : \"0\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ce02f433e5d4071dbebb9ee68da0e22895887b6b"}, "originalPosition": 602}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjg4OTI4NA==", "bodyText": "how come you include an invalid argument message for some of these LcnExceptions but not all?", "url": "https://github.com/openhab/openhab-addons/pull/7509#discussion_r436889284", "createdAt": "2020-06-08T17:54:14Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.lcn/src/main/java/org/openhab/binding/lcn/internal/common/PckGenerator.java", "diffHunk": "@@ -0,0 +1,779 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.lcn.internal.common;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.binding.lcn.internal.LcnBindingConstants;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Helpers to generate LCN-PCK commands.\n+ * <p>\n+ * LCN-PCK is the command-syntax used by LCN-PCHK to send and receive LCN commands.\n+ *\n+ * @author Tobias J\u00fcttner - Initial Contribution\n+ * @author Fabian Wolter - Migration to OH2\n+ */\n+@NonNullByDefault\n+public final class PckGenerator {\n+    private static final Logger LOGGER = LoggerFactory.getLogger(PckGenerator.class);\n+    /** Termination character after a PCK message */\n+    public static final String TERMINATION = \"\\n\";\n+\n+    /**\n+     * Generates a keep-alive.\n+     * LCN-PCHK will close the connection if it does not receive any commands from\n+     * an open {@link Connection} for a specific period (10 minutes by default).\n+     *\n+     * @param counter the current ping's id (optional, but \"best practice\"). Should start with 1\n+     * @return the PCK command as text\n+     */\n+    public static String ping(int counter) {\n+        return String.format(\"^ping%d\", counter);\n+    }\n+\n+    /**\n+     * Generates a PCK command that will set the LCN-PCHK connection's operation mode.\n+     * This influences how output-port commands and status are interpreted and must be\n+     * in sync with the LCN bus.\n+     *\n+     * @param dimMode see {@link LcnDefs.OutputPortDimMode}\n+     * @param statusMode see {@link LcnDefs.OutputPortStatusMode}\n+     * @return the PCK command as text\n+     */\n+    public static String setOperationMode(LcnDefs.OutputPortDimMode dimMode, LcnDefs.OutputPortStatusMode statusMode) {\n+        return \"!OM\" + (dimMode == LcnDefs.OutputPortDimMode.NATIVE200 ? \"1\" : \"0\")\n+                + (statusMode == LcnDefs.OutputPortStatusMode.PERCENT ? \"P\" : \"N\");\n+    }\n+\n+    /**\n+     * Generates a PCK address header.\n+     * Used for commands to LCN modules and groups.\n+     *\n+     * @param addr the target's address (module or group)\n+     * @param localSegId the local segment id where the physical bus connection is located\n+     * @param wantsAck true to claim an acknowledge / receipt from the target\n+     * @return the PCK address header as text\n+     */\n+    public static String generateAddressHeader(LcnAddr addr, int localSegId, boolean wantsAck) {\n+        return String.format(\">%s%03d%03d%s\", addr.isGroup() ? \"G\" : \"M\", addr.getPhysicalSegmentId(localSegId),\n+                addr.getId(), wantsAck ? \"!\" : \".\");\n+    }\n+\n+    /**\n+     * Generates a scan-command for LCN segment-couplers.\n+     * Used to detect the local segment (where the physical bus connection is located).\n+     *\n+     * @return the PCK command (without address header) as text\n+     */\n+    public static String segmentCouplerScan() {\n+        return \"SK\";\n+    }\n+\n+    /**\n+     * Generates a firmware/serial-number request.\n+     *\n+     * @return the PCK command (without address header) as text\n+     */\n+    public static String requestSn() {\n+        return \"SN\";\n+    }\n+\n+    /**\n+     * Generates a command to request a part of a name of a module.\n+     *\n+     * @param partNumber 0..1\n+     * @return the PCK command (without address header) as text\n+     */\n+    public static String requestModuleName(int partNumber) {\n+        return \"NMN\" + (partNumber + 1);\n+    }\n+\n+    /**\n+     * Generates an output-port status request.\n+     *\n+     * @param outputId 0..3\n+     * @return the PCK command (without address header) as text\n+     * @throws LcnException if out of range\n+     */\n+    public static String requestOutputStatus(int outputId) throws LcnException {\n+        if (outputId < 0 || outputId > 3) {\n+            throw new LcnException();\n+        }\n+        return String.format(\"SMA%d\", outputId + 1);\n+    }\n+\n+    /**\n+     * Generates a dim command for a single output-port.\n+     *\n+     * @param outputId 0..3\n+     * @param percent 0..100\n+     * @param rampMs ramp in milliseconds\n+     * @return the PCK command (without address header) as text\n+     * @throws LcnException if out of range\n+     */\n+    public static String dimOutput(int outputId, double percent, int rampMs) throws LcnException {\n+        if (outputId < 0 || outputId > 3) {\n+            throw new LcnException();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ce02f433e5d4071dbebb9ee68da0e22895887b6b"}, "originalPosition": 128}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjg5MTAwOA==", "bodyText": "make these final", "url": "https://github.com/openhab/openhab-addons/pull/7509#discussion_r436891008", "createdAt": "2020-06-08T17:56:59Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.lcn/src/main/java/org/openhab/binding/lcn/internal/common/Variable.java", "diffHunk": "@@ -0,0 +1,274 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.lcn.internal.common;\n+\n+import java.util.Optional;\n+import java.util.function.Predicate;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.binding.lcn.internal.LcnBindingConstants;\n+\n+/**\n+ * LCN variable types.\n+ *\n+ * @author Tobias J\u00fcttner - Initial Contribution\n+ * @author Fabian Wolter - Migration to OH2\n+ */\n+@NonNullByDefault\n+public enum Variable {\n+    UNKNOWN(0, Type.UNKNOWN, LcnChannelGroup.VARIABLE), // Used if the real type is not known (yet)\n+    VARIABLE1(0, Type.VARIABLE, LcnChannelGroup.VARIABLE), // or TVar\n+    VARIABLE2(1, Type.VARIABLE, LcnChannelGroup.VARIABLE),\n+    VARIABLE3(2, Type.VARIABLE, LcnChannelGroup.VARIABLE),\n+    VARIABLE4(3, Type.VARIABLE, LcnChannelGroup.VARIABLE),\n+    VARIABLE5(4, Type.VARIABLE, LcnChannelGroup.VARIABLE),\n+    VARIABLE6(5, Type.VARIABLE, LcnChannelGroup.VARIABLE),\n+    VARIABLE7(6, Type.VARIABLE, LcnChannelGroup.VARIABLE),\n+    VARIABLE8(7, Type.VARIABLE, LcnChannelGroup.VARIABLE),\n+    VARIABLE9(8, Type.VARIABLE, LcnChannelGroup.VARIABLE),\n+    VARIABLE10(9, Type.VARIABLE, LcnChannelGroup.VARIABLE),\n+    VARIABLE11(10, Type.VARIABLE, LcnChannelGroup.VARIABLE),\n+    VARIABLE12(11, Type.VARIABLE, LcnChannelGroup.VARIABLE), // Since 170206\n+    RVARSETPOINT1(0, Type.REGULATOR, LcnChannelGroup.RVARSETPOINT),\n+    RVARSETPOINT2(1, Type.REGULATOR, LcnChannelGroup.RVARSETPOINT), // Set-points for regulators\n+    THRESHOLDREGISTER11(0, 0, Type.THRESHOLD, LcnChannelGroup.THRESHOLDREGISTER1),\n+    THRESHOLDREGISTER12(0, 1, Type.THRESHOLD, LcnChannelGroup.THRESHOLDREGISTER1),\n+    THRESHOLDREGISTER13(0, 2, Type.THRESHOLD, LcnChannelGroup.THRESHOLDREGISTER1),\n+    THRESHOLDREGISTER14(0, 3, Type.THRESHOLD, LcnChannelGroup.THRESHOLDREGISTER1),\n+    // Register 1 (THRESHOLDREGISTER15 only before 170206)\n+    THRESHOLDREGISTER15(0, 4, Type.THRESHOLD, LcnChannelGroup.THRESHOLDREGISTER1),\n+    THRESHOLDREGISTER21(1, 0, Type.THRESHOLD, LcnChannelGroup.THRESHOLDREGISTER2),\n+    THRESHOLDREGISTER22(1, 1, Type.THRESHOLD, LcnChannelGroup.THRESHOLDREGISTER2),\n+    THRESHOLDREGISTER23(1, 2, Type.THRESHOLD, LcnChannelGroup.THRESHOLDREGISTER2),\n+    THRESHOLDREGISTER24(1, 3, Type.THRESHOLD, LcnChannelGroup.THRESHOLDREGISTER2), // Register 2 (since 2012)\n+    THRESHOLDREGISTER31(2, 0, Type.THRESHOLD, LcnChannelGroup.THRESHOLDREGISTER3),\n+    THRESHOLDREGISTER32(2, 1, Type.THRESHOLD, LcnChannelGroup.THRESHOLDREGISTER3),\n+    THRESHOLDREGISTER33(2, 2, Type.THRESHOLD, LcnChannelGroup.THRESHOLDREGISTER3),\n+    THRESHOLDREGISTER34(2, 3, Type.THRESHOLD, LcnChannelGroup.THRESHOLDREGISTER3), // Register 3 (since 2012)\n+    THRESHOLDREGISTER41(3, 0, Type.THRESHOLD, LcnChannelGroup.THRESHOLDREGISTER4),\n+    THRESHOLDREGISTER42(3, 1, Type.THRESHOLD, LcnChannelGroup.THRESHOLDREGISTER4),\n+    THRESHOLDREGISTER43(3, 2, Type.THRESHOLD, LcnChannelGroup.THRESHOLDREGISTER4),\n+    THRESHOLDREGISTER44(3, 3, Type.THRESHOLD, LcnChannelGroup.THRESHOLDREGISTER4), // Register 4 (since 2012)\n+    S0INPUT1(0, Type.S0INPUT, LcnChannelGroup.S0INPUT),\n+    S0INPUT2(1, Type.S0INPUT, LcnChannelGroup.S0INPUT),\n+    S0INPUT3(2, Type.S0INPUT, LcnChannelGroup.S0INPUT),\n+    S0INPUT4(3, Type.S0INPUT, LcnChannelGroup.S0INPUT); // LCN-BU4L\n+\n+    private int number;\n+    private Optional<Integer> thresholdNumber = Optional.empty();\n+    private Type type;\n+    private LcnChannelGroup channelGroup;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ce02f433e5d4071dbebb9ee68da0e22895887b6b"}, "originalPosition": 71}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjg5MTgzOQ==", "bodyText": "Can you make these final?", "url": "https://github.com/openhab/openhab-addons/pull/7509#discussion_r436891839", "createdAt": "2020-06-08T17:58:25Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.lcn/src/main/java/org/openhab/binding/lcn/internal/connection/AbstractConnectionState.java", "diffHunk": "@@ -0,0 +1,93 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.lcn.internal.connection;\n+\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.Channel;\n+import java.util.concurrent.ScheduledExecutorService;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.binding.lcn.internal.common.LcnAddr;\n+import org.openhab.binding.lcn.internal.common.LcnDefs;\n+\n+/**\n+ * Base class for representing LCN-PCK gateway connection states\n+ *\n+ * @author Fabian Wolter - Initial Contribution\n+ */\n+@NonNullByDefault\n+public abstract class AbstractConnectionState extends AbstractState {\n+    /** The PCK gateway's Connection */\n+    protected Connection connection;\n+    /** An openHAB scheduler */\n+    protected ScheduledExecutorService scheduler;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ce02f433e5d4071dbebb9ee68da0e22895887b6b"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjg5Mjg4OA==", "bodyText": "make these final", "url": "https://github.com/openhab/openhab-addons/pull/7509#discussion_r436892888", "createdAt": "2020-06-08T18:00:06Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.lcn/src/main/java/org/openhab/binding/lcn/internal/connection/AbstractState.java", "diffHunk": "@@ -0,0 +1,70 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.lcn.internal.connection;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.ScheduledFuture;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+\n+/**\n+ * Base class for usage for states with {@link StateMachine}.\n+ *\n+ * @author Fabian Wolter - Initial Contribution\n+ */\n+@NonNullByDefault\n+public abstract class AbstractState {\n+    private List<ScheduledFuture<?>> usedTimers = Collections.synchronizedList(new ArrayList<>());\n+    protected StateContext context;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ce02f433e5d4071dbebb9ee68da0e22895887b6b"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjg5NDU4NA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        ModInfo data = this.modData.get(addr);\n          \n          \n            \n                        if (data == null) {\n          \n          \n            \n                            data = new ModInfo(addr);\n          \n          \n            \n                            this.modData.put(addr, data);\n          \n          \n            \n                        }\n          \n          \n            \n                        return data;\n          \n          \n            \n                        return this.modData.computeIfAbsent(ModInfo::new);", "url": "https://github.com/openhab/openhab-addons/pull/7509#discussion_r436894584", "createdAt": "2020-06-08T18:03:06Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.lcn/src/main/java/org/openhab/binding/lcn/internal/connection/Connection.java", "diffHunk": "@@ -0,0 +1,505 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.lcn.internal.connection;\n+\n+import java.io.IOException;\n+import java.io.UnsupportedEncodingException;\n+import java.nio.BufferOverflowException;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.AsynchronousSocketChannel;\n+import java.nio.channels.Channel;\n+import java.nio.channels.CompletionHandler;\n+import java.time.Instant;\n+import java.time.temporal.ChronoUnit;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Queue;\n+import java.util.concurrent.LinkedBlockingQueue;\n+import java.util.concurrent.ScheduledExecutorService;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.lcn.internal.common.LcnAddr;\n+import org.openhab.binding.lcn.internal.common.LcnAddrGrp;\n+import org.openhab.binding.lcn.internal.common.LcnAddrMod;\n+import org.openhab.binding.lcn.internal.common.LcnDefs;\n+import org.openhab.binding.lcn.internal.common.LcnException;\n+import org.openhab.binding.lcn.internal.common.PckGenerator;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * This class represents a configured connection to one LCN-PCHK.\n+ * It uses a {@link AsynchronousSocketChannel} to connect to LCN-PCHK.\n+ * Included logic:\n+ * <ul>\n+ * <li>Reconnection on connection loss\n+ * <li>Segment scan (to detect the local segment ID)\n+ * <li>Acknowledge handling\n+ * <li>Periodic value requests\n+ * <li>Caching of runtime data about the underlying LCN bus\n+ * </ul>\n+ *\n+ * @author Fabian Wolter - Initial Contribution\n+ */\n+@NonNullByDefault\n+public class Connection {\n+    private final Logger logger = LoggerFactory.getLogger(Connection.class);\n+    /** Max. lengths of a PCK string including address and line feed. Currently dynamic text (GTDT) */\n+    private static final int MAX_PCK_STRING_LENGTH = 34;\n+    private static final int BROADCAST_MODULE_ID = 3;\n+    private static final int BROADCAST_SEGMENT_ID = 3;\n+    private final ConnectionSettings settings;\n+    private final ConnectionCallback callback;\n+    @Nullable\n+    private AsynchronousSocketChannel channel;\n+    /** The local segment id. -1 means \"unknown\". */\n+    private int localSegId;\n+    private final ByteBuffer readBuffer = ByteBuffer.allocate(1024);\n+    private final ByteBuffer sendBuffer = ByteBuffer.allocate(MAX_PCK_STRING_LENGTH);\n+    private final Queue<@Nullable SendData> sendQueue = new LinkedBlockingQueue<>();\n+    private final Queue<@Nullable PckQueueItem> offlineSendQueue = new LinkedBlockingQueue<>();\n+    private final Map<LcnAddr, @Nullable ModInfo> modData = Collections.synchronizedMap(new HashMap<>());\n+    private volatile boolean writeInProgress;\n+    private ScheduledExecutorService scheduler;\n+    private StateMachine stateMachine;\n+\n+    /**\n+     * Constructs a clean (disconnected) connection with the given settings.\n+     * This does not start the actual connection process.\n+     *\n+     * @param sets the settings to use for the new connection\n+     * @param callback the callback to the owner\n+     * @throws IOException\n+     */\n+    public Connection(ConnectionSettings sets, ScheduledExecutorService scheduler, ConnectionCallback callback) {\n+        this.settings = sets;\n+        this.callback = callback;\n+        this.scheduler = scheduler;\n+        this.clearRuntimeData();\n+\n+        stateMachine = new StateMachine(this, scheduler);\n+        stateMachine.startWorking();\n+    }\n+\n+    /** Clears all runtime data. */\n+    void clearRuntimeData() {\n+        this.channel = null;\n+        this.localSegId = -1;\n+        this.readBuffer.clear();\n+        this.sendQueue.clear();\n+        this.sendBuffer.clear();\n+    }\n+\n+    /**\n+     * Retrieves the settings for this connection (never changed).\n+     *\n+     * @return the settings\n+     */\n+    public ConnectionSettings getSettings() {\n+        return this.settings;\n+    }\n+\n+    private boolean isSocketConnected() {\n+        try {\n+            AsynchronousSocketChannel localChannel = channel;\n+            return localChannel != null && localChannel.getRemoteAddress() != null;\n+        } catch (IOException e) {\n+            return false;\n+        }\n+    }\n+\n+    /**\n+     * Sets the local segment id.\n+     *\n+     * @param localSegId the new local segment id\n+     */\n+    public void setLocalSegId(int localSegId) {\n+        this.localSegId = localSegId;\n+    }\n+\n+    /**\n+     * Called whenever an acknowledge is received.\n+     *\n+     * @param addr the source LCN module\n+     * @param code the LCN internal code (-1 = \"positive\")\n+     */\n+    public void onAck(LcnAddrMod addr, int code) {\n+        ModInfo info = this.modData.get(addr);\n+        if (info != null) {\n+            info.onAck(code, this, this.settings.getTimeout(), System.nanoTime());\n+        }\n+    }\n+\n+    /**\n+     * Creates and/or returns cached data for the given LCN module.\n+     *\n+     * @param addr the module's address\n+     * @return the data (never null)\n+     */\n+    public ModInfo updateModuleData(LcnAddrMod addr) {\n+        synchronized (modData) {\n+            ModInfo data = this.modData.get(addr);\n+            if (data == null) {\n+                data = new ModInfo(addr);\n+                this.modData.put(addr, data);\n+            }\n+            return data;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ce02f433e5d4071dbebb9ee68da0e22895887b6b"}, "originalPosition": 158}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjg5NTYxMA==", "bodyText": "Every single info will be update with a different System.nanoTime() result. Is that what you want? Or should they all be the same?", "url": "https://github.com/openhab/openhab-addons/pull/7509#discussion_r436895610", "createdAt": "2020-06-08T18:04:53Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.lcn/src/main/java/org/openhab/binding/lcn/internal/connection/Connection.java", "diffHunk": "@@ -0,0 +1,505 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.lcn.internal.connection;\n+\n+import java.io.IOException;\n+import java.io.UnsupportedEncodingException;\n+import java.nio.BufferOverflowException;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.AsynchronousSocketChannel;\n+import java.nio.channels.Channel;\n+import java.nio.channels.CompletionHandler;\n+import java.time.Instant;\n+import java.time.temporal.ChronoUnit;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Queue;\n+import java.util.concurrent.LinkedBlockingQueue;\n+import java.util.concurrent.ScheduledExecutorService;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.lcn.internal.common.LcnAddr;\n+import org.openhab.binding.lcn.internal.common.LcnAddrGrp;\n+import org.openhab.binding.lcn.internal.common.LcnAddrMod;\n+import org.openhab.binding.lcn.internal.common.LcnDefs;\n+import org.openhab.binding.lcn.internal.common.LcnException;\n+import org.openhab.binding.lcn.internal.common.PckGenerator;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * This class represents a configured connection to one LCN-PCHK.\n+ * It uses a {@link AsynchronousSocketChannel} to connect to LCN-PCHK.\n+ * Included logic:\n+ * <ul>\n+ * <li>Reconnection on connection loss\n+ * <li>Segment scan (to detect the local segment ID)\n+ * <li>Acknowledge handling\n+ * <li>Periodic value requests\n+ * <li>Caching of runtime data about the underlying LCN bus\n+ * </ul>\n+ *\n+ * @author Fabian Wolter - Initial Contribution\n+ */\n+@NonNullByDefault\n+public class Connection {\n+    private final Logger logger = LoggerFactory.getLogger(Connection.class);\n+    /** Max. lengths of a PCK string including address and line feed. Currently dynamic text (GTDT) */\n+    private static final int MAX_PCK_STRING_LENGTH = 34;\n+    private static final int BROADCAST_MODULE_ID = 3;\n+    private static final int BROADCAST_SEGMENT_ID = 3;\n+    private final ConnectionSettings settings;\n+    private final ConnectionCallback callback;\n+    @Nullable\n+    private AsynchronousSocketChannel channel;\n+    /** The local segment id. -1 means \"unknown\". */\n+    private int localSegId;\n+    private final ByteBuffer readBuffer = ByteBuffer.allocate(1024);\n+    private final ByteBuffer sendBuffer = ByteBuffer.allocate(MAX_PCK_STRING_LENGTH);\n+    private final Queue<@Nullable SendData> sendQueue = new LinkedBlockingQueue<>();\n+    private final Queue<@Nullable PckQueueItem> offlineSendQueue = new LinkedBlockingQueue<>();\n+    private final Map<LcnAddr, @Nullable ModInfo> modData = Collections.synchronizedMap(new HashMap<>());\n+    private volatile boolean writeInProgress;\n+    private ScheduledExecutorService scheduler;\n+    private StateMachine stateMachine;\n+\n+    /**\n+     * Constructs a clean (disconnected) connection with the given settings.\n+     * This does not start the actual connection process.\n+     *\n+     * @param sets the settings to use for the new connection\n+     * @param callback the callback to the owner\n+     * @throws IOException\n+     */\n+    public Connection(ConnectionSettings sets, ScheduledExecutorService scheduler, ConnectionCallback callback) {\n+        this.settings = sets;\n+        this.callback = callback;\n+        this.scheduler = scheduler;\n+        this.clearRuntimeData();\n+\n+        stateMachine = new StateMachine(this, scheduler);\n+        stateMachine.startWorking();\n+    }\n+\n+    /** Clears all runtime data. */\n+    void clearRuntimeData() {\n+        this.channel = null;\n+        this.localSegId = -1;\n+        this.readBuffer.clear();\n+        this.sendQueue.clear();\n+        this.sendBuffer.clear();\n+    }\n+\n+    /**\n+     * Retrieves the settings for this connection (never changed).\n+     *\n+     * @return the settings\n+     */\n+    public ConnectionSettings getSettings() {\n+        return this.settings;\n+    }\n+\n+    private boolean isSocketConnected() {\n+        try {\n+            AsynchronousSocketChannel localChannel = channel;\n+            return localChannel != null && localChannel.getRemoteAddress() != null;\n+        } catch (IOException e) {\n+            return false;\n+        }\n+    }\n+\n+    /**\n+     * Sets the local segment id.\n+     *\n+     * @param localSegId the new local segment id\n+     */\n+    public void setLocalSegId(int localSegId) {\n+        this.localSegId = localSegId;\n+    }\n+\n+    /**\n+     * Called whenever an acknowledge is received.\n+     *\n+     * @param addr the source LCN module\n+     * @param code the LCN internal code (-1 = \"positive\")\n+     */\n+    public void onAck(LcnAddrMod addr, int code) {\n+        ModInfo info = this.modData.get(addr);\n+        if (info != null) {\n+            info.onAck(code, this, this.settings.getTimeout(), System.nanoTime());\n+        }\n+    }\n+\n+    /**\n+     * Creates and/or returns cached data for the given LCN module.\n+     *\n+     * @param addr the module's address\n+     * @return the data (never null)\n+     */\n+    public ModInfo updateModuleData(LcnAddrMod addr) {\n+        synchronized (modData) {\n+            ModInfo data = this.modData.get(addr);\n+            if (data == null) {\n+                data = new ModInfo(addr);\n+                this.modData.put(addr, data);\n+            }\n+            return data;\n+        }\n+    }\n+\n+    /**\n+     * Reads and processes input from the underlying channel.\n+     * Fragmented input is kept in {@link #readBuffer} and will be processed with the next call.\n+     *\n+     * @throws IOException if connection was closed or a generic channel error occurred\n+     */\n+    void readAndProcess() {\n+        AsynchronousSocketChannel localChannel = channel;\n+        if (localChannel != null && isSocketConnected()) {\n+            localChannel.read(readBuffer, null, new CompletionHandler<@Nullable Integer, @Nullable Void>() {\n+                @Override\n+                public void completed(@Nullable Integer transmittedByteCount, @Nullable Void attachment) {\n+                    synchronized (Connection.this) {\n+                        if (transmittedByteCount == null || transmittedByteCount == -1) {\n+                            String msg = \"Connection was closed by foreign host.\";\n+                            stateMachine.handleConnectionFailed(new LcnException(msg));\n+                        } else {\n+                            try {\n+                                // read data chunks from socket and separate frames\n+                                readBuffer.flip();\n+                                int aPos = readBuffer.position(); // 0\n+                                String s = new String(readBuffer.array(), aPos, transmittedByteCount,\n+                                        LcnDefs.LCN_ENCODING);\n+                                int pos1 = 0, pos2 = s.indexOf(PckGenerator.TERMINATION, pos1);\n+                                while (pos2 != -1) {\n+                                    String data = s.substring(pos1, pos2);\n+                                    if (logger.isTraceEnabled()) {\n+                                        logger.trace(\"Received: '{}'\", data);\n+                                    }\n+                                    scheduler.submit(() -> {\n+                                        stateMachine.onInputReceived(data);\n+                                        callback.onPckMessageReceived(data);\n+                                    });\n+                                    // Seek position in input array\n+                                    aPos += s.substring(pos1, pos2 + 1).getBytes(LcnDefs.LCN_ENCODING).length;\n+                                    // Next input\n+                                    pos1 = pos2 + 1;\n+                                    pos2 = s.indexOf(PckGenerator.TERMINATION, pos1);\n+                                }\n+                                readBuffer.limit(readBuffer.capacity());\n+                                readBuffer.position(transmittedByteCount - aPos); // Keeps fragments for the next call\n+                            } catch (UnsupportedEncodingException ex) {\n+                                logger.warn(\"Unable to decode input from channel \\\"{}\\\": {}\", settings.getId(),\n+                                        ex.getMessage());\n+                            }\n+\n+                            if (isSocketConnected()) {\n+                                readAndProcess();\n+                            }\n+                        }\n+                    }\n+                }\n+\n+                @Override\n+                public void failed(@Nullable Throwable e, @Nullable Void attachment) {\n+                    logger.debug(\"Lost connection\");\n+                    stateMachine.handleConnectionFailed(e);\n+                }\n+            });\n+        } else {\n+            stateMachine.handleConnectionFailed(new LcnException(\"Socket not open\"));\n+        }\n+    }\n+\n+    /**\n+     * Writes all queued data.\n+     * Will try to write all data at once to reduce overhead.\n+     */\n+    public synchronized void triggerWriteToSocket() {\n+        AsynchronousSocketChannel localChannel = channel;\n+        if (localChannel == null || !isSocketConnected() || writeInProgress) {\n+            return;\n+        }\n+        sendBuffer.clear();\n+        SendData item = sendQueue.poll();\n+\n+        if (item != null) {\n+            try {\n+                if (!item.write(sendBuffer, localSegId)) {\n+                    logger.warn(\"Data loss: Could not write packet into send buffer\");\n+                }\n+\n+                writeInProgress = true;\n+                sendBuffer.flip();\n+                localChannel.write(sendBuffer, null, new CompletionHandler<@Nullable Integer, @Nullable Void>() {\n+                    @Override\n+                    public void completed(@Nullable Integer result, @Nullable Void attachment) {\n+                        synchronized (Connection.this) {\n+                            if (result != sendBuffer.limit()) {\n+                                logger.warn(\"Data loss while writing to channel: {}\", settings.getAddress());\n+                            } else {\n+                                if (logger.isTraceEnabled()) {\n+                                    logger.trace(\"Sent: {}\", new String(sendBuffer.array(), 0, sendBuffer.limit()));\n+                                }\n+                            }\n+\n+                            writeInProgress = false;\n+\n+                            if (sendQueue.size() > 0) {\n+                                /**\n+                                 * This could lead to stack overflows, since the CompletionHandler may run in the same\n+                                 * Thread as triggerWriteToSocket() is invoked (see\n+                                 * {@link AsynchronousChannelGroup}/Threading), but we do not expect as much data\n+                                 * in one chunk here, that the stack can be filled in a critical way.\n+                                 */\n+                                triggerWriteToSocket();\n+                            }\n+                        }\n+                    }\n+\n+                    @Override\n+                    public void failed(@Nullable Throwable exc, @Nullable Void attachment) {\n+                        synchronized (Connection.this) {\n+                            if (exc != null) {\n+                                logger.warn(\"Writing to channel \\\"{}\\\" failed: {}\", settings.getAddress(),\n+                                        exc.getMessage());\n+                            }\n+                            writeInProgress = false;\n+                            stateMachine.handleConnectionFailed(new LcnException(\"write() failed\"));\n+                        }\n+                    }\n+                });\n+            } catch (UnsupportedEncodingException | BufferOverflowException e) {\n+                logger.warn(\"Sending failed: {}: {}: {}\", item, e.getClass().getSimpleName(), e.getMessage());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Queues plain text to be sent to LCN-PCHK.\n+     * Sending will be done the next time {@link #triggerWriteToSocket()} is called.\n+     *\n+     * @param plainText the text\n+     */\n+    public void queueDirectlyPlainText(String plainText) {\n+        this.queueAndSend(new SendDataPlainText(plainText));\n+    }\n+\n+    /**\n+     * Queues a PCK command to be sent.\n+     *\n+     * @param addr the target LCN address\n+     * @param wantsAck true to wait for acknowledge on receipt (should be false for group addresses)\n+     * @param pck the pure PCK command (without address header)\n+     */\n+    void queueDirectly(LcnAddr addr, boolean wantsAck, String pck) {\n+        try {\n+            this.queueDirectly(addr, wantsAck, ByteBuffer.wrap(pck.getBytes(LcnDefs.LCN_ENCODING)));\n+        } catch (UnsupportedEncodingException ex) {\n+            logger.error(\"Failed to encode PCK command: {}\", pck);\n+        }\n+    }\n+\n+    /**\n+     * Queues a PCK command for immediate sending, regardless of the Connection state. The PCK command is automatically\n+     * re-sent if the destination is not a group, an Ack is requested and the module did not answer within the expected\n+     * time.\n+     *\n+     * @param addr the target LCN address\n+     * @param wantsAck true to wait for acknowledge on receipt (should be false for group addresses)\n+     * @param data the pure PCK command (without address header)\n+     */\n+    void queueDirectly(LcnAddr addr, boolean wantsAck, ByteBuffer data) {\n+        if (!addr.isGroup() && wantsAck) {\n+            this.updateModuleData((LcnAddrMod) addr).queuePckCommandWithAck(data, this, this.settings.getTimeout(),\n+                    System.nanoTime());\n+        } else {\n+            this.queueAndSend(new SendDataPck(addr, false, data));\n+        }\n+    }\n+\n+    /**\n+     * Enqueues a raw PCK command and triggers the socket to start sending, if it does not already. Does not take care\n+     * of any Acks.\n+     *\n+     * @param data raw PCK command\n+     */\n+    synchronized void queueAndSend(SendData data) {\n+        this.sendQueue.add(data);\n+\n+        triggerWriteToSocket();\n+    }\n+\n+    /**\n+     * Enqueues a PCK command to the offline queue. Data will be sent when the Connection state will enter\n+     * {@link ConnectionStateConnected}.\n+     *\n+     * @param addr LCN module address\n+     * @param wantsAck true, if the LCN module shall respond with an Ack on successful processing\n+     * @param data the pure PCK command (without address header)\n+     */\n+    void queueOffline(LcnAddr addr, boolean wantsAck, ByteBuffer data) {\n+        offlineSendQueue.add(new PckQueueItem(addr, wantsAck, data));\n+    }\n+\n+    /**\n+     * Enqueues a PCK command for sending. Takes care of the Connection state and buffers the command for a specific\n+     * time if the Connection is not ready. If an Ack is requested, the PCK command is automatically\n+     * re-sent, if the module did not answer in the expected time.\n+     *\n+     * @param addr LCN module address\n+     * @param wantsAck true, if the LCN module shall respond with an Ack on successful processing\n+     * @param pck the pure PCK command (without address header)\n+     */\n+    public void queue(LcnAddr addr, boolean wantsAck, String pck) {\n+        try {\n+            this.queue(addr, wantsAck, ByteBuffer.wrap(pck.getBytes(LcnDefs.LCN_ENCODING)));\n+        } catch (UnsupportedEncodingException ex) {\n+            logger.warn(\"Failed to encode PCK command: {}\", pck);\n+        }\n+    }\n+\n+    /**\n+     * Enqueues a PCK command for sending. Takes care of the Connection state and buffers the command for a specific\n+     * time if the Connection is not ready. If an Ack is requested, the PCK command is automatically\n+     * re-sent, if the module did not answer in the expected time.\n+     *\n+     * @param addr LCN module address\n+     * @param wantsAck true, if the LCN module shall respond with an Ack on successful processing\n+     * @param pck the pure PCK command (without address header)\n+     */\n+    public void queue(LcnAddr addr, boolean wantsAck, ByteBuffer pck) {\n+        stateMachine.queue(addr, wantsAck, pck);\n+    }\n+\n+    /**\n+     * Process the offline PCK command queue. Does only send recently enqueued PCK commands, the rest is discarded.\n+     */\n+    void sendOfflineQueue() {\n+        // don't use forEach(), because elements can be added during iteration\n+        while (!offlineSendQueue.isEmpty()) {\n+            PckQueueItem item = offlineSendQueue.poll();\n+\n+            if (item == null) {\n+                break;\n+            }\n+\n+            // only send messages that were enqueued recently, discard older messages\n+            long timeout = settings.getTimeout();\n+            if (item.getEnqueued().isAfter(Instant.now().minus(timeout * 4, ChronoUnit.MILLIS))) {\n+                queueDirectly(item.getAddr(), item.isWantsAck(), item.getData());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Gets the Connection's callback.\n+     *\n+     * @return the callback\n+     */\n+    public ConnectionCallback getCallback() {\n+        return callback;\n+    }\n+\n+    /**\n+     * Sets the SocketChannel of this Connection\n+     *\n+     * @param channel the new Channel\n+     */\n+    public void setSocketChannel(AsynchronousSocketChannel channel) {\n+        this.channel = channel;\n+    }\n+\n+    /**\n+     * Gets the SocketChannel of the Connection.\n+     *\n+     * @returnthe socket channel\n+     */\n+    @Nullable\n+    public Channel getSocketChannel() {\n+        return channel;\n+    }\n+\n+    /**\n+     * Gets the local segment ID. When no segments are used, the local segment ID is 0.\n+     *\n+     * @return the local segment ID\n+     */\n+    public int getLocalSegId() {\n+        return localSegId;\n+    }\n+\n+    /**\n+     * Runs the periodic updates on all ModInfos.\n+     */\n+    public void updateModInfos() {\n+        synchronized (modData) {\n+            for (ModInfo info : modData.values()) {\n+                if (info != null) {\n+                    info.update(this, settings.getTimeout(), System.nanoTime());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ce02f433e5d4071dbebb9ee68da0e22895887b6b"}, "originalPosition": 451}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjg5Njk5MA==", "bodyText": "Why are you using a byte buffer here instead of a byte array?", "url": "https://github.com/openhab/openhab-addons/pull/7509#discussion_r436896990", "createdAt": "2020-06-08T18:07:24Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.lcn/src/main/java/org/openhab/binding/lcn/internal/connection/SendDataPck.java", "diffHunk": "@@ -0,0 +1,78 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.lcn.internal.connection;\n+\n+import java.io.UnsupportedEncodingException;\n+import java.nio.BufferOverflowException;\n+import java.nio.ByteBuffer;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.binding.lcn.internal.common.LcnAddr;\n+import org.openhab.binding.lcn.internal.common.LcnDefs;\n+import org.openhab.binding.lcn.internal.common.PckGenerator;\n+\n+/**\n+ * A PCK command to be send to LCN-PCHK.\n+ * It is already encoded as bytes to allow different text-encodings (ANSI, UTF-8).\n+ *\n+ * @author Tobias J\u00fcttner - Initial Contribution\n+ * @author Fabian Wolter - Migration to OH2\n+ */\n+@NonNullByDefault\n+class SendDataPck extends SendData {\n+    /** The target LCN address. */\n+    private final LcnAddr addr;\n+\n+    /** true to acknowledge the command on receipt. */\n+    private final boolean wantsAck;\n+\n+    /** PCK command (without address header) encoded as bytes. */\n+    private final ByteBuffer data;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ce02f433e5d4071dbebb9ee68da0e22895887b6b"}, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjg5ODc0MQ==", "bodyText": "taking a byte buffer as an argument for a write operation is inherently risky since it cannot grow in size and makes it very easy to implementors to write in excess of the buffer's size. I think a DataOutputStream would be more appropriate here.", "url": "https://github.com/openhab/openhab-addons/pull/7509#discussion_r436898741", "createdAt": "2020-06-08T18:10:36Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.lcn/src/main/java/org/openhab/binding/lcn/internal/connection/SendData.java", "diffHunk": "@@ -0,0 +1,41 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.lcn.internal.connection;\n+\n+import java.io.UnsupportedEncodingException;\n+import java.nio.BufferOverflowException;\n+import java.nio.ByteBuffer;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+\n+/**\n+ * Base class for a packet to be send to LCN-PCHK.\n+ *\n+ * @author Tobias J\u00fcttner - Initial Contribution\n+ * @author Fabian Wolter - Migration to OH2\n+ */\n+@NonNullByDefault\n+public abstract class SendData {\n+    /**\n+     * Writes the packet's data into the given buffer.\n+     * Called right before the packet is actually sent to LCN-PCHK.\n+     *\n+     * @param buffer the target buffer\n+     * @param localSegId the local segment id\n+     * @return true if everything was set-up correctly and data was written\n+     * @throws UnsupportedEncodingException if text could not be encoded for LCN-PCHK\n+     * @throws BufferOverflowException if target buffer has not enough space left (buffer will not be altered)\n+     */\n+    abstract boolean write(ByteBuffer buffer, int localSegId)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ce02f433e5d4071dbebb9ee68da0e22895887b6b"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjkwMTI3OQ==", "bodyText": "If you made an implementation of AbstractVariableValueConverter that takes a Unit and scaling constructor parameters then you could probably get rid of this class and a few others.", "url": "https://github.com/openhab/openhab-addons/pull/7509#discussion_r436901279", "createdAt": "2020-06-08T18:15:21Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.lcn/src/main/java/org/openhab/binding/lcn/internal/converter/AngleConverter.java", "diffHunk": "@@ -0,0 +1,41 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.lcn.internal.converter;\n+\n+import javax.measure.Unit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.smarthome.core.library.unit.SmartHomeUnits;\n+\n+/**\n+ * Converts the native LCN value of LCN-WIH to the sun azimuth/elevation values.\n+ *\n+ * @author Fabian Wolter - Initial Contribution\n+ */\n+@NonNullByDefault\n+public class AngleConverter extends AbstractVariableValueConverter {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ce02f433e5d4071dbebb9ee68da0e22895887b6b"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjkwMzYxOQ==", "bodyText": "I'm not sure that lazy initialization of the singleton instance really matters for stateless singletons.", "url": "https://github.com/openhab/openhab-addons/pull/7509#discussion_r436903619", "createdAt": "2020-06-08T18:19:31Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.lcn/src/main/java/org/openhab/binding/lcn/internal/converter/IdentityConverter.java", "diffHunk": "@@ -0,0 +1,62 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.lcn.internal.converter;\n+\n+import javax.measure.Unit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.unit.SmartHomeUnits;\n+import org.openhab.binding.lcn.internal.common.LcnException;\n+\n+/**\n+ * Converts the value 1:1.\n+ *\n+ * @author Fabian Wolter - Initial Contribution\n+ */\n+@NonNullByDefault\n+public class IdentityConverter extends AbstractVariableValueConverter {\n+    private IdentityConverter() {\n+        // nothing\n+    }\n+\n+    @NonNullByDefault({})\n+    private static class LazyHolder {\n+        static final IdentityConverter INSTANCE = new IdentityConverter();\n+    }\n+\n+    public static IdentityConverter getInstance() {\n+        return LazyHolder.INSTANCE;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ce02f433e5d4071dbebb9ee68da0e22895887b6b"}, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjkxMjc5Ng==", "bodyText": "why not make this a byte array?", "url": "https://github.com/openhab/openhab-addons/pull/7509#discussion_r436912796", "createdAt": "2020-06-08T18:36:08Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.lcn/src/main/java/org/openhab/binding/lcn/internal/connection/PckQueueItem.java", "diffHunk": "@@ -0,0 +1,75 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.lcn.internal.connection;\n+\n+import java.nio.ByteBuffer;\n+import java.time.Instant;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.binding.lcn.internal.common.LcnAddr;\n+\n+/**\n+ * Holds data of one PCK command with the target address and the date when the item has been enqueued.\n+ *\n+ * @author Fabian Wolter - Initial Contribution\n+ */\n+@NonNullByDefault\n+public class PckQueueItem {\n+    private Instant enqueued;\n+    private LcnAddr addr;\n+    private boolean wantsAck;\n+    private ByteBuffer data;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ce02f433e5d4071dbebb9ee68da0e22895887b6b"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjkxMzcxNQ==", "bodyText": "Just letting you know in case you are not aware, but there is a current outstanding bug regarding actions that currently requires a workaround.\nopenhab/openhab-core#1265\nIf you feel like implementing the workaround you can use this as a example:\nhttps://github.com/openhab/openhab-addons/blob/2.5.x/bundles/org.openhab.binding.ecobee/src/main/java/org/openhab/binding/ecobee/action/EcobeeActions.java#L89", "url": "https://github.com/openhab/openhab-addons/pull/7509#discussion_r436913715", "createdAt": "2020-06-08T18:37:47Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.lcn/src/main/java/org/openhab/binding/lcn/internal/LcnModuleActions.java", "diffHunk": "@@ -0,0 +1,194 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.lcn.internal;\n+\n+import java.io.UnsupportedEncodingException;\n+import java.nio.ByteBuffer;\n+import java.util.Arrays;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.binding.ThingActions;\n+import org.eclipse.smarthome.core.thing.binding.ThingActionsScope;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\n+import org.openhab.binding.lcn.internal.common.LcnChannelGroup;\n+import org.openhab.binding.lcn.internal.common.LcnDefs;\n+import org.openhab.binding.lcn.internal.common.LcnDefs.KeyTable;\n+import org.openhab.binding.lcn.internal.common.LcnDefs.SendKeyCommand;\n+import org.openhab.binding.lcn.internal.common.LcnException;\n+import org.openhab.binding.lcn.internal.common.PckGenerator;\n+import org.openhab.core.automation.annotation.ActionInput;\n+import org.openhab.core.automation.annotation.RuleAction;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Handles actions requested to be sent to an LCN module.\n+ *\n+ * @author Fabian Wolter - Initial contribution\n+ */\n+@ThingActionsScope(name = \"lcn\")\n+@NonNullByDefault\n+public class LcnModuleActions implements ThingActions {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ce02f433e5d4071dbebb9ee68da0e22895887b6b"}, "originalPosition": 42}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjkxNTAxMQ==", "bodyText": "Why is this a synchronized HashMap instead of a ConcurrentHashMap?", "url": "https://github.com/openhab/openhab-addons/pull/7509#discussion_r436915011", "createdAt": "2020-06-08T18:40:20Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.lcn/src/main/java/org/openhab/binding/lcn/internal/LcnModuleDiscoveryService.java", "diffHunk": "@@ -0,0 +1,246 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.lcn.internal;\n+\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Queue;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentLinkedQueue;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.config.discovery.AbstractDiscoveryService;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResultBuilder;\n+import org.eclipse.smarthome.config.discovery.DiscoveryService;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.thing.ThingUID;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.openhab.binding.lcn.internal.common.LcnAddrMod;\n+import org.openhab.binding.lcn.internal.common.NullScheduledFuture;\n+import org.openhab.binding.lcn.internal.connection.Connection;\n+import org.openhab.binding.lcn.internal.subhandler.LcnModuleMetaAckSubHandler;\n+import org.openhab.binding.lcn.internal.subhandler.LcnModuleMetaFirmwareSubHandler;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Scans all LCN segments for LCN modules.\n+ *\n+ * Scan approach:\n+ * 1. Send \"Leerkomando\" to the broadcast address with request for Ack set\n+ * 2. For every received Ack, send the following requests to the module:\n+ * - serial number request (SN)\n+ * - module's name first part request (NM1)\n+ * - module's name second part request (NM2)\n+ * 3. When all three messages have been received, fire thingDiscovered()\n+ *\n+ * @author Fabian Wolter - Initial Contribution\n+ */\n+@NonNullByDefault\n+public class LcnModuleDiscoveryService extends AbstractDiscoveryService\n+        implements DiscoveryService, ThingHandlerService {\n+    private final Logger logger = LoggerFactory.getLogger(LcnModuleDiscoveryService.class);\n+    private static final Pattern NAME_PATTERN = Pattern\n+            .compile(\"=M(?<segId>\\\\d{3})(?<modId>\\\\d{3}).N(?<part>[1-2]{1})(?<name>.*)\");\n+    private static final int MODULE_NAME_PART_COUNT = 2;\n+    private static final int DISCOVERY_TIMEOUT_SEC = 90;\n+    private static final int ACK_TIMEOUT_MS = 1000;\n+    private static final Set<ThingTypeUID> SUPPORTED_THING_TYPES_UIDS = Collections\n+            .unmodifiableSet(Stream.of(LcnBindingConstants.THING_TYPE_MODULE).collect(Collectors.toSet()));\n+    private @Nullable PckGatewayHandler bridgeHandler;\n+    private Map<LcnAddrMod, Map<Integer, String>> moduleNames = Collections.synchronizedMap(new HashMap<>());\n+    private Map<LcnAddrMod, DiscoveryResultBuilder> discoveryResultBuilders = Collections\n+            .synchronizedMap(new HashMap<>());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ce02f433e5d4071dbebb9ee68da0e22895887b6b"}, "originalPosition": 74}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjkxNTYyNA==", "bodyText": "Why does this need to be a synchronized map if all access to it is already synchronized around LcnModuleDiscoveryService?", "url": "https://github.com/openhab/openhab-addons/pull/7509#discussion_r436915624", "createdAt": "2020-06-08T18:41:21Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.lcn/src/main/java/org/openhab/binding/lcn/internal/LcnModuleDiscoveryService.java", "diffHunk": "@@ -0,0 +1,246 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.lcn.internal;\n+\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Queue;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentLinkedQueue;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.config.discovery.AbstractDiscoveryService;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResultBuilder;\n+import org.eclipse.smarthome.config.discovery.DiscoveryService;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.thing.ThingUID;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.openhab.binding.lcn.internal.common.LcnAddrMod;\n+import org.openhab.binding.lcn.internal.common.NullScheduledFuture;\n+import org.openhab.binding.lcn.internal.connection.Connection;\n+import org.openhab.binding.lcn.internal.subhandler.LcnModuleMetaAckSubHandler;\n+import org.openhab.binding.lcn.internal.subhandler.LcnModuleMetaFirmwareSubHandler;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Scans all LCN segments for LCN modules.\n+ *\n+ * Scan approach:\n+ * 1. Send \"Leerkomando\" to the broadcast address with request for Ack set\n+ * 2. For every received Ack, send the following requests to the module:\n+ * - serial number request (SN)\n+ * - module's name first part request (NM1)\n+ * - module's name second part request (NM2)\n+ * 3. When all three messages have been received, fire thingDiscovered()\n+ *\n+ * @author Fabian Wolter - Initial Contribution\n+ */\n+@NonNullByDefault\n+public class LcnModuleDiscoveryService extends AbstractDiscoveryService\n+        implements DiscoveryService, ThingHandlerService {\n+    private final Logger logger = LoggerFactory.getLogger(LcnModuleDiscoveryService.class);\n+    private static final Pattern NAME_PATTERN = Pattern\n+            .compile(\"=M(?<segId>\\\\d{3})(?<modId>\\\\d{3}).N(?<part>[1-2]{1})(?<name>.*)\");\n+    private static final int MODULE_NAME_PART_COUNT = 2;\n+    private static final int DISCOVERY_TIMEOUT_SEC = 90;\n+    private static final int ACK_TIMEOUT_MS = 1000;\n+    private static final Set<ThingTypeUID> SUPPORTED_THING_TYPES_UIDS = Collections\n+            .unmodifiableSet(Stream.of(LcnBindingConstants.THING_TYPE_MODULE).collect(Collectors.toSet()));\n+    private @Nullable PckGatewayHandler bridgeHandler;\n+    private Map<LcnAddrMod, Map<Integer, String>> moduleNames = Collections.synchronizedMap(new HashMap<>());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ce02f433e5d4071dbebb9ee68da0e22895887b6b"}, "originalPosition": 72}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjkxNjcxMw==", "bodyText": "Is it possible to specify the representation property as well?", "url": "https://github.com/openhab/openhab-addons/pull/7509#discussion_r436916713", "createdAt": "2020-06-08T18:43:21Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.lcn/src/main/java/org/openhab/binding/lcn/internal/LcnModuleDiscoveryService.java", "diffHunk": "@@ -0,0 +1,246 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.lcn.internal;\n+\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Queue;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentLinkedQueue;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.config.discovery.AbstractDiscoveryService;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResultBuilder;\n+import org.eclipse.smarthome.config.discovery.DiscoveryService;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.thing.ThingUID;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.openhab.binding.lcn.internal.common.LcnAddrMod;\n+import org.openhab.binding.lcn.internal.common.NullScheduledFuture;\n+import org.openhab.binding.lcn.internal.connection.Connection;\n+import org.openhab.binding.lcn.internal.subhandler.LcnModuleMetaAckSubHandler;\n+import org.openhab.binding.lcn.internal.subhandler.LcnModuleMetaFirmwareSubHandler;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Scans all LCN segments for LCN modules.\n+ *\n+ * Scan approach:\n+ * 1. Send \"Leerkomando\" to the broadcast address with request for Ack set\n+ * 2. For every received Ack, send the following requests to the module:\n+ * - serial number request (SN)\n+ * - module's name first part request (NM1)\n+ * - module's name second part request (NM2)\n+ * 3. When all three messages have been received, fire thingDiscovered()\n+ *\n+ * @author Fabian Wolter - Initial Contribution\n+ */\n+@NonNullByDefault\n+public class LcnModuleDiscoveryService extends AbstractDiscoveryService\n+        implements DiscoveryService, ThingHandlerService {\n+    private final Logger logger = LoggerFactory.getLogger(LcnModuleDiscoveryService.class);\n+    private static final Pattern NAME_PATTERN = Pattern\n+            .compile(\"=M(?<segId>\\\\d{3})(?<modId>\\\\d{3}).N(?<part>[1-2]{1})(?<name>.*)\");\n+    private static final int MODULE_NAME_PART_COUNT = 2;\n+    private static final int DISCOVERY_TIMEOUT_SEC = 90;\n+    private static final int ACK_TIMEOUT_MS = 1000;\n+    private static final Set<ThingTypeUID> SUPPORTED_THING_TYPES_UIDS = Collections\n+            .unmodifiableSet(Stream.of(LcnBindingConstants.THING_TYPE_MODULE).collect(Collectors.toSet()));\n+    private @Nullable PckGatewayHandler bridgeHandler;\n+    private Map<LcnAddrMod, Map<Integer, String>> moduleNames = Collections.synchronizedMap(new HashMap<>());\n+    private Map<LcnAddrMod, DiscoveryResultBuilder> discoveryResultBuilders = Collections\n+            .synchronizedMap(new HashMap<>());\n+    private List<LcnAddrMod> successfullyDiscovered = new LinkedList<>();\n+    private Queue<@Nullable LcnAddrMod> serialNumberRequestQueue = new ConcurrentLinkedQueue<>();\n+    private Queue<@Nullable LcnAddrMod> moduleNameRequestQueue = new ConcurrentLinkedQueue<>();\n+    private volatile ScheduledFuture<?> queueProcessor = NullScheduledFuture.getInstance();\n+    private ScheduledFuture<?> builderTask = NullScheduledFuture.getInstance();\n+\n+    public LcnModuleDiscoveryService() {\n+        super(SUPPORTED_THING_TYPES_UIDS, DISCOVERY_TIMEOUT_SEC, false);\n+    }\n+\n+    @Override\n+    public void setThingHandler(@Nullable ThingHandler handler) {\n+        if (handler instanceof PckGatewayHandler) {\n+            this.bridgeHandler = (PckGatewayHandler) handler;\n+        }\n+    }\n+\n+    @Override\n+    public @Nullable ThingHandler getThingHandler() {\n+        return bridgeHandler;\n+    }\n+\n+    @Override\n+    public void deactivate() {\n+        super.deactivate();\n+        stopScan();\n+    }\n+\n+    @SuppressWarnings({ \"unused\", \"null\" })\n+    @Override\n+    protected void startScan() {\n+        synchronized (this) {\n+            PckGatewayHandler localBridgeHandler = bridgeHandler;\n+            if (localBridgeHandler == null) {\n+                logger.warn(\"Bridge handler not set\");\n+                return;\n+            }\n+\n+            if (localBridgeHandler.getConnection() == null) {\n+                builderTask.cancel(true);\n+            }\n+\n+            localBridgeHandler.registerPckListener(data -> {\n+                Matcher matcher;\n+\n+                if ((matcher = LcnModuleMetaAckSubHandler.PATTERN_POS.matcher(data)).matches()\n+                        || (matcher = LcnModuleMetaFirmwareSubHandler.PATTERN.matcher(data)).matches()\n+                        || (matcher = NAME_PATTERN.matcher(data)).matches()) {\n+                    synchronized (LcnModuleDiscoveryService.this) {\n+                        Connection connection = localBridgeHandler.getConnection();\n+\n+                        if (connection == null) {\n+                            return;\n+                        }\n+\n+                        LcnAddrMod addr = new LcnAddrMod(\n+                                localBridgeHandler.toLogicalSegmentId(Integer.parseInt(matcher.group(\"segId\"))),\n+                                Integer.parseInt(matcher.group(\"modId\")));\n+\n+                        if (matcher.pattern() == LcnModuleMetaAckSubHandler.PATTERN_POS) {\n+                            // Received an ACK frame\n+\n+                            // The module could send an Ack with a response to another command. So, ignore the Ack, when\n+                            // we received our data already.\n+                            if (!discoveryResultBuilders.containsKey(addr)) {\n+                                serialNumberRequestQueue.add(addr);\n+                                rescheduleQueueProcessor(); // delay request of serial until all modules finished ACKing\n+                            }\n+\n+                            if (!moduleNames.containsKey(addr)\n+                                    || moduleNames.get(addr).size() != MODULE_NAME_PART_COUNT) {\n+                                moduleNameRequestQueue.add(addr);\n+                                rescheduleQueueProcessor(); // delay request of names until all modules finished ACKing\n+                            }\n+                        } else if (matcher.pattern() == LcnModuleMetaFirmwareSubHandler.PATTERN) {\n+                            // Received a firmware version info frame\n+\n+                            Map<String, Object> properties = new HashMap<>(5);\n+                            properties.put(\"segmentId\", addr.getSegmentId());\n+                            properties.put(\"moduleId\", addr.getModuleId());\n+\n+                            ThingUID bridgeUid = localBridgeHandler.getThing().getUID();\n+                            String thingId = matcher.group(\"sn\");\n+                            ThingUID thingUid = new ThingUID(LcnBindingConstants.THING_TYPE_MODULE, bridgeUid, thingId);\n+\n+                            DiscoveryResultBuilder discoveryResult = DiscoveryResultBuilder.create(thingUid)\n+                                    .withProperties(properties).withBridge(bridgeUid);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ce02f433e5d4071dbebb9ee68da0e22895887b6b"}, "originalPosition": 161}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjkxODA1OA==", "bodyText": "please cache config.getMode() in a local variable so it can be reused", "url": "https://github.com/openhab/openhab-addons/pull/7509#discussion_r436918058", "createdAt": "2020-06-08T18:45:40Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.lcn/src/main/java/org/openhab/binding/lcn/internal/PckGatewayHandler.java", "diffHunk": "@@ -0,0 +1,301 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.lcn.internal;\n+\n+import java.nio.ByteBuffer;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Optional;\n+import java.util.function.Consumer;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseBridgeHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.openhab.binding.lcn.internal.common.LcnAddr;\n+import org.openhab.binding.lcn.internal.common.LcnAddrMod;\n+import org.openhab.binding.lcn.internal.common.LcnDefs;\n+import org.openhab.binding.lcn.internal.common.LcnDefs.OutputPortDimMode;\n+import org.openhab.binding.lcn.internal.common.LcnException;\n+import org.openhab.binding.lcn.internal.connection.Connection;\n+import org.openhab.binding.lcn.internal.connection.ConnectionCallback;\n+import org.openhab.binding.lcn.internal.connection.ConnectionSettings;\n+import org.openhab.binding.lcn.internal.connection.ModInfo;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link PckGatewayHandler} is responsible for the communication via a PCK gateway.\n+ *\n+ * @author Fabian Wolter - Initial contribution\n+ */\n+@NonNullByDefault\n+public class PckGatewayHandler extends BaseBridgeHandler {\n+    private final Logger logger = LoggerFactory.getLogger(PckGatewayHandler.class);\n+    private @Nullable Connection connection;\n+    private Optional<Consumer<String>> pckListener = Optional.empty();\n+\n+    public PckGatewayHandler(Bridge bridge) {\n+        super(bridge);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        // nothing\n+    }\n+\n+    @Override\n+    public synchronized void initialize() {\n+        PckGatewayConfiguration config = getConfigAs(PckGatewayConfiguration.class);\n+\n+        String errorMessage = \"Could not connect to LCN-PCHK/PKE: \" + config.getHostname() + \": \";\n+\n+        try {\n+            OutputPortDimMode dimMode;\n+            if (LcnDefs.OutputPortDimMode.NATIVE50.name().equalsIgnoreCase(config.getMode())) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ce02f433e5d4071dbebb9ee68da0e22895887b6b"}, "originalPosition": 72}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjkxODY5OQ==", "bodyText": "make these final", "url": "https://github.com/openhab/openhab-addons/pull/7509#discussion_r436918699", "createdAt": "2020-06-08T18:46:50Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.lcn/src/main/java/org/openhab/binding/lcn/internal/common/DimmerOutputCommand.java", "diffHunk": "@@ -0,0 +1,65 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.lcn.internal.common;\n+\n+import java.math.BigDecimal;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+\n+/**\n+ * Holds the information to control dimmer outputs of an LCN module. Used when the user configured an \"output\" profile.\n+ *\n+ * @author Fabian Wolter - Initial Contribution\n+ */\n+@NonNullByDefault\n+public class DimmerOutputCommand extends PercentType {\n+    private static final long serialVersionUID = 8147502412107723798L;\n+    private boolean controlAllOutputs;\n+    private boolean controlOutputs12;\n+    private int rampMs;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ce02f433e5d4071dbebb9ee68da0e22895887b6b"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjkyMDc0Mg==", "bodyText": "Would it be possible to allow the results to be null so you don't have to call new Object() for your get methods?\nWould something like this work?\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             */\n          \n          \n            \n            @NonNullByDefault\n          \n          \n            \n            public class NullScheduledFuture implements ScheduledFuture<Object> {\n          \n          \n            \n             */\n          \n          \n            \n            @NonNullByDefault\n          \n          \n            \n            public class NullScheduledFuture implements ScheduledFuture<@Nullable Object> {\n          \n      \n    \n    \n  \n\nThen you should be able to return null instead of creating a new object.\nI'm not sure if this would cause issues with the existing code that uses this but I suspect it should be fine since you mostly use wildcards in your fields.", "url": "https://github.com/openhab/openhab-addons/pull/7509#discussion_r436920742", "createdAt": "2020-06-08T18:50:37Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.lcn/src/main/java/org/openhab/binding/lcn/internal/common/NullScheduledFuture.java", "diffHunk": "@@ -0,0 +1,80 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.lcn.internal.common;\n+\n+import java.util.concurrent.Delayed;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+\n+/**\n+ * Empty ScheduledFuture, used for initialization.\n+ *\n+ * @author Fabian Wolter - Initial Contribution\n+ */\n+@NonNullByDefault\n+public class NullScheduledFuture implements ScheduledFuture<Object> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ce02f433e5d4071dbebb9ee68da0e22895887b6b"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjkyMjc2OQ==", "bodyText": "I don't think there is much benefit to do lazy initialization here. I suggest keeping it simple.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                @NonNullByDefault({})\n          \n          \n            \n                private static class LazyHolder {\n          \n          \n            \n                    static final NullScheduledFuture INSTANCE = new NullScheduledFuture();\n          \n          \n            \n                }\n          \n          \n            \n            \n          \n          \n            \n                private NullScheduledFuture() {\n          \n          \n            \n                    // nothing\n          \n          \n            \n                }\n          \n          \n            \n            \n          \n          \n            \n                /** Gets the instance of this singleton. */\n          \n          \n            \n                public static NullScheduledFuture getInstance() {\n          \n          \n            \n                    return LazyHolder.INSTANCE;\n          \n          \n            \n                }\n          \n          \n            \n                \n          \n          \n            \n                /** Gets the instance of this singleton. */\n          \n          \n            \n                public static final NullScheduledFuture INSTANCE = new NullScheduledFuture();\n          \n          \n            \n            \n          \n          \n            \n                private NullScheduledFuture() {\n          \n          \n            \n                    // nothing\n          \n          \n            \n                }", "url": "https://github.com/openhab/openhab-addons/pull/7509#discussion_r436922769", "createdAt": "2020-06-08T18:54:23Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.lcn/src/main/java/org/openhab/binding/lcn/internal/common/NullScheduledFuture.java", "diffHunk": "@@ -0,0 +1,80 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.lcn.internal.common;\n+\n+import java.util.concurrent.Delayed;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+\n+/**\n+ * Empty ScheduledFuture, used for initialization.\n+ *\n+ * @author Fabian Wolter - Initial Contribution\n+ */\n+@NonNullByDefault\n+public class NullScheduledFuture implements ScheduledFuture<Object> {\n+    @NonNullByDefault({})\n+    private static class LazyHolder {\n+        static final NullScheduledFuture INSTANCE = new NullScheduledFuture();\n+    }\n+\n+    private NullScheduledFuture() {\n+        // nothing\n+    }\n+\n+    /** Gets the instance of this singleton. */\n+    public static NullScheduledFuture getInstance() {\n+        return LazyHolder.INSTANCE;\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ce02f433e5d4071dbebb9ee68da0e22895887b6b"}, "originalPosition": 43}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjkyNDUzMQ==", "bodyText": "Are you sure you want to exit here instead of capping the percent value?", "url": "https://github.com/openhab/openhab-addons/pull/7509#discussion_r436924531", "createdAt": "2020-06-08T18:57:46Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.lcn/src/main/java/org/openhab/binding/lcn/internal/subhandler/LcnModuleOutputSubHandler.java", "diffHunk": "@@ -0,0 +1,185 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.lcn.internal.subhandler;\n+\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.smarthome.core.library.types.HSBType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.library.types.UpDownType;\n+import org.openhab.binding.lcn.internal.LcnBindingConstants;\n+import org.openhab.binding.lcn.internal.LcnModuleHandler;\n+import org.openhab.binding.lcn.internal.common.DimmerOutputCommand;\n+import org.openhab.binding.lcn.internal.common.LcnChannelGroup;\n+import org.openhab.binding.lcn.internal.common.LcnDefs;\n+import org.openhab.binding.lcn.internal.common.LcnException;\n+import org.openhab.binding.lcn.internal.common.PckGenerator;\n+import org.openhab.binding.lcn.internal.connection.ModInfo;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Handles Commands and State changes of dimmer outputs of an LCN module.\n+ *\n+ * @author Fabian Wolter - Initial contribution\n+ */\n+@NonNullByDefault\n+public class LcnModuleOutputSubHandler extends AbstractLcnModuleSubHandler {\n+    private final Logger logger = LoggerFactory.getLogger(LcnModuleOutputSubHandler.class);\n+    private static final int COLOR_RAMP_MS = 1000;\n+    private static final String OUTPUT_COLOR = \"color\";\n+    private static final Pattern PERCENT_PATTERN;\n+    private static final Pattern NATIVE_PATTERN;\n+    private volatile HSBType currentColor = new HSBType();\n+    private volatile PercentType output4 = new PercentType();\n+\n+    public LcnModuleOutputSubHandler(LcnModuleHandler handler, ModInfo info) {\n+        super(handler, info);\n+    }\n+\n+    static {\n+        PERCENT_PATTERN = Pattern.compile(LcnBindingConstants.ADDRESS_REGEX + \"A(?<outputId>\\\\d)(?<percent>\\\\d+)\");\n+        NATIVE_PATTERN = Pattern.compile(LcnBindingConstants.ADDRESS_REGEX + \"O(?<outputId>\\\\d)(?<value>\\\\d+)\");\n+    }\n+\n+    @Override\n+    public Collection<Pattern> getPckStatusMessagePatterns() {\n+        return Arrays.asList(NATIVE_PATTERN, PERCENT_PATTERN);\n+    }\n+\n+    @Override\n+    public void handleRefresh(LcnChannelGroup channelGroup, int number) {\n+        info.refreshOutput(number);\n+    }\n+\n+    @Override\n+    public void handleRefresh(String groupId) {\n+        if (OUTPUT_COLOR.equals(groupId)) {\n+            info.refreshAllOutputs();\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommandOnOff(OnOffType command, LcnChannelGroup channelGroup, int number) throws LcnException {\n+        // don't use OnOffType.as() here, because it returns @Nullable\n+        handler.sendPck(PckGenerator.dimOutput(number, command == OnOffType.ON ? 100 : 0, 0));\n+    }\n+\n+    @Override\n+    public void handleCommandPercent(PercentType command, LcnChannelGroup channelGroup, int number)\n+            throws LcnException {\n+        handler.sendPck(PckGenerator.dimOutput(number, command.doubleValue(), 0));\n+    }\n+\n+    @Override\n+    public void handleCommandPercent(PercentType command, LcnChannelGroup channelGroup, String idWithoutGroup)\n+            throws LcnException {\n+        if (!OUTPUT_COLOR.equals(idWithoutGroup)) {\n+            throw new LcnException(\"Unknown group ID: \" + idWithoutGroup);\n+        }\n+        updateAndSendColor(new HSBType(currentColor.getHue(), currentColor.getSaturation(), command));\n+    }\n+\n+    @Override\n+    public void handleCommandHsb(HSBType command, String groupId) throws LcnException {\n+        if (!OUTPUT_COLOR.equals(groupId)) {\n+            throw new LcnException(\"Unknown group ID: \" + groupId);\n+        }\n+        updateAndSendColor(command);\n+    }\n+\n+    private synchronized void updateAndSendColor(HSBType hsbType) throws LcnException {\n+        currentColor = hsbType;\n+        handler.updateChannel(LcnChannelGroup.OUTPUT, OUTPUT_COLOR, currentColor);\n+\n+        if (info.getFirmwareVersion() >= LcnBindingConstants.FIRMWARE_2014) {\n+            handler.sendPck(PckGenerator.dimAllOutputs(currentColor.getRed().doubleValue(),\n+                    currentColor.getGreen().doubleValue(), currentColor.getBlue().doubleValue(), output4.doubleValue(),\n+                    COLOR_RAMP_MS));\n+        } else {\n+            handler.sendPck(PckGenerator.dimOutput(0, currentColor.getRed().doubleValue(), COLOR_RAMP_MS));\n+            handler.sendPck(PckGenerator.dimOutput(1, currentColor.getGreen().doubleValue(), COLOR_RAMP_MS));\n+            handler.sendPck(PckGenerator.dimOutput(2, currentColor.getBlue().doubleValue(), COLOR_RAMP_MS));\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommandDimmerOutput(DimmerOutputCommand command, int number) throws LcnException {\n+        int rampMs = command.getRampMs();\n+        if (command.isControlAllOutputs()) { // control all dimmer outputs\n+            if (rampMs == LcnDefs.FIXED_RAMP_MS) {\n+                // compatibility command\n+                handler.sendPck(PckGenerator.controlAllOutputs(command.intValue()));\n+            } else {\n+                // command since firmware 180501\n+                handler.sendPck(PckGenerator.dimAllOutputs(command.doubleValue(), command.doubleValue(),\n+                        command.doubleValue(), command.doubleValue(), rampMs));\n+            }\n+        } else if (command.isControlOutputs12()) { // control dimmer outputs 1+2\n+            if (command.intValue() == 0 || command.intValue() == 100) {\n+                handler.sendPck(PckGenerator.controlOutputs12(command.intValue() > 0, rampMs >= LcnDefs.FIXED_RAMP_MS));\n+            } else {\n+                // ignore ramp when dimming\n+                handler.sendPck(PckGenerator.dimOutputs12(command.doubleValue()));\n+            }\n+        } else {\n+            handler.sendPck(PckGenerator.dimOutput(number, command.doubleValue(), rampMs));\n+        }\n+    }\n+\n+    @Override\n+    public void handleStatusMessage(Matcher matcher) {\n+        int outputId = Integer.parseInt(matcher.group(\"outputId\")) - 1;\n+\n+        if (!LcnChannelGroup.OUTPUT.isValidId(outputId)) {\n+            logger.warn(\"outputId out of range: {}\", outputId);\n+            return;\n+        }\n+        double percent;\n+        if (matcher.pattern() == PERCENT_PATTERN) {\n+            percent = Integer.parseInt(matcher.group(\"percent\"));\n+        } else if (matcher.pattern() == NATIVE_PATTERN) {\n+            percent = (double) Integer.parseInt(matcher.group(\"value\")) / 2;\n+        } else {\n+            logger.warn(\"Unexpected pattern: {}\", matcher.pattern());\n+            return;\n+        }\n+        if (percent < 0 || percent > 100) {\n+            logger.warn(\"Output value out of range: {}\", percent);\n+            return;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ce02f433e5d4071dbebb9ee68da0e22895887b6b"}, "originalPosition": 164}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjkyNTgwOQ==", "bodyText": "This synchronization doesn't do anything.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        synchronized (this) {\n          \n          \n            \n                            output4 = percentType;\n          \n          \n            \n                        }\n          \n          \n            \n                        output4 = percentType;", "url": "https://github.com/openhab/openhab-addons/pull/7509#discussion_r436925809", "createdAt": "2020-06-08T19:00:09Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.lcn/src/main/java/org/openhab/binding/lcn/internal/subhandler/LcnModuleOutputSubHandler.java", "diffHunk": "@@ -0,0 +1,185 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.lcn.internal.subhandler;\n+\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.smarthome.core.library.types.HSBType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.library.types.UpDownType;\n+import org.openhab.binding.lcn.internal.LcnBindingConstants;\n+import org.openhab.binding.lcn.internal.LcnModuleHandler;\n+import org.openhab.binding.lcn.internal.common.DimmerOutputCommand;\n+import org.openhab.binding.lcn.internal.common.LcnChannelGroup;\n+import org.openhab.binding.lcn.internal.common.LcnDefs;\n+import org.openhab.binding.lcn.internal.common.LcnException;\n+import org.openhab.binding.lcn.internal.common.PckGenerator;\n+import org.openhab.binding.lcn.internal.connection.ModInfo;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Handles Commands and State changes of dimmer outputs of an LCN module.\n+ *\n+ * @author Fabian Wolter - Initial contribution\n+ */\n+@NonNullByDefault\n+public class LcnModuleOutputSubHandler extends AbstractLcnModuleSubHandler {\n+    private final Logger logger = LoggerFactory.getLogger(LcnModuleOutputSubHandler.class);\n+    private static final int COLOR_RAMP_MS = 1000;\n+    private static final String OUTPUT_COLOR = \"color\";\n+    private static final Pattern PERCENT_PATTERN;\n+    private static final Pattern NATIVE_PATTERN;\n+    private volatile HSBType currentColor = new HSBType();\n+    private volatile PercentType output4 = new PercentType();\n+\n+    public LcnModuleOutputSubHandler(LcnModuleHandler handler, ModInfo info) {\n+        super(handler, info);\n+    }\n+\n+    static {\n+        PERCENT_PATTERN = Pattern.compile(LcnBindingConstants.ADDRESS_REGEX + \"A(?<outputId>\\\\d)(?<percent>\\\\d+)\");\n+        NATIVE_PATTERN = Pattern.compile(LcnBindingConstants.ADDRESS_REGEX + \"O(?<outputId>\\\\d)(?<value>\\\\d+)\");\n+    }\n+\n+    @Override\n+    public Collection<Pattern> getPckStatusMessagePatterns() {\n+        return Arrays.asList(NATIVE_PATTERN, PERCENT_PATTERN);\n+    }\n+\n+    @Override\n+    public void handleRefresh(LcnChannelGroup channelGroup, int number) {\n+        info.refreshOutput(number);\n+    }\n+\n+    @Override\n+    public void handleRefresh(String groupId) {\n+        if (OUTPUT_COLOR.equals(groupId)) {\n+            info.refreshAllOutputs();\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommandOnOff(OnOffType command, LcnChannelGroup channelGroup, int number) throws LcnException {\n+        // don't use OnOffType.as() here, because it returns @Nullable\n+        handler.sendPck(PckGenerator.dimOutput(number, command == OnOffType.ON ? 100 : 0, 0));\n+    }\n+\n+    @Override\n+    public void handleCommandPercent(PercentType command, LcnChannelGroup channelGroup, int number)\n+            throws LcnException {\n+        handler.sendPck(PckGenerator.dimOutput(number, command.doubleValue(), 0));\n+    }\n+\n+    @Override\n+    public void handleCommandPercent(PercentType command, LcnChannelGroup channelGroup, String idWithoutGroup)\n+            throws LcnException {\n+        if (!OUTPUT_COLOR.equals(idWithoutGroup)) {\n+            throw new LcnException(\"Unknown group ID: \" + idWithoutGroup);\n+        }\n+        updateAndSendColor(new HSBType(currentColor.getHue(), currentColor.getSaturation(), command));\n+    }\n+\n+    @Override\n+    public void handleCommandHsb(HSBType command, String groupId) throws LcnException {\n+        if (!OUTPUT_COLOR.equals(groupId)) {\n+            throw new LcnException(\"Unknown group ID: \" + groupId);\n+        }\n+        updateAndSendColor(command);\n+    }\n+\n+    private synchronized void updateAndSendColor(HSBType hsbType) throws LcnException {\n+        currentColor = hsbType;\n+        handler.updateChannel(LcnChannelGroup.OUTPUT, OUTPUT_COLOR, currentColor);\n+\n+        if (info.getFirmwareVersion() >= LcnBindingConstants.FIRMWARE_2014) {\n+            handler.sendPck(PckGenerator.dimAllOutputs(currentColor.getRed().doubleValue(),\n+                    currentColor.getGreen().doubleValue(), currentColor.getBlue().doubleValue(), output4.doubleValue(),\n+                    COLOR_RAMP_MS));\n+        } else {\n+            handler.sendPck(PckGenerator.dimOutput(0, currentColor.getRed().doubleValue(), COLOR_RAMP_MS));\n+            handler.sendPck(PckGenerator.dimOutput(1, currentColor.getGreen().doubleValue(), COLOR_RAMP_MS));\n+            handler.sendPck(PckGenerator.dimOutput(2, currentColor.getBlue().doubleValue(), COLOR_RAMP_MS));\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommandDimmerOutput(DimmerOutputCommand command, int number) throws LcnException {\n+        int rampMs = command.getRampMs();\n+        if (command.isControlAllOutputs()) { // control all dimmer outputs\n+            if (rampMs == LcnDefs.FIXED_RAMP_MS) {\n+                // compatibility command\n+                handler.sendPck(PckGenerator.controlAllOutputs(command.intValue()));\n+            } else {\n+                // command since firmware 180501\n+                handler.sendPck(PckGenerator.dimAllOutputs(command.doubleValue(), command.doubleValue(),\n+                        command.doubleValue(), command.doubleValue(), rampMs));\n+            }\n+        } else if (command.isControlOutputs12()) { // control dimmer outputs 1+2\n+            if (command.intValue() == 0 || command.intValue() == 100) {\n+                handler.sendPck(PckGenerator.controlOutputs12(command.intValue() > 0, rampMs >= LcnDefs.FIXED_RAMP_MS));\n+            } else {\n+                // ignore ramp when dimming\n+                handler.sendPck(PckGenerator.dimOutputs12(command.doubleValue()));\n+            }\n+        } else {\n+            handler.sendPck(PckGenerator.dimOutput(number, command.doubleValue(), rampMs));\n+        }\n+    }\n+\n+    @Override\n+    public void handleStatusMessage(Matcher matcher) {\n+        int outputId = Integer.parseInt(matcher.group(\"outputId\")) - 1;\n+\n+        if (!LcnChannelGroup.OUTPUT.isValidId(outputId)) {\n+            logger.warn(\"outputId out of range: {}\", outputId);\n+            return;\n+        }\n+        double percent;\n+        if (matcher.pattern() == PERCENT_PATTERN) {\n+            percent = Integer.parseInt(matcher.group(\"percent\"));\n+        } else if (matcher.pattern() == NATIVE_PATTERN) {\n+            percent = (double) Integer.parseInt(matcher.group(\"value\")) / 2;\n+        } else {\n+            logger.warn(\"Unexpected pattern: {}\", matcher.pattern());\n+            return;\n+        }\n+        if (percent < 0 || percent > 100) {\n+            logger.warn(\"Output value out of range: {}\", percent);\n+            return;\n+        }\n+        info.onOutputResponseReceived(outputId);\n+\n+        PercentType percentType = new PercentType((int) Math.round(percent));\n+        fireUpdate(LcnChannelGroup.OUTPUT, outputId, percentType);\n+\n+        if (outputId == 3) {\n+            synchronized (this) {\n+                output4 = percentType;\n+            }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ce02f433e5d4071dbebb9ee68da0e22895887b6b"}, "originalPosition": 174}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjkzMjY0OA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            fireUpdateAndReset(matcher, groupSuffix.orElse(i + \"\"), Variable.thrsIdToVar(registerNumber, i));\n          \n          \n            \n                            fireUpdateAndReset(matcher, groupSuffix.orElse(String.valueOf(i)), Variable.thrsIdToVar(registerNumber, i));", "url": "https://github.com/openhab/openhab-addons/pull/7509#discussion_r436932648", "createdAt": "2020-06-08T19:08:05Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.lcn/src/main/java/org/openhab/binding/lcn/internal/subhandler/LcnModuleThresholdSubHandler.java", "diffHunk": "@@ -0,0 +1,104 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.lcn.internal.subhandler;\n+\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Optional;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.IntStream;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.openhab.binding.lcn.internal.LcnBindingConstants;\n+import org.openhab.binding.lcn.internal.LcnModuleHandler;\n+import org.openhab.binding.lcn.internal.common.LcnChannelGroup;\n+import org.openhab.binding.lcn.internal.common.LcnDefs;\n+import org.openhab.binding.lcn.internal.common.LcnException;\n+import org.openhab.binding.lcn.internal.common.PckGenerator;\n+import org.openhab.binding.lcn.internal.common.Variable;\n+import org.openhab.binding.lcn.internal.connection.ModInfo;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Handles Commands and State changes of thresholds of an LCN module.\n+ *\n+ * @author Fabian Wolter - Initial contribution\n+ */\n+@NonNullByDefault\n+public class LcnModuleThresholdSubHandler extends AbstractLcnModuleVariableSubHandler {\n+    private final Logger logger = LoggerFactory.getLogger(LcnModuleThresholdSubHandler.class);\n+    private static final Pattern PATTERN = Pattern\n+            .compile(LcnBindingConstants.ADDRESS_REGEX + \"\\\\.T(?<registerId>\\\\d)(?<thresholdId>\\\\d)(?<value>\\\\d+)\");\n+    private static final Pattern PATTERN_BEFORE_2013 = Pattern.compile(LcnBindingConstants.ADDRESS_REGEX\n+            + \"\\\\.S1(?<value0>\\\\d{5})(?<value1>\\\\d{5})(?<value2>\\\\d{5})(?<value3>\\\\d{5})(?<value4>\\\\d{5})(?<hyst>\\\\d{5})\");\n+\n+    public LcnModuleThresholdSubHandler(LcnModuleHandler handler, ModInfo info) {\n+        super(handler, info);\n+    }\n+\n+    @Override\n+    public void handleCommandDecimal(DecimalType command, LcnChannelGroup channelGroup, int number)\n+            throws LcnException {\n+        Variable variable = getVariable(channelGroup, number);\n+        try {\n+            int relativeChange = getRelativeChange(command, variable);\n+            handler.sendPck(PckGenerator.setThresholdRelative(variable, LcnDefs.RelVarRef.CURRENT, relativeChange,\n+                    info.hasExtendedMeasurementProcessing()));\n+\n+            // request new value, if the module doesn't send it on itself\n+            if (variable.shouldPollStatusAfterCommand(info.getFirmwareVersion())) {\n+                info.refreshVariable(variable);\n+            }\n+        } catch (LcnException e) {\n+            // current value unknown for some reason, refresh it in case we come again here\n+            info.refreshVariable(variable);\n+            throw e;\n+        }\n+    }\n+\n+    @Override\n+    public void handleStatusMessage(Matcher matcher) {\n+        IntStream stream;\n+        Optional<String> groupSuffix;\n+        int registerNumber;\n+        if (matcher.pattern() == PATTERN) {\n+            int thresholdId = Integer.parseInt(matcher.group(\"thresholdId\")) - 1;\n+            registerNumber = Integer.parseInt(matcher.group(\"registerId\")) - 1;\n+            stream = IntStream.rangeClosed(thresholdId, thresholdId);\n+            groupSuffix = Optional.of(\"\");\n+        } else if (matcher.pattern() == PATTERN_BEFORE_2013) {\n+            stream = IntStream.range(0, LcnDefs.THRESHOLD_COUNT_BEFORE_2013);\n+            groupSuffix = Optional.empty();\n+            registerNumber = 0;\n+        } else {\n+            logger.warn(\"Unexpected pattern: {}\", matcher.pattern());\n+            return;\n+        }\n+\n+        stream.forEach(i -> {\n+            try {\n+                fireUpdateAndReset(matcher, groupSuffix.orElse(i + \"\"), Variable.thrsIdToVar(registerNumber, i));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ce02f433e5d4071dbebb9ee68da0e22895887b6b"}, "originalPosition": 93}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjk0NTUwOA==", "bodyText": "You should also give a clue as to which AbstractLcnModuleSubHandler subclass this is since there isn't anyway for the user to know which handler this error refers to at the moment.", "url": "https://github.com/openhab/openhab-addons/pull/7509#discussion_r436945508", "createdAt": "2020-06-08T19:20:29Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.lcn/src/main/java/org/openhab/binding/lcn/internal/subhandler/AbstractLcnModuleSubHandler.java", "diffHunk": "@@ -0,0 +1,178 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.lcn.internal.subhandler;\n+\n+import java.util.Arrays;\n+import java.util.Optional;\n+import java.util.regex.Matcher;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.HSBType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.library.types.StopMoveType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.library.types.UpDownType;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.lcn.internal.LcnModuleHandler;\n+import org.openhab.binding.lcn.internal.common.DimmerOutputCommand;\n+import org.openhab.binding.lcn.internal.common.LcnChannelGroup;\n+import org.openhab.binding.lcn.internal.common.LcnDefs;\n+import org.openhab.binding.lcn.internal.common.LcnDefs.RelayStateModifier;\n+import org.openhab.binding.lcn.internal.common.LcnException;\n+import org.openhab.binding.lcn.internal.common.Variable;\n+import org.openhab.binding.lcn.internal.common.VariableValue;\n+import org.openhab.binding.lcn.internal.connection.ModInfo;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Base class for LCN module Thing sub handlers.\n+ *\n+ * @author Fabian Wolter - Initial contribution\n+ */\n+@NonNullByDefault\n+public abstract class AbstractLcnModuleSubHandler implements ILcnModuleSubHandler {\n+    private final Logger logger = LoggerFactory.getLogger(AbstractLcnModuleSubHandler.class);\n+    protected LcnModuleHandler handler;\n+    protected ModInfo info;\n+\n+    public AbstractLcnModuleSubHandler(LcnModuleHandler handler, ModInfo info) {\n+        this.handler = handler;\n+        this.info = info;\n+    }\n+\n+    @Override\n+    public void handleRefresh(String groupId) {\n+        // can be overwritten by subclasses.\n+    }\n+\n+    @Override\n+    public void handleCommandOnOff(OnOffType command, LcnChannelGroup channelGroup, int number) throws LcnException {\n+        unsupportedCommand(command);\n+    }\n+\n+    @Override\n+    public void handleCommandPercent(PercentType command, LcnChannelGroup channelGroup, int number)\n+            throws LcnException {\n+        unsupportedCommand(command);\n+    }\n+\n+    @Override\n+    public void handleCommandPercent(PercentType command, LcnChannelGroup channelGroup, String idWithoutGroup)\n+            throws LcnException {\n+        unsupportedCommand(command);\n+    }\n+\n+    @Override\n+    public void handleCommandDecimal(DecimalType command, LcnChannelGroup channelGroup, int number)\n+            throws LcnException {\n+        unsupportedCommand(command);\n+    }\n+\n+    @Override\n+    public void handleCommandDimmerOutput(DimmerOutputCommand command, int number) throws LcnException {\n+        unsupportedCommand(command);\n+    }\n+\n+    @Override\n+    public void handleCommandString(StringType command, int number) throws LcnException {\n+        unsupportedCommand(command);\n+    }\n+\n+    @Override\n+    public void handleCommandUpDown(UpDownType command, LcnChannelGroup channelGroup, int number) throws LcnException {\n+        unsupportedCommand(command);\n+    }\n+\n+    @Override\n+    public void handleCommandStopMove(StopMoveType command, LcnChannelGroup channelGroup, int number)\n+            throws LcnException {\n+        unsupportedCommand(command);\n+    }\n+\n+    @Override\n+    public void handleCommandHsb(HSBType command, String groupId) throws LcnException {\n+        unsupportedCommand(command);\n+    }\n+\n+    private void unsupportedCommand(Command command) {\n+        logger.warn(\"Unsupported command: {}\", command.getClass().getSimpleName());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ce02f433e5d4071dbebb9ee68da0e22895887b6b"}, "originalPosition": 112}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjk0NTc2Mg==", "bodyText": "Can you make these final?", "url": "https://github.com/openhab/openhab-addons/pull/7509#discussion_r436945762", "createdAt": "2020-06-08T19:20:58Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.lcn/src/main/java/org/openhab/binding/lcn/internal/subhandler/AbstractLcnModuleSubHandler.java", "diffHunk": "@@ -0,0 +1,178 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.lcn.internal.subhandler;\n+\n+import java.util.Arrays;\n+import java.util.Optional;\n+import java.util.regex.Matcher;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.HSBType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.library.types.StopMoveType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.library.types.UpDownType;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.lcn.internal.LcnModuleHandler;\n+import org.openhab.binding.lcn.internal.common.DimmerOutputCommand;\n+import org.openhab.binding.lcn.internal.common.LcnChannelGroup;\n+import org.openhab.binding.lcn.internal.common.LcnDefs;\n+import org.openhab.binding.lcn.internal.common.LcnDefs.RelayStateModifier;\n+import org.openhab.binding.lcn.internal.common.LcnException;\n+import org.openhab.binding.lcn.internal.common.Variable;\n+import org.openhab.binding.lcn.internal.common.VariableValue;\n+import org.openhab.binding.lcn.internal.connection.ModInfo;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Base class for LCN module Thing sub handlers.\n+ *\n+ * @author Fabian Wolter - Initial contribution\n+ */\n+@NonNullByDefault\n+public abstract class AbstractLcnModuleSubHandler implements ILcnModuleSubHandler {\n+    private final Logger logger = LoggerFactory.getLogger(AbstractLcnModuleSubHandler.class);\n+    protected LcnModuleHandler handler;\n+    protected ModInfo info;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ce02f433e5d4071dbebb9ee68da0e22895887b6b"}, "originalPosition": 50}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjk0NjcwNg==", "bodyText": "Can you make these final?", "url": "https://github.com/openhab/openhab-addons/pull/7509#discussion_r436946706", "createdAt": "2020-06-08T19:22:49Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.lcn/src/main/java/org/openhab/binding/lcn/internal/connection/StateMachine.java", "diffHunk": "@@ -0,0 +1,109 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.lcn.internal.connection;\n+\n+import java.lang.reflect.InvocationTargetException;\n+import java.nio.ByteBuffer;\n+import java.util.concurrent.ScheduledExecutorService;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.lcn.internal.common.LcnAddr;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Implements a state machine for managing the connection to the LCN-PCK gateway. Setting states is thread-safe.\n+ *\n+ * @author Fabian Wolter - Initial Contribution\n+ */\n+@NonNullByDefault\n+public class StateMachine implements StateContext {\n+    private final Logger logger = LoggerFactory.getLogger(StateMachine.class);\n+    /** The StateMachine's current state */\n+    protected volatile AbstractConnectionState state;\n+    private Connection connection;\n+    private ScheduledExecutorService scheduler;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ce02f433e5d4071dbebb9ee68da0e22895887b6b"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjk0OTg2OA==", "bodyText": "Since this is supposed to be a fixed sized list, perhaps an array would be more appropriate.", "url": "https://github.com/openhab/openhab-addons/pull/7509#discussion_r436949868", "createdAt": "2020-06-08T19:28:35Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.lcn/src/main/java/org/openhab/binding/lcn/internal/connection/ModInfo.java", "diffHunk": "@@ -0,0 +1,500 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.lcn.internal.connection;\n+\n+import java.io.UnsupportedEncodingException;\n+import java.nio.ByteBuffer;\n+import java.util.ArrayList;\n+import java.util.LinkedList;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.TreeMap;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.lcn.internal.LcnBindingConstants;\n+import org.openhab.binding.lcn.internal.common.LcnAddrMod;\n+import org.openhab.binding.lcn.internal.common.LcnChannelGroup;\n+import org.openhab.binding.lcn.internal.common.LcnDefs;\n+import org.openhab.binding.lcn.internal.common.LcnException;\n+import org.openhab.binding.lcn.internal.common.PckGenerator;\n+import org.openhab.binding.lcn.internal.common.Variable;\n+import org.openhab.binding.lcn.internal.common.VariableValue;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Holds data of an LCN module.\n+ * <ul>\n+ * <li>Stores the module's firmware version (if requested)\n+ * <li>Manages the scheduling of status-requests\n+ * <li>Manages the scheduling of acknowledged commands\n+ * </ul>\n+ *\n+ * @author Tobias J\u00fcttner - Initial Contribution\n+ * @author Fabian Wolter - Migration to OH2\n+ */\n+@NonNullByDefault\n+public class ModInfo {\n+    private final Logger logger = LoggerFactory.getLogger(ModInfo.class);\n+    /** Total number of request to sent before going into failed-state. */\n+    private static final int NUM_TRIES = 3;\n+\n+    /** Poll interval for status values that automatically send their values on change. */\n+    private static final int MAX_STATUS_EVENTBASED_VALUEAGE_MSEC = 600000;\n+\n+    /** Poll interval for status values that do not send their values on change (always polled). */\n+    private static final int MAX_STATUS_POLLED_VALUEAGE_MSEC = 30000;\n+\n+    /** Status request delay after a command has been send which potentially changed that status. */\n+    private static final int STATUS_REQUEST_DELAY_AFTER_COMMAND_MSEC = 2000;\n+\n+    /** The LCN module's address. */\n+    private final LcnAddrMod addr;\n+\n+    /** Firmware date of the LCN module. -1 means \"unknown\". */\n+    private int firmwareVersion = -1;\n+\n+    /** Firmware version request status. */\n+    private final RequestStatus requestFirmwareVersion = new RequestStatus(-1, NUM_TRIES, \"Firmware Version\");\n+\n+    /** Output-port request status (0..3). */\n+    private final ArrayList<RequestStatus> requestStatusOutputs = new ArrayList<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ce02f433e5d4071dbebb9ee68da0e22895887b6b"}, "originalPosition": 72}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjk1MDgwMg==", "bodyText": "I suggest turning this into a utility function since it gets used so much.", "url": "https://github.com/openhab/openhab-addons/pull/7509#discussion_r436950802", "createdAt": "2020-06-08T19:30:16Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.lcn/src/main/java/org/openhab/binding/lcn/internal/connection/ModInfo.java", "diffHunk": "@@ -0,0 +1,500 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.lcn.internal.connection;\n+\n+import java.io.UnsupportedEncodingException;\n+import java.nio.ByteBuffer;\n+import java.util.ArrayList;\n+import java.util.LinkedList;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.TreeMap;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.lcn.internal.LcnBindingConstants;\n+import org.openhab.binding.lcn.internal.common.LcnAddrMod;\n+import org.openhab.binding.lcn.internal.common.LcnChannelGroup;\n+import org.openhab.binding.lcn.internal.common.LcnDefs;\n+import org.openhab.binding.lcn.internal.common.LcnException;\n+import org.openhab.binding.lcn.internal.common.PckGenerator;\n+import org.openhab.binding.lcn.internal.common.Variable;\n+import org.openhab.binding.lcn.internal.common.VariableValue;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Holds data of an LCN module.\n+ * <ul>\n+ * <li>Stores the module's firmware version (if requested)\n+ * <li>Manages the scheduling of status-requests\n+ * <li>Manages the scheduling of acknowledged commands\n+ * </ul>\n+ *\n+ * @author Tobias J\u00fcttner - Initial Contribution\n+ * @author Fabian Wolter - Migration to OH2\n+ */\n+@NonNullByDefault\n+public class ModInfo {\n+    private final Logger logger = LoggerFactory.getLogger(ModInfo.class);\n+    /** Total number of request to sent before going into failed-state. */\n+    private static final int NUM_TRIES = 3;\n+\n+    /** Poll interval for status values that automatically send their values on change. */\n+    private static final int MAX_STATUS_EVENTBASED_VALUEAGE_MSEC = 600000;\n+\n+    /** Poll interval for status values that do not send their values on change (always polled). */\n+    private static final int MAX_STATUS_POLLED_VALUEAGE_MSEC = 30000;\n+\n+    /** Status request delay after a command has been send which potentially changed that status. */\n+    private static final int STATUS_REQUEST_DELAY_AFTER_COMMAND_MSEC = 2000;\n+\n+    /** The LCN module's address. */\n+    private final LcnAddrMod addr;\n+\n+    /** Firmware date of the LCN module. -1 means \"unknown\". */\n+    private int firmwareVersion = -1;\n+\n+    /** Firmware version request status. */\n+    private final RequestStatus requestFirmwareVersion = new RequestStatus(-1, NUM_TRIES, \"Firmware Version\");\n+\n+    /** Output-port request status (0..3). */\n+    private final ArrayList<RequestStatus> requestStatusOutputs = new ArrayList<>();\n+\n+    /** Relays request status (all 8). */\n+    private final RequestStatus requestStatusRelays = new RequestStatus(MAX_STATUS_EVENTBASED_VALUEAGE_MSEC, NUM_TRIES,\n+            \"Relays\");\n+\n+    /** Binary-sensors request status (all 8). */\n+    private final RequestStatus requestStatusBinSensors = new RequestStatus(MAX_STATUS_EVENTBASED_VALUEAGE_MSEC,\n+            NUM_TRIES, \"Binary Sensors\");\n+\n+    /**\n+     * Variables request status.\n+     * Lazy initialization: Will be filled once the firmware version is known.\n+     */\n+    private final Map<Variable, RequestStatus> requestStatusVars = new TreeMap<>();\n+\n+    /**\n+     * Caches the values of the variables, needed for changing the values.\n+     */\n+    private final Map<Variable, VariableValue> variableValue = new TreeMap<>();\n+\n+    /** LEDs and logic-operations request status (all 12+4). */\n+    private final RequestStatus requestStatusLedsAndLogicOps = new RequestStatus(MAX_STATUS_POLLED_VALUEAGE_MSEC,\n+            NUM_TRIES, \"LEDs and Logic\");\n+\n+    /** Key lock-states request status (all tables, A-D). */\n+    private final RequestStatus requestStatusLockedKeys = new RequestStatus(MAX_STATUS_POLLED_VALUEAGE_MSEC, NUM_TRIES,\n+            \"Key Locks\");\n+\n+    /**\n+     * Holds the last LCN variable requested whose response will not contain the variable's type.\n+     * {@link Variable#UNKNOWN} means there is currently no such request.\n+     */\n+    private Variable lastRequestedVarWithoutTypeInResponse = Variable.UNKNOWN;\n+\n+    /**\n+     * List of queued PCK commands to be acknowledged by the LCN module.\n+     * Commands are always without address header.\n+     * Note that the first one might currently be \"in progress\".\n+     */\n+    private final LinkedList<@Nullable ByteBuffer> pckCommandsWithAck = new LinkedList<>();\n+\n+    /** Status data for the currently processed {@link PckCommandWithAck}. */\n+    private final RequestStatus requestCurrentPckCommandWithAck = new RequestStatus(-1, NUM_TRIES, \"Commands with Ack\");\n+\n+    /**\n+     * Constructor.\n+     *\n+     * @param addr the module's address\n+     */\n+    public ModInfo(LcnAddrMod addr) {\n+        this.addr = addr;\n+        for (int i = 0; i < LcnChannelGroup.OUTPUT.getCount(); ++i) {\n+            this.requestStatusOutputs\n+                    .add(new RequestStatus(MAX_STATUS_EVENTBASED_VALUEAGE_MSEC, NUM_TRIES, \"Output \" + (i + 1)));\n+        }\n+\n+        for (Variable var : Variable.values()) {\n+            if (var != Variable.UNKNOWN) {\n+                this.requestStatusVars.put(var, new RequestStatus(MAX_STATUS_POLLED_VALUEAGE_MSEC, NUM_TRIES,\n+                        var.getType() + \" \" + (var.getNumber() + 1)));\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Gets the last requested variable whose response will not contain the variables type.\n+     *\n+     * @return the \"typeless\" variable\n+     */\n+    public Variable getLastRequestedVarWithoutTypeInResponse() {\n+        return this.lastRequestedVarWithoutTypeInResponse;\n+    }\n+\n+    /**\n+     * Sets the last requested variable whose response will not contain the variables type.\n+     *\n+     * @param var the \"typeless\" variable\n+     */\n+    public void setLastRequestedVarWithoutTypeInResponse(Variable var) {\n+        this.lastRequestedVarWithoutTypeInResponse = var;\n+    }\n+\n+    /**\n+     * Queues a PCK command to be sent.\n+     * It will request an acknowledge from the LCN module on receipt.\n+     * If there is no response within the request timeout, the command is retried.\n+     *\n+     * @param data the PCK command to send (without address header)\n+     * @param timeoutMSec the time to wait for a response before retrying a request\n+     * @param currTime the current time stamp\n+     */\n+    public void queuePckCommandWithAck(ByteBuffer data, Connection conn, long timeoutMSec, long currTime) {\n+        this.pckCommandsWithAck.add(data);\n+        // Try to process the new acknowledged command. Will do nothing if another one is still in progress.\n+        this.tryProcessNextCommandWithAck(conn, timeoutMSec, currTime);\n+    }\n+\n+    /**\n+     * Called whenever an acknowledge is received from the LCN module.\n+     *\n+     * @param code the LCN internal code. -1 means \"positive\" acknowledge\n+     * @param timeoutMSec the time to wait for a response before retrying a request\n+     * @param currTime the current time stamp\n+     */\n+    public void onAck(int code, Connection conn, long timeoutMSec, long currTime) {\n+        if (this.requestCurrentPckCommandWithAck.isActive()) { // Check if we wait for an ack.\n+            this.pckCommandsWithAck.pollFirst();\n+            this.requestCurrentPckCommandWithAck.reset();\n+            // Try to process next acknowledged command\n+            this.tryProcessNextCommandWithAck(conn, timeoutMSec, currTime);\n+        }\n+    }\n+\n+    /**\n+     * Sends the next acknowledged command from the queue.\n+     *\n+     * @param conn the {@link Connection} belonging to this {@link ModInfo}\n+     * @param timeoutMSec the time to wait for a response before retrying a request\n+     * @param currTime the current time stamp\n+     * @return true if a new command was sent\n+     * @throws LcnException when a command response timed out\n+     */\n+    private boolean tryProcessNextCommandWithAck(Connection conn, long timeoutMSec, long currTime) {\n+        // Use the chance to remove a failed command first\n+        if (this.requestCurrentPckCommandWithAck.isFailed(timeoutMSec, currTime)) {\n+            ByteBuffer failedCommand = this.pckCommandsWithAck.pollFirst();\n+            this.requestCurrentPckCommandWithAck.reset();\n+\n+            if (failedCommand != null) {\n+                try {\n+                    logger.warn(\"{}: Module did not respond to command: {}\", addr,\n+                            new String(failedCommand.array(), LcnDefs.LCN_ENCODING));\n+                } catch (UnsupportedEncodingException e) {\n+                    // ignore\n+                }\n+            }\n+        }\n+        // Peek new command\n+        if (!this.pckCommandsWithAck.isEmpty() && !this.requestCurrentPckCommandWithAck.isActive()) {\n+            this.requestCurrentPckCommandWithAck.nextRequestIn(0, currTime);\n+        }\n+        ByteBuffer command = this.pckCommandsWithAck.peekFirst();\n+        if (command == null) {\n+            return false;\n+        }\n+        try {\n+            if (requestCurrentPckCommandWithAck.shouldSendNextRequest(timeoutMSec, currTime)) {\n+                conn.queueAndSend(new SendDataPck(addr, true, command));\n+                this.requestCurrentPckCommandWithAck.onRequestSent(currTime);\n+            }\n+        } catch (LcnException e) {\n+            try {\n+                logger.warn(\"{}: Could not send command: {}: {}\", addr,\n+                        new String(command.array(), LcnDefs.LCN_ENCODING), e.getMessage());\n+            } catch (UnsupportedEncodingException e1) {\n+                // ignore\n+            }\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * Triggers a request to retrieve the firmware version of the LCN module, if it is not known, yet.\n+     */\n+    public void requestFirmwareVersion() {\n+        if (firmwareVersion == -1) {\n+            requestFirmwareVersion.refresh();\n+        }\n+    }\n+\n+    /**\n+     * Used to check if the module has the measurement processing firmware (since Feb. 2013).\n+     *\n+     * @return if the module has at least 4 threshold registers and 12 variables\n+     */\n+    public boolean hasExtendedMeasurementProcessing() {\n+        if (firmwareVersion == -1) {\n+            logger.warn(\"LCN module firmware version unknown\");\n+            return false;\n+        }\n+        return firmwareVersion >= LcnBindingConstants.FIRMWARE_2013;\n+    }\n+\n+    /**\n+     * Keeps the request logic active.\n+     * Must be called periodically.\n+     *\n+     * @param conn the {@link Connection} belonging to this {@link ModInfo}\n+     * @param timeoutMSec the time to wait for a response before retrying a request\n+     * @param currTime the current time stamp\n+     */\n+    void update(Connection conn, long timeoutMSec, long currTime) {\n+        RequestStatus r;\n+        try {\n+            // Firmware request\n+            if ((r = this.requestFirmwareVersion).shouldSendNextRequest(timeoutMSec, currTime)) {\n+                conn.queue(this.addr, false, PckGenerator.requestSn());\n+                r.onRequestSent(currTime);\n+                return;\n+            }\n+            // Output-port requests\n+            for (int i = 0; i < 4; ++i) {\n+                if ((r = this.requestStatusOutputs.get(i)).shouldSendNextRequest(timeoutMSec, currTime)) {\n+                    conn.queue(this.addr, false, PckGenerator.requestOutputStatus(i));\n+                    r.onRequestSent(currTime);\n+                    return;\n+                }\n+            }\n+            // Relays request\n+            if ((r = this.requestStatusRelays).shouldSendNextRequest(timeoutMSec, currTime)) {\n+                conn.queue(this.addr, false, PckGenerator.requestRelaysStatus());\n+                r.onRequestSent(currTime);\n+                return;\n+            }\n+            // Binary-sensors request\n+            if ((r = this.requestStatusBinSensors).shouldSendNextRequest(timeoutMSec, currTime)) {\n+                conn.queue(this.addr, false, PckGenerator.requestBinSensorsStatus());\n+                r.onRequestSent(currTime);\n+                return;\n+            }\n+            // Variable requests\n+            if (this.firmwareVersion != -1) { // Firmware version is required\n+                // Use the chance to remove a failed \"typeless variable\" request\n+                if (this.lastRequestedVarWithoutTypeInResponse != Variable.UNKNOWN) {\n+                    if (this.requestStatusVars.get(this.lastRequestedVarWithoutTypeInResponse).isTimeout(timeoutMSec,\n+                            currTime)) {\n+                        this.lastRequestedVarWithoutTypeInResponse = Variable.UNKNOWN;\n+                    }\n+                }\n+                // Variables\n+                for (Map.Entry<Variable, RequestStatus> kv : this.requestStatusVars.entrySet()) {\n+                    if ((r = kv.getValue()).shouldSendNextRequest(timeoutMSec, currTime)) {\n+                        // Detect if we can send immediately or if we have to wait for a \"typeless\" request first\n+                        boolean hasTypeInResponse = kv.getKey().hasTypeInResponse(this.firmwareVersion);\n+                        if (hasTypeInResponse || this.lastRequestedVarWithoutTypeInResponse == Variable.UNKNOWN) {\n+                            try {\n+                                conn.queue(this.addr, false,\n+                                        PckGenerator.requestVarStatus(kv.getKey(), this.firmwareVersion));\n+                                r.onRequestSent(currTime);\n+                                if (!hasTypeInResponse) {\n+                                    this.lastRequestedVarWithoutTypeInResponse = kv.getKey();\n+                                }\n+                                return;\n+                            } catch (LcnException ex) {\n+                                r.reset();\n+                            }\n+                        }\n+                    }\n+                }\n+            }\n+            // LEDs and logic-operations request\n+            if ((r = this.requestStatusLedsAndLogicOps).shouldSendNextRequest(timeoutMSec, currTime)) {\n+                conn.queue(this.addr, false, PckGenerator.requestLedsAndLogicOpsStatus());\n+                r.onRequestSent(currTime);\n+                return;\n+            }\n+            // Key-locks request\n+            if ((r = this.requestStatusLockedKeys).shouldSendNextRequest(timeoutMSec, currTime)) {\n+                conn.queue(this.addr, false, PckGenerator.requestKeyLocksStatus());\n+                r.onRequestSent(currTime);\n+                return;\n+            }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ce02f433e5d4071dbebb9ee68da0e22895887b6b"}, "originalPosition": 334}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjk1OTE1Mg==", "bodyText": "It would be better to use offlineSendQueue.drainTo here.", "url": "https://github.com/openhab/openhab-addons/pull/7509#discussion_r436959152", "createdAt": "2020-06-08T19:46:39Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.lcn/src/main/java/org/openhab/binding/lcn/internal/connection/Connection.java", "diffHunk": "@@ -0,0 +1,505 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.lcn.internal.connection;\n+\n+import java.io.IOException;\n+import java.io.UnsupportedEncodingException;\n+import java.nio.BufferOverflowException;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.AsynchronousSocketChannel;\n+import java.nio.channels.Channel;\n+import java.nio.channels.CompletionHandler;\n+import java.time.Instant;\n+import java.time.temporal.ChronoUnit;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Queue;\n+import java.util.concurrent.LinkedBlockingQueue;\n+import java.util.concurrent.ScheduledExecutorService;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.lcn.internal.common.LcnAddr;\n+import org.openhab.binding.lcn.internal.common.LcnAddrGrp;\n+import org.openhab.binding.lcn.internal.common.LcnAddrMod;\n+import org.openhab.binding.lcn.internal.common.LcnDefs;\n+import org.openhab.binding.lcn.internal.common.LcnException;\n+import org.openhab.binding.lcn.internal.common.PckGenerator;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * This class represents a configured connection to one LCN-PCHK.\n+ * It uses a {@link AsynchronousSocketChannel} to connect to LCN-PCHK.\n+ * Included logic:\n+ * <ul>\n+ * <li>Reconnection on connection loss\n+ * <li>Segment scan (to detect the local segment ID)\n+ * <li>Acknowledge handling\n+ * <li>Periodic value requests\n+ * <li>Caching of runtime data about the underlying LCN bus\n+ * </ul>\n+ *\n+ * @author Fabian Wolter - Initial Contribution\n+ */\n+@NonNullByDefault\n+public class Connection {\n+    private final Logger logger = LoggerFactory.getLogger(Connection.class);\n+    /** Max. lengths of a PCK string including address and line feed. Currently dynamic text (GTDT) */\n+    private static final int MAX_PCK_STRING_LENGTH = 34;\n+    private static final int BROADCAST_MODULE_ID = 3;\n+    private static final int BROADCAST_SEGMENT_ID = 3;\n+    private final ConnectionSettings settings;\n+    private final ConnectionCallback callback;\n+    @Nullable\n+    private AsynchronousSocketChannel channel;\n+    /** The local segment id. -1 means \"unknown\". */\n+    private int localSegId;\n+    private final ByteBuffer readBuffer = ByteBuffer.allocate(1024);\n+    private final ByteBuffer sendBuffer = ByteBuffer.allocate(MAX_PCK_STRING_LENGTH);\n+    private final Queue<@Nullable SendData> sendQueue = new LinkedBlockingQueue<>();\n+    private final Queue<@Nullable PckQueueItem> offlineSendQueue = new LinkedBlockingQueue<>();\n+    private final Map<LcnAddr, @Nullable ModInfo> modData = Collections.synchronizedMap(new HashMap<>());\n+    private volatile boolean writeInProgress;\n+    private ScheduledExecutorService scheduler;\n+    private StateMachine stateMachine;\n+\n+    /**\n+     * Constructs a clean (disconnected) connection with the given settings.\n+     * This does not start the actual connection process.\n+     *\n+     * @param sets the settings to use for the new connection\n+     * @param callback the callback to the owner\n+     * @throws IOException\n+     */\n+    public Connection(ConnectionSettings sets, ScheduledExecutorService scheduler, ConnectionCallback callback) {\n+        this.settings = sets;\n+        this.callback = callback;\n+        this.scheduler = scheduler;\n+        this.clearRuntimeData();\n+\n+        stateMachine = new StateMachine(this, scheduler);\n+        stateMachine.startWorking();\n+    }\n+\n+    /** Clears all runtime data. */\n+    void clearRuntimeData() {\n+        this.channel = null;\n+        this.localSegId = -1;\n+        this.readBuffer.clear();\n+        this.sendQueue.clear();\n+        this.sendBuffer.clear();\n+    }\n+\n+    /**\n+     * Retrieves the settings for this connection (never changed).\n+     *\n+     * @return the settings\n+     */\n+    public ConnectionSettings getSettings() {\n+        return this.settings;\n+    }\n+\n+    private boolean isSocketConnected() {\n+        try {\n+            AsynchronousSocketChannel localChannel = channel;\n+            return localChannel != null && localChannel.getRemoteAddress() != null;\n+        } catch (IOException e) {\n+            return false;\n+        }\n+    }\n+\n+    /**\n+     * Sets the local segment id.\n+     *\n+     * @param localSegId the new local segment id\n+     */\n+    public void setLocalSegId(int localSegId) {\n+        this.localSegId = localSegId;\n+    }\n+\n+    /**\n+     * Called whenever an acknowledge is received.\n+     *\n+     * @param addr the source LCN module\n+     * @param code the LCN internal code (-1 = \"positive\")\n+     */\n+    public void onAck(LcnAddrMod addr, int code) {\n+        ModInfo info = this.modData.get(addr);\n+        if (info != null) {\n+            info.onAck(code, this, this.settings.getTimeout(), System.nanoTime());\n+        }\n+    }\n+\n+    /**\n+     * Creates and/or returns cached data for the given LCN module.\n+     *\n+     * @param addr the module's address\n+     * @return the data (never null)\n+     */\n+    public ModInfo updateModuleData(LcnAddrMod addr) {\n+        synchronized (modData) {\n+            ModInfo data = this.modData.get(addr);\n+            if (data == null) {\n+                data = new ModInfo(addr);\n+                this.modData.put(addr, data);\n+            }\n+            return data;\n+        }\n+    }\n+\n+    /**\n+     * Reads and processes input from the underlying channel.\n+     * Fragmented input is kept in {@link #readBuffer} and will be processed with the next call.\n+     *\n+     * @throws IOException if connection was closed or a generic channel error occurred\n+     */\n+    void readAndProcess() {\n+        AsynchronousSocketChannel localChannel = channel;\n+        if (localChannel != null && isSocketConnected()) {\n+            localChannel.read(readBuffer, null, new CompletionHandler<@Nullable Integer, @Nullable Void>() {\n+                @Override\n+                public void completed(@Nullable Integer transmittedByteCount, @Nullable Void attachment) {\n+                    synchronized (Connection.this) {\n+                        if (transmittedByteCount == null || transmittedByteCount == -1) {\n+                            String msg = \"Connection was closed by foreign host.\";\n+                            stateMachine.handleConnectionFailed(new LcnException(msg));\n+                        } else {\n+                            try {\n+                                // read data chunks from socket and separate frames\n+                                readBuffer.flip();\n+                                int aPos = readBuffer.position(); // 0\n+                                String s = new String(readBuffer.array(), aPos, transmittedByteCount,\n+                                        LcnDefs.LCN_ENCODING);\n+                                int pos1 = 0, pos2 = s.indexOf(PckGenerator.TERMINATION, pos1);\n+                                while (pos2 != -1) {\n+                                    String data = s.substring(pos1, pos2);\n+                                    if (logger.isTraceEnabled()) {\n+                                        logger.trace(\"Received: '{}'\", data);\n+                                    }\n+                                    scheduler.submit(() -> {\n+                                        stateMachine.onInputReceived(data);\n+                                        callback.onPckMessageReceived(data);\n+                                    });\n+                                    // Seek position in input array\n+                                    aPos += s.substring(pos1, pos2 + 1).getBytes(LcnDefs.LCN_ENCODING).length;\n+                                    // Next input\n+                                    pos1 = pos2 + 1;\n+                                    pos2 = s.indexOf(PckGenerator.TERMINATION, pos1);\n+                                }\n+                                readBuffer.limit(readBuffer.capacity());\n+                                readBuffer.position(transmittedByteCount - aPos); // Keeps fragments for the next call\n+                            } catch (UnsupportedEncodingException ex) {\n+                                logger.warn(\"Unable to decode input from channel \\\"{}\\\": {}\", settings.getId(),\n+                                        ex.getMessage());\n+                            }\n+\n+                            if (isSocketConnected()) {\n+                                readAndProcess();\n+                            }\n+                        }\n+                    }\n+                }\n+\n+                @Override\n+                public void failed(@Nullable Throwable e, @Nullable Void attachment) {\n+                    logger.debug(\"Lost connection\");\n+                    stateMachine.handleConnectionFailed(e);\n+                }\n+            });\n+        } else {\n+            stateMachine.handleConnectionFailed(new LcnException(\"Socket not open\"));\n+        }\n+    }\n+\n+    /**\n+     * Writes all queued data.\n+     * Will try to write all data at once to reduce overhead.\n+     */\n+    public synchronized void triggerWriteToSocket() {\n+        AsynchronousSocketChannel localChannel = channel;\n+        if (localChannel == null || !isSocketConnected() || writeInProgress) {\n+            return;\n+        }\n+        sendBuffer.clear();\n+        SendData item = sendQueue.poll();\n+\n+        if (item != null) {\n+            try {\n+                if (!item.write(sendBuffer, localSegId)) {\n+                    logger.warn(\"Data loss: Could not write packet into send buffer\");\n+                }\n+\n+                writeInProgress = true;\n+                sendBuffer.flip();\n+                localChannel.write(sendBuffer, null, new CompletionHandler<@Nullable Integer, @Nullable Void>() {\n+                    @Override\n+                    public void completed(@Nullable Integer result, @Nullable Void attachment) {\n+                        synchronized (Connection.this) {\n+                            if (result != sendBuffer.limit()) {\n+                                logger.warn(\"Data loss while writing to channel: {}\", settings.getAddress());\n+                            } else {\n+                                if (logger.isTraceEnabled()) {\n+                                    logger.trace(\"Sent: {}\", new String(sendBuffer.array(), 0, sendBuffer.limit()));\n+                                }\n+                            }\n+\n+                            writeInProgress = false;\n+\n+                            if (sendQueue.size() > 0) {\n+                                /**\n+                                 * This could lead to stack overflows, since the CompletionHandler may run in the same\n+                                 * Thread as triggerWriteToSocket() is invoked (see\n+                                 * {@link AsynchronousChannelGroup}/Threading), but we do not expect as much data\n+                                 * in one chunk here, that the stack can be filled in a critical way.\n+                                 */\n+                                triggerWriteToSocket();\n+                            }\n+                        }\n+                    }\n+\n+                    @Override\n+                    public void failed(@Nullable Throwable exc, @Nullable Void attachment) {\n+                        synchronized (Connection.this) {\n+                            if (exc != null) {\n+                                logger.warn(\"Writing to channel \\\"{}\\\" failed: {}\", settings.getAddress(),\n+                                        exc.getMessage());\n+                            }\n+                            writeInProgress = false;\n+                            stateMachine.handleConnectionFailed(new LcnException(\"write() failed\"));\n+                        }\n+                    }\n+                });\n+            } catch (UnsupportedEncodingException | BufferOverflowException e) {\n+                logger.warn(\"Sending failed: {}: {}: {}\", item, e.getClass().getSimpleName(), e.getMessage());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Queues plain text to be sent to LCN-PCHK.\n+     * Sending will be done the next time {@link #triggerWriteToSocket()} is called.\n+     *\n+     * @param plainText the text\n+     */\n+    public void queueDirectlyPlainText(String plainText) {\n+        this.queueAndSend(new SendDataPlainText(plainText));\n+    }\n+\n+    /**\n+     * Queues a PCK command to be sent.\n+     *\n+     * @param addr the target LCN address\n+     * @param wantsAck true to wait for acknowledge on receipt (should be false for group addresses)\n+     * @param pck the pure PCK command (without address header)\n+     */\n+    void queueDirectly(LcnAddr addr, boolean wantsAck, String pck) {\n+        try {\n+            this.queueDirectly(addr, wantsAck, ByteBuffer.wrap(pck.getBytes(LcnDefs.LCN_ENCODING)));\n+        } catch (UnsupportedEncodingException ex) {\n+            logger.error(\"Failed to encode PCK command: {}\", pck);\n+        }\n+    }\n+\n+    /**\n+     * Queues a PCK command for immediate sending, regardless of the Connection state. The PCK command is automatically\n+     * re-sent if the destination is not a group, an Ack is requested and the module did not answer within the expected\n+     * time.\n+     *\n+     * @param addr the target LCN address\n+     * @param wantsAck true to wait for acknowledge on receipt (should be false for group addresses)\n+     * @param data the pure PCK command (without address header)\n+     */\n+    void queueDirectly(LcnAddr addr, boolean wantsAck, ByteBuffer data) {\n+        if (!addr.isGroup() && wantsAck) {\n+            this.updateModuleData((LcnAddrMod) addr).queuePckCommandWithAck(data, this, this.settings.getTimeout(),\n+                    System.nanoTime());\n+        } else {\n+            this.queueAndSend(new SendDataPck(addr, false, data));\n+        }\n+    }\n+\n+    /**\n+     * Enqueues a raw PCK command and triggers the socket to start sending, if it does not already. Does not take care\n+     * of any Acks.\n+     *\n+     * @param data raw PCK command\n+     */\n+    synchronized void queueAndSend(SendData data) {\n+        this.sendQueue.add(data);\n+\n+        triggerWriteToSocket();\n+    }\n+\n+    /**\n+     * Enqueues a PCK command to the offline queue. Data will be sent when the Connection state will enter\n+     * {@link ConnectionStateConnected}.\n+     *\n+     * @param addr LCN module address\n+     * @param wantsAck true, if the LCN module shall respond with an Ack on successful processing\n+     * @param data the pure PCK command (without address header)\n+     */\n+    void queueOffline(LcnAddr addr, boolean wantsAck, ByteBuffer data) {\n+        offlineSendQueue.add(new PckQueueItem(addr, wantsAck, data));\n+    }\n+\n+    /**\n+     * Enqueues a PCK command for sending. Takes care of the Connection state and buffers the command for a specific\n+     * time if the Connection is not ready. If an Ack is requested, the PCK command is automatically\n+     * re-sent, if the module did not answer in the expected time.\n+     *\n+     * @param addr LCN module address\n+     * @param wantsAck true, if the LCN module shall respond with an Ack on successful processing\n+     * @param pck the pure PCK command (without address header)\n+     */\n+    public void queue(LcnAddr addr, boolean wantsAck, String pck) {\n+        try {\n+            this.queue(addr, wantsAck, ByteBuffer.wrap(pck.getBytes(LcnDefs.LCN_ENCODING)));\n+        } catch (UnsupportedEncodingException ex) {\n+            logger.warn(\"Failed to encode PCK command: {}\", pck);\n+        }\n+    }\n+\n+    /**\n+     * Enqueues a PCK command for sending. Takes care of the Connection state and buffers the command for a specific\n+     * time if the Connection is not ready. If an Ack is requested, the PCK command is automatically\n+     * re-sent, if the module did not answer in the expected time.\n+     *\n+     * @param addr LCN module address\n+     * @param wantsAck true, if the LCN module shall respond with an Ack on successful processing\n+     * @param pck the pure PCK command (without address header)\n+     */\n+    public void queue(LcnAddr addr, boolean wantsAck, ByteBuffer pck) {\n+        stateMachine.queue(addr, wantsAck, pck);\n+    }\n+\n+    /**\n+     * Process the offline PCK command queue. Does only send recently enqueued PCK commands, the rest is discarded.\n+     */\n+    void sendOfflineQueue() {\n+        // don't use forEach(), because elements can be added during iteration\n+        while (!offlineSendQueue.isEmpty()) {\n+            PckQueueItem item = offlineSendQueue.poll();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ce02f433e5d4071dbebb9ee68da0e22895887b6b"}, "originalPosition": 393}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjk2NTEwMw==", "bodyText": "Why not make this a CopyOnWriteArrayList instead?", "url": "https://github.com/openhab/openhab-addons/pull/7509#discussion_r436965103", "createdAt": "2020-06-08T19:58:11Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.lcn/src/main/java/org/openhab/binding/lcn/internal/LcnModuleHandler.java", "diffHunk": "@@ -0,0 +1,411 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.lcn.internal;\n+\n+import java.lang.reflect.InvocationTargetException;\n+import java.nio.ByteBuffer;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+import java.util.Optional;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.HSBType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StopMoveType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.library.types.UpDownType;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.lcn.internal.common.DimmerOutputCommand;\n+import org.openhab.binding.lcn.internal.common.LcnAddr;\n+import org.openhab.binding.lcn.internal.common.LcnAddrMod;\n+import org.openhab.binding.lcn.internal.common.LcnChannelGroup;\n+import org.openhab.binding.lcn.internal.common.LcnException;\n+import org.openhab.binding.lcn.internal.connection.Connection;\n+import org.openhab.binding.lcn.internal.connection.ModInfo;\n+import org.openhab.binding.lcn.internal.converter.AbstractVariableValueConverter;\n+import org.openhab.binding.lcn.internal.converter.AngleConverter;\n+import org.openhab.binding.lcn.internal.converter.Co2Converter;\n+import org.openhab.binding.lcn.internal.converter.CurrentConverter;\n+import org.openhab.binding.lcn.internal.converter.EnergyConverter;\n+import org.openhab.binding.lcn.internal.converter.IdentityConverter;\n+import org.openhab.binding.lcn.internal.converter.LightConverter;\n+import org.openhab.binding.lcn.internal.converter.PowerConverter;\n+import org.openhab.binding.lcn.internal.converter.TemperatureConverter;\n+import org.openhab.binding.lcn.internal.converter.VoltageConverter;\n+import org.openhab.binding.lcn.internal.converter.WindspeedConverter;\n+import org.openhab.binding.lcn.internal.subhandler.AbstractLcnModuleSubHandler;\n+import org.openhab.binding.lcn.internal.subhandler.LcnModuleMetaAckSubHandler;\n+import org.openhab.binding.lcn.internal.subhandler.LcnModuleMetaFirmwareSubHandler;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link LcnModuleHandler} is responsible for handling commands, which are\n+ * sent to or received from one of the channels.\n+ *\n+ * @author Fabian Wolter - Initial contribution\n+ */\n+@NonNullByDefault\n+public class LcnModuleHandler extends BaseThingHandler {\n+    private final Logger logger = LoggerFactory.getLogger(LcnModuleHandler.class);\n+    private @Nullable LcnAddrMod moduleAddress;\n+    private Map<LcnChannelGroup, @Nullable AbstractLcnModuleSubHandler> subHandlers;\n+    private List<AbstractLcnModuleSubHandler> metadataSubHandlers;\n+    private Map<ChannelUID, @Nullable AbstractVariableValueConverter> converters;\n+\n+    public LcnModuleHandler(Thing thing) {\n+        super(thing);\n+\n+        subHandlers = Collections.synchronizedMap(new HashMap<>());\n+        metadataSubHandlers = Collections.synchronizedList(new LinkedList<>());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ce02f433e5d4071dbebb9ee68da0e22895887b6b"}, "originalPosition": 89}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjk2NjIyNA==", "bodyText": "It should be safe to leave this as a regular HashMap since you only perform read operations on it outside of initialize and dispose. But if you want to be extra safe use a ConcurrentHashMap instead.", "url": "https://github.com/openhab/openhab-addons/pull/7509#discussion_r436966224", "createdAt": "2020-06-08T20:00:21Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.lcn/src/main/java/org/openhab/binding/lcn/internal/LcnModuleHandler.java", "diffHunk": "@@ -0,0 +1,411 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.lcn.internal;\n+\n+import java.lang.reflect.InvocationTargetException;\n+import java.nio.ByteBuffer;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+import java.util.Optional;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.HSBType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StopMoveType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.library.types.UpDownType;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.lcn.internal.common.DimmerOutputCommand;\n+import org.openhab.binding.lcn.internal.common.LcnAddr;\n+import org.openhab.binding.lcn.internal.common.LcnAddrMod;\n+import org.openhab.binding.lcn.internal.common.LcnChannelGroup;\n+import org.openhab.binding.lcn.internal.common.LcnException;\n+import org.openhab.binding.lcn.internal.connection.Connection;\n+import org.openhab.binding.lcn.internal.connection.ModInfo;\n+import org.openhab.binding.lcn.internal.converter.AbstractVariableValueConverter;\n+import org.openhab.binding.lcn.internal.converter.AngleConverter;\n+import org.openhab.binding.lcn.internal.converter.Co2Converter;\n+import org.openhab.binding.lcn.internal.converter.CurrentConverter;\n+import org.openhab.binding.lcn.internal.converter.EnergyConverter;\n+import org.openhab.binding.lcn.internal.converter.IdentityConverter;\n+import org.openhab.binding.lcn.internal.converter.LightConverter;\n+import org.openhab.binding.lcn.internal.converter.PowerConverter;\n+import org.openhab.binding.lcn.internal.converter.TemperatureConverter;\n+import org.openhab.binding.lcn.internal.converter.VoltageConverter;\n+import org.openhab.binding.lcn.internal.converter.WindspeedConverter;\n+import org.openhab.binding.lcn.internal.subhandler.AbstractLcnModuleSubHandler;\n+import org.openhab.binding.lcn.internal.subhandler.LcnModuleMetaAckSubHandler;\n+import org.openhab.binding.lcn.internal.subhandler.LcnModuleMetaFirmwareSubHandler;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link LcnModuleHandler} is responsible for handling commands, which are\n+ * sent to or received from one of the channels.\n+ *\n+ * @author Fabian Wolter - Initial contribution\n+ */\n+@NonNullByDefault\n+public class LcnModuleHandler extends BaseThingHandler {\n+    private final Logger logger = LoggerFactory.getLogger(LcnModuleHandler.class);\n+    private @Nullable LcnAddrMod moduleAddress;\n+    private Map<LcnChannelGroup, @Nullable AbstractLcnModuleSubHandler> subHandlers;\n+    private List<AbstractLcnModuleSubHandler> metadataSubHandlers;\n+    private Map<ChannelUID, @Nullable AbstractVariableValueConverter> converters;\n+\n+    public LcnModuleHandler(Thing thing) {\n+        super(thing);\n+\n+        subHandlers = Collections.synchronizedMap(new HashMap<>());\n+        metadataSubHandlers = Collections.synchronizedList(new LinkedList<>());\n+        converters = Collections.synchronizedMap(new HashMap<>());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ce02f433e5d4071dbebb9ee68da0e22895887b6b"}, "originalPosition": 90}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjk2NjY2Mg==", "bodyText": "same here", "url": "https://github.com/openhab/openhab-addons/pull/7509#discussion_r436966662", "createdAt": "2020-06-08T20:01:10Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.lcn/src/main/java/org/openhab/binding/lcn/internal/LcnModuleHandler.java", "diffHunk": "@@ -0,0 +1,411 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.lcn.internal;\n+\n+import java.lang.reflect.InvocationTargetException;\n+import java.nio.ByteBuffer;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+import java.util.Optional;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.HSBType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StopMoveType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.library.types.UpDownType;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.lcn.internal.common.DimmerOutputCommand;\n+import org.openhab.binding.lcn.internal.common.LcnAddr;\n+import org.openhab.binding.lcn.internal.common.LcnAddrMod;\n+import org.openhab.binding.lcn.internal.common.LcnChannelGroup;\n+import org.openhab.binding.lcn.internal.common.LcnException;\n+import org.openhab.binding.lcn.internal.connection.Connection;\n+import org.openhab.binding.lcn.internal.connection.ModInfo;\n+import org.openhab.binding.lcn.internal.converter.AbstractVariableValueConverter;\n+import org.openhab.binding.lcn.internal.converter.AngleConverter;\n+import org.openhab.binding.lcn.internal.converter.Co2Converter;\n+import org.openhab.binding.lcn.internal.converter.CurrentConverter;\n+import org.openhab.binding.lcn.internal.converter.EnergyConverter;\n+import org.openhab.binding.lcn.internal.converter.IdentityConverter;\n+import org.openhab.binding.lcn.internal.converter.LightConverter;\n+import org.openhab.binding.lcn.internal.converter.PowerConverter;\n+import org.openhab.binding.lcn.internal.converter.TemperatureConverter;\n+import org.openhab.binding.lcn.internal.converter.VoltageConverter;\n+import org.openhab.binding.lcn.internal.converter.WindspeedConverter;\n+import org.openhab.binding.lcn.internal.subhandler.AbstractLcnModuleSubHandler;\n+import org.openhab.binding.lcn.internal.subhandler.LcnModuleMetaAckSubHandler;\n+import org.openhab.binding.lcn.internal.subhandler.LcnModuleMetaFirmwareSubHandler;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link LcnModuleHandler} is responsible for handling commands, which are\n+ * sent to or received from one of the channels.\n+ *\n+ * @author Fabian Wolter - Initial contribution\n+ */\n+@NonNullByDefault\n+public class LcnModuleHandler extends BaseThingHandler {\n+    private final Logger logger = LoggerFactory.getLogger(LcnModuleHandler.class);\n+    private @Nullable LcnAddrMod moduleAddress;\n+    private Map<LcnChannelGroup, @Nullable AbstractLcnModuleSubHandler> subHandlers;\n+    private List<AbstractLcnModuleSubHandler> metadataSubHandlers;\n+    private Map<ChannelUID, @Nullable AbstractVariableValueConverter> converters;\n+\n+    public LcnModuleHandler(Thing thing) {\n+        super(thing);\n+\n+        subHandlers = Collections.synchronizedMap(new HashMap<>());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ce02f433e5d4071dbebb9ee68da0e22895887b6b"}, "originalPosition": 88}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjk2ODQwOA==", "bodyText": "Why not have each LcnChannelGroup enum instance include a AbstractLcnModuleSubHandler factory lambda method for creating class instances? That way you wouldn't need to use reflection here.", "url": "https://github.com/openhab/openhab-addons/pull/7509#discussion_r436968408", "createdAt": "2020-06-08T20:04:50Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.lcn/src/main/java/org/openhab/binding/lcn/internal/LcnModuleHandler.java", "diffHunk": "@@ -0,0 +1,411 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.lcn.internal;\n+\n+import java.lang.reflect.InvocationTargetException;\n+import java.nio.ByteBuffer;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+import java.util.Optional;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.HSBType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StopMoveType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.library.types.UpDownType;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.lcn.internal.common.DimmerOutputCommand;\n+import org.openhab.binding.lcn.internal.common.LcnAddr;\n+import org.openhab.binding.lcn.internal.common.LcnAddrMod;\n+import org.openhab.binding.lcn.internal.common.LcnChannelGroup;\n+import org.openhab.binding.lcn.internal.common.LcnException;\n+import org.openhab.binding.lcn.internal.connection.Connection;\n+import org.openhab.binding.lcn.internal.connection.ModInfo;\n+import org.openhab.binding.lcn.internal.converter.AbstractVariableValueConverter;\n+import org.openhab.binding.lcn.internal.converter.AngleConverter;\n+import org.openhab.binding.lcn.internal.converter.Co2Converter;\n+import org.openhab.binding.lcn.internal.converter.CurrentConverter;\n+import org.openhab.binding.lcn.internal.converter.EnergyConverter;\n+import org.openhab.binding.lcn.internal.converter.IdentityConverter;\n+import org.openhab.binding.lcn.internal.converter.LightConverter;\n+import org.openhab.binding.lcn.internal.converter.PowerConverter;\n+import org.openhab.binding.lcn.internal.converter.TemperatureConverter;\n+import org.openhab.binding.lcn.internal.converter.VoltageConverter;\n+import org.openhab.binding.lcn.internal.converter.WindspeedConverter;\n+import org.openhab.binding.lcn.internal.subhandler.AbstractLcnModuleSubHandler;\n+import org.openhab.binding.lcn.internal.subhandler.LcnModuleMetaAckSubHandler;\n+import org.openhab.binding.lcn.internal.subhandler.LcnModuleMetaFirmwareSubHandler;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link LcnModuleHandler} is responsible for handling commands, which are\n+ * sent to or received from one of the channels.\n+ *\n+ * @author Fabian Wolter - Initial contribution\n+ */\n+@NonNullByDefault\n+public class LcnModuleHandler extends BaseThingHandler {\n+    private final Logger logger = LoggerFactory.getLogger(LcnModuleHandler.class);\n+    private @Nullable LcnAddrMod moduleAddress;\n+    private Map<LcnChannelGroup, @Nullable AbstractLcnModuleSubHandler> subHandlers;\n+    private List<AbstractLcnModuleSubHandler> metadataSubHandlers;\n+    private Map<ChannelUID, @Nullable AbstractVariableValueConverter> converters;\n+\n+    public LcnModuleHandler(Thing thing) {\n+        super(thing);\n+\n+        subHandlers = Collections.synchronizedMap(new HashMap<>());\n+        metadataSubHandlers = Collections.synchronizedList(new LinkedList<>());\n+        converters = Collections.synchronizedMap(new HashMap<>());\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        LcnModuleConfiguration localConfig = getConfigAs(LcnModuleConfiguration.class);\n+        LcnAddrMod localModuleAddress = moduleAddress = new LcnAddrMod(localConfig.segmentId, localConfig.moduleId);\n+\n+        try {\n+            // create sub handlers\n+            ModInfo info = getPckGatewayHandler().getModInfo(localModuleAddress);\n+            for (LcnChannelGroup type : LcnChannelGroup.values()) {\n+                AbstractLcnModuleSubHandler newHandler = type.getSubHandlerClass()\n+                        .getDeclaredConstructor(LcnModuleHandler.class, ModInfo.class).newInstance(this, info);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ce02f433e5d4071dbebb9ee68da0e22895887b6b"}, "originalPosition": 103}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjk3MjE1NA==", "bodyText": "Here is an example of what I mean:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                CODE(0, LcnModuleCodeSubHandler.class);\n          \n          \n            \n            \n          \n          \n            \n                private int count;\n          \n          \n            \n                private Class<? extends AbstractLcnModuleSubHandler> subHandlerClass;\n          \n          \n            \n            \n          \n          \n            \n                private LcnChannelGroup(int count, Class<? extends AbstractLcnModuleSubHandler> subHandlerClass) {\n          \n          \n            \n                    this.count = count;\n          \n          \n            \n                    this.subHandlerClass = subHandlerClass;\n          \n          \n            \n                }\n          \n          \n            \n                CODE(0, LcnModuleCodeSubHandler.class, LcnModuleCodeSubHandler::new);\n          \n          \n            \n            \n          \n          \n            \n                private final int count;\n          \n          \n            \n                private final Class<? extends AbstractLcnModuleSubHandler> subHandlerClass;\n          \n          \n            \n                private final BiFunction<LcnModuleHandler, ModInfo, ? extends AbstractLcnModuleSubHandler> handlerFactory;\n          \n          \n            \n            \n          \n          \n            \n                private <T extends AbstractLcnModuleSubHandler> LcnChannelGroup(int count, Class<T> subHandlerClass, \n          \n          \n            \n                    BiFunction<LcnModuleHandler, ModInfo, T> handlerFactory) {\n          \n          \n            \n                    this.count = count;\n          \n          \n            \n                    this.subHandlerClass = subHandlerClass;\n          \n          \n            \n                    this.handlerFactory = handlerFactory;\n          \n          \n            \n                }", "url": "https://github.com/openhab/openhab-addons/pull/7509#discussion_r436972154", "createdAt": "2020-06-08T20:12:19Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.lcn/src/main/java/org/openhab/binding/lcn/internal/common/LcnChannelGroup.java", "diffHunk": "@@ -0,0 +1,117 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.lcn.internal.common;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.binding.lcn.internal.subhandler.AbstractLcnModuleSubHandler;\n+import org.openhab.binding.lcn.internal.subhandler.LcnModuleBinarySensorSubHandler;\n+import org.openhab.binding.lcn.internal.subhandler.LcnModuleCodeSubHandler;\n+import org.openhab.binding.lcn.internal.subhandler.LcnModuleKeyLockTableSubHandler;\n+import org.openhab.binding.lcn.internal.subhandler.LcnModuleLedSubHandler;\n+import org.openhab.binding.lcn.internal.subhandler.LcnModuleLogicSubHandler;\n+import org.openhab.binding.lcn.internal.subhandler.LcnModuleOutputSubHandler;\n+import org.openhab.binding.lcn.internal.subhandler.LcnModuleRelaySubHandler;\n+import org.openhab.binding.lcn.internal.subhandler.LcnModuleRollershutterOutputSubHandler;\n+import org.openhab.binding.lcn.internal.subhandler.LcnModuleRollershutterRelaySubHandler;\n+import org.openhab.binding.lcn.internal.subhandler.LcnModuleRvarLockSubHandler;\n+import org.openhab.binding.lcn.internal.subhandler.LcnModuleRvarSetpointSubHandler;\n+import org.openhab.binding.lcn.internal.subhandler.LcnModuleS0CounterSubHandler;\n+import org.openhab.binding.lcn.internal.subhandler.LcnModuleThresholdSubHandler;\n+import org.openhab.binding.lcn.internal.subhandler.LcnModuleVariableSubHandler;\n+\n+/**\n+ * Defines the supported channels of an LCN module handler.\n+ *\n+ * @author Fabian Wolter - Initial contribution\n+ */\n+@NonNullByDefault\n+public enum LcnChannelGroup {\n+    OUTPUT(4, LcnModuleOutputSubHandler.class),\n+    ROLLERSHUTTEROUTPUT(1, LcnModuleRollershutterOutputSubHandler.class),\n+    RELAY(8, LcnModuleRelaySubHandler.class),\n+    ROLLERSHUTTERRELAY(4, LcnModuleRollershutterRelaySubHandler.class),\n+    LED(12, LcnModuleLedSubHandler.class),\n+    LOGIC(4, LcnModuleLogicSubHandler.class),\n+    BINARYSENSOR(8, LcnModuleBinarySensorSubHandler.class),\n+    VARIABLE(12, LcnModuleVariableSubHandler.class),\n+    RVARSETPOINT(2, LcnModuleRvarSetpointSubHandler.class),\n+    RVARLOCK(2, LcnModuleRvarLockSubHandler.class),\n+    THRESHOLDREGISTER1(5, LcnModuleThresholdSubHandler.class),\n+    THRESHOLDREGISTER2(4, LcnModuleThresholdSubHandler.class),\n+    THRESHOLDREGISTER3(4, LcnModuleThresholdSubHandler.class),\n+    THRESHOLDREGISTER4(4, LcnModuleThresholdSubHandler.class),\n+    S0INPUT(4, LcnModuleS0CounterSubHandler.class),\n+    KEYLOCKTABLEA(8, LcnModuleKeyLockTableSubHandler.class),\n+    KEYLOCKTABLEB(8, LcnModuleKeyLockTableSubHandler.class),\n+    KEYLOCKTABLEC(8, LcnModuleKeyLockTableSubHandler.class),\n+    KEYLOCKTABLED(8, LcnModuleKeyLockTableSubHandler.class),\n+    CODE(0, LcnModuleCodeSubHandler.class);\n+\n+    private int count;\n+    private Class<? extends AbstractLcnModuleSubHandler> subHandlerClass;\n+\n+    private LcnChannelGroup(int count, Class<? extends AbstractLcnModuleSubHandler> subHandlerClass) {\n+        this.count = count;\n+        this.subHandlerClass = subHandlerClass;\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ce02f433e5d4071dbebb9ee68da0e22895887b6b"}, "originalPosition": 66}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f286ec5e63678277ee6c0c42b0e316ffb3997d38", "author": {"user": {"login": "fwolter", "name": "Fabian Wolter"}}, "url": "https://github.com/openhab/openhab-addons/commit/f286ec5e63678277ee6c0c42b0e316ffb3997d38", "committedDate": "2020-06-10T13:09:34Z", "message": "Incorporate review feedback\n\nSigned-off-by: Fabian Wolter <github@fabian-wolter.de>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ec291ce4f40624263177049a28d70762a64e8c9c", "author": {"user": {"login": "fwolter", "name": "Fabian Wolter"}}, "url": "https://github.com/openhab/openhab-addons/commit/ec291ce4f40624263177049a28d70762a64e8c9c", "committedDate": "2020-06-10T13:09:35Z", "message": "Fix DimmerOutputProfile\n\nSigned-off-by: Fabian Wolter <github@fabian-wolter.de>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "aa746b45c1b7e84de15259f8d41ff931d670d355", "author": {"user": {"login": "fwolter", "name": "Fabian Wolter"}}, "url": "https://github.com/openhab/openhab-addons/commit/aa746b45c1b7e84de15259f8d41ff931d670d355", "committedDate": "2020-06-10T13:09:35Z", "message": "Fix NPE\n\nSigned-off-by: Fabian Wolter <github@fabian-wolter.de>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7384be9252bcb0aeb89efeada0f9fa255c15f424", "author": {"user": {"login": "fwolter", "name": "Fabian Wolter"}}, "url": "https://github.com/openhab/openhab-addons/commit/7384be9252bcb0aeb89efeada0f9fa255c15f424", "committedDate": "2020-06-10T13:09:59Z", "message": "Refactor\n\nSigned-off-by: Fabian Wolter <github@fabian-wolter.de>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9e249fde574174c45a06de38d391391f0c42920a", "author": {"user": {"login": "fwolter", "name": "Fabian Wolter"}}, "url": "https://github.com/openhab/openhab-addons/commit/9e249fde574174c45a06de38d391391f0c42920a", "committedDate": "2020-06-10T20:17:56Z", "message": "Add representation property to Discovery Services\n\nSigned-off-by: Fabian Wolter <github@fabian-wolter.de>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI4MzEwMzcw", "url": "https://github.com/openhab/openhab-addons/pull/7509#pullrequestreview-428310370", "createdAt": "2020-06-10T18:11:52Z", "commit": {"oid": "f286ec5e63678277ee6c0c42b0e316ffb3997d38"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMFQxODoxMTo1MlrOGiAzKg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMFQyMDoyMjoyNlrOGiE-UQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODMxNzg2Ng==", "bodyText": "Standard java Proxys can only be interfaces, so you would need to make an interface that has all your action methods in it.", "url": "https://github.com/openhab/openhab-addons/pull/7509#discussion_r438317866", "createdAt": "2020-06-10T18:11:52Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.lcn/src/main/java/org/openhab/binding/lcn/internal/LcnModuleActions.java", "diffHunk": "@@ -145,42 +147,46 @@ public void sendDynamicText(\n                 command.put(PckGenerator.dynTextHeader(row - 1, part++).getBytes(LcnDefs.LCN_ENCODING));\n                 command.put(chunk);\n \n-                getHandler().sendPck(command);\n+                getHandler().sendPck(command.array());\n             }\n         } catch (UnsupportedEncodingException | IllegalArgumentException | LcnException e) {\n             logger.warn(\"Could not send dynamic text: {}\", e.getMessage());\n         }\n     }\n \n+    private static LcnModuleActions invokeMethodOf(@Nullable ThingActions actions) {\n+        if (actions == null) {\n+            throw new IllegalArgumentException(\"actions cannot be null\");\n+        }\n+        if (actions.getClass().getName().equals(LcnModuleActions.class.getName())) {\n+            if (actions instanceof LcnModuleActions) {\n+                return (LcnModuleActions) actions;\n+            } else {\n+                return (LcnModuleActions) Proxy.newProxyInstance(LcnModuleActions.class.getClassLoader(),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f286ec5e63678277ee6c0c42b0e316ffb3997d38"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODMzMzc4Ng==", "bodyText": "You should try to cache the configuration instances in your initialize() method since they are pretty costly to construct.", "url": "https://github.com/openhab/openhab-addons/pull/7509#discussion_r438333786", "createdAt": "2020-06-10T18:40:41Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.lcn/src/main/java/org/openhab/binding/lcn/internal/PckGatewayHandler.java", "diffHunk": "@@ -0,0 +1,301 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.lcn.internal;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Optional;\n+import java.util.function.Consumer;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseBridgeHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.openhab.binding.lcn.internal.common.LcnAddr;\n+import org.openhab.binding.lcn.internal.common.LcnAddrMod;\n+import org.openhab.binding.lcn.internal.common.LcnDefs;\n+import org.openhab.binding.lcn.internal.common.LcnDefs.OutputPortDimMode;\n+import org.openhab.binding.lcn.internal.common.LcnException;\n+import org.openhab.binding.lcn.internal.connection.Connection;\n+import org.openhab.binding.lcn.internal.connection.ConnectionCallback;\n+import org.openhab.binding.lcn.internal.connection.ConnectionSettings;\n+import org.openhab.binding.lcn.internal.connection.ModInfo;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link PckGatewayHandler} is responsible for the communication via a PCK gateway.\n+ *\n+ * @author Fabian Wolter - Initial contribution\n+ */\n+@NonNullByDefault\n+public class PckGatewayHandler extends BaseBridgeHandler {\n+    private final Logger logger = LoggerFactory.getLogger(PckGatewayHandler.class);\n+    private @Nullable Connection connection;\n+    private Optional<Consumer<String>> pckListener = Optional.empty();\n+\n+    public PckGatewayHandler(Bridge bridge) {\n+        super(bridge);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        // nothing\n+    }\n+\n+    @Override\n+    public synchronized void initialize() {\n+        PckGatewayConfiguration config = getConfigAs(PckGatewayConfiguration.class);\n+\n+        String errorMessage = \"Could not connect to LCN-PCHK/PKE: \" + config.getHostname() + \": \";\n+\n+        try {\n+            OutputPortDimMode dimMode;\n+            String mode = config.getMode();\n+            if (LcnDefs.OutputPortDimMode.NATIVE50.name().equalsIgnoreCase(mode)) {\n+                dimMode = LcnDefs.OutputPortDimMode.NATIVE50;\n+            } else if (LcnDefs.OutputPortDimMode.NATIVE200.name().equalsIgnoreCase(mode)) {\n+                dimMode = LcnDefs.OutputPortDimMode.NATIVE200;\n+            } else {\n+                throw new LcnException(\"DimMode \" + mode + \" is not supported\");\n+            }\n+\n+            ConnectionSettings settings = new ConnectionSettings(\"0\", config.getHostname(), config.getPort(),\n+                    config.getUsername(), config.getPassword(), dimMode, LcnDefs.OutputPortStatusMode.PERCENT,\n+                    config.getTimeoutMs());\n+\n+            connection = new Connection(settings, scheduler, new ConnectionCallback() {\n+                @Override\n+                public void onOnline() {\n+                    updateStatus(ThingStatus.ONLINE);\n+                }\n+\n+                @Override\n+                public void onOffline(@Nullable String errorMessage) {\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, errorMessage + \".\");\n+                }\n+\n+                @Override\n+                public void onPckMessageReceived(String message) {\n+                    pckListener.ifPresent(l -> l.accept(message));\n+                    getThing().getThings().stream().filter(t -> t.getStatus() == ThingStatus.ONLINE).map(t -> {\n+                        LcnModuleHandler handler = (LcnModuleHandler) t.getHandler();\n+                        if (handler == null) {\n+                            logger.warn(\"Failed to process PCK message: Handler not set\");\n+                        }\n+                        return handler;\n+                    }).filter(h -> h != null).forEach(h -> h.handleStatusMessage(message));\n+                }\n+            });\n+\n+            updateStatus(ThingStatus.UNKNOWN);\n+        } catch (LcnException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, errorMessage + e.getMessage());\n+        }\n+    }\n+\n+    @Override\n+    public Collection<Class<? extends ThingHandlerService>> getServices() {\n+        return Collections.singleton(LcnModuleDiscoveryService.class);\n+    }\n+\n+    @Override\n+    public void childHandlerDisposed(ThingHandler childHandler, Thing childThing) {\n+        if (childThing.getThingTypeUID().equals(LcnBindingConstants.THING_TYPE_MODULE)\n+                || childThing.getThingTypeUID().equals(LcnBindingConstants.THING_TYPE_GROUP)) {\n+            try {\n+                LcnAddr addr = getLcnAddrFromThing(childThing);\n+                Connection localConnection = connection;\n+                if (localConnection != null) {\n+                    localConnection.removeLcnModule(addr);\n+                }\n+            } catch (LcnException e) {\n+                logger.warn(\"Failed to read configuration: {}\", e.getMessage());\n+            }\n+        }\n+    }\n+\n+    private LcnAddr getLcnAddrFromThing(Thing childThing) throws LcnException {\n+        LcnModuleHandler lcnModuleHandler = (LcnModuleHandler) childThing.getHandler();\n+        if (lcnModuleHandler != null) {\n+            return lcnModuleHandler.getCommandAddress();\n+        } else {\n+            throw new LcnException(\"Could not get module handler\");\n+        }\n+    }\n+\n+    /**\n+     * Enqueues a PCK (String) command to be sent to an LCN module.\n+     *\n+     * @param addr the modules address\n+     * @param wantsAck true, if the module shall send an ACK upon successful processing\n+     * @param pck the command to send\n+     */\n+    public void queue(LcnAddr addr, boolean wantsAck, String pck) {\n+        Connection localConnection = connection;\n+        if (localConnection != null) {\n+            localConnection.queue(addr, wantsAck, pck);\n+        } else {\n+            logger.warn(\"Dropped PCK command: {}\", pck);\n+        }\n+    }\n+\n+    /**\n+     * Enqueues a PCK (ByteBuffer) command to be sent to an LCN module.\n+     *\n+     * @param addr the modules address\n+     * @param wantsAck true, if the module shall send an ACK upon successful processing\n+     * @param pck the command to send\n+     */\n+    public void queue(LcnAddr addr, boolean wantsAck, byte[] pck) {\n+        Connection localConnection = connection;\n+        if (localConnection != null) {\n+            localConnection.queue(addr, wantsAck, pck);\n+        } else {\n+            logger.warn(\"Dropped PCK command of length: {}\", pck.length);\n+        }\n+    }\n+\n+    /**\n+     * Sends a broadcast message to all LCN modules: All LCN modules are requested to answer with an Ack.\n+     */\n+    void sendModuleDiscoveryCommand() {\n+        Connection localConnection = connection;\n+        if (localConnection != null) {\n+            localConnection.sendModuleDiscoveryCommand();\n+        }\n+    }\n+\n+    /**\n+     * Send a request to an LCN module to respond with its serial number and firmware version.\n+     *\n+     * @param addr the module's address\n+     */\n+    void sendSerialNumberRequest(LcnAddrMod addr) {\n+        Connection localConnection = connection;\n+        if (localConnection != null) {\n+            localConnection.sendSerialNumberRequest(addr);\n+        }\n+    }\n+\n+    /**\n+     * Send a request to an LCN module to respond with its configured name.\n+     *\n+     * @param addr the module's address\n+     */\n+    void sendModuleNameRequest(LcnAddrMod addr) {\n+        Connection localConnection = connection;\n+        if (localConnection != null) {\n+            localConnection.sendModuleNameRequest(addr);\n+        }\n+    }\n+\n+    /**\n+     * Returns the ModInfo to a given module. Will be created if it doesn't exist,yet.\n+     *\n+     * @param addr the module's address\n+     * @return the ModInfo\n+     * @throws LcnException when this handler is not initialized, yet\n+     */\n+    ModInfo getModInfo(LcnAddrMod addr) throws LcnException {\n+        Connection localConnection = connection;\n+        if (localConnection != null) {\n+            return localConnection.updateModuleData(addr);\n+        } else {\n+            throw new LcnException(\"Connection is null\");\n+        }\n+    }\n+\n+    /**\n+     * Registers a listener to receive all PCK messages from this PCK gateway.\n+     *\n+     * @param listener the listener to add\n+     */\n+    void registerPckListener(Consumer<String> listener) {\n+        this.pckListener = Optional.of(listener);\n+    }\n+\n+    /**\n+     * Removes all listeners for PCK messages from this PCK gateway.\n+     */\n+    void removeAllPckListeners() {\n+        this.pckListener = Optional.empty();\n+    }\n+\n+    /**\n+     * Gets the Connection for this handler.\n+     *\n+     * @return the Connection\n+     */\n+    @Nullable\n+    public Connection getConnection() {\n+        return connection;\n+    }\n+\n+    /**\n+     * Gets the local segment ID. When no segments are used, the value is 0.\n+     *\n+     * @return the local segment ID\n+     */\n+    public int getLocalSegmentId() {\n+        Connection localConnection = connection;\n+        if (localConnection != null) {\n+            return localConnection.getLocalSegId();\n+        } else {\n+            return 0;\n+        }\n+    }\n+\n+    /**\n+     * Translates the given physical segment ID (0 or 4 if local segment) to the logical segment ID (local segment ID).\n+     *\n+     * @param physicalSegmentId the segment ID to convert\n+     * @return the converted segment ID\n+     */\n+    public int toLogicalSegmentId(int physicalSegmentId) {\n+        int localSegmentId = getLocalSegmentId();\n+        if ((physicalSegmentId == 0 || physicalSegmentId == 4) && localSegmentId != -1) {\n+            // PCK message came from local segment\n+            // physicalSegmentId == 0 => Module is programmed to send status messages to local segment only\n+            // physicalSegmentId == 4 => Module is programmed to send status messages globally (to all segments)\n+            // or segment coupler scan did not finish, yet (-1). Assume local segment, then.\n+            return localSegmentId;\n+        } else {\n+            return physicalSegmentId;\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        Connection localConnection = connection;\n+        if (localConnection != null) {\n+            localConnection.shutdown();\n+        }\n+    }\n+\n+    /**\n+     * Gets the configured connection timeout for the PCK gateway.\n+     *\n+     * @return the timeout in ms\n+     */\n+    public long getTimeoutMs() {\n+        return getConfigAs(PckGatewayConfiguration.class).getTimeoutMs();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7384be9252bcb0aeb89efeada0f9fa255c15f424"}, "originalPosition": 299}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODM0Mjc0MQ==", "bodyText": "This should allow you to make thresholdNumber final.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private final int number;\n          \n          \n            \n                private Optional<Integer> thresholdNumber = Optional.empty();\n          \n          \n            \n                private final Type type;\n          \n          \n            \n                private final LcnChannelGroup channelGroup;\n          \n          \n            \n            \n          \n          \n            \n                /**\n          \n          \n            \n                 * Defines the origin of an LCN variable.\n          \n          \n            \n                 */\n          \n          \n            \n                public enum Type {\n          \n          \n            \n                    UNKNOWN,\n          \n          \n            \n                    VARIABLE,\n          \n          \n            \n                    REGULATOR,\n          \n          \n            \n                    THRESHOLD,\n          \n          \n            \n                    S0INPUT\n          \n          \n            \n                }\n          \n          \n            \n            \n          \n          \n            \n                Variable(int number, Type type, LcnChannelGroup channelGroup) {\n          \n          \n            \n                    this.number = number;\n          \n          \n            \n                    this.type = type;\n          \n          \n            \n                    this.channelGroup = channelGroup;\n          \n          \n            \n                }\n          \n          \n            \n            \n          \n          \n            \n                Variable(int number, int thresholdNumber, Type type, LcnChannelGroup channelGroup) {\n          \n          \n            \n                    this(number, type, channelGroup);\n          \n          \n            \n                    this.thresholdNumber = Optional.of(thresholdNumber);\n          \n          \n            \n                }\n          \n          \n            \n                private final int number;\n          \n          \n            \n                private final Optional<Integer> thresholdNumber;\n          \n          \n            \n                private final Type type;\n          \n          \n            \n                private final LcnChannelGroup channelGroup;\n          \n          \n            \n            \n          \n          \n            \n                /**\n          \n          \n            \n                 * Defines the origin of an LCN variable.\n          \n          \n            \n                 */\n          \n          \n            \n                public enum Type {\n          \n          \n            \n                    UNKNOWN,\n          \n          \n            \n                    VARIABLE,\n          \n          \n            \n                    REGULATOR,\n          \n          \n            \n                    THRESHOLD,\n          \n          \n            \n                    S0INPUT\n          \n          \n            \n                }\n          \n          \n            \n            \n          \n          \n            \n                Variable(int number, Type type, LcnChannelGroup channelGroup) {\n          \n          \n            \n                    this(number, Optional.empty(), type, channelGroup);\n          \n          \n            \n                }\n          \n          \n            \n            \n          \n          \n            \n                Variable(int number, int thresholdNumber, Type type, LcnChannelGroup channelGroup) {\n          \n          \n            \n                    this(number, Optional.of(thresholdNumber), type, channelGroup);\n          \n          \n            \n                }\n          \n          \n            \n                \n          \n          \n            \n                Variable(int number, Optional<Integer> thresholdNumber, Type type, LcnChannelGroup channelGroup) {\n          \n          \n            \n                    this.number = number;\n          \n          \n            \n                    this.type = type;\n          \n          \n            \n                    this.channelGroup = channelGroup;\n          \n          \n            \n                    this.thresholdNumber = thresholdNumber;\n          \n          \n            \n                }", "url": "https://github.com/openhab/openhab-addons/pull/7509#discussion_r438342741", "createdAt": "2020-06-10T18:57:22Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.lcn/src/main/java/org/openhab/binding/lcn/internal/common/Variable.java", "diffHunk": "@@ -0,0 +1,274 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.lcn.internal.common;\n+\n+import java.util.Optional;\n+import java.util.function.Predicate;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.binding.lcn.internal.LcnBindingConstants;\n+\n+/**\n+ * LCN variable types.\n+ *\n+ * @author Tobias J\u00fcttner - Initial Contribution\n+ * @author Fabian Wolter - Migration to OH2\n+ */\n+@NonNullByDefault\n+public enum Variable {\n+    UNKNOWN(0, Type.UNKNOWN, LcnChannelGroup.VARIABLE), // Used if the real type is not known (yet)\n+    VARIABLE1(0, Type.VARIABLE, LcnChannelGroup.VARIABLE), // or TVar\n+    VARIABLE2(1, Type.VARIABLE, LcnChannelGroup.VARIABLE),\n+    VARIABLE3(2, Type.VARIABLE, LcnChannelGroup.VARIABLE),\n+    VARIABLE4(3, Type.VARIABLE, LcnChannelGroup.VARIABLE),\n+    VARIABLE5(4, Type.VARIABLE, LcnChannelGroup.VARIABLE),\n+    VARIABLE6(5, Type.VARIABLE, LcnChannelGroup.VARIABLE),\n+    VARIABLE7(6, Type.VARIABLE, LcnChannelGroup.VARIABLE),\n+    VARIABLE8(7, Type.VARIABLE, LcnChannelGroup.VARIABLE),\n+    VARIABLE9(8, Type.VARIABLE, LcnChannelGroup.VARIABLE),\n+    VARIABLE10(9, Type.VARIABLE, LcnChannelGroup.VARIABLE),\n+    VARIABLE11(10, Type.VARIABLE, LcnChannelGroup.VARIABLE),\n+    VARIABLE12(11, Type.VARIABLE, LcnChannelGroup.VARIABLE), // Since 170206\n+    RVARSETPOINT1(0, Type.REGULATOR, LcnChannelGroup.RVARSETPOINT),\n+    RVARSETPOINT2(1, Type.REGULATOR, LcnChannelGroup.RVARSETPOINT), // Set-points for regulators\n+    THRESHOLDREGISTER11(0, 0, Type.THRESHOLD, LcnChannelGroup.THRESHOLDREGISTER1),\n+    THRESHOLDREGISTER12(0, 1, Type.THRESHOLD, LcnChannelGroup.THRESHOLDREGISTER1),\n+    THRESHOLDREGISTER13(0, 2, Type.THRESHOLD, LcnChannelGroup.THRESHOLDREGISTER1),\n+    THRESHOLDREGISTER14(0, 3, Type.THRESHOLD, LcnChannelGroup.THRESHOLDREGISTER1),\n+    // Register 1 (THRESHOLDREGISTER15 only before 170206)\n+    THRESHOLDREGISTER15(0, 4, Type.THRESHOLD, LcnChannelGroup.THRESHOLDREGISTER1),\n+    THRESHOLDREGISTER21(1, 0, Type.THRESHOLD, LcnChannelGroup.THRESHOLDREGISTER2),\n+    THRESHOLDREGISTER22(1, 1, Type.THRESHOLD, LcnChannelGroup.THRESHOLDREGISTER2),\n+    THRESHOLDREGISTER23(1, 2, Type.THRESHOLD, LcnChannelGroup.THRESHOLDREGISTER2),\n+    THRESHOLDREGISTER24(1, 3, Type.THRESHOLD, LcnChannelGroup.THRESHOLDREGISTER2), // Register 2 (since 2012)\n+    THRESHOLDREGISTER31(2, 0, Type.THRESHOLD, LcnChannelGroup.THRESHOLDREGISTER3),\n+    THRESHOLDREGISTER32(2, 1, Type.THRESHOLD, LcnChannelGroup.THRESHOLDREGISTER3),\n+    THRESHOLDREGISTER33(2, 2, Type.THRESHOLD, LcnChannelGroup.THRESHOLDREGISTER3),\n+    THRESHOLDREGISTER34(2, 3, Type.THRESHOLD, LcnChannelGroup.THRESHOLDREGISTER3), // Register 3 (since 2012)\n+    THRESHOLDREGISTER41(3, 0, Type.THRESHOLD, LcnChannelGroup.THRESHOLDREGISTER4),\n+    THRESHOLDREGISTER42(3, 1, Type.THRESHOLD, LcnChannelGroup.THRESHOLDREGISTER4),\n+    THRESHOLDREGISTER43(3, 2, Type.THRESHOLD, LcnChannelGroup.THRESHOLDREGISTER4),\n+    THRESHOLDREGISTER44(3, 3, Type.THRESHOLD, LcnChannelGroup.THRESHOLDREGISTER4), // Register 4 (since 2012)\n+    S0INPUT1(0, Type.S0INPUT, LcnChannelGroup.S0INPUT),\n+    S0INPUT2(1, Type.S0INPUT, LcnChannelGroup.S0INPUT),\n+    S0INPUT3(2, Type.S0INPUT, LcnChannelGroup.S0INPUT),\n+    S0INPUT4(3, Type.S0INPUT, LcnChannelGroup.S0INPUT); // LCN-BU4L\n+\n+    private final int number;\n+    private Optional<Integer> thresholdNumber = Optional.empty();\n+    private final Type type;\n+    private final LcnChannelGroup channelGroup;\n+\n+    /**\n+     * Defines the origin of an LCN variable.\n+     */\n+    public enum Type {\n+        UNKNOWN,\n+        VARIABLE,\n+        REGULATOR,\n+        THRESHOLD,\n+        S0INPUT\n+    }\n+\n+    Variable(int number, Type type, LcnChannelGroup channelGroup) {\n+        this.number = number;\n+        this.type = type;\n+        this.channelGroup = channelGroup;\n+    }\n+\n+    Variable(int number, int thresholdNumber, Type type, LcnChannelGroup channelGroup) {\n+        this(number, type, channelGroup);\n+        this.thresholdNumber = Optional.of(thresholdNumber);\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7384be9252bcb0aeb89efeada0f9fa255c15f424"}, "originalPosition": 93}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODM4NjI1Nw==", "bodyText": "You should probably make this the default implementation of this method in AbstractConnectionState.", "url": "https://github.com/openhab/openhab-addons/pull/7509#discussion_r438386257", "createdAt": "2020-06-10T20:22:26Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.lcn/src/main/java/org/openhab/binding/lcn/internal/connection/ConnectionStateSegmentScan.java", "diffHunk": "@@ -0,0 +1,89 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.lcn.internal.connection;\n+\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.binding.lcn.internal.common.LcnAddr;\n+import org.openhab.binding.lcn.internal.common.LcnAddrGrp;\n+import org.openhab.binding.lcn.internal.common.LcnException;\n+import org.openhab.binding.lcn.internal.common.PckGenerator;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * This state discovers the LCN segment couplers.\n+ *\n+ * After the authorization against the LCN-PCK gateway was successful, the LCN segment couplers are discovery, to\n+ * retrieve the segment ID of the local segment. When no segment couplers were found, a timeout sets the local segment\n+ * ID to 0.\n+ *\n+ * @author Fabian Wolter - Initial Contribution\n+ */\n+@NonNullByDefault\n+public class ConnectionStateSegmentScan extends AbstractConnectionState {\n+    private final Logger logger = LoggerFactory.getLogger(ConnectionStateSegmentScan.class);\n+    public static final Pattern PATTERN_SK_RESPONSE = Pattern\n+            .compile(\"=M(?<segId>\\\\d{3})(?<modId>\\\\d{3})\\\\.SK(?<id>\\\\d+)\");\n+    private final RequestStatus statusSegmentScan = new RequestStatus(-1, 3, \"Segment Scan\");\n+\n+    public ConnectionStateSegmentScan(StateContext context, ScheduledExecutorService scheduler) {\n+        super(context, scheduler);\n+    }\n+\n+    @Override\n+    public void startWorking() {\n+        statusSegmentScan.refresh();\n+        addTimer(scheduler.scheduleWithFixedDelay(this::update, 0, 500, TimeUnit.MILLISECONDS));\n+    }\n+\n+    private void update() {\n+        long currTime = System.nanoTime();\n+        try {\n+            if (statusSegmentScan.shouldSendNextRequest(connection.getSettings().getTimeout(), currTime)) {\n+                connection.queueDirectly(new LcnAddrGrp(3, 3), false, PckGenerator.segmentCouplerScan());\n+                statusSegmentScan.onRequestSent(currTime);\n+            }\n+        } catch (LcnException e) {\n+            // Give up. Probably no segments available.\n+            connection.setLocalSegId(0);\n+            logger.debug(\"No segment couplers detected\");\n+            nextState(ConnectionStateConnected.class);\n+        }\n+    }\n+\n+    @Override\n+    public void queue(LcnAddr addr, boolean wantsAck, byte[] data) {\n+        connection.queueOffline(addr, wantsAck, data);\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7384be9252bcb0aeb89efeada0f9fa255c15f424"}, "originalPosition": 72}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "55f98964ceda94d860f5904b336419ce182f88d8", "author": {"user": {"login": "fwolter", "name": "Fabian Wolter"}}, "url": "https://github.com/openhab/openhab-addons/commit/55f98964ceda94d860f5904b336419ce182f88d8", "committedDate": "2020-06-10T21:02:59Z", "message": "Incorporate review feedback\n\nSigned-off-by: Fabian Wolter <github@fabian-wolter.de>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI4NDMzNjI4", "url": "https://github.com/openhab/openhab-addons/pull/7509#pullrequestreview-428433628", "createdAt": "2020-06-10T21:15:19Z", "commit": {"oid": "55f98964ceda94d860f5904b336419ce182f88d8"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMFQyMToxNToyMFrOGiGlFw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMFQyMToxNToyMFrOGiGlFw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQxMjU2Nw==", "bodyText": "I'm not sure that this works. To my knowledge the type check occurs in the caller, not around this generic cast.", "url": "https://github.com/openhab/openhab-addons/pull/7509#discussion_r438412567", "createdAt": "2020-06-10T21:15:20Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.lcn/src/main/java/org/openhab/binding/lcn/internal/LcnModuleHandler.java", "diffHunk": "@@ -0,0 +1,380 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.lcn.internal;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+import java.util.Optional;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.HSBType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StopMoveType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.library.types.UpDownType;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.lcn.internal.common.DimmerOutputCommand;\n+import org.openhab.binding.lcn.internal.common.LcnAddr;\n+import org.openhab.binding.lcn.internal.common.LcnAddrMod;\n+import org.openhab.binding.lcn.internal.common.LcnChannelGroup;\n+import org.openhab.binding.lcn.internal.common.LcnException;\n+import org.openhab.binding.lcn.internal.connection.Connection;\n+import org.openhab.binding.lcn.internal.connection.ModInfo;\n+import org.openhab.binding.lcn.internal.converter.Converter;\n+import org.openhab.binding.lcn.internal.converter.Converters;\n+import org.openhab.binding.lcn.internal.converter.S0Converter;\n+import org.openhab.binding.lcn.internal.subhandler.AbstractLcnModuleSubHandler;\n+import org.openhab.binding.lcn.internal.subhandler.LcnModuleMetaAckSubHandler;\n+import org.openhab.binding.lcn.internal.subhandler.LcnModuleMetaFirmwareSubHandler;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link LcnModuleHandler} is responsible for handling commands, which are\n+ * sent to or received from one of the channels.\n+ *\n+ * @author Fabian Wolter - Initial contribution\n+ */\n+@NonNullByDefault\n+public class LcnModuleHandler extends BaseThingHandler {\n+    private final Logger logger = LoggerFactory.getLogger(LcnModuleHandler.class);\n+    private static final Map<String, Converter> CONVERTERS = new HashMap<>();\n+    private @Nullable LcnAddrMod moduleAddress;\n+    private final Map<LcnChannelGroup, @Nullable AbstractLcnModuleSubHandler> subHandlers = new HashMap<>();\n+    private final List<AbstractLcnModuleSubHandler> metadataSubHandlers = new ArrayList<>();\n+    private final Map<ChannelUID, @Nullable Converter> converters = new HashMap<>();\n+\n+    static {\n+        CONVERTERS.put(\"temperature\", Converters.TEMPERATURE);\n+        CONVERTERS.put(\"light\", Converters.LIGHT);\n+        CONVERTERS.put(\"co2\", Converters.CO2);\n+        CONVERTERS.put(\"current\", Converters.CURRENT);\n+        CONVERTERS.put(\"voltage\", Converters.VOLTAGE);\n+        CONVERTERS.put(\"angle\", Converters.ANGLE);\n+        CONVERTERS.put(\"windspeed\", Converters.WINDSPEED);\n+    }\n+\n+    public LcnModuleHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        LcnModuleConfiguration localConfig = getConfigAs(LcnModuleConfiguration.class);\n+        LcnAddrMod localModuleAddress = moduleAddress = new LcnAddrMod(localConfig.segmentId, localConfig.moduleId);\n+\n+        try {\n+            // create sub handlers\n+            ModInfo info = getPckGatewayHandler().getModInfo(localModuleAddress);\n+            for (LcnChannelGroup type : LcnChannelGroup.values()) {\n+                subHandlers.put(type, type.createSubHandler(this, info));\n+            }\n+\n+            // meta sub handlers, which are not assigned to a channel group\n+            metadataSubHandlers.add(new LcnModuleMetaAckSubHandler(this, info));\n+            metadataSubHandlers.add(new LcnModuleMetaFirmwareSubHandler(this, info));\n+\n+            // initialize variable value converters\n+            for (Channel channel : thing.getChannels()) {\n+                Object unitObject = channel.getConfiguration().get(\"unit\");\n+                Object parameterObject = channel.getConfiguration().get(\"parameter\");\n+\n+                if (unitObject instanceof String) {\n+                    switch ((String) unitObject) {\n+                        case \"power\":\n+                        case \"energy\":\n+                            converters.put(channel.getUID(), new S0Converter(parameterObject));\n+                            break;\n+                        default:\n+                            if (CONVERTERS.containsKey(unitObject)) {\n+                                converters.put(channel.getUID(), CONVERTERS.get(unitObject));\n+                            }\n+                            break;\n+                    }\n+                }\n+            }\n+\n+            // module is assumed as online, when the corresponding Bridge (PckGatewayHandler) is online.\n+            updateStatus(ThingStatus.ONLINE);\n+        } catch (LcnException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, e.getMessage());\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUid, Command command) {\n+        try {\n+            String groupId = channelUid.getGroupId();\n+\n+            if (!channelUid.isInGroup()) {\n+                return;\n+            }\n+\n+            if (groupId == null) {\n+                throw new LcnException(\"Group ID is null\");\n+            }\n+\n+            LcnChannelGroup channelGroup = LcnChannelGroup.valueOf(groupId.toUpperCase());\n+            AbstractLcnModuleSubHandler subHandler = subHandlers.get(channelGroup);\n+\n+            if (subHandler == null) {\n+                throw new LcnException(\"Sub Handler not found for: \" + channelGroup);\n+            }\n+\n+            Optional<Integer> number = channelUidToChannelNumber(channelUid, channelGroup);\n+\n+            if (command instanceof RefreshType) {\n+                number.ifPresent(n -> subHandler.handleRefresh(channelGroup, n));\n+                subHandler.handleRefresh(channelUid.getIdWithoutGroup());\n+            } else if (command instanceof OnOffType) {\n+                subHandler.handleCommandOnOff(castCommand(command), channelGroup, number.get());\n+            } else if (command instanceof DimmerOutputCommand) {\n+                subHandler.handleCommandDimmerOutput(castCommand(command), number.get());\n+            } else if (command instanceof PercentType && number.isPresent()) {\n+                subHandler.handleCommandPercent(castCommand(command), channelGroup, number.get());\n+            } else if (command instanceof HSBType) {\n+                subHandler.handleCommandHsb(castCommand(command), channelUid.getIdWithoutGroup());\n+            } else if (command instanceof PercentType) {\n+                subHandler.handleCommandPercent(castCommand(command), channelGroup, channelUid.getIdWithoutGroup());\n+            } else if (command instanceof StringType) {\n+                subHandler.handleCommandString(castCommand(command), number.get());\n+            } else if (command instanceof DecimalType) {\n+                DecimalType decimalType = castCommand(command);\n+                DecimalType nativeValue = getConverter(channelUid).onCommandFromItem(decimalType.doubleValue());\n+                subHandler.handleCommandDecimal(nativeValue, channelGroup, number.get());\n+            } else if (command instanceof QuantityType) {\n+                QuantityType<?> quantityType = castCommand(command);\n+                DecimalType nativeValue = getConverter(channelUid).onCommandFromItem(quantityType);\n+                subHandler.handleCommandDecimal(nativeValue, channelGroup, number.get());\n+            } else if (command instanceof UpDownType) {\n+                subHandler.handleCommandUpDown(castCommand(command), channelGroup, number.get());\n+            } else if (command instanceof StopMoveType) {\n+                subHandler.handleCommandStopMove(castCommand(command), channelGroup, number.get());\n+            } else {\n+                throw new LcnException(\"Unsupported command type\");\n+            }\n+        } catch (IllegalArgumentException | NoSuchElementException | LcnException e) {\n+            logger.warn(\"{}: Failed to handle command {}: {}\", channelUid, command.getClass().getSimpleName(),\n+                    e.getMessage());\n+        }\n+    }\n+\n+    @NonNullByDefault({}) // getOrDefault()\n+    private Converter getConverter(ChannelUID channelUid) {\n+        return converters.getOrDefault(channelUid, Converters.IDENTITY);\n+    }\n+\n+    /**\n+     * Convenience method to cast a command.\n+     *\n+     * @param <T> the concrete type to be casted to\n+     * @param command the command to be casted\n+     * @return the concrete command\n+     * @throws LcnException when the command cannot be casted\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    private <T extends Command> T castCommand(Command command) throws LcnException {\n+        try {\n+            return (T) command;\n+        } catch (ClassCastException e) {\n+            throw new LcnException(\"Unexpected command type\");\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "55f98964ceda94d860f5904b336419ce182f88d8"}, "originalPosition": 210}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8d692ad7724548be4563c7b5309e1215ed73ca83", "author": {"user": {"login": "fwolter", "name": "Fabian Wolter"}}, "url": "https://github.com/openhab/openhab-addons/commit/8d692ad7724548be4563c7b5309e1215ed73ca83", "committedDate": "2020-06-10T21:27:25Z", "message": "Incorporate review feedback #3\n\nSigned-off-by: Fabian Wolter <github@fabian-wolter.de>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI4NDM4MzA2", "url": "https://github.com/openhab/openhab-addons/pull/7509#pullrequestreview-428438306", "createdAt": "2020-06-10T21:23:18Z", "commit": {"oid": "55f98964ceda94d860f5904b336419ce182f88d8"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMFQyMToyMzoxOFrOGiGy6A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMFQyMTozMDowMVrOGiG-zg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQxNjEwNA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                @Nullable\n          \n          \n            \n                private PckGatewayConfiguration config;\n          \n          \n            \n                private @Nullable PckGatewayConfiguration config;", "url": "https://github.com/openhab/openhab-addons/pull/7509#discussion_r438416104", "createdAt": "2020-06-10T21:23:18Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.lcn/src/main/java/org/openhab/binding/lcn/internal/PckGatewayHandler.java", "diffHunk": "@@ -50,6 +50,8 @@\n     private final Logger logger = LoggerFactory.getLogger(PckGatewayHandler.class);\n     private @Nullable Connection connection;\n     private Optional<Consumer<String>> pckListener = Optional.empty();\n+    @Nullable\n+    private PckGatewayConfiguration config;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "55f98964ceda94d860f5904b336419ce182f88d8"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQxNzQ3NQ==", "bodyText": "calling the super's destructor should usually be done last.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    super.deactivate();\n          \n          \n            \n                    stopScan();\n          \n          \n            \n                    stopScan();\n          \n          \n            \n                    super.deactivate();", "url": "https://github.com/openhab/openhab-addons/pull/7509#discussion_r438417475", "createdAt": "2020-06-10T21:26:14Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.lcn/src/main/java/org/openhab/binding/lcn/internal/LcnModuleDiscoveryService.java", "diffHunk": "@@ -0,0 +1,264 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.lcn.internal;\n+\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Queue;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentLinkedQueue;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.config.discovery.AbstractDiscoveryService;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResultBuilder;\n+import org.eclipse.smarthome.config.discovery.DiscoveryService;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.thing.ThingUID;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.openhab.binding.lcn.internal.common.LcnAddrMod;\n+import org.openhab.binding.lcn.internal.connection.Connection;\n+import org.openhab.binding.lcn.internal.subhandler.LcnModuleMetaAckSubHandler;\n+import org.openhab.binding.lcn.internal.subhandler.LcnModuleMetaFirmwareSubHandler;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Scans all LCN segments for LCN modules.\n+ *\n+ * Scan approach:\n+ * 1. Send \"Leerkomando\" to the broadcast address with request for Ack set\n+ * 2. For every received Ack, send the following requests to the module:\n+ * - serial number request (SN)\n+ * - module's name first part request (NM1)\n+ * - module's name second part request (NM2)\n+ * 3. When all three messages have been received, fire thingDiscovered()\n+ *\n+ * @author Fabian Wolter - Initial Contribution\n+ */\n+@NonNullByDefault\n+public class LcnModuleDiscoveryService extends AbstractDiscoveryService\n+        implements DiscoveryService, ThingHandlerService {\n+    private final Logger logger = LoggerFactory.getLogger(LcnModuleDiscoveryService.class);\n+    private static final Pattern NAME_PATTERN = Pattern\n+            .compile(\"=M(?<segId>\\\\d{3})(?<modId>\\\\d{3}).N(?<part>[1-2]{1})(?<name>.*)\");\n+    private static final String SEGMENT_ID = \"segmentId\";\n+    private static final String MODULE_ID = \"moduleId\";\n+    private static final String SERIAL_NUMBER = \"serialNumber\";\n+    private static final int MODULE_NAME_PART_COUNT = 2;\n+    private static final int DISCOVERY_TIMEOUT_SEC = 90;\n+    private static final int ACK_TIMEOUT_MS = 1000;\n+    private static final Set<ThingTypeUID> SUPPORTED_THING_TYPES_UIDS = Collections\n+            .unmodifiableSet(Stream.of(LcnBindingConstants.THING_TYPE_MODULE).collect(Collectors.toSet()));\n+    private @Nullable PckGatewayHandler bridgeHandler;\n+    private final Map<LcnAddrMod, @Nullable Map<Integer, String>> moduleNames = new HashMap<>();\n+    private final Map<LcnAddrMod, DiscoveryResultBuilder> discoveryResultBuilders = new ConcurrentHashMap<>();\n+    private final List<LcnAddrMod> successfullyDiscovered = new LinkedList<>();\n+    private final Queue<@Nullable LcnAddrMod> serialNumberRequestQueue = new ConcurrentLinkedQueue<>();\n+    private final Queue<@Nullable LcnAddrMod> moduleNameRequestQueue = new ConcurrentLinkedQueue<>();\n+    private @Nullable volatile ScheduledFuture<?> queueProcessor;\n+    private @Nullable ScheduledFuture<?> builderTask;\n+\n+    public LcnModuleDiscoveryService() {\n+        super(SUPPORTED_THING_TYPES_UIDS, DISCOVERY_TIMEOUT_SEC, false);\n+    }\n+\n+    @Override\n+    public void setThingHandler(@Nullable ThingHandler handler) {\n+        if (handler instanceof PckGatewayHandler) {\n+            this.bridgeHandler = (PckGatewayHandler) handler;\n+        }\n+    }\n+\n+    @Override\n+    public @Nullable ThingHandler getThingHandler() {\n+        return bridgeHandler;\n+    }\n+\n+    @Override\n+    public void deactivate() {\n+        super.deactivate();\n+        stopScan();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "55f98964ceda94d860f5904b336419ce182f88d8"}, "originalPosition": 102}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQxOTE1MA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        } else if (command instanceof PercentType && number.isPresent()) {\n          \n          \n            \n                            subHandler.handleCommandPercent(castCommand(command), channelGroup, number.get());\n          \n          \n            \n                        } else if (command instanceof HSBType) {\n          \n          \n            \n                            subHandler.handleCommandHsb(castCommand(command), channelUid.getIdWithoutGroup());\n          \n          \n            \n                        } else if (command instanceof PercentType) {\n          \n          \n            \n                            subHandler.handleCommandPercent(castCommand(command), channelGroup, channelUid.getIdWithoutGroup());\n          \n          \n            \n                        } else if (command instanceof PercentType && number.isPresent()) {\n          \n          \n            \n                            subHandler.handleCommandPercent(castCommand(command), channelGroup, number.orElse(channelUid.getIdWithoutGroup()));\n          \n          \n            \n                        } else if (command instanceof HSBType) {\n          \n          \n            \n                            subHandler.handleCommandHsb(castCommand(command), channelUid.getIdWithoutGroup());", "url": "https://github.com/openhab/openhab-addons/pull/7509#discussion_r438419150", "createdAt": "2020-06-10T21:30:01Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.lcn/src/main/java/org/openhab/binding/lcn/internal/LcnModuleHandler.java", "diffHunk": "@@ -0,0 +1,380 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.lcn.internal;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+import java.util.Optional;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.HSBType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StopMoveType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.library.types.UpDownType;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.lcn.internal.common.DimmerOutputCommand;\n+import org.openhab.binding.lcn.internal.common.LcnAddr;\n+import org.openhab.binding.lcn.internal.common.LcnAddrMod;\n+import org.openhab.binding.lcn.internal.common.LcnChannelGroup;\n+import org.openhab.binding.lcn.internal.common.LcnException;\n+import org.openhab.binding.lcn.internal.connection.Connection;\n+import org.openhab.binding.lcn.internal.connection.ModInfo;\n+import org.openhab.binding.lcn.internal.converter.Converter;\n+import org.openhab.binding.lcn.internal.converter.Converters;\n+import org.openhab.binding.lcn.internal.converter.S0Converter;\n+import org.openhab.binding.lcn.internal.subhandler.AbstractLcnModuleSubHandler;\n+import org.openhab.binding.lcn.internal.subhandler.LcnModuleMetaAckSubHandler;\n+import org.openhab.binding.lcn.internal.subhandler.LcnModuleMetaFirmwareSubHandler;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link LcnModuleHandler} is responsible for handling commands, which are\n+ * sent to or received from one of the channels.\n+ *\n+ * @author Fabian Wolter - Initial contribution\n+ */\n+@NonNullByDefault\n+public class LcnModuleHandler extends BaseThingHandler {\n+    private final Logger logger = LoggerFactory.getLogger(LcnModuleHandler.class);\n+    private static final Map<String, Converter> CONVERTERS = new HashMap<>();\n+    private @Nullable LcnAddrMod moduleAddress;\n+    private final Map<LcnChannelGroup, @Nullable AbstractLcnModuleSubHandler> subHandlers = new HashMap<>();\n+    private final List<AbstractLcnModuleSubHandler> metadataSubHandlers = new ArrayList<>();\n+    private final Map<ChannelUID, @Nullable Converter> converters = new HashMap<>();\n+\n+    static {\n+        CONVERTERS.put(\"temperature\", Converters.TEMPERATURE);\n+        CONVERTERS.put(\"light\", Converters.LIGHT);\n+        CONVERTERS.put(\"co2\", Converters.CO2);\n+        CONVERTERS.put(\"current\", Converters.CURRENT);\n+        CONVERTERS.put(\"voltage\", Converters.VOLTAGE);\n+        CONVERTERS.put(\"angle\", Converters.ANGLE);\n+        CONVERTERS.put(\"windspeed\", Converters.WINDSPEED);\n+    }\n+\n+    public LcnModuleHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        LcnModuleConfiguration localConfig = getConfigAs(LcnModuleConfiguration.class);\n+        LcnAddrMod localModuleAddress = moduleAddress = new LcnAddrMod(localConfig.segmentId, localConfig.moduleId);\n+\n+        try {\n+            // create sub handlers\n+            ModInfo info = getPckGatewayHandler().getModInfo(localModuleAddress);\n+            for (LcnChannelGroup type : LcnChannelGroup.values()) {\n+                subHandlers.put(type, type.createSubHandler(this, info));\n+            }\n+\n+            // meta sub handlers, which are not assigned to a channel group\n+            metadataSubHandlers.add(new LcnModuleMetaAckSubHandler(this, info));\n+            metadataSubHandlers.add(new LcnModuleMetaFirmwareSubHandler(this, info));\n+\n+            // initialize variable value converters\n+            for (Channel channel : thing.getChannels()) {\n+                Object unitObject = channel.getConfiguration().get(\"unit\");\n+                Object parameterObject = channel.getConfiguration().get(\"parameter\");\n+\n+                if (unitObject instanceof String) {\n+                    switch ((String) unitObject) {\n+                        case \"power\":\n+                        case \"energy\":\n+                            converters.put(channel.getUID(), new S0Converter(parameterObject));\n+                            break;\n+                        default:\n+                            if (CONVERTERS.containsKey(unitObject)) {\n+                                converters.put(channel.getUID(), CONVERTERS.get(unitObject));\n+                            }\n+                            break;\n+                    }\n+                }\n+            }\n+\n+            // module is assumed as online, when the corresponding Bridge (PckGatewayHandler) is online.\n+            updateStatus(ThingStatus.ONLINE);\n+        } catch (LcnException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, e.getMessage());\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUid, Command command) {\n+        try {\n+            String groupId = channelUid.getGroupId();\n+\n+            if (!channelUid.isInGroup()) {\n+                return;\n+            }\n+\n+            if (groupId == null) {\n+                throw new LcnException(\"Group ID is null\");\n+            }\n+\n+            LcnChannelGroup channelGroup = LcnChannelGroup.valueOf(groupId.toUpperCase());\n+            AbstractLcnModuleSubHandler subHandler = subHandlers.get(channelGroup);\n+\n+            if (subHandler == null) {\n+                throw new LcnException(\"Sub Handler not found for: \" + channelGroup);\n+            }\n+\n+            Optional<Integer> number = channelUidToChannelNumber(channelUid, channelGroup);\n+\n+            if (command instanceof RefreshType) {\n+                number.ifPresent(n -> subHandler.handleRefresh(channelGroup, n));\n+                subHandler.handleRefresh(channelUid.getIdWithoutGroup());\n+            } else if (command instanceof OnOffType) {\n+                subHandler.handleCommandOnOff(castCommand(command), channelGroup, number.get());\n+            } else if (command instanceof DimmerOutputCommand) {\n+                subHandler.handleCommandDimmerOutput(castCommand(command), number.get());\n+            } else if (command instanceof PercentType && number.isPresent()) {\n+                subHandler.handleCommandPercent(castCommand(command), channelGroup, number.get());\n+            } else if (command instanceof HSBType) {\n+                subHandler.handleCommandHsb(castCommand(command), channelUid.getIdWithoutGroup());\n+            } else if (command instanceof PercentType) {\n+                subHandler.handleCommandPercent(castCommand(command), channelGroup, channelUid.getIdWithoutGroup());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "55f98964ceda94d860f5904b336419ce182f88d8"}, "originalPosition": 167}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b66904ef02f89b7ecfb46e341c6a3aeb27e85c39", "author": {"user": {"login": "fwolter", "name": "Fabian Wolter"}}, "url": "https://github.com/openhab/openhab-addons/commit/b66904ef02f89b7ecfb46e341c6a3aeb27e85c39", "committedDate": "2020-06-10T21:44:03Z", "message": "Incorporate review feedback No.4\n\nSigned-off-by: Fabian Wolter <github@fabian-wolter.de>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI4NDUwMTk0", "url": "https://github.com/openhab/openhab-addons/pull/7509#pullrequestreview-428450194", "createdAt": "2020-06-10T21:44:10Z", "commit": {"oid": "8d692ad7724548be4563c7b5309e1215ed73ca83"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMFQyMTo0NDoxMFrOGiHXbg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMFQyMTo0OTozM1rOGiHgDg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQyNTQ1NA==", "bodyText": "Would a BufferOverflowException still be thrown in implementors?", "url": "https://github.com/openhab/openhab-addons/pull/7509#discussion_r438425454", "createdAt": "2020-06-10T21:44:10Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.lcn/src/main/java/org/openhab/binding/lcn/internal/connection/SendData.java", "diffHunk": "@@ -0,0 +1,43 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.lcn.internal.connection;\n+\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.io.UnsupportedEncodingException;\n+import java.nio.BufferOverflowException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+\n+/**\n+ * Base class for a packet to be send to LCN-PCHK.\n+ *\n+ * @author Tobias J\u00fcttner - Initial Contribution\n+ * @author Fabian Wolter - Migration to OH2\n+ */\n+@NonNullByDefault\n+public abstract class SendData {\n+    /**\n+     * Writes the packet's data into the given buffer.\n+     * Called right before the packet is actually sent to LCN-PCHK.\n+     *\n+     * @param buffer the target buffer\n+     * @param localSegId the local segment id\n+     * @return true if everything was set-up correctly and data was written\n+     * @throws UnsupportedEncodingException if text could not be encoded for LCN-PCHK\n+     * @throws BufferOverflowException if target buffer has not enough space left (buffer will not be altered)\n+     * @throws IOException if an I/O error occurs\n+     */\n+    abstract boolean write(OutputStream buffer, int localSegId)\n+            throws UnsupportedEncodingException, BufferOverflowException, IOException;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8d692ad7724548be4563c7b5309e1215ed73ca83"}, "originalPosition": 42}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQyNjkzMw==", "bodyText": "Would it be possible to change this to a Charset? I think you can avoid a lot of UnsupportedEncodingException if you do that.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public static final String LCN_ENCODING = \"UTF-8\";\n          \n          \n            \n                public static final Charset LCN_ENCODING = StandardCharsets.UTF_8;", "url": "https://github.com/openhab/openhab-addons/pull/7509#discussion_r438426933", "createdAt": "2020-06-10T21:47:41Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.lcn/src/main/java/org/openhab/binding/lcn/internal/common/LcnDefs.java", "diffHunk": "@@ -0,0 +1,153 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.lcn.internal.common;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+\n+/**\n+ * Common definitions and helpers for the PCK protocol.\n+ *\n+ * @author Tobias J\u00fcttner - Initial Contribution\n+ * @author Fabian Wolter - Migration to OH2\n+ */\n+@NonNullByDefault\n+public final class LcnDefs {\n+    /** Text encoding used by LCN-PCHK. */\n+    public static final String LCN_ENCODING = \"UTF-8\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8d692ad7724548be4563c7b5309e1215ed73ca83"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQyNzY2Mg==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    return \"Addr: \" + addr + \": \" + new String(data, 0, data.length);\n          \n          \n            \n                    return \"Addr: \" + addr + \": \" + new String(data);\n          \n      \n    \n    \n  \n\nYou could also include the charset here if you want.", "url": "https://github.com/openhab/openhab-addons/pull/7509#discussion_r438427662", "createdAt": "2020-06-10T21:49:33Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.lcn/src/main/java/org/openhab/binding/lcn/internal/connection/SendDataPck.java", "diffHunk": "@@ -0,0 +1,77 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.lcn.internal.connection;\n+\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.nio.BufferOverflowException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.binding.lcn.internal.common.LcnAddr;\n+import org.openhab.binding.lcn.internal.common.LcnDefs;\n+import org.openhab.binding.lcn.internal.common.PckGenerator;\n+\n+/**\n+ * A PCK command to be send to LCN-PCHK.\n+ * It is already encoded as bytes to allow different text-encodings (ANSI, UTF-8).\n+ *\n+ * @author Tobias J\u00fcttner - Initial Contribution\n+ * @author Fabian Wolter - Migration to OH2\n+ */\n+@NonNullByDefault\n+class SendDataPck extends SendData {\n+    /** The target LCN address. */\n+    private final LcnAddr addr;\n+\n+    /** true to acknowledge the command on receipt. */\n+    private final boolean wantsAck;\n+\n+    /** PCK command (without address header) encoded as bytes. */\n+    private final byte[] data;\n+\n+    /**\n+     * Constructor.\n+     *\n+     * @param addr the target LCN address\n+     * @param wantsAck true to claim receipt\n+     * @param data the PCK command encoded as bytes\n+     */\n+    SendDataPck(LcnAddr addr, boolean wantsAck, byte[] data) {\n+        this.addr = addr;\n+        this.wantsAck = wantsAck;\n+        this.data = data;\n+    }\n+\n+    /**\n+     * Gets the PCK command.\n+     *\n+     * @return the PCK command encoded as bytes\n+     */\n+    byte[] getData() {\n+        return this.data;\n+    }\n+\n+    @Override\n+    boolean write(OutputStream buffer, int localSegId) throws BufferOverflowException, IOException {\n+        buffer.write(PckGenerator.generateAddressHeader(this.addr, localSegId == -1 ? 0 : localSegId, this.wantsAck)\n+                .getBytes(LcnDefs.LCN_ENCODING));\n+        buffer.write(this.data);\n+        buffer.write(PckGenerator.TERMINATION.getBytes(LcnDefs.LCN_ENCODING));\n+        return true;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return \"Addr: \" + addr + \": \" + new String(data, 0, data.length);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8d692ad7724548be4563c7b5309e1215ed73ca83"}, "originalPosition": 75}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "67c50cbdbf636b589880d1f623187c9033c2d9e8", "author": {"user": {"login": "fwolter", "name": "Fabian Wolter"}}, "url": "https://github.com/openhab/openhab-addons/commit/67c50cbdbf636b589880d1f623187c9033c2d9e8", "committedDate": "2020-06-10T22:00:36Z", "message": "Incorporate review feedback No.5\n\nSigned-off-by: Fabian Wolter <github@fabian-wolter.de>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI4NDY3OTY0", "url": "https://github.com/openhab/openhab-addons/pull/7509#pullrequestreview-428467964", "createdAt": "2020-06-10T22:20:26Z", "commit": {"oid": "67c50cbdbf636b589880d1f623187c9033c2d9e8"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMFQyMjoyMDoyN1rOGiIN9g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMFQyMjoyMzo1M1rOGiISpw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQzOTQxNA==", "bodyText": "It still bothers me that you are using reflection here. One option you can do is create an enum of state factories, similar to what I suggested earlier.\nAnother option is to just have each state construct the next state instance since they should already have all the data required to construct the next state anyway. Each state already has a reference to the StateContext field and the ScheduledExecutorService so it wouldn't be that difficult for each state to just pass those along when constructing the next state.", "url": "https://github.com/openhab/openhab-addons/pull/7509#discussion_r438439414", "createdAt": "2020-06-10T22:20:27Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.lcn/src/main/java/org/openhab/binding/lcn/internal/connection/StateMachine.java", "diffHunk": "@@ -0,0 +1,108 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.lcn.internal.connection;\n+\n+import java.lang.reflect.InvocationTargetException;\n+import java.util.concurrent.ScheduledExecutorService;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.lcn.internal.common.LcnAddr;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Implements a state machine for managing the connection to the LCN-PCK gateway. Setting states is thread-safe.\n+ *\n+ * @author Fabian Wolter - Initial Contribution\n+ */\n+@NonNullByDefault\n+public class StateMachine implements StateContext {\n+    private final Logger logger = LoggerFactory.getLogger(StateMachine.class);\n+    /** The StateMachine's current state */\n+    protected volatile AbstractConnectionState state;\n+    private final Connection connection;\n+    private final ScheduledExecutorService scheduler;\n+\n+    public StateMachine(Connection connection, ScheduledExecutorService scheduler) {\n+        this.connection = connection;\n+        this.scheduler = scheduler;\n+        this.state = new ConnectionStateInit(this, scheduler);\n+    }\n+\n+    @Override\n+    public synchronized void setState(Class<? extends AbstractConnectionState> newStateClass) {\n+        logger.debug(\"Changing state {} -> {}\", state.getClass().getSimpleName(), newStateClass.getSimpleName());\n+\n+        state.cancelAllTimers();\n+\n+        try {\n+            state = newStateClass.getDeclaredConstructor(StateContext.class, ScheduledExecutorService.class)\n+                    .newInstance(this, scheduler);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "67c50cbdbf636b589880d1f623187c9033c2d9e8"}, "originalPosition": 51}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQ0MDIxNg==", "bodyText": "charset should be specified here", "url": "https://github.com/openhab/openhab-addons/pull/7509#discussion_r438440216", "createdAt": "2020-06-10T22:22:42Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.lcn/src/main/java/org/openhab/binding/lcn/internal/pchkdiscovery/LcnPchkDiscoveryService.java", "diffHunk": "@@ -0,0 +1,165 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.lcn.internal.pchkdiscovery;\n+\n+import java.io.IOException;\n+import java.net.DatagramPacket;\n+import java.net.InetAddress;\n+import java.net.MulticastSocket;\n+import java.net.NetworkInterface;\n+import java.net.SocketException;\n+import java.net.SocketTimeoutException;\n+import java.net.UnknownHostException;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.smarthome.config.discovery.AbstractDiscoveryService;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResultBuilder;\n+import org.eclipse.smarthome.config.discovery.DiscoveryService;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.thing.ThingUID;\n+import org.openhab.binding.lcn.internal.LcnBindingConstants;\n+import org.osgi.service.component.annotations.Component;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.thoughtworks.xstream.XStream;\n+import com.thoughtworks.xstream.io.xml.StaxDriver;\n+\n+/**\n+ * Discovers LCN-PCK gateways, such as LCN-PCHK.\n+ *\n+ * Scan approach:\n+ * 1. Determines all local network interfaces\n+ * 2. Send a multicast message on each interface to the PCHK multicast address 234.5.6.7 (not configurable by user).\n+ * 3. Evaluate multicast responses of PCK gateways in the network\n+ *\n+ * @author Fabian Wolter - Initial Contribution\n+ */\n+@NonNullByDefault\n+@Component(service = DiscoveryService.class, immediate = true, configurationPid = \"discovery.lcn\")\n+public class LcnPchkDiscoveryService extends AbstractDiscoveryService {\n+    private final Logger logger = LoggerFactory.getLogger(LcnPchkDiscoveryService.class);\n+    private static final String HOSTNAME = \"hostname\";\n+    private static final String PORT = \"port\";\n+    private static final String MAC_ADDRESS = \"macAddress\";\n+    private static final String PCHK_DISCOVERY_MULTICAST_ADDRESS = \"234.5.6.7\";\n+    private static final int PCHK_DISCOVERY_PORT = 4220;\n+    private static final int INTERFACE_TIMEOUT_SEC = 2;\n+    private static final Set<ThingTypeUID> SUPPORTED_THING_TYPES_UIDS = Collections\n+            .unmodifiableSet(Stream.of(LcnBindingConstants.THING_TYPE_PCK_GATEWAY).collect(Collectors.toSet()));\n+    private static final String DISCOVER_REQUEST = \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?><ServicesRequest xmlns:xsi=\\\"http://www.w3.org/2001/XMLSchema-instance\\\" xsi:noNamespaceSchemaLocation=\\\"servicesrequest.xsd\\\"><Version major=\\\"1\\\" minor=\\\"0\\\" /><Requester requestId=\\\"1\\\" type=\\\"openHAB\\\" major=\\\"1\\\" minor=\\\"0\\\">openHAB</Requester><Requests><Request xsi:type=\\\"EnumServices\\\" major=\\\"1\\\" minor=\\\"0\\\" name=\\\"LcnPchkBus\\\" /></Requests></ServicesRequest>\";\n+\n+    public LcnPchkDiscoveryService() throws IllegalArgumentException {\n+        super(SUPPORTED_THING_TYPES_UIDS, 0, false);\n+    }\n+\n+    private List<InetAddress> getLocalAddresses() {\n+        List<InetAddress> result = new LinkedList<>();\n+        try {\n+            for (NetworkInterface networkInterface : Collections.list(NetworkInterface.getNetworkInterfaces())) {\n+                try {\n+                    if (networkInterface.isUp() && !networkInterface.isLoopback()\n+                            && !networkInterface.isPointToPoint()) {\n+                        result.addAll(Collections.list(networkInterface.getInetAddresses()));\n+                    }\n+                } catch (SocketException exception) {\n+                    // ignore\n+                }\n+            }\n+        } catch (SocketException exception) {\n+            return Collections.emptyList();\n+        }\n+        return result;\n+    }\n+\n+    @Override\n+    protected void startScan() {\n+        try {\n+            InetAddress multicastAddress = InetAddress.getByName(PCHK_DISCOVERY_MULTICAST_ADDRESS);\n+\n+            getLocalAddresses().forEach(localInterfaceAddress -> {\n+                logger.debug(\"Searching on {} ...\", localInterfaceAddress.getHostAddress());\n+                try (MulticastSocket socket = new MulticastSocket(PCHK_DISCOVERY_PORT)) {\n+                    socket.setInterface(localInterfaceAddress);\n+                    socket.setReuseAddress(true);\n+                    socket.setSoTimeout(INTERFACE_TIMEOUT_SEC * 1000);\n+                    socket.joinGroup(multicastAddress);\n+\n+                    byte[] requestData = DISCOVER_REQUEST.getBytes(\"UTF-8\");\n+                    DatagramPacket request = new DatagramPacket(requestData, requestData.length, multicastAddress,\n+                            PCHK_DISCOVERY_PORT);\n+                    socket.send(request);\n+\n+                    try {\n+                        do {\n+                            byte[] rxbuf = new byte[8192];\n+                            DatagramPacket packet = new DatagramPacket(rxbuf, rxbuf.length);\n+                            socket.receive(packet);\n+\n+                            InetAddress addr = packet.getAddress();\n+                            String response = new String(packet.getData());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "67c50cbdbf636b589880d1f623187c9033c2d9e8"}, "originalPosition": 118}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQ0MDYxNQ==", "bodyText": "merge these two try-catch clauses into one.", "url": "https://github.com/openhab/openhab-addons/pull/7509#discussion_r438440615", "createdAt": "2020-06-10T22:23:53Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.lcn/src/main/java/org/openhab/binding/lcn/internal/pchkdiscovery/LcnPchkDiscoveryService.java", "diffHunk": "@@ -0,0 +1,165 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.lcn.internal.pchkdiscovery;\n+\n+import java.io.IOException;\n+import java.net.DatagramPacket;\n+import java.net.InetAddress;\n+import java.net.MulticastSocket;\n+import java.net.NetworkInterface;\n+import java.net.SocketException;\n+import java.net.SocketTimeoutException;\n+import java.net.UnknownHostException;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.smarthome.config.discovery.AbstractDiscoveryService;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResultBuilder;\n+import org.eclipse.smarthome.config.discovery.DiscoveryService;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.thing.ThingUID;\n+import org.openhab.binding.lcn.internal.LcnBindingConstants;\n+import org.osgi.service.component.annotations.Component;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.thoughtworks.xstream.XStream;\n+import com.thoughtworks.xstream.io.xml.StaxDriver;\n+\n+/**\n+ * Discovers LCN-PCK gateways, such as LCN-PCHK.\n+ *\n+ * Scan approach:\n+ * 1. Determines all local network interfaces\n+ * 2. Send a multicast message on each interface to the PCHK multicast address 234.5.6.7 (not configurable by user).\n+ * 3. Evaluate multicast responses of PCK gateways in the network\n+ *\n+ * @author Fabian Wolter - Initial Contribution\n+ */\n+@NonNullByDefault\n+@Component(service = DiscoveryService.class, immediate = true, configurationPid = \"discovery.lcn\")\n+public class LcnPchkDiscoveryService extends AbstractDiscoveryService {\n+    private final Logger logger = LoggerFactory.getLogger(LcnPchkDiscoveryService.class);\n+    private static final String HOSTNAME = \"hostname\";\n+    private static final String PORT = \"port\";\n+    private static final String MAC_ADDRESS = \"macAddress\";\n+    private static final String PCHK_DISCOVERY_MULTICAST_ADDRESS = \"234.5.6.7\";\n+    private static final int PCHK_DISCOVERY_PORT = 4220;\n+    private static final int INTERFACE_TIMEOUT_SEC = 2;\n+    private static final Set<ThingTypeUID> SUPPORTED_THING_TYPES_UIDS = Collections\n+            .unmodifiableSet(Stream.of(LcnBindingConstants.THING_TYPE_PCK_GATEWAY).collect(Collectors.toSet()));\n+    private static final String DISCOVER_REQUEST = \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?><ServicesRequest xmlns:xsi=\\\"http://www.w3.org/2001/XMLSchema-instance\\\" xsi:noNamespaceSchemaLocation=\\\"servicesrequest.xsd\\\"><Version major=\\\"1\\\" minor=\\\"0\\\" /><Requester requestId=\\\"1\\\" type=\\\"openHAB\\\" major=\\\"1\\\" minor=\\\"0\\\">openHAB</Requester><Requests><Request xsi:type=\\\"EnumServices\\\" major=\\\"1\\\" minor=\\\"0\\\" name=\\\"LcnPchkBus\\\" /></Requests></ServicesRequest>\";\n+\n+    public LcnPchkDiscoveryService() throws IllegalArgumentException {\n+        super(SUPPORTED_THING_TYPES_UIDS, 0, false);\n+    }\n+\n+    private List<InetAddress> getLocalAddresses() {\n+        List<InetAddress> result = new LinkedList<>();\n+        try {\n+            for (NetworkInterface networkInterface : Collections.list(NetworkInterface.getNetworkInterfaces())) {\n+                try {\n+                    if (networkInterface.isUp() && !networkInterface.isLoopback()\n+                            && !networkInterface.isPointToPoint()) {\n+                        result.addAll(Collections.list(networkInterface.getInetAddresses()));\n+                    }\n+                } catch (SocketException exception) {\n+                    // ignore\n+                }\n+            }\n+        } catch (SocketException exception) {\n+            return Collections.emptyList();\n+        }\n+        return result;\n+    }\n+\n+    @Override\n+    protected void startScan() {\n+        try {\n+            InetAddress multicastAddress = InetAddress.getByName(PCHK_DISCOVERY_MULTICAST_ADDRESS);\n+\n+            getLocalAddresses().forEach(localInterfaceAddress -> {\n+                logger.debug(\"Searching on {} ...\", localInterfaceAddress.getHostAddress());\n+                try (MulticastSocket socket = new MulticastSocket(PCHK_DISCOVERY_PORT)) {\n+                    socket.setInterface(localInterfaceAddress);\n+                    socket.setReuseAddress(true);\n+                    socket.setSoTimeout(INTERFACE_TIMEOUT_SEC * 1000);\n+                    socket.joinGroup(multicastAddress);\n+\n+                    byte[] requestData = DISCOVER_REQUEST.getBytes(\"UTF-8\");\n+                    DatagramPacket request = new DatagramPacket(requestData, requestData.length, multicastAddress,\n+                            PCHK_DISCOVERY_PORT);\n+                    socket.send(request);\n+\n+                    try {\n+                        do {\n+                            byte[] rxbuf = new byte[8192];\n+                            DatagramPacket packet = new DatagramPacket(rxbuf, rxbuf.length);\n+                            socket.receive(packet);\n+\n+                            InetAddress addr = packet.getAddress();\n+                            String response = new String(packet.getData());\n+\n+                            if (response.contains(\"ServicesRequest\")) {\n+                                continue;\n+                            }\n+\n+                            ServicesResponse deserialized = xmlToServiceResponse(response);\n+\n+                            String macAddress = deserialized.getServer().getMachineId().replace(\":\", \"\");\n+                            ThingUID thingUid = new ThingUID(LcnBindingConstants.THING_TYPE_PCK_GATEWAY, macAddress);\n+\n+                            Map<String, Object> properties = new HashMap<>(3);\n+                            properties.put(HOSTNAME, addr.getHostAddress());\n+                            properties.put(PORT, deserialized.getExtServices().getExtService().getLocalPort());\n+                            properties.put(MAC_ADDRESS, macAddress);\n+\n+                            DiscoveryResultBuilder discoveryResult = DiscoveryResultBuilder.create(thingUid)\n+                                    .withProperties(properties).withRepresentationProperty(MAC_ADDRESS)\n+                                    .withLabel(deserialized.getServer().getContent() + \" (\"\n+                                            + deserialized.getServer().getMachineName() + \")\");\n+\n+                            thingDiscovered(discoveryResult.build());\n+                        } while (true); // left by SocketTimeoutException\n+                    } catch (SocketTimeoutException e) {\n+                        // nothing\n+                    }\n+                } catch (IOException e) {\n+                    logger.warn(\"Discovery failed for {}: {}\", localInterfaceAddress, e.getMessage());\n+                }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "67c50cbdbf636b589880d1f623187c9033c2d9e8"}, "originalPosition": 146}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2024f87f82fafa8f69eb3e84fe885d3b062c1f32", "author": {"user": {"login": "fwolter", "name": "Fabian Wolter"}}, "url": "https://github.com/openhab/openhab-addons/commit/2024f87f82fafa8f69eb3e84fe885d3b062c1f32", "committedDate": "2020-06-13T18:51:25Z", "message": "Incorporate review feedback No.6\n\nSigned-off-by: Fabian Wolter <github@fabian-wolter.de>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMwMTYyNDE2", "url": "https://github.com/openhab/openhab-addons/pull/7509#pullrequestreview-430162416", "createdAt": "2020-06-13T19:57:43Z", "commit": {"oid": "2024f87f82fafa8f69eb3e84fe885d3b062c1f32"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xM1QxOTo1Nzo0NFrOGjZIJg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xM1QxOTo1Nzo0NFrOGjZIJg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTc2NTAzMA==", "bodyText": "Is it necessary to add all these generics? Shouldn't the new state factory function just be a simple Function< AbstractStateMachine, AbstractState>?", "url": "https://github.com/openhab/openhab-addons/pull/7509#discussion_r439765030", "createdAt": "2020-06-13T19:57:44Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.lcn/src/main/java/org/openhab/binding/lcn/internal/connection/AbstractState.java", "diffHunk": "@@ -16,55 +16,61 @@\n import java.util.Collections;\n import java.util.List;\n import java.util.concurrent.ScheduledFuture;\n+import java.util.function.Function;\n \n import org.eclipse.jdt.annotation.NonNullByDefault;\n \n /**\n- * Base class for usage for states with {@link StateMachine}.\n+ * Base class for all states used with {@link AbstractStateMachine}.\n+ *\n+ * @param <T> type of the state machine implementation\n+ * @param <U> type of the state implementation\n  *\n  * @author Fabian Wolter - Initial Contribution\n  */\n @NonNullByDefault\n-public abstract class AbstractState {\n+public abstract class AbstractState<T extends AbstractStateMachine<T, U>, U extends AbstractState<T, U>> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2024f87f82fafa8f69eb3e84fe885d3b062c1f32"}, "originalPosition": 19}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMxMDcyODUy", "url": "https://github.com/openhab/openhab-addons/pull/7509#pullrequestreview-431072852", "createdAt": "2020-06-16T00:07:47Z", "commit": {"oid": "2024f87f82fafa8f69eb3e84fe885d3b062c1f32"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMyNzAzODcx", "url": "https://github.com/openhab/openhab-addons/pull/7509#pullrequestreview-432703871", "createdAt": "2020-06-17T19:20:09Z", "commit": {"oid": "2024f87f82fafa8f69eb3e84fe885d3b062c1f32"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 952, "cost": 1, "resetAt": "2021-10-28T19:08:13Z"}}}