{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzYxNzg3NDA1", "number": 6814, "title": "[danfossairunit] Danfoss AirUnit binding - initial commit", "bodyText": "Signed-off-by: Robert Bach openhab@mortalsilence.net\n[danfossairunit] Initial contribution\n\nThis initial contribution of the danfoss air unit binding is the result of an ongoing discussion which can be found here: https://community.openhab.org/t/danfoss-air-unit-ethernet-connection/17844\nIt will allow to connect to the air units via ethernet and poll for monitoring values (temperatures and ventilation speed and so on). It furthermore allows to set several parameters (bypass mode, fan speed override, ...).\nThe air unit is detected via autodiscovery (broadcast on a well known port). It is queried for the monitoring values (polling) in a configurable refresh interval.\nA pre-built binary can be downloaded here:\nhttps://github.com/pravussum/openhab2-addons/releases/tag/2.5.1-danfossair_alpha7", "createdAt": "2020-01-12T02:28:00Z", "url": "https://github.com/openhab/openhab-addons/pull/6814", "merged": true, "mergeCommit": {"oid": "8bb8981c3cde9c32bf2a5e4a33d9cdebeab9c39f"}, "closed": true, "closedAt": "2020-05-11T18:48:59Z", "author": {"login": "pravussum"}, "timelineItems": {"totalCount": 10, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcI3FKxAFqTM2NjY3MTEzNw==", "endCursor": "Y3Vyc29yOnYyOpPPAAABcgURUygFqTQwOTQzODU3Mg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY2NjcxMTM3", "url": "https://github.com/openhab/openhab-addons/pull/6814#pullrequestreview-366671137", "createdAt": "2020-02-28T20:38:39Z", "commit": {"oid": "ad93709e77a6687e32c3a9cdab3d8e74b61979c4"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 13, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yOFQyMDozODozOVrOFwCKWw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yOFQyMTo0NzoyNFrOFwDw_Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTkxMTM4Nw==", "bodyText": "I would cache the hrv variable locally so that you don't need to do this assertion check.", "url": "https://github.com/openhab/openhab-addons/pull/6814#discussion_r385911387", "createdAt": "2020-02-28T20:38:39Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/DanfossAirUnitHandler.java", "diffHunk": "@@ -0,0 +1,177 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.danfossairunit.internal;\n+\n+import static org.openhab.binding.danfossairunit.internal.DanfossAirUnitBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.net.UnknownHostException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link DanfossAirUnitHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Ralf Duckstein - Initial contribution\n+ * @author Robert Bach - heavy refactorings\n+ */\n+@NonNullByDefault\n+public class DanfossAirUnitHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(DanfossAirUnitHandler.class);\n+\n+    private @Nullable DanfossAirUnitConfiguration config;\n+\n+    public DanfossAirUnitHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    private @Nullable ValueCache valueCache;\n+\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+    private @Nullable DanfossHRV hrv;\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            updateAllChannels();\n+\n+        } else {\n+            if (hrv == null) {\n+                return;\n+            }\n+            try {\n+                Channel channel = Channel.getByName(channelUID.getIdWithoutGroup());\n+                hrv.connect();\n+                if (channel.getWriteAccessor() != null) {\n+                    updateState(channelUID, channel.getWriteAccessor().access(assertNonNull(hrv), command));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ad93709e77a6687e32c3a9cdab3d8e74b61979c4"}, "originalPosition": 73}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTkxMjc1Nw==", "bodyText": "Please specify specific checked exceptions if possible, if not possible just catch RuntimeException", "url": "https://github.com/openhab/openhab-addons/pull/6814#discussion_r385912757", "createdAt": "2020-02-28T20:42:21Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/DanfossAirUnitHandler.java", "diffHunk": "@@ -0,0 +1,177 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.danfossairunit.internal;\n+\n+import static org.openhab.binding.danfossairunit.internal.DanfossAirUnitBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.net.UnknownHostException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link DanfossAirUnitHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Ralf Duckstein - Initial contribution\n+ * @author Robert Bach - heavy refactorings\n+ */\n+@NonNullByDefault\n+public class DanfossAirUnitHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(DanfossAirUnitHandler.class);\n+\n+    private @Nullable DanfossAirUnitConfiguration config;\n+\n+    public DanfossAirUnitHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    private @Nullable ValueCache valueCache;\n+\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+    private @Nullable DanfossHRV hrv;\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            updateAllChannels();\n+\n+        } else {\n+            if (hrv == null) {\n+                return;\n+            }\n+            try {\n+                Channel channel = Channel.getByName(channelUID.getIdWithoutGroup());\n+                hrv.connect();\n+                if (channel.getWriteAccessor() != null) {\n+                    updateState(channelUID, channel.getWriteAccessor().access(assertNonNull(hrv), command));\n+                }\n+            } catch (IllegalArgumentException e) {\n+                logger.info(\"{}\", e.getMessage());\n+            } catch (IOException ioe) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR, ioe.getMessage());\n+            } catch (Exception e) {\n+                logger.info(\"Error updating channel {}: {}\", channelUID, e.getMessage());\n+            } finally {\n+                hrv.disconnect();\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        updateStatus(ThingStatus.UNKNOWN);\n+        config = getConfigAs(DanfossAirUnitConfiguration.class);\n+        valueCache = new ValueCache(config.updateUnchangedValuesEveryMillis);\n+        try {\n+            hrv = new DanfossHRV(InetAddress.getByName(config.host), 30046);\n+        } catch (UnknownHostException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                    \"Unknown host: \" + config.host);\n+        }\n+\n+        scheduler.execute(() -> {\n+            try {\n+                hrv.connect();\n+                thing.setProperty(PROPERTY_UNIT_NAME, hrv.getUnitName());\n+                thing.setProperty(PROPERTY_SERIAL, hrv.getUnitSerialNumber());\n+                hrv.disconnect();\n+                pollingJob = scheduler.scheduleWithFixedDelay(this::updateAllChannels, 5, config.refreshInterval,\n+                        TimeUnit.SECONDS);\n+                updateStatus(ThingStatus.ONLINE);\n+\n+            } catch (IOException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR, e.getMessage());\n+            }\n+        });\n+    }\n+\n+    private void updateAllChannels() {\n+        if (hrv == null) {\n+            return;\n+        }\n+        logger.debug(\"Updating DanfossHRV data '{}'\", getThing().getUID());\n+\n+        try {\n+            hrv.connect();\n+\n+            for (Channel channel : Channel.values()) {\n+                if (Thread.interrupted()) {\n+                    logger.debug(\"Polling thread interrupted...\");\n+                    return;\n+                }\n+                try {\n+                    updateState(channel.getGroup().getGroupName(), channel.getChannelName(),\n+                            channel.getReadAccessor().access(assertNonNull(hrv)));\n+                } catch (Exception e) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ad93709e77a6687e32c3a9cdab3d8e74b61979c4"}, "originalPosition": 132}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTkxMzgxNQ==", "bodyText": "I would synchronize all hrv.connect()...hrv.disconnect() logic to prevent nasty multithreaded issues.", "url": "https://github.com/openhab/openhab-addons/pull/6814#discussion_r385913815", "createdAt": "2020-02-28T20:45:11Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/DanfossAirUnitHandler.java", "diffHunk": "@@ -0,0 +1,177 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.danfossairunit.internal;\n+\n+import static org.openhab.binding.danfossairunit.internal.DanfossAirUnitBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.net.UnknownHostException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link DanfossAirUnitHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Ralf Duckstein - Initial contribution\n+ * @author Robert Bach - heavy refactorings\n+ */\n+@NonNullByDefault\n+public class DanfossAirUnitHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(DanfossAirUnitHandler.class);\n+\n+    private @Nullable DanfossAirUnitConfiguration config;\n+\n+    public DanfossAirUnitHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    private @Nullable ValueCache valueCache;\n+\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+    private @Nullable DanfossHRV hrv;\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            updateAllChannels();\n+\n+        } else {\n+            if (hrv == null) {\n+                return;\n+            }\n+            try {\n+                Channel channel = Channel.getByName(channelUID.getIdWithoutGroup());\n+                hrv.connect();\n+                if (channel.getWriteAccessor() != null) {\n+                    updateState(channelUID, channel.getWriteAccessor().access(assertNonNull(hrv), command));\n+                }\n+            } catch (IllegalArgumentException e) {\n+                logger.info(\"{}\", e.getMessage());\n+            } catch (IOException ioe) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR, ioe.getMessage());\n+            } catch (Exception e) {\n+                logger.info(\"Error updating channel {}: {}\", channelUID, e.getMessage());\n+            } finally {\n+                hrv.disconnect();\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        updateStatus(ThingStatus.UNKNOWN);\n+        config = getConfigAs(DanfossAirUnitConfiguration.class);\n+        valueCache = new ValueCache(config.updateUnchangedValuesEveryMillis);\n+        try {\n+            hrv = new DanfossHRV(InetAddress.getByName(config.host), 30046);\n+        } catch (UnknownHostException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                    \"Unknown host: \" + config.host);\n+        }\n+\n+        scheduler.execute(() -> {\n+            try {\n+                hrv.connect();\n+                thing.setProperty(PROPERTY_UNIT_NAME, hrv.getUnitName());\n+                thing.setProperty(PROPERTY_SERIAL, hrv.getUnitSerialNumber());\n+                hrv.disconnect();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ad93709e77a6687e32c3a9cdab3d8e74b61979c4"}, "originalPosition": 104}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTkxNDMwMw==", "bodyText": "Do your TODO", "url": "https://github.com/openhab/openhab-addons/pull/6814#discussion_r385914303", "createdAt": "2020-02-28T20:46:27Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/DanfossHRV.java", "diffHunk": "@@ -0,0 +1,322 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.danfossairunit.internal;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.math.BigDecimal;\n+import java.math.RoundingMode;\n+import java.net.InetAddress;\n+import java.net.Socket;\n+import java.nio.ByteBuffer;\n+import java.nio.charset.StandardCharsets;\n+import java.time.DateTimeException;\n+import java.time.ZoneId;\n+import java.time.ZonedDateTime;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.*;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link DanfossHRV} class does the actual network communication with the air unit.\n+ *\n+ * @author Ralf Duckstein - Initial contribution\n+ * @author Robert Bach - heavy refactorings\n+ */\n+\n+@NonNullByDefault\n+public class DanfossHRV implements Commands {\n+\n+    private final Logger logger = LoggerFactory.getLogger(DanfossHRV.class);\n+\n+    private InetAddress inetAddr;\n+    private int port;\n+    private @Nullable Socket socket;\n+    private @Nullable OutputStream oStream;\n+    private @Nullable InputStream iStream;\n+\n+    public DanfossHRV(InetAddress inetAddr, int port) {\n+        this.inetAddr = inetAddr;\n+        this.port = port;\n+    }\n+\n+    public void connect() throws IOException {\n+        socket = new Socket(inetAddr, port);\n+        oStream = socket.getOutputStream();\n+        iStream = socket.getInputStream();\n+    }\n+\n+    public void disconnect() {\n+        try {\n+            if (socket != null) {\n+                socket.close();\n+                socket = null;\n+                iStream = null;\n+                oStream = null;\n+            }\n+\n+        } catch (IOException ioe) {\n+            // TODO: handle exception", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ad93709e77a6687e32c3a9cdab3d8e74b61979c4"}, "originalPosition": 74}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTkxNTM1Ng==", "bodyText": "ByteBuffer should not be used for something so trivial. Please write this logic without using ByteBuffer.", "url": "https://github.com/openhab/openhab-addons/pull/6814#discussion_r385915356", "createdAt": "2020-02-28T20:49:05Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/DanfossHRV.java", "diffHunk": "@@ -0,0 +1,322 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.danfossairunit.internal;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.math.BigDecimal;\n+import java.math.RoundingMode;\n+import java.net.InetAddress;\n+import java.net.Socket;\n+import java.nio.ByteBuffer;\n+import java.nio.charset.StandardCharsets;\n+import java.time.DateTimeException;\n+import java.time.ZoneId;\n+import java.time.ZonedDateTime;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.*;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link DanfossHRV} class does the actual network communication with the air unit.\n+ *\n+ * @author Ralf Duckstein - Initial contribution\n+ * @author Robert Bach - heavy refactorings\n+ */\n+\n+@NonNullByDefault\n+public class DanfossHRV implements Commands {\n+\n+    private final Logger logger = LoggerFactory.getLogger(DanfossHRV.class);\n+\n+    private InetAddress inetAddr;\n+    private int port;\n+    private @Nullable Socket socket;\n+    private @Nullable OutputStream oStream;\n+    private @Nullable InputStream iStream;\n+\n+    public DanfossHRV(InetAddress inetAddr, int port) {\n+        this.inetAddr = inetAddr;\n+        this.port = port;\n+    }\n+\n+    public void connect() throws IOException {\n+        socket = new Socket(inetAddr, port);\n+        oStream = socket.getOutputStream();\n+        iStream = socket.getInputStream();\n+    }\n+\n+    public void disconnect() {\n+        try {\n+            if (socket != null) {\n+                socket.close();\n+                socket = null;\n+                iStream = null;\n+                oStream = null;\n+            }\n+\n+        } catch (IOException ioe) {\n+            // TODO: handle exception\n+        }\n+    }\n+\n+    private byte[] sendRobustRequest(byte[] operation, byte[] register) throws IOException {\n+        return sendRobustRequest(operation, register, EMPTY);\n+    }\n+\n+    private byte[] sendRobustRequest(byte[] operation, byte[] register, byte[] value) throws IOException {\n+        if (socket == null) {\n+            throw new DisconnectedException();\n+        }\n+        byte[] request = new byte[4 + value.length];\n+        System.arraycopy(operation, 0, request, 0, 2);\n+        System.arraycopy(register, 0, request, 2, 2);\n+        System.arraycopy(value, 0, request, 4, value.length);\n+\n+        try {\n+            return sendRequest(request);\n+        } catch (IOException exIo) {\n+            logger.info(\"Connection to the air unit has been lost, reconnecting ({}).\", exIo.getMessage());\n+            connect();\n+            return sendRequest(request);\n+        }\n+    }\n+\n+    private synchronized byte[] sendRequest(byte[] request) throws IOException {\n+\n+        oStream.write(request);\n+        oStream.flush();\n+\n+        byte[] result = new byte[63];\n+        iStream.read(result, 0, 63);\n+\n+        return result;\n+    }\n+\n+    private boolean getBoolean(byte[] operation, byte[] register) throws IOException {\n+        return sendRobustRequest(operation, register)[0] != 0;\n+    }\n+\n+    private void setSetting(byte[] register, boolean value) throws IOException {\n+        setSetting(register, value ? (byte) 1 : (byte) 0);\n+    }\n+\n+    private short getWord(byte[] operation, byte[] register) throws IOException {\n+        byte[] resultBytes = sendRobustRequest(operation, register);\n+        return ByteBuffer.wrap(new byte[] { resultBytes[0], resultBytes[1] }).getShort();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ad93709e77a6687e32c3a9cdab3d8e74b61979c4"}, "originalPosition": 121}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTkxNTQ3MQ==", "bodyText": "see comment above", "url": "https://github.com/openhab/openhab-addons/pull/6814#discussion_r385915471", "createdAt": "2020-02-28T20:49:25Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/DanfossHRV.java", "diffHunk": "@@ -0,0 +1,322 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.danfossairunit.internal;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.math.BigDecimal;\n+import java.math.RoundingMode;\n+import java.net.InetAddress;\n+import java.net.Socket;\n+import java.nio.ByteBuffer;\n+import java.nio.charset.StandardCharsets;\n+import java.time.DateTimeException;\n+import java.time.ZoneId;\n+import java.time.ZonedDateTime;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.*;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link DanfossHRV} class does the actual network communication with the air unit.\n+ *\n+ * @author Ralf Duckstein - Initial contribution\n+ * @author Robert Bach - heavy refactorings\n+ */\n+\n+@NonNullByDefault\n+public class DanfossHRV implements Commands {\n+\n+    private final Logger logger = LoggerFactory.getLogger(DanfossHRV.class);\n+\n+    private InetAddress inetAddr;\n+    private int port;\n+    private @Nullable Socket socket;\n+    private @Nullable OutputStream oStream;\n+    private @Nullable InputStream iStream;\n+\n+    public DanfossHRV(InetAddress inetAddr, int port) {\n+        this.inetAddr = inetAddr;\n+        this.port = port;\n+    }\n+\n+    public void connect() throws IOException {\n+        socket = new Socket(inetAddr, port);\n+        oStream = socket.getOutputStream();\n+        iStream = socket.getInputStream();\n+    }\n+\n+    public void disconnect() {\n+        try {\n+            if (socket != null) {\n+                socket.close();\n+                socket = null;\n+                iStream = null;\n+                oStream = null;\n+            }\n+\n+        } catch (IOException ioe) {\n+            // TODO: handle exception\n+        }\n+    }\n+\n+    private byte[] sendRobustRequest(byte[] operation, byte[] register) throws IOException {\n+        return sendRobustRequest(operation, register, EMPTY);\n+    }\n+\n+    private byte[] sendRobustRequest(byte[] operation, byte[] register, byte[] value) throws IOException {\n+        if (socket == null) {\n+            throw new DisconnectedException();\n+        }\n+        byte[] request = new byte[4 + value.length];\n+        System.arraycopy(operation, 0, request, 0, 2);\n+        System.arraycopy(register, 0, request, 2, 2);\n+        System.arraycopy(value, 0, request, 4, value.length);\n+\n+        try {\n+            return sendRequest(request);\n+        } catch (IOException exIo) {\n+            logger.info(\"Connection to the air unit has been lost, reconnecting ({}).\", exIo.getMessage());\n+            connect();\n+            return sendRequest(request);\n+        }\n+    }\n+\n+    private synchronized byte[] sendRequest(byte[] request) throws IOException {\n+\n+        oStream.write(request);\n+        oStream.flush();\n+\n+        byte[] result = new byte[63];\n+        iStream.read(result, 0, 63);\n+\n+        return result;\n+    }\n+\n+    private boolean getBoolean(byte[] operation, byte[] register) throws IOException {\n+        return sendRobustRequest(operation, register)[0] != 0;\n+    }\n+\n+    private void setSetting(byte[] register, boolean value) throws IOException {\n+        setSetting(register, value ? (byte) 1 : (byte) 0);\n+    }\n+\n+    private short getWord(byte[] operation, byte[] register) throws IOException {\n+        byte[] resultBytes = sendRobustRequest(operation, register);\n+        return ByteBuffer.wrap(new byte[] { resultBytes[0], resultBytes[1] }).getShort();\n+    }\n+\n+    private byte getByte(byte[] operation, byte[] register) throws IOException {\n+        return sendRobustRequest(operation, register)[0];\n+    }\n+\n+    private String getString(byte[] operation, byte[] register) throws IOException {\n+        // length of the string is stored in the first byte\n+        byte[] result = sendRobustRequest(operation, register);\n+        return new String(result, 1, result[0], StandardCharsets.US_ASCII);\n+    }\n+\n+    private void set(byte[] operation, byte[] register, byte value) throws IOException {\n+        byte[] valueArray = { value };\n+        sendRobustRequest(operation, register, valueArray);\n+    }\n+\n+    private void set(byte[] operation, byte[] register, short value) throws IOException {\n+        ByteBuffer byteBuffer = ByteBuffer.allocate(2);\n+        byteBuffer.putShort(value);\n+        sendRobustRequest(operation, register, byteBuffer.array());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ad93709e77a6687e32c3a9cdab3d8e74b61979c4"}, "originalPosition": 142}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTkxOTI3MA==", "bodyText": "Please use the OH UoM framework.", "url": "https://github.com/openhab/openhab-addons/pull/6814#discussion_r385919270", "createdAt": "2020-02-28T20:59:02Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.danfossairunit/src/main/resources/ESH-INF/thing/thing-types.xml", "diffHunk": "@@ -0,0 +1,191 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"danfossairunit\"\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\n+\t<!--HRV -->\n+\t<thing-type id=\"airunit\">\n+\t\t<label>Danfoss Air Unit</label>\n+\t\t<description>The Danfoss Air Unit Heat Exchanger, CCM and Air Dial</description>\n+\n+\t\t<channel-groups>\n+\t\t\t<channel-group id=\"main\" typeId=\"main\" />\n+\t\t\t<channel-group id=\"temps\" typeId=\"temps\" />\n+\t\t\t<channel-group id=\"humidity\" typeId=\"humidity\" />\n+\t\t\t<channel-group id=\"recuperator\" typeId=\"recuperator\" />\n+\t\t\t<channel-group id=\"service\" typeId=\"service\" />\n+\t\t</channel-groups>\n+\t\t<properties>\n+\t\t\t<property name=\"Unit Name\">unknown</property>\n+\t\t\t<property name=\"Serial Number\">unknown</property>\n+\t\t</properties>\n+\t\t<config-description>\n+\t\t\t<parameter name=\"host\" type=\"text\" required=\"true\">\n+\t\t\t\t<label>Host</label>\n+\t\t\t\t<context>network-address</context>\n+\t\t\t\t<description>Host name or IP address of the Danfoss Air CCM</description>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"refreshInterval\" type=\"integer\" required=\"false\" unit=\"s\">\n+\t\t\t\t<default>10</default>\n+\t\t\t\t<label>Refresh Interval</label>\n+\t\t\t\t<unitLabel>Seconds</unitLabel>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"updateUnchangedValuesEveryMillis\" type=\"integer\" min=\"0\" unit=\"ms\">\n+\t\t\t\t<label>Interval for Updating Unchanged Values</label>\n+\t\t\t\t<default>60000</default>\n+\t\t\t\t<unitLabel>ms</unitLabel>\n+\t\t\t\t<description>Interval to update unchanged values (to the event bus) in milliseconds. A value of 0 means that every\n+\t\t\t\t\tvalue (received via polling the air unit) is updated to the event bus, unchanged or not.</description>\n+\t\t\t\t<advanced>true</advanced>\n+\t\t\t</parameter>\n+\t\t</config-description>\n+\n+\t</thing-type>\n+\n+\t<!--Cannel Group Definitions -->\n+\t<channel-group-type id=\"main\">\n+\t\t<label>Mode and Fan Speeds</label>\n+\t\t<channels>\n+\t\t\t<channel id=\"current_time\" typeId=\"currentTime\" />\n+\t\t\t<channel id=\"mode\" typeId=\"mode\" />\n+\t\t\t<channel id=\"manual_fan_speed\" typeId=\"manualFanSpeed\" />\n+\t\t\t<channel id=\"supply_fan_speed\" typeId=\"supplyFanSpeed\" />\n+\t\t\t<channel id=\"extract_fan_speed\" typeId=\"extractFanSpeed\" />\n+\t\t\t<channel id=\"boost\" typeId=\"switch\">\n+\t\t\t\t<label>Boost</label>\n+\t\t\t\t<description>Enables fan boost</description>\n+\t\t\t</channel>\n+\t\t\t<channel id=\"night_cooling\" typeId=\"switch\">\n+\t\t\t\t<label>Night cooling</label>\n+\t\t\t\t<description>Enables night cooling</description>\n+\t\t\t</channel>\n+\t\t</channels>\n+\t</channel-group-type>\n+\t<channel-group-type id=\"temps\">\n+\t\t<label>Temperatures</label>\n+\t\t<category>Temperature</category>\n+\t\t<channels>\n+\t\t\t<channel id=\"room_temp\" typeId=\"temperature\">\n+\t\t\t\t<label>Room Temperature</label>\n+\t\t\t\t<description>Temperature of the air in the room of the Air Dial</description>\n+\t\t\t</channel>\n+\t\t\t<channel id=\"room_temp_calculated\" typeId=\"temperature\">\n+\t\t\t\t<label>Calculated Room Temperature</label>\n+\t\t\t\t<description>Calculated Room Temperature</description>\n+\t\t\t</channel>\n+\t\t\t<channel id=\"outdoor_temp\" typeId=\"temperature\">\n+\t\t\t\t<label>Outdoor Temperature</label>\n+\t\t\t\t<description>Temperature of the air outside</description>\n+\t\t\t</channel>\n+\t\t</channels>\n+\t</channel-group-type>\n+\t<channel-group-type id=\"humidity\">\n+\t\t<label>Humidity</label>\n+\t\t<channels>\n+\t\t\t<channel id=\"humidity\" typeId=\"humidity\" />\n+\t\t</channels>\n+\t</channel-group-type>\n+\t<channel-group-type id=\"recuperator\" advanced=\"true\">\n+\t\t<label>Recuperator</label>\n+\t\t<description>Heat exchaning device in the Air Unit</description>\n+\t\t<channels>\n+\t\t\t<channel id=\"bypass\" typeId=\"switch\">\n+\t\t\t\t<label>Bypass</label>\n+\t\t\t\t<description>Disables the heat exchange. Useful in summer when room temperature is above target and outside\n+\t\t\t\t\ttemperature is below target.</description>\n+\t\t\t</channel>\n+\t\t\t<channel id=\"supply_temp\" typeId=\"temperature\">\n+\t\t\t\t<label>Supply Air Temperature</label>\n+\t\t\t\t<description>Temperature of air which is passed to the rooms</description>\n+\t\t\t</channel>\n+\t\t\t<channel id=\"extract_temp\" typeId=\"temperature\">\n+\t\t\t\t<label>Extract Air Temperature</label>\n+\t\t\t\t<description>Temperature of the air as extracted from the rooms</description>\n+\t\t\t</channel>\n+\t\t\t<channel id=\"exhaust_temp\" typeId=\"temperature\">\n+\t\t\t\t<label>Exhaust Air Temperature</label>\n+\t\t\t\t<description>Temperature of the air when pushed outside</description>\n+\t\t\t</channel>\n+\t\t</channels>\n+\t</channel-group-type>\n+\t<channel-group-type id=\"service\" advanced=\"true\">\n+\t\t<label>Service</label>\n+\t\t<channels>\n+\t\t\t<channel id=\"battery_life\" typeId=\"percentage\">\n+\t\t\t\t<label>Battery Life</label>\n+\t\t\t\t<description>Remaining Air Dial Battery Level</description>\n+\t\t\t</channel>\n+\t\t\t<channel id=\"filter_life\" typeId=\"percentage\">\n+\t\t\t\t<label>Remaining Filter Life</label>\n+\t\t\t\t<description>Remaining life of filter until exchange is necessary</description>\n+\t\t\t</channel>\n+\t\t</channels>\n+\t</channel-group-type>\n+\n+\t<!--Channel Definitions -->\n+\t<channel-type id=\"currentTime\">\n+\t\t<item-type>DateTime</item-type>\n+\t\t<label>Current Time</label>\n+\t\t<state readOnly=\"true\" />\n+\t</channel-type>\n+\t<channel-type id=\"mode\">\n+\t\t<item-type>String</item-type>\n+\t\t<label>Mode</label>\n+\t\t<description>Off, Demand, Manual, Program</description>\n+\t\t<state>\n+\t\t\t<options>\n+\t\t\t\t<option value=\"DEMAND\">Demand</option>\n+\t\t\t\t<option value=\"PROGRAM\">Program</option>\n+\t\t\t\t<option value=\"MANUAL\">Manual</option>\n+\t\t\t\t<option value=\"OFF\">Off</option>\n+\t\t\t</options>\n+\t\t</state>\n+\t</channel-type>\n+\t<channel-type id=\"manualFanSpeed\">\n+\t\t<item-type>Dimmer</item-type>\n+\t\t<label>Manual Fan Speed</label>\n+\t\t<state step=\"10\" />\n+\t</channel-type>\n+\t<channel-type id=\"supplyFanSpeed\">\n+\t\t<item-type>Number</item-type>\n+\t\t<label>Supply Fan Speed</label>\n+\t\t<state pattern=\"%.0f rpm\" readOnly=\"true\" min=\"0\" />\n+\t</channel-type>\n+\t<channel-type id=\"extractFanSpeed\">\n+\t\t<item-type>Number</item-type>\n+\t\t<label>Extract Fan Speed</label>\n+\t\t<state pattern=\"%.0f rpm\" readOnly=\"true\" min=\"0\" />\n+\t</channel-type>\n+\t<channel-type id=\"percentage\">\n+\t\t<item-type>Number</item-type>\n+\t\t<label>Percentage</label>\n+\t\t<description>Read only percentage</description>\n+\t\t<state pattern=\"%.0f %%\" readOnly=\"true\" min=\"0\" max=\"100\" />\n+\t</channel-type>\n+\t<channel-type id=\"humidity\">\n+\t\t<item-type>Number</item-type>\n+\t\t<label>Humidity</label>\n+\t\t<category>Humidity</category>\n+\t\t<tags>\n+\t\t\t<tag>CurrentHumidity</tag>\n+\t\t</tags>\n+\t\t<state pattern=\"%.0f %%\" readOnly=\"true\" min=\"0\" max=\"100\">\n+\t\t</state>\n+\t</channel-type>\n+\t<channel-type id=\"switch\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Something that can be turned on or off</label>\n+\t</channel-type>\n+\t<channel-type id=\"temperature\">\n+\t\t<item-type>Number</item-type>\n+\t\t<label>Temperature</label>\n+\t\t<description>A measured temperature</description>\n+\t\t<category>Temperature</category>\n+\t\t<tags>\n+\t\t\t<tag>CurrentTemperature</tag>\n+\t\t</tags>\n+\t\t<state pattern=\"%.1f \u00b0C\" readOnly=\"true\" />", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ad93709e77a6687e32c3a9cdab3d8e74b61979c4"}, "originalPosition": 188}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTkyMjgwMA==", "bodyText": "Rather than implementing your own cache. I would recommend using the one that already comes with the OH core.\nYou can find details here", "url": "https://github.com/openhab/openhab-addons/pull/6814#discussion_r385922800", "createdAt": "2020-02-28T21:08:22Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/ValueCache.java", "diffHunk": "@@ -0,0 +1,70 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.danfossairunit.internal;\n+\n+import java.util.Calendar;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.smarthome.core.types.State;\n+\n+/**\n+ * The {@link ValueCache} is responsible for holding the last value of the channels for a\n+ * certain amount of time {@link ValueCache#durationMs} to prevent unnecessary event bus updates if the value didn't\n+ * change.\n+ *\n+ * @author Robert Bach - Initial contribution\n+ */\n+@NonNullByDefault\n+public class ValueCache {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ad93709e77a6687e32c3a9cdab3d8e74b61979c4"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTkyNTAxMA==", "bodyText": "Do you mean this?\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            DiscoveryResult result = DiscoveryResultBuilder.create(uid).withRepresentationProperty(host)\n          \n          \n            \n                            DiscoveryResult result = DiscoveryResultBuilder.create(uid).withRepresentationProperty(\"host\")", "url": "https://github.com/openhab/openhab-addons/pull/6814#discussion_r385925010", "createdAt": "2020-02-28T21:14:19Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/discovery/DanfossAirUnitDiscoveryService.java", "diffHunk": "@@ -0,0 +1,140 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.danfossairunit.internal.discovery;\n+\n+import static org.openhab.binding.danfossairunit.internal.DanfossAirUnitBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.InetAddress;\n+import java.net.InterfaceAddress;\n+import java.net.NetworkInterface;\n+import java.net.SocketTimeoutException;\n+import java.util.*;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.smarthome.config.discovery.AbstractDiscoveryService;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResult;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResultBuilder;\n+import org.eclipse.smarthome.config.discovery.DiscoveryService;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.thing.ThingUID;\n+import org.osgi.service.component.annotations.Component;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The Discovery service implementation to scan for available air units in the network via broadcast.\n+ *\n+ * @author Ralf Duckstein - Initial contribution\n+ * @author Robert Bach - heavy refactorings\n+ */\n+@Component(service = DiscoveryService.class, immediate = true)\n+@NonNullByDefault\n+public class DanfossAirUnitDiscoveryService extends AbstractDiscoveryService {\n+\n+    private static final int BROADCAST_PORT = 30045;\n+    private static final byte[] DISCOVER_SEND = { 0x0c, 0x00, 0x30, 0x00, 0x11, 0x00, 0x12, 0x00, 0x13 };\n+    private static final byte[] DISCOVER_RECEIVE = { 0x0d, 0x00, 0x07, 0x00, 0x02, 0x02, 0x00 };\n+\n+    private Logger logger = LoggerFactory.getLogger(DanfossAirUnitDiscoveryService.class);\n+\n+    public DanfossAirUnitDiscoveryService() {\n+        super(SUPPORTED_THING_TYPES_UIDS, 15, true);\n+    }\n+\n+    @Override\n+    public Set<ThingTypeUID> getSupportedThingTypes() {\n+        return SUPPORTED_THING_TYPES_UIDS;\n+    }\n+\n+    @Override\n+    protected void startBackgroundDiscovery() {\n+        logger.debug(\"Start Danfoss Air CCM background discovery\");\n+        scheduler.schedule(this::discover, 0, TimeUnit.SECONDS);\n+    }\n+\n+    @Override\n+    public void startScan() {\n+        logger.debug(\"Start Danfoss Air CCM scan\");\n+        discover();\n+    }\n+\n+    private synchronized void discover() {\n+        logger.debug(\"Try to discover all Danfoss Air CCM devices\");\n+\n+        try (DatagramSocket socket = new DatagramSocket()) {\n+\n+            Enumeration<NetworkInterface> interfaces = NetworkInterface.getNetworkInterfaces();\n+            while (interfaces.hasMoreElements()) {\n+                NetworkInterface networkInterface = interfaces.nextElement();\n+                if (networkInterface == null || networkInterface.isLoopback() || !networkInterface.isUp()) {\n+                    continue;\n+                }\n+                for (InterfaceAddress interfaceAddress : networkInterface.getInterfaceAddresses()) {\n+                    if (interfaceAddress == null || interfaceAddress.getBroadcast() == null) {\n+                        continue;\n+                    }\n+                    logger.debug(\"Sending broadcast on interface {} to discover Danfoss Air CCM device...\",\n+                            interfaceAddress.getAddress().toString());\n+                    sendBroadcastToDiscoverThing(socket, interfaceAddress.getBroadcast());\n+                }\n+            }\n+\n+        } catch (IOException e) {\n+            logger.debug(\"No Danfoss Air CCM device found. Diagnostic: {}\", e.getMessage());\n+        }\n+    }\n+\n+    private void sendBroadcastToDiscoverThing(DatagramSocket socket, InetAddress broadcastAddress) throws IOException {\n+        socket.setBroadcast(true);\n+        socket.setSoTimeout(5000);\n+        // send discover\n+        byte[] sendBuffer = DISCOVER_SEND;\n+        DatagramPacket sendPacket = new DatagramPacket(sendBuffer, sendBuffer.length, broadcastAddress, BROADCAST_PORT);\n+        socket.send(sendPacket);\n+        logger.debug(\"Disover message sent\");\n+\n+        // wait for responses\n+        while (true) {\n+            byte[] receiveBuffer = new byte[7];\n+            DatagramPacket receivePacket = new DatagramPacket(receiveBuffer, receiveBuffer.length);\n+            try {\n+                socket.receive(receivePacket);\n+            } catch (SocketTimeoutException e) {\n+                break; // leave the endless loop\n+            }\n+\n+            byte[] data = receivePacket.getData();\n+            if (Arrays.equals(data, DISCOVER_RECEIVE)) {\n+                logger.debug(\"Disover received correct response\");\n+\n+                String host = receivePacket.getAddress().getHostName();\n+                Map<String, Object> properties = new HashMap<>();\n+                properties.put(\"host\", host);\n+\n+                logger.debug(\"Adding a new Danfoss Air Unit CCM '{}' to inbox\", host);\n+\n+                ThingUID uid = new ThingUID(THING_TYPE_AIRUNIT, String.valueOf(receivePacket.getAddress().hashCode()));\n+\n+                DiscoveryResult result = DiscoveryResultBuilder.create(uid).withRepresentationProperty(host)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ad93709e77a6687e32c3a9cdab3d8e74b61979c4"}, "originalPosition": 132}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTkzNDMwNA==", "bodyText": "no min/max?", "url": "https://github.com/openhab/openhab-addons/pull/6814#discussion_r385934304", "createdAt": "2020-02-28T21:38:21Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.danfossairunit/src/main/resources/ESH-INF/thing/thing-types.xml", "diffHunk": "@@ -0,0 +1,191 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"danfossairunit\"\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\n+\t<!--HRV -->\n+\t<thing-type id=\"airunit\">\n+\t\t<label>Danfoss Air Unit</label>\n+\t\t<description>The Danfoss Air Unit Heat Exchanger, CCM and Air Dial</description>\n+\n+\t\t<channel-groups>\n+\t\t\t<channel-group id=\"main\" typeId=\"main\" />\n+\t\t\t<channel-group id=\"temps\" typeId=\"temps\" />\n+\t\t\t<channel-group id=\"humidity\" typeId=\"humidity\" />\n+\t\t\t<channel-group id=\"recuperator\" typeId=\"recuperator\" />\n+\t\t\t<channel-group id=\"service\" typeId=\"service\" />\n+\t\t</channel-groups>\n+\t\t<properties>\n+\t\t\t<property name=\"Unit Name\">unknown</property>\n+\t\t\t<property name=\"Serial Number\">unknown</property>\n+\t\t</properties>\n+\t\t<config-description>\n+\t\t\t<parameter name=\"host\" type=\"text\" required=\"true\">\n+\t\t\t\t<label>Host</label>\n+\t\t\t\t<context>network-address</context>\n+\t\t\t\t<description>Host name or IP address of the Danfoss Air CCM</description>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"refreshInterval\" type=\"integer\" required=\"false\" unit=\"s\">\n+\t\t\t\t<default>10</default>\n+\t\t\t\t<label>Refresh Interval</label>\n+\t\t\t\t<unitLabel>Seconds</unitLabel>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"updateUnchangedValuesEveryMillis\" type=\"integer\" min=\"0\" unit=\"ms\">\n+\t\t\t\t<label>Interval for Updating Unchanged Values</label>\n+\t\t\t\t<default>60000</default>\n+\t\t\t\t<unitLabel>ms</unitLabel>\n+\t\t\t\t<description>Interval to update unchanged values (to the event bus) in milliseconds. A value of 0 means that every\n+\t\t\t\t\tvalue (received via polling the air unit) is updated to the event bus, unchanged or not.</description>\n+\t\t\t\t<advanced>true</advanced>\n+\t\t\t</parameter>\n+\t\t</config-description>\n+\n+\t</thing-type>\n+\n+\t<!--Cannel Group Definitions -->\n+\t<channel-group-type id=\"main\">\n+\t\t<label>Mode and Fan Speeds</label>\n+\t\t<channels>\n+\t\t\t<channel id=\"current_time\" typeId=\"currentTime\" />\n+\t\t\t<channel id=\"mode\" typeId=\"mode\" />\n+\t\t\t<channel id=\"manual_fan_speed\" typeId=\"manualFanSpeed\" />\n+\t\t\t<channel id=\"supply_fan_speed\" typeId=\"supplyFanSpeed\" />\n+\t\t\t<channel id=\"extract_fan_speed\" typeId=\"extractFanSpeed\" />\n+\t\t\t<channel id=\"boost\" typeId=\"switch\">\n+\t\t\t\t<label>Boost</label>\n+\t\t\t\t<description>Enables fan boost</description>\n+\t\t\t</channel>\n+\t\t\t<channel id=\"night_cooling\" typeId=\"switch\">\n+\t\t\t\t<label>Night cooling</label>\n+\t\t\t\t<description>Enables night cooling</description>\n+\t\t\t</channel>\n+\t\t</channels>\n+\t</channel-group-type>\n+\t<channel-group-type id=\"temps\">\n+\t\t<label>Temperatures</label>\n+\t\t<category>Temperature</category>\n+\t\t<channels>\n+\t\t\t<channel id=\"room_temp\" typeId=\"temperature\">\n+\t\t\t\t<label>Room Temperature</label>\n+\t\t\t\t<description>Temperature of the air in the room of the Air Dial</description>\n+\t\t\t</channel>\n+\t\t\t<channel id=\"room_temp_calculated\" typeId=\"temperature\">\n+\t\t\t\t<label>Calculated Room Temperature</label>\n+\t\t\t\t<description>Calculated Room Temperature</description>\n+\t\t\t</channel>\n+\t\t\t<channel id=\"outdoor_temp\" typeId=\"temperature\">\n+\t\t\t\t<label>Outdoor Temperature</label>\n+\t\t\t\t<description>Temperature of the air outside</description>\n+\t\t\t</channel>\n+\t\t</channels>\n+\t</channel-group-type>\n+\t<channel-group-type id=\"humidity\">\n+\t\t<label>Humidity</label>\n+\t\t<channels>\n+\t\t\t<channel id=\"humidity\" typeId=\"humidity\" />\n+\t\t</channels>\n+\t</channel-group-type>\n+\t<channel-group-type id=\"recuperator\" advanced=\"true\">\n+\t\t<label>Recuperator</label>\n+\t\t<description>Heat exchaning device in the Air Unit</description>\n+\t\t<channels>\n+\t\t\t<channel id=\"bypass\" typeId=\"switch\">\n+\t\t\t\t<label>Bypass</label>\n+\t\t\t\t<description>Disables the heat exchange. Useful in summer when room temperature is above target and outside\n+\t\t\t\t\ttemperature is below target.</description>\n+\t\t\t</channel>\n+\t\t\t<channel id=\"supply_temp\" typeId=\"temperature\">\n+\t\t\t\t<label>Supply Air Temperature</label>\n+\t\t\t\t<description>Temperature of air which is passed to the rooms</description>\n+\t\t\t</channel>\n+\t\t\t<channel id=\"extract_temp\" typeId=\"temperature\">\n+\t\t\t\t<label>Extract Air Temperature</label>\n+\t\t\t\t<description>Temperature of the air as extracted from the rooms</description>\n+\t\t\t</channel>\n+\t\t\t<channel id=\"exhaust_temp\" typeId=\"temperature\">\n+\t\t\t\t<label>Exhaust Air Temperature</label>\n+\t\t\t\t<description>Temperature of the air when pushed outside</description>\n+\t\t\t</channel>\n+\t\t</channels>\n+\t</channel-group-type>\n+\t<channel-group-type id=\"service\" advanced=\"true\">\n+\t\t<label>Service</label>\n+\t\t<channels>\n+\t\t\t<channel id=\"battery_life\" typeId=\"percentage\">\n+\t\t\t\t<label>Battery Life</label>\n+\t\t\t\t<description>Remaining Air Dial Battery Level</description>\n+\t\t\t</channel>\n+\t\t\t<channel id=\"filter_life\" typeId=\"percentage\">\n+\t\t\t\t<label>Remaining Filter Life</label>\n+\t\t\t\t<description>Remaining life of filter until exchange is necessary</description>\n+\t\t\t</channel>\n+\t\t</channels>\n+\t</channel-group-type>\n+\n+\t<!--Channel Definitions -->\n+\t<channel-type id=\"currentTime\">\n+\t\t<item-type>DateTime</item-type>\n+\t\t<label>Current Time</label>\n+\t\t<state readOnly=\"true\" />\n+\t</channel-type>\n+\t<channel-type id=\"mode\">\n+\t\t<item-type>String</item-type>\n+\t\t<label>Mode</label>\n+\t\t<description>Off, Demand, Manual, Program</description>\n+\t\t<state>\n+\t\t\t<options>\n+\t\t\t\t<option value=\"DEMAND\">Demand</option>\n+\t\t\t\t<option value=\"PROGRAM\">Program</option>\n+\t\t\t\t<option value=\"MANUAL\">Manual</option>\n+\t\t\t\t<option value=\"OFF\">Off</option>\n+\t\t\t</options>\n+\t\t</state>\n+\t</channel-type>\n+\t<channel-type id=\"manualFanSpeed\">\n+\t\t<item-type>Dimmer</item-type>\n+\t\t<label>Manual Fan Speed</label>\n+\t\t<state step=\"10\" />", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ad93709e77a6687e32c3a9cdab3d8e74b61979c4"}, "originalPosition": 148}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTkzNzA4OQ==", "bodyText": "This type of Exception isn't handled in any special way in the rest of the code. I would suggest using an IllegalArgumentException instead.", "url": "https://github.com/openhab/openhab-addons/pull/6814#discussion_r385937089", "createdAt": "2020-02-28T21:45:46Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/InvalidDateTimeException.java", "diffHunk": "@@ -0,0 +1,43 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.danfossairunit.internal;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+\n+/**\n+ * An Exception thrown when a value received from the air unit cannot be interpreted as DateTime value.\n+ *\n+ * @author Robert Bach - Initial contribution\n+ */\n+@NonNullByDefault\n+public class InvalidDateTimeException extends RuntimeException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ad93709e77a6687e32c3a9cdab3d8e74b61979c4"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTkzNzM5OQ==", "bodyText": "This type of Exception isn't handled in any special way in the rest of the code. I would suggest using an IllegalArgumentException instead.", "url": "https://github.com/openhab/openhab-addons/pull/6814#discussion_r385937399", "createdAt": "2020-02-28T21:46:38Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/InvalidTemperatureException.java", "diffHunk": "@@ -0,0 +1,43 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.danfossairunit.internal;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+\n+/**\n+ * An Exception thrown when a value received from the air unit cannot be interpreted as temperature value.\n+ *\n+ * @author Robert Bach - Initial contribution\n+ */\n+@NonNullByDefault\n+public class InvalidTemperatureException extends RuntimeException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ad93709e77a6687e32c3a9cdab3d8e74b61979c4"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTkzNzY2MQ==", "bodyText": "This type of Exception isn't handled in any special way in the rest of the code. I would suggest using an IOException instead.", "url": "https://github.com/openhab/openhab-addons/pull/6814#discussion_r385937661", "createdAt": "2020-02-28T21:47:24Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/DisconnectedException.java", "diffHunk": "@@ -0,0 +1,43 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.danfossairunit.internal;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+\n+/**\n+ * Represents a communication failure with the air unit when it has not been connected.\n+ *\n+ * @author Robert Bach - Initial contribution\n+ */\n+@NonNullByDefault\n+public class DisconnectedException extends RuntimeException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ad93709e77a6687e32c3a9cdab3d8e74b61979c4"}, "originalPosition": 23}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzcwNzA0NDUz", "url": "https://github.com/openhab/openhab-addons/pull/6814#pullrequestreview-370704453", "createdAt": "2020-03-07T00:53:40Z", "commit": {"oid": "80f84c03c034dcb4c1f7a3571d06df1b43a2e71e"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wN1QwMDo1Mzo0MFrOFzLaFA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wN1QwMToyNjo0OVrOFzLsSw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTIwODU5Ng==", "bodyText": "Please make these fields private and final", "url": "https://github.com/openhab/openhab-addons/pull/6814#discussion_r389208596", "createdAt": "2020-03-07T00:53:40Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/Channel.java", "diffHunk": "@@ -0,0 +1,96 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.danfossairunit.internal;\n+\n+/**\n+ * This enum holds the available channels with their properties (name, ...) and read/write accessors to access\n+ * the corresponding values on the air unit.\n+ *\n+ * @author Robert Bach - Initial contribution\n+ */\n+public enum Channel {\n+\n+    // Main Channels\n+\n+    CHANNEL_CURRENT_TIME(\"current_time\", ChannelGroup.MAIN, DanfossHRV::getCurrentTime),\n+    CHANNEL_MODE(\"mode\", ChannelGroup.MAIN, DanfossHRV::getMode, DanfossHRV::setMode),\n+    CHANNEL_MANUAL_FAN_SPEED(\"manual_fan_speed\", ChannelGroup.MAIN, DanfossHRV::getManualFanSpeed,\n+            DanfossHRV::setManualFanSpeed),\n+    CHANNEL_EXTRACT_FAN_SPEED(\"extract_fan_speed\", ChannelGroup.MAIN, DanfossHRV::getExtractFanSpeed),\n+    CHANNEL_SUPPLY_FAN_SPEED(\"supply_fan_speed\", ChannelGroup.MAIN, DanfossHRV::getSupplyFanSpeed),\n+\n+    CHANNEL_BOOST(\"boost\", ChannelGroup.MAIN, DanfossHRV::getBoost, DanfossHRV::setBoost),\n+    CHANNEL_NIGHT_COOLING(\"night_cooling\", ChannelGroup.MAIN, DanfossHRV::getNightCooling, DanfossHRV::setNightCooling),\n+\n+    // Main Temperature Channels\n+    CHANNEL_ROOM_TEMP(\"room_temp\", ChannelGroup.TEMPS, DanfossHRV::getRoomTemperature),\n+    CHANNEL_ROOM_TEMP_CALCULATED(\"room_temp_calculated\", ChannelGroup.TEMPS, DanfossHRV::getRoomTemperatureCalculated),\n+    CHANNEL_OUTDOOR_TEMP(\"outdoor_temp\", ChannelGroup.TEMPS, DanfossHRV::getOutdoorTemperature),\n+\n+    // Humidity Channel\n+    CHANNEL_HUMIDITY(\"humidity\", ChannelGroup.HUMIDITY, DanfossHRV::getHumidity),\n+\n+    // recuperator channels\n+    CHANNEL_BYPASS(\"bypass\", ChannelGroup.RECUPERATOR, DanfossHRV::getBypass, DanfossHRV::setBypass),\n+    CHANNEL_SUPPLY_TEMP(\"supply_temp\", ChannelGroup.RECUPERATOR, DanfossHRV::getSupplyTemperature),\n+    CHANNEL_EXTRACT_TEMP(\"extract_temp\", ChannelGroup.RECUPERATOR, DanfossHRV::getExtractTemperature),\n+    CHANNEL_EXHAUST_TEMP(\"exhaust_temp\", ChannelGroup.RECUPERATOR, DanfossHRV::getExhaustTemperature),\n+\n+    // service channels\n+    CHANNEL_BATTERY_LIFE(\"battery_life\", ChannelGroup.SERVICE, DanfossHRV::getBatteryLife),\n+    CHANNEL_FILTER_LIFE(\"filter_life\", ChannelGroup.SERVICE, DanfossHRV::getFilterLife);\n+\n+    String channelName;\n+    ChannelGroup group;\n+    DanfossAirUnitReadAccessor readAccessor;\n+    DanfossAirUnitWriteAccessor writeAccessor = null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "80f84c03c034dcb4c1f7a3571d06df1b43a2e71e"}, "originalPosition": 56}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTIwODY0Mw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                Channel(String channelName, ChannelGroup group, DanfossAirUnitReadAccessor readAccessor) {\n          \n          \n            \n                private Channel(String channelName, ChannelGroup group, DanfossAirUnitReadAccessor readAccessor) {", "url": "https://github.com/openhab/openhab-addons/pull/6814#discussion_r389208643", "createdAt": "2020-03-07T00:54:02Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/Channel.java", "diffHunk": "@@ -0,0 +1,96 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.danfossairunit.internal;\n+\n+/**\n+ * This enum holds the available channels with their properties (name, ...) and read/write accessors to access\n+ * the corresponding values on the air unit.\n+ *\n+ * @author Robert Bach - Initial contribution\n+ */\n+public enum Channel {\n+\n+    // Main Channels\n+\n+    CHANNEL_CURRENT_TIME(\"current_time\", ChannelGroup.MAIN, DanfossHRV::getCurrentTime),\n+    CHANNEL_MODE(\"mode\", ChannelGroup.MAIN, DanfossHRV::getMode, DanfossHRV::setMode),\n+    CHANNEL_MANUAL_FAN_SPEED(\"manual_fan_speed\", ChannelGroup.MAIN, DanfossHRV::getManualFanSpeed,\n+            DanfossHRV::setManualFanSpeed),\n+    CHANNEL_EXTRACT_FAN_SPEED(\"extract_fan_speed\", ChannelGroup.MAIN, DanfossHRV::getExtractFanSpeed),\n+    CHANNEL_SUPPLY_FAN_SPEED(\"supply_fan_speed\", ChannelGroup.MAIN, DanfossHRV::getSupplyFanSpeed),\n+\n+    CHANNEL_BOOST(\"boost\", ChannelGroup.MAIN, DanfossHRV::getBoost, DanfossHRV::setBoost),\n+    CHANNEL_NIGHT_COOLING(\"night_cooling\", ChannelGroup.MAIN, DanfossHRV::getNightCooling, DanfossHRV::setNightCooling),\n+\n+    // Main Temperature Channels\n+    CHANNEL_ROOM_TEMP(\"room_temp\", ChannelGroup.TEMPS, DanfossHRV::getRoomTemperature),\n+    CHANNEL_ROOM_TEMP_CALCULATED(\"room_temp_calculated\", ChannelGroup.TEMPS, DanfossHRV::getRoomTemperatureCalculated),\n+    CHANNEL_OUTDOOR_TEMP(\"outdoor_temp\", ChannelGroup.TEMPS, DanfossHRV::getOutdoorTemperature),\n+\n+    // Humidity Channel\n+    CHANNEL_HUMIDITY(\"humidity\", ChannelGroup.HUMIDITY, DanfossHRV::getHumidity),\n+\n+    // recuperator channels\n+    CHANNEL_BYPASS(\"bypass\", ChannelGroup.RECUPERATOR, DanfossHRV::getBypass, DanfossHRV::setBypass),\n+    CHANNEL_SUPPLY_TEMP(\"supply_temp\", ChannelGroup.RECUPERATOR, DanfossHRV::getSupplyTemperature),\n+    CHANNEL_EXTRACT_TEMP(\"extract_temp\", ChannelGroup.RECUPERATOR, DanfossHRV::getExtractTemperature),\n+    CHANNEL_EXHAUST_TEMP(\"exhaust_temp\", ChannelGroup.RECUPERATOR, DanfossHRV::getExhaustTemperature),\n+\n+    // service channels\n+    CHANNEL_BATTERY_LIFE(\"battery_life\", ChannelGroup.SERVICE, DanfossHRV::getBatteryLife),\n+    CHANNEL_FILTER_LIFE(\"filter_life\", ChannelGroup.SERVICE, DanfossHRV::getFilterLife);\n+\n+    String channelName;\n+    ChannelGroup group;\n+    DanfossAirUnitReadAccessor readAccessor;\n+    DanfossAirUnitWriteAccessor writeAccessor = null;\n+\n+    static Channel getByName(String name) {\n+        for (Channel channel : values()) {\n+            if (channel.getChannelName().equals(name)) {\n+                return channel;\n+            }\n+        }\n+        throw new IllegalArgumentException(String.format(\"Unknown channel name: %s\", name));\n+    }\n+\n+    Channel(String channelName, ChannelGroup group, DanfossAirUnitReadAccessor readAccessor) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "80f84c03c034dcb4c1f7a3571d06df1b43a2e71e"}, "originalPosition": 67}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTIwODY2NQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                Channel(String channelName, ChannelGroup group, DanfossAirUnitReadAccessor readAccessor,\n          \n          \n            \n                private Channel(String channelName, ChannelGroup group, DanfossAirUnitReadAccessor readAccessor,", "url": "https://github.com/openhab/openhab-addons/pull/6814#discussion_r389208665", "createdAt": "2020-03-07T00:54:12Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/Channel.java", "diffHunk": "@@ -0,0 +1,96 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.danfossairunit.internal;\n+\n+/**\n+ * This enum holds the available channels with their properties (name, ...) and read/write accessors to access\n+ * the corresponding values on the air unit.\n+ *\n+ * @author Robert Bach - Initial contribution\n+ */\n+public enum Channel {\n+\n+    // Main Channels\n+\n+    CHANNEL_CURRENT_TIME(\"current_time\", ChannelGroup.MAIN, DanfossHRV::getCurrentTime),\n+    CHANNEL_MODE(\"mode\", ChannelGroup.MAIN, DanfossHRV::getMode, DanfossHRV::setMode),\n+    CHANNEL_MANUAL_FAN_SPEED(\"manual_fan_speed\", ChannelGroup.MAIN, DanfossHRV::getManualFanSpeed,\n+            DanfossHRV::setManualFanSpeed),\n+    CHANNEL_EXTRACT_FAN_SPEED(\"extract_fan_speed\", ChannelGroup.MAIN, DanfossHRV::getExtractFanSpeed),\n+    CHANNEL_SUPPLY_FAN_SPEED(\"supply_fan_speed\", ChannelGroup.MAIN, DanfossHRV::getSupplyFanSpeed),\n+\n+    CHANNEL_BOOST(\"boost\", ChannelGroup.MAIN, DanfossHRV::getBoost, DanfossHRV::setBoost),\n+    CHANNEL_NIGHT_COOLING(\"night_cooling\", ChannelGroup.MAIN, DanfossHRV::getNightCooling, DanfossHRV::setNightCooling),\n+\n+    // Main Temperature Channels\n+    CHANNEL_ROOM_TEMP(\"room_temp\", ChannelGroup.TEMPS, DanfossHRV::getRoomTemperature),\n+    CHANNEL_ROOM_TEMP_CALCULATED(\"room_temp_calculated\", ChannelGroup.TEMPS, DanfossHRV::getRoomTemperatureCalculated),\n+    CHANNEL_OUTDOOR_TEMP(\"outdoor_temp\", ChannelGroup.TEMPS, DanfossHRV::getOutdoorTemperature),\n+\n+    // Humidity Channel\n+    CHANNEL_HUMIDITY(\"humidity\", ChannelGroup.HUMIDITY, DanfossHRV::getHumidity),\n+\n+    // recuperator channels\n+    CHANNEL_BYPASS(\"bypass\", ChannelGroup.RECUPERATOR, DanfossHRV::getBypass, DanfossHRV::setBypass),\n+    CHANNEL_SUPPLY_TEMP(\"supply_temp\", ChannelGroup.RECUPERATOR, DanfossHRV::getSupplyTemperature),\n+    CHANNEL_EXTRACT_TEMP(\"extract_temp\", ChannelGroup.RECUPERATOR, DanfossHRV::getExtractTemperature),\n+    CHANNEL_EXHAUST_TEMP(\"exhaust_temp\", ChannelGroup.RECUPERATOR, DanfossHRV::getExhaustTemperature),\n+\n+    // service channels\n+    CHANNEL_BATTERY_LIFE(\"battery_life\", ChannelGroup.SERVICE, DanfossHRV::getBatteryLife),\n+    CHANNEL_FILTER_LIFE(\"filter_life\", ChannelGroup.SERVICE, DanfossHRV::getFilterLife);\n+\n+    String channelName;\n+    ChannelGroup group;\n+    DanfossAirUnitReadAccessor readAccessor;\n+    DanfossAirUnitWriteAccessor writeAccessor = null;\n+\n+    static Channel getByName(String name) {\n+        for (Channel channel : values()) {\n+            if (channel.getChannelName().equals(name)) {\n+                return channel;\n+            }\n+        }\n+        throw new IllegalArgumentException(String.format(\"Unknown channel name: %s\", name));\n+    }\n+\n+    Channel(String channelName, ChannelGroup group, DanfossAirUnitReadAccessor readAccessor) {\n+        this.channelName = channelName;\n+        this.group = group;\n+        this.readAccessor = readAccessor;\n+    }\n+\n+    Channel(String channelName, ChannelGroup group, DanfossAirUnitReadAccessor readAccessor,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "80f84c03c034dcb4c1f7a3571d06df1b43a2e71e"}, "originalPosition": 73}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTIwODc0OQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                ChannelGroup(String groupName) {\n          \n          \n            \n                private ChannelGroup(String groupName) {", "url": "https://github.com/openhab/openhab-addons/pull/6814#discussion_r389208749", "createdAt": "2020-03-07T00:54:33Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/ChannelGroup.java", "diffHunk": "@@ -0,0 +1,36 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.danfossairunit.internal;\n+\n+/**\n+ * Represents a channel group, channels are divided into.\n+ *\n+ * @author Robert Bach - Initial contribution\n+ */\n+public enum ChannelGroup {\n+    MAIN(\"main\"),\n+    TEMPS(\"temps\"),\n+    HUMIDITY(\"humidity\"),\n+    RECUPERATOR(\"recuperator\"),\n+    SERVICE(\"service\");\n+\n+    ChannelGroup(String groupName) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "80f84c03c034dcb4c1f7a3571d06df1b43a2e71e"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTIwOTk2OQ==", "bodyText": "IOException shouldn't be ignored, you should log it at the very least.", "url": "https://github.com/openhab/openhab-addons/pull/6814#discussion_r389209969", "createdAt": "2020-03-07T01:02:26Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/DanfossHRV.java", "diffHunk": "@@ -0,0 +1,323 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.danfossairunit.internal;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.math.BigDecimal;\n+import java.math.RoundingMode;\n+import java.net.InetAddress;\n+import java.net.Socket;\n+import java.nio.charset.StandardCharsets;\n+import java.time.DateTimeException;\n+import java.time.ZoneId;\n+import java.time.ZonedDateTime;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.*;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link DanfossHRV} class does the actual network communication with the air unit.\n+ *\n+ * @author Ralf Duckstein - Initial contribution\n+ * @author Robert Bach - heavy refactorings\n+ */\n+\n+@NonNullByDefault\n+public class DanfossHRV implements Commands {\n+\n+    private final Logger logger = LoggerFactory.getLogger(DanfossHRV.class);\n+\n+    private InetAddress inetAddr;\n+    private int port;\n+    private @Nullable Socket socket;\n+    private @Nullable OutputStream oStream;\n+    private @Nullable InputStream iStream;\n+\n+    public DanfossHRV(InetAddress inetAddr, int port) {\n+        this.inetAddr = inetAddr;\n+        this.port = port;\n+    }\n+\n+    public synchronized void connect() throws IOException {\n+        socket = new Socket(inetAddr, port);\n+        oStream = socket.getOutputStream();\n+        iStream = socket.getInputStream();\n+    }\n+\n+    public synchronized void disconnect() {\n+        try {\n+            if (socket != null) {\n+                socket.close();\n+            }\n+        } catch (IOException ignore) {\n+        } finally {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "80f84c03c034dcb4c1f7a3571d06df1b43a2e71e"}, "originalPosition": 69}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTIxMTEzNA==", "bodyText": "What are you expecting to throw this?", "url": "https://github.com/openhab/openhab-addons/pull/6814#discussion_r389211134", "createdAt": "2020-03-07T01:10:49Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/DanfossAirUnitHandler.java", "diffHunk": "@@ -0,0 +1,171 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.danfossairunit.internal;\n+\n+import static org.openhab.binding.danfossairunit.internal.DanfossAirUnitBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.net.UnknownHostException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link DanfossAirUnitHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Ralf Duckstein - Initial contribution\n+ * @author Robert Bach - heavy refactorings\n+ */\n+@NonNullByDefault\n+public class DanfossAirUnitHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(DanfossAirUnitHandler.class);\n+\n+    private @Nullable DanfossAirUnitConfiguration config;\n+\n+    public DanfossAirUnitHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    private @Nullable ValueCache valueCache;\n+\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+    private @Nullable DanfossHRV hrv;\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            updateAllChannels();\n+        } else {\n+            if (hrv == null) {\n+                return;\n+            }\n+            try {\n+                DanfossHRV danfossHRV = hrv;\n+                Channel channel = Channel.getByName(channelUID.getIdWithoutGroup());\n+                hrv.connect();\n+                if (channel.getWriteAccessor() != null) {\n+                    updateState(channelUID, channel.getWriteAccessor().access(danfossHRV, command));\n+                }\n+            } catch (IllegalArgumentException e) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "80f84c03c034dcb4c1f7a3571d06df1b43a2e71e"}, "originalPosition": 75}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTIxMzA5MA==", "bodyText": "\ud83e\udd26\u200d\u2642 This isn't what I meant by synchronizing connect()...disconnect() logic. I will elaborate on what I meant.\nRight now all of your communication logic happens in short bursts: connect->send/receive messages -> disconnect.\nThe issue I'm trying to point out is what happens when, lets say, a RefreshCommand and a your scheduled updateAllChannels() happen at the same time? Whichever one calls connect() first will have its socket instance overwritten by the second call to connect(), this will cause a number of problems depending on when the second call occurs. The most important problem is that if you overwrite the socket instance before closing it, it will never get closed! In the worst case this could eventually lead to crashing either openhab or the airunit you are talking to.", "url": "https://github.com/openhab/openhab-addons/pull/6814#discussion_r389213090", "createdAt": "2020-03-07T01:25:35Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/DanfossHRV.java", "diffHunk": "@@ -0,0 +1,323 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.danfossairunit.internal;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.math.BigDecimal;\n+import java.math.RoundingMode;\n+import java.net.InetAddress;\n+import java.net.Socket;\n+import java.nio.charset.StandardCharsets;\n+import java.time.DateTimeException;\n+import java.time.ZoneId;\n+import java.time.ZonedDateTime;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.*;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link DanfossHRV} class does the actual network communication with the air unit.\n+ *\n+ * @author Ralf Duckstein - Initial contribution\n+ * @author Robert Bach - heavy refactorings\n+ */\n+\n+@NonNullByDefault\n+public class DanfossHRV implements Commands {\n+\n+    private final Logger logger = LoggerFactory.getLogger(DanfossHRV.class);\n+\n+    private InetAddress inetAddr;\n+    private int port;\n+    private @Nullable Socket socket;\n+    private @Nullable OutputStream oStream;\n+    private @Nullable InputStream iStream;\n+\n+    public DanfossHRV(InetAddress inetAddr, int port) {\n+        this.inetAddr = inetAddr;\n+        this.port = port;\n+    }\n+\n+    public synchronized void connect() throws IOException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "80f84c03c034dcb4c1f7a3571d06df1b43a2e71e"}, "originalPosition": 57}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTIxMzI1OQ==", "bodyText": "Percentage of what?", "url": "https://github.com/openhab/openhab-addons/pull/6814#discussion_r389213259", "createdAt": "2020-03-07T01:26:49Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.danfossairunit/src/main/resources/ESH-INF/thing/thing-types.xml", "diffHunk": "@@ -0,0 +1,191 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"danfossairunit\"\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\n+\t<!--HRV -->\n+\t<thing-type id=\"airunit\">\n+\t\t<label>Danfoss Air Unit</label>\n+\t\t<description>The Danfoss Air Unit Heat Exchanger, CCM and Air Dial</description>\n+\n+\t\t<channel-groups>\n+\t\t\t<channel-group id=\"main\" typeId=\"main\" />\n+\t\t\t<channel-group id=\"temps\" typeId=\"temps\" />\n+\t\t\t<channel-group id=\"humidity\" typeId=\"humidity\" />\n+\t\t\t<channel-group id=\"recuperator\" typeId=\"recuperator\" />\n+\t\t\t<channel-group id=\"service\" typeId=\"service\" />\n+\t\t</channel-groups>\n+\t\t<properties>\n+\t\t\t<property name=\"Unit Name\">unknown</property>\n+\t\t\t<property name=\"Serial Number\">unknown</property>\n+\t\t</properties>\n+\t\t<config-description>\n+\t\t\t<parameter name=\"host\" type=\"text\" required=\"true\">\n+\t\t\t\t<label>Host</label>\n+\t\t\t\t<context>network-address</context>\n+\t\t\t\t<description>Host name or IP address of the Danfoss Air CCM</description>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"refreshInterval\" type=\"integer\" required=\"false\" unit=\"s\">\n+\t\t\t\t<default>10</default>\n+\t\t\t\t<label>Refresh Interval</label>\n+\t\t\t\t<unitLabel>Seconds</unitLabel>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"updateUnchangedValuesEveryMillis\" type=\"integer\" min=\"0\" unit=\"ms\">\n+\t\t\t\t<label>Interval for Updating Unchanged Values</label>\n+\t\t\t\t<default>60000</default>\n+\t\t\t\t<unitLabel>ms</unitLabel>\n+\t\t\t\t<description>Interval to update unchanged values (to the event bus) in milliseconds. A value of 0 means that every\n+\t\t\t\t\tvalue (received via polling the air unit) is updated to the event bus, unchanged or not.</description>\n+\t\t\t\t<advanced>true</advanced>\n+\t\t\t</parameter>\n+\t\t</config-description>\n+\n+\t</thing-type>\n+\n+\t<!--Cannel Group Definitions -->\n+\t<channel-group-type id=\"main\">\n+\t\t<label>Mode and Fan Speeds</label>\n+\t\t<channels>\n+\t\t\t<channel id=\"current_time\" typeId=\"currentTime\" />\n+\t\t\t<channel id=\"mode\" typeId=\"mode\" />\n+\t\t\t<channel id=\"manual_fan_speed\" typeId=\"manualFanSpeed\" />\n+\t\t\t<channel id=\"supply_fan_speed\" typeId=\"supplyFanSpeed\" />\n+\t\t\t<channel id=\"extract_fan_speed\" typeId=\"extractFanSpeed\" />\n+\t\t\t<channel id=\"boost\" typeId=\"switch\">\n+\t\t\t\t<label>Boost</label>\n+\t\t\t\t<description>Enables fan boost</description>\n+\t\t\t</channel>\n+\t\t\t<channel id=\"night_cooling\" typeId=\"switch\">\n+\t\t\t\t<label>Night cooling</label>\n+\t\t\t\t<description>Enables night cooling</description>\n+\t\t\t</channel>\n+\t\t</channels>\n+\t</channel-group-type>\n+\t<channel-group-type id=\"temps\">\n+\t\t<label>Temperatures</label>\n+\t\t<category>Temperature</category>\n+\t\t<channels>\n+\t\t\t<channel id=\"room_temp\" typeId=\"temperature\">\n+\t\t\t\t<label>Room Temperature</label>\n+\t\t\t\t<description>Temperature of the air in the room of the Air Dial</description>\n+\t\t\t</channel>\n+\t\t\t<channel id=\"room_temp_calculated\" typeId=\"temperature\">\n+\t\t\t\t<label>Calculated Room Temperature</label>\n+\t\t\t\t<description>Calculated Room Temperature</description>\n+\t\t\t</channel>\n+\t\t\t<channel id=\"outdoor_temp\" typeId=\"temperature\">\n+\t\t\t\t<label>Outdoor Temperature</label>\n+\t\t\t\t<description>Temperature of the air outside</description>\n+\t\t\t</channel>\n+\t\t</channels>\n+\t</channel-group-type>\n+\t<channel-group-type id=\"humidity\">\n+\t\t<label>Humidity</label>\n+\t\t<channels>\n+\t\t\t<channel id=\"humidity\" typeId=\"humidity\" />\n+\t\t</channels>\n+\t</channel-group-type>\n+\t<channel-group-type id=\"recuperator\" advanced=\"true\">\n+\t\t<label>Recuperator</label>\n+\t\t<description>Heat exchaning device in the Air Unit</description>\n+\t\t<channels>\n+\t\t\t<channel id=\"bypass\" typeId=\"switch\">\n+\t\t\t\t<label>Bypass</label>\n+\t\t\t\t<description>Disables the heat exchange. Useful in summer when room temperature is above target and outside\n+\t\t\t\t\ttemperature is below target.</description>\n+\t\t\t</channel>\n+\t\t\t<channel id=\"supply_temp\" typeId=\"temperature\">\n+\t\t\t\t<label>Supply Air Temperature</label>\n+\t\t\t\t<description>Temperature of air which is passed to the rooms</description>\n+\t\t\t</channel>\n+\t\t\t<channel id=\"extract_temp\" typeId=\"temperature\">\n+\t\t\t\t<label>Extract Air Temperature</label>\n+\t\t\t\t<description>Temperature of the air as extracted from the rooms</description>\n+\t\t\t</channel>\n+\t\t\t<channel id=\"exhaust_temp\" typeId=\"temperature\">\n+\t\t\t\t<label>Exhaust Air Temperature</label>\n+\t\t\t\t<description>Temperature of the air when pushed outside</description>\n+\t\t\t</channel>\n+\t\t</channels>\n+\t</channel-group-type>\n+\t<channel-group-type id=\"service\" advanced=\"true\">\n+\t\t<label>Service</label>\n+\t\t<channels>\n+\t\t\t<channel id=\"battery_life\" typeId=\"percentage\">\n+\t\t\t\t<label>Battery Life</label>\n+\t\t\t\t<description>Remaining Air Dial Battery Level</description>\n+\t\t\t</channel>\n+\t\t\t<channel id=\"filter_life\" typeId=\"percentage\">\n+\t\t\t\t<label>Remaining Filter Life</label>\n+\t\t\t\t<description>Remaining life of filter until exchange is necessary</description>\n+\t\t\t</channel>\n+\t\t</channels>\n+\t</channel-group-type>\n+\n+\t<!--Channel Definitions -->\n+\t<channel-type id=\"currentTime\">\n+\t\t<item-type>DateTime</item-type>\n+\t\t<label>Current Time</label>\n+\t\t<state readOnly=\"true\" />\n+\t</channel-type>\n+\t<channel-type id=\"mode\">\n+\t\t<item-type>String</item-type>\n+\t\t<label>Mode</label>\n+\t\t<description>Off, Demand, Manual, Program</description>\n+\t\t<state>\n+\t\t\t<options>\n+\t\t\t\t<option value=\"DEMAND\">Demand</option>\n+\t\t\t\t<option value=\"PROGRAM\">Program</option>\n+\t\t\t\t<option value=\"MANUAL\">Manual</option>\n+\t\t\t\t<option value=\"OFF\">Off</option>\n+\t\t\t</options>\n+\t\t</state>\n+\t</channel-type>\n+\t<channel-type id=\"manualFanSpeed\">\n+\t\t<item-type>Dimmer</item-type>\n+\t\t<label>Manual Fan Speed</label>\n+\t\t<state step=\"10\" min=\"0\" max=\"100\" />\n+\t</channel-type>\n+\t<channel-type id=\"supplyFanSpeed\">\n+\t\t<item-type>Number</item-type>\n+\t\t<label>Supply Fan Speed</label>\n+\t\t<state pattern=\"%.0f rpm\" readOnly=\"true\" min=\"0\" />\n+\t</channel-type>\n+\t<channel-type id=\"extractFanSpeed\">\n+\t\t<item-type>Number</item-type>\n+\t\t<label>Extract Fan Speed</label>\n+\t\t<state pattern=\"%.0f rpm\" readOnly=\"true\" min=\"0\" />\n+\t</channel-type>\n+\t<channel-type id=\"percentage\">\n+\t\t<item-type>Number</item-type>\n+\t\t<label>Percentage</label>\n+\t\t<description>Read only percentage</description>\n+\t\t<state pattern=\"%.0f %%\" readOnly=\"true\" min=\"0\" max=\"100\" />\n+\t</channel-type>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "80f84c03c034dcb4c1f7a3571d06df1b43a2e71e"}, "originalPosition": 165}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzcwODQ2NjQ1", "url": "https://github.com/openhab/openhab-addons/pull/6814#pullrequestreview-370846645", "createdAt": "2020-03-08T17:42:50Z", "commit": {"oid": "135ef20d83e815afa86904aabd4bbf102be92315"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wOFQxNzo0Mjo1MFrOFzWgmQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wOFQxODo0NTozNFrOFzWxvg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTM5MDQ4OQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    scheduler.schedule(this::discover, 0, TimeUnit.SECONDS);\n          \n          \n            \n                    scheduler.execute(this::discover);", "url": "https://github.com/openhab/openhab-addons/pull/6814#discussion_r389390489", "createdAt": "2020-03-08T17:42:50Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/discovery/DanfossAirUnitDiscoveryService.java", "diffHunk": "@@ -0,0 +1,140 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.danfossairunit.internal.discovery;\n+\n+import static org.openhab.binding.danfossairunit.internal.DanfossAirUnitBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.InetAddress;\n+import java.net.InterfaceAddress;\n+import java.net.NetworkInterface;\n+import java.net.SocketTimeoutException;\n+import java.util.*;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.smarthome.config.discovery.AbstractDiscoveryService;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResult;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResultBuilder;\n+import org.eclipse.smarthome.config.discovery.DiscoveryService;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.thing.ThingUID;\n+import org.osgi.service.component.annotations.Component;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The Discovery service implementation to scan for available air units in the network via broadcast.\n+ *\n+ * @author Ralf Duckstein - Initial contribution\n+ * @author Robert Bach - heavy refactorings\n+ */\n+@Component(service = DiscoveryService.class, immediate = true)\n+@NonNullByDefault\n+public class DanfossAirUnitDiscoveryService extends AbstractDiscoveryService {\n+\n+    private static final int BROADCAST_PORT = 30045;\n+    private static final byte[] DISCOVER_SEND = { 0x0c, 0x00, 0x30, 0x00, 0x11, 0x00, 0x12, 0x00, 0x13 };\n+    private static final byte[] DISCOVER_RECEIVE = { 0x0d, 0x00, 0x07, 0x00, 0x02, 0x02, 0x00 };\n+\n+    private Logger logger = LoggerFactory.getLogger(DanfossAirUnitDiscoveryService.class);\n+\n+    public DanfossAirUnitDiscoveryService() {\n+        super(SUPPORTED_THING_TYPES_UIDS, 15, true);\n+    }\n+\n+    @Override\n+    public Set<ThingTypeUID> getSupportedThingTypes() {\n+        return SUPPORTED_THING_TYPES_UIDS;\n+    }\n+\n+    @Override\n+    protected void startBackgroundDiscovery() {\n+        logger.debug(\"Start Danfoss Air CCM background discovery\");\n+        scheduler.schedule(this::discover, 0, TimeUnit.SECONDS);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "135ef20d83e815afa86904aabd4bbf102be92315"}, "originalPosition": 66}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTM5MjEyNw==", "bodyText": "This exception isn't used anywhere now, please delete this class", "url": "https://github.com/openhab/openhab-addons/pull/6814#discussion_r389392127", "createdAt": "2020-03-08T18:06:04Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/DisconnectedException.java", "diffHunk": "@@ -0,0 +1,43 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.danfossairunit.internal;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+\n+/**\n+ * Represents a communication failure with the air unit when it has not been connected.\n+ *\n+ * @author Robert Bach - Initial contribution\n+ */\n+@NonNullByDefault\n+public class DisconnectedException extends RuntimeException {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTkzNzY2MQ=="}, "originalCommit": {"oid": "ad93709e77a6687e32c3a9cdab3d8e74b61979c4"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTM5MjYxMA==", "bodyText": "IllegalArgumentException should be reserved for invalid or incorrect arguments to a function or constructor. This case is neither of those as you are handling a response message. You should either throw an IOException or return Float.NaN then handle the NaN case elsewhere in your code.", "url": "https://github.com/openhab/openhab-addons/pull/6814#discussion_r389392610", "createdAt": "2020-03-08T18:12:49Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/DanfossAirUnit.java", "diffHunk": "@@ -0,0 +1,278 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.danfossairunit.internal;\n+\n+import java.io.IOException;\n+import java.math.BigDecimal;\n+import java.math.RoundingMode;\n+import java.net.InetAddress;\n+import java.nio.charset.StandardCharsets;\n+import java.time.DateTimeException;\n+import java.time.ZoneId;\n+import java.time.ZonedDateTime;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.smarthome.core.library.types.DateTimeType;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link DanfossAirUnit} class represents the air unit device and build the commands to be sent by\n+ * {@link DanfossAirUnitCommunicationController}\n+ *\n+ * @author Ralf Duckstein - Initial contribution\n+ * @author Robert Bach - heavy refactorings\n+ */\n+\n+@SuppressWarnings(\"SameParameterValue\")\n+@NonNullByDefault\n+public class DanfossAirUnit implements Commands {\n+\n+    private final Logger logger = LoggerFactory.getLogger(DanfossAirUnit.class);\n+    private final DanfossAirUnitCommunicationController communicationController;\n+\n+    public DanfossAirUnit(InetAddress inetAddr, int port) {\n+        this.communicationController  = new DanfossAirUnitCommunicationController(inetAddr, port);\n+    }\n+\n+    public void cleanUp() {\n+        this.communicationController.disconnect();\n+    }\n+\n+    private boolean getBoolean(byte[] operation, byte[] register) throws IOException {\n+        return communicationController.sendRobustRequest(operation, register)[0] != 0;\n+    }\n+\n+    private void setSetting(byte[] register, boolean value) throws IOException {\n+        setSetting(register, value ? (byte) 1 : (byte) 0);\n+    }\n+\n+    private short getWord(byte[] operation, byte[] register) throws IOException {\n+        byte[] resultBytes = communicationController.sendRobustRequest(operation, register);\n+        return (short)((resultBytes[0] << 8)  | (resultBytes[1] & 0xFF));\n+    }\n+\n+    private byte getByte(byte[] operation, byte[] register) throws IOException {\n+        return communicationController.sendRobustRequest(operation, register)[0];\n+    }\n+\n+    private String getString(byte[] operation, byte[] register) throws IOException {\n+        // length of the string is stored in the first byte\n+        byte[] result = communicationController.sendRobustRequest(operation, register);\n+        return new String(result, 1, result[0], StandardCharsets.US_ASCII);\n+    }\n+\n+    private void set(byte[] operation, byte[] register, byte value) throws IOException {\n+        byte[] valueArray = { value };\n+        communicationController.sendRobustRequest(operation, register, valueArray);\n+    }\n+\n+    private void set(byte[] operation, byte[] register, short value) throws IOException {\n+        communicationController.sendRobustRequest(operation, register, shortToBytes(value));\n+    }\n+\n+    private byte[] shortToBytes(short s) {\n+        return new byte[]{(byte)((s & 0xFF00) >> 8),(byte)(s & 0x00FF)};\n+    }\n+\n+    private short getShort(byte[] operation, byte[] register) throws IOException {\n+        byte[] result = communicationController.sendRobustRequest(operation, register);\n+        return (short) ((result[0] << 8) + (result[1] & 0xff));\n+    }\n+\n+    private float getTemperature(byte[] operation, byte[] register) throws IOException {\n+        short shortTemp = getShort(operation, register);\n+        float temp = ((float) shortTemp) / 100;\n+        if (temp <= -274 || temp > 100) {\n+            throw new IllegalArgumentException(String.format(\"Invalid temperature: %s\", temp));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "135ef20d83e815afa86904aabd4bbf102be92315"}, "originalPosition": 102}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTM5Mjg2Nw==", "bodyText": "Is this supposed to be a signed byte value? This code will allow years in the range 1872-2127. Just checking if that is what you are expecting.", "url": "https://github.com/openhab/openhab-addons/pull/6814#discussion_r389392867", "createdAt": "2020-03-08T18:16:10Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/DanfossAirUnit.java", "diffHunk": "@@ -0,0 +1,278 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.danfossairunit.internal;\n+\n+import java.io.IOException;\n+import java.math.BigDecimal;\n+import java.math.RoundingMode;\n+import java.net.InetAddress;\n+import java.nio.charset.StandardCharsets;\n+import java.time.DateTimeException;\n+import java.time.ZoneId;\n+import java.time.ZonedDateTime;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.smarthome.core.library.types.DateTimeType;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link DanfossAirUnit} class represents the air unit device and build the commands to be sent by\n+ * {@link DanfossAirUnitCommunicationController}\n+ *\n+ * @author Ralf Duckstein - Initial contribution\n+ * @author Robert Bach - heavy refactorings\n+ */\n+\n+@SuppressWarnings(\"SameParameterValue\")\n+@NonNullByDefault\n+public class DanfossAirUnit implements Commands {\n+\n+    private final Logger logger = LoggerFactory.getLogger(DanfossAirUnit.class);\n+    private final DanfossAirUnitCommunicationController communicationController;\n+\n+    public DanfossAirUnit(InetAddress inetAddr, int port) {\n+        this.communicationController  = new DanfossAirUnitCommunicationController(inetAddr, port);\n+    }\n+\n+    public void cleanUp() {\n+        this.communicationController.disconnect();\n+    }\n+\n+    private boolean getBoolean(byte[] operation, byte[] register) throws IOException {\n+        return communicationController.sendRobustRequest(operation, register)[0] != 0;\n+    }\n+\n+    private void setSetting(byte[] register, boolean value) throws IOException {\n+        setSetting(register, value ? (byte) 1 : (byte) 0);\n+    }\n+\n+    private short getWord(byte[] operation, byte[] register) throws IOException {\n+        byte[] resultBytes = communicationController.sendRobustRequest(operation, register);\n+        return (short)((resultBytes[0] << 8)  | (resultBytes[1] & 0xFF));\n+    }\n+\n+    private byte getByte(byte[] operation, byte[] register) throws IOException {\n+        return communicationController.sendRobustRequest(operation, register)[0];\n+    }\n+\n+    private String getString(byte[] operation, byte[] register) throws IOException {\n+        // length of the string is stored in the first byte\n+        byte[] result = communicationController.sendRobustRequest(operation, register);\n+        return new String(result, 1, result[0], StandardCharsets.US_ASCII);\n+    }\n+\n+    private void set(byte[] operation, byte[] register, byte value) throws IOException {\n+        byte[] valueArray = { value };\n+        communicationController.sendRobustRequest(operation, register, valueArray);\n+    }\n+\n+    private void set(byte[] operation, byte[] register, short value) throws IOException {\n+        communicationController.sendRobustRequest(operation, register, shortToBytes(value));\n+    }\n+\n+    private byte[] shortToBytes(short s) {\n+        return new byte[]{(byte)((s & 0xFF00) >> 8),(byte)(s & 0x00FF)};\n+    }\n+\n+    private short getShort(byte[] operation, byte[] register) throws IOException {\n+        byte[] result = communicationController.sendRobustRequest(operation, register);\n+        return (short) ((result[0] << 8) + (result[1] & 0xff));\n+    }\n+\n+    private float getTemperature(byte[] operation, byte[] register) throws IOException {\n+        short shortTemp = getShort(operation, register);\n+        float temp = ((float) shortTemp) / 100;\n+        if (temp <= -274 || temp > 100) {\n+            throw new IllegalArgumentException(String.format(\"Invalid temperature: %s\", temp));\n+        }\n+        return temp;\n+    }\n+\n+    private ZonedDateTime getTimestamp(byte[] operation, byte[] register) throws IOException {\n+        byte[] result = communicationController.sendRobustRequest(operation, register);\n+        return asZonedDateTime(result);\n+    }\n+\n+    private ZonedDateTime asZonedDateTime(byte[] data) {\n+        int second = data[0];\n+        int minute = data[1];\n+        int hour = data[2] & 0x1f;\n+        int day = data[3] & 0x1f;\n+        int month = data[4];\n+        int year = data[5] + 2000;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "135ef20d83e815afa86904aabd4bbf102be92315"}, "originalPosition": 118}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTM5MzMxNQ==", "bodyText": "I wouldn't throw an IllegalArgumentException. Similar to reasons I mentioned above. This code is used to process response messages and as such it should be a checked exception like an IOException.", "url": "https://github.com/openhab/openhab-addons/pull/6814#discussion_r389393315", "createdAt": "2020-03-08T18:22:25Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/DanfossAirUnit.java", "diffHunk": "@@ -0,0 +1,278 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.danfossairunit.internal;\n+\n+import java.io.IOException;\n+import java.math.BigDecimal;\n+import java.math.RoundingMode;\n+import java.net.InetAddress;\n+import java.nio.charset.StandardCharsets;\n+import java.time.DateTimeException;\n+import java.time.ZoneId;\n+import java.time.ZonedDateTime;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.smarthome.core.library.types.DateTimeType;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link DanfossAirUnit} class represents the air unit device and build the commands to be sent by\n+ * {@link DanfossAirUnitCommunicationController}\n+ *\n+ * @author Ralf Duckstein - Initial contribution\n+ * @author Robert Bach - heavy refactorings\n+ */\n+\n+@SuppressWarnings(\"SameParameterValue\")\n+@NonNullByDefault\n+public class DanfossAirUnit implements Commands {\n+\n+    private final Logger logger = LoggerFactory.getLogger(DanfossAirUnit.class);\n+    private final DanfossAirUnitCommunicationController communicationController;\n+\n+    public DanfossAirUnit(InetAddress inetAddr, int port) {\n+        this.communicationController  = new DanfossAirUnitCommunicationController(inetAddr, port);\n+    }\n+\n+    public void cleanUp() {\n+        this.communicationController.disconnect();\n+    }\n+\n+    private boolean getBoolean(byte[] operation, byte[] register) throws IOException {\n+        return communicationController.sendRobustRequest(operation, register)[0] != 0;\n+    }\n+\n+    private void setSetting(byte[] register, boolean value) throws IOException {\n+        setSetting(register, value ? (byte) 1 : (byte) 0);\n+    }\n+\n+    private short getWord(byte[] operation, byte[] register) throws IOException {\n+        byte[] resultBytes = communicationController.sendRobustRequest(operation, register);\n+        return (short)((resultBytes[0] << 8)  | (resultBytes[1] & 0xFF));\n+    }\n+\n+    private byte getByte(byte[] operation, byte[] register) throws IOException {\n+        return communicationController.sendRobustRequest(operation, register)[0];\n+    }\n+\n+    private String getString(byte[] operation, byte[] register) throws IOException {\n+        // length of the string is stored in the first byte\n+        byte[] result = communicationController.sendRobustRequest(operation, register);\n+        return new String(result, 1, result[0], StandardCharsets.US_ASCII);\n+    }\n+\n+    private void set(byte[] operation, byte[] register, byte value) throws IOException {\n+        byte[] valueArray = { value };\n+        communicationController.sendRobustRequest(operation, register, valueArray);\n+    }\n+\n+    private void set(byte[] operation, byte[] register, short value) throws IOException {\n+        communicationController.sendRobustRequest(operation, register, shortToBytes(value));\n+    }\n+\n+    private byte[] shortToBytes(short s) {\n+        return new byte[]{(byte)((s & 0xFF00) >> 8),(byte)(s & 0x00FF)};\n+    }\n+\n+    private short getShort(byte[] operation, byte[] register) throws IOException {\n+        byte[] result = communicationController.sendRobustRequest(operation, register);\n+        return (short) ((result[0] << 8) + (result[1] & 0xff));\n+    }\n+\n+    private float getTemperature(byte[] operation, byte[] register) throws IOException {\n+        short shortTemp = getShort(operation, register);\n+        float temp = ((float) shortTemp) / 100;\n+        if (temp <= -274 || temp > 100) {\n+            throw new IllegalArgumentException(String.format(\"Invalid temperature: %s\", temp));\n+        }\n+        return temp;\n+    }\n+\n+    private ZonedDateTime getTimestamp(byte[] operation, byte[] register) throws IOException {\n+        byte[] result = communicationController.sendRobustRequest(operation, register);\n+        return asZonedDateTime(result);\n+    }\n+\n+    private ZonedDateTime asZonedDateTime(byte[] data) {\n+        int second = data[0];\n+        int minute = data[1];\n+        int hour = data[2] & 0x1f;\n+        int day = data[3] & 0x1f;\n+        int month = data[4];\n+        int year = data[5] + 2000;\n+        try {\n+            return ZonedDateTime.of(year, month, day, hour, minute, second, 0, ZoneId.systemDefault());\n+        } catch (DateTimeException e) {\n+            logger.debug(\"Ignoring invalid timestamp {}.{}.{} {}:{}:{}\", day, month, year, hour, minute, second);\n+            throw new IllegalArgumentException();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "135ef20d83e815afa86904aabd4bbf102be92315"}, "originalPosition": 123}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTM5MzM0OQ==", "bodyText": "Not UTF-8? Unusual.", "url": "https://github.com/openhab/openhab-addons/pull/6814#discussion_r389393349", "createdAt": "2020-03-08T18:23:04Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/DanfossAirUnit.java", "diffHunk": "@@ -0,0 +1,278 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.danfossairunit.internal;\n+\n+import java.io.IOException;\n+import java.math.BigDecimal;\n+import java.math.RoundingMode;\n+import java.net.InetAddress;\n+import java.nio.charset.StandardCharsets;\n+import java.time.DateTimeException;\n+import java.time.ZoneId;\n+import java.time.ZonedDateTime;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.smarthome.core.library.types.DateTimeType;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link DanfossAirUnit} class represents the air unit device and build the commands to be sent by\n+ * {@link DanfossAirUnitCommunicationController}\n+ *\n+ * @author Ralf Duckstein - Initial contribution\n+ * @author Robert Bach - heavy refactorings\n+ */\n+\n+@SuppressWarnings(\"SameParameterValue\")\n+@NonNullByDefault\n+public class DanfossAirUnit implements Commands {\n+\n+    private final Logger logger = LoggerFactory.getLogger(DanfossAirUnit.class);\n+    private final DanfossAirUnitCommunicationController communicationController;\n+\n+    public DanfossAirUnit(InetAddress inetAddr, int port) {\n+        this.communicationController  = new DanfossAirUnitCommunicationController(inetAddr, port);\n+    }\n+\n+    public void cleanUp() {\n+        this.communicationController.disconnect();\n+    }\n+\n+    private boolean getBoolean(byte[] operation, byte[] register) throws IOException {\n+        return communicationController.sendRobustRequest(operation, register)[0] != 0;\n+    }\n+\n+    private void setSetting(byte[] register, boolean value) throws IOException {\n+        setSetting(register, value ? (byte) 1 : (byte) 0);\n+    }\n+\n+    private short getWord(byte[] operation, byte[] register) throws IOException {\n+        byte[] resultBytes = communicationController.sendRobustRequest(operation, register);\n+        return (short)((resultBytes[0] << 8)  | (resultBytes[1] & 0xFF));\n+    }\n+\n+    private byte getByte(byte[] operation, byte[] register) throws IOException {\n+        return communicationController.sendRobustRequest(operation, register)[0];\n+    }\n+\n+    private String getString(byte[] operation, byte[] register) throws IOException {\n+        // length of the string is stored in the first byte\n+        byte[] result = communicationController.sendRobustRequest(operation, register);\n+        return new String(result, 1, result[0], StandardCharsets.US_ASCII);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "135ef20d83e815afa86904aabd4bbf102be92315"}, "originalPosition": 77}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTM5NDg3OA==", "bodyText": "You shouldn't catch RuntimeException here. If you are trying to catch exceptions that occur in your accessor then then your accessor should throw checked exceptions that you can then handle here.", "url": "https://github.com/openhab/openhab-addons/pull/6814#discussion_r389394878", "createdAt": "2020-03-08T18:45:34Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/DanfossAirUnitHandler.java", "diffHunk": "@@ -0,0 +1,160 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.danfossairunit.internal;\n+\n+import static org.openhab.binding.danfossairunit.internal.DanfossAirUnitBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.net.UnknownHostException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link DanfossAirUnitHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Ralf Duckstein - Initial contribution\n+ * @author Robert Bach - heavy refactorings\n+ */\n+@NonNullByDefault\n+public class DanfossAirUnitHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(DanfossAirUnitHandler.class);\n+\n+    private @Nullable DanfossAirUnitConfiguration config;\n+\n+    public DanfossAirUnitHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    private @Nullable ValueCache valueCache;\n+\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+    private @Nullable DanfossAirUnit hrv;\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            updateAllChannels();\n+        } else {\n+            try {\n+                DanfossAirUnit danfossAirUnit = hrv;\n+                Channel channel = Channel.getByName(channelUID.getIdWithoutGroup());\n+                if (channel.getWriteAccessor() != null) {\n+                    updateState(channelUID, channel.getWriteAccessor().access(danfossAirUnit, command));\n+                }\n+            } catch (IllegalArgumentException e) {\n+                logger.info(\"{}\", e.getMessage());\n+            } catch (IOException ioe) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR, ioe.getMessage());\n+            } catch (Exception e) {\n+                logger.info(\"Error updating channel {}: {}\", channelUID, e.getMessage());\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        updateStatus(ThingStatus.UNKNOWN);\n+        config = getConfigAs(DanfossAirUnitConfiguration.class);\n+        valueCache = new ValueCache(config.updateUnchangedValuesEveryMillis);\n+        try {\n+            hrv = new DanfossAirUnit(InetAddress.getByName(config.host), 30046);\n+        } catch (UnknownHostException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                    \"Unknown host: \" + config.host);\n+        }\n+\n+        scheduler.execute(() -> {\n+            try {\n+                thing.setProperty(PROPERTY_UNIT_NAME, hrv.getUnitName());\n+                thing.setProperty(PROPERTY_SERIAL, hrv.getUnitSerialNumber());\n+                pollingJob = scheduler.scheduleWithFixedDelay(this::updateAllChannels, 5, config.refreshInterval,\n+                        TimeUnit.SECONDS);\n+                updateStatus(ThingStatus.ONLINE);\n+\n+            } catch (IOException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR, e.getMessage());\n+            }\n+        });\n+    }\n+\n+    private void updateAllChannels() {\n+        if (hrv == null) {\n+            return;\n+        }\n+        DanfossAirUnit danfossAirUnit = hrv;\n+        logger.debug(\"Updating DanfossHRV data '{}'\", getThing().getUID());\n+\n+        try {\n+            for (Channel channel : Channel.values()) {\n+                if (Thread.interrupted()) {\n+                    logger.debug(\"Polling thread interrupted...\");\n+                    return;\n+                }\n+                try {\n+                    updateState(channel.getGroup().getGroupName(), channel.getChannelName(),\n+                            channel.getReadAccessor().access(danfossAirUnit));\n+                } catch (RuntimeException e) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "135ef20d83e815afa86904aabd4bbf102be92315"}, "originalPosition": 123}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzcwOTI3MTcy", "url": "https://github.com/openhab/openhab-addons/pull/6814#pullrequestreview-370927172", "createdAt": "2020-03-09T05:44:27Z", "commit": {"oid": "04f171986cfdf5462a02a68015ddca808913c996"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wOVQwNTo0NDoyN1rOFzbd5A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wOVQwNTo1MTozMVrOFzbjNA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTQ3MTcxNg==", "bodyText": "Please move this field above the constructor", "url": "https://github.com/openhab/openhab-addons/pull/6814#discussion_r389471716", "createdAt": "2020-03-09T05:44:27Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/ChannelGroup.java", "diffHunk": "@@ -0,0 +1,36 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.danfossairunit.internal;\n+\n+/**\n+ * Represents a channel group, channels are divided into.\n+ *\n+ * @author Robert Bach - Initial contribution\n+ */\n+public enum ChannelGroup {\n+    MAIN(\"main\"),\n+    TEMPS(\"temps\"),\n+    HUMIDITY(\"humidity\"),\n+    RECUPERATOR(\"recuperator\"),\n+    SERVICE(\"service\");\n+\n+    ChannelGroup(String groupName) {\n+        this.groupName = groupName;\n+    }\n+\n+    private String groupName;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "04f171986cfdf5462a02a68015ddca808913c996"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTQ3MjMwMA==", "bodyText": "Could you please try and address this?", "url": "https://github.com/openhab/openhab-addons/pull/6814#discussion_r389472300", "createdAt": "2020-03-09T05:47:22Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.danfossairunit/src/main/resources/ESH-INF/thing/thing-types.xml", "diffHunk": "@@ -0,0 +1,191 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"danfossairunit\"\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\n+\t<!--HRV -->\n+\t<thing-type id=\"airunit\">\n+\t\t<label>Danfoss Air Unit</label>\n+\t\t<description>The Danfoss Air Unit Heat Exchanger, CCM and Air Dial</description>\n+\n+\t\t<channel-groups>\n+\t\t\t<channel-group id=\"main\" typeId=\"main\" />\n+\t\t\t<channel-group id=\"temps\" typeId=\"temps\" />\n+\t\t\t<channel-group id=\"humidity\" typeId=\"humidity\" />\n+\t\t\t<channel-group id=\"recuperator\" typeId=\"recuperator\" />\n+\t\t\t<channel-group id=\"service\" typeId=\"service\" />\n+\t\t</channel-groups>\n+\t\t<properties>\n+\t\t\t<property name=\"Unit Name\">unknown</property>\n+\t\t\t<property name=\"Serial Number\">unknown</property>\n+\t\t</properties>\n+\t\t<config-description>\n+\t\t\t<parameter name=\"host\" type=\"text\" required=\"true\">\n+\t\t\t\t<label>Host</label>\n+\t\t\t\t<context>network-address</context>\n+\t\t\t\t<description>Host name or IP address of the Danfoss Air CCM</description>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"refreshInterval\" type=\"integer\" required=\"false\" unit=\"s\">\n+\t\t\t\t<default>10</default>\n+\t\t\t\t<label>Refresh Interval</label>\n+\t\t\t\t<unitLabel>Seconds</unitLabel>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"updateUnchangedValuesEveryMillis\" type=\"integer\" min=\"0\" unit=\"ms\">\n+\t\t\t\t<label>Interval for Updating Unchanged Values</label>\n+\t\t\t\t<default>60000</default>\n+\t\t\t\t<unitLabel>ms</unitLabel>\n+\t\t\t\t<description>Interval to update unchanged values (to the event bus) in milliseconds. A value of 0 means that every\n+\t\t\t\t\tvalue (received via polling the air unit) is updated to the event bus, unchanged or not.</description>\n+\t\t\t\t<advanced>true</advanced>\n+\t\t\t</parameter>\n+\t\t</config-description>\n+\n+\t</thing-type>\n+\n+\t<!--Cannel Group Definitions -->\n+\t<channel-group-type id=\"main\">\n+\t\t<label>Mode and Fan Speeds</label>\n+\t\t<channels>\n+\t\t\t<channel id=\"current_time\" typeId=\"currentTime\" />\n+\t\t\t<channel id=\"mode\" typeId=\"mode\" />\n+\t\t\t<channel id=\"manual_fan_speed\" typeId=\"manualFanSpeed\" />\n+\t\t\t<channel id=\"supply_fan_speed\" typeId=\"supplyFanSpeed\" />\n+\t\t\t<channel id=\"extract_fan_speed\" typeId=\"extractFanSpeed\" />\n+\t\t\t<channel id=\"boost\" typeId=\"switch\">\n+\t\t\t\t<label>Boost</label>\n+\t\t\t\t<description>Enables fan boost</description>\n+\t\t\t</channel>\n+\t\t\t<channel id=\"night_cooling\" typeId=\"switch\">\n+\t\t\t\t<label>Night cooling</label>\n+\t\t\t\t<description>Enables night cooling</description>\n+\t\t\t</channel>\n+\t\t</channels>\n+\t</channel-group-type>\n+\t<channel-group-type id=\"temps\">\n+\t\t<label>Temperatures</label>\n+\t\t<category>Temperature</category>\n+\t\t<channels>\n+\t\t\t<channel id=\"room_temp\" typeId=\"temperature\">\n+\t\t\t\t<label>Room Temperature</label>\n+\t\t\t\t<description>Temperature of the air in the room of the Air Dial</description>\n+\t\t\t</channel>\n+\t\t\t<channel id=\"room_temp_calculated\" typeId=\"temperature\">\n+\t\t\t\t<label>Calculated Room Temperature</label>\n+\t\t\t\t<description>Calculated Room Temperature</description>\n+\t\t\t</channel>\n+\t\t\t<channel id=\"outdoor_temp\" typeId=\"temperature\">\n+\t\t\t\t<label>Outdoor Temperature</label>\n+\t\t\t\t<description>Temperature of the air outside</description>\n+\t\t\t</channel>\n+\t\t</channels>\n+\t</channel-group-type>\n+\t<channel-group-type id=\"humidity\">\n+\t\t<label>Humidity</label>\n+\t\t<channels>\n+\t\t\t<channel id=\"humidity\" typeId=\"humidity\" />\n+\t\t</channels>\n+\t</channel-group-type>\n+\t<channel-group-type id=\"recuperator\" advanced=\"true\">\n+\t\t<label>Recuperator</label>\n+\t\t<description>Heat exchaning device in the Air Unit</description>\n+\t\t<channels>\n+\t\t\t<channel id=\"bypass\" typeId=\"switch\">\n+\t\t\t\t<label>Bypass</label>\n+\t\t\t\t<description>Disables the heat exchange. Useful in summer when room temperature is above target and outside\n+\t\t\t\t\ttemperature is below target.</description>\n+\t\t\t</channel>\n+\t\t\t<channel id=\"supply_temp\" typeId=\"temperature\">\n+\t\t\t\t<label>Supply Air Temperature</label>\n+\t\t\t\t<description>Temperature of air which is passed to the rooms</description>\n+\t\t\t</channel>\n+\t\t\t<channel id=\"extract_temp\" typeId=\"temperature\">\n+\t\t\t\t<label>Extract Air Temperature</label>\n+\t\t\t\t<description>Temperature of the air as extracted from the rooms</description>\n+\t\t\t</channel>\n+\t\t\t<channel id=\"exhaust_temp\" typeId=\"temperature\">\n+\t\t\t\t<label>Exhaust Air Temperature</label>\n+\t\t\t\t<description>Temperature of the air when pushed outside</description>\n+\t\t\t</channel>\n+\t\t</channels>\n+\t</channel-group-type>\n+\t<channel-group-type id=\"service\" advanced=\"true\">\n+\t\t<label>Service</label>\n+\t\t<channels>\n+\t\t\t<channel id=\"battery_life\" typeId=\"percentage\">\n+\t\t\t\t<label>Battery Life</label>\n+\t\t\t\t<description>Remaining Air Dial Battery Level</description>\n+\t\t\t</channel>\n+\t\t\t<channel id=\"filter_life\" typeId=\"percentage\">\n+\t\t\t\t<label>Remaining Filter Life</label>\n+\t\t\t\t<description>Remaining life of filter until exchange is necessary</description>\n+\t\t\t</channel>\n+\t\t</channels>\n+\t</channel-group-type>\n+\n+\t<!--Channel Definitions -->\n+\t<channel-type id=\"currentTime\">\n+\t\t<item-type>DateTime</item-type>\n+\t\t<label>Current Time</label>\n+\t\t<state readOnly=\"true\" />\n+\t</channel-type>\n+\t<channel-type id=\"mode\">\n+\t\t<item-type>String</item-type>\n+\t\t<label>Mode</label>\n+\t\t<description>Off, Demand, Manual, Program</description>\n+\t\t<state>\n+\t\t\t<options>\n+\t\t\t\t<option value=\"DEMAND\">Demand</option>\n+\t\t\t\t<option value=\"PROGRAM\">Program</option>\n+\t\t\t\t<option value=\"MANUAL\">Manual</option>\n+\t\t\t\t<option value=\"OFF\">Off</option>\n+\t\t\t</options>\n+\t\t</state>\n+\t</channel-type>\n+\t<channel-type id=\"manualFanSpeed\">\n+\t\t<item-type>Dimmer</item-type>\n+\t\t<label>Manual Fan Speed</label>\n+\t\t<state step=\"10\" />\n+\t</channel-type>\n+\t<channel-type id=\"supplyFanSpeed\">\n+\t\t<item-type>Number</item-type>\n+\t\t<label>Supply Fan Speed</label>\n+\t\t<state pattern=\"%.0f rpm\" readOnly=\"true\" min=\"0\" />\n+\t</channel-type>\n+\t<channel-type id=\"extractFanSpeed\">\n+\t\t<item-type>Number</item-type>\n+\t\t<label>Extract Fan Speed</label>\n+\t\t<state pattern=\"%.0f rpm\" readOnly=\"true\" min=\"0\" />\n+\t</channel-type>\n+\t<channel-type id=\"percentage\">\n+\t\t<item-type>Number</item-type>\n+\t\t<label>Percentage</label>\n+\t\t<description>Read only percentage</description>\n+\t\t<state pattern=\"%.0f %%\" readOnly=\"true\" min=\"0\" max=\"100\" />\n+\t</channel-type>\n+\t<channel-type id=\"humidity\">\n+\t\t<item-type>Number</item-type>\n+\t\t<label>Humidity</label>\n+\t\t<category>Humidity</category>\n+\t\t<tags>\n+\t\t\t<tag>CurrentHumidity</tag>\n+\t\t</tags>\n+\t\t<state pattern=\"%.0f %%\" readOnly=\"true\" min=\"0\" max=\"100\">\n+\t\t</state>\n+\t</channel-type>\n+\t<channel-type id=\"switch\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Something that can be turned on or off</label>\n+\t</channel-type>\n+\t<channel-type id=\"temperature\">\n+\t\t<item-type>Number</item-type>\n+\t\t<label>Temperature</label>\n+\t\t<description>A measured temperature</description>\n+\t\t<category>Temperature</category>\n+\t\t<tags>\n+\t\t\t<tag>CurrentTemperature</tag>\n+\t\t</tags>\n+\t\t<state pattern=\"%.1f \u00b0C\" readOnly=\"true\" />", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTkxOTI3MA=="}, "originalCommit": {"oid": "ad93709e77a6687e32c3a9cdab3d8e74b61979c4"}, "originalPosition": 188}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTQ3Mjk2NA==", "bodyText": "Are these properties meant to get populated elsewhere?", "url": "https://github.com/openhab/openhab-addons/pull/6814#discussion_r389472964", "createdAt": "2020-03-09T05:50:54Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.danfossairunit/src/main/resources/ESH-INF/thing/thing-types.xml", "diffHunk": "@@ -0,0 +1,203 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"danfossairunit\"\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\n+\t<!--HRV -->\n+\t<thing-type id=\"airunit\">\n+\t\t<label>Danfoss Air Unit</label>\n+\t\t<description>The Danfoss Air Unit Heat Exchanger, CCM and Air Dial</description>\n+\n+\t\t<channel-groups>\n+\t\t\t<channel-group id=\"main\" typeId=\"main\" />\n+\t\t\t<channel-group id=\"temps\" typeId=\"temps\" />\n+\t\t\t<channel-group id=\"humidity\" typeId=\"humidity\" />\n+\t\t\t<channel-group id=\"recuperator\" typeId=\"recuperator\" />\n+\t\t\t<channel-group id=\"service\" typeId=\"service\" />\n+\t\t</channel-groups>\n+\t\t<properties>\n+\t\t\t<property name=\"Unit Name\">unknown</property>\n+\t\t\t<property name=\"Serial Number\">unknown</property>\n+\t\t</properties>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "04f171986cfdf5462a02a68015ddca808913c996"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTQ3MzA3Ng==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\t\t\t<label>Night cooling</label>\n          \n          \n            \n            \t\t\t\t<label>Night Cooling</label>", "url": "https://github.com/openhab/openhab-addons/pull/6814#discussion_r389473076", "createdAt": "2020-03-09T05:51:31Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.danfossairunit/src/main/resources/ESH-INF/thing/thing-types.xml", "diffHunk": "@@ -0,0 +1,203 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"danfossairunit\"\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\n+\t<!--HRV -->\n+\t<thing-type id=\"airunit\">\n+\t\t<label>Danfoss Air Unit</label>\n+\t\t<description>The Danfoss Air Unit Heat Exchanger, CCM and Air Dial</description>\n+\n+\t\t<channel-groups>\n+\t\t\t<channel-group id=\"main\" typeId=\"main\" />\n+\t\t\t<channel-group id=\"temps\" typeId=\"temps\" />\n+\t\t\t<channel-group id=\"humidity\" typeId=\"humidity\" />\n+\t\t\t<channel-group id=\"recuperator\" typeId=\"recuperator\" />\n+\t\t\t<channel-group id=\"service\" typeId=\"service\" />\n+\t\t</channel-groups>\n+\t\t<properties>\n+\t\t\t<property name=\"Unit Name\">unknown</property>\n+\t\t\t<property name=\"Serial Number\">unknown</property>\n+\t\t</properties>\n+\t\t<config-description>\n+\t\t\t<parameter name=\"host\" type=\"text\" required=\"true\">\n+\t\t\t\t<label>Host</label>\n+\t\t\t\t<context>network-address</context>\n+\t\t\t\t<description>Host name or IP address of the Danfoss Air CCM</description>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"refreshInterval\" type=\"integer\" required=\"false\" unit=\"s\">\n+\t\t\t\t<default>10</default>\n+\t\t\t\t<label>Refresh Interval</label>\n+\t\t\t\t<unitLabel>Seconds</unitLabel>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"updateUnchangedValuesEveryMillis\" type=\"integer\" min=\"0\" unit=\"ms\">\n+\t\t\t\t<label>Interval for Updating Unchanged Values</label>\n+\t\t\t\t<default>60000</default>\n+\t\t\t\t<unitLabel>ms</unitLabel>\n+\t\t\t\t<description>Interval to update unchanged values (to the event bus) in milliseconds. A value of 0 means that every\n+\t\t\t\t\tvalue (received via polling from the air unit) is updated to the event bus, unchanged or not.</description>\n+\t\t\t\t<advanced>true</advanced>\n+\t\t\t</parameter>\n+\t\t</config-description>\n+\n+\t</thing-type>\n+\n+\t<!--Cannel Group Definitions -->\n+\t<channel-group-type id=\"main\">\n+\t\t<label>Mode and Fan Speeds</label>\n+\t\t<channels>\n+\t\t\t<channel id=\"current_time\" typeId=\"currentTime\" />\n+\t\t\t<channel id=\"mode\" typeId=\"mode\" />\n+\t\t\t<channel id=\"manual_fan_speed\" typeId=\"manualFanSpeed\" />\n+\t\t\t<channel id=\"supply_fan_speed\" typeId=\"supplyFanSpeed\" />\n+\t\t\t<channel id=\"extract_fan_speed\" typeId=\"extractFanSpeed\" />\n+\t\t\t<channel id=\"supply_fan_step\" typeId=\"supplyFanStep\" />\n+\t\t\t<channel id=\"extract_fan_step\" typeId=\"extractFanStep\" />\n+\t\t\t<channel id=\"boost\" typeId=\"switch\">\n+\t\t\t\t<label>Boost</label>\n+\t\t\t\t<description>Enables fan boost</description>\n+\t\t\t</channel>\n+\t\t\t<channel id=\"night_cooling\" typeId=\"switch\">\n+\t\t\t\t<label>Night cooling</label>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "04f171986cfdf5462a02a68015ddca808913c996"}, "originalPosition": 62}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzcyMjgyNTY0", "url": "https://github.com/openhab/openhab-addons/pull/6814#pullrequestreview-372282564", "createdAt": "2020-03-10T20:06:37Z", "commit": {"oid": "7ae36564597a2284590a7bbc8bd8fe72bd8cd3a9"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMFQyMDowNjozOFrOF0fEyg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMFQyMToxNzo1OFrOF0hZFg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDU3OTQwMg==", "bodyText": "Putting constants into interfaces is no longer considered a good coding practice.\nI would suggest making this a class and then use static imports instead.", "url": "https://github.com/openhab/openhab-addons/pull/6814#discussion_r390579402", "createdAt": "2020-03-10T20:06:38Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/Commands.java", "diffHunk": "@@ -0,0 +1,66 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.danfossairunit.internal;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+\n+/**\n+ * The {@link Commands} interface holds the commands which can be send to the air unit to read/write values or trigger\n+ * actions.\n+ *\n+ * @author Robert Bach - Initial contribution\n+ */\n+\n+@NonNullByDefault\n+public interface Commands {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7ae36564597a2284590a7bbc8bd8fe72bd8cd3a9"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDU3OTcwOQ==", "bodyText": "See above", "url": "https://github.com/openhab/openhab-addons/pull/6814#discussion_r390579709", "createdAt": "2020-03-10T20:07:11Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/DanfossAirUnitBindingConstants.java", "diffHunk": "@@ -0,0 +1,49 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.danfossairunit.internal;\n+\n+import java.util.Collections;\n+import java.util.Set;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+\n+/**\n+ * The {@link DanfossAirUnitBindingConstants} class defines common constants, which are\n+ * used across the whole binding.\n+ *\n+ * @author Ralf Duckstein - Initial contribution\n+ * @author Robert Bach - heavy refactorings\n+ */\n+@NonNullByDefault\n+public interface DanfossAirUnitBindingConstants {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7ae36564597a2284590a7bbc8bd8fe72bd8cd3a9"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDU4MjQ1NQ==", "bodyText": "Since your temperature channels now have an item type of Number:Temperature. You should make sure to use QuantityType<Temperature> instead of DecimalType.", "url": "https://github.com/openhab/openhab-addons/pull/6814#discussion_r390582455", "createdAt": "2020-03-10T20:12:34Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/DanfossAirUnit.java", "diffHunk": "@@ -0,0 +1,280 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.danfossairunit.internal;\n+\n+import java.io.IOException;\n+import java.math.BigDecimal;\n+import java.math.RoundingMode;\n+import java.net.InetAddress;\n+import java.nio.charset.StandardCharsets;\n+import java.time.DateTimeException;\n+import java.time.ZoneId;\n+import java.time.ZonedDateTime;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.smarthome.core.library.types.DateTimeType;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link DanfossAirUnit} class represents the air unit device and build the commands to be sent by\n+ * {@link DanfossAirUnitCommunicationController}\n+ *\n+ * @author Ralf Duckstein - Initial contribution\n+ * @author Robert Bach - heavy refactorings\n+ */\n+\n+@SuppressWarnings(\"SameParameterValue\")\n+@NonNullByDefault\n+public class DanfossAirUnit implements Commands {\n+\n+    private final Logger logger = LoggerFactory.getLogger(DanfossAirUnit.class);\n+    private final DanfossAirUnitCommunicationController communicationController;\n+\n+    public DanfossAirUnit(InetAddress inetAddr, int port) {\n+        this.communicationController  = new DanfossAirUnitCommunicationController(inetAddr, port);\n+    }\n+\n+    public void cleanUp() {\n+        this.communicationController.disconnect();\n+    }\n+\n+    private boolean getBoolean(byte[] operation, byte[] register) throws IOException {\n+        return communicationController.sendRobustRequest(operation, register)[0] != 0;\n+    }\n+\n+    private void setSetting(byte[] register, boolean value) throws IOException {\n+        setSetting(register, value ? (byte) 1 : (byte) 0);\n+    }\n+\n+    private short getWord(byte[] operation, byte[] register) throws IOException {\n+        byte[] resultBytes = communicationController.sendRobustRequest(operation, register);\n+        return (short)((resultBytes[0] << 8)  | (resultBytes[1] & 0xFF));\n+    }\n+\n+    private byte getByte(byte[] operation, byte[] register) throws IOException {\n+        return communicationController.sendRobustRequest(operation, register)[0];\n+    }\n+\n+    private String getString(byte[] operation, byte[] register) throws IOException {\n+        // length of the string is stored in the first byte\n+        byte[] result = communicationController.sendRobustRequest(operation, register);\n+        return new String(result, 1, result[0], StandardCharsets.US_ASCII);\n+    }\n+\n+    private void set(byte[] operation, byte[] register, byte value) throws IOException {\n+        byte[] valueArray = { value };\n+        communicationController.sendRobustRequest(operation, register, valueArray);\n+    }\n+\n+    private void set(byte[] operation, byte[] register, short value) throws IOException {\n+        communicationController.sendRobustRequest(operation, register, shortToBytes(value));\n+    }\n+\n+    private byte[] shortToBytes(short s) {\n+        return new byte[]{(byte)((s & 0xFF00) >> 8),(byte)(s & 0x00FF)};\n+    }\n+\n+    private short getShort(byte[] operation, byte[] register) throws IOException {\n+        byte[] result = communicationController.sendRobustRequest(operation, register);\n+        return (short) ((result[0] << 8) + (result[1] & 0xff));\n+    }\n+\n+    private float getTemperature(byte[] operation, byte[] register) throws IOException, UnexpectedResponseValueException {\n+        short shortTemp = getShort(operation, register);\n+        float temp = ((float) shortTemp) / 100;\n+        if (temp <= -274 || temp > 100) {\n+            throw new UnexpectedResponseValueException(String.format(\"Invalid temperature: %s\", temp));\n+        }\n+        return temp;\n+    }\n+\n+    private ZonedDateTime getTimestamp(byte[] operation, byte[] register) throws IOException, UnexpectedResponseValueException {\n+        byte[] result = communicationController.sendRobustRequest(operation, register);\n+        return asZonedDateTime(result);\n+    }\n+\n+    private ZonedDateTime asZonedDateTime(byte[] data) throws UnexpectedResponseValueException {\n+        int second = data[0];\n+        int minute = data[1];\n+        int hour = data[2] & 0x1f;\n+        int day = data[3] & 0x1f;\n+        int month = data[4];\n+        int year = data[5] + 2000;\n+        try {\n+            return ZonedDateTime.of(year, month, day, hour, minute, second, 0, ZoneId.systemDefault());\n+        } catch (DateTimeException e) {\n+            String msg = String.format(\"Ignoring invalid timestamp %s.%s.%s %s:%s:%s\", day, month, year, hour, minute,\n+                    second);\n+            logger.debug(msg);\n+            throw new UnexpectedResponseValueException(msg);\n+        }\n+    }\n+\n+    private static int asUnsignedByte(byte b) {\n+        return b & 0xFF;\n+    }\n+\n+    private static float asPercentByte(byte b) {\n+        float f = asUnsignedByte(b);\n+        return f * 100 / 255;\n+    }\n+\n+    private void setSetting(byte[] register, short value) throws IOException {\n+        byte[] valueArray = new byte[2];\n+        valueArray[0] = (byte) (value >> 8);\n+        valueArray[1] = (byte) value;\n+\n+        communicationController.sendRobustRequest(REGISTER_1_WRITE, register, valueArray);\n+    }\n+\n+    public String getUnitName() throws IOException {\n+        return getString(REGISTER_1_READ, UNIT_NAME);\n+    }\n+\n+    public String getUnitSerialNumber() throws IOException {\n+        return String.valueOf(getShort(REGISTER_4_READ, UNIT_SERIAL));\n+    }\n+\n+    public StringType getMode() throws IOException {\n+        return new StringType(Mode.values()[getByte(REGISTER_1_READ, MODE)].name());\n+    }\n+\n+    public PercentType getManualFanSpeed() throws IOException {\n+        return new PercentType(BigDecimal.valueOf(getByte(REGISTER_1_READ, MANUAL_FAN_SPEED_STEP) * 10));\n+    }\n+\n+    public DecimalType getSupplyFanSpeed() throws IOException {\n+        return new DecimalType(BigDecimal.valueOf(getWord(REGISTER_4_READ, SUPPLY_FAN_SPEED)));\n+    }\n+\n+    public DecimalType getExtractFanSpeed() throws IOException {\n+        return new DecimalType(BigDecimal.valueOf(getWord(REGISTER_4_READ, EXTRACT_FAN_SPEED)));\n+    }\n+\n+    public PercentType getSupplyFanStep() throws IOException {\n+        return new PercentType(BigDecimal.valueOf(getByte(REGISTER_4_READ, SUPPLY_FAN_STEP)));\n+    }\n+\n+    public PercentType getExtractFanStep() throws IOException {\n+        return new PercentType(BigDecimal.valueOf(getByte(REGISTER_4_READ, EXTRACT_FAN_STEP)));\n+    }\n+\n+    public OnOffType getBoost() throws IOException {\n+        return getBoolean(REGISTER_1_READ, BOOST) ? OnOffType.ON : OnOffType.OFF;\n+    }\n+\n+    public OnOffType getNightCooling() throws IOException {\n+        return getBoolean(REGISTER_1_READ, NIGHT_COOLING) ? OnOffType.ON : OnOffType.OFF;\n+    }\n+\n+    public OnOffType getBypass() throws IOException {\n+        return getBoolean(REGISTER_1_READ, BYPASS) ? OnOffType.ON : OnOffType.OFF;\n+    }\n+\n+    public DecimalType getHumidity() throws IOException {\n+        BigDecimal value = BigDecimal.valueOf(asPercentByte(getByte(REGISTER_1_READ, HUMIDITY)));\n+        return new DecimalType(value.setScale(1, RoundingMode.HALF_UP));\n+    }\n+\n+    public DecimalType getRoomTemperature() throws IOException, UnexpectedResponseValueException {\n+        return getTemperatureAsDecimalType(REGISTER_1_READ, ROOM_TEMPERATURE);\n+    }\n+\n+    public DecimalType getRoomTemperatureCalculated() throws IOException, UnexpectedResponseValueException {\n+        return getTemperatureAsDecimalType(REGISTER_0_READ, ROOM_TEMPERATURE_CALCULATED);\n+    }\n+\n+    public DecimalType getOutdoorTemperature() throws IOException, UnexpectedResponseValueException {\n+        return getTemperatureAsDecimalType(REGISTER_1_READ, OUTDOOR_TEMPERATURE);\n+    }\n+\n+    public DecimalType getSupplyTemperature() throws IOException, UnexpectedResponseValueException {\n+        return getTemperatureAsDecimalType(REGISTER_4_READ, SUPPLY_TEMPERATURE);\n+    }\n+\n+    public DecimalType getExtractTemperature() throws IOException, UnexpectedResponseValueException {\n+        return getTemperatureAsDecimalType(REGISTER_4_READ, EXTRACT_TEMPERATURE);\n+    }\n+\n+    public DecimalType getExhaustTemperature() throws IOException, UnexpectedResponseValueException {\n+        return getTemperatureAsDecimalType(REGISTER_4_READ, EXHAUST_TEMPERATURE);\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7ae36564597a2284590a7bbc8bd8fe72bd8cd3a9"}, "originalPosition": 217}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDU4NzQwOA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                \"Unknown host: \" + config.host);\n          \n          \n            \n                    }\n          \n          \n            \n                                \"Unknown host: \" + config.host);\n          \n          \n            \n                        return;\n          \n          \n            \n                    }", "url": "https://github.com/openhab/openhab-addons/pull/6814#discussion_r390587408", "createdAt": "2020-03-10T20:21:51Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/DanfossAirUnitHandler.java", "diffHunk": "@@ -0,0 +1,164 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.danfossairunit.internal;\n+\n+import static org.openhab.binding.danfossairunit.internal.DanfossAirUnitBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.net.UnknownHostException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link DanfossAirUnitHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Ralf Duckstein - Initial contribution\n+ * @author Robert Bach - heavy refactorings\n+ */\n+@NonNullByDefault\n+public class DanfossAirUnitHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(DanfossAirUnitHandler.class);\n+\n+    private @Nullable DanfossAirUnitConfiguration config;\n+\n+    public DanfossAirUnitHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    private @Nullable ValueCache valueCache;\n+\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+    private @Nullable DanfossAirUnit hrv;\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            updateAllChannels();\n+        } else {\n+            try {\n+                DanfossAirUnit danfossAirUnit = hrv;\n+                Channel channel = Channel.getByName(channelUID.getIdWithoutGroup());\n+                if (channel.getWriteAccessor() != null) {\n+                    updateState(channelUID, channel.getWriteAccessor().access(danfossAirUnit, command));\n+                }\n+            } catch (IllegalArgumentException e) {\n+                logger.info(\"{}\", e.getMessage());\n+            } catch (IOException ioe) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR, ioe.getMessage());\n+            } catch (Exception e) {\n+                logger.info(\"Error updating channel {}: {}\", channelUID, e.getMessage());\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        updateStatus(ThingStatus.UNKNOWN);\n+        config = getConfigAs(DanfossAirUnitConfiguration.class);\n+        valueCache = new ValueCache(config.updateUnchangedValuesEveryMillis);\n+        try {\n+            hrv = new DanfossAirUnit(InetAddress.getByName(config.host), 30046);\n+        } catch (UnknownHostException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                    \"Unknown host: \" + config.host);\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7ae36564597a2284590a7bbc8bd8fe72bd8cd3a9"}, "originalPosition": 91}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDU4ODU5Mg==", "bodyText": "Shouldn't this be considered a configuration error instead of a communication error?", "url": "https://github.com/openhab/openhab-addons/pull/6814#discussion_r390588592", "createdAt": "2020-03-10T20:24:02Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/DanfossAirUnitHandler.java", "diffHunk": "@@ -0,0 +1,164 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.danfossairunit.internal;\n+\n+import static org.openhab.binding.danfossairunit.internal.DanfossAirUnitBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.net.UnknownHostException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link DanfossAirUnitHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Ralf Duckstein - Initial contribution\n+ * @author Robert Bach - heavy refactorings\n+ */\n+@NonNullByDefault\n+public class DanfossAirUnitHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(DanfossAirUnitHandler.class);\n+\n+    private @Nullable DanfossAirUnitConfiguration config;\n+\n+    public DanfossAirUnitHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    private @Nullable ValueCache valueCache;\n+\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+    private @Nullable DanfossAirUnit hrv;\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            updateAllChannels();\n+        } else {\n+            try {\n+                DanfossAirUnit danfossAirUnit = hrv;\n+                Channel channel = Channel.getByName(channelUID.getIdWithoutGroup());\n+                if (channel.getWriteAccessor() != null) {\n+                    updateState(channelUID, channel.getWriteAccessor().access(danfossAirUnit, command));\n+                }\n+            } catch (IllegalArgumentException e) {\n+                logger.info(\"{}\", e.getMessage());\n+            } catch (IOException ioe) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR, ioe.getMessage());\n+            } catch (Exception e) {\n+                logger.info(\"Error updating channel {}: {}\", channelUID, e.getMessage());\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        updateStatus(ThingStatus.UNKNOWN);\n+        config = getConfigAs(DanfossAirUnitConfiguration.class);\n+        valueCache = new ValueCache(config.updateUnchangedValuesEveryMillis);\n+        try {\n+            hrv = new DanfossAirUnit(InetAddress.getByName(config.host), 30046);\n+        } catch (UnknownHostException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7ae36564597a2284590a7bbc8bd8fe72bd8cd3a9"}, "originalPosition": 89}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDU5MTQ2MQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    logger.debug(\"Disover message sent\");\n          \n          \n            \n                    logger.debug(\"Discover message sent\");", "url": "https://github.com/openhab/openhab-addons/pull/6814#discussion_r390591461", "createdAt": "2020-03-10T20:29:06Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/discovery/DanfossAirUnitDiscoveryService.java", "diffHunk": "@@ -0,0 +1,140 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.danfossairunit.internal.discovery;\n+\n+import static org.openhab.binding.danfossairunit.internal.DanfossAirUnitBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.InetAddress;\n+import java.net.InterfaceAddress;\n+import java.net.NetworkInterface;\n+import java.net.SocketTimeoutException;\n+import java.util.*;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.smarthome.config.discovery.AbstractDiscoveryService;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResult;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResultBuilder;\n+import org.eclipse.smarthome.config.discovery.DiscoveryService;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.thing.ThingUID;\n+import org.osgi.service.component.annotations.Component;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The Discovery service implementation to scan for available air units in the network via broadcast.\n+ *\n+ * @author Ralf Duckstein - Initial contribution\n+ * @author Robert Bach - heavy refactorings\n+ */\n+@Component(service = DiscoveryService.class, immediate = true)\n+@NonNullByDefault\n+public class DanfossAirUnitDiscoveryService extends AbstractDiscoveryService {\n+\n+    private static final int BROADCAST_PORT = 30045;\n+    private static final byte[] DISCOVER_SEND = { 0x0c, 0x00, 0x30, 0x00, 0x11, 0x00, 0x12, 0x00, 0x13 };\n+    private static final byte[] DISCOVER_RECEIVE = { 0x0d, 0x00, 0x07, 0x00, 0x02, 0x02, 0x00 };\n+\n+    private Logger logger = LoggerFactory.getLogger(DanfossAirUnitDiscoveryService.class);\n+\n+    public DanfossAirUnitDiscoveryService() {\n+        super(SUPPORTED_THING_TYPES_UIDS, 15, true);\n+    }\n+\n+    @Override\n+    public Set<ThingTypeUID> getSupportedThingTypes() {\n+        return SUPPORTED_THING_TYPES_UIDS;\n+    }\n+\n+    @Override\n+    protected void startBackgroundDiscovery() {\n+        logger.debug(\"Start Danfoss Air CCM background discovery\");\n+        scheduler.execute(this::discover);\n+    }\n+\n+    @Override\n+    public void startScan() {\n+        logger.debug(\"Start Danfoss Air CCM scan\");\n+        discover();\n+    }\n+\n+    private synchronized void discover() {\n+        logger.debug(\"Try to discover all Danfoss Air CCM devices\");\n+\n+        try (DatagramSocket socket = new DatagramSocket()) {\n+\n+            Enumeration<NetworkInterface> interfaces = NetworkInterface.getNetworkInterfaces();\n+            while (interfaces.hasMoreElements()) {\n+                NetworkInterface networkInterface = interfaces.nextElement();\n+                if (networkInterface == null || networkInterface.isLoopback() || !networkInterface.isUp()) {\n+                    continue;\n+                }\n+                for (InterfaceAddress interfaceAddress : networkInterface.getInterfaceAddresses()) {\n+                    if (interfaceAddress == null || interfaceAddress.getBroadcast() == null) {\n+                        continue;\n+                    }\n+                    logger.debug(\"Sending broadcast on interface {} to discover Danfoss Air CCM device...\",\n+                            interfaceAddress.getAddress().toString());\n+                    sendBroadcastToDiscoverThing(socket, interfaceAddress.getBroadcast());\n+                }\n+            }\n+\n+        } catch (IOException e) {\n+            logger.debug(\"No Danfoss Air CCM device found. Diagnostic: {}\", e.getMessage());\n+        }\n+    }\n+\n+    private void sendBroadcastToDiscoverThing(DatagramSocket socket, InetAddress broadcastAddress) throws IOException {\n+        socket.setBroadcast(true);\n+        socket.setSoTimeout(5000);\n+        // send discover\n+        byte[] sendBuffer = DISCOVER_SEND;\n+        DatagramPacket sendPacket = new DatagramPacket(sendBuffer, sendBuffer.length, broadcastAddress, BROADCAST_PORT);\n+        socket.send(sendPacket);\n+        logger.debug(\"Disover message sent\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7ae36564597a2284590a7bbc8bd8fe72bd8cd3a9"}, "originalPosition": 108}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDYwMDQ4MQ==", "bodyText": "Assuming that you are doing broadcast discovery on a local area network. I don't see why you would expect any response to take up to 5 seconds. Wouldn't 500 milliseconds be more than sufficient?", "url": "https://github.com/openhab/openhab-addons/pull/6814#discussion_r390600481", "createdAt": "2020-03-10T20:46:37Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/discovery/DanfossAirUnitDiscoveryService.java", "diffHunk": "@@ -0,0 +1,140 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.danfossairunit.internal.discovery;\n+\n+import static org.openhab.binding.danfossairunit.internal.DanfossAirUnitBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.InetAddress;\n+import java.net.InterfaceAddress;\n+import java.net.NetworkInterface;\n+import java.net.SocketTimeoutException;\n+import java.util.*;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.smarthome.config.discovery.AbstractDiscoveryService;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResult;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResultBuilder;\n+import org.eclipse.smarthome.config.discovery.DiscoveryService;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.thing.ThingUID;\n+import org.osgi.service.component.annotations.Component;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The Discovery service implementation to scan for available air units in the network via broadcast.\n+ *\n+ * @author Ralf Duckstein - Initial contribution\n+ * @author Robert Bach - heavy refactorings\n+ */\n+@Component(service = DiscoveryService.class, immediate = true)\n+@NonNullByDefault\n+public class DanfossAirUnitDiscoveryService extends AbstractDiscoveryService {\n+\n+    private static final int BROADCAST_PORT = 30045;\n+    private static final byte[] DISCOVER_SEND = { 0x0c, 0x00, 0x30, 0x00, 0x11, 0x00, 0x12, 0x00, 0x13 };\n+    private static final byte[] DISCOVER_RECEIVE = { 0x0d, 0x00, 0x07, 0x00, 0x02, 0x02, 0x00 };\n+\n+    private Logger logger = LoggerFactory.getLogger(DanfossAirUnitDiscoveryService.class);\n+\n+    public DanfossAirUnitDiscoveryService() {\n+        super(SUPPORTED_THING_TYPES_UIDS, 15, true);\n+    }\n+\n+    @Override\n+    public Set<ThingTypeUID> getSupportedThingTypes() {\n+        return SUPPORTED_THING_TYPES_UIDS;\n+    }\n+\n+    @Override\n+    protected void startBackgroundDiscovery() {\n+        logger.debug(\"Start Danfoss Air CCM background discovery\");\n+        scheduler.execute(this::discover);\n+    }\n+\n+    @Override\n+    public void startScan() {\n+        logger.debug(\"Start Danfoss Air CCM scan\");\n+        discover();\n+    }\n+\n+    private synchronized void discover() {\n+        logger.debug(\"Try to discover all Danfoss Air CCM devices\");\n+\n+        try (DatagramSocket socket = new DatagramSocket()) {\n+\n+            Enumeration<NetworkInterface> interfaces = NetworkInterface.getNetworkInterfaces();\n+            while (interfaces.hasMoreElements()) {\n+                NetworkInterface networkInterface = interfaces.nextElement();\n+                if (networkInterface == null || networkInterface.isLoopback() || !networkInterface.isUp()) {\n+                    continue;\n+                }\n+                for (InterfaceAddress interfaceAddress : networkInterface.getInterfaceAddresses()) {\n+                    if (interfaceAddress == null || interfaceAddress.getBroadcast() == null) {\n+                        continue;\n+                    }\n+                    logger.debug(\"Sending broadcast on interface {} to discover Danfoss Air CCM device...\",\n+                            interfaceAddress.getAddress().toString());\n+                    sendBroadcastToDiscoverThing(socket, interfaceAddress.getBroadcast());\n+                }\n+            }\n+\n+        } catch (IOException e) {\n+            logger.debug(\"No Danfoss Air CCM device found. Diagnostic: {}\", e.getMessage());\n+        }\n+    }\n+\n+    private void sendBroadcastToDiscoverThing(DatagramSocket socket, InetAddress broadcastAddress) throws IOException {\n+        socket.setBroadcast(true);\n+        socket.setSoTimeout(5000);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7ae36564597a2284590a7bbc8bd8fe72bd8cd3a9"}, "originalPosition": 103}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDYxNzM2Ng==", "bodyText": "I think you might have missed this suggestion from my first review so I'll copy it here:\nRather than implementing your own cache. I would recommend using the one that already comes with the OH core.\nYou can find details here\nThe class I think would be most relevant to you would be org.eclipse.smarthome.core.cache.ExpiringCacheMap.", "url": "https://github.com/openhab/openhab-addons/pull/6814#discussion_r390617366", "createdAt": "2020-03-10T21:17:58Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/ValueCache.java", "diffHunk": "@@ -0,0 +1,70 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.danfossairunit.internal;\n+\n+import java.util.Calendar;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.smarthome.core.types.State;\n+\n+/**\n+ * The {@link ValueCache} is responsible for holding the last value of the channels for a\n+ * certain amount of time {@link ValueCache#durationMs} to prevent unnecessary event bus updates if the value didn't\n+ * change.\n+ *\n+ * @author Robert Bach - Initial contribution\n+ */\n+@NonNullByDefault\n+public class ValueCache {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTkyMjgwMA=="}, "originalCommit": {"oid": "ad93709e77a6687e32c3a9cdab3d8e74b61979c4"}, "originalPosition": 30}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzczMDM3Njg4", "url": "https://github.com/openhab/openhab-addons/pull/6814#pullrequestreview-373037688", "createdAt": "2020-03-11T18:53:30Z", "commit": {"oid": "ff2dffe42f55b3fdc86b49916230b10cd2472fd2"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc4MTE1NjM4", "url": "https://github.com/openhab/openhab-addons/pull/6814#pullrequestreview-378115638", "createdAt": "2020-03-19T21:44:22Z", "commit": {"oid": "ff2dffe42f55b3fdc86b49916230b10cd2472fd2"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOVQyMTo0NDoyMlrOF5BdPQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOVQyMTo0NDoyMlrOF5BdPQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTMzNzAyMQ==", "bodyText": "A new release just went out so we need to change this again.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                <version>2.5.3-SNAPSHOT</version>\n          \n          \n            \n                <version>2.5.4-SNAPSHOT</version>", "url": "https://github.com/openhab/openhab-addons/pull/6814#discussion_r395337021", "createdAt": "2020-03-19T21:44:22Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.danfossairunit/pom.xml", "diffHunk": "@@ -0,0 +1,17 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<project xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns=\"http://maven.apache.org/POM/4.0.0\"\n+  xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n+\n+  <modelVersion>4.0.0</modelVersion>\n+\n+  <parent>\n+    <groupId>org.openhab.addons.bundles</groupId>\n+    <artifactId>org.openhab.addons.reactor.bundles</artifactId>\n+    <version>2.5.3-SNAPSHOT</version>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ff2dffe42f55b3fdc86b49916230b10cd2472fd2"}, "originalPosition": 10}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkxNzc2ODYz", "url": "https://github.com/openhab/openhab-addons/pull/6814#pullrequestreview-391776863", "createdAt": "2020-04-11T15:42:57Z", "commit": {"oid": "846ac84dd0b9064408bce34d6eb0ef80467c7b6c"}, "state": "COMMENTED", "comments": {"totalCount": 23, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xMVQxNTo0Mjo1N1rOGEOFYQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOVQxMzoxNTozNVrOGS7B2A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzA3ODI0MQ==", "bodyText": "The full example should also include an example for people not using autodiscovery, so the thing definition", "url": "https://github.com/openhab/openhab-addons/pull/6814#discussion_r407078241", "createdAt": "2020-04-11T15:42:57Z", "author": {"login": "martinvw"}, "path": "bundles/org.openhab.binding.danfossairunit/README.md", "diffHunk": "@@ -0,0 +1,74 @@\n+# DanfossAirUnit Binding\n+\n+This binding supports controlling and monitoring [Danfoss air units](https://www.danfoss.com/en/products/energy-recovery-devices/dhs/heat-recovery-ventilation/air-units/) via Ethernet connection.\n+It emerged from [this forum discussion](https://community.openhab.org/t/danfoss-air-unit-ethernet-connection/17844), where you can find further details. \n+ \n+## Supported Things\n+\n+This binding has been tested/reported to work with the Danfoss Air w2 / a2 / a3 devices. \n+\n+## Discovery\n+\n+Air units in the LAN are automatically discovered via broadcast and added to the Inbox. \n+\n+## Thing Configuration\n+\n+These are the available configuration parameters:\n+\n+- ```host``` Hostname/IP of the air unit (automatically set by discovery service)\n+- ```refreshInterval``` Time (in seconds) between monitoring requests to the air unit. Smaller values mean more network load, typically set between a few seconds and a minute. Defaults to 10 seconds. \n+- ```updateUnchangedValuesEveryMillis``` Minimum time between state updates sent to the event bus for a particular channel when the state of the channel didn't change. This should avoid spamming the event bus with unnecessary updates. When set to 0, all channel state are updated every time the air unit requests are sent (see refresh interval). When set to a non zero value, unchanged values are only reported after the configured timespan has passed. Changed values are always sent to the event bus. Defaults to 60.000 (one minute), so updates are sent every minute or if the state of the channel changes.                  \n+\n+## Channels\n+\n+| channel | channel group | type   | readable only (RO) or writable (RW) | description                  |\n+|---|---|---|---|---|\n+| current_time | main | DateTime | RO | Current time reported by the air unit.  |\n+| mode | main | String | RW | Value to control the operation mode of the air unit. One of DEMAND, PROGRAM, MANUAL and OFF  |\n+| manual_fan_speed | main | Dimmer | RW | Value to control the fan speed when in MANUAL mode (10 steps) |\n+| supply_fan_speed | main | Number | RO | Current rotation of the fan supplying air to the rooms (in rpm) |\n+| extract_fan_speed | main | Number | RO | Current rotation of the fan extracting air from the rooms (in rpm) |\n+| supply_fan_step | main | Dimmer | RO | Current 10-step setting of the fan supplying air to the rooms |\n+| extract_fan_step | main | Dimmer | RO | Current 10-step setting of the fan extracting air from the rooms |\n+| boost | main | Switch | RW | Enables fan boost  |\n+| night_cooling | main | Switch | RW | Enables night cooling  |\n+| room_temp | temps | Number | RO | Temperature of the air in the room of the Air Dial  |\n+| room_temp_calculated | temps | Number | RO | Calculated Room Temperature  |\n+| outdoor_temp | temps | Number | RO | Temperature of the air outside  |\n+| humidity | humidity | Number | RO | Humidity  |\n+| bypass | recuperator | Switch | RW | Disables the heat exchange. Useful in summer when room temperature is above target and outside temperature is below target.  |\n+| supply_temp | recuperator | Number | RO | Temperature of air which is passed to the rooms  |\n+| extract_temp | recuperator | Number | RO | Temperature of the air as extracted from the rooms  |\n+| exhaust_temp | recuperator | Number | RO | Temperature of the air when pushed outside  |\n+| battery_life | service | Number | RO | Remaining Air Dial Battery Level (percentage) |\n+| filter_life | service | Number | RO | Remaining life of filter until exchange is necessary (percentage) |\n+\n+\n+## Full Example\n+\n+### Things\n+\n+Suppose your autodiscovered air unit is identified by the id \"danfossairunit:airunit:-1062731769\".", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "846ac84dd0b9064408bce34d6eb0ef80467c7b6c"}, "originalPosition": 51}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQ5MDczMg==", "bodyText": "I'm personally in doubt about the long term value of this link.\n@openhab/add-ons-maintainers wdyt?", "url": "https://github.com/openhab/openhab-addons/pull/6814#discussion_r422490732", "createdAt": "2020-05-09T12:36:32Z", "author": {"login": "martinvw"}, "path": "bundles/org.openhab.binding.danfossairunit/README.md", "diffHunk": "@@ -0,0 +1,74 @@\n+# DanfossAirUnit Binding\n+\n+This binding supports controlling and monitoring [Danfoss air units](https://www.danfoss.com/en/products/energy-recovery-devices/dhs/heat-recovery-ventilation/air-units/) via Ethernet connection.\n+It emerged from [this forum discussion](https://community.openhab.org/t/danfoss-air-unit-ethernet-connection/17844), where you can find further details. ", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "846ac84dd0b9064408bce34d6eb0ef80467c7b6c"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQ5MTk0MQ==", "bodyText": "For a single line code block you should use the single ` / backticks", "url": "https://github.com/openhab/openhab-addons/pull/6814#discussion_r422491941", "createdAt": "2020-05-09T12:48:55Z", "author": {"login": "martinvw"}, "path": "bundles/org.openhab.binding.danfossairunit/README.md", "diffHunk": "@@ -0,0 +1,74 @@\n+# DanfossAirUnit Binding\n+\n+This binding supports controlling and monitoring [Danfoss air units](https://www.danfoss.com/en/products/energy-recovery-devices/dhs/heat-recovery-ventilation/air-units/) via Ethernet connection.\n+It emerged from [this forum discussion](https://community.openhab.org/t/danfoss-air-unit-ethernet-connection/17844), where you can find further details. \n+ \n+## Supported Things\n+\n+This binding has been tested/reported to work with the Danfoss Air w2 / a2 / a3 devices. \n+\n+## Discovery\n+\n+Air units in the LAN are automatically discovered via broadcast and added to the Inbox. \n+\n+## Thing Configuration\n+\n+These are the available configuration parameters:\n+\n+- ```host``` Hostname/IP of the air unit (automatically set by discovery service)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "846ac84dd0b9064408bce34d6eb0ef80467c7b6c"}, "originalPosition": 18}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQ5MjQ0Mg==", "bodyText": "Could be null is there btw a reason you are not using the nullable annotations? For such classes its almost trivial to implement, see also: https://www.openhab.org/docs/developer/guidelines.html#null-annotations", "url": "https://github.com/openhab/openhab-addons/pull/6814#discussion_r422492442", "createdAt": "2020-05-09T12:54:05Z", "author": {"login": "martinvw"}, "path": "bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/ChannelGroup.java", "diffHunk": "@@ -0,0 +1,36 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.danfossairunit.internal;\n+\n+/**\n+ * Represents a channel group, channels are divided into.\n+ *\n+ * @author Robert Bach - Initial contribution\n+ */\n+public enum ChannelGroup {\n+    MAIN(\"main\"),\n+    TEMPS(\"temps\"),\n+    HUMIDITY(\"humidity\"),\n+    RECUPERATOR(\"recuperator\"),\n+    SERVICE(\"service\");\n+\n+    private String groupName;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "846ac84dd0b9064408bce34d6eb0ef80467c7b6c"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQ5MjU0Mg==", "bodyText": "Please remove this empty line", "url": "https://github.com/openhab/openhab-addons/pull/6814#discussion_r422492542", "createdAt": "2020-05-09T12:55:04Z", "author": {"login": "martinvw"}, "path": "bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/DanfossAirUnit.java", "diffHunk": "@@ -0,0 +1,287 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.danfossairunit.internal;\n+\n+import java.io.IOException;\n+import java.math.BigDecimal;\n+import java.math.RoundingMode;\n+import java.net.InetAddress;\n+import java.nio.charset.StandardCharsets;\n+import java.time.DateTimeException;\n+import java.time.ZoneId;\n+import java.time.ZonedDateTime;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.smarthome.core.library.types.DateTimeType;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.library.unit.SIUnits;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import javax.measure.Unit;\n+import javax.measure.quantity.Temperature;\n+\n+import static org.openhab.binding.danfossairunit.internal.Commands.*;\n+\n+/**\n+ * The {@link DanfossAirUnit} class represents the air unit device and build the commands to be sent by\n+ * {@link DanfossAirUnitCommunicationController}\n+ *\n+ * @author Ralf Duckstein - Initial contribution\n+ * @author Robert Bach - heavy refactorings\n+ */\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "846ac84dd0b9064408bce34d6eb0ef80467c7b6c"}, "originalPosition": 48}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQ5Mjc0OQ==", "bodyText": "It's considered bad practice to both log and (re)throw an exception", "url": "https://github.com/openhab/openhab-addons/pull/6814#discussion_r422492749", "createdAt": "2020-05-09T12:56:52Z", "author": {"login": "martinvw"}, "path": "bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/DanfossAirUnit.java", "diffHunk": "@@ -0,0 +1,287 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.danfossairunit.internal;\n+\n+import java.io.IOException;\n+import java.math.BigDecimal;\n+import java.math.RoundingMode;\n+import java.net.InetAddress;\n+import java.nio.charset.StandardCharsets;\n+import java.time.DateTimeException;\n+import java.time.ZoneId;\n+import java.time.ZonedDateTime;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.smarthome.core.library.types.DateTimeType;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.library.unit.SIUnits;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import javax.measure.Unit;\n+import javax.measure.quantity.Temperature;\n+\n+import static org.openhab.binding.danfossairunit.internal.Commands.*;\n+\n+/**\n+ * The {@link DanfossAirUnit} class represents the air unit device and build the commands to be sent by\n+ * {@link DanfossAirUnitCommunicationController}\n+ *\n+ * @author Ralf Duckstein - Initial contribution\n+ * @author Robert Bach - heavy refactorings\n+ */\n+\n+@SuppressWarnings(\"SameParameterValue\")\n+@NonNullByDefault\n+public class DanfossAirUnit {\n+\n+    private final Logger logger = LoggerFactory.getLogger(DanfossAirUnit.class);\n+    private final DanfossAirUnitCommunicationController communicationController;\n+\n+    public DanfossAirUnit(InetAddress inetAddr, int port) {\n+        this.communicationController  = new DanfossAirUnitCommunicationController(inetAddr, port);\n+    }\n+\n+    public void cleanUp() {\n+        this.communicationController.disconnect();\n+    }\n+\n+    private boolean getBoolean(byte[] operation, byte[] register) throws IOException {\n+        return communicationController.sendRobustRequest(operation, register)[0] != 0;\n+    }\n+\n+    private void setSetting(byte[] register, boolean value) throws IOException {\n+        setSetting(register, value ? (byte) 1 : (byte) 0);\n+    }\n+\n+    private short getWord(byte[] operation, byte[] register) throws IOException {\n+        byte[] resultBytes = communicationController.sendRobustRequest(operation, register);\n+        return (short)((resultBytes[0] << 8)  | (resultBytes[1] & 0xFF));\n+    }\n+\n+    private byte getByte(byte[] operation, byte[] register) throws IOException {\n+        return communicationController.sendRobustRequest(operation, register)[0];\n+    }\n+\n+    private String getString(byte[] operation, byte[] register) throws IOException {\n+        // length of the string is stored in the first byte\n+        byte[] result = communicationController.sendRobustRequest(operation, register);\n+        return new String(result, 1, result[0], StandardCharsets.US_ASCII);\n+    }\n+\n+    private void set(byte[] operation, byte[] register, byte value) throws IOException {\n+        byte[] valueArray = { value };\n+        communicationController.sendRobustRequest(operation, register, valueArray);\n+    }\n+\n+    private void set(byte[] operation, byte[] register, short value) throws IOException {\n+        communicationController.sendRobustRequest(operation, register, shortToBytes(value));\n+    }\n+\n+    private byte[] shortToBytes(short s) {\n+        return new byte[]{(byte)((s & 0xFF00) >> 8),(byte)(s & 0x00FF)};\n+    }\n+\n+    private short getShort(byte[] operation, byte[] register) throws IOException {\n+        byte[] result = communicationController.sendRobustRequest(operation, register);\n+        return (short) ((result[0] << 8) + (result[1] & 0xff));\n+    }\n+\n+    private float getTemperature(byte[] operation, byte[] register) throws IOException, UnexpectedResponseValueException {\n+        short shortTemp = getShort(operation, register);\n+        float temp = ((float) shortTemp) / 100;\n+        if (temp <= -274 || temp > 100) {\n+            throw new UnexpectedResponseValueException(String.format(\"Invalid temperature: %s\", temp));\n+        }\n+        return temp;\n+    }\n+\n+    private ZonedDateTime getTimestamp(byte[] operation, byte[] register) throws IOException, UnexpectedResponseValueException {\n+        byte[] result = communicationController.sendRobustRequest(operation, register);\n+        return asZonedDateTime(result);\n+    }\n+\n+    private ZonedDateTime asZonedDateTime(byte[] data) throws UnexpectedResponseValueException {\n+        int second = data[0];\n+        int minute = data[1];\n+        int hour = data[2] & 0x1f;\n+        int day = data[3] & 0x1f;\n+        int month = data[4];\n+        int year = data[5] + 2000;\n+        try {\n+            return ZonedDateTime.of(year, month, day, hour, minute, second, 0, ZoneId.systemDefault());\n+        } catch (DateTimeException e) {\n+            String msg = String.format(\"Ignoring invalid timestamp %s.%s.%s %s:%s:%s\", day, month, year, hour, minute,\n+                    second);\n+            logger.debug(msg);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "846ac84dd0b9064408bce34d6eb0ef80467c7b6c"}, "originalPosition": 131}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQ5Mjc5Ng==", "bodyText": "Consider passing the cause of the exception, now you are effectively ignoring the caught exception.", "url": "https://github.com/openhab/openhab-addons/pull/6814#discussion_r422492796", "createdAt": "2020-05-09T12:57:35Z", "author": {"login": "martinvw"}, "path": "bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/DanfossAirUnit.java", "diffHunk": "@@ -0,0 +1,287 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.danfossairunit.internal;\n+\n+import java.io.IOException;\n+import java.math.BigDecimal;\n+import java.math.RoundingMode;\n+import java.net.InetAddress;\n+import java.nio.charset.StandardCharsets;\n+import java.time.DateTimeException;\n+import java.time.ZoneId;\n+import java.time.ZonedDateTime;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.smarthome.core.library.types.DateTimeType;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.library.unit.SIUnits;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import javax.measure.Unit;\n+import javax.measure.quantity.Temperature;\n+\n+import static org.openhab.binding.danfossairunit.internal.Commands.*;\n+\n+/**\n+ * The {@link DanfossAirUnit} class represents the air unit device and build the commands to be sent by\n+ * {@link DanfossAirUnitCommunicationController}\n+ *\n+ * @author Ralf Duckstein - Initial contribution\n+ * @author Robert Bach - heavy refactorings\n+ */\n+\n+@SuppressWarnings(\"SameParameterValue\")\n+@NonNullByDefault\n+public class DanfossAirUnit {\n+\n+    private final Logger logger = LoggerFactory.getLogger(DanfossAirUnit.class);\n+    private final DanfossAirUnitCommunicationController communicationController;\n+\n+    public DanfossAirUnit(InetAddress inetAddr, int port) {\n+        this.communicationController  = new DanfossAirUnitCommunicationController(inetAddr, port);\n+    }\n+\n+    public void cleanUp() {\n+        this.communicationController.disconnect();\n+    }\n+\n+    private boolean getBoolean(byte[] operation, byte[] register) throws IOException {\n+        return communicationController.sendRobustRequest(operation, register)[0] != 0;\n+    }\n+\n+    private void setSetting(byte[] register, boolean value) throws IOException {\n+        setSetting(register, value ? (byte) 1 : (byte) 0);\n+    }\n+\n+    private short getWord(byte[] operation, byte[] register) throws IOException {\n+        byte[] resultBytes = communicationController.sendRobustRequest(operation, register);\n+        return (short)((resultBytes[0] << 8)  | (resultBytes[1] & 0xFF));\n+    }\n+\n+    private byte getByte(byte[] operation, byte[] register) throws IOException {\n+        return communicationController.sendRobustRequest(operation, register)[0];\n+    }\n+\n+    private String getString(byte[] operation, byte[] register) throws IOException {\n+        // length of the string is stored in the first byte\n+        byte[] result = communicationController.sendRobustRequest(operation, register);\n+        return new String(result, 1, result[0], StandardCharsets.US_ASCII);\n+    }\n+\n+    private void set(byte[] operation, byte[] register, byte value) throws IOException {\n+        byte[] valueArray = { value };\n+        communicationController.sendRobustRequest(operation, register, valueArray);\n+    }\n+\n+    private void set(byte[] operation, byte[] register, short value) throws IOException {\n+        communicationController.sendRobustRequest(operation, register, shortToBytes(value));\n+    }\n+\n+    private byte[] shortToBytes(short s) {\n+        return new byte[]{(byte)((s & 0xFF00) >> 8),(byte)(s & 0x00FF)};\n+    }\n+\n+    private short getShort(byte[] operation, byte[] register) throws IOException {\n+        byte[] result = communicationController.sendRobustRequest(operation, register);\n+        return (short) ((result[0] << 8) + (result[1] & 0xff));\n+    }\n+\n+    private float getTemperature(byte[] operation, byte[] register) throws IOException, UnexpectedResponseValueException {\n+        short shortTemp = getShort(operation, register);\n+        float temp = ((float) shortTemp) / 100;\n+        if (temp <= -274 || temp > 100) {\n+            throw new UnexpectedResponseValueException(String.format(\"Invalid temperature: %s\", temp));\n+        }\n+        return temp;\n+    }\n+\n+    private ZonedDateTime getTimestamp(byte[] operation, byte[] register) throws IOException, UnexpectedResponseValueException {\n+        byte[] result = communicationController.sendRobustRequest(operation, register);\n+        return asZonedDateTime(result);\n+    }\n+\n+    private ZonedDateTime asZonedDateTime(byte[] data) throws UnexpectedResponseValueException {\n+        int second = data[0];\n+        int minute = data[1];\n+        int hour = data[2] & 0x1f;\n+        int day = data[3] & 0x1f;\n+        int month = data[4];\n+        int year = data[5] + 2000;\n+        try {\n+            return ZonedDateTime.of(year, month, day, hour, minute, second, 0, ZoneId.systemDefault());\n+        } catch (DateTimeException e) {\n+            String msg = String.format(\"Ignoring invalid timestamp %s.%s.%s %s:%s:%s\", day, month, year, hour, minute,\n+                    second);\n+            logger.debug(msg);\n+            throw new UnexpectedResponseValueException(msg);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "846ac84dd0b9064408bce34d6eb0ef80467c7b6c"}, "originalPosition": 132}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQ5Mjk2Mw==", "bodyText": "I don't think this has to be logged on info level?", "url": "https://github.com/openhab/openhab-addons/pull/6814#discussion_r422492963", "createdAt": "2020-05-09T12:58:52Z", "author": {"login": "martinvw"}, "path": "bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/DanfossAirUnitCommunicationController.java", "diffHunk": "@@ -0,0 +1,111 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.danfossairunit.internal;\n+\n+import static org.openhab.binding.danfossairunit.internal.Commands.EMPTY;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.net.InetAddress;\n+import java.net.Socket;\n+import java.util.Objects;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link DanfossAirUnitCommunicationController} class does the actual network communication with the air unit.\n+ *\n+ * @author Robert Bach - initial contribution\n+ */\n+\n+@NonNullByDefault\n+public class DanfossAirUnitCommunicationController {\n+\n+    private final Logger logger = LoggerFactory.getLogger(DanfossAirUnitCommunicationController.class);\n+\n+    private final InetAddress inetAddr;\n+    private final int port;\n+    private boolean connected = false;\n+    private @Nullable Socket socket;\n+    private @Nullable OutputStream oStream;\n+    private @Nullable InputStream iStream;\n+\n+    public DanfossAirUnitCommunicationController(InetAddress inetAddr, int port) {\n+        this.inetAddr = inetAddr;\n+        this.port = port;\n+    }\n+\n+    public synchronized void connect() throws IOException {\n+        if(connected) {\n+            return;\n+        }\n+        socket = new Socket(inetAddr, port);\n+        oStream = socket.getOutputStream();\n+        iStream = socket.getInputStream();\n+        connected = true;\n+    }\n+\n+    public synchronized void disconnect() {\n+        if(!connected) {\n+            return;\n+        }\n+        try {\n+            if (socket != null) {\n+                socket.close();\n+            }\n+        } catch (IOException ioe) {\n+            logger.info(\"Connection to air unit could not be closed gracefully. {}\", ioe.getMessage());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "846ac84dd0b9064408bce34d6eb0ef80467c7b6c"}, "originalPosition": 71}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQ5MzA1NA==", "bodyText": "This will throw an NPE when iStream is null and that is likely because it's nullable, is there any reason not to check?", "url": "https://github.com/openhab/openhab-addons/pull/6814#discussion_r422493054", "createdAt": "2020-05-09T12:59:49Z", "author": {"login": "martinvw"}, "path": "bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/DanfossAirUnitCommunicationController.java", "diffHunk": "@@ -0,0 +1,111 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.danfossairunit.internal;\n+\n+import static org.openhab.binding.danfossairunit.internal.Commands.EMPTY;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.net.InetAddress;\n+import java.net.Socket;\n+import java.util.Objects;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link DanfossAirUnitCommunicationController} class does the actual network communication with the air unit.\n+ *\n+ * @author Robert Bach - initial contribution\n+ */\n+\n+@NonNullByDefault\n+public class DanfossAirUnitCommunicationController {\n+\n+    private final Logger logger = LoggerFactory.getLogger(DanfossAirUnitCommunicationController.class);\n+\n+    private final InetAddress inetAddr;\n+    private final int port;\n+    private boolean connected = false;\n+    private @Nullable Socket socket;\n+    private @Nullable OutputStream oStream;\n+    private @Nullable InputStream iStream;\n+\n+    public DanfossAirUnitCommunicationController(InetAddress inetAddr, int port) {\n+        this.inetAddr = inetAddr;\n+        this.port = port;\n+    }\n+\n+    public synchronized void connect() throws IOException {\n+        if(connected) {\n+            return;\n+        }\n+        socket = new Socket(inetAddr, port);\n+        oStream = socket.getOutputStream();\n+        iStream = socket.getInputStream();\n+        connected = true;\n+    }\n+\n+    public synchronized void disconnect() {\n+        if(!connected) {\n+            return;\n+        }\n+        try {\n+            if (socket != null) {\n+                socket.close();\n+            }\n+        } catch (IOException ioe) {\n+            logger.info(\"Connection to air unit could not be closed gracefully. {}\", ioe.getMessage());\n+        } finally {\n+            socket = null;\n+            iStream = null;\n+            oStream = null;\n+        }\n+        connected = false;\n+    }\n+\n+    public byte[] sendRobustRequest(byte[] operation, byte[] register) throws IOException {\n+        return sendRobustRequest(operation, register, EMPTY);\n+    }\n+\n+    public synchronized byte[] sendRobustRequest(byte[] operation, byte[] register, byte[] value) throws IOException {\n+        connect();\n+        byte[] request = new byte[4 + value.length];\n+        System.arraycopy(operation, 0, request, 0, 2);\n+        System.arraycopy(register, 0, request, 2, 2);\n+        System.arraycopy(value, 0, request, 4, value.length);\n+        try {\n+            return sendRequestInternal(request);\n+        } catch (IOException ioe) {\n+            // retry once if there was connection problem\n+            disconnect();\n+            connect();\n+            return sendRequestInternal(request);\n+        }\n+    }\n+\n+    private synchronized byte[] sendRequestInternal(byte[] request) throws IOException {\n+\n+        Objects.requireNonNull(oStream).write(request);\n+        oStream.flush();\n+\n+        byte[] result = new byte[63];\n+        //noinspection ResultOfMethodCallIgnored\n+        Objects.requireNonNull(iStream).read(result, 0, 63);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "846ac84dd0b9064408bce34d6eb0ef80467c7b6c"}, "originalPosition": 107}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQ5MzA2NA==", "bodyText": "See below", "url": "https://github.com/openhab/openhab-addons/pull/6814#discussion_r422493064", "createdAt": "2020-05-09T12:59:58Z", "author": {"login": "martinvw"}, "path": "bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/DanfossAirUnitCommunicationController.java", "diffHunk": "@@ -0,0 +1,111 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.danfossairunit.internal;\n+\n+import static org.openhab.binding.danfossairunit.internal.Commands.EMPTY;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.net.InetAddress;\n+import java.net.Socket;\n+import java.util.Objects;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link DanfossAirUnitCommunicationController} class does the actual network communication with the air unit.\n+ *\n+ * @author Robert Bach - initial contribution\n+ */\n+\n+@NonNullByDefault\n+public class DanfossAirUnitCommunicationController {\n+\n+    private final Logger logger = LoggerFactory.getLogger(DanfossAirUnitCommunicationController.class);\n+\n+    private final InetAddress inetAddr;\n+    private final int port;\n+    private boolean connected = false;\n+    private @Nullable Socket socket;\n+    private @Nullable OutputStream oStream;\n+    private @Nullable InputStream iStream;\n+\n+    public DanfossAirUnitCommunicationController(InetAddress inetAddr, int port) {\n+        this.inetAddr = inetAddr;\n+        this.port = port;\n+    }\n+\n+    public synchronized void connect() throws IOException {\n+        if(connected) {\n+            return;\n+        }\n+        socket = new Socket(inetAddr, port);\n+        oStream = socket.getOutputStream();\n+        iStream = socket.getInputStream();\n+        connected = true;\n+    }\n+\n+    public synchronized void disconnect() {\n+        if(!connected) {\n+            return;\n+        }\n+        try {\n+            if (socket != null) {\n+                socket.close();\n+            }\n+        } catch (IOException ioe) {\n+            logger.info(\"Connection to air unit could not be closed gracefully. {}\", ioe.getMessage());\n+        } finally {\n+            socket = null;\n+            iStream = null;\n+            oStream = null;\n+        }\n+        connected = false;\n+    }\n+\n+    public byte[] sendRobustRequest(byte[] operation, byte[] register) throws IOException {\n+        return sendRobustRequest(operation, register, EMPTY);\n+    }\n+\n+    public synchronized byte[] sendRobustRequest(byte[] operation, byte[] register, byte[] value) throws IOException {\n+        connect();\n+        byte[] request = new byte[4 + value.length];\n+        System.arraycopy(operation, 0, request, 0, 2);\n+        System.arraycopy(register, 0, request, 2, 2);\n+        System.arraycopy(value, 0, request, 4, value.length);\n+        try {\n+            return sendRequestInternal(request);\n+        } catch (IOException ioe) {\n+            // retry once if there was connection problem\n+            disconnect();\n+            connect();\n+            return sendRequestInternal(request);\n+        }\n+    }\n+\n+    private synchronized byte[] sendRequestInternal(byte[] request) throws IOException {\n+\n+        Objects.requireNonNull(oStream).write(request);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "846ac84dd0b9064408bce34d6eb0ef80467c7b6c"}, "originalPosition": 102}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQ5MzExNA==", "bodyText": "Please put all fields above the constructor", "url": "https://github.com/openhab/openhab-addons/pull/6814#discussion_r422493114", "createdAt": "2020-05-09T13:00:28Z", "author": {"login": "martinvw"}, "path": "bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/DanfossAirUnitHandler.java", "diffHunk": "@@ -0,0 +1,165 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.danfossairunit.internal;\n+\n+import static org.openhab.binding.danfossairunit.internal.DanfossAirUnitBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.net.UnknownHostException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link DanfossAirUnitHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Ralf Duckstein - Initial contribution\n+ * @author Robert Bach - heavy refactorings\n+ */\n+@NonNullByDefault\n+public class DanfossAirUnitHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(DanfossAirUnitHandler.class);\n+\n+    private @Nullable DanfossAirUnitConfiguration config;\n+\n+    public DanfossAirUnitHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    private @Nullable ValueCache valueCache;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "846ac84dd0b9064408bce34d6eb0ef80467c7b6c"}, "originalPosition": 55}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQ5MzI2Mw==", "bodyText": "I don't think this should be an info log statement especially not without and context and without stack trace. I would propose to provide some context what is the code doing while this fails and pass the exception as parameter.", "url": "https://github.com/openhab/openhab-addons/pull/6814#discussion_r422493263", "createdAt": "2020-05-09T13:01:52Z", "author": {"login": "martinvw"}, "path": "bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/DanfossAirUnitHandler.java", "diffHunk": "@@ -0,0 +1,165 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.danfossairunit.internal;\n+\n+import static org.openhab.binding.danfossairunit.internal.DanfossAirUnitBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.net.UnknownHostException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link DanfossAirUnitHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Ralf Duckstein - Initial contribution\n+ * @author Robert Bach - heavy refactorings\n+ */\n+@NonNullByDefault\n+public class DanfossAirUnitHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(DanfossAirUnitHandler.class);\n+\n+    private @Nullable DanfossAirUnitConfiguration config;\n+\n+    public DanfossAirUnitHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    private @Nullable ValueCache valueCache;\n+\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+    private @Nullable DanfossAirUnit hrv;\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            updateAllChannels();\n+        } else {\n+            try {\n+                DanfossAirUnit danfossAirUnit = hrv;\n+                Channel channel = Channel.getByName(channelUID.getIdWithoutGroup());\n+                if (channel.getWriteAccessor() != null) {\n+                    updateState(channelUID, channel.getWriteAccessor().access(danfossAirUnit, command));\n+                }\n+            } catch (IllegalArgumentException e) {\n+                logger.info(\"{}\", e.getMessage());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "846ac84dd0b9064408bce34d6eb0ef80467c7b6c"}, "originalPosition": 72}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQ5MzI4NQ==", "bodyText": "Do you really need to catch the Exception-class or are there more specific exceptions you could catch like the IOException or maybe only RuntimeException's (which is not that good either). The current code and also catching RuntimeException's might 'hide' programming errors like NullPointerExceptions occurring.\nhttps://www.google.nl/search?q=java%20why%20not%20to%20catch%20exception", "url": "https://github.com/openhab/openhab-addons/pull/6814#discussion_r422493285", "createdAt": "2020-05-09T13:02:06Z", "author": {"login": "martinvw"}, "path": "bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/DanfossAirUnitHandler.java", "diffHunk": "@@ -0,0 +1,165 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.danfossairunit.internal;\n+\n+import static org.openhab.binding.danfossairunit.internal.DanfossAirUnitBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.net.UnknownHostException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link DanfossAirUnitHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Ralf Duckstein - Initial contribution\n+ * @author Robert Bach - heavy refactorings\n+ */\n+@NonNullByDefault\n+public class DanfossAirUnitHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(DanfossAirUnitHandler.class);\n+\n+    private @Nullable DanfossAirUnitConfiguration config;\n+\n+    public DanfossAirUnitHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    private @Nullable ValueCache valueCache;\n+\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+    private @Nullable DanfossAirUnit hrv;\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            updateAllChannels();\n+        } else {\n+            try {\n+                DanfossAirUnit danfossAirUnit = hrv;\n+                Channel channel = Channel.getByName(channelUID.getIdWithoutGroup());\n+                if (channel.getWriteAccessor() != null) {\n+                    updateState(channelUID, channel.getWriteAccessor().access(danfossAirUnit, command));\n+                }\n+            } catch (IllegalArgumentException e) {\n+                logger.info(\"{}\", e.getMessage());\n+            } catch (IOException ioe) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR, ioe.getMessage());\n+            } catch (Exception e) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "846ac84dd0b9064408bce34d6eb0ef80467c7b6c"}, "originalPosition": 75}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQ5MzMxNg==", "bodyText": "If you catch all Exception you are potentially also catching for example NullPointerExceptions and  they tend to miss a message, so you will be printing the message null which will make it troublesome to debug, in this case it is always better to log the complete stacktrace.", "url": "https://github.com/openhab/openhab-addons/pull/6814#discussion_r422493316", "createdAt": "2020-05-09T13:02:16Z", "author": {"login": "martinvw"}, "path": "bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/DanfossAirUnitHandler.java", "diffHunk": "@@ -0,0 +1,165 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.danfossairunit.internal;\n+\n+import static org.openhab.binding.danfossairunit.internal.DanfossAirUnitBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.net.UnknownHostException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link DanfossAirUnitHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Ralf Duckstein - Initial contribution\n+ * @author Robert Bach - heavy refactorings\n+ */\n+@NonNullByDefault\n+public class DanfossAirUnitHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(DanfossAirUnitHandler.class);\n+\n+    private @Nullable DanfossAirUnitConfiguration config;\n+\n+    public DanfossAirUnitHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    private @Nullable ValueCache valueCache;\n+\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+    private @Nullable DanfossAirUnit hrv;\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            updateAllChannels();\n+        } else {\n+            try {\n+                DanfossAirUnit danfossAirUnit = hrv;\n+                Channel channel = Channel.getByName(channelUID.getIdWithoutGroup());\n+                if (channel.getWriteAccessor() != null) {\n+                    updateState(channelUID, channel.getWriteAccessor().access(danfossAirUnit, command));\n+                }\n+            } catch (IllegalArgumentException e) {\n+                logger.info(\"{}\", e.getMessage());\n+            } catch (IOException ioe) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR, ioe.getMessage());\n+            } catch (Exception e) {\n+                logger.info(\"Error updating channel {}: {}\", channelUID, e.getMessage());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "846ac84dd0b9064408bce34d6eb0ef80467c7b6c"}, "originalPosition": 76}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQ5MzQ5MA==", "bodyText": "I doubt whether info is the proper log level and I suppose updating the thing status makes more sense for average users.", "url": "https://github.com/openhab/openhab-addons/pull/6814#discussion_r422493490", "createdAt": "2020-05-09T13:03:51Z", "author": {"login": "martinvw"}, "path": "bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/DanfossAirUnitHandler.java", "diffHunk": "@@ -0,0 +1,165 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.danfossairunit.internal;\n+\n+import static org.openhab.binding.danfossairunit.internal.DanfossAirUnitBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.net.UnknownHostException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link DanfossAirUnitHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Ralf Duckstein - Initial contribution\n+ * @author Robert Bach - heavy refactorings\n+ */\n+@NonNullByDefault\n+public class DanfossAirUnitHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(DanfossAirUnitHandler.class);\n+\n+    private @Nullable DanfossAirUnitConfiguration config;\n+\n+    public DanfossAirUnitHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    private @Nullable ValueCache valueCache;\n+\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+    private @Nullable DanfossAirUnit hrv;\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            updateAllChannels();\n+        } else {\n+            try {\n+                DanfossAirUnit danfossAirUnit = hrv;\n+                Channel channel = Channel.getByName(channelUID.getIdWithoutGroup());\n+                if (channel.getWriteAccessor() != null) {\n+                    updateState(channelUID, channel.getWriteAccessor().access(danfossAirUnit, command));\n+                }\n+            } catch (IllegalArgumentException e) {\n+                logger.info(\"{}\", e.getMessage());\n+            } catch (IOException ioe) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR, ioe.getMessage());\n+            } catch (Exception e) {\n+                logger.info(\"Error updating channel {}: {}\", channelUID, e.getMessage());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQ5MzMxNg=="}, "originalCommit": {"oid": "846ac84dd0b9064408bce34d6eb0ef80467c7b6c"}, "originalPosition": 76}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQ5MzU2Nw==", "bodyText": "It's an enum feel free to compare using ==", "url": "https://github.com/openhab/openhab-addons/pull/6814#discussion_r422493567", "createdAt": "2020-05-09T13:04:33Z", "author": {"login": "martinvw"}, "path": "bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/DanfossAirUnitHandler.java", "diffHunk": "@@ -0,0 +1,165 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.danfossairunit.internal;\n+\n+import static org.openhab.binding.danfossairunit.internal.DanfossAirUnitBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.net.UnknownHostException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link DanfossAirUnitHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Ralf Duckstein - Initial contribution\n+ * @author Robert Bach - heavy refactorings\n+ */\n+@NonNullByDefault\n+public class DanfossAirUnitHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(DanfossAirUnitHandler.class);\n+\n+    private @Nullable DanfossAirUnitConfiguration config;\n+\n+    public DanfossAirUnitHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    private @Nullable ValueCache valueCache;\n+\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+    private @Nullable DanfossAirUnit hrv;\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            updateAllChannels();\n+        } else {\n+            try {\n+                DanfossAirUnit danfossAirUnit = hrv;\n+                Channel channel = Channel.getByName(channelUID.getIdWithoutGroup());\n+                if (channel.getWriteAccessor() != null) {\n+                    updateState(channelUID, channel.getWriteAccessor().access(danfossAirUnit, command));\n+                }\n+            } catch (IllegalArgumentException e) {\n+                logger.info(\"{}\", e.getMessage());\n+            } catch (IOException ioe) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR, ioe.getMessage());\n+            } catch (Exception e) {\n+                logger.info(\"Error updating channel {}: {}\", channelUID, e.getMessage());\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        updateStatus(ThingStatus.UNKNOWN);\n+        config = getConfigAs(DanfossAirUnitConfiguration.class);\n+        valueCache = new ValueCache(config.updateUnchangedValuesEveryMillis);\n+        try {\n+            hrv = new DanfossAirUnit(InetAddress.getByName(config.host), 30046);\n+        } catch (UnknownHostException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                    \"Unknown host: \" + config.host);\n+            return;\n+        }\n+\n+        scheduler.execute(() -> {\n+            try {\n+                thing.setProperty(PROPERTY_UNIT_NAME, hrv.getUnitName());\n+                thing.setProperty(PROPERTY_SERIAL, hrv.getUnitSerialNumber());\n+                pollingJob = scheduler.scheduleWithFixedDelay(this::updateAllChannels, 5, config.refreshInterval,\n+                        TimeUnit.SECONDS);\n+                updateStatus(ThingStatus.ONLINE);\n+\n+            } catch (IOException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR, e.getMessage());\n+            }\n+        });\n+    }\n+\n+    private void updateAllChannels() {\n+        if (hrv == null) {\n+            return;\n+        }\n+        DanfossAirUnit danfossAirUnit = hrv;\n+        logger.debug(\"Updating DanfossHRV data '{}'\", getThing().getUID());\n+\n+        try {\n+            for (Channel channel : Channel.values()) {\n+                if (Thread.interrupted()) {\n+                    logger.debug(\"Polling thread interrupted...\");\n+                    return;\n+                }\n+                try {\n+                    updateState(channel.getGroup().getGroupName(), channel.getChannelName(),\n+                            channel.getReadAccessor().access(danfossAirUnit));\n+                } catch(UnexpectedResponseValueException e) {\n+                    updateState(channel.getGroup().getGroupName(), channel.getChannelName(), UnDefType.UNDEF);\n+                    logger.debug(\"Cannot update channel {}: an unexpected or invalid response has been received from the air unit: {}\",\n+                            channel.getChannelName(), e.getMessage());\n+                } catch (IOException e) {\n+                    updateState(channel.getGroup().getGroupName(), channel.getChannelName(), UnDefType.UNDEF);\n+                    logger.debug(\"Cannot update channel {}: an error occurred retrieving the value: {}\",\n+                            channel.getChannelName(), e.getMessage());\n+                }\n+            }\n+\n+            if (getThing().getStatus().equals(ThingStatus.OFFLINE)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "846ac84dd0b9064408bce34d6eb0ef80467c7b6c"}, "originalPosition": 135}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQ5Mzc2MA==", "bodyText": "At first glance, this catches exception before the outer catch can handle them. Should this catch update any status?", "url": "https://github.com/openhab/openhab-addons/pull/6814#discussion_r422493760", "createdAt": "2020-05-09T13:06:14Z", "author": {"login": "martinvw"}, "path": "bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/DanfossAirUnitHandler.java", "diffHunk": "@@ -0,0 +1,165 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.danfossairunit.internal;\n+\n+import static org.openhab.binding.danfossairunit.internal.DanfossAirUnitBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.net.UnknownHostException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link DanfossAirUnitHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Ralf Duckstein - Initial contribution\n+ * @author Robert Bach - heavy refactorings\n+ */\n+@NonNullByDefault\n+public class DanfossAirUnitHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(DanfossAirUnitHandler.class);\n+\n+    private @Nullable DanfossAirUnitConfiguration config;\n+\n+    public DanfossAirUnitHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    private @Nullable ValueCache valueCache;\n+\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+    private @Nullable DanfossAirUnit hrv;\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            updateAllChannels();\n+        } else {\n+            try {\n+                DanfossAirUnit danfossAirUnit = hrv;\n+                Channel channel = Channel.getByName(channelUID.getIdWithoutGroup());\n+                if (channel.getWriteAccessor() != null) {\n+                    updateState(channelUID, channel.getWriteAccessor().access(danfossAirUnit, command));\n+                }\n+            } catch (IllegalArgumentException e) {\n+                logger.info(\"{}\", e.getMessage());\n+            } catch (IOException ioe) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR, ioe.getMessage());\n+            } catch (Exception e) {\n+                logger.info(\"Error updating channel {}: {}\", channelUID, e.getMessage());\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        updateStatus(ThingStatus.UNKNOWN);\n+        config = getConfigAs(DanfossAirUnitConfiguration.class);\n+        valueCache = new ValueCache(config.updateUnchangedValuesEveryMillis);\n+        try {\n+            hrv = new DanfossAirUnit(InetAddress.getByName(config.host), 30046);\n+        } catch (UnknownHostException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                    \"Unknown host: \" + config.host);\n+            return;\n+        }\n+\n+        scheduler.execute(() -> {\n+            try {\n+                thing.setProperty(PROPERTY_UNIT_NAME, hrv.getUnitName());\n+                thing.setProperty(PROPERTY_SERIAL, hrv.getUnitSerialNumber());\n+                pollingJob = scheduler.scheduleWithFixedDelay(this::updateAllChannels, 5, config.refreshInterval,\n+                        TimeUnit.SECONDS);\n+                updateStatus(ThingStatus.ONLINE);\n+\n+            } catch (IOException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR, e.getMessage());\n+            }\n+        });\n+    }\n+\n+    private void updateAllChannels() {\n+        if (hrv == null) {\n+            return;\n+        }\n+        DanfossAirUnit danfossAirUnit = hrv;\n+        logger.debug(\"Updating DanfossHRV data '{}'\", getThing().getUID());\n+\n+        try {\n+            for (Channel channel : Channel.values()) {\n+                if (Thread.interrupted()) {\n+                    logger.debug(\"Polling thread interrupted...\");\n+                    return;\n+                }\n+                try {\n+                    updateState(channel.getGroup().getGroupName(), channel.getChannelName(),\n+                            channel.getReadAccessor().access(danfossAirUnit));\n+                } catch(UnexpectedResponseValueException e) {\n+                    updateState(channel.getGroup().getGroupName(), channel.getChannelName(), UnDefType.UNDEF);\n+                    logger.debug(\"Cannot update channel {}: an unexpected or invalid response has been received from the air unit: {}\",\n+                            channel.getChannelName(), e.getMessage());\n+                } catch (IOException e) {\n+                    updateState(channel.getGroup().getGroupName(), channel.getChannelName(), UnDefType.UNDEF);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "846ac84dd0b9064408bce34d6eb0ef80467c7b6c"}, "originalPosition": 129}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQ5Mzc3MQ==", "bodyText": "See above check all", "url": "https://github.com/openhab/openhab-addons/pull/6814#discussion_r422493771", "createdAt": "2020-05-09T13:06:28Z", "author": {"login": "martinvw"}, "path": "bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/DanfossAirUnitHandler.java", "diffHunk": "@@ -0,0 +1,165 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.danfossairunit.internal;\n+\n+import static org.openhab.binding.danfossairunit.internal.DanfossAirUnitBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.net.UnknownHostException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link DanfossAirUnitHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Ralf Duckstein - Initial contribution\n+ * @author Robert Bach - heavy refactorings\n+ */\n+@NonNullByDefault\n+public class DanfossAirUnitHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(DanfossAirUnitHandler.class);\n+\n+    private @Nullable DanfossAirUnitConfiguration config;\n+\n+    public DanfossAirUnitHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    private @Nullable ValueCache valueCache;\n+\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+    private @Nullable DanfossAirUnit hrv;\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            updateAllChannels();\n+        } else {\n+            try {\n+                DanfossAirUnit danfossAirUnit = hrv;\n+                Channel channel = Channel.getByName(channelUID.getIdWithoutGroup());\n+                if (channel.getWriteAccessor() != null) {\n+                    updateState(channelUID, channel.getWriteAccessor().access(danfossAirUnit, command));\n+                }\n+            } catch (IllegalArgumentException e) {\n+                logger.info(\"{}\", e.getMessage());\n+            } catch (IOException ioe) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR, ioe.getMessage());\n+            } catch (Exception e) {\n+                logger.info(\"Error updating channel {}: {}\", channelUID, e.getMessage());\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        updateStatus(ThingStatus.UNKNOWN);\n+        config = getConfigAs(DanfossAirUnitConfiguration.class);\n+        valueCache = new ValueCache(config.updateUnchangedValuesEveryMillis);\n+        try {\n+            hrv = new DanfossAirUnit(InetAddress.getByName(config.host), 30046);\n+        } catch (UnknownHostException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                    \"Unknown host: \" + config.host);\n+            return;\n+        }\n+\n+        scheduler.execute(() -> {\n+            try {\n+                thing.setProperty(PROPERTY_UNIT_NAME, hrv.getUnitName());\n+                thing.setProperty(PROPERTY_SERIAL, hrv.getUnitSerialNumber());\n+                pollingJob = scheduler.scheduleWithFixedDelay(this::updateAllChannels, 5, config.refreshInterval,\n+                        TimeUnit.SECONDS);\n+                updateStatus(ThingStatus.ONLINE);\n+\n+            } catch (IOException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR, e.getMessage());\n+            }\n+        });\n+    }\n+\n+    private void updateAllChannels() {\n+        if (hrv == null) {\n+            return;\n+        }\n+        DanfossAirUnit danfossAirUnit = hrv;\n+        logger.debug(\"Updating DanfossHRV data '{}'\", getThing().getUID());\n+\n+        try {\n+            for (Channel channel : Channel.values()) {\n+                if (Thread.interrupted()) {\n+                    logger.debug(\"Polling thread interrupted...\");\n+                    return;\n+                }\n+                try {\n+                    updateState(channel.getGroup().getGroupName(), channel.getChannelName(),\n+                            channel.getReadAccessor().access(danfossAirUnit));\n+                } catch(UnexpectedResponseValueException e) {\n+                    updateState(channel.getGroup().getGroupName(), channel.getChannelName(), UnDefType.UNDEF);\n+                    logger.debug(\"Cannot update channel {}: an unexpected or invalid response has been received from the air unit: {}\",\n+                            channel.getChannelName(), e.getMessage());\n+                } catch (IOException e) {\n+                    updateState(channel.getGroup().getGroupName(), channel.getChannelName(), UnDefType.UNDEF);\n+                    logger.debug(\"Cannot update channel {}: an error occurred retrieving the value: {}\",\n+                            channel.getChannelName(), e.getMessage());\n+                }\n+            }\n+\n+            if (getThing().getStatus().equals(ThingStatus.OFFLINE)) {\n+                updateStatus(ThingStatus.ONLINE);\n+            }\n+        } catch (IOException ioe) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR, ioe.getMessage());\n+        } catch (Exception e) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "846ac84dd0b9064408bce34d6eb0ef80467c7b6c"}, "originalPosition": 140}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQ5MzkyMA==", "bodyText": "If you really need this nested try-catch I would suggest to split of the part of the code that contains the nested try-catch to a separate method. This makes your code more readable and it might also make it more clear which part of the exceptions should be handled inside the method and which in the updateAllChannels method", "url": "https://github.com/openhab/openhab-addons/pull/6814#discussion_r422493920", "createdAt": "2020-05-09T13:07:58Z", "author": {"login": "martinvw"}, "path": "bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/DanfossAirUnitHandler.java", "diffHunk": "@@ -0,0 +1,165 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.danfossairunit.internal;\n+\n+import static org.openhab.binding.danfossairunit.internal.DanfossAirUnitBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.net.UnknownHostException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link DanfossAirUnitHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Ralf Duckstein - Initial contribution\n+ * @author Robert Bach - heavy refactorings\n+ */\n+@NonNullByDefault\n+public class DanfossAirUnitHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(DanfossAirUnitHandler.class);\n+\n+    private @Nullable DanfossAirUnitConfiguration config;\n+\n+    public DanfossAirUnitHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    private @Nullable ValueCache valueCache;\n+\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+    private @Nullable DanfossAirUnit hrv;\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            updateAllChannels();\n+        } else {\n+            try {\n+                DanfossAirUnit danfossAirUnit = hrv;\n+                Channel channel = Channel.getByName(channelUID.getIdWithoutGroup());\n+                if (channel.getWriteAccessor() != null) {\n+                    updateState(channelUID, channel.getWriteAccessor().access(danfossAirUnit, command));\n+                }\n+            } catch (IllegalArgumentException e) {\n+                logger.info(\"{}\", e.getMessage());\n+            } catch (IOException ioe) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR, ioe.getMessage());\n+            } catch (Exception e) {\n+                logger.info(\"Error updating channel {}: {}\", channelUID, e.getMessage());\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        updateStatus(ThingStatus.UNKNOWN);\n+        config = getConfigAs(DanfossAirUnitConfiguration.class);\n+        valueCache = new ValueCache(config.updateUnchangedValuesEveryMillis);\n+        try {\n+            hrv = new DanfossAirUnit(InetAddress.getByName(config.host), 30046);\n+        } catch (UnknownHostException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                    \"Unknown host: \" + config.host);\n+            return;\n+        }\n+\n+        scheduler.execute(() -> {\n+            try {\n+                thing.setProperty(PROPERTY_UNIT_NAME, hrv.getUnitName());\n+                thing.setProperty(PROPERTY_SERIAL, hrv.getUnitSerialNumber());\n+                pollingJob = scheduler.scheduleWithFixedDelay(this::updateAllChannels, 5, config.refreshInterval,\n+                        TimeUnit.SECONDS);\n+                updateStatus(ThingStatus.ONLINE);\n+\n+            } catch (IOException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR, e.getMessage());\n+            }\n+        });\n+    }\n+\n+    private void updateAllChannels() {\n+        if (hrv == null) {\n+            return;\n+        }\n+        DanfossAirUnit danfossAirUnit = hrv;\n+        logger.debug(\"Updating DanfossHRV data '{}'\", getThing().getUID());\n+\n+        try {\n+            for (Channel channel : Channel.values()) {\n+                if (Thread.interrupted()) {\n+                    logger.debug(\"Polling thread interrupted...\");\n+                    return;\n+                }\n+                try {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "846ac84dd0b9064408bce34d6eb0ef80467c7b6c"}, "originalPosition": 121}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQ5NDEzOQ==", "bodyText": "If you really need this nested try-catch I would suggest to split of the part of the code that contains the nested try-catch to a separate method. This makes your code more readable and it might also make it more clear which part of the exceptions should be handled inside the method and which in the updateAllChannels method", "url": "https://github.com/openhab/openhab-addons/pull/6814#discussion_r422494139", "createdAt": "2020-05-09T13:10:18Z", "author": {"login": "martinvw"}, "path": "bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/DanfossAirUnitHandler.java", "diffHunk": "@@ -0,0 +1,165 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.danfossairunit.internal;\n+\n+import static org.openhab.binding.danfossairunit.internal.DanfossAirUnitBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.net.UnknownHostException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link DanfossAirUnitHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Ralf Duckstein - Initial contribution\n+ * @author Robert Bach - heavy refactorings\n+ */\n+@NonNullByDefault\n+public class DanfossAirUnitHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(DanfossAirUnitHandler.class);\n+\n+    private @Nullable DanfossAirUnitConfiguration config;\n+\n+    public DanfossAirUnitHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    private @Nullable ValueCache valueCache;\n+\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+    private @Nullable DanfossAirUnit hrv;\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            updateAllChannels();\n+        } else {\n+            try {\n+                DanfossAirUnit danfossAirUnit = hrv;\n+                Channel channel = Channel.getByName(channelUID.getIdWithoutGroup());\n+                if (channel.getWriteAccessor() != null) {\n+                    updateState(channelUID, channel.getWriteAccessor().access(danfossAirUnit, command));\n+                }\n+            } catch (IllegalArgumentException e) {\n+                logger.info(\"{}\", e.getMessage());\n+            } catch (IOException ioe) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR, ioe.getMessage());\n+            } catch (Exception e) {\n+                logger.info(\"Error updating channel {}: {}\", channelUID, e.getMessage());\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        updateStatus(ThingStatus.UNKNOWN);\n+        config = getConfigAs(DanfossAirUnitConfiguration.class);\n+        valueCache = new ValueCache(config.updateUnchangedValuesEveryMillis);\n+        try {\n+            hrv = new DanfossAirUnit(InetAddress.getByName(config.host), 30046);\n+        } catch (UnknownHostException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                    \"Unknown host: \" + config.host);\n+            return;\n+        }\n+\n+        scheduler.execute(() -> {\n+            try {\n+                thing.setProperty(PROPERTY_UNIT_NAME, hrv.getUnitName());\n+                thing.setProperty(PROPERTY_SERIAL, hrv.getUnitSerialNumber());\n+                pollingJob = scheduler.scheduleWithFixedDelay(this::updateAllChannels, 5, config.refreshInterval,\n+                        TimeUnit.SECONDS);\n+                updateStatus(ThingStatus.ONLINE);\n+\n+            } catch (IOException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR, e.getMessage());\n+            }\n+        });\n+    }\n+\n+    private void updateAllChannels() {\n+        if (hrv == null) {\n+            return;\n+        }\n+        DanfossAirUnit danfossAirUnit = hrv;\n+        logger.debug(\"Updating DanfossHRV data '{}'\", getThing().getUID());\n+\n+        try {\n+            for (Channel channel : Channel.values()) {\n+                if (Thread.interrupted()) {\n+                    logger.debug(\"Polling thread interrupted...\");\n+                    return;\n+                }\n+                try {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "846ac84dd0b9064408bce34d6eb0ef80467c7b6c"}, "originalPosition": 121}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQ5NDI4Ng==", "bodyText": "Please check for all classes that lack NonNullByDefault annotations whether they can be added easily", "url": "https://github.com/openhab/openhab-addons/pull/6814#discussion_r422494286", "createdAt": "2020-05-09T13:11:39Z", "author": {"login": "martinvw"}, "path": "bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/Mode.java", "diffHunk": "@@ -0,0 +1,25 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.danfossairunit.internal;\n+\n+/**\n+ * The {@link Mode} enum represents an air unit operation mode.\n+ *\n+ * @author Robert Bach - Initial contribution\n+ */\n+public enum Mode {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "846ac84dd0b9064408bce34d6eb0ef80467c7b6c"}, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQ5NDQzMw==", "bodyText": "You don't have to call toString it will be called automatically, but only when the logging-level actually applies.", "url": "https://github.com/openhab/openhab-addons/pull/6814#discussion_r422494433", "createdAt": "2020-05-09T13:13:07Z", "author": {"login": "martinvw"}, "path": "bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/discovery/DanfossAirUnitDiscoveryService.java", "diffHunk": "@@ -0,0 +1,139 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.danfossairunit.internal.discovery;\n+\n+import static org.openhab.binding.danfossairunit.internal.DanfossAirUnitBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.InetAddress;\n+import java.net.InterfaceAddress;\n+import java.net.NetworkInterface;\n+import java.net.SocketTimeoutException;\n+import java.util.*;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.smarthome.config.discovery.AbstractDiscoveryService;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResult;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResultBuilder;\n+import org.eclipse.smarthome.config.discovery.DiscoveryService;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.thing.ThingUID;\n+import org.osgi.service.component.annotations.Component;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The Discovery service implementation to scan for available air units in the network via broadcast.\n+ *\n+ * @author Ralf Duckstein - Initial contribution\n+ * @author Robert Bach - heavy refactorings\n+ */\n+@Component(service = DiscoveryService.class, immediate = true)\n+@NonNullByDefault\n+public class DanfossAirUnitDiscoveryService extends AbstractDiscoveryService {\n+\n+    private static final int BROADCAST_PORT = 30045;\n+    private static final byte[] DISCOVER_SEND = { 0x0c, 0x00, 0x30, 0x00, 0x11, 0x00, 0x12, 0x00, 0x13 };\n+    private static final byte[] DISCOVER_RECEIVE = { 0x0d, 0x00, 0x07, 0x00, 0x02, 0x02, 0x00 };\n+\n+    private Logger logger = LoggerFactory.getLogger(DanfossAirUnitDiscoveryService.class);\n+\n+    public DanfossAirUnitDiscoveryService() {\n+        super(SUPPORTED_THING_TYPES_UIDS, 15, true);\n+    }\n+\n+    @Override\n+    public Set<ThingTypeUID> getSupportedThingTypes() {\n+        return SUPPORTED_THING_TYPES_UIDS;\n+    }\n+\n+    @Override\n+    protected void startBackgroundDiscovery() {\n+        logger.debug(\"Start Danfoss Air CCM background discovery\");\n+        scheduler.execute(this::discover);\n+    }\n+\n+    @Override\n+    public void startScan() {\n+        logger.debug(\"Start Danfoss Air CCM scan\");\n+        discover();\n+    }\n+\n+    private synchronized void discover() {\n+        logger.debug(\"Try to discover all Danfoss Air CCM devices\");\n+\n+        try (DatagramSocket socket = new DatagramSocket()) {\n+\n+            Enumeration<NetworkInterface> interfaces = NetworkInterface.getNetworkInterfaces();\n+            while (interfaces.hasMoreElements()) {\n+                NetworkInterface networkInterface = interfaces.nextElement();\n+                if (networkInterface == null || networkInterface.isLoopback() || !networkInterface.isUp()) {\n+                    continue;\n+                }\n+                for (InterfaceAddress interfaceAddress : networkInterface.getInterfaceAddresses()) {\n+                    if (interfaceAddress == null || interfaceAddress.getBroadcast() == null) {\n+                        continue;\n+                    }\n+                    logger.debug(\"Sending broadcast on interface {} to discover Danfoss Air CCM device...\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "846ac84dd0b9064408bce34d6eb0ef80467c7b6c"}, "originalPosition": 89}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQ5NDY4MA==", "bodyText": "Is this missing a break, because if the device responds it will just keep running or will it always throw an SocketTimeoutException?", "url": "https://github.com/openhab/openhab-addons/pull/6814#discussion_r422494680", "createdAt": "2020-05-09T13:15:35Z", "author": {"login": "martinvw"}, "path": "bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/discovery/DanfossAirUnitDiscoveryService.java", "diffHunk": "@@ -0,0 +1,139 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.danfossairunit.internal.discovery;\n+\n+import static org.openhab.binding.danfossairunit.internal.DanfossAirUnitBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.InetAddress;\n+import java.net.InterfaceAddress;\n+import java.net.NetworkInterface;\n+import java.net.SocketTimeoutException;\n+import java.util.*;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.smarthome.config.discovery.AbstractDiscoveryService;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResult;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResultBuilder;\n+import org.eclipse.smarthome.config.discovery.DiscoveryService;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.thing.ThingUID;\n+import org.osgi.service.component.annotations.Component;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The Discovery service implementation to scan for available air units in the network via broadcast.\n+ *\n+ * @author Ralf Duckstein - Initial contribution\n+ * @author Robert Bach - heavy refactorings\n+ */\n+@Component(service = DiscoveryService.class, immediate = true)\n+@NonNullByDefault\n+public class DanfossAirUnitDiscoveryService extends AbstractDiscoveryService {\n+\n+    private static final int BROADCAST_PORT = 30045;\n+    private static final byte[] DISCOVER_SEND = { 0x0c, 0x00, 0x30, 0x00, 0x11, 0x00, 0x12, 0x00, 0x13 };\n+    private static final byte[] DISCOVER_RECEIVE = { 0x0d, 0x00, 0x07, 0x00, 0x02, 0x02, 0x00 };\n+\n+    private Logger logger = LoggerFactory.getLogger(DanfossAirUnitDiscoveryService.class);\n+\n+    public DanfossAirUnitDiscoveryService() {\n+        super(SUPPORTED_THING_TYPES_UIDS, 15, true);\n+    }\n+\n+    @Override\n+    public Set<ThingTypeUID> getSupportedThingTypes() {\n+        return SUPPORTED_THING_TYPES_UIDS;\n+    }\n+\n+    @Override\n+    protected void startBackgroundDiscovery() {\n+        logger.debug(\"Start Danfoss Air CCM background discovery\");\n+        scheduler.execute(this::discover);\n+    }\n+\n+    @Override\n+    public void startScan() {\n+        logger.debug(\"Start Danfoss Air CCM scan\");\n+        discover();\n+    }\n+\n+    private synchronized void discover() {\n+        logger.debug(\"Try to discover all Danfoss Air CCM devices\");\n+\n+        try (DatagramSocket socket = new DatagramSocket()) {\n+\n+            Enumeration<NetworkInterface> interfaces = NetworkInterface.getNetworkInterfaces();\n+            while (interfaces.hasMoreElements()) {\n+                NetworkInterface networkInterface = interfaces.nextElement();\n+                if (networkInterface == null || networkInterface.isLoopback() || !networkInterface.isUp()) {\n+                    continue;\n+                }\n+                for (InterfaceAddress interfaceAddress : networkInterface.getInterfaceAddresses()) {\n+                    if (interfaceAddress == null || interfaceAddress.getBroadcast() == null) {\n+                        continue;\n+                    }\n+                    logger.debug(\"Sending broadcast on interface {} to discover Danfoss Air CCM device...\",\n+                            interfaceAddress.getAddress().toString());\n+                    sendBroadcastToDiscoverThing(socket, interfaceAddress.getBroadcast());\n+                }\n+            }\n+\n+        } catch (IOException e) {\n+            logger.debug(\"No Danfoss Air CCM device found. Diagnostic: {}\", e.getMessage());\n+        }\n+    }\n+\n+    private void sendBroadcastToDiscoverThing(DatagramSocket socket, InetAddress broadcastAddress) throws IOException {\n+        socket.setBroadcast(true);\n+        socket.setSoTimeout(500);\n+        // send discover\n+        byte[] sendBuffer = DISCOVER_SEND;\n+        DatagramPacket sendPacket = new DatagramPacket(sendBuffer, sendBuffer.length, broadcastAddress, BROADCAST_PORT);\n+        socket.send(sendPacket);\n+        logger.debug(\"Discover message sent\");\n+\n+        // wait for responses\n+        while (true) {\n+            byte[] receiveBuffer = new byte[7];\n+            DatagramPacket receivePacket = new DatagramPacket(receiveBuffer, receiveBuffer.length);\n+            try {\n+                socket.receive(receivePacket);\n+            } catch (SocketTimeoutException e) {\n+                break; // leave the endless loop\n+            }\n+\n+            byte[] data = receivePacket.getData();\n+            if (Arrays.equals(data, DISCOVER_RECEIVE)) {\n+                logger.debug(\"Discover received correct response\");\n+\n+                String host = receivePacket.getAddress().getHostName();\n+                Map<String, Object> properties = new HashMap<>();\n+                properties.put(\"host\", host);\n+\n+                logger.debug(\"Adding a new Danfoss Air Unit CCM '{}' to inbox\", host);\n+\n+                ThingUID uid = new ThingUID(THING_TYPE_AIRUNIT, String.valueOf(receivePacket.getAddress().hashCode()));\n+\n+                DiscoveryResult result = DiscoveryResultBuilder.create(uid).withRepresentationProperty(\"host\")\n+                        .withProperties(properties).withLabel(\"Danfoss HRV\").build();\n+                thingDiscovered(result);\n+\n+                logger.debug(\"Thing discovered '{}'\", result);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "846ac84dd0b9064408bce34d6eb0ef80467c7b6c"}, "originalPosition": 135}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "22efaaafbe9fbbc631ebe18128e11b8dfffa74f8", "author": {"user": null}, "url": "https://github.com/openhab/openhab-addons/commit/22efaaafbe9fbbc631ebe18128e11b8dfffa74f8", "committedDate": "2020-05-11T16:09:56Z", "message": "[danfossairunit] initial contribution\n\nSigned-off-by: Robert Bach <openhab@mortalsilence.net>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA5NDM4NTcy", "url": "https://github.com/openhab/openhab-addons/pull/6814#pullrequestreview-409438572", "createdAt": "2020-05-11T18:48:41Z", "commit": {"oid": "22efaaafbe9fbbc631ebe18128e11b8dfffa74f8"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1624, "cost": 1, "resetAt": "2021-10-28T19:08:13Z"}}}