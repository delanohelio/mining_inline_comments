{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTA3MzA2NTI3", "number": 8819, "reviewThreads": {"totalCount": 36, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQxNjozODozN1rOEwV02w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNFQwODoyMDo1OFrOExe4lw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE5MTI0Njk5OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.bluetooth.bluez/README.md", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQxNjozODozN1rOHl1jOg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQxODo0MzozM1rOHl9odw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTQzNjczMA==", "bodyText": "Looks like I forgot to resolve the conflicts here from my own branch...\nJust leave it as\nBridge bluetooth:bluez:hci0 [ address=\"12:34:56:78:90:AB\", backgroundDiscovery=false ]", "url": "https://github.com/openhab/openhab-addons/pull/8819#discussion_r509436730", "createdAt": "2020-10-21T16:38:37Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.bluetooth.bluez/README.md", "diffHunk": "@@ -45,19 +12,26 @@ It defines the following bridge type:\n | bluez          | A Bluetooth adapter that is supported by BlueZ                            |\n \n \n-## Discovery\n-\n-If BlueZ is enabled and can be accessed, all available adapters are automatically discovered.\n-\n ## Bridge Configuration\n \n The bluez bridge requires the configuration parameter `address`, which corresponds to the Bluetooth address of the adapter (in format \"XX:XX:XX:XX:XX:XX\").\n+\n Additionally, the parameter `backgroundDiscovery` can be set to true/false.When set to true, any Bluetooth device of which broadcasts are received is added to the Inbox.\n \n ## Example\n \n This is how an BlueZ adapter can be configured textually in a *.things file:\n \n ```\n+<<<<<<< HEAD\n+Bridge bluetooth:bluez:hci0 [ address=\"12:34:56:78:90:AB\" ]\n+=======\n Bridge bluetooth:bluez:hci0 [ address=\"12:34:56:78:90:AB\", backgroundDiscovery=false ]\n+>>>>>>> bluetooth-channels", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1e67777e5ee588d82fccd47bbdbbaa8d1f12d39d"}, "originalPosition": 65}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTQ5OTE5Mw==", "bodyText": "Actually, the backgroundDiscovery is not supported. I'll remove it.", "url": "https://github.com/openhab/openhab-addons/pull/8819#discussion_r509499193", "createdAt": "2020-10-21T17:47:58Z", "author": {"login": "blafois"}, "path": "bundles/org.openhab.binding.bluetooth.bluez/README.md", "diffHunk": "@@ -45,19 +12,26 @@ It defines the following bridge type:\n | bluez          | A Bluetooth adapter that is supported by BlueZ                            |\n \n \n-## Discovery\n-\n-If BlueZ is enabled and can be accessed, all available adapters are automatically discovered.\n-\n ## Bridge Configuration\n \n The bluez bridge requires the configuration parameter `address`, which corresponds to the Bluetooth address of the adapter (in format \"XX:XX:XX:XX:XX:XX\").\n+\n Additionally, the parameter `backgroundDiscovery` can be set to true/false.When set to true, any Bluetooth device of which broadcasts are received is added to the Inbox.\n \n ## Example\n \n This is how an BlueZ adapter can be configured textually in a *.things file:\n \n ```\n+<<<<<<< HEAD\n+Bridge bluetooth:bluez:hci0 [ address=\"12:34:56:78:90:AB\" ]\n+=======\n Bridge bluetooth:bluez:hci0 [ address=\"12:34:56:78:90:AB\", backgroundDiscovery=false ]\n+>>>>>>> bluetooth-channels", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTQzNjczMA=="}, "originalCommit": {"oid": "1e67777e5ee588d82fccd47bbdbbaa8d1f12d39d"}, "originalPosition": 65}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTU2OTE0Mw==", "bodyText": "backgroundDiscovery actually is supported through the AbstractBluetoothBridgeHandler", "url": "https://github.com/openhab/openhab-addons/pull/8819#discussion_r509569143", "createdAt": "2020-10-21T18:43:33Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.bluetooth.bluez/README.md", "diffHunk": "@@ -45,19 +12,26 @@ It defines the following bridge type:\n | bluez          | A Bluetooth adapter that is supported by BlueZ                            |\n \n \n-## Discovery\n-\n-If BlueZ is enabled and can be accessed, all available adapters are automatically discovered.\n-\n ## Bridge Configuration\n \n The bluez bridge requires the configuration parameter `address`, which corresponds to the Bluetooth address of the adapter (in format \"XX:XX:XX:XX:XX:XX\").\n+\n Additionally, the parameter `backgroundDiscovery` can be set to true/false.When set to true, any Bluetooth device of which broadcasts are received is added to the Inbox.\n \n ## Example\n \n This is how an BlueZ adapter can be configured textually in a *.things file:\n \n ```\n+<<<<<<< HEAD\n+Bridge bluetooth:bluez:hci0 [ address=\"12:34:56:78:90:AB\" ]\n+=======\n Bridge bluetooth:bluez:hci0 [ address=\"12:34:56:78:90:AB\", backgroundDiscovery=false ]\n+>>>>>>> bluetooth-channels", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTQzNjczMA=="}, "originalCommit": {"oid": "1e67777e5ee588d82fccd47bbdbbaa8d1f12d39d"}, "originalPosition": 65}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE5MTI0Nzk2OnYy", "diffSide": "LEFT", "path": "bundles/org.openhab.binding.bluetooth.bluez/README.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQxNjozODo1NVrOHl1j4w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQxNjozODo1NVrOHl1j4w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTQzNjg5OQ==", "bodyText": "This should be left in.", "url": "https://github.com/openhab/openhab-addons/pull/8819#discussion_r509436899", "createdAt": "2020-10-21T16:38:55Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.bluetooth.bluez/README.md", "diffHunk": "@@ -45,19 +12,26 @@ It defines the following bridge type:\n | bluez          | A Bluetooth adapter that is supported by BlueZ                            |\n \n \n-## Discovery\n-\n-If BlueZ is enabled and can be accessed, all available adapters are automatically discovered.\n-", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1e67777e5ee588d82fccd47bbdbbaa8d1f12d39d"}, "originalPosition": 49}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE5MTI0OTY4OnYy", "diffSide": "LEFT", "path": "bundles/org.openhab.binding.bluetooth.bluez/README.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQxNjozOToxOFrOHl1k7Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQxNjozOToxOFrOHl1k7Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTQzNzE2NQ==", "bodyText": "These setup notes should be left in as well.", "url": "https://github.com/openhab/openhab-addons/pull/8819#discussion_r509437165", "createdAt": "2020-10-21T16:39:18Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.bluetooth.bluez/README.md", "diffHunk": "@@ -1,40 +1,7 @@\n # Bluetooth BlueZ Adapter\n \n-This extension supports Bluetooth access via BlueZ on Linux (ARMv6hf).\n+This extension supports Bluetooth access via BlueZ and DBus on Linux. This is architecture agnostic and uses Unix Sockets.\n \n-# Setup\n-\n-Please note that at least BlueZ 5.43 is required, while 5.48 or above are [not (yet) supported](https://github.com/intel-iot-devkit/tinyb/issues/131) either.\n-\n-Some settings are required to ensure that openHAB has access to Bluez.\n-To allow openHAB to access Bluez via dbus you need to add the following entry within your dbus configuration in `/etc/dbus-1/system.d/bluetooth.conf`\n-\n-```xml\n-<busconfig>\n-  <policy user=\"root\">\n-    ...\n-  </policy>\n-  <policy group=\"bluetooth\">\n-    <allow send_destination=\"org.bluez\"/>\n-  </policy>\n-  ...\n-</busconfig>\n-```\n-\n-and add openHAB to the \"bluetooth\" group.\n-\n-```shell\n-sudo adduser openhab bluetooth\n-```\n-\n-Also, in case you don't want to manually enable your bluetooth adapters with `bluetoothctl`, ensure that it's automatically enabled by setting the option `AutoEnable` in your `/etc/bluetooth/main.conf` to `true`.\n-Restart running services for changes to take effect.\n-\n-```\n-systemctl restart dbus\n-systemctl restart bluetooth\n-systemctl restart openhab2\n-```", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1e67777e5ee588d82fccd47bbdbbaa8d1f12d39d"}, "originalPosition": 38}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE5MTI1NDQ3OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.bluetooth.bluez/src/main/feature/feature.xml", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQxNjo0MDoyMlrOHl1n0g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQxNjo0MDoyMlrOHl1n0g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTQzNzkwNg==", "bodyText": "This line isn't needed until the general bluetooth PR is committed, so feel free to remove this.\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\t<bundle dependency=\"true\">mvn:commons-beanutils/commons-beanutils/1.9.3</bundle>", "url": "https://github.com/openhab/openhab-addons/pull/8819#discussion_r509437906", "createdAt": "2020-10-21T16:40:22Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.bluetooth.bluez/src/main/feature/feature.xml", "diffHunk": "@@ -4,7 +4,9 @@\n \n \t<feature name=\"openhab-binding-bluetooth-bluez\" description=\"Bluetooth Binding Bluez\" version=\"${project.version}\">\n \t\t<feature>openhab-runtime-base</feature>\n-\t\t<feature>openhab-transport-serial</feature>\n+\n+\t\t<bundle dependency=\"true\">mvn:com.github.hypfvieh/bluez-dbus-osgi/0.1.3</bundle>\n+\t\t<bundle dependency=\"true\">mvn:commons-beanutils/commons-beanutils/1.9.3</bundle>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1e67777e5ee588d82fccd47bbdbbaa8d1f12d39d"}, "originalPosition": 7}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE5MTI2MjcyOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.bluetooth.bluez/src/main/java/org/openhab/binding/bluetooth/bluez/internal/BlueZHandlerFactory.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQxNjo0MjoxOFrOHl1s-Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQxNjo0MjoxOFrOHl1s-Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTQzOTIyNQ==", "bodyText": "This should be kept as is.", "url": "https://github.com/openhab/openhab-addons/pull/8819#discussion_r509439225", "createdAt": "2020-10-21T16:42:18Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.bluetooth.bluez/src/main/java/org/openhab/binding/bluetooth/bluez/internal/BlueZHandlerFactory.java", "diffHunk": "@@ -30,33 +30,47 @@\n import org.openhab.core.thing.binding.ThingHandler;\n import org.openhab.core.thing.binding.ThingHandlerFactory;\n import org.osgi.framework.ServiceRegistration;\n+import org.osgi.service.component.annotations.Activate;\n import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Reference;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n \n /**\n  * The {@link BlueZHandlerFactory} is responsible for creating things and thing\n  * handlers.\n  *\n- * @author Kai Kreuzer - Initial contribution and API\n+ * @author Benjamin Lafois - Initial contribution and API", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1e67777e5ee588d82fccd47bbdbbaa8d1f12d39d"}, "originalPosition": 27}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE5MTI2NTE4OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.bluetooth.bluez/src/main/java/org/openhab/binding/bluetooth/bluez/internal/BlueZPropertiesChangedHandler.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQxNjo0Mjo1NVrOHl1uig==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQxNjo0Mjo1NVrOHl1uig==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTQzOTYyNg==", "bodyText": "remove blank line", "url": "https://github.com/openhab/openhab-addons/pull/8819#discussion_r509439626", "createdAt": "2020-10-21T16:42:55Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.bluetooth.bluez/src/main/java/org/openhab/binding/bluetooth/bluez/internal/BlueZPropertiesChangedHandler.java", "diffHunk": "@@ -0,0 +1,215 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bluetooth.bluez.internal;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.CopyOnWriteArraySet;\n+import java.util.concurrent.ScheduledExecutorService;\n+\n+import org.eclipse.jdt.annotation.NonNull;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.freedesktop.dbus.DBusMap;\n+import org.freedesktop.dbus.handlers.AbstractPropertiesChangedHandler;\n+import org.freedesktop.dbus.interfaces.Properties.PropertiesChanged;\n+import org.freedesktop.dbus.types.UInt16;\n+import org.freedesktop.dbus.types.Variant;\n+import org.openhab.binding.bluetooth.BluetoothAddress;\n+import org.openhab.binding.bluetooth.bluez.internal.events.AdapterDiscoveringChangedEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.AdapterPoweredChangedEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.BlueZEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.BlueZEventListener;\n+import org.openhab.binding.bluetooth.bluez.internal.events.CharacteristicUpdateEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.ConnectedEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.ManufacturerDataEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.NameEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.RssiEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.ServicesResolvedEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.TXPowerEvent;\n+import org.openhab.core.common.ThreadPoolManager;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ *\n+ *\n+ * @author Benjamin Lafois - Initial contribution and API\n+ *\n+ */\n+@NonNullByDefault\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1e67777e5ee588d82fccd47bbdbbaa8d1f12d39d"}, "originalPosition": 52}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE5MTI2ODQ0OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.bluetooth.bluez/src/main/java/org/openhab/binding/bluetooth/bluez/internal/DeviceManagerFactory.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQxNjo0Mzo0NlrOHl1wlA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQxNjo0Mzo0NlrOHl1wlA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTQ0MDE0OA==", "bodyText": "I forgot to remove this earlier.\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            @Component(service = DeviceManagerFactory.class, immediate = true)\n          \n          \n            \n            @Component(service = DeviceManagerFactory.class)", "url": "https://github.com/openhab/openhab-addons/pull/8819#discussion_r509440148", "createdAt": "2020-10-21T16:43:46Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.bluetooth.bluez/src/main/java/org/openhab/binding/bluetooth/bluez/internal/DeviceManagerFactory.java", "diffHunk": "@@ -0,0 +1,167 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bluetooth.bluez.internal;\n+\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledThreadPoolExecutor;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.freedesktop.dbus.exceptions.DBusException;\n+import org.openhab.core.common.NamedThreadFactory;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Deactivate;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.github.hypfvieh.bluetooth.DeviceManager;\n+\n+/**\n+ *\n+ * @author Connor Petty - Initial Contribution\n+ *\n+ */\n+@NonNullByDefault\n+@Component(service = DeviceManagerFactory.class, immediate = true)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1e67777e5ee588d82fccd47bbdbbaa8d1f12d39d"}, "originalPosition": 41}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE5MTQxMjAzOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/resources/OH-INF/thing/daikinmadoka.xml", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQxNzoxNTo0OVrOHl3LlA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQxNzo1Mzo0MlrOHl6H5g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTQ2MzQ0NA==", "bodyText": "This change shouldn't be part of this PR.", "url": "https://github.com/openhab/openhab-addons/pull/8819#discussion_r509463444", "createdAt": "2020-10-21T17:15:49Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/resources/OH-INF/thing/daikinmadoka.xml", "diffHunk": "@@ -6,14 +6,13 @@\n \n \t<thing-type id=\"brc1h\">\n \t\t<supported-bridge-type-refs>\n-\t\t\t<bridge-type-ref id=\"dbusbluez\"/>\n+\t\t\t<bridge-type-ref id=\"bluez\"/>\n \t\t</supported-bridge-type-refs>\n \n \t\t<label>Daikin BRC1H Thermostat</label>\n \t\t<description>A Daikin Madoka BRC1H Thermostat (BLE)</description>\n \n \t\t<channels>\n-\t\t\t<channel id=\"rssi\" typeId=\"rssi\"/>\n \t\t\t<channel id=\"onOffStatus\" typeId=\"brc1h_onOffStatus\"/>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1e67777e5ee588d82fccd47bbdbbaa8d1f12d39d"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTUxMTY1NA==", "bodyText": "Oops yes ! I submitted the PR yesterday but forgot to include it.", "url": "https://github.com/openhab/openhab-addons/pull/8819#discussion_r509511654", "createdAt": "2020-10-21T17:53:42Z", "author": {"login": "blafois"}, "path": "bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/resources/OH-INF/thing/daikinmadoka.xml", "diffHunk": "@@ -6,14 +6,13 @@\n \n \t<thing-type id=\"brc1h\">\n \t\t<supported-bridge-type-refs>\n-\t\t\t<bridge-type-ref id=\"dbusbluez\"/>\n+\t\t\t<bridge-type-ref id=\"bluez\"/>\n \t\t</supported-bridge-type-refs>\n \n \t\t<label>Daikin BRC1H Thermostat</label>\n \t\t<description>A Daikin Madoka BRC1H Thermostat (BLE)</description>\n \n \t\t<channels>\n-\t\t\t<channel id=\"rssi\" typeId=\"rssi\"/>\n \t\t\t<channel id=\"onOffStatus\" typeId=\"brc1h_onOffStatus\"/>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTQ2MzQ0NA=="}, "originalCommit": {"oid": "1e67777e5ee588d82fccd47bbdbbaa8d1f12d39d"}, "originalPosition": 13}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE5MTQxOTIyOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.bluetooth.bluez/src/main/java/org/openhab/binding/bluetooth/bluez/internal/BlueZAdapterConfiguration.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQxNzoxNzowOVrOHl3Qag==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQxNzoxNzowOVrOHl3Qag==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTQ2NDY4Mg==", "bodyText": "This shouldn't be changed", "url": "https://github.com/openhab/openhab-addons/pull/8819#discussion_r509464682", "createdAt": "2020-10-21T17:17:09Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.bluetooth.bluez/src/main/java/org/openhab/binding/bluetooth/bluez/internal/BlueZAdapterConfiguration.java", "diffHunk": "@@ -10,14 +10,14 @@\n  *\n  * SPDX-License-Identifier: EPL-2.0\n  */\n-package org.openhab.binding.bluetooth.bluez.handler;\n+package org.openhab.binding.bluetooth.bluez.internal;\n \n import org.openhab.binding.bluetooth.BaseBluetoothBridgeHandlerConfiguration;\n \n /**\n- * Configuration properties class.\n+ * Configuration properties for a bridge.\n  *\n- * @author Hilbrand Bouwkamp - Initial contribution\n+ * @author Benjamin Lafois - Initial contribution", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1e67777e5ee588d82fccd47bbdbbaa8d1f12d39d"}, "originalPosition": 14}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE5MTQyNzI3OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.bluetooth.bluez/src/main/java/org/openhab/binding/bluetooth/bluez/internal/BlueZBluetoothDevice.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQxNzoxODozMlrOHl3V7A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQxNzoxODozMlrOHl3V7A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTQ2NjA5Mg==", "bodyText": "This can be removed", "url": "https://github.com/openhab/openhab-addons/pull/8819#discussion_r509466092", "createdAt": "2020-10-21T17:18:32Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.bluetooth.bluez/src/main/java/org/openhab/binding/bluetooth/bluez/internal/BlueZBluetoothDevice.java", "diffHunk": "@@ -0,0 +1,501 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bluetooth.bluez.internal;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.UUID;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.bluez.exceptions.BluezFailedException;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.freedesktop.dbus.errors.NoReply;\n+import org.freedesktop.dbus.exceptions.DBusException;\n+import org.freedesktop.dbus.exceptions.DBusExecutionException;\n+import org.freedesktop.dbus.types.UInt16;\n+import org.openhab.binding.bluetooth.BaseBluetoothDevice;\n+import org.openhab.binding.bluetooth.BluetoothAddress;\n+import org.openhab.binding.bluetooth.BluetoothCharacteristic;\n+import org.openhab.binding.bluetooth.BluetoothCompletionStatus;\n+import org.openhab.binding.bluetooth.BluetoothDescriptor;\n+import org.openhab.binding.bluetooth.BluetoothService;\n+import org.openhab.binding.bluetooth.bluez.internal.events.BlueZEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.BlueZEventListener;\n+import org.openhab.binding.bluetooth.bluez.internal.events.CharacteristicUpdateEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.ConnectedEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.ManufacturerDataEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.NameEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.RssiEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.ServicesResolvedEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.TXPowerEvent;\n+import org.openhab.binding.bluetooth.notification.BluetoothConnectionStatusNotification;\n+import org.openhab.binding.bluetooth.notification.BluetoothScanNotification;\n+import org.openhab.core.common.ThreadPoolManager;\n+import org.openhab.core.util.HexUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.github.hypfvieh.bluetooth.wrapper.BluetoothDevice;\n+import com.github.hypfvieh.bluetooth.wrapper.BluetoothGattCharacteristic;\n+import com.github.hypfvieh.bluetooth.wrapper.BluetoothGattDescriptor;\n+import com.github.hypfvieh.bluetooth.wrapper.BluetoothGattService;\n+\n+/**\n+ * Implementation of BluetoothDevice for BlueZ via DBus-BlueZ API\n+ *\n+ *\n+ * @author Benjamin Lafois - Initial contribution and API\n+ *\n+ */\n+@NonNullByDefault\n+public class BlueZBluetoothDevice extends BaseBluetoothDevice implements BlueZEventListener {\n+\n+    private final Logger logger = LoggerFactory.getLogger(BlueZBluetoothDevice.class);\n+\n+    // Device from native lib\n+    private @Nullable BluetoothDevice device = null;\n+\n+    private final ScheduledExecutorService scheduler = ThreadPoolManager.getScheduledPool(\"bluetooth\");\n+\n+    protected final Map<UUID, BluetoothService> supportedServices = new HashMap<>();\n+\n+    /**\n+     * Constructor\n+     *\n+     * @param adapter the bridge handler through which this device is connected\n+     * @param address the Bluetooth address of the device\n+     * @param name the name of the device\n+     */\n+    public BlueZBluetoothDevice(BlueZBridgeHandler adapter, BluetoothAddress address) {\n+        super(adapter, address);\n+        logger.debug(\"Creating DBusBlueZ device with address '{}'\", address);\n+    }\n+\n+    public synchronized void updateBlueZDevice(@Nullable BluetoothDevice blueZDevice) {\n+        if (this.device != null && this.device == blueZDevice) {\n+            // logger.debug(\"Objects representing the BT device {} has not changed. Exiting function.\", address);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1e67777e5ee588d82fccd47bbdbbaa8d1f12d39d"}, "originalPosition": 89}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE5MTQyODQwOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.bluetooth.bluez/src/main/java/org/openhab/binding/bluetooth/bluez/internal/BlueZBluetoothDevice.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQxNzoxODo0OFrOHl3WtA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQxNzoxODo0OFrOHl3WtA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTQ2NjI5Mg==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                logger.error(\"error occured while trying to connect\", e);\n          \n          \n            \n                                logger.warn(\"error occured while trying to connect\", e);", "url": "https://github.com/openhab/openhab-addons/pull/8819#discussion_r509466292", "createdAt": "2020-10-21T17:18:48Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.bluetooth.bluez/src/main/java/org/openhab/binding/bluetooth/bluez/internal/BlueZBluetoothDevice.java", "diffHunk": "@@ -0,0 +1,501 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bluetooth.bluez.internal;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.UUID;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.bluez.exceptions.BluezFailedException;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.freedesktop.dbus.errors.NoReply;\n+import org.freedesktop.dbus.exceptions.DBusException;\n+import org.freedesktop.dbus.exceptions.DBusExecutionException;\n+import org.freedesktop.dbus.types.UInt16;\n+import org.openhab.binding.bluetooth.BaseBluetoothDevice;\n+import org.openhab.binding.bluetooth.BluetoothAddress;\n+import org.openhab.binding.bluetooth.BluetoothCharacteristic;\n+import org.openhab.binding.bluetooth.BluetoothCompletionStatus;\n+import org.openhab.binding.bluetooth.BluetoothDescriptor;\n+import org.openhab.binding.bluetooth.BluetoothService;\n+import org.openhab.binding.bluetooth.bluez.internal.events.BlueZEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.BlueZEventListener;\n+import org.openhab.binding.bluetooth.bluez.internal.events.CharacteristicUpdateEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.ConnectedEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.ManufacturerDataEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.NameEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.RssiEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.ServicesResolvedEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.TXPowerEvent;\n+import org.openhab.binding.bluetooth.notification.BluetoothConnectionStatusNotification;\n+import org.openhab.binding.bluetooth.notification.BluetoothScanNotification;\n+import org.openhab.core.common.ThreadPoolManager;\n+import org.openhab.core.util.HexUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.github.hypfvieh.bluetooth.wrapper.BluetoothDevice;\n+import com.github.hypfvieh.bluetooth.wrapper.BluetoothGattCharacteristic;\n+import com.github.hypfvieh.bluetooth.wrapper.BluetoothGattDescriptor;\n+import com.github.hypfvieh.bluetooth.wrapper.BluetoothGattService;\n+\n+/**\n+ * Implementation of BluetoothDevice for BlueZ via DBus-BlueZ API\n+ *\n+ *\n+ * @author Benjamin Lafois - Initial contribution and API\n+ *\n+ */\n+@NonNullByDefault\n+public class BlueZBluetoothDevice extends BaseBluetoothDevice implements BlueZEventListener {\n+\n+    private final Logger logger = LoggerFactory.getLogger(BlueZBluetoothDevice.class);\n+\n+    // Device from native lib\n+    private @Nullable BluetoothDevice device = null;\n+\n+    private final ScheduledExecutorService scheduler = ThreadPoolManager.getScheduledPool(\"bluetooth\");\n+\n+    protected final Map<UUID, BluetoothService> supportedServices = new HashMap<>();\n+\n+    /**\n+     * Constructor\n+     *\n+     * @param adapter the bridge handler through which this device is connected\n+     * @param address the Bluetooth address of the device\n+     * @param name the name of the device\n+     */\n+    public BlueZBluetoothDevice(BlueZBridgeHandler adapter, BluetoothAddress address) {\n+        super(adapter, address);\n+        logger.debug(\"Creating DBusBlueZ device with address '{}'\", address);\n+    }\n+\n+    public synchronized void updateBlueZDevice(@Nullable BluetoothDevice blueZDevice) {\n+        if (this.device != null && this.device == blueZDevice) {\n+            // logger.debug(\"Objects representing the BT device {} has not changed. Exiting function.\", address);\n+            return;\n+        }\n+        logger.debug(\"updateBlueZDevice({})\", blueZDevice);\n+\n+        this.device = blueZDevice;\n+\n+        if (blueZDevice == null) {\n+            return;\n+        }\n+\n+        Short rssi = blueZDevice.getRssi();\n+        if (rssi != null) {\n+            this.rssi = rssi.intValue();\n+        }\n+        this.name = blueZDevice.getName();\n+        Map<UInt16, byte[]> manData = blueZDevice.getManufacturerData();\n+        if (manData != null) {\n+            manData.entrySet().stream().map(Map.Entry::getKey).filter(Objects::nonNull).findFirst()\n+                    .ifPresent((UInt16 manufacturerId) ->\n+                    // Convert to unsigned int to match the convention in BluetoothCompanyIdentifiers\n+                    this.manufacturer = manufacturerId.intValue() & 0xFFFF);\n+        }\n+\n+        if (Boolean.TRUE.equals(blueZDevice.isConnected())) {\n+            setConnectionState(ConnectionState.CONNECTED);\n+        }\n+\n+        discoverServices();\n+    }\n+\n+    /**\n+     * Clean up and release memory.\n+     */\n+    @Override\n+    public void dispose() {\n+        BluetoothDevice dev = device;\n+        if (dev != null) {\n+            try {\n+                dev.getAdapter().removeDevice(dev.getRawDevice());\n+            } catch (DBusException ex) {\n+                if (ex.getMessage().contains(\"Does Not Exist\")) {\n+                    // this happens when the underlying device has already been removed\n+                    // but we don't have a way to check if that is the case beforehand so\n+                    // we will just eat the error here.\n+                } else {\n+                    logger.debug(\"Exception occurred when trying to remove inactive device '{}': {}\", address,\n+                            ex.getMessage());\n+                }\n+            } catch (RuntimeException ex) {\n+                // try to catch any other exceptions\n+                logger.debug(\"Exception occurred when trying to remove inactive device '{}': {}\", address,\n+                        ex.getMessage());\n+            }\n+        }\n+    }\n+\n+    private void setConnectionState(ConnectionState state) {\n+        if (this.connectionState != state) {\n+            this.connectionState = state;\n+            notifyListeners(BluetoothEventType.CONNECTION_STATE, new BluetoothConnectionStatusNotification(state));\n+        }\n+    }\n+\n+    @Override\n+    public boolean connect() {\n+        logger.debug(\"Connect({})\", device);\n+\n+        BluetoothDevice dev = device;\n+        if (dev != null) {\n+            if (Boolean.FALSE.equals(dev.isConnected())) {\n+                try {\n+                    boolean ret = dev.connect();\n+                    logger.debug(\"Connect result: {}\", ret);\n+                    return ret;\n+                } catch (NoReply e) {\n+                    // Have to double check because sometimes, exception but still worked\n+                    logger.debug(\"Got a timeout - but sometimes happen. Is Connected ? {}\", dev.isConnected());\n+                    if (Boolean.FALSE.equals(dev.isConnected())) {\n+\n+                        notifyListeners(BluetoothEventType.CONNECTION_STATE,\n+                                new BluetoothConnectionStatusNotification(ConnectionState.DISCONNECTED));\n+                        return false;\n+                    } else {\n+                        return true;\n+                    }\n+                } catch (DBusExecutionException e) {\n+                    // Catch \"software caused connection abort\"\n+                    return false;\n+                } catch (Exception e) {\n+                    logger.error(\"error occured while trying to connect\", e);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1e67777e5ee588d82fccd47bbdbbaa8d1f12d39d"}, "originalPosition": 179}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE5MTQzMzEwOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.bluetooth.bluez/src/main/java/org/openhab/binding/bluetooth/bluez/internal/BlueZBridgeHandler.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQxNzoxOTozN1rOHl3Z3w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQxNzoxOTozN1rOHl3Z3w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTQ2NzEwMw==", "bodyText": "This can be removed", "url": "https://github.com/openhab/openhab-addons/pull/8819#discussion_r509467103", "createdAt": "2020-10-21T17:19:37Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.bluetooth.bluez/src/main/java/org/openhab/binding/bluetooth/bluez/internal/BlueZBridgeHandler.java", "diffHunk": "@@ -0,0 +1,266 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bluetooth.bluez.internal;\n+\n+import java.util.List;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNull;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.bluetooth.AbstractBluetoothBridgeHandler;\n+import org.openhab.binding.bluetooth.BluetoothAddress;\n+import org.openhab.binding.bluetooth.bluez.internal.events.AdapterDiscoveringChangedEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.AdapterPoweredChangedEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.BlueZEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.BlueZEventListener;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.github.hypfvieh.bluetooth.DeviceManager;\n+import com.github.hypfvieh.bluetooth.wrapper.BluetoothAdapter;\n+import com.github.hypfvieh.bluetooth.wrapper.BluetoothDevice;\n+\n+/**\n+ * The {@link BlueZBridgeHandler} is responsible for talking to the BlueZ stack, using DBus Unix Socket.\n+ * This Binding does not use any JNI.\n+ * It provides a private interface for {@link BlueZBluetoothDevice}s to access the stack and provides top\n+ * level adaptor functionality for scanning and arbitration.\n+ *\n+ * @author Benjamin Lafois - Initial contribution and API\n+ */\n+@NonNullByDefault\n+public class BlueZBridgeHandler extends AbstractBluetoothBridgeHandler<BlueZBluetoothDevice>\n+        implements BlueZEventListener {\n+\n+    private final Logger logger = LoggerFactory.getLogger(BlueZBridgeHandler.class);\n+\n+    // ADAPTER from BlueZ-DBus Library\n+    private @Nullable BluetoothAdapter adapter;\n+\n+    // Our BT address\n+    private @Nullable BluetoothAddress adapterAddress;\n+\n+    // private final ReentrantLock lockDiscoveryJob = new ReentrantLock();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1e67777e5ee588d82fccd47bbdbbaa8d1f12d39d"}, "originalPosition": 59}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE5MTQzNTg3OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.bluetooth.bluez/src/main/java/org/openhab/binding/bluetooth/bluez/internal/BlueZBridgeHandler.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQxNzoyMDowN1rOHl3b1Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQxNzoyMDowN1rOHl3b1Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTQ2NzYwNQ==", "bodyText": "This can be removed", "url": "https://github.com/openhab/openhab-addons/pull/8819#discussion_r509467605", "createdAt": "2020-10-21T17:20:07Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.bluetooth.bluez/src/main/java/org/openhab/binding/bluetooth/bluez/internal/BlueZBridgeHandler.java", "diffHunk": "@@ -0,0 +1,266 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bluetooth.bluez.internal;\n+\n+import java.util.List;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNull;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.bluetooth.AbstractBluetoothBridgeHandler;\n+import org.openhab.binding.bluetooth.BluetoothAddress;\n+import org.openhab.binding.bluetooth.bluez.internal.events.AdapterDiscoveringChangedEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.AdapterPoweredChangedEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.BlueZEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.BlueZEventListener;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.github.hypfvieh.bluetooth.DeviceManager;\n+import com.github.hypfvieh.bluetooth.wrapper.BluetoothAdapter;\n+import com.github.hypfvieh.bluetooth.wrapper.BluetoothDevice;\n+\n+/**\n+ * The {@link BlueZBridgeHandler} is responsible for talking to the BlueZ stack, using DBus Unix Socket.\n+ * This Binding does not use any JNI.\n+ * It provides a private interface for {@link BlueZBluetoothDevice}s to access the stack and provides top\n+ * level adaptor functionality for scanning and arbitration.\n+ *\n+ * @author Benjamin Lafois - Initial contribution and API\n+ */\n+@NonNullByDefault\n+public class BlueZBridgeHandler extends AbstractBluetoothBridgeHandler<BlueZBluetoothDevice>\n+        implements BlueZEventListener {\n+\n+    private final Logger logger = LoggerFactory.getLogger(BlueZBridgeHandler.class);\n+\n+    // ADAPTER from BlueZ-DBus Library\n+    private @Nullable BluetoothAdapter adapter;\n+\n+    // Our BT address\n+    private @Nullable BluetoothAddress adapterAddress;\n+\n+    // private final ReentrantLock lockDiscoveryJob = new ReentrantLock();\n+\n+    private @Nullable ScheduledFuture<?> discoveryJob;\n+\n+    private final DeviceManagerFactory deviceManagerFactory;\n+\n+    /**\n+     * Constructor\n+     *\n+     * @param bridge the bridge definition for this handler\n+     */\n+    public BlueZBridgeHandler(Bridge bridge, DeviceManagerFactory deviceManagerFactory) {\n+        super(bridge);\n+        this.deviceManagerFactory = deviceManagerFactory;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        super.initialize();\n+\n+        // Load configuration\n+        final BlueZAdapterConfiguration configuration = getConfigAs(BlueZAdapterConfiguration.class);\n+        if (configuration.address != null) {\n+            this.adapterAddress = new BluetoothAddress(configuration.address.toUpperCase());\n+        } else {\n+            // If configuration does not contain adapter address to use, exit with error.\n+            logger.info(\"Adapter MAC address not provided\");\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"address not set\");\n+            return;\n+        }\n+\n+        logger.debug(\"Creating BlueZ adapter with address '{}'\", adapterAddress);\n+\n+        updateStatus(ThingStatus.UNKNOWN, ThingStatusDetail.CONFIGURATION_PENDING, \"Initializing\");\n+\n+        deviceManagerFactory.getPropertiesChangedHandler().addListener(this);\n+\n+        discoveryJob = scheduler.scheduleWithFixedDelay(this::initializeAndRefreshDevices, 5, 10, TimeUnit.SECONDS);\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        deviceManagerFactory.getPropertiesChangedHandler().removeListener(this);\n+        logger.debug(\"Termination of DBus BlueZ handler\");\n+\n+        Future<?> job = discoveryJob;\n+        if (job != null) {\n+            job.cancel(false);\n+            discoveryJob = null;\n+        }\n+\n+        if (this.adapter != null) {\n+            ((@NonNull BluetoothAdapter) this.adapter).stopDiscovery();\n+            this.adapter = null;\n+        }\n+\n+        super.dispose();\n+    }\n+\n+    private static @Nullable BluetoothAdapter findAdapter(DeviceManager deviceManager, String address) {\n+        List<BluetoothAdapter> adapters = deviceManager.getAdapters();\n+        if (adapters != null) {\n+            for (BluetoothAdapter btAdapter : adapters) {\n+                if (btAdapter.getAddress() != null && btAdapter.getAddress().equalsIgnoreCase(address)) {\n+                    return btAdapter;\n+                }\n+            }\n+        }\n+        return null;\n+    }\n+\n+    private boolean validateAdapter(DeviceManager deviceManager) {\n+\n+        // next lets check if we can find our adapter in the manager.\n+        BluetoothAdapter localAdapter = adapter;\n+        if (localAdapter == null) {\n+            if (adapterAddress != null) {\n+                localAdapter = adapter = findAdapter(deviceManager,\n+                        ((@NonNull BluetoothAddress) adapterAddress).toString());\n+            } else {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"No adapter address provided\");\n+                return false;\n+            }\n+        }\n+        if (localAdapter == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                    \"Native adapter could not be found for address '\" + adapterAddress + \"'\");\n+            return false;\n+        }\n+        // now lets confirm that the adapter is powered\n+        if (!localAdapter.isPowered()) {\n+            localAdapter.setPowered(true);\n+            // give the device some time to power on\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.DUTY_CYCLE,\n+                    \"Adapter is not powered, attempting to turn on...\");\n+            return false;\n+        }\n+\n+        // now lets make sure that discovery is turned on\n+        if (!Boolean.TRUE.equals(localAdapter.isDiscovering())) {\n+            // we will check for devices next time around\n+            localAdapter.startDiscovery();\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.DUTY_CYCLE, \"Starting discovery\");\n+            return false;\n+        }\n+        return true;\n+    }\n+\n+    private void initializeAndRefreshDevices() {\n+        logger.debug(\"initializeAndRefreshDevice()\");\n+\n+        try {\n+            // first check if the device manager is ready\n+            DeviceManager deviceManager = deviceManagerFactory.getDeviceManager();\n+            if (deviceManager == null) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        \"Bluez DeviceManager not available yet.\");\n+                return;\n+            }\n+\n+            if (!validateAdapter(deviceManager)) {\n+                return;\n+            }\n+\n+            // as we have already validated the adapteraddress in {@link #validateAdapter(DeviceAdapter)}, we can safely\n+            // assume that adapterAddress is not null.\n+            @NonNull\n+            BluetoothAddress adapterAddress = (@NonNull BluetoothAddress) this.adapterAddress;\n+\n+            // now lets refresh devices\n+            List<BluetoothDevice> bluezDevices = deviceManager.getDevices(adapterAddress.toString(), true);\n+            logger.debug(\"Found {} Bluetooth devices.\", bluezDevices.size());\n+            for (BluetoothDevice bluezDevice : bluezDevices) {\n+                // logger.debug(\"discovered device {}\", bluezDevice);\n+                if (bluezDevice.getAddress() == null) {\n+                    // For some reasons, sometimes the address is null..\n+                    continue;\n+                }\n+                BlueZBluetoothDevice device = getDevice(new BluetoothAddress(bluezDevice.getAddress()));\n+                device.updateBlueZDevice(bluezDevice);\n+                deviceDiscovered(device);\n+            }\n+            updateStatus(ThingStatus.ONLINE);\n+        } catch (Exception ex) {\n+            // don't know what kind of exception the bluez library might throw at us so lets catch them here so our\n+            // scheduler loop doesn't get terminated\n+            logger.warn(\"Unknown exception\", ex);\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, ex.getMessage());\n+        }\n+    }\n+\n+    @Override\n+    public @Nullable BluetoothAddress getAddress() {\n+        return adapterAddress;\n+    }\n+\n+    @Override\n+    protected BlueZBluetoothDevice createDevice(BluetoothAddress address) {\n+        logger.debug(\"createDevice {}\", address);\n+        BlueZBluetoothDevice device = new BlueZBluetoothDevice(this, address);\n+        return device;\n+    }\n+\n+    @Override\n+    public void onDBusBlueZEvent(BlueZEvent event) {\n+\n+        BluetoothAdapter localAdapter = this.adapter;\n+        String adapterName = event.getAdapterName();\n+        if (adapterName == null || localAdapter == null) {\n+            // We cannot be sure that this event concerns this adapter.. So ignore message\n+            return;\n+        }\n+        String localName = localAdapter.getDeviceName();\n+\n+        // logger.debug(\"Received event {}. Adapter={}. AdapterBridge={}\", event.getClass().getSimpleName(),\n+        // adapterName,\n+        // localName);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1e67777e5ee588d82fccd47bbdbbaa8d1f12d39d"}, "originalPosition": 235}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE5MTk2MTU4OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.bluetooth.bluez/README.md", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQxODozMzoxOVrOHl9D-w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQxODo0NDowMVrOHl9qMw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTU1OTgwMw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            Bridge bluetooth:bluez:hci0 [ address=\"12:34:56:78:90:AB\" ]\n          \n          \n            \n            Bridge bluetooth:bluez:hci0 [ address=\"12:34:56:78:90:AB\", backgroundDiscovery=false ]", "url": "https://github.com/openhab/openhab-addons/pull/8819#discussion_r509559803", "createdAt": "2020-10-21T18:33:19Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.bluetooth.bluez/README.md", "diffHunk": "@@ -44,20 +44,27 @@ It defines the following bridge type:\n |----------------|---------------------------------------------------------------------------|\n | bluez          | A Bluetooth adapter that is supported by BlueZ                            |\n \n-\n ## Discovery\n \n If BlueZ is enabled and can be accessed, all available adapters are automatically discovered.\n \n+\n ## Bridge Configuration\n \n The bluez bridge requires the configuration parameter `address`, which corresponds to the Bluetooth address of the adapter (in format \"XX:XX:XX:XX:XX:XX\").\n+\n Additionally, the parameter `backgroundDiscovery` can be set to true/false.When set to true, any Bluetooth device of which broadcasts are received is added to the Inbox.\n \n ## Example\n \n This is how an BlueZ adapter can be configured textually in a *.things file:\n \n ```\n-Bridge bluetooth:bluez:hci0 [ address=\"12:34:56:78:90:AB\", backgroundDiscovery=false ]\n+Bridge bluetooth:bluez:hci0 [ address=\"12:34:56:78:90:AB\" ]", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bb659f9e334d1a8366b4b9623d2afb54ea3c24ba"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTU2OTU4Nw==", "bodyText": "backgroundDiscovery is actually supported through the AbstractBluetoothBridgeHandler", "url": "https://github.com/openhab/openhab-addons/pull/8819#discussion_r509569587", "createdAt": "2020-10-21T18:44:01Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.bluetooth.bluez/README.md", "diffHunk": "@@ -44,20 +44,27 @@ It defines the following bridge type:\n |----------------|---------------------------------------------------------------------------|\n | bluez          | A Bluetooth adapter that is supported by BlueZ                            |\n \n-\n ## Discovery\n \n If BlueZ is enabled and can be accessed, all available adapters are automatically discovered.\n \n+\n ## Bridge Configuration\n \n The bluez bridge requires the configuration parameter `address`, which corresponds to the Bluetooth address of the adapter (in format \"XX:XX:XX:XX:XX:XX\").\n+\n Additionally, the parameter `backgroundDiscovery` can be set to true/false.When set to true, any Bluetooth device of which broadcasts are received is added to the Inbox.\n \n ## Example\n \n This is how an BlueZ adapter can be configured textually in a *.things file:\n \n ```\n-Bridge bluetooth:bluez:hci0 [ address=\"12:34:56:78:90:AB\", backgroundDiscovery=false ]\n+Bridge bluetooth:bluez:hci0 [ address=\"12:34:56:78:90:AB\" ]", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTU1OTgwMw=="}, "originalCommit": {"oid": "bb659f9e334d1a8366b4b9623d2afb54ea3c24ba"}, "originalPosition": 30}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE5MTk2MzYzOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.bluetooth.bluez/src/main/java/org/openhab/binding/bluetooth/bluez/internal/BlueZAdapterConstants.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQxODozMzo1NFrOHl9FXQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQxODozMzo1NFrOHl9FXQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTU2MDE1Nw==", "bodyText": "This shouldn't be changed", "url": "https://github.com/openhab/openhab-addons/pull/8819#discussion_r509560157", "createdAt": "2020-10-21T18:33:54Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.bluetooth.bluez/src/main/java/org/openhab/binding/bluetooth/bluez/internal/BlueZAdapterConstants.java", "diffHunk": "@@ -20,7 +20,7 @@\n  * The {@link BlueZAdapterConstants} class defines common constants, which are\n  * used across the whole binding.\n  *\n- * @author Kai Kreuzer - Initial contribution and API\n+ * @author Benjamin Lafois - Initial contribution and API", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bb659f9e334d1a8366b4b9623d2afb54ea3c24ba"}, "originalPosition": 14}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE5MTk3Mjg4OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.bluetooth.bluez/src/main/java/org/openhab/binding/bluetooth/bluez/internal/BlueZBluetoothDevice.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQxODozNToyNlrOHl9L0A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQxODozNToyNlrOHl9L0A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTU2MTgwOA==", "bodyText": "This should already be inherited from the BaseBluetoothDevice, so remove this field.", "url": "https://github.com/openhab/openhab-addons/pull/8819#discussion_r509561808", "createdAt": "2020-10-21T18:35:26Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.bluetooth.bluez/src/main/java/org/openhab/binding/bluetooth/bluez/internal/BlueZBluetoothDevice.java", "diffHunk": "@@ -0,0 +1,500 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bluetooth.bluez.internal;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.UUID;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.bluez.exceptions.BluezFailedException;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.freedesktop.dbus.errors.NoReply;\n+import org.freedesktop.dbus.exceptions.DBusException;\n+import org.freedesktop.dbus.exceptions.DBusExecutionException;\n+import org.freedesktop.dbus.types.UInt16;\n+import org.openhab.binding.bluetooth.BaseBluetoothDevice;\n+import org.openhab.binding.bluetooth.BluetoothAddress;\n+import org.openhab.binding.bluetooth.BluetoothCharacteristic;\n+import org.openhab.binding.bluetooth.BluetoothCompletionStatus;\n+import org.openhab.binding.bluetooth.BluetoothDescriptor;\n+import org.openhab.binding.bluetooth.BluetoothService;\n+import org.openhab.binding.bluetooth.bluez.internal.events.BlueZEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.BlueZEventListener;\n+import org.openhab.binding.bluetooth.bluez.internal.events.CharacteristicUpdateEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.ConnectedEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.ManufacturerDataEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.NameEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.RssiEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.ServicesResolvedEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.TXPowerEvent;\n+import org.openhab.binding.bluetooth.notification.BluetoothConnectionStatusNotification;\n+import org.openhab.binding.bluetooth.notification.BluetoothScanNotification;\n+import org.openhab.core.common.ThreadPoolManager;\n+import org.openhab.core.util.HexUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.github.hypfvieh.bluetooth.wrapper.BluetoothDevice;\n+import com.github.hypfvieh.bluetooth.wrapper.BluetoothGattCharacteristic;\n+import com.github.hypfvieh.bluetooth.wrapper.BluetoothGattDescriptor;\n+import com.github.hypfvieh.bluetooth.wrapper.BluetoothGattService;\n+\n+/**\n+ * Implementation of BluetoothDevice for BlueZ via DBus-BlueZ API\n+ *\n+ *\n+ * @author Benjamin Lafois - Initial contribution and API\n+ *\n+ */\n+@NonNullByDefault\n+public class BlueZBluetoothDevice extends BaseBluetoothDevice implements BlueZEventListener {\n+\n+    private final Logger logger = LoggerFactory.getLogger(BlueZBluetoothDevice.class);\n+\n+    // Device from native lib\n+    private @Nullable BluetoothDevice device = null;\n+\n+    private final ScheduledExecutorService scheduler = ThreadPoolManager.getScheduledPool(\"bluetooth\");\n+\n+    protected final Map<UUID, BluetoothService> supportedServices = new HashMap<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bb659f9e334d1a8366b4b9623d2afb54ea3c24ba"}, "originalPosition": 73}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE5MTk4NDA5OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.bluetooth.bluez/src/main/java/org/openhab/binding/bluetooth/bluez/internal/BlueZBluetoothDevice.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQxODozNzozNlrOHl9TbA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQxODozNzozNlrOHl9TbA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTU2Mzc1Ng==", "bodyText": "We should keep the authoring tags.\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             *\n          \n          \n            \n             * @author Benjamin Lafois - Initial contribution and API\n          \n          \n            \n             * @author Kai Kreuzer - Initial contribution and API\n          \n          \n            \n             * @author Benjamin Lafois - Reimplemented using Dbus instead of tinyB", "url": "https://github.com/openhab/openhab-addons/pull/8819#discussion_r509563756", "createdAt": "2020-10-21T18:37:36Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.bluetooth.bluez/src/main/java/org/openhab/binding/bluetooth/bluez/internal/BlueZBluetoothDevice.java", "diffHunk": "@@ -0,0 +1,500 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bluetooth.bluez.internal;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.UUID;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.bluez.exceptions.BluezFailedException;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.freedesktop.dbus.errors.NoReply;\n+import org.freedesktop.dbus.exceptions.DBusException;\n+import org.freedesktop.dbus.exceptions.DBusExecutionException;\n+import org.freedesktop.dbus.types.UInt16;\n+import org.openhab.binding.bluetooth.BaseBluetoothDevice;\n+import org.openhab.binding.bluetooth.BluetoothAddress;\n+import org.openhab.binding.bluetooth.BluetoothCharacteristic;\n+import org.openhab.binding.bluetooth.BluetoothCompletionStatus;\n+import org.openhab.binding.bluetooth.BluetoothDescriptor;\n+import org.openhab.binding.bluetooth.BluetoothService;\n+import org.openhab.binding.bluetooth.bluez.internal.events.BlueZEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.BlueZEventListener;\n+import org.openhab.binding.bluetooth.bluez.internal.events.CharacteristicUpdateEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.ConnectedEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.ManufacturerDataEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.NameEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.RssiEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.ServicesResolvedEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.TXPowerEvent;\n+import org.openhab.binding.bluetooth.notification.BluetoothConnectionStatusNotification;\n+import org.openhab.binding.bluetooth.notification.BluetoothScanNotification;\n+import org.openhab.core.common.ThreadPoolManager;\n+import org.openhab.core.util.HexUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.github.hypfvieh.bluetooth.wrapper.BluetoothDevice;\n+import com.github.hypfvieh.bluetooth.wrapper.BluetoothGattCharacteristic;\n+import com.github.hypfvieh.bluetooth.wrapper.BluetoothGattDescriptor;\n+import com.github.hypfvieh.bluetooth.wrapper.BluetoothGattService;\n+\n+/**\n+ * Implementation of BluetoothDevice for BlueZ via DBus-BlueZ API\n+ *\n+ *\n+ * @author Benjamin Lafois - Initial contribution and API", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bb659f9e334d1a8366b4b9623d2afb54ea3c24ba"}, "originalPosition": 60}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE5MTk5MTgzOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.bluetooth.bluez/src/main/java/org/openhab/binding/bluetooth/bluez/internal/BlueZBridgeHandler.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQxODozOTowM1rOHl9YlQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQxODozOTowM1rOHl9YlQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTU2NTA3Nw==", "bodyText": "Are these null annotations required?", "url": "https://github.com/openhab/openhab-addons/pull/8819#discussion_r509565077", "createdAt": "2020-10-21T18:39:03Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.bluetooth.bluez/src/main/java/org/openhab/binding/bluetooth/bluez/internal/BlueZBridgeHandler.java", "diffHunk": "@@ -0,0 +1,261 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bluetooth.bluez.internal;\n+\n+import java.util.List;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNull;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.bluetooth.AbstractBluetoothBridgeHandler;\n+import org.openhab.binding.bluetooth.BluetoothAddress;\n+import org.openhab.binding.bluetooth.bluez.internal.events.AdapterDiscoveringChangedEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.AdapterPoweredChangedEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.BlueZEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.BlueZEventListener;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.github.hypfvieh.bluetooth.DeviceManager;\n+import com.github.hypfvieh.bluetooth.wrapper.BluetoothAdapter;\n+import com.github.hypfvieh.bluetooth.wrapper.BluetoothDevice;\n+\n+/**\n+ * The {@link BlueZBridgeHandler} is responsible for talking to the BlueZ stack, using DBus Unix Socket.\n+ * This Binding does not use any JNI.\n+ * It provides a private interface for {@link BlueZBluetoothDevice}s to access the stack and provides top\n+ * level adaptor functionality for scanning and arbitration.\n+ *\n+ * @author Benjamin Lafois - Initial contribution and API\n+ */\n+@NonNullByDefault\n+public class BlueZBridgeHandler extends AbstractBluetoothBridgeHandler<BlueZBluetoothDevice>\n+        implements BlueZEventListener {\n+\n+    private final Logger logger = LoggerFactory.getLogger(BlueZBridgeHandler.class);\n+\n+    // ADAPTER from BlueZ-DBus Library\n+    private @Nullable BluetoothAdapter adapter;\n+\n+    // Our BT address\n+    private @Nullable BluetoothAddress adapterAddress;\n+\n+    private @Nullable ScheduledFuture<?> discoveryJob;\n+\n+    private final DeviceManagerFactory deviceManagerFactory;\n+\n+    /**\n+     * Constructor\n+     *\n+     * @param bridge the bridge definition for this handler\n+     */\n+    public BlueZBridgeHandler(Bridge bridge, DeviceManagerFactory deviceManagerFactory) {\n+        super(bridge);\n+        this.deviceManagerFactory = deviceManagerFactory;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        super.initialize();\n+\n+        // Load configuration\n+        final BlueZAdapterConfiguration configuration = getConfigAs(BlueZAdapterConfiguration.class);\n+        if (configuration.address != null) {\n+            this.adapterAddress = new BluetoothAddress(configuration.address.toUpperCase());\n+        } else {\n+            // If configuration does not contain adapter address to use, exit with error.\n+            logger.info(\"Adapter MAC address not provided\");\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"address not set\");\n+            return;\n+        }\n+\n+        logger.debug(\"Creating BlueZ adapter with address '{}'\", adapterAddress);\n+\n+        updateStatus(ThingStatus.UNKNOWN, ThingStatusDetail.CONFIGURATION_PENDING, \"Initializing\");\n+\n+        deviceManagerFactory.getPropertiesChangedHandler().addListener(this);\n+\n+        discoveryJob = scheduler.scheduleWithFixedDelay(this::initializeAndRefreshDevices, 5, 10, TimeUnit.SECONDS);\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        deviceManagerFactory.getPropertiesChangedHandler().removeListener(this);\n+        logger.debug(\"Termination of DBus BlueZ handler\");\n+\n+        Future<?> job = discoveryJob;\n+        if (job != null) {\n+            job.cancel(false);\n+            discoveryJob = null;\n+        }\n+\n+        if (this.adapter != null) {\n+            ((@NonNull BluetoothAdapter) this.adapter).stopDiscovery();\n+            this.adapter = null;\n+        }\n+\n+        super.dispose();\n+    }\n+\n+    private static @Nullable BluetoothAdapter findAdapter(DeviceManager deviceManager, String address) {\n+        List<BluetoothAdapter> adapters = deviceManager.getAdapters();\n+        if (adapters != null) {\n+            for (BluetoothAdapter btAdapter : adapters) {\n+                if (btAdapter.getAddress() != null && btAdapter.getAddress().equalsIgnoreCase(address)) {\n+                    return btAdapter;\n+                }\n+            }\n+        }\n+        return null;\n+    }\n+\n+    private boolean validateAdapter(DeviceManager deviceManager) {\n+\n+        // next lets check if we can find our adapter in the manager.\n+        BluetoothAdapter localAdapter = adapter;\n+        if (localAdapter == null) {\n+            if (adapterAddress != null) {\n+                localAdapter = adapter = findAdapter(deviceManager,\n+                        ((@NonNull BluetoothAddress) adapterAddress).toString());\n+            } else {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"No adapter address provided\");\n+                return false;\n+            }\n+        }\n+        if (localAdapter == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                    \"Native adapter could not be found for address '\" + adapterAddress + \"'\");\n+            return false;\n+        }\n+        // now lets confirm that the adapter is powered\n+        if (!localAdapter.isPowered()) {\n+            localAdapter.setPowered(true);\n+            // give the device some time to power on\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.DUTY_CYCLE,\n+                    \"Adapter is not powered, attempting to turn on...\");\n+            return false;\n+        }\n+\n+        // now lets make sure that discovery is turned on\n+        if (!Boolean.TRUE.equals(localAdapter.isDiscovering())) {\n+            // we will check for devices next time around\n+            localAdapter.startDiscovery();\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.DUTY_CYCLE, \"Starting discovery\");\n+            return false;\n+        }\n+        return true;\n+    }\n+\n+    private void initializeAndRefreshDevices() {\n+        logger.debug(\"initializeAndRefreshDevice()\");\n+\n+        try {\n+            // first check if the device manager is ready\n+            DeviceManager deviceManager = deviceManagerFactory.getDeviceManager();\n+            if (deviceManager == null) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        \"Bluez DeviceManager not available yet.\");\n+                return;\n+            }\n+\n+            if (!validateAdapter(deviceManager)) {\n+                return;\n+            }\n+\n+            // as we have already validated the adapteraddress in {@link #validateAdapter(DeviceAdapter)}, we can safely\n+            // assume that adapterAddress is not null.\n+            @NonNull\n+            BluetoothAddress adapterAddress = (@NonNull BluetoothAddress) this.adapterAddress;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bb659f9e334d1a8366b4b9623d2afb54ea3c24ba"}, "originalPosition": 184}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE5NDMwNzQyOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.bluetooth.bluez/pom.xml", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMlQwNzoyOTozNVrOHmULpA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QyMTo0MDo1MVrOHnfMaQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTkzODU5Ng==", "bodyText": "Is this used by any other bundle or available from a core-bom? Otherwise change scope to compile and remove it from the feature.", "url": "https://github.com/openhab/openhab-addons/pull/8819#discussion_r509938596", "createdAt": "2020-10-22T07:29:35Z", "author": {"login": "J-N-K"}, "path": "bundles/org.openhab.binding.bluetooth.bluez/pom.xml", "diffHunk": "@@ -15,18 +15,21 @@\n   <name>openHAB Add-ons :: Bundles :: BlueZ Bluetooth Adapter</name>\n \n   <dependencies>\n+\n     <dependency>\n       <groupId>org.openhab.addons.bundles</groupId>\n       <artifactId>org.openhab.binding.bluetooth</artifactId>\n       <version>${project.version}</version>\n       <scope>provided</scope>\n     </dependency>\n+\n     <dependency>\n-      <groupId>org.openhab.osgiify</groupId>\n-      <artifactId>intel-iot-devkit.tinyb</artifactId>\n-      <version>0.5.1</version>\n-      <scope>compile</scope>\n+      <groupId>com.github.hypfvieh</groupId>\n+      <artifactId>bluez-dbus-osgi</artifactId>\n+      <version>0.1.3</version>\n+      <scope>provided</scope>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "00d70430420d1037e3a206a0b1c83549f7d151b5"}, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDEwOTEzMQ==", "bodyText": "No, this will only be used by this add-on here.", "url": "https://github.com/openhab/openhab-addons/pull/8819#discussion_r510109131", "createdAt": "2020-10-22T12:11:06Z", "author": {"login": "kaikreuzer"}, "path": "bundles/org.openhab.binding.bluetooth.bluez/pom.xml", "diffHunk": "@@ -15,18 +15,21 @@\n   <name>openHAB Add-ons :: Bundles :: BlueZ Bluetooth Adapter</name>\n \n   <dependencies>\n+\n     <dependency>\n       <groupId>org.openhab.addons.bundles</groupId>\n       <artifactId>org.openhab.binding.bluetooth</artifactId>\n       <version>${project.version}</version>\n       <scope>provided</scope>\n     </dependency>\n+\n     <dependency>\n-      <groupId>org.openhab.osgiify</groupId>\n-      <artifactId>intel-iot-devkit.tinyb</artifactId>\n-      <version>0.5.1</version>\n-      <scope>compile</scope>\n+      <groupId>com.github.hypfvieh</groupId>\n+      <artifactId>bluez-dbus-osgi</artifactId>\n+      <version>0.1.3</version>\n+      <scope>provided</scope>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTkzODU5Ng=="}, "originalCommit": {"oid": "00d70430420d1037e3a206a0b1c83549f7d151b5"}, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDI5NjA3Mg==", "bodyText": "I switched it over to use compile and removed it from both the feature.xml and the footer.xml. But then I get this build error:\nFeature resolution failed for [openhab-binding-bluetooth-bluez/3.0.0.SNAPSHOT]\n[ERROR] Message: Unable to resolve root: missing requirement [root] osgi.identity; osgi.identity=openhab-binding-bluetooth-bluez; type=karaf.feature; version=3.0.0.SNAPSHOT; filter:=\"(&(osgi.identity=openhab-binding-bluetooth-bluez)(type=karaf.feature)(version>=3.0.0.SNAPSHOT))\" [caused by: Unable to resolve openhab-binding-bluetooth-bluez/3.0.0.SNAPSHOT: missing requirement [openhab-binding-bluetooth-bluez/3.0.0.SNAPSHOT] osgi.identity; osgi.identity=org.openhab.binding.bluetooth.bluez; type=osgi.bundle; version=\"[3.0.0.202010221615,3.0.0.202010221615]\"; resolution:=mandatory [caused by: Unable to resolve org.openhab.binding.bluetooth.bluez/3.0.0.202010221615: missing requirement [org.openhab.binding.bluetooth.bluez/3.0.0.202010221615] osgi.wiring.package; filter:=\"(&(osgi.wiring.package=jnr.constants.platform)(version>=0.9.0)(!(version>=1.0.0)))\"]]\n\nAny ideas? All the jnr jars are embedded within the bluez-dbus-osgi jar from what I can tell so I don't know why it says they are missing. jnr.constants.platform isn't even among the package imports of the bluez-dbus-osgi jar.", "url": "https://github.com/openhab/openhab-addons/pull/8819#discussion_r510296072", "createdAt": "2020-10-22T16:24:58Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.bluetooth.bluez/pom.xml", "diffHunk": "@@ -15,18 +15,21 @@\n   <name>openHAB Add-ons :: Bundles :: BlueZ Bluetooth Adapter</name>\n \n   <dependencies>\n+\n     <dependency>\n       <groupId>org.openhab.addons.bundles</groupId>\n       <artifactId>org.openhab.binding.bluetooth</artifactId>\n       <version>${project.version}</version>\n       <scope>provided</scope>\n     </dependency>\n+\n     <dependency>\n-      <groupId>org.openhab.osgiify</groupId>\n-      <artifactId>intel-iot-devkit.tinyb</artifactId>\n-      <version>0.5.1</version>\n-      <scope>compile</scope>\n+      <groupId>com.github.hypfvieh</groupId>\n+      <artifactId>bluez-dbus-osgi</artifactId>\n+      <version>0.1.3</version>\n+      <scope>provided</scope>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTkzODU5Ng=="}, "originalCommit": {"oid": "00d70430420d1037e3a206a0b1c83549f7d151b5"}, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTE2NzU5Mw==", "bodyText": "No idea, really. Maybe @J-N-K?", "url": "https://github.com/openhab/openhab-addons/pull/8819#discussion_r511167593", "createdAt": "2020-10-23T21:40:51Z", "author": {"login": "kaikreuzer"}, "path": "bundles/org.openhab.binding.bluetooth.bluez/pom.xml", "diffHunk": "@@ -15,18 +15,21 @@\n   <name>openHAB Add-ons :: Bundles :: BlueZ Bluetooth Adapter</name>\n \n   <dependencies>\n+\n     <dependency>\n       <groupId>org.openhab.addons.bundles</groupId>\n       <artifactId>org.openhab.binding.bluetooth</artifactId>\n       <version>${project.version}</version>\n       <scope>provided</scope>\n     </dependency>\n+\n     <dependency>\n-      <groupId>org.openhab.osgiify</groupId>\n-      <artifactId>intel-iot-devkit.tinyb</artifactId>\n-      <version>0.5.1</version>\n-      <scope>compile</scope>\n+      <groupId>com.github.hypfvieh</groupId>\n+      <artifactId>bluez-dbus-osgi</artifactId>\n+      <version>0.1.3</version>\n+      <scope>provided</scope>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTkzODU5Ng=="}, "originalCommit": {"oid": "00d70430420d1037e3a206a0b1c83549f7d151b5"}, "originalPosition": 20}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE5NzEyMTcwOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.bluetooth.bluez/src/main/java/org/openhab/binding/bluetooth/bluez/internal/DeviceManagerFactory.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMlQxODo1NjowN1rOHmvjCQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMlQxOTo0OToxMFrOHmxUSg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDM4Njk1Mw==", "bodyText": "Looking at this code I have an impression that it could be simplified with basic:\nif (deviceManager != null) deviceManager.closeConnection();\ndeviceManager = null\n\nIs there a concurrency issue that forces you to assign field to local variable?", "url": "https://github.com/openhab/openhab-addons/pull/8819#discussion_r510386953", "createdAt": "2020-10-22T18:56:07Z", "author": {"login": "splatch"}, "path": "bundles/org.openhab.binding.bluetooth.bluez/src/main/java/org/openhab/binding/bluetooth/bluez/internal/DeviceManagerFactory.java", "diffHunk": "@@ -0,0 +1,174 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bluetooth.bluez.internal;\n+\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledThreadPoolExecutor;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.freedesktop.dbus.exceptions.DBusException;\n+import org.openhab.core.common.NamedThreadFactory;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Deactivate;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.github.hypfvieh.bluetooth.DeviceManager;\n+\n+/**\n+ * This service handles the lifecycle of the {@link DeviceManager} singleton instance.\n+ * In addition, this class is responsible for managing the BlueZPropertiesChangedHandler instance\n+ * used by the binding for listening and dispatching dbus events from the DeviceManager.\n+ *\n+ * Creation of the DeviceManager is asynchronous and thus attempts to retrieve the DeviceManager\n+ * through 'getDeviceManager' may initially fail.\n+ *\n+ * @author Connor Petty - Initial Contribution\n+ *\n+ */\n+@NonNullByDefault\n+@Component(service = DeviceManagerFactory.class)\n+public class DeviceManagerFactory {\n+\n+    private final Logger logger = LoggerFactory.getLogger(DeviceManagerFactory.class);\n+    private final BlueZPropertiesChangedHandler changeHandler = new BlueZPropertiesChangedHandler();\n+\n+    private @Nullable ScheduledExecutorService scheduler;\n+    private @Nullable DeviceManager deviceManager;\n+    private @Nullable CompletableFuture<DeviceManagerWrapper> deviceManagerFuture;\n+\n+    public BlueZPropertiesChangedHandler getPropertiesChangedHandler() {\n+        return changeHandler;\n+    }\n+\n+    public @Nullable DeviceManagerWrapper getDeviceManager() {\n+        // we can cheat the null checker with casting here\n+        var future = (CompletableFuture<@Nullable DeviceManagerWrapper>) this.deviceManagerFuture;\n+        if (future != null) {\n+            return future.getNow(null);\n+        }\n+        return null;\n+    }\n+\n+    @Activate\n+    public void initialize() {\n+        logger.debug(\"initializing DeviceManagerFactory\");\n+        ScheduledThreadPoolExecutor scheduler = new ScheduledThreadPoolExecutor(1,\n+                new NamedThreadFactory(\"bluetooth.bluez-init\", true));\n+\n+        scheduler.setExecuteExistingDelayedTasksAfterShutdownPolicy(false);\n+        scheduler.setRemoveOnCancelPolicy(true);\n+\n+        this.scheduler = scheduler;\n+\n+        this.deviceManagerFuture = callAsync(() -> {\n+            try {\n+                // if this is the first call to the library, this call\n+                // should throw an exception (that we are catching)\n+                return DeviceManager.getInstance();\n+                // Experimental - seems reuse does not work\n+            } catch (IllegalStateException e) {\n+                // Exception caused by first call to the library\n+                return DeviceManager.createInstance(false);\n+            }\n+        }, scheduler)//\n+                .thenApply(devManager -> {\n+                    this.deviceManager = devManager;\n+                    return devManager;\n+                }).thenCompose(devManager -> registerPropertyHandler(devManager, scheduler))//\n+                .thenApply(DeviceManagerWrapper::new)//\n+                .whenComplete((devManager, th) -> {\n+                    if (th != null) {\n+                        logger.warn(\"Failed to initialize DeviceManager: {}\", th.getMessage());\n+                    }\n+                });\n+    }\n+\n+    @Deactivate\n+    public void dispose() {\n+        DeviceManager manager = deviceManager;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "00d70430420d1037e3a206a0b1c83549f7d151b5"}, "originalPosition": 106}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDM5NDc0Mg==", "bodyText": "Is there a concurrency issue that forces you to assign field to local variable?\n\nBingo, we use a pretty strict NPE prevention tool that will ignore null checks for @Nullablee fields.", "url": "https://github.com/openhab/openhab-addons/pull/8819#discussion_r510394742", "createdAt": "2020-10-22T19:09:22Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.bluetooth.bluez/src/main/java/org/openhab/binding/bluetooth/bluez/internal/DeviceManagerFactory.java", "diffHunk": "@@ -0,0 +1,174 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bluetooth.bluez.internal;\n+\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledThreadPoolExecutor;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.freedesktop.dbus.exceptions.DBusException;\n+import org.openhab.core.common.NamedThreadFactory;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Deactivate;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.github.hypfvieh.bluetooth.DeviceManager;\n+\n+/**\n+ * This service handles the lifecycle of the {@link DeviceManager} singleton instance.\n+ * In addition, this class is responsible for managing the BlueZPropertiesChangedHandler instance\n+ * used by the binding for listening and dispatching dbus events from the DeviceManager.\n+ *\n+ * Creation of the DeviceManager is asynchronous and thus attempts to retrieve the DeviceManager\n+ * through 'getDeviceManager' may initially fail.\n+ *\n+ * @author Connor Petty - Initial Contribution\n+ *\n+ */\n+@NonNullByDefault\n+@Component(service = DeviceManagerFactory.class)\n+public class DeviceManagerFactory {\n+\n+    private final Logger logger = LoggerFactory.getLogger(DeviceManagerFactory.class);\n+    private final BlueZPropertiesChangedHandler changeHandler = new BlueZPropertiesChangedHandler();\n+\n+    private @Nullable ScheduledExecutorService scheduler;\n+    private @Nullable DeviceManager deviceManager;\n+    private @Nullable CompletableFuture<DeviceManagerWrapper> deviceManagerFuture;\n+\n+    public BlueZPropertiesChangedHandler getPropertiesChangedHandler() {\n+        return changeHandler;\n+    }\n+\n+    public @Nullable DeviceManagerWrapper getDeviceManager() {\n+        // we can cheat the null checker with casting here\n+        var future = (CompletableFuture<@Nullable DeviceManagerWrapper>) this.deviceManagerFuture;\n+        if (future != null) {\n+            return future.getNow(null);\n+        }\n+        return null;\n+    }\n+\n+    @Activate\n+    public void initialize() {\n+        logger.debug(\"initializing DeviceManagerFactory\");\n+        ScheduledThreadPoolExecutor scheduler = new ScheduledThreadPoolExecutor(1,\n+                new NamedThreadFactory(\"bluetooth.bluez-init\", true));\n+\n+        scheduler.setExecuteExistingDelayedTasksAfterShutdownPolicy(false);\n+        scheduler.setRemoveOnCancelPolicy(true);\n+\n+        this.scheduler = scheduler;\n+\n+        this.deviceManagerFuture = callAsync(() -> {\n+            try {\n+                // if this is the first call to the library, this call\n+                // should throw an exception (that we are catching)\n+                return DeviceManager.getInstance();\n+                // Experimental - seems reuse does not work\n+            } catch (IllegalStateException e) {\n+                // Exception caused by first call to the library\n+                return DeviceManager.createInstance(false);\n+            }\n+        }, scheduler)//\n+                .thenApply(devManager -> {\n+                    this.deviceManager = devManager;\n+                    return devManager;\n+                }).thenCompose(devManager -> registerPropertyHandler(devManager, scheduler))//\n+                .thenApply(DeviceManagerWrapper::new)//\n+                .whenComplete((devManager, th) -> {\n+                    if (th != null) {\n+                        logger.warn(\"Failed to initialize DeviceManager: {}\", th.getMessage());\n+                    }\n+                });\n+    }\n+\n+    @Deactivate\n+    public void dispose() {\n+        DeviceManager manager = deviceManager;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDM4Njk1Mw=="}, "originalCommit": {"oid": "00d70430420d1037e3a206a0b1c83549f7d151b5"}, "originalPosition": 106}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDM5OTcyNw==", "bodyText": "Are you kidding me? Does the tool is blind to non null condition or imply multi thread access based on code in other places?\nAnyhow - maybe it is avoidable with AtomicReference.getAndUpdate which should be consider safer?\nLooking at code and use of CompletableFuture you might be still better with direct access over future which should retain computed value unless disposed..", "url": "https://github.com/openhab/openhab-addons/pull/8819#discussion_r510399727", "createdAt": "2020-10-22T19:18:45Z", "author": {"login": "splatch"}, "path": "bundles/org.openhab.binding.bluetooth.bluez/src/main/java/org/openhab/binding/bluetooth/bluez/internal/DeviceManagerFactory.java", "diffHunk": "@@ -0,0 +1,174 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bluetooth.bluez.internal;\n+\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledThreadPoolExecutor;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.freedesktop.dbus.exceptions.DBusException;\n+import org.openhab.core.common.NamedThreadFactory;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Deactivate;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.github.hypfvieh.bluetooth.DeviceManager;\n+\n+/**\n+ * This service handles the lifecycle of the {@link DeviceManager} singleton instance.\n+ * In addition, this class is responsible for managing the BlueZPropertiesChangedHandler instance\n+ * used by the binding for listening and dispatching dbus events from the DeviceManager.\n+ *\n+ * Creation of the DeviceManager is asynchronous and thus attempts to retrieve the DeviceManager\n+ * through 'getDeviceManager' may initially fail.\n+ *\n+ * @author Connor Petty - Initial Contribution\n+ *\n+ */\n+@NonNullByDefault\n+@Component(service = DeviceManagerFactory.class)\n+public class DeviceManagerFactory {\n+\n+    private final Logger logger = LoggerFactory.getLogger(DeviceManagerFactory.class);\n+    private final BlueZPropertiesChangedHandler changeHandler = new BlueZPropertiesChangedHandler();\n+\n+    private @Nullable ScheduledExecutorService scheduler;\n+    private @Nullable DeviceManager deviceManager;\n+    private @Nullable CompletableFuture<DeviceManagerWrapper> deviceManagerFuture;\n+\n+    public BlueZPropertiesChangedHandler getPropertiesChangedHandler() {\n+        return changeHandler;\n+    }\n+\n+    public @Nullable DeviceManagerWrapper getDeviceManager() {\n+        // we can cheat the null checker with casting here\n+        var future = (CompletableFuture<@Nullable DeviceManagerWrapper>) this.deviceManagerFuture;\n+        if (future != null) {\n+            return future.getNow(null);\n+        }\n+        return null;\n+    }\n+\n+    @Activate\n+    public void initialize() {\n+        logger.debug(\"initializing DeviceManagerFactory\");\n+        ScheduledThreadPoolExecutor scheduler = new ScheduledThreadPoolExecutor(1,\n+                new NamedThreadFactory(\"bluetooth.bluez-init\", true));\n+\n+        scheduler.setExecuteExistingDelayedTasksAfterShutdownPolicy(false);\n+        scheduler.setRemoveOnCancelPolicy(true);\n+\n+        this.scheduler = scheduler;\n+\n+        this.deviceManagerFuture = callAsync(() -> {\n+            try {\n+                // if this is the first call to the library, this call\n+                // should throw an exception (that we are catching)\n+                return DeviceManager.getInstance();\n+                // Experimental - seems reuse does not work\n+            } catch (IllegalStateException e) {\n+                // Exception caused by first call to the library\n+                return DeviceManager.createInstance(false);\n+            }\n+        }, scheduler)//\n+                .thenApply(devManager -> {\n+                    this.deviceManager = devManager;\n+                    return devManager;\n+                }).thenCompose(devManager -> registerPropertyHandler(devManager, scheduler))//\n+                .thenApply(DeviceManagerWrapper::new)//\n+                .whenComplete((devManager, th) -> {\n+                    if (th != null) {\n+                        logger.warn(\"Failed to initialize DeviceManager: {}\", th.getMessage());\n+                    }\n+                });\n+    }\n+\n+    @Deactivate\n+    public void dispose() {\n+        DeviceManager manager = deviceManager;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDM4Njk1Mw=="}, "originalCommit": {"oid": "00d70430420d1037e3a206a0b1c83549f7d151b5"}, "originalPosition": 106}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDQxNTk0Ng==", "bodyText": "Are you kidding me? Does the tool is blind to non null condition or imply multi thread access based on code in other places?\n\nI think the tool is taking the heavy-handed assumption that any nullable field could be changed to null by another thread at any time. Overzealous and inappropriate in a vast majority of situations but if you hate NPE enough the tradeoff can be worth it.\n\nAnyhow - maybe it is avoidable with AtomicReference.getAndUpdate which should be consider safer?\nLooking at code and use of CompletableFuture you might be still better with direct access over future which should retain computed value unless disposed..\n\nMy use of completable future was to prevent access to the deviceManager before the BlueZPropertiesChangedHandler was registered. Making sure that BlueZPropertiesChangedHandler successfully registered is a rather good litmus test for whether the deviceManager is in a state usable by the rest of the application.\nI suppose I could add more fields to keep track of registration state but I think adding more state fields might make the code less maintainable.", "url": "https://github.com/openhab/openhab-addons/pull/8819#discussion_r510415946", "createdAt": "2020-10-22T19:49:10Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.bluetooth.bluez/src/main/java/org/openhab/binding/bluetooth/bluez/internal/DeviceManagerFactory.java", "diffHunk": "@@ -0,0 +1,174 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bluetooth.bluez.internal;\n+\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledThreadPoolExecutor;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.freedesktop.dbus.exceptions.DBusException;\n+import org.openhab.core.common.NamedThreadFactory;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Deactivate;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.github.hypfvieh.bluetooth.DeviceManager;\n+\n+/**\n+ * This service handles the lifecycle of the {@link DeviceManager} singleton instance.\n+ * In addition, this class is responsible for managing the BlueZPropertiesChangedHandler instance\n+ * used by the binding for listening and dispatching dbus events from the DeviceManager.\n+ *\n+ * Creation of the DeviceManager is asynchronous and thus attempts to retrieve the DeviceManager\n+ * through 'getDeviceManager' may initially fail.\n+ *\n+ * @author Connor Petty - Initial Contribution\n+ *\n+ */\n+@NonNullByDefault\n+@Component(service = DeviceManagerFactory.class)\n+public class DeviceManagerFactory {\n+\n+    private final Logger logger = LoggerFactory.getLogger(DeviceManagerFactory.class);\n+    private final BlueZPropertiesChangedHandler changeHandler = new BlueZPropertiesChangedHandler();\n+\n+    private @Nullable ScheduledExecutorService scheduler;\n+    private @Nullable DeviceManager deviceManager;\n+    private @Nullable CompletableFuture<DeviceManagerWrapper> deviceManagerFuture;\n+\n+    public BlueZPropertiesChangedHandler getPropertiesChangedHandler() {\n+        return changeHandler;\n+    }\n+\n+    public @Nullable DeviceManagerWrapper getDeviceManager() {\n+        // we can cheat the null checker with casting here\n+        var future = (CompletableFuture<@Nullable DeviceManagerWrapper>) this.deviceManagerFuture;\n+        if (future != null) {\n+            return future.getNow(null);\n+        }\n+        return null;\n+    }\n+\n+    @Activate\n+    public void initialize() {\n+        logger.debug(\"initializing DeviceManagerFactory\");\n+        ScheduledThreadPoolExecutor scheduler = new ScheduledThreadPoolExecutor(1,\n+                new NamedThreadFactory(\"bluetooth.bluez-init\", true));\n+\n+        scheduler.setExecuteExistingDelayedTasksAfterShutdownPolicy(false);\n+        scheduler.setRemoveOnCancelPolicy(true);\n+\n+        this.scheduler = scheduler;\n+\n+        this.deviceManagerFuture = callAsync(() -> {\n+            try {\n+                // if this is the first call to the library, this call\n+                // should throw an exception (that we are catching)\n+                return DeviceManager.getInstance();\n+                // Experimental - seems reuse does not work\n+            } catch (IllegalStateException e) {\n+                // Exception caused by first call to the library\n+                return DeviceManager.createInstance(false);\n+            }\n+        }, scheduler)//\n+                .thenApply(devManager -> {\n+                    this.deviceManager = devManager;\n+                    return devManager;\n+                }).thenCompose(devManager -> registerPropertyHandler(devManager, scheduler))//\n+                .thenApply(DeviceManagerWrapper::new)//\n+                .whenComplete((devManager, th) -> {\n+                    if (th != null) {\n+                        logger.warn(\"Failed to initialize DeviceManager: {}\", th.getMessage());\n+                    }\n+                });\n+    }\n+\n+    @Deactivate\n+    public void dispose() {\n+        DeviceManager manager = deviceManager;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDM4Njk1Mw=="}, "originalCommit": {"oid": "00d70430420d1037e3a206a0b1c83549f7d151b5"}, "originalPosition": 106}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE5NzEyNzc2OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.bluetooth.bluez/src/main/java/org/openhab/binding/bluetooth/bluez/internal/BlueZPropertiesChangedHandler.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMlQxODo1Nzo1NFrOHmvm6w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMlQxOTo0OToyN1rOHmxVMg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDM4Nzk0Nw==", "bodyText": "I believe that making key.toLowerCase() might be more reliable in case of future updates in bluez and eventual changes in property names.", "url": "https://github.com/openhab/openhab-addons/pull/8819#discussion_r510387947", "createdAt": "2020-10-22T18:57:54Z", "author": {"login": "splatch"}, "path": "bundles/org.openhab.binding.bluetooth.bluez/src/main/java/org/openhab/binding/bluetooth/bluez/internal/BlueZPropertiesChangedHandler.java", "diffHunk": "@@ -0,0 +1,212 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bluetooth.bluez.internal;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.CopyOnWriteArraySet;\n+import java.util.concurrent.ScheduledExecutorService;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.freedesktop.dbus.DBusMap;\n+import org.freedesktop.dbus.handlers.AbstractPropertiesChangedHandler;\n+import org.freedesktop.dbus.interfaces.Properties.PropertiesChanged;\n+import org.freedesktop.dbus.types.UInt16;\n+import org.freedesktop.dbus.types.Variant;\n+import org.openhab.binding.bluetooth.bluez.internal.events.AdapterDiscoveringChangedEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.AdapterPoweredChangedEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.BlueZEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.BlueZEventListener;\n+import org.openhab.binding.bluetooth.bluez.internal.events.CharacteristicUpdateEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.ConnectedEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.ManufacturerDataEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.NameEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.RssiEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.ServicesResolvedEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.TXPowerEvent;\n+import org.openhab.core.common.ThreadPoolManager;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * This is the PropertiesChangedHandler subclass used by the binding to handle/dispatch property change events\n+ * from bluez.\n+ *\n+ * @author Benjamin Lafois - Initial contribution and API\n+ * @author Connor Petty - Code cleanup\n+ */\n+@NonNullByDefault\n+public class BlueZPropertiesChangedHandler extends AbstractPropertiesChangedHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(BlueZPropertiesChangedHandler.class);\n+\n+    private final Set<BlueZEventListener> listeners = new CopyOnWriteArraySet<>();\n+\n+    private final ScheduledExecutorService scheduler = ThreadPoolManager.getScheduledPool(\"bluetooth\");\n+\n+    public void addListener(BlueZEventListener listener) {\n+        this.listeners.add(listener);\n+    }\n+\n+    public void removeListener(BlueZEventListener listener) {\n+        this.listeners.remove(listener);\n+    }\n+\n+    private void notifyListeners(BlueZEvent event) {\n+        for (BlueZEventListener listener : this.listeners) {\n+            event.dispatch(listener);\n+        }\n+    }\n+\n+    @Override\n+    public void handle(@Nullable PropertiesChanged properties) {\n+        if (properties == null || properties.getPropertiesChanged() == null) {\n+            logger.debug(\"Null properties. Skipping.\");\n+            return;\n+        }\n+        Map<@Nullable String, @Nullable Variant<?>> changedProperties = properties.getPropertiesChanged();\n+        if (changedProperties == null) {\n+            logger.debug(\"Null properties changed. Skipping.\");\n+            return;\n+        }\n+\n+        // do this asynchronously so that we don't slow things down for the dbus event dispatcher\n+        scheduler.execute(() -> {\n+\n+            String dbusPath = properties.getPath();\n+            changedProperties.forEach((key, variant) -> {\n+                if (key == null || variant == null) {\n+                    return;\n+                }\n+                switch (key) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "00d70430420d1037e3a206a0b1c83549f7d151b5"}, "originalPosition": 93}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDQxNjE3OA==", "bodyText": "good idea!", "url": "https://github.com/openhab/openhab-addons/pull/8819#discussion_r510416178", "createdAt": "2020-10-22T19:49:27Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.bluetooth.bluez/src/main/java/org/openhab/binding/bluetooth/bluez/internal/BlueZPropertiesChangedHandler.java", "diffHunk": "@@ -0,0 +1,212 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bluetooth.bluez.internal;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.CopyOnWriteArraySet;\n+import java.util.concurrent.ScheduledExecutorService;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.freedesktop.dbus.DBusMap;\n+import org.freedesktop.dbus.handlers.AbstractPropertiesChangedHandler;\n+import org.freedesktop.dbus.interfaces.Properties.PropertiesChanged;\n+import org.freedesktop.dbus.types.UInt16;\n+import org.freedesktop.dbus.types.Variant;\n+import org.openhab.binding.bluetooth.bluez.internal.events.AdapterDiscoveringChangedEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.AdapterPoweredChangedEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.BlueZEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.BlueZEventListener;\n+import org.openhab.binding.bluetooth.bluez.internal.events.CharacteristicUpdateEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.ConnectedEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.ManufacturerDataEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.NameEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.RssiEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.ServicesResolvedEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.TXPowerEvent;\n+import org.openhab.core.common.ThreadPoolManager;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * This is the PropertiesChangedHandler subclass used by the binding to handle/dispatch property change events\n+ * from bluez.\n+ *\n+ * @author Benjamin Lafois - Initial contribution and API\n+ * @author Connor Petty - Code cleanup\n+ */\n+@NonNullByDefault\n+public class BlueZPropertiesChangedHandler extends AbstractPropertiesChangedHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(BlueZPropertiesChangedHandler.class);\n+\n+    private final Set<BlueZEventListener> listeners = new CopyOnWriteArraySet<>();\n+\n+    private final ScheduledExecutorService scheduler = ThreadPoolManager.getScheduledPool(\"bluetooth\");\n+\n+    public void addListener(BlueZEventListener listener) {\n+        this.listeners.add(listener);\n+    }\n+\n+    public void removeListener(BlueZEventListener listener) {\n+        this.listeners.remove(listener);\n+    }\n+\n+    private void notifyListeners(BlueZEvent event) {\n+        for (BlueZEventListener listener : this.listeners) {\n+            event.dispatch(listener);\n+        }\n+    }\n+\n+    @Override\n+    public void handle(@Nullable PropertiesChanged properties) {\n+        if (properties == null || properties.getPropertiesChanged() == null) {\n+            logger.debug(\"Null properties. Skipping.\");\n+            return;\n+        }\n+        Map<@Nullable String, @Nullable Variant<?>> changedProperties = properties.getPropertiesChanged();\n+        if (changedProperties == null) {\n+            logger.debug(\"Null properties changed. Skipping.\");\n+            return;\n+        }\n+\n+        // do this asynchronously so that we don't slow things down for the dbus event dispatcher\n+        scheduler.execute(() -> {\n+\n+            String dbusPath = properties.getPath();\n+            changedProperties.forEach((key, variant) -> {\n+                if (key == null || variant == null) {\n+                    return;\n+                }\n+                switch (key) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDM4Nzk0Nw=="}, "originalCommit": {"oid": "00d70430420d1037e3a206a0b1c83549f7d151b5"}, "originalPosition": 93}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE5NzE0Nzg3OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.bluetooth.bluez/src/main/feature/feature.xml", "isResolved": false, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMlQxOTowMzoyOFrOHmvzhQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNFQwMDozNToyMVrOHnh-tQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDM5MTE3Mw==", "bodyText": "I have dbus-java working under OSGi with no troubles using following feature:\n  <feature name=\"dbus\" description=\"DBus transport\" version=\"${project.version}\">\n    <feature prerequisite=\"true\">wrap</feature>\n    <bundle>mvn:com.github.jnr/jnr-unixsocket/0.33</bundle>\n    <bundle>mvn:com.github.jnr/jnr-constants/0.9.15</bundle>\n    <bundle>mvn:com.github.jnr/jnr-enxio/0.28</bundle>\n    <bundle>mvn:com.github.jnr/jnr-ffi/2.1.15</bundle>\n    <bundle>mvn:com.github.jnr/jnr-posix/3.0.58</bundle>\n    <bundle>wrap:mvn:com.github.jnr/jnr-a64asm/1.0.0</bundle>\n    <bundle>wrap:mvn:com.github.jnr/jnr-x86asm/1.0.2</bundle>\n    <bundle>mvn:com.github.jnr/jffi/1.2.23/jar/complete</bundle>\n    <bundle>wrap:mvn:com.github.jnr/jffi/1.2.23/jar/native</bundle>\n    <bundle>wrap:mvn:com.github.hypfvieh/dbus-java/3.2.3</bundle>\n    <bundle>wrap:mvn:com.github.hypfvieh/java-utils/1.0.6</bundle>\n  </feature>\n\nI discourage you from using bluez-dbus-osgi cause this packaging is really a fat jar which doesn't even make use of Bundle-NativeCode header. It doesn't have to, but it packs up all the jnr stuff making it pretty hard to run this with for example NetworkManager or ModemManager. Both use dbus as possible communication mechanism and give access to different parts related to network interfaces.\nTo try out with dbus stuff try adding this:\n<bundle>wrap:mvn:com.github.hypfvieh/bluez-dbus/0.1.3</bundle>", "url": "https://github.com/openhab/openhab-addons/pull/8819#discussion_r510391173", "createdAt": "2020-10-22T19:03:28Z", "author": {"login": "splatch"}, "path": "bundles/org.openhab.binding.bluetooth.bluez/src/main/feature/feature.xml", "diffHunk": "@@ -4,7 +4,8 @@\n \n \t<feature name=\"openhab-binding-bluetooth-bluez\" description=\"Bluetooth Binding Bluez\" version=\"${project.version}\">\n \t\t<feature>openhab-runtime-base</feature>\n-\t\t<feature>openhab-transport-serial</feature>\n+\n+\t\t<bundle dependency=\"true\">mvn:com.github.hypfvieh/bluez-dbus-osgi/0.1.3</bundle>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "00d70430420d1037e3a206a0b1c83549f7d151b5"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDQwODQ0NQ==", "bodyText": "@J-N-K @kaikreuzer\nIs @splatch's suggestion above acceptable?", "url": "https://github.com/openhab/openhab-addons/pull/8819#discussion_r510408445", "createdAt": "2020-10-22T19:35:18Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.bluetooth.bluez/src/main/feature/feature.xml", "diffHunk": "@@ -4,7 +4,8 @@\n \n \t<feature name=\"openhab-binding-bluetooth-bluez\" description=\"Bluetooth Binding Bluez\" version=\"${project.version}\">\n \t\t<feature>openhab-runtime-base</feature>\n-\t\t<feature>openhab-transport-serial</feature>\n+\n+\t\t<bundle dependency=\"true\">mvn:com.github.hypfvieh/bluez-dbus-osgi/0.1.3</bundle>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDM5MTE3Mw=="}, "originalCommit": {"oid": "00d70430420d1037e3a206a0b1c83549f7d151b5"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTE2NjE3OQ==", "bodyText": "I agree that the bluez-dbus-osgi jar is a fat jar, which isn't really ideal - but it is always hard to tell, what can be left out from it.\nIt e.g. contains commons-lang3, which I do not see in your suggested feature definition, @splatch. Can you confirm that the bundles that you list there are enough as a replacement?\nI cannot say much about the NetworkManager or ModemManager argument, since I am not deep enough in these details.\nI'd think, we should be fine and the fat jar as a start (as it is confirmed to be working) and address the splitting up of it in a follow-up PR, if ok for everyone.", "url": "https://github.com/openhab/openhab-addons/pull/8819#discussion_r511166179", "createdAt": "2020-10-23T21:37:01Z", "author": {"login": "kaikreuzer"}, "path": "bundles/org.openhab.binding.bluetooth.bluez/src/main/feature/feature.xml", "diffHunk": "@@ -4,7 +4,8 @@\n \n \t<feature name=\"openhab-binding-bluetooth-bluez\" description=\"Bluetooth Binding Bluez\" version=\"${project.version}\">\n \t\t<feature>openhab-runtime-base</feature>\n-\t\t<feature>openhab-transport-serial</feature>\n+\n+\t\t<bundle dependency=\"true\">mvn:com.github.hypfvieh/bluez-dbus-osgi/0.1.3</bundle>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDM5MTE3Mw=="}, "originalCommit": {"oid": "00d70430420d1037e3a206a0b1c83549f7d151b5"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTE3MDAzNQ==", "bodyText": "@kaikreuzer I did test dbus-java for discovery of can interfaces through generated NetworkManager stub. It does work without commons. The dbus-java itself have very few dependencies (slf4j, jnr, java-utils), however bluez-dbus have some calls which introduce dependency to commons, see here: https://github.com/hypfvieh/bluez-dbus/search?q=org.apache.commons", "url": "https://github.com/openhab/openhab-addons/pull/8819#discussion_r511170035", "createdAt": "2020-10-23T21:47:59Z", "author": {"login": "splatch"}, "path": "bundles/org.openhab.binding.bluetooth.bluez/src/main/feature/feature.xml", "diffHunk": "@@ -4,7 +4,8 @@\n \n \t<feature name=\"openhab-binding-bluetooth-bluez\" description=\"Bluetooth Binding Bluez\" version=\"${project.version}\">\n \t\t<feature>openhab-runtime-base</feature>\n-\t\t<feature>openhab-transport-serial</feature>\n+\n+\t\t<bundle dependency=\"true\">mvn:com.github.hypfvieh/bluez-dbus-osgi/0.1.3</bundle>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDM5MTE3Mw=="}, "originalCommit": {"oid": "00d70430420d1037e3a206a0b1c83549f7d151b5"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTIxMzIzNw==", "bodyText": "I'd think, we should be fine and the fat jar as a start (as it is confirmed to be working) and address the splitting up of it in a follow-up PR, if ok for everyone.\n\nFine by me", "url": "https://github.com/openhab/openhab-addons/pull/8819#discussion_r511213237", "createdAt": "2020-10-24T00:35:21Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.bluetooth.bluez/src/main/feature/feature.xml", "diffHunk": "@@ -4,7 +4,8 @@\n \n \t<feature name=\"openhab-binding-bluetooth-bluez\" description=\"Bluetooth Binding Bluez\" version=\"${project.version}\">\n \t\t<feature>openhab-runtime-base</feature>\n-\t\t<feature>openhab-transport-serial</feature>\n+\n+\t\t<bundle dependency=\"true\">mvn:com.github.hypfvieh/bluez-dbus-osgi/0.1.3</bundle>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDM5MTE3Mw=="}, "originalCommit": {"oid": "00d70430420d1037e3a206a0b1c83549f7d151b5"}, "originalPosition": 6}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIwMjE2MDcxOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.bluetooth.bluez/README.md", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QyMTozOTowNlrOHnfJxA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QyMzoxNTozNVrOHngw-A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTE2NjkxNg==", "bodyText": "This should be removed, since we define that bundle to be part of the feature. So when it is correctly installed, the bundle will be there, no question.", "url": "https://github.com/openhab/openhab-addons/pull/8819#discussion_r511166916", "createdAt": "2020-10-23T21:39:06Z", "author": {"login": "kaikreuzer"}, "path": "bundles/org.openhab.binding.bluetooth.bluez/README.md", "diffHunk": "@@ -61,3 +62,10 @@ This is how an BlueZ adapter can be configured textually in a *.things file:\n ```\n Bridge bluetooth:bluez:hci0 [ address=\"12:34:56:78:90:AB\", backgroundDiscovery=false ]\n ```\n+\n+##Troubleshooting", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9c2c484c0a68abcdb7f6e511a0635e2dd9353821"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTE5MzMzNg==", "bodyText": "done", "url": "https://github.com/openhab/openhab-addons/pull/8819#discussion_r511193336", "createdAt": "2020-10-23T23:15:35Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.bluetooth.bluez/README.md", "diffHunk": "@@ -61,3 +62,10 @@ This is how an BlueZ adapter can be configured textually in a *.things file:\n ```\n Bridge bluetooth:bluez:hci0 [ address=\"12:34:56:78:90:AB\", backgroundDiscovery=false ]\n ```\n+\n+##Troubleshooting", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTE2NjkxNg=="}, "originalCommit": {"oid": "9c2c484c0a68abcdb7f6e511a0635e2dd9353821"}, "originalPosition": 30}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIwMjE3MTQ0OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.bluetooth.bluez/src/main/java/org/openhab/binding/bluetooth/bluez/internal/BlueZBluetoothDevice.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QyMTo0Mzo0NFrOHnfQOw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QyMzoxNzoxMlrOHngyXg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTE2ODU3MQ==", "bodyText": "What is this info telling to the user? Either he can ignore it, then debug should suffice or it is a problem in the configuration/device, then it should rather be a warning with more details.", "url": "https://github.com/openhab/openhab-addons/pull/8819#discussion_r511168571", "createdAt": "2020-10-23T21:43:44Z", "author": {"login": "kaikreuzer"}, "path": "bundles/org.openhab.binding.bluetooth.bluez/src/main/java/org/openhab/binding/bluetooth/bluez/internal/BlueZBluetoothDevice.java", "diffHunk": "@@ -0,0 +1,474 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bluetooth.bluez.internal;\n+\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.UUID;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.bluez.exceptions.BluezFailedException;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.freedesktop.dbus.errors.NoReply;\n+import org.freedesktop.dbus.exceptions.DBusException;\n+import org.freedesktop.dbus.exceptions.DBusExecutionException;\n+import org.freedesktop.dbus.types.UInt16;\n+import org.openhab.binding.bluetooth.BaseBluetoothDevice;\n+import org.openhab.binding.bluetooth.BluetoothAddress;\n+import org.openhab.binding.bluetooth.BluetoothCharacteristic;\n+import org.openhab.binding.bluetooth.BluetoothCompletionStatus;\n+import org.openhab.binding.bluetooth.BluetoothDescriptor;\n+import org.openhab.binding.bluetooth.BluetoothService;\n+import org.openhab.binding.bluetooth.bluez.internal.events.BlueZEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.BlueZEventListener;\n+import org.openhab.binding.bluetooth.bluez.internal.events.CharacteristicUpdateEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.ConnectedEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.ManufacturerDataEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.NameEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.RssiEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.ServicesResolvedEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.TXPowerEvent;\n+import org.openhab.binding.bluetooth.notification.BluetoothConnectionStatusNotification;\n+import org.openhab.binding.bluetooth.notification.BluetoothScanNotification;\n+import org.openhab.core.common.ThreadPoolManager;\n+import org.openhab.core.util.HexUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.github.hypfvieh.bluetooth.wrapper.BluetoothDevice;\n+import com.github.hypfvieh.bluetooth.wrapper.BluetoothGattCharacteristic;\n+import com.github.hypfvieh.bluetooth.wrapper.BluetoothGattDescriptor;\n+import com.github.hypfvieh.bluetooth.wrapper.BluetoothGattService;\n+\n+/**\n+ * Implementation of BluetoothDevice for BlueZ via DBus-BlueZ API\n+ *\n+ * @author Kai Kreuzer - Initial contribution and API\n+ * @author Benjamin Lafois - Replaced tinyB with bluezDbus\n+ *\n+ */\n+@NonNullByDefault\n+public class BlueZBluetoothDevice extends BaseBluetoothDevice implements BlueZEventListener {\n+\n+    private final Logger logger = LoggerFactory.getLogger(BlueZBluetoothDevice.class);\n+\n+    private final ScheduledExecutorService scheduler = ThreadPoolManager.getScheduledPool(\"bluetooth\");\n+\n+    // Device from native lib\n+    private @Nullable BluetoothDevice device = null;\n+\n+    /**\n+     * Constructor\n+     *\n+     * @param adapter the bridge handler through which this device is connected\n+     * @param address the Bluetooth address of the device\n+     * @param name the name of the device\n+     */\n+    public BlueZBluetoothDevice(BlueZBridgeHandler adapter, BluetoothAddress address) {\n+        super(adapter, address);\n+        logger.debug(\"Creating DBusBlueZ device with address '{}'\", address);\n+    }\n+\n+    public synchronized void updateBlueZDevice(@Nullable BluetoothDevice blueZDevice) {\n+        if (this.device != null && this.device == blueZDevice) {\n+            return;\n+        }\n+        logger.debug(\"updateBlueZDevice({})\", blueZDevice);\n+\n+        this.device = blueZDevice;\n+\n+        if (blueZDevice == null) {\n+            return;\n+        }\n+\n+        Short rssi = blueZDevice.getRssi();\n+        if (rssi != null) {\n+            this.rssi = rssi.intValue();\n+        }\n+        this.name = blueZDevice.getName();\n+        Map<UInt16, byte[]> manData = blueZDevice.getManufacturerData();\n+        if (manData != null) {\n+            manData.entrySet().stream().map(Map.Entry::getKey).filter(Objects::nonNull).findFirst()\n+                    .ifPresent((UInt16 manufacturerId) ->\n+                    // Convert to unsigned int to match the convention in BluetoothCompanyIdentifiers\n+                    this.manufacturer = manufacturerId.intValue() & 0xFFFF);\n+        }\n+\n+        if (Boolean.TRUE.equals(blueZDevice.isConnected())) {\n+            setConnectionState(ConnectionState.CONNECTED);\n+        }\n+\n+        discoverServices();\n+    }\n+\n+    /**\n+     * Clean up and release memory.\n+     */\n+    @Override\n+    public void dispose() {\n+        BluetoothDevice dev = device;\n+        if (dev != null) {\n+            try {\n+                dev.getAdapter().removeDevice(dev.getRawDevice());\n+            } catch (DBusException ex) {\n+                if (ex.getMessage().contains(\"Does Not Exist\")) {\n+                    // this happens when the underlying device has already been removed\n+                    // but we don't have a way to check if that is the case beforehand so\n+                    // we will just eat the error here.\n+                } else {\n+                    logger.debug(\"Exception occurred when trying to remove inactive device '{}': {}\", address,\n+                            ex.getMessage());\n+                }\n+            } catch (RuntimeException ex) {\n+                // try to catch any other exceptions\n+                logger.debug(\"Exception occurred when trying to remove inactive device '{}': {}\", address,\n+                        ex.getMessage());\n+            }\n+        }\n+    }\n+\n+    private void setConnectionState(ConnectionState state) {\n+        if (this.connectionState != state) {\n+            this.connectionState = state;\n+            notifyListeners(BluetoothEventType.CONNECTION_STATE, new BluetoothConnectionStatusNotification(state));\n+        }\n+    }\n+\n+    @Override\n+    public boolean connect() {\n+        logger.debug(\"Connect({})\", device);\n+\n+        BluetoothDevice dev = device;\n+        if (dev != null) {\n+            if (Boolean.FALSE.equals(dev.isConnected())) {\n+                try {\n+                    boolean ret = dev.connect();\n+                    logger.debug(\"Connect result: {}\", ret);\n+                    return ret;\n+                } catch (NoReply e) {\n+                    // Have to double check because sometimes, exception but still worked\n+                    logger.debug(\"Got a timeout - but sometimes happen. Is Connected ? {}\", dev.isConnected());\n+                    if (Boolean.FALSE.equals(dev.isConnected())) {\n+\n+                        notifyListeners(BluetoothEventType.CONNECTION_STATE,\n+                                new BluetoothConnectionStatusNotification(ConnectionState.DISCONNECTED));\n+                        return false;\n+                    } else {\n+                        return true;\n+                    }\n+                } catch (DBusExecutionException e) {\n+                    // Catch \"software caused connection abort\"\n+                    return false;\n+                } catch (Exception e) {\n+                    logger.warn(\"error occured while trying to connect\", e);\n+                }\n+\n+            } else {\n+                logger.debug(\"Device was already connected\");\n+                // we might be stuck in another state atm so we need to trigger a connected in this case\n+                setConnectionState(ConnectionState.CONNECTED);\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    @Override\n+    public boolean disconnect() {\n+        BluetoothDevice dev = device;\n+        if (dev != null) {\n+            logger.debug(\"Disconnecting '{}'\", address);\n+            return dev.disconnect();\n+        }\n+        return false;\n+    }\n+\n+    private void ensureConnected() {\n+        BluetoothDevice dev = device;\n+        if (dev == null || !dev.isConnected()) {\n+            throw new IllegalStateException(\"DBusBlueZ device is not set or not connected\");\n+        }\n+    }\n+\n+    private @Nullable BluetoothGattCharacteristic getDBusBlueZCharacteristicByUUID(String uuid) {\n+        BluetoothDevice dev = device;\n+        if (dev == null) {\n+            return null;\n+        }\n+        for (BluetoothGattService service : dev.getGattServices()) {\n+            for (BluetoothGattCharacteristic c : service.getGattCharacteristics()) {\n+                if (c.getUuid().equalsIgnoreCase(uuid)) {\n+                    return c;\n+                }\n+            }\n+        }\n+        return null;\n+    }\n+\n+    private @Nullable BluetoothGattCharacteristic getDBusBlueZCharacteristicByDBusPath(String dBusPath) {\n+        BluetoothDevice dev = device;\n+        if (dev == null) {\n+            return null;\n+        }\n+        for (BluetoothGattService service : dev.getGattServices()) {\n+            if (dBusPath.startsWith(service.getDbusPath())) {\n+                for (BluetoothGattCharacteristic characteristic : service.getGattCharacteristics()) {\n+                    if (dBusPath.startsWith(characteristic.getDbusPath())) {\n+                        return characteristic;\n+                    }\n+                }\n+            }\n+        }\n+        return null;\n+    }\n+\n+    private @Nullable BluetoothGattDescriptor getDBusBlueZDescriptorByUUID(String uuid) {\n+        BluetoothDevice dev = device;\n+        if (dev == null) {\n+            return null;\n+        }\n+        for (BluetoothGattService service : dev.getGattServices()) {\n+            for (BluetoothGattCharacteristic c : service.getGattCharacteristics()) {\n+                for (BluetoothGattDescriptor d : c.getGattDescriptors()) {\n+                    if (d.getUuid().equalsIgnoreCase(uuid)) {\n+                        return d;\n+                    }\n+                }\n+            }\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public boolean enableNotifications(BluetoothCharacteristic characteristic) {\n+        ensureConnected();\n+\n+        BluetoothGattCharacteristic c = getDBusBlueZCharacteristicByUUID(characteristic.getUuid().toString());\n+        if (c != null) {\n+\n+            try {\n+                c.startNotify();\n+            } catch (DBusException e) {\n+                if (e.getMessage().contains(\"Already notifying\")) {\n+                    return false;\n+                } else if (e.getMessage().contains(\"In Progress\")) {\n+                    // let's retry in 10 seconds\n+                    scheduler.schedule(() -> enableNotifications(characteristic), 10, TimeUnit.SECONDS);\n+                } else {\n+                    logger.warn(\"Exception occurred while activating notifications on '{}'\", address, e);\n+                }\n+            }\n+            return true;\n+        } else {\n+            logger.warn(\"Characteristic '{}' is missing on device '{}'.\", characteristic.getUuid(), address);\n+            return false;\n+        }\n+    }\n+\n+    @Override\n+    public boolean writeCharacteristic(BluetoothCharacteristic characteristic) {\n+        logger.debug(\"writeCharacteristic()\");\n+\n+        ensureConnected();\n+\n+        BluetoothGattCharacteristic c = getDBusBlueZCharacteristicByUUID(characteristic.getUuid().toString());\n+        if (c == null) {\n+            logger.warn(\"Characteristic '{}' is missing on device '{}'.\", characteristic.getUuid(), address);\n+            return false;\n+        }\n+\n+        scheduler.submit(() -> {\n+            try {\n+                c.writeValue(characteristic.getByteValue(), null);\n+                notifyListeners(BluetoothEventType.CHARACTERISTIC_WRITE_COMPLETE, characteristic,\n+                        BluetoothCompletionStatus.SUCCESS);\n+\n+            } catch (DBusException e) {\n+                logger.debug(\"Exception occurred when trying to write characteristic '{}': {}\",\n+                        characteristic.getUuid(), e.getMessage());\n+                notifyListeners(BluetoothEventType.CHARACTERISTIC_WRITE_COMPLETE, characteristic,\n+                        BluetoothCompletionStatus.ERROR);\n+            }\n+        });\n+        return true;\n+    }\n+\n+    @Override\n+    public void onDBusBlueZEvent(BlueZEvent event) {\n+        logger.debug(\"Unsupported event: {}\", event);\n+    }\n+\n+    @Override\n+    public void onServicesResolved(ServicesResolvedEvent event) {\n+        if (event.isResolved()) {\n+            notifyListeners(BluetoothEventType.SERVICES_DISCOVERED);\n+        }\n+    }\n+\n+    @Override\n+    public void onNameUpdate(NameEvent event) {\n+        BluetoothScanNotification notification = new BluetoothScanNotification();\n+        notification.setDeviceName(event.getName());\n+        notifyListeners(BluetoothEventType.SCAN_RECORD, notification);\n+    }\n+\n+    @Override\n+    public void onManufacturerDataUpdate(ManufacturerDataEvent event) {\n+        for (Map.Entry<Short, byte[]> entry : event.getData().entrySet()) {\n+            BluetoothScanNotification notification = new BluetoothScanNotification();\n+            byte[] data = new byte[entry.getValue().length + 2];\n+            data[0] = (byte) (entry.getKey() & 0xFF);\n+            data[1] = (byte) (entry.getKey() >>> 8);\n+\n+            System.arraycopy(entry.getValue(), 0, data, 2, entry.getValue().length);\n+\n+            if (logger.isDebugEnabled()) {\n+                logger.debug(\"Received manufacturer data for '{}': {}\", address, HexUtils.bytesToHex(data, \" \"));\n+            }\n+\n+            notification.setManufacturerData(data);\n+            notifyListeners(BluetoothEventType.SCAN_RECORD, notification);\n+        }\n+    }\n+\n+    @Override\n+    public void onTxPowerUpdate(TXPowerEvent event) {\n+        this.txPower = (int) event.getTxPower();\n+    }\n+\n+    @Override\n+    public void onCharacteristicNotify(CharacteristicUpdateEvent event) {\n+        // Here it is a bit special - as the event is linked to the DBUS path, not characteristic UUID.\n+        // So we need to find the characteristic by its DBUS path.\n+        BluetoothGattCharacteristic characteristic = getDBusBlueZCharacteristicByDBusPath(event.getDbusPath());\n+        if (characteristic == null) {\n+            logger.info(\"Received a notification for a characteristic not found on device.\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9c2c484c0a68abcdb7f6e511a0635e2dd9353821"}, "originalPosition": 357}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTE5MzY5NA==", "bodyText": "The situation is unusual, and might indicate a problem. But the issue doesn't require intervention so I'll change to debug.", "url": "https://github.com/openhab/openhab-addons/pull/8819#discussion_r511193694", "createdAt": "2020-10-23T23:17:12Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.bluetooth.bluez/src/main/java/org/openhab/binding/bluetooth/bluez/internal/BlueZBluetoothDevice.java", "diffHunk": "@@ -0,0 +1,474 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bluetooth.bluez.internal;\n+\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.UUID;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.bluez.exceptions.BluezFailedException;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.freedesktop.dbus.errors.NoReply;\n+import org.freedesktop.dbus.exceptions.DBusException;\n+import org.freedesktop.dbus.exceptions.DBusExecutionException;\n+import org.freedesktop.dbus.types.UInt16;\n+import org.openhab.binding.bluetooth.BaseBluetoothDevice;\n+import org.openhab.binding.bluetooth.BluetoothAddress;\n+import org.openhab.binding.bluetooth.BluetoothCharacteristic;\n+import org.openhab.binding.bluetooth.BluetoothCompletionStatus;\n+import org.openhab.binding.bluetooth.BluetoothDescriptor;\n+import org.openhab.binding.bluetooth.BluetoothService;\n+import org.openhab.binding.bluetooth.bluez.internal.events.BlueZEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.BlueZEventListener;\n+import org.openhab.binding.bluetooth.bluez.internal.events.CharacteristicUpdateEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.ConnectedEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.ManufacturerDataEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.NameEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.RssiEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.ServicesResolvedEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.TXPowerEvent;\n+import org.openhab.binding.bluetooth.notification.BluetoothConnectionStatusNotification;\n+import org.openhab.binding.bluetooth.notification.BluetoothScanNotification;\n+import org.openhab.core.common.ThreadPoolManager;\n+import org.openhab.core.util.HexUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.github.hypfvieh.bluetooth.wrapper.BluetoothDevice;\n+import com.github.hypfvieh.bluetooth.wrapper.BluetoothGattCharacteristic;\n+import com.github.hypfvieh.bluetooth.wrapper.BluetoothGattDescriptor;\n+import com.github.hypfvieh.bluetooth.wrapper.BluetoothGattService;\n+\n+/**\n+ * Implementation of BluetoothDevice for BlueZ via DBus-BlueZ API\n+ *\n+ * @author Kai Kreuzer - Initial contribution and API\n+ * @author Benjamin Lafois - Replaced tinyB with bluezDbus\n+ *\n+ */\n+@NonNullByDefault\n+public class BlueZBluetoothDevice extends BaseBluetoothDevice implements BlueZEventListener {\n+\n+    private final Logger logger = LoggerFactory.getLogger(BlueZBluetoothDevice.class);\n+\n+    private final ScheduledExecutorService scheduler = ThreadPoolManager.getScheduledPool(\"bluetooth\");\n+\n+    // Device from native lib\n+    private @Nullable BluetoothDevice device = null;\n+\n+    /**\n+     * Constructor\n+     *\n+     * @param adapter the bridge handler through which this device is connected\n+     * @param address the Bluetooth address of the device\n+     * @param name the name of the device\n+     */\n+    public BlueZBluetoothDevice(BlueZBridgeHandler adapter, BluetoothAddress address) {\n+        super(adapter, address);\n+        logger.debug(\"Creating DBusBlueZ device with address '{}'\", address);\n+    }\n+\n+    public synchronized void updateBlueZDevice(@Nullable BluetoothDevice blueZDevice) {\n+        if (this.device != null && this.device == blueZDevice) {\n+            return;\n+        }\n+        logger.debug(\"updateBlueZDevice({})\", blueZDevice);\n+\n+        this.device = blueZDevice;\n+\n+        if (blueZDevice == null) {\n+            return;\n+        }\n+\n+        Short rssi = blueZDevice.getRssi();\n+        if (rssi != null) {\n+            this.rssi = rssi.intValue();\n+        }\n+        this.name = blueZDevice.getName();\n+        Map<UInt16, byte[]> manData = blueZDevice.getManufacturerData();\n+        if (manData != null) {\n+            manData.entrySet().stream().map(Map.Entry::getKey).filter(Objects::nonNull).findFirst()\n+                    .ifPresent((UInt16 manufacturerId) ->\n+                    // Convert to unsigned int to match the convention in BluetoothCompanyIdentifiers\n+                    this.manufacturer = manufacturerId.intValue() & 0xFFFF);\n+        }\n+\n+        if (Boolean.TRUE.equals(blueZDevice.isConnected())) {\n+            setConnectionState(ConnectionState.CONNECTED);\n+        }\n+\n+        discoverServices();\n+    }\n+\n+    /**\n+     * Clean up and release memory.\n+     */\n+    @Override\n+    public void dispose() {\n+        BluetoothDevice dev = device;\n+        if (dev != null) {\n+            try {\n+                dev.getAdapter().removeDevice(dev.getRawDevice());\n+            } catch (DBusException ex) {\n+                if (ex.getMessage().contains(\"Does Not Exist\")) {\n+                    // this happens when the underlying device has already been removed\n+                    // but we don't have a way to check if that is the case beforehand so\n+                    // we will just eat the error here.\n+                } else {\n+                    logger.debug(\"Exception occurred when trying to remove inactive device '{}': {}\", address,\n+                            ex.getMessage());\n+                }\n+            } catch (RuntimeException ex) {\n+                // try to catch any other exceptions\n+                logger.debug(\"Exception occurred when trying to remove inactive device '{}': {}\", address,\n+                        ex.getMessage());\n+            }\n+        }\n+    }\n+\n+    private void setConnectionState(ConnectionState state) {\n+        if (this.connectionState != state) {\n+            this.connectionState = state;\n+            notifyListeners(BluetoothEventType.CONNECTION_STATE, new BluetoothConnectionStatusNotification(state));\n+        }\n+    }\n+\n+    @Override\n+    public boolean connect() {\n+        logger.debug(\"Connect({})\", device);\n+\n+        BluetoothDevice dev = device;\n+        if (dev != null) {\n+            if (Boolean.FALSE.equals(dev.isConnected())) {\n+                try {\n+                    boolean ret = dev.connect();\n+                    logger.debug(\"Connect result: {}\", ret);\n+                    return ret;\n+                } catch (NoReply e) {\n+                    // Have to double check because sometimes, exception but still worked\n+                    logger.debug(\"Got a timeout - but sometimes happen. Is Connected ? {}\", dev.isConnected());\n+                    if (Boolean.FALSE.equals(dev.isConnected())) {\n+\n+                        notifyListeners(BluetoothEventType.CONNECTION_STATE,\n+                                new BluetoothConnectionStatusNotification(ConnectionState.DISCONNECTED));\n+                        return false;\n+                    } else {\n+                        return true;\n+                    }\n+                } catch (DBusExecutionException e) {\n+                    // Catch \"software caused connection abort\"\n+                    return false;\n+                } catch (Exception e) {\n+                    logger.warn(\"error occured while trying to connect\", e);\n+                }\n+\n+            } else {\n+                logger.debug(\"Device was already connected\");\n+                // we might be stuck in another state atm so we need to trigger a connected in this case\n+                setConnectionState(ConnectionState.CONNECTED);\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    @Override\n+    public boolean disconnect() {\n+        BluetoothDevice dev = device;\n+        if (dev != null) {\n+            logger.debug(\"Disconnecting '{}'\", address);\n+            return dev.disconnect();\n+        }\n+        return false;\n+    }\n+\n+    private void ensureConnected() {\n+        BluetoothDevice dev = device;\n+        if (dev == null || !dev.isConnected()) {\n+            throw new IllegalStateException(\"DBusBlueZ device is not set or not connected\");\n+        }\n+    }\n+\n+    private @Nullable BluetoothGattCharacteristic getDBusBlueZCharacteristicByUUID(String uuid) {\n+        BluetoothDevice dev = device;\n+        if (dev == null) {\n+            return null;\n+        }\n+        for (BluetoothGattService service : dev.getGattServices()) {\n+            for (BluetoothGattCharacteristic c : service.getGattCharacteristics()) {\n+                if (c.getUuid().equalsIgnoreCase(uuid)) {\n+                    return c;\n+                }\n+            }\n+        }\n+        return null;\n+    }\n+\n+    private @Nullable BluetoothGattCharacteristic getDBusBlueZCharacteristicByDBusPath(String dBusPath) {\n+        BluetoothDevice dev = device;\n+        if (dev == null) {\n+            return null;\n+        }\n+        for (BluetoothGattService service : dev.getGattServices()) {\n+            if (dBusPath.startsWith(service.getDbusPath())) {\n+                for (BluetoothGattCharacteristic characteristic : service.getGattCharacteristics()) {\n+                    if (dBusPath.startsWith(characteristic.getDbusPath())) {\n+                        return characteristic;\n+                    }\n+                }\n+            }\n+        }\n+        return null;\n+    }\n+\n+    private @Nullable BluetoothGattDescriptor getDBusBlueZDescriptorByUUID(String uuid) {\n+        BluetoothDevice dev = device;\n+        if (dev == null) {\n+            return null;\n+        }\n+        for (BluetoothGattService service : dev.getGattServices()) {\n+            for (BluetoothGattCharacteristic c : service.getGattCharacteristics()) {\n+                for (BluetoothGattDescriptor d : c.getGattDescriptors()) {\n+                    if (d.getUuid().equalsIgnoreCase(uuid)) {\n+                        return d;\n+                    }\n+                }\n+            }\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public boolean enableNotifications(BluetoothCharacteristic characteristic) {\n+        ensureConnected();\n+\n+        BluetoothGattCharacteristic c = getDBusBlueZCharacteristicByUUID(characteristic.getUuid().toString());\n+        if (c != null) {\n+\n+            try {\n+                c.startNotify();\n+            } catch (DBusException e) {\n+                if (e.getMessage().contains(\"Already notifying\")) {\n+                    return false;\n+                } else if (e.getMessage().contains(\"In Progress\")) {\n+                    // let's retry in 10 seconds\n+                    scheduler.schedule(() -> enableNotifications(characteristic), 10, TimeUnit.SECONDS);\n+                } else {\n+                    logger.warn(\"Exception occurred while activating notifications on '{}'\", address, e);\n+                }\n+            }\n+            return true;\n+        } else {\n+            logger.warn(\"Characteristic '{}' is missing on device '{}'.\", characteristic.getUuid(), address);\n+            return false;\n+        }\n+    }\n+\n+    @Override\n+    public boolean writeCharacteristic(BluetoothCharacteristic characteristic) {\n+        logger.debug(\"writeCharacteristic()\");\n+\n+        ensureConnected();\n+\n+        BluetoothGattCharacteristic c = getDBusBlueZCharacteristicByUUID(characteristic.getUuid().toString());\n+        if (c == null) {\n+            logger.warn(\"Characteristic '{}' is missing on device '{}'.\", characteristic.getUuid(), address);\n+            return false;\n+        }\n+\n+        scheduler.submit(() -> {\n+            try {\n+                c.writeValue(characteristic.getByteValue(), null);\n+                notifyListeners(BluetoothEventType.CHARACTERISTIC_WRITE_COMPLETE, characteristic,\n+                        BluetoothCompletionStatus.SUCCESS);\n+\n+            } catch (DBusException e) {\n+                logger.debug(\"Exception occurred when trying to write characteristic '{}': {}\",\n+                        characteristic.getUuid(), e.getMessage());\n+                notifyListeners(BluetoothEventType.CHARACTERISTIC_WRITE_COMPLETE, characteristic,\n+                        BluetoothCompletionStatus.ERROR);\n+            }\n+        });\n+        return true;\n+    }\n+\n+    @Override\n+    public void onDBusBlueZEvent(BlueZEvent event) {\n+        logger.debug(\"Unsupported event: {}\", event);\n+    }\n+\n+    @Override\n+    public void onServicesResolved(ServicesResolvedEvent event) {\n+        if (event.isResolved()) {\n+            notifyListeners(BluetoothEventType.SERVICES_DISCOVERED);\n+        }\n+    }\n+\n+    @Override\n+    public void onNameUpdate(NameEvent event) {\n+        BluetoothScanNotification notification = new BluetoothScanNotification();\n+        notification.setDeviceName(event.getName());\n+        notifyListeners(BluetoothEventType.SCAN_RECORD, notification);\n+    }\n+\n+    @Override\n+    public void onManufacturerDataUpdate(ManufacturerDataEvent event) {\n+        for (Map.Entry<Short, byte[]> entry : event.getData().entrySet()) {\n+            BluetoothScanNotification notification = new BluetoothScanNotification();\n+            byte[] data = new byte[entry.getValue().length + 2];\n+            data[0] = (byte) (entry.getKey() & 0xFF);\n+            data[1] = (byte) (entry.getKey() >>> 8);\n+\n+            System.arraycopy(entry.getValue(), 0, data, 2, entry.getValue().length);\n+\n+            if (logger.isDebugEnabled()) {\n+                logger.debug(\"Received manufacturer data for '{}': {}\", address, HexUtils.bytesToHex(data, \" \"));\n+            }\n+\n+            notification.setManufacturerData(data);\n+            notifyListeners(BluetoothEventType.SCAN_RECORD, notification);\n+        }\n+    }\n+\n+    @Override\n+    public void onTxPowerUpdate(TXPowerEvent event) {\n+        this.txPower = (int) event.getTxPower();\n+    }\n+\n+    @Override\n+    public void onCharacteristicNotify(CharacteristicUpdateEvent event) {\n+        // Here it is a bit special - as the event is linked to the DBUS path, not characteristic UUID.\n+        // So we need to find the characteristic by its DBUS path.\n+        BluetoothGattCharacteristic characteristic = getDBusBlueZCharacteristicByDBusPath(event.getDbusPath());\n+        if (characteristic == null) {\n+            logger.info(\"Received a notification for a characteristic not found on device.\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTE2ODU3MQ=="}, "originalCommit": {"oid": "9c2c484c0a68abcdb7f6e511a0635e2dd9353821"}, "originalPosition": 357}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIwMjE3MzU0OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.bluetooth.bluez/src/main/java/org/openhab/binding/bluetooth/bluez/internal/BlueZBluetoothDevice.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QyMTo0NDozOFrOHnfRgQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QyMzoxODozNVrOHngzdA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTE2ODg5Nw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        logger.debug(\"Has notified that a characteristic has been updated\");\n          \n          \n            \n                        logger.debug(\"Notified that a characteristic has been updated\");", "url": "https://github.com/openhab/openhab-addons/pull/8819#discussion_r511168897", "createdAt": "2020-10-23T21:44:38Z", "author": {"login": "kaikreuzer"}, "path": "bundles/org.openhab.binding.bluetooth.bluez/src/main/java/org/openhab/binding/bluetooth/bluez/internal/BlueZBluetoothDevice.java", "diffHunk": "@@ -0,0 +1,474 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bluetooth.bluez.internal;\n+\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.UUID;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.bluez.exceptions.BluezFailedException;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.freedesktop.dbus.errors.NoReply;\n+import org.freedesktop.dbus.exceptions.DBusException;\n+import org.freedesktop.dbus.exceptions.DBusExecutionException;\n+import org.freedesktop.dbus.types.UInt16;\n+import org.openhab.binding.bluetooth.BaseBluetoothDevice;\n+import org.openhab.binding.bluetooth.BluetoothAddress;\n+import org.openhab.binding.bluetooth.BluetoothCharacteristic;\n+import org.openhab.binding.bluetooth.BluetoothCompletionStatus;\n+import org.openhab.binding.bluetooth.BluetoothDescriptor;\n+import org.openhab.binding.bluetooth.BluetoothService;\n+import org.openhab.binding.bluetooth.bluez.internal.events.BlueZEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.BlueZEventListener;\n+import org.openhab.binding.bluetooth.bluez.internal.events.CharacteristicUpdateEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.ConnectedEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.ManufacturerDataEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.NameEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.RssiEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.ServicesResolvedEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.TXPowerEvent;\n+import org.openhab.binding.bluetooth.notification.BluetoothConnectionStatusNotification;\n+import org.openhab.binding.bluetooth.notification.BluetoothScanNotification;\n+import org.openhab.core.common.ThreadPoolManager;\n+import org.openhab.core.util.HexUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.github.hypfvieh.bluetooth.wrapper.BluetoothDevice;\n+import com.github.hypfvieh.bluetooth.wrapper.BluetoothGattCharacteristic;\n+import com.github.hypfvieh.bluetooth.wrapper.BluetoothGattDescriptor;\n+import com.github.hypfvieh.bluetooth.wrapper.BluetoothGattService;\n+\n+/**\n+ * Implementation of BluetoothDevice for BlueZ via DBus-BlueZ API\n+ *\n+ * @author Kai Kreuzer - Initial contribution and API\n+ * @author Benjamin Lafois - Replaced tinyB with bluezDbus\n+ *\n+ */\n+@NonNullByDefault\n+public class BlueZBluetoothDevice extends BaseBluetoothDevice implements BlueZEventListener {\n+\n+    private final Logger logger = LoggerFactory.getLogger(BlueZBluetoothDevice.class);\n+\n+    private final ScheduledExecutorService scheduler = ThreadPoolManager.getScheduledPool(\"bluetooth\");\n+\n+    // Device from native lib\n+    private @Nullable BluetoothDevice device = null;\n+\n+    /**\n+     * Constructor\n+     *\n+     * @param adapter the bridge handler through which this device is connected\n+     * @param address the Bluetooth address of the device\n+     * @param name the name of the device\n+     */\n+    public BlueZBluetoothDevice(BlueZBridgeHandler adapter, BluetoothAddress address) {\n+        super(adapter, address);\n+        logger.debug(\"Creating DBusBlueZ device with address '{}'\", address);\n+    }\n+\n+    public synchronized void updateBlueZDevice(@Nullable BluetoothDevice blueZDevice) {\n+        if (this.device != null && this.device == blueZDevice) {\n+            return;\n+        }\n+        logger.debug(\"updateBlueZDevice({})\", blueZDevice);\n+\n+        this.device = blueZDevice;\n+\n+        if (blueZDevice == null) {\n+            return;\n+        }\n+\n+        Short rssi = blueZDevice.getRssi();\n+        if (rssi != null) {\n+            this.rssi = rssi.intValue();\n+        }\n+        this.name = blueZDevice.getName();\n+        Map<UInt16, byte[]> manData = blueZDevice.getManufacturerData();\n+        if (manData != null) {\n+            manData.entrySet().stream().map(Map.Entry::getKey).filter(Objects::nonNull).findFirst()\n+                    .ifPresent((UInt16 manufacturerId) ->\n+                    // Convert to unsigned int to match the convention in BluetoothCompanyIdentifiers\n+                    this.manufacturer = manufacturerId.intValue() & 0xFFFF);\n+        }\n+\n+        if (Boolean.TRUE.equals(blueZDevice.isConnected())) {\n+            setConnectionState(ConnectionState.CONNECTED);\n+        }\n+\n+        discoverServices();\n+    }\n+\n+    /**\n+     * Clean up and release memory.\n+     */\n+    @Override\n+    public void dispose() {\n+        BluetoothDevice dev = device;\n+        if (dev != null) {\n+            try {\n+                dev.getAdapter().removeDevice(dev.getRawDevice());\n+            } catch (DBusException ex) {\n+                if (ex.getMessage().contains(\"Does Not Exist\")) {\n+                    // this happens when the underlying device has already been removed\n+                    // but we don't have a way to check if that is the case beforehand so\n+                    // we will just eat the error here.\n+                } else {\n+                    logger.debug(\"Exception occurred when trying to remove inactive device '{}': {}\", address,\n+                            ex.getMessage());\n+                }\n+            } catch (RuntimeException ex) {\n+                // try to catch any other exceptions\n+                logger.debug(\"Exception occurred when trying to remove inactive device '{}': {}\", address,\n+                        ex.getMessage());\n+            }\n+        }\n+    }\n+\n+    private void setConnectionState(ConnectionState state) {\n+        if (this.connectionState != state) {\n+            this.connectionState = state;\n+            notifyListeners(BluetoothEventType.CONNECTION_STATE, new BluetoothConnectionStatusNotification(state));\n+        }\n+    }\n+\n+    @Override\n+    public boolean connect() {\n+        logger.debug(\"Connect({})\", device);\n+\n+        BluetoothDevice dev = device;\n+        if (dev != null) {\n+            if (Boolean.FALSE.equals(dev.isConnected())) {\n+                try {\n+                    boolean ret = dev.connect();\n+                    logger.debug(\"Connect result: {}\", ret);\n+                    return ret;\n+                } catch (NoReply e) {\n+                    // Have to double check because sometimes, exception but still worked\n+                    logger.debug(\"Got a timeout - but sometimes happen. Is Connected ? {}\", dev.isConnected());\n+                    if (Boolean.FALSE.equals(dev.isConnected())) {\n+\n+                        notifyListeners(BluetoothEventType.CONNECTION_STATE,\n+                                new BluetoothConnectionStatusNotification(ConnectionState.DISCONNECTED));\n+                        return false;\n+                    } else {\n+                        return true;\n+                    }\n+                } catch (DBusExecutionException e) {\n+                    // Catch \"software caused connection abort\"\n+                    return false;\n+                } catch (Exception e) {\n+                    logger.warn(\"error occured while trying to connect\", e);\n+                }\n+\n+            } else {\n+                logger.debug(\"Device was already connected\");\n+                // we might be stuck in another state atm so we need to trigger a connected in this case\n+                setConnectionState(ConnectionState.CONNECTED);\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    @Override\n+    public boolean disconnect() {\n+        BluetoothDevice dev = device;\n+        if (dev != null) {\n+            logger.debug(\"Disconnecting '{}'\", address);\n+            return dev.disconnect();\n+        }\n+        return false;\n+    }\n+\n+    private void ensureConnected() {\n+        BluetoothDevice dev = device;\n+        if (dev == null || !dev.isConnected()) {\n+            throw new IllegalStateException(\"DBusBlueZ device is not set or not connected\");\n+        }\n+    }\n+\n+    private @Nullable BluetoothGattCharacteristic getDBusBlueZCharacteristicByUUID(String uuid) {\n+        BluetoothDevice dev = device;\n+        if (dev == null) {\n+            return null;\n+        }\n+        for (BluetoothGattService service : dev.getGattServices()) {\n+            for (BluetoothGattCharacteristic c : service.getGattCharacteristics()) {\n+                if (c.getUuid().equalsIgnoreCase(uuid)) {\n+                    return c;\n+                }\n+            }\n+        }\n+        return null;\n+    }\n+\n+    private @Nullable BluetoothGattCharacteristic getDBusBlueZCharacteristicByDBusPath(String dBusPath) {\n+        BluetoothDevice dev = device;\n+        if (dev == null) {\n+            return null;\n+        }\n+        for (BluetoothGattService service : dev.getGattServices()) {\n+            if (dBusPath.startsWith(service.getDbusPath())) {\n+                for (BluetoothGattCharacteristic characteristic : service.getGattCharacteristics()) {\n+                    if (dBusPath.startsWith(characteristic.getDbusPath())) {\n+                        return characteristic;\n+                    }\n+                }\n+            }\n+        }\n+        return null;\n+    }\n+\n+    private @Nullable BluetoothGattDescriptor getDBusBlueZDescriptorByUUID(String uuid) {\n+        BluetoothDevice dev = device;\n+        if (dev == null) {\n+            return null;\n+        }\n+        for (BluetoothGattService service : dev.getGattServices()) {\n+            for (BluetoothGattCharacteristic c : service.getGattCharacteristics()) {\n+                for (BluetoothGattDescriptor d : c.getGattDescriptors()) {\n+                    if (d.getUuid().equalsIgnoreCase(uuid)) {\n+                        return d;\n+                    }\n+                }\n+            }\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public boolean enableNotifications(BluetoothCharacteristic characteristic) {\n+        ensureConnected();\n+\n+        BluetoothGattCharacteristic c = getDBusBlueZCharacteristicByUUID(characteristic.getUuid().toString());\n+        if (c != null) {\n+\n+            try {\n+                c.startNotify();\n+            } catch (DBusException e) {\n+                if (e.getMessage().contains(\"Already notifying\")) {\n+                    return false;\n+                } else if (e.getMessage().contains(\"In Progress\")) {\n+                    // let's retry in 10 seconds\n+                    scheduler.schedule(() -> enableNotifications(characteristic), 10, TimeUnit.SECONDS);\n+                } else {\n+                    logger.warn(\"Exception occurred while activating notifications on '{}'\", address, e);\n+                }\n+            }\n+            return true;\n+        } else {\n+            logger.warn(\"Characteristic '{}' is missing on device '{}'.\", characteristic.getUuid(), address);\n+            return false;\n+        }\n+    }\n+\n+    @Override\n+    public boolean writeCharacteristic(BluetoothCharacteristic characteristic) {\n+        logger.debug(\"writeCharacteristic()\");\n+\n+        ensureConnected();\n+\n+        BluetoothGattCharacteristic c = getDBusBlueZCharacteristicByUUID(characteristic.getUuid().toString());\n+        if (c == null) {\n+            logger.warn(\"Characteristic '{}' is missing on device '{}'.\", characteristic.getUuid(), address);\n+            return false;\n+        }\n+\n+        scheduler.submit(() -> {\n+            try {\n+                c.writeValue(characteristic.getByteValue(), null);\n+                notifyListeners(BluetoothEventType.CHARACTERISTIC_WRITE_COMPLETE, characteristic,\n+                        BluetoothCompletionStatus.SUCCESS);\n+\n+            } catch (DBusException e) {\n+                logger.debug(\"Exception occurred when trying to write characteristic '{}': {}\",\n+                        characteristic.getUuid(), e.getMessage());\n+                notifyListeners(BluetoothEventType.CHARACTERISTIC_WRITE_COMPLETE, characteristic,\n+                        BluetoothCompletionStatus.ERROR);\n+            }\n+        });\n+        return true;\n+    }\n+\n+    @Override\n+    public void onDBusBlueZEvent(BlueZEvent event) {\n+        logger.debug(\"Unsupported event: {}\", event);\n+    }\n+\n+    @Override\n+    public void onServicesResolved(ServicesResolvedEvent event) {\n+        if (event.isResolved()) {\n+            notifyListeners(BluetoothEventType.SERVICES_DISCOVERED);\n+        }\n+    }\n+\n+    @Override\n+    public void onNameUpdate(NameEvent event) {\n+        BluetoothScanNotification notification = new BluetoothScanNotification();\n+        notification.setDeviceName(event.getName());\n+        notifyListeners(BluetoothEventType.SCAN_RECORD, notification);\n+    }\n+\n+    @Override\n+    public void onManufacturerDataUpdate(ManufacturerDataEvent event) {\n+        for (Map.Entry<Short, byte[]> entry : event.getData().entrySet()) {\n+            BluetoothScanNotification notification = new BluetoothScanNotification();\n+            byte[] data = new byte[entry.getValue().length + 2];\n+            data[0] = (byte) (entry.getKey() & 0xFF);\n+            data[1] = (byte) (entry.getKey() >>> 8);\n+\n+            System.arraycopy(entry.getValue(), 0, data, 2, entry.getValue().length);\n+\n+            if (logger.isDebugEnabled()) {\n+                logger.debug(\"Received manufacturer data for '{}': {}\", address, HexUtils.bytesToHex(data, \" \"));\n+            }\n+\n+            notification.setManufacturerData(data);\n+            notifyListeners(BluetoothEventType.SCAN_RECORD, notification);\n+        }\n+    }\n+\n+    @Override\n+    public void onTxPowerUpdate(TXPowerEvent event) {\n+        this.txPower = (int) event.getTxPower();\n+    }\n+\n+    @Override\n+    public void onCharacteristicNotify(CharacteristicUpdateEvent event) {\n+        // Here it is a bit special - as the event is linked to the DBUS path, not characteristic UUID.\n+        // So we need to find the characteristic by its DBUS path.\n+        BluetoothGattCharacteristic characteristic = getDBusBlueZCharacteristicByDBusPath(event.getDbusPath());\n+        if (characteristic == null) {\n+            logger.info(\"Received a notification for a characteristic not found on device.\");\n+            return;\n+        }\n+        BluetoothCharacteristic c = getCharacteristic(UUID.fromString(characteristic.getUuid()));\n+        if (c != null) {\n+            c.setValue(event.getData());\n+            notifyListeners(BluetoothEventType.CHARACTERISTIC_UPDATED, c, BluetoothCompletionStatus.SUCCESS);\n+            logger.debug(\"Has notified that a characteristic has been updated\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9c2c484c0a68abcdb7f6e511a0635e2dd9353821"}, "originalPosition": 364}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTE5Mzk3Mg==", "bodyText": "Actually, this log isn't really needed anyway since I'll get a log from the BlueZPropertyChangedHandler anyway.\nRemoving.", "url": "https://github.com/openhab/openhab-addons/pull/8819#discussion_r511193972", "createdAt": "2020-10-23T23:18:35Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.bluetooth.bluez/src/main/java/org/openhab/binding/bluetooth/bluez/internal/BlueZBluetoothDevice.java", "diffHunk": "@@ -0,0 +1,474 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bluetooth.bluez.internal;\n+\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.UUID;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.bluez.exceptions.BluezFailedException;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.freedesktop.dbus.errors.NoReply;\n+import org.freedesktop.dbus.exceptions.DBusException;\n+import org.freedesktop.dbus.exceptions.DBusExecutionException;\n+import org.freedesktop.dbus.types.UInt16;\n+import org.openhab.binding.bluetooth.BaseBluetoothDevice;\n+import org.openhab.binding.bluetooth.BluetoothAddress;\n+import org.openhab.binding.bluetooth.BluetoothCharacteristic;\n+import org.openhab.binding.bluetooth.BluetoothCompletionStatus;\n+import org.openhab.binding.bluetooth.BluetoothDescriptor;\n+import org.openhab.binding.bluetooth.BluetoothService;\n+import org.openhab.binding.bluetooth.bluez.internal.events.BlueZEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.BlueZEventListener;\n+import org.openhab.binding.bluetooth.bluez.internal.events.CharacteristicUpdateEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.ConnectedEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.ManufacturerDataEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.NameEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.RssiEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.ServicesResolvedEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.TXPowerEvent;\n+import org.openhab.binding.bluetooth.notification.BluetoothConnectionStatusNotification;\n+import org.openhab.binding.bluetooth.notification.BluetoothScanNotification;\n+import org.openhab.core.common.ThreadPoolManager;\n+import org.openhab.core.util.HexUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.github.hypfvieh.bluetooth.wrapper.BluetoothDevice;\n+import com.github.hypfvieh.bluetooth.wrapper.BluetoothGattCharacteristic;\n+import com.github.hypfvieh.bluetooth.wrapper.BluetoothGattDescriptor;\n+import com.github.hypfvieh.bluetooth.wrapper.BluetoothGattService;\n+\n+/**\n+ * Implementation of BluetoothDevice for BlueZ via DBus-BlueZ API\n+ *\n+ * @author Kai Kreuzer - Initial contribution and API\n+ * @author Benjamin Lafois - Replaced tinyB with bluezDbus\n+ *\n+ */\n+@NonNullByDefault\n+public class BlueZBluetoothDevice extends BaseBluetoothDevice implements BlueZEventListener {\n+\n+    private final Logger logger = LoggerFactory.getLogger(BlueZBluetoothDevice.class);\n+\n+    private final ScheduledExecutorService scheduler = ThreadPoolManager.getScheduledPool(\"bluetooth\");\n+\n+    // Device from native lib\n+    private @Nullable BluetoothDevice device = null;\n+\n+    /**\n+     * Constructor\n+     *\n+     * @param adapter the bridge handler through which this device is connected\n+     * @param address the Bluetooth address of the device\n+     * @param name the name of the device\n+     */\n+    public BlueZBluetoothDevice(BlueZBridgeHandler adapter, BluetoothAddress address) {\n+        super(adapter, address);\n+        logger.debug(\"Creating DBusBlueZ device with address '{}'\", address);\n+    }\n+\n+    public synchronized void updateBlueZDevice(@Nullable BluetoothDevice blueZDevice) {\n+        if (this.device != null && this.device == blueZDevice) {\n+            return;\n+        }\n+        logger.debug(\"updateBlueZDevice({})\", blueZDevice);\n+\n+        this.device = blueZDevice;\n+\n+        if (blueZDevice == null) {\n+            return;\n+        }\n+\n+        Short rssi = blueZDevice.getRssi();\n+        if (rssi != null) {\n+            this.rssi = rssi.intValue();\n+        }\n+        this.name = blueZDevice.getName();\n+        Map<UInt16, byte[]> manData = blueZDevice.getManufacturerData();\n+        if (manData != null) {\n+            manData.entrySet().stream().map(Map.Entry::getKey).filter(Objects::nonNull).findFirst()\n+                    .ifPresent((UInt16 manufacturerId) ->\n+                    // Convert to unsigned int to match the convention in BluetoothCompanyIdentifiers\n+                    this.manufacturer = manufacturerId.intValue() & 0xFFFF);\n+        }\n+\n+        if (Boolean.TRUE.equals(blueZDevice.isConnected())) {\n+            setConnectionState(ConnectionState.CONNECTED);\n+        }\n+\n+        discoverServices();\n+    }\n+\n+    /**\n+     * Clean up and release memory.\n+     */\n+    @Override\n+    public void dispose() {\n+        BluetoothDevice dev = device;\n+        if (dev != null) {\n+            try {\n+                dev.getAdapter().removeDevice(dev.getRawDevice());\n+            } catch (DBusException ex) {\n+                if (ex.getMessage().contains(\"Does Not Exist\")) {\n+                    // this happens when the underlying device has already been removed\n+                    // but we don't have a way to check if that is the case beforehand so\n+                    // we will just eat the error here.\n+                } else {\n+                    logger.debug(\"Exception occurred when trying to remove inactive device '{}': {}\", address,\n+                            ex.getMessage());\n+                }\n+            } catch (RuntimeException ex) {\n+                // try to catch any other exceptions\n+                logger.debug(\"Exception occurred when trying to remove inactive device '{}': {}\", address,\n+                        ex.getMessage());\n+            }\n+        }\n+    }\n+\n+    private void setConnectionState(ConnectionState state) {\n+        if (this.connectionState != state) {\n+            this.connectionState = state;\n+            notifyListeners(BluetoothEventType.CONNECTION_STATE, new BluetoothConnectionStatusNotification(state));\n+        }\n+    }\n+\n+    @Override\n+    public boolean connect() {\n+        logger.debug(\"Connect({})\", device);\n+\n+        BluetoothDevice dev = device;\n+        if (dev != null) {\n+            if (Boolean.FALSE.equals(dev.isConnected())) {\n+                try {\n+                    boolean ret = dev.connect();\n+                    logger.debug(\"Connect result: {}\", ret);\n+                    return ret;\n+                } catch (NoReply e) {\n+                    // Have to double check because sometimes, exception but still worked\n+                    logger.debug(\"Got a timeout - but sometimes happen. Is Connected ? {}\", dev.isConnected());\n+                    if (Boolean.FALSE.equals(dev.isConnected())) {\n+\n+                        notifyListeners(BluetoothEventType.CONNECTION_STATE,\n+                                new BluetoothConnectionStatusNotification(ConnectionState.DISCONNECTED));\n+                        return false;\n+                    } else {\n+                        return true;\n+                    }\n+                } catch (DBusExecutionException e) {\n+                    // Catch \"software caused connection abort\"\n+                    return false;\n+                } catch (Exception e) {\n+                    logger.warn(\"error occured while trying to connect\", e);\n+                }\n+\n+            } else {\n+                logger.debug(\"Device was already connected\");\n+                // we might be stuck in another state atm so we need to trigger a connected in this case\n+                setConnectionState(ConnectionState.CONNECTED);\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    @Override\n+    public boolean disconnect() {\n+        BluetoothDevice dev = device;\n+        if (dev != null) {\n+            logger.debug(\"Disconnecting '{}'\", address);\n+            return dev.disconnect();\n+        }\n+        return false;\n+    }\n+\n+    private void ensureConnected() {\n+        BluetoothDevice dev = device;\n+        if (dev == null || !dev.isConnected()) {\n+            throw new IllegalStateException(\"DBusBlueZ device is not set or not connected\");\n+        }\n+    }\n+\n+    private @Nullable BluetoothGattCharacteristic getDBusBlueZCharacteristicByUUID(String uuid) {\n+        BluetoothDevice dev = device;\n+        if (dev == null) {\n+            return null;\n+        }\n+        for (BluetoothGattService service : dev.getGattServices()) {\n+            for (BluetoothGattCharacteristic c : service.getGattCharacteristics()) {\n+                if (c.getUuid().equalsIgnoreCase(uuid)) {\n+                    return c;\n+                }\n+            }\n+        }\n+        return null;\n+    }\n+\n+    private @Nullable BluetoothGattCharacteristic getDBusBlueZCharacteristicByDBusPath(String dBusPath) {\n+        BluetoothDevice dev = device;\n+        if (dev == null) {\n+            return null;\n+        }\n+        for (BluetoothGattService service : dev.getGattServices()) {\n+            if (dBusPath.startsWith(service.getDbusPath())) {\n+                for (BluetoothGattCharacteristic characteristic : service.getGattCharacteristics()) {\n+                    if (dBusPath.startsWith(characteristic.getDbusPath())) {\n+                        return characteristic;\n+                    }\n+                }\n+            }\n+        }\n+        return null;\n+    }\n+\n+    private @Nullable BluetoothGattDescriptor getDBusBlueZDescriptorByUUID(String uuid) {\n+        BluetoothDevice dev = device;\n+        if (dev == null) {\n+            return null;\n+        }\n+        for (BluetoothGattService service : dev.getGattServices()) {\n+            for (BluetoothGattCharacteristic c : service.getGattCharacteristics()) {\n+                for (BluetoothGattDescriptor d : c.getGattDescriptors()) {\n+                    if (d.getUuid().equalsIgnoreCase(uuid)) {\n+                        return d;\n+                    }\n+                }\n+            }\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public boolean enableNotifications(BluetoothCharacteristic characteristic) {\n+        ensureConnected();\n+\n+        BluetoothGattCharacteristic c = getDBusBlueZCharacteristicByUUID(characteristic.getUuid().toString());\n+        if (c != null) {\n+\n+            try {\n+                c.startNotify();\n+            } catch (DBusException e) {\n+                if (e.getMessage().contains(\"Already notifying\")) {\n+                    return false;\n+                } else if (e.getMessage().contains(\"In Progress\")) {\n+                    // let's retry in 10 seconds\n+                    scheduler.schedule(() -> enableNotifications(characteristic), 10, TimeUnit.SECONDS);\n+                } else {\n+                    logger.warn(\"Exception occurred while activating notifications on '{}'\", address, e);\n+                }\n+            }\n+            return true;\n+        } else {\n+            logger.warn(\"Characteristic '{}' is missing on device '{}'.\", characteristic.getUuid(), address);\n+            return false;\n+        }\n+    }\n+\n+    @Override\n+    public boolean writeCharacteristic(BluetoothCharacteristic characteristic) {\n+        logger.debug(\"writeCharacteristic()\");\n+\n+        ensureConnected();\n+\n+        BluetoothGattCharacteristic c = getDBusBlueZCharacteristicByUUID(characteristic.getUuid().toString());\n+        if (c == null) {\n+            logger.warn(\"Characteristic '{}' is missing on device '{}'.\", characteristic.getUuid(), address);\n+            return false;\n+        }\n+\n+        scheduler.submit(() -> {\n+            try {\n+                c.writeValue(characteristic.getByteValue(), null);\n+                notifyListeners(BluetoothEventType.CHARACTERISTIC_WRITE_COMPLETE, characteristic,\n+                        BluetoothCompletionStatus.SUCCESS);\n+\n+            } catch (DBusException e) {\n+                logger.debug(\"Exception occurred when trying to write characteristic '{}': {}\",\n+                        characteristic.getUuid(), e.getMessage());\n+                notifyListeners(BluetoothEventType.CHARACTERISTIC_WRITE_COMPLETE, characteristic,\n+                        BluetoothCompletionStatus.ERROR);\n+            }\n+        });\n+        return true;\n+    }\n+\n+    @Override\n+    public void onDBusBlueZEvent(BlueZEvent event) {\n+        logger.debug(\"Unsupported event: {}\", event);\n+    }\n+\n+    @Override\n+    public void onServicesResolved(ServicesResolvedEvent event) {\n+        if (event.isResolved()) {\n+            notifyListeners(BluetoothEventType.SERVICES_DISCOVERED);\n+        }\n+    }\n+\n+    @Override\n+    public void onNameUpdate(NameEvent event) {\n+        BluetoothScanNotification notification = new BluetoothScanNotification();\n+        notification.setDeviceName(event.getName());\n+        notifyListeners(BluetoothEventType.SCAN_RECORD, notification);\n+    }\n+\n+    @Override\n+    public void onManufacturerDataUpdate(ManufacturerDataEvent event) {\n+        for (Map.Entry<Short, byte[]> entry : event.getData().entrySet()) {\n+            BluetoothScanNotification notification = new BluetoothScanNotification();\n+            byte[] data = new byte[entry.getValue().length + 2];\n+            data[0] = (byte) (entry.getKey() & 0xFF);\n+            data[1] = (byte) (entry.getKey() >>> 8);\n+\n+            System.arraycopy(entry.getValue(), 0, data, 2, entry.getValue().length);\n+\n+            if (logger.isDebugEnabled()) {\n+                logger.debug(\"Received manufacturer data for '{}': {}\", address, HexUtils.bytesToHex(data, \" \"));\n+            }\n+\n+            notification.setManufacturerData(data);\n+            notifyListeners(BluetoothEventType.SCAN_RECORD, notification);\n+        }\n+    }\n+\n+    @Override\n+    public void onTxPowerUpdate(TXPowerEvent event) {\n+        this.txPower = (int) event.getTxPower();\n+    }\n+\n+    @Override\n+    public void onCharacteristicNotify(CharacteristicUpdateEvent event) {\n+        // Here it is a bit special - as the event is linked to the DBUS path, not characteristic UUID.\n+        // So we need to find the characteristic by its DBUS path.\n+        BluetoothGattCharacteristic characteristic = getDBusBlueZCharacteristicByDBusPath(event.getDbusPath());\n+        if (characteristic == null) {\n+            logger.info(\"Received a notification for a characteristic not found on device.\");\n+            return;\n+        }\n+        BluetoothCharacteristic c = getCharacteristic(UUID.fromString(characteristic.getUuid()));\n+        if (c != null) {\n+            c.setValue(event.getData());\n+            notifyListeners(BluetoothEventType.CHARACTERISTIC_UPDATED, c, BluetoothCompletionStatus.SUCCESS);\n+            logger.debug(\"Has notified that a characteristic has been updated\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTE2ODg5Nw=="}, "originalCommit": {"oid": "9c2c484c0a68abcdb7f6e511a0635e2dd9353821"}, "originalPosition": 364}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIwMjE3NDM2OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.bluetooth.bluez/src/main/java/org/openhab/binding/bluetooth/bluez/internal/BlueZBluetoothDevice.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QyMTo0NDo1NlrOHnfR-g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QyMzoxOToyMFrOHng0XQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTE2OTAxOA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change", "url": "https://github.com/openhab/openhab-addons/pull/8819#discussion_r511169018", "createdAt": "2020-10-23T21:44:56Z", "author": {"login": "kaikreuzer"}, "path": "bundles/org.openhab.binding.bluetooth.bluez/src/main/java/org/openhab/binding/bluetooth/bluez/internal/BlueZBluetoothDevice.java", "diffHunk": "@@ -0,0 +1,474 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bluetooth.bluez.internal;\n+\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.UUID;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.bluez.exceptions.BluezFailedException;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.freedesktop.dbus.errors.NoReply;\n+import org.freedesktop.dbus.exceptions.DBusException;\n+import org.freedesktop.dbus.exceptions.DBusExecutionException;\n+import org.freedesktop.dbus.types.UInt16;\n+import org.openhab.binding.bluetooth.BaseBluetoothDevice;\n+import org.openhab.binding.bluetooth.BluetoothAddress;\n+import org.openhab.binding.bluetooth.BluetoothCharacteristic;\n+import org.openhab.binding.bluetooth.BluetoothCompletionStatus;\n+import org.openhab.binding.bluetooth.BluetoothDescriptor;\n+import org.openhab.binding.bluetooth.BluetoothService;\n+import org.openhab.binding.bluetooth.bluez.internal.events.BlueZEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.BlueZEventListener;\n+import org.openhab.binding.bluetooth.bluez.internal.events.CharacteristicUpdateEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.ConnectedEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.ManufacturerDataEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.NameEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.RssiEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.ServicesResolvedEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.TXPowerEvent;\n+import org.openhab.binding.bluetooth.notification.BluetoothConnectionStatusNotification;\n+import org.openhab.binding.bluetooth.notification.BluetoothScanNotification;\n+import org.openhab.core.common.ThreadPoolManager;\n+import org.openhab.core.util.HexUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.github.hypfvieh.bluetooth.wrapper.BluetoothDevice;\n+import com.github.hypfvieh.bluetooth.wrapper.BluetoothGattCharacteristic;\n+import com.github.hypfvieh.bluetooth.wrapper.BluetoothGattDescriptor;\n+import com.github.hypfvieh.bluetooth.wrapper.BluetoothGattService;\n+\n+/**\n+ * Implementation of BluetoothDevice for BlueZ via DBus-BlueZ API\n+ *\n+ * @author Kai Kreuzer - Initial contribution and API\n+ * @author Benjamin Lafois - Replaced tinyB with bluezDbus\n+ *\n+ */\n+@NonNullByDefault\n+public class BlueZBluetoothDevice extends BaseBluetoothDevice implements BlueZEventListener {\n+\n+    private final Logger logger = LoggerFactory.getLogger(BlueZBluetoothDevice.class);\n+\n+    private final ScheduledExecutorService scheduler = ThreadPoolManager.getScheduledPool(\"bluetooth\");\n+\n+    // Device from native lib\n+    private @Nullable BluetoothDevice device = null;\n+\n+    /**\n+     * Constructor\n+     *\n+     * @param adapter the bridge handler through which this device is connected\n+     * @param address the Bluetooth address of the device\n+     * @param name the name of the device\n+     */\n+    public BlueZBluetoothDevice(BlueZBridgeHandler adapter, BluetoothAddress address) {\n+        super(adapter, address);\n+        logger.debug(\"Creating DBusBlueZ device with address '{}'\", address);\n+    }\n+\n+    public synchronized void updateBlueZDevice(@Nullable BluetoothDevice blueZDevice) {\n+        if (this.device != null && this.device == blueZDevice) {\n+            return;\n+        }\n+        logger.debug(\"updateBlueZDevice({})\", blueZDevice);\n+\n+        this.device = blueZDevice;\n+\n+        if (blueZDevice == null) {\n+            return;\n+        }\n+\n+        Short rssi = blueZDevice.getRssi();\n+        if (rssi != null) {\n+            this.rssi = rssi.intValue();\n+        }\n+        this.name = blueZDevice.getName();\n+        Map<UInt16, byte[]> manData = blueZDevice.getManufacturerData();\n+        if (manData != null) {\n+            manData.entrySet().stream().map(Map.Entry::getKey).filter(Objects::nonNull).findFirst()\n+                    .ifPresent((UInt16 manufacturerId) ->\n+                    // Convert to unsigned int to match the convention in BluetoothCompanyIdentifiers\n+                    this.manufacturer = manufacturerId.intValue() & 0xFFFF);\n+        }\n+\n+        if (Boolean.TRUE.equals(blueZDevice.isConnected())) {\n+            setConnectionState(ConnectionState.CONNECTED);\n+        }\n+\n+        discoverServices();\n+    }\n+\n+    /**\n+     * Clean up and release memory.\n+     */\n+    @Override\n+    public void dispose() {\n+        BluetoothDevice dev = device;\n+        if (dev != null) {\n+            try {\n+                dev.getAdapter().removeDevice(dev.getRawDevice());\n+            } catch (DBusException ex) {\n+                if (ex.getMessage().contains(\"Does Not Exist\")) {\n+                    // this happens when the underlying device has already been removed\n+                    // but we don't have a way to check if that is the case beforehand so\n+                    // we will just eat the error here.\n+                } else {\n+                    logger.debug(\"Exception occurred when trying to remove inactive device '{}': {}\", address,\n+                            ex.getMessage());\n+                }\n+            } catch (RuntimeException ex) {\n+                // try to catch any other exceptions\n+                logger.debug(\"Exception occurred when trying to remove inactive device '{}': {}\", address,\n+                        ex.getMessage());\n+            }\n+        }\n+    }\n+\n+    private void setConnectionState(ConnectionState state) {\n+        if (this.connectionState != state) {\n+            this.connectionState = state;\n+            notifyListeners(BluetoothEventType.CONNECTION_STATE, new BluetoothConnectionStatusNotification(state));\n+        }\n+    }\n+\n+    @Override\n+    public boolean connect() {\n+        logger.debug(\"Connect({})\", device);\n+\n+        BluetoothDevice dev = device;\n+        if (dev != null) {\n+            if (Boolean.FALSE.equals(dev.isConnected())) {\n+                try {\n+                    boolean ret = dev.connect();\n+                    logger.debug(\"Connect result: {}\", ret);\n+                    return ret;\n+                } catch (NoReply e) {\n+                    // Have to double check because sometimes, exception but still worked\n+                    logger.debug(\"Got a timeout - but sometimes happen. Is Connected ? {}\", dev.isConnected());\n+                    if (Boolean.FALSE.equals(dev.isConnected())) {\n+\n+                        notifyListeners(BluetoothEventType.CONNECTION_STATE,\n+                                new BluetoothConnectionStatusNotification(ConnectionState.DISCONNECTED));\n+                        return false;\n+                    } else {\n+                        return true;\n+                    }\n+                } catch (DBusExecutionException e) {\n+                    // Catch \"software caused connection abort\"\n+                    return false;\n+                } catch (Exception e) {\n+                    logger.warn(\"error occured while trying to connect\", e);\n+                }\n+\n+            } else {\n+                logger.debug(\"Device was already connected\");\n+                // we might be stuck in another state atm so we need to trigger a connected in this case\n+                setConnectionState(ConnectionState.CONNECTED);\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    @Override\n+    public boolean disconnect() {\n+        BluetoothDevice dev = device;\n+        if (dev != null) {\n+            logger.debug(\"Disconnecting '{}'\", address);\n+            return dev.disconnect();\n+        }\n+        return false;\n+    }\n+\n+    private void ensureConnected() {\n+        BluetoothDevice dev = device;\n+        if (dev == null || !dev.isConnected()) {\n+            throw new IllegalStateException(\"DBusBlueZ device is not set or not connected\");\n+        }\n+    }\n+\n+    private @Nullable BluetoothGattCharacteristic getDBusBlueZCharacteristicByUUID(String uuid) {\n+        BluetoothDevice dev = device;\n+        if (dev == null) {\n+            return null;\n+        }\n+        for (BluetoothGattService service : dev.getGattServices()) {\n+            for (BluetoothGattCharacteristic c : service.getGattCharacteristics()) {\n+                if (c.getUuid().equalsIgnoreCase(uuid)) {\n+                    return c;\n+                }\n+            }\n+        }\n+        return null;\n+    }\n+\n+    private @Nullable BluetoothGattCharacteristic getDBusBlueZCharacteristicByDBusPath(String dBusPath) {\n+        BluetoothDevice dev = device;\n+        if (dev == null) {\n+            return null;\n+        }\n+        for (BluetoothGattService service : dev.getGattServices()) {\n+            if (dBusPath.startsWith(service.getDbusPath())) {\n+                for (BluetoothGattCharacteristic characteristic : service.getGattCharacteristics()) {\n+                    if (dBusPath.startsWith(characteristic.getDbusPath())) {\n+                        return characteristic;\n+                    }\n+                }\n+            }\n+        }\n+        return null;\n+    }\n+\n+    private @Nullable BluetoothGattDescriptor getDBusBlueZDescriptorByUUID(String uuid) {\n+        BluetoothDevice dev = device;\n+        if (dev == null) {\n+            return null;\n+        }\n+        for (BluetoothGattService service : dev.getGattServices()) {\n+            for (BluetoothGattCharacteristic c : service.getGattCharacteristics()) {\n+                for (BluetoothGattDescriptor d : c.getGattDescriptors()) {\n+                    if (d.getUuid().equalsIgnoreCase(uuid)) {\n+                        return d;\n+                    }\n+                }\n+            }\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public boolean enableNotifications(BluetoothCharacteristic characteristic) {\n+        ensureConnected();\n+\n+        BluetoothGattCharacteristic c = getDBusBlueZCharacteristicByUUID(characteristic.getUuid().toString());\n+        if (c != null) {\n+\n+            try {\n+                c.startNotify();\n+            } catch (DBusException e) {\n+                if (e.getMessage().contains(\"Already notifying\")) {\n+                    return false;\n+                } else if (e.getMessage().contains(\"In Progress\")) {\n+                    // let's retry in 10 seconds\n+                    scheduler.schedule(() -> enableNotifications(characteristic), 10, TimeUnit.SECONDS);\n+                } else {\n+                    logger.warn(\"Exception occurred while activating notifications on '{}'\", address, e);\n+                }\n+            }\n+            return true;\n+        } else {\n+            logger.warn(\"Characteristic '{}' is missing on device '{}'.\", characteristic.getUuid(), address);\n+            return false;\n+        }\n+    }\n+\n+    @Override\n+    public boolean writeCharacteristic(BluetoothCharacteristic characteristic) {\n+        logger.debug(\"writeCharacteristic()\");\n+\n+        ensureConnected();\n+\n+        BluetoothGattCharacteristic c = getDBusBlueZCharacteristicByUUID(characteristic.getUuid().toString());\n+        if (c == null) {\n+            logger.warn(\"Characteristic '{}' is missing on device '{}'.\", characteristic.getUuid(), address);\n+            return false;\n+        }\n+\n+        scheduler.submit(() -> {\n+            try {\n+                c.writeValue(characteristic.getByteValue(), null);\n+                notifyListeners(BluetoothEventType.CHARACTERISTIC_WRITE_COMPLETE, characteristic,\n+                        BluetoothCompletionStatus.SUCCESS);\n+\n+            } catch (DBusException e) {\n+                logger.debug(\"Exception occurred when trying to write characteristic '{}': {}\",\n+                        characteristic.getUuid(), e.getMessage());\n+                notifyListeners(BluetoothEventType.CHARACTERISTIC_WRITE_COMPLETE, characteristic,\n+                        BluetoothCompletionStatus.ERROR);\n+            }\n+        });\n+        return true;\n+    }\n+\n+    @Override\n+    public void onDBusBlueZEvent(BlueZEvent event) {\n+        logger.debug(\"Unsupported event: {}\", event);\n+    }\n+\n+    @Override\n+    public void onServicesResolved(ServicesResolvedEvent event) {\n+        if (event.isResolved()) {\n+            notifyListeners(BluetoothEventType.SERVICES_DISCOVERED);\n+        }\n+    }\n+\n+    @Override\n+    public void onNameUpdate(NameEvent event) {\n+        BluetoothScanNotification notification = new BluetoothScanNotification();\n+        notification.setDeviceName(event.getName());\n+        notifyListeners(BluetoothEventType.SCAN_RECORD, notification);\n+    }\n+\n+    @Override\n+    public void onManufacturerDataUpdate(ManufacturerDataEvent event) {\n+        for (Map.Entry<Short, byte[]> entry : event.getData().entrySet()) {\n+            BluetoothScanNotification notification = new BluetoothScanNotification();\n+            byte[] data = new byte[entry.getValue().length + 2];\n+            data[0] = (byte) (entry.getKey() & 0xFF);\n+            data[1] = (byte) (entry.getKey() >>> 8);\n+\n+            System.arraycopy(entry.getValue(), 0, data, 2, entry.getValue().length);\n+\n+            if (logger.isDebugEnabled()) {\n+                logger.debug(\"Received manufacturer data for '{}': {}\", address, HexUtils.bytesToHex(data, \" \"));\n+            }\n+\n+            notification.setManufacturerData(data);\n+            notifyListeners(BluetoothEventType.SCAN_RECORD, notification);\n+        }\n+    }\n+\n+    @Override\n+    public void onTxPowerUpdate(TXPowerEvent event) {\n+        this.txPower = (int) event.getTxPower();\n+    }\n+\n+    @Override\n+    public void onCharacteristicNotify(CharacteristicUpdateEvent event) {\n+        // Here it is a bit special - as the event is linked to the DBUS path, not characteristic UUID.\n+        // So we need to find the characteristic by its DBUS path.\n+        BluetoothGattCharacteristic characteristic = getDBusBlueZCharacteristicByDBusPath(event.getDbusPath());\n+        if (characteristic == null) {\n+            logger.info(\"Received a notification for a characteristic not found on device.\");\n+            return;\n+        }\n+        BluetoothCharacteristic c = getCharacteristic(UUID.fromString(characteristic.getUuid()));\n+        if (c != null) {\n+            c.setValue(event.getData());\n+            notifyListeners(BluetoothEventType.CHARACTERISTIC_UPDATED, c, BluetoothCompletionStatus.SUCCESS);\n+            logger.debug(\"Has notified that a characteristic has been updated\");\n+        }\n+    }\n+\n+    @Override\n+    public void onRssiUpdate(RssiEvent event) {\n+        int rssiTmp = event.getRssi();\n+        this.rssi = rssiTmp;\n+        BluetoothScanNotification notification = new BluetoothScanNotification();\n+        notification.setRssi(rssiTmp);\n+        notifyListeners(BluetoothEventType.SCAN_RECORD, notification);\n+    }\n+\n+    @Override\n+    public void onConnectedStatusUpdate(ConnectedEvent event) {\n+        this.connectionState = event.isConnected() ? ConnectionState.CONNECTED : ConnectionState.DISCONNECTED;\n+        notifyListeners(BluetoothEventType.CONNECTION_STATE,\n+                new BluetoothConnectionStatusNotification(connectionState));\n+    }\n+\n+    @Override\n+    public boolean discoverServices() {\n+        BluetoothDevice dev = device;\n+        if (dev == null) {\n+            return false;\n+        }\n+        if (dev.getGattServices().size() > getServices().size()) {\n+\n+            for (BluetoothGattService dBusBlueZService : dev.getGattServices()) {\n+                BluetoothService service = new BluetoothService(UUID.fromString(dBusBlueZService.getUuid()),\n+                        dBusBlueZService.isPrimary());\n+\n+                for (BluetoothGattCharacteristic dBusBlueZCharacteristic : dBusBlueZService.getGattCharacteristics()) {\n+                    BluetoothCharacteristic characteristic = new BluetoothCharacteristic(\n+                            UUID.fromString(dBusBlueZCharacteristic.getUuid()), 0);\n+\n+                    for (BluetoothGattDescriptor dBusBlueZDescriptor : dBusBlueZCharacteristic.getGattDescriptors()) {\n+                        BluetoothDescriptor descriptor = new BluetoothDescriptor(characteristic,\n+                                UUID.fromString(dBusBlueZDescriptor.getUuid()));\n+                        characteristic.addDescriptor(descriptor);\n+                    }\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9c2c484c0a68abcdb7f6e511a0635e2dd9353821"}, "originalPosition": 405}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTE5NDIwNQ==", "bodyText": "done", "url": "https://github.com/openhab/openhab-addons/pull/8819#discussion_r511194205", "createdAt": "2020-10-23T23:19:20Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.bluetooth.bluez/src/main/java/org/openhab/binding/bluetooth/bluez/internal/BlueZBluetoothDevice.java", "diffHunk": "@@ -0,0 +1,474 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bluetooth.bluez.internal;\n+\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.UUID;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.bluez.exceptions.BluezFailedException;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.freedesktop.dbus.errors.NoReply;\n+import org.freedesktop.dbus.exceptions.DBusException;\n+import org.freedesktop.dbus.exceptions.DBusExecutionException;\n+import org.freedesktop.dbus.types.UInt16;\n+import org.openhab.binding.bluetooth.BaseBluetoothDevice;\n+import org.openhab.binding.bluetooth.BluetoothAddress;\n+import org.openhab.binding.bluetooth.BluetoothCharacteristic;\n+import org.openhab.binding.bluetooth.BluetoothCompletionStatus;\n+import org.openhab.binding.bluetooth.BluetoothDescriptor;\n+import org.openhab.binding.bluetooth.BluetoothService;\n+import org.openhab.binding.bluetooth.bluez.internal.events.BlueZEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.BlueZEventListener;\n+import org.openhab.binding.bluetooth.bluez.internal.events.CharacteristicUpdateEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.ConnectedEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.ManufacturerDataEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.NameEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.RssiEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.ServicesResolvedEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.TXPowerEvent;\n+import org.openhab.binding.bluetooth.notification.BluetoothConnectionStatusNotification;\n+import org.openhab.binding.bluetooth.notification.BluetoothScanNotification;\n+import org.openhab.core.common.ThreadPoolManager;\n+import org.openhab.core.util.HexUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.github.hypfvieh.bluetooth.wrapper.BluetoothDevice;\n+import com.github.hypfvieh.bluetooth.wrapper.BluetoothGattCharacteristic;\n+import com.github.hypfvieh.bluetooth.wrapper.BluetoothGattDescriptor;\n+import com.github.hypfvieh.bluetooth.wrapper.BluetoothGattService;\n+\n+/**\n+ * Implementation of BluetoothDevice for BlueZ via DBus-BlueZ API\n+ *\n+ * @author Kai Kreuzer - Initial contribution and API\n+ * @author Benjamin Lafois - Replaced tinyB with bluezDbus\n+ *\n+ */\n+@NonNullByDefault\n+public class BlueZBluetoothDevice extends BaseBluetoothDevice implements BlueZEventListener {\n+\n+    private final Logger logger = LoggerFactory.getLogger(BlueZBluetoothDevice.class);\n+\n+    private final ScheduledExecutorService scheduler = ThreadPoolManager.getScheduledPool(\"bluetooth\");\n+\n+    // Device from native lib\n+    private @Nullable BluetoothDevice device = null;\n+\n+    /**\n+     * Constructor\n+     *\n+     * @param adapter the bridge handler through which this device is connected\n+     * @param address the Bluetooth address of the device\n+     * @param name the name of the device\n+     */\n+    public BlueZBluetoothDevice(BlueZBridgeHandler adapter, BluetoothAddress address) {\n+        super(adapter, address);\n+        logger.debug(\"Creating DBusBlueZ device with address '{}'\", address);\n+    }\n+\n+    public synchronized void updateBlueZDevice(@Nullable BluetoothDevice blueZDevice) {\n+        if (this.device != null && this.device == blueZDevice) {\n+            return;\n+        }\n+        logger.debug(\"updateBlueZDevice({})\", blueZDevice);\n+\n+        this.device = blueZDevice;\n+\n+        if (blueZDevice == null) {\n+            return;\n+        }\n+\n+        Short rssi = blueZDevice.getRssi();\n+        if (rssi != null) {\n+            this.rssi = rssi.intValue();\n+        }\n+        this.name = blueZDevice.getName();\n+        Map<UInt16, byte[]> manData = blueZDevice.getManufacturerData();\n+        if (manData != null) {\n+            manData.entrySet().stream().map(Map.Entry::getKey).filter(Objects::nonNull).findFirst()\n+                    .ifPresent((UInt16 manufacturerId) ->\n+                    // Convert to unsigned int to match the convention in BluetoothCompanyIdentifiers\n+                    this.manufacturer = manufacturerId.intValue() & 0xFFFF);\n+        }\n+\n+        if (Boolean.TRUE.equals(blueZDevice.isConnected())) {\n+            setConnectionState(ConnectionState.CONNECTED);\n+        }\n+\n+        discoverServices();\n+    }\n+\n+    /**\n+     * Clean up and release memory.\n+     */\n+    @Override\n+    public void dispose() {\n+        BluetoothDevice dev = device;\n+        if (dev != null) {\n+            try {\n+                dev.getAdapter().removeDevice(dev.getRawDevice());\n+            } catch (DBusException ex) {\n+                if (ex.getMessage().contains(\"Does Not Exist\")) {\n+                    // this happens when the underlying device has already been removed\n+                    // but we don't have a way to check if that is the case beforehand so\n+                    // we will just eat the error here.\n+                } else {\n+                    logger.debug(\"Exception occurred when trying to remove inactive device '{}': {}\", address,\n+                            ex.getMessage());\n+                }\n+            } catch (RuntimeException ex) {\n+                // try to catch any other exceptions\n+                logger.debug(\"Exception occurred when trying to remove inactive device '{}': {}\", address,\n+                        ex.getMessage());\n+            }\n+        }\n+    }\n+\n+    private void setConnectionState(ConnectionState state) {\n+        if (this.connectionState != state) {\n+            this.connectionState = state;\n+            notifyListeners(BluetoothEventType.CONNECTION_STATE, new BluetoothConnectionStatusNotification(state));\n+        }\n+    }\n+\n+    @Override\n+    public boolean connect() {\n+        logger.debug(\"Connect({})\", device);\n+\n+        BluetoothDevice dev = device;\n+        if (dev != null) {\n+            if (Boolean.FALSE.equals(dev.isConnected())) {\n+                try {\n+                    boolean ret = dev.connect();\n+                    logger.debug(\"Connect result: {}\", ret);\n+                    return ret;\n+                } catch (NoReply e) {\n+                    // Have to double check because sometimes, exception but still worked\n+                    logger.debug(\"Got a timeout - but sometimes happen. Is Connected ? {}\", dev.isConnected());\n+                    if (Boolean.FALSE.equals(dev.isConnected())) {\n+\n+                        notifyListeners(BluetoothEventType.CONNECTION_STATE,\n+                                new BluetoothConnectionStatusNotification(ConnectionState.DISCONNECTED));\n+                        return false;\n+                    } else {\n+                        return true;\n+                    }\n+                } catch (DBusExecutionException e) {\n+                    // Catch \"software caused connection abort\"\n+                    return false;\n+                } catch (Exception e) {\n+                    logger.warn(\"error occured while trying to connect\", e);\n+                }\n+\n+            } else {\n+                logger.debug(\"Device was already connected\");\n+                // we might be stuck in another state atm so we need to trigger a connected in this case\n+                setConnectionState(ConnectionState.CONNECTED);\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    @Override\n+    public boolean disconnect() {\n+        BluetoothDevice dev = device;\n+        if (dev != null) {\n+            logger.debug(\"Disconnecting '{}'\", address);\n+            return dev.disconnect();\n+        }\n+        return false;\n+    }\n+\n+    private void ensureConnected() {\n+        BluetoothDevice dev = device;\n+        if (dev == null || !dev.isConnected()) {\n+            throw new IllegalStateException(\"DBusBlueZ device is not set or not connected\");\n+        }\n+    }\n+\n+    private @Nullable BluetoothGattCharacteristic getDBusBlueZCharacteristicByUUID(String uuid) {\n+        BluetoothDevice dev = device;\n+        if (dev == null) {\n+            return null;\n+        }\n+        for (BluetoothGattService service : dev.getGattServices()) {\n+            for (BluetoothGattCharacteristic c : service.getGattCharacteristics()) {\n+                if (c.getUuid().equalsIgnoreCase(uuid)) {\n+                    return c;\n+                }\n+            }\n+        }\n+        return null;\n+    }\n+\n+    private @Nullable BluetoothGattCharacteristic getDBusBlueZCharacteristicByDBusPath(String dBusPath) {\n+        BluetoothDevice dev = device;\n+        if (dev == null) {\n+            return null;\n+        }\n+        for (BluetoothGattService service : dev.getGattServices()) {\n+            if (dBusPath.startsWith(service.getDbusPath())) {\n+                for (BluetoothGattCharacteristic characteristic : service.getGattCharacteristics()) {\n+                    if (dBusPath.startsWith(characteristic.getDbusPath())) {\n+                        return characteristic;\n+                    }\n+                }\n+            }\n+        }\n+        return null;\n+    }\n+\n+    private @Nullable BluetoothGattDescriptor getDBusBlueZDescriptorByUUID(String uuid) {\n+        BluetoothDevice dev = device;\n+        if (dev == null) {\n+            return null;\n+        }\n+        for (BluetoothGattService service : dev.getGattServices()) {\n+            for (BluetoothGattCharacteristic c : service.getGattCharacteristics()) {\n+                for (BluetoothGattDescriptor d : c.getGattDescriptors()) {\n+                    if (d.getUuid().equalsIgnoreCase(uuid)) {\n+                        return d;\n+                    }\n+                }\n+            }\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public boolean enableNotifications(BluetoothCharacteristic characteristic) {\n+        ensureConnected();\n+\n+        BluetoothGattCharacteristic c = getDBusBlueZCharacteristicByUUID(characteristic.getUuid().toString());\n+        if (c != null) {\n+\n+            try {\n+                c.startNotify();\n+            } catch (DBusException e) {\n+                if (e.getMessage().contains(\"Already notifying\")) {\n+                    return false;\n+                } else if (e.getMessage().contains(\"In Progress\")) {\n+                    // let's retry in 10 seconds\n+                    scheduler.schedule(() -> enableNotifications(characteristic), 10, TimeUnit.SECONDS);\n+                } else {\n+                    logger.warn(\"Exception occurred while activating notifications on '{}'\", address, e);\n+                }\n+            }\n+            return true;\n+        } else {\n+            logger.warn(\"Characteristic '{}' is missing on device '{}'.\", characteristic.getUuid(), address);\n+            return false;\n+        }\n+    }\n+\n+    @Override\n+    public boolean writeCharacteristic(BluetoothCharacteristic characteristic) {\n+        logger.debug(\"writeCharacteristic()\");\n+\n+        ensureConnected();\n+\n+        BluetoothGattCharacteristic c = getDBusBlueZCharacteristicByUUID(characteristic.getUuid().toString());\n+        if (c == null) {\n+            logger.warn(\"Characteristic '{}' is missing on device '{}'.\", characteristic.getUuid(), address);\n+            return false;\n+        }\n+\n+        scheduler.submit(() -> {\n+            try {\n+                c.writeValue(characteristic.getByteValue(), null);\n+                notifyListeners(BluetoothEventType.CHARACTERISTIC_WRITE_COMPLETE, characteristic,\n+                        BluetoothCompletionStatus.SUCCESS);\n+\n+            } catch (DBusException e) {\n+                logger.debug(\"Exception occurred when trying to write characteristic '{}': {}\",\n+                        characteristic.getUuid(), e.getMessage());\n+                notifyListeners(BluetoothEventType.CHARACTERISTIC_WRITE_COMPLETE, characteristic,\n+                        BluetoothCompletionStatus.ERROR);\n+            }\n+        });\n+        return true;\n+    }\n+\n+    @Override\n+    public void onDBusBlueZEvent(BlueZEvent event) {\n+        logger.debug(\"Unsupported event: {}\", event);\n+    }\n+\n+    @Override\n+    public void onServicesResolved(ServicesResolvedEvent event) {\n+        if (event.isResolved()) {\n+            notifyListeners(BluetoothEventType.SERVICES_DISCOVERED);\n+        }\n+    }\n+\n+    @Override\n+    public void onNameUpdate(NameEvent event) {\n+        BluetoothScanNotification notification = new BluetoothScanNotification();\n+        notification.setDeviceName(event.getName());\n+        notifyListeners(BluetoothEventType.SCAN_RECORD, notification);\n+    }\n+\n+    @Override\n+    public void onManufacturerDataUpdate(ManufacturerDataEvent event) {\n+        for (Map.Entry<Short, byte[]> entry : event.getData().entrySet()) {\n+            BluetoothScanNotification notification = new BluetoothScanNotification();\n+            byte[] data = new byte[entry.getValue().length + 2];\n+            data[0] = (byte) (entry.getKey() & 0xFF);\n+            data[1] = (byte) (entry.getKey() >>> 8);\n+\n+            System.arraycopy(entry.getValue(), 0, data, 2, entry.getValue().length);\n+\n+            if (logger.isDebugEnabled()) {\n+                logger.debug(\"Received manufacturer data for '{}': {}\", address, HexUtils.bytesToHex(data, \" \"));\n+            }\n+\n+            notification.setManufacturerData(data);\n+            notifyListeners(BluetoothEventType.SCAN_RECORD, notification);\n+        }\n+    }\n+\n+    @Override\n+    public void onTxPowerUpdate(TXPowerEvent event) {\n+        this.txPower = (int) event.getTxPower();\n+    }\n+\n+    @Override\n+    public void onCharacteristicNotify(CharacteristicUpdateEvent event) {\n+        // Here it is a bit special - as the event is linked to the DBUS path, not characteristic UUID.\n+        // So we need to find the characteristic by its DBUS path.\n+        BluetoothGattCharacteristic characteristic = getDBusBlueZCharacteristicByDBusPath(event.getDbusPath());\n+        if (characteristic == null) {\n+            logger.info(\"Received a notification for a characteristic not found on device.\");\n+            return;\n+        }\n+        BluetoothCharacteristic c = getCharacteristic(UUID.fromString(characteristic.getUuid()));\n+        if (c != null) {\n+            c.setValue(event.getData());\n+            notifyListeners(BluetoothEventType.CHARACTERISTIC_UPDATED, c, BluetoothCompletionStatus.SUCCESS);\n+            logger.debug(\"Has notified that a characteristic has been updated\");\n+        }\n+    }\n+\n+    @Override\n+    public void onRssiUpdate(RssiEvent event) {\n+        int rssiTmp = event.getRssi();\n+        this.rssi = rssiTmp;\n+        BluetoothScanNotification notification = new BluetoothScanNotification();\n+        notification.setRssi(rssiTmp);\n+        notifyListeners(BluetoothEventType.SCAN_RECORD, notification);\n+    }\n+\n+    @Override\n+    public void onConnectedStatusUpdate(ConnectedEvent event) {\n+        this.connectionState = event.isConnected() ? ConnectionState.CONNECTED : ConnectionState.DISCONNECTED;\n+        notifyListeners(BluetoothEventType.CONNECTION_STATE,\n+                new BluetoothConnectionStatusNotification(connectionState));\n+    }\n+\n+    @Override\n+    public boolean discoverServices() {\n+        BluetoothDevice dev = device;\n+        if (dev == null) {\n+            return false;\n+        }\n+        if (dev.getGattServices().size() > getServices().size()) {\n+\n+            for (BluetoothGattService dBusBlueZService : dev.getGattServices()) {\n+                BluetoothService service = new BluetoothService(UUID.fromString(dBusBlueZService.getUuid()),\n+                        dBusBlueZService.isPrimary());\n+\n+                for (BluetoothGattCharacteristic dBusBlueZCharacteristic : dBusBlueZService.getGattCharacteristics()) {\n+                    BluetoothCharacteristic characteristic = new BluetoothCharacteristic(\n+                            UUID.fromString(dBusBlueZCharacteristic.getUuid()), 0);\n+\n+                    for (BluetoothGattDescriptor dBusBlueZDescriptor : dBusBlueZCharacteristic.getGattDescriptors()) {\n+                        BluetoothDescriptor descriptor = new BluetoothDescriptor(characteristic,\n+                                UUID.fromString(dBusBlueZDescriptor.getUuid()));\n+                        characteristic.addDescriptor(descriptor);\n+                    }\n+", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTE2OTAxOA=="}, "originalCommit": {"oid": "9c2c484c0a68abcdb7f6e511a0635e2dd9353821"}, "originalPosition": 405}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIwMjE3NDc2OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.bluetooth.bluez/src/main/java/org/openhab/binding/bluetooth/bluez/internal/BlueZBluetoothDevice.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QyMTo0NTowNVrOHnfSNw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNFQwMDoxMTo0MVrOHnhbVA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTE2OTA3OQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change", "url": "https://github.com/openhab/openhab-addons/pull/8819#discussion_r511169079", "createdAt": "2020-10-23T21:45:05Z", "author": {"login": "kaikreuzer"}, "path": "bundles/org.openhab.binding.bluetooth.bluez/src/main/java/org/openhab/binding/bluetooth/bluez/internal/BlueZBluetoothDevice.java", "diffHunk": "@@ -0,0 +1,474 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bluetooth.bluez.internal;\n+\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.UUID;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.bluez.exceptions.BluezFailedException;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.freedesktop.dbus.errors.NoReply;\n+import org.freedesktop.dbus.exceptions.DBusException;\n+import org.freedesktop.dbus.exceptions.DBusExecutionException;\n+import org.freedesktop.dbus.types.UInt16;\n+import org.openhab.binding.bluetooth.BaseBluetoothDevice;\n+import org.openhab.binding.bluetooth.BluetoothAddress;\n+import org.openhab.binding.bluetooth.BluetoothCharacteristic;\n+import org.openhab.binding.bluetooth.BluetoothCompletionStatus;\n+import org.openhab.binding.bluetooth.BluetoothDescriptor;\n+import org.openhab.binding.bluetooth.BluetoothService;\n+import org.openhab.binding.bluetooth.bluez.internal.events.BlueZEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.BlueZEventListener;\n+import org.openhab.binding.bluetooth.bluez.internal.events.CharacteristicUpdateEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.ConnectedEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.ManufacturerDataEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.NameEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.RssiEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.ServicesResolvedEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.TXPowerEvent;\n+import org.openhab.binding.bluetooth.notification.BluetoothConnectionStatusNotification;\n+import org.openhab.binding.bluetooth.notification.BluetoothScanNotification;\n+import org.openhab.core.common.ThreadPoolManager;\n+import org.openhab.core.util.HexUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.github.hypfvieh.bluetooth.wrapper.BluetoothDevice;\n+import com.github.hypfvieh.bluetooth.wrapper.BluetoothGattCharacteristic;\n+import com.github.hypfvieh.bluetooth.wrapper.BluetoothGattDescriptor;\n+import com.github.hypfvieh.bluetooth.wrapper.BluetoothGattService;\n+\n+/**\n+ * Implementation of BluetoothDevice for BlueZ via DBus-BlueZ API\n+ *\n+ * @author Kai Kreuzer - Initial contribution and API\n+ * @author Benjamin Lafois - Replaced tinyB with bluezDbus\n+ *\n+ */\n+@NonNullByDefault\n+public class BlueZBluetoothDevice extends BaseBluetoothDevice implements BlueZEventListener {\n+\n+    private final Logger logger = LoggerFactory.getLogger(BlueZBluetoothDevice.class);\n+\n+    private final ScheduledExecutorService scheduler = ThreadPoolManager.getScheduledPool(\"bluetooth\");\n+\n+    // Device from native lib\n+    private @Nullable BluetoothDevice device = null;\n+\n+    /**\n+     * Constructor\n+     *\n+     * @param adapter the bridge handler through which this device is connected\n+     * @param address the Bluetooth address of the device\n+     * @param name the name of the device\n+     */\n+    public BlueZBluetoothDevice(BlueZBridgeHandler adapter, BluetoothAddress address) {\n+        super(adapter, address);\n+        logger.debug(\"Creating DBusBlueZ device with address '{}'\", address);\n+    }\n+\n+    public synchronized void updateBlueZDevice(@Nullable BluetoothDevice blueZDevice) {\n+        if (this.device != null && this.device == blueZDevice) {\n+            return;\n+        }\n+        logger.debug(\"updateBlueZDevice({})\", blueZDevice);\n+\n+        this.device = blueZDevice;\n+\n+        if (blueZDevice == null) {\n+            return;\n+        }\n+\n+        Short rssi = blueZDevice.getRssi();\n+        if (rssi != null) {\n+            this.rssi = rssi.intValue();\n+        }\n+        this.name = blueZDevice.getName();\n+        Map<UInt16, byte[]> manData = blueZDevice.getManufacturerData();\n+        if (manData != null) {\n+            manData.entrySet().stream().map(Map.Entry::getKey).filter(Objects::nonNull).findFirst()\n+                    .ifPresent((UInt16 manufacturerId) ->\n+                    // Convert to unsigned int to match the convention in BluetoothCompanyIdentifiers\n+                    this.manufacturer = manufacturerId.intValue() & 0xFFFF);\n+        }\n+\n+        if (Boolean.TRUE.equals(blueZDevice.isConnected())) {\n+            setConnectionState(ConnectionState.CONNECTED);\n+        }\n+\n+        discoverServices();\n+    }\n+\n+    /**\n+     * Clean up and release memory.\n+     */\n+    @Override\n+    public void dispose() {\n+        BluetoothDevice dev = device;\n+        if (dev != null) {\n+            try {\n+                dev.getAdapter().removeDevice(dev.getRawDevice());\n+            } catch (DBusException ex) {\n+                if (ex.getMessage().contains(\"Does Not Exist\")) {\n+                    // this happens when the underlying device has already been removed\n+                    // but we don't have a way to check if that is the case beforehand so\n+                    // we will just eat the error here.\n+                } else {\n+                    logger.debug(\"Exception occurred when trying to remove inactive device '{}': {}\", address,\n+                            ex.getMessage());\n+                }\n+            } catch (RuntimeException ex) {\n+                // try to catch any other exceptions\n+                logger.debug(\"Exception occurred when trying to remove inactive device '{}': {}\", address,\n+                        ex.getMessage());\n+            }\n+        }\n+    }\n+\n+    private void setConnectionState(ConnectionState state) {\n+        if (this.connectionState != state) {\n+            this.connectionState = state;\n+            notifyListeners(BluetoothEventType.CONNECTION_STATE, new BluetoothConnectionStatusNotification(state));\n+        }\n+    }\n+\n+    @Override\n+    public boolean connect() {\n+        logger.debug(\"Connect({})\", device);\n+\n+        BluetoothDevice dev = device;\n+        if (dev != null) {\n+            if (Boolean.FALSE.equals(dev.isConnected())) {\n+                try {\n+                    boolean ret = dev.connect();\n+                    logger.debug(\"Connect result: {}\", ret);\n+                    return ret;\n+                } catch (NoReply e) {\n+                    // Have to double check because sometimes, exception but still worked\n+                    logger.debug(\"Got a timeout - but sometimes happen. Is Connected ? {}\", dev.isConnected());\n+                    if (Boolean.FALSE.equals(dev.isConnected())) {\n+\n+                        notifyListeners(BluetoothEventType.CONNECTION_STATE,\n+                                new BluetoothConnectionStatusNotification(ConnectionState.DISCONNECTED));\n+                        return false;\n+                    } else {\n+                        return true;\n+                    }\n+                } catch (DBusExecutionException e) {\n+                    // Catch \"software caused connection abort\"\n+                    return false;\n+                } catch (Exception e) {\n+                    logger.warn(\"error occured while trying to connect\", e);\n+                }\n+\n+            } else {\n+                logger.debug(\"Device was already connected\");\n+                // we might be stuck in another state atm so we need to trigger a connected in this case\n+                setConnectionState(ConnectionState.CONNECTED);\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    @Override\n+    public boolean disconnect() {\n+        BluetoothDevice dev = device;\n+        if (dev != null) {\n+            logger.debug(\"Disconnecting '{}'\", address);\n+            return dev.disconnect();\n+        }\n+        return false;\n+    }\n+\n+    private void ensureConnected() {\n+        BluetoothDevice dev = device;\n+        if (dev == null || !dev.isConnected()) {\n+            throw new IllegalStateException(\"DBusBlueZ device is not set or not connected\");\n+        }\n+    }\n+\n+    private @Nullable BluetoothGattCharacteristic getDBusBlueZCharacteristicByUUID(String uuid) {\n+        BluetoothDevice dev = device;\n+        if (dev == null) {\n+            return null;\n+        }\n+        for (BluetoothGattService service : dev.getGattServices()) {\n+            for (BluetoothGattCharacteristic c : service.getGattCharacteristics()) {\n+                if (c.getUuid().equalsIgnoreCase(uuid)) {\n+                    return c;\n+                }\n+            }\n+        }\n+        return null;\n+    }\n+\n+    private @Nullable BluetoothGattCharacteristic getDBusBlueZCharacteristicByDBusPath(String dBusPath) {\n+        BluetoothDevice dev = device;\n+        if (dev == null) {\n+            return null;\n+        }\n+        for (BluetoothGattService service : dev.getGattServices()) {\n+            if (dBusPath.startsWith(service.getDbusPath())) {\n+                for (BluetoothGattCharacteristic characteristic : service.getGattCharacteristics()) {\n+                    if (dBusPath.startsWith(characteristic.getDbusPath())) {\n+                        return characteristic;\n+                    }\n+                }\n+            }\n+        }\n+        return null;\n+    }\n+\n+    private @Nullable BluetoothGattDescriptor getDBusBlueZDescriptorByUUID(String uuid) {\n+        BluetoothDevice dev = device;\n+        if (dev == null) {\n+            return null;\n+        }\n+        for (BluetoothGattService service : dev.getGattServices()) {\n+            for (BluetoothGattCharacteristic c : service.getGattCharacteristics()) {\n+                for (BluetoothGattDescriptor d : c.getGattDescriptors()) {\n+                    if (d.getUuid().equalsIgnoreCase(uuid)) {\n+                        return d;\n+                    }\n+                }\n+            }\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public boolean enableNotifications(BluetoothCharacteristic characteristic) {\n+        ensureConnected();\n+\n+        BluetoothGattCharacteristic c = getDBusBlueZCharacteristicByUUID(characteristic.getUuid().toString());\n+        if (c != null) {\n+\n+            try {\n+                c.startNotify();\n+            } catch (DBusException e) {\n+                if (e.getMessage().contains(\"Already notifying\")) {\n+                    return false;\n+                } else if (e.getMessage().contains(\"In Progress\")) {\n+                    // let's retry in 10 seconds\n+                    scheduler.schedule(() -> enableNotifications(characteristic), 10, TimeUnit.SECONDS);\n+                } else {\n+                    logger.warn(\"Exception occurred while activating notifications on '{}'\", address, e);\n+                }\n+            }\n+            return true;\n+        } else {\n+            logger.warn(\"Characteristic '{}' is missing on device '{}'.\", characteristic.getUuid(), address);\n+            return false;\n+        }\n+    }\n+\n+    @Override\n+    public boolean writeCharacteristic(BluetoothCharacteristic characteristic) {\n+        logger.debug(\"writeCharacteristic()\");\n+\n+        ensureConnected();\n+\n+        BluetoothGattCharacteristic c = getDBusBlueZCharacteristicByUUID(characteristic.getUuid().toString());\n+        if (c == null) {\n+            logger.warn(\"Characteristic '{}' is missing on device '{}'.\", characteristic.getUuid(), address);\n+            return false;\n+        }\n+\n+        scheduler.submit(() -> {\n+            try {\n+                c.writeValue(characteristic.getByteValue(), null);\n+                notifyListeners(BluetoothEventType.CHARACTERISTIC_WRITE_COMPLETE, characteristic,\n+                        BluetoothCompletionStatus.SUCCESS);\n+\n+            } catch (DBusException e) {\n+                logger.debug(\"Exception occurred when trying to write characteristic '{}': {}\",\n+                        characteristic.getUuid(), e.getMessage());\n+                notifyListeners(BluetoothEventType.CHARACTERISTIC_WRITE_COMPLETE, characteristic,\n+                        BluetoothCompletionStatus.ERROR);\n+            }\n+        });\n+        return true;\n+    }\n+\n+    @Override\n+    public void onDBusBlueZEvent(BlueZEvent event) {\n+        logger.debug(\"Unsupported event: {}\", event);\n+    }\n+\n+    @Override\n+    public void onServicesResolved(ServicesResolvedEvent event) {\n+        if (event.isResolved()) {\n+            notifyListeners(BluetoothEventType.SERVICES_DISCOVERED);\n+        }\n+    }\n+\n+    @Override\n+    public void onNameUpdate(NameEvent event) {\n+        BluetoothScanNotification notification = new BluetoothScanNotification();\n+        notification.setDeviceName(event.getName());\n+        notifyListeners(BluetoothEventType.SCAN_RECORD, notification);\n+    }\n+\n+    @Override\n+    public void onManufacturerDataUpdate(ManufacturerDataEvent event) {\n+        for (Map.Entry<Short, byte[]> entry : event.getData().entrySet()) {\n+            BluetoothScanNotification notification = new BluetoothScanNotification();\n+            byte[] data = new byte[entry.getValue().length + 2];\n+            data[0] = (byte) (entry.getKey() & 0xFF);\n+            data[1] = (byte) (entry.getKey() >>> 8);\n+\n+            System.arraycopy(entry.getValue(), 0, data, 2, entry.getValue().length);\n+\n+            if (logger.isDebugEnabled()) {\n+                logger.debug(\"Received manufacturer data for '{}': {}\", address, HexUtils.bytesToHex(data, \" \"));\n+            }\n+\n+            notification.setManufacturerData(data);\n+            notifyListeners(BluetoothEventType.SCAN_RECORD, notification);\n+        }\n+    }\n+\n+    @Override\n+    public void onTxPowerUpdate(TXPowerEvent event) {\n+        this.txPower = (int) event.getTxPower();\n+    }\n+\n+    @Override\n+    public void onCharacteristicNotify(CharacteristicUpdateEvent event) {\n+        // Here it is a bit special - as the event is linked to the DBUS path, not characteristic UUID.\n+        // So we need to find the characteristic by its DBUS path.\n+        BluetoothGattCharacteristic characteristic = getDBusBlueZCharacteristicByDBusPath(event.getDbusPath());\n+        if (characteristic == null) {\n+            logger.info(\"Received a notification for a characteristic not found on device.\");\n+            return;\n+        }\n+        BluetoothCharacteristic c = getCharacteristic(UUID.fromString(characteristic.getUuid()));\n+        if (c != null) {\n+            c.setValue(event.getData());\n+            notifyListeners(BluetoothEventType.CHARACTERISTIC_UPDATED, c, BluetoothCompletionStatus.SUCCESS);\n+            logger.debug(\"Has notified that a characteristic has been updated\");\n+        }\n+    }\n+\n+    @Override\n+    public void onRssiUpdate(RssiEvent event) {\n+        int rssiTmp = event.getRssi();\n+        this.rssi = rssiTmp;\n+        BluetoothScanNotification notification = new BluetoothScanNotification();\n+        notification.setRssi(rssiTmp);\n+        notifyListeners(BluetoothEventType.SCAN_RECORD, notification);\n+    }\n+\n+    @Override\n+    public void onConnectedStatusUpdate(ConnectedEvent event) {\n+        this.connectionState = event.isConnected() ? ConnectionState.CONNECTED : ConnectionState.DISCONNECTED;\n+        notifyListeners(BluetoothEventType.CONNECTION_STATE,\n+                new BluetoothConnectionStatusNotification(connectionState));\n+    }\n+\n+    @Override\n+    public boolean discoverServices() {\n+        BluetoothDevice dev = device;\n+        if (dev == null) {\n+            return false;\n+        }\n+        if (dev.getGattServices().size() > getServices().size()) {\n+\n+            for (BluetoothGattService dBusBlueZService : dev.getGattServices()) {\n+                BluetoothService service = new BluetoothService(UUID.fromString(dBusBlueZService.getUuid()),\n+                        dBusBlueZService.isPrimary());\n+\n+                for (BluetoothGattCharacteristic dBusBlueZCharacteristic : dBusBlueZService.getGattCharacteristics()) {\n+                    BluetoothCharacteristic characteristic = new BluetoothCharacteristic(\n+                            UUID.fromString(dBusBlueZCharacteristic.getUuid()), 0);\n+\n+                    for (BluetoothGattDescriptor dBusBlueZDescriptor : dBusBlueZCharacteristic.getGattDescriptors()) {\n+                        BluetoothDescriptor descriptor = new BluetoothDescriptor(characteristic,\n+                                UUID.fromString(dBusBlueZDescriptor.getUuid()));\n+                        characteristic.addDescriptor(descriptor);\n+                    }\n+\n+                    service.addCharacteristic(characteristic);\n+                }\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9c2c484c0a68abcdb7f6e511a0635e2dd9353821"}, "originalPosition": 408}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTIwNDE4MA==", "bodyText": "done", "url": "https://github.com/openhab/openhab-addons/pull/8819#discussion_r511204180", "createdAt": "2020-10-24T00:11:41Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.bluetooth.bluez/src/main/java/org/openhab/binding/bluetooth/bluez/internal/BlueZBluetoothDevice.java", "diffHunk": "@@ -0,0 +1,474 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bluetooth.bluez.internal;\n+\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.UUID;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.bluez.exceptions.BluezFailedException;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.freedesktop.dbus.errors.NoReply;\n+import org.freedesktop.dbus.exceptions.DBusException;\n+import org.freedesktop.dbus.exceptions.DBusExecutionException;\n+import org.freedesktop.dbus.types.UInt16;\n+import org.openhab.binding.bluetooth.BaseBluetoothDevice;\n+import org.openhab.binding.bluetooth.BluetoothAddress;\n+import org.openhab.binding.bluetooth.BluetoothCharacteristic;\n+import org.openhab.binding.bluetooth.BluetoothCompletionStatus;\n+import org.openhab.binding.bluetooth.BluetoothDescriptor;\n+import org.openhab.binding.bluetooth.BluetoothService;\n+import org.openhab.binding.bluetooth.bluez.internal.events.BlueZEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.BlueZEventListener;\n+import org.openhab.binding.bluetooth.bluez.internal.events.CharacteristicUpdateEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.ConnectedEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.ManufacturerDataEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.NameEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.RssiEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.ServicesResolvedEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.TXPowerEvent;\n+import org.openhab.binding.bluetooth.notification.BluetoothConnectionStatusNotification;\n+import org.openhab.binding.bluetooth.notification.BluetoothScanNotification;\n+import org.openhab.core.common.ThreadPoolManager;\n+import org.openhab.core.util.HexUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.github.hypfvieh.bluetooth.wrapper.BluetoothDevice;\n+import com.github.hypfvieh.bluetooth.wrapper.BluetoothGattCharacteristic;\n+import com.github.hypfvieh.bluetooth.wrapper.BluetoothGattDescriptor;\n+import com.github.hypfvieh.bluetooth.wrapper.BluetoothGattService;\n+\n+/**\n+ * Implementation of BluetoothDevice for BlueZ via DBus-BlueZ API\n+ *\n+ * @author Kai Kreuzer - Initial contribution and API\n+ * @author Benjamin Lafois - Replaced tinyB with bluezDbus\n+ *\n+ */\n+@NonNullByDefault\n+public class BlueZBluetoothDevice extends BaseBluetoothDevice implements BlueZEventListener {\n+\n+    private final Logger logger = LoggerFactory.getLogger(BlueZBluetoothDevice.class);\n+\n+    private final ScheduledExecutorService scheduler = ThreadPoolManager.getScheduledPool(\"bluetooth\");\n+\n+    // Device from native lib\n+    private @Nullable BluetoothDevice device = null;\n+\n+    /**\n+     * Constructor\n+     *\n+     * @param adapter the bridge handler through which this device is connected\n+     * @param address the Bluetooth address of the device\n+     * @param name the name of the device\n+     */\n+    public BlueZBluetoothDevice(BlueZBridgeHandler adapter, BluetoothAddress address) {\n+        super(adapter, address);\n+        logger.debug(\"Creating DBusBlueZ device with address '{}'\", address);\n+    }\n+\n+    public synchronized void updateBlueZDevice(@Nullable BluetoothDevice blueZDevice) {\n+        if (this.device != null && this.device == blueZDevice) {\n+            return;\n+        }\n+        logger.debug(\"updateBlueZDevice({})\", blueZDevice);\n+\n+        this.device = blueZDevice;\n+\n+        if (blueZDevice == null) {\n+            return;\n+        }\n+\n+        Short rssi = blueZDevice.getRssi();\n+        if (rssi != null) {\n+            this.rssi = rssi.intValue();\n+        }\n+        this.name = blueZDevice.getName();\n+        Map<UInt16, byte[]> manData = blueZDevice.getManufacturerData();\n+        if (manData != null) {\n+            manData.entrySet().stream().map(Map.Entry::getKey).filter(Objects::nonNull).findFirst()\n+                    .ifPresent((UInt16 manufacturerId) ->\n+                    // Convert to unsigned int to match the convention in BluetoothCompanyIdentifiers\n+                    this.manufacturer = manufacturerId.intValue() & 0xFFFF);\n+        }\n+\n+        if (Boolean.TRUE.equals(blueZDevice.isConnected())) {\n+            setConnectionState(ConnectionState.CONNECTED);\n+        }\n+\n+        discoverServices();\n+    }\n+\n+    /**\n+     * Clean up and release memory.\n+     */\n+    @Override\n+    public void dispose() {\n+        BluetoothDevice dev = device;\n+        if (dev != null) {\n+            try {\n+                dev.getAdapter().removeDevice(dev.getRawDevice());\n+            } catch (DBusException ex) {\n+                if (ex.getMessage().contains(\"Does Not Exist\")) {\n+                    // this happens when the underlying device has already been removed\n+                    // but we don't have a way to check if that is the case beforehand so\n+                    // we will just eat the error here.\n+                } else {\n+                    logger.debug(\"Exception occurred when trying to remove inactive device '{}': {}\", address,\n+                            ex.getMessage());\n+                }\n+            } catch (RuntimeException ex) {\n+                // try to catch any other exceptions\n+                logger.debug(\"Exception occurred when trying to remove inactive device '{}': {}\", address,\n+                        ex.getMessage());\n+            }\n+        }\n+    }\n+\n+    private void setConnectionState(ConnectionState state) {\n+        if (this.connectionState != state) {\n+            this.connectionState = state;\n+            notifyListeners(BluetoothEventType.CONNECTION_STATE, new BluetoothConnectionStatusNotification(state));\n+        }\n+    }\n+\n+    @Override\n+    public boolean connect() {\n+        logger.debug(\"Connect({})\", device);\n+\n+        BluetoothDevice dev = device;\n+        if (dev != null) {\n+            if (Boolean.FALSE.equals(dev.isConnected())) {\n+                try {\n+                    boolean ret = dev.connect();\n+                    logger.debug(\"Connect result: {}\", ret);\n+                    return ret;\n+                } catch (NoReply e) {\n+                    // Have to double check because sometimes, exception but still worked\n+                    logger.debug(\"Got a timeout - but sometimes happen. Is Connected ? {}\", dev.isConnected());\n+                    if (Boolean.FALSE.equals(dev.isConnected())) {\n+\n+                        notifyListeners(BluetoothEventType.CONNECTION_STATE,\n+                                new BluetoothConnectionStatusNotification(ConnectionState.DISCONNECTED));\n+                        return false;\n+                    } else {\n+                        return true;\n+                    }\n+                } catch (DBusExecutionException e) {\n+                    // Catch \"software caused connection abort\"\n+                    return false;\n+                } catch (Exception e) {\n+                    logger.warn(\"error occured while trying to connect\", e);\n+                }\n+\n+            } else {\n+                logger.debug(\"Device was already connected\");\n+                // we might be stuck in another state atm so we need to trigger a connected in this case\n+                setConnectionState(ConnectionState.CONNECTED);\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    @Override\n+    public boolean disconnect() {\n+        BluetoothDevice dev = device;\n+        if (dev != null) {\n+            logger.debug(\"Disconnecting '{}'\", address);\n+            return dev.disconnect();\n+        }\n+        return false;\n+    }\n+\n+    private void ensureConnected() {\n+        BluetoothDevice dev = device;\n+        if (dev == null || !dev.isConnected()) {\n+            throw new IllegalStateException(\"DBusBlueZ device is not set or not connected\");\n+        }\n+    }\n+\n+    private @Nullable BluetoothGattCharacteristic getDBusBlueZCharacteristicByUUID(String uuid) {\n+        BluetoothDevice dev = device;\n+        if (dev == null) {\n+            return null;\n+        }\n+        for (BluetoothGattService service : dev.getGattServices()) {\n+            for (BluetoothGattCharacteristic c : service.getGattCharacteristics()) {\n+                if (c.getUuid().equalsIgnoreCase(uuid)) {\n+                    return c;\n+                }\n+            }\n+        }\n+        return null;\n+    }\n+\n+    private @Nullable BluetoothGattCharacteristic getDBusBlueZCharacteristicByDBusPath(String dBusPath) {\n+        BluetoothDevice dev = device;\n+        if (dev == null) {\n+            return null;\n+        }\n+        for (BluetoothGattService service : dev.getGattServices()) {\n+            if (dBusPath.startsWith(service.getDbusPath())) {\n+                for (BluetoothGattCharacteristic characteristic : service.getGattCharacteristics()) {\n+                    if (dBusPath.startsWith(characteristic.getDbusPath())) {\n+                        return characteristic;\n+                    }\n+                }\n+            }\n+        }\n+        return null;\n+    }\n+\n+    private @Nullable BluetoothGattDescriptor getDBusBlueZDescriptorByUUID(String uuid) {\n+        BluetoothDevice dev = device;\n+        if (dev == null) {\n+            return null;\n+        }\n+        for (BluetoothGattService service : dev.getGattServices()) {\n+            for (BluetoothGattCharacteristic c : service.getGattCharacteristics()) {\n+                for (BluetoothGattDescriptor d : c.getGattDescriptors()) {\n+                    if (d.getUuid().equalsIgnoreCase(uuid)) {\n+                        return d;\n+                    }\n+                }\n+            }\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public boolean enableNotifications(BluetoothCharacteristic characteristic) {\n+        ensureConnected();\n+\n+        BluetoothGattCharacteristic c = getDBusBlueZCharacteristicByUUID(characteristic.getUuid().toString());\n+        if (c != null) {\n+\n+            try {\n+                c.startNotify();\n+            } catch (DBusException e) {\n+                if (e.getMessage().contains(\"Already notifying\")) {\n+                    return false;\n+                } else if (e.getMessage().contains(\"In Progress\")) {\n+                    // let's retry in 10 seconds\n+                    scheduler.schedule(() -> enableNotifications(characteristic), 10, TimeUnit.SECONDS);\n+                } else {\n+                    logger.warn(\"Exception occurred while activating notifications on '{}'\", address, e);\n+                }\n+            }\n+            return true;\n+        } else {\n+            logger.warn(\"Characteristic '{}' is missing on device '{}'.\", characteristic.getUuid(), address);\n+            return false;\n+        }\n+    }\n+\n+    @Override\n+    public boolean writeCharacteristic(BluetoothCharacteristic characteristic) {\n+        logger.debug(\"writeCharacteristic()\");\n+\n+        ensureConnected();\n+\n+        BluetoothGattCharacteristic c = getDBusBlueZCharacteristicByUUID(characteristic.getUuid().toString());\n+        if (c == null) {\n+            logger.warn(\"Characteristic '{}' is missing on device '{}'.\", characteristic.getUuid(), address);\n+            return false;\n+        }\n+\n+        scheduler.submit(() -> {\n+            try {\n+                c.writeValue(characteristic.getByteValue(), null);\n+                notifyListeners(BluetoothEventType.CHARACTERISTIC_WRITE_COMPLETE, characteristic,\n+                        BluetoothCompletionStatus.SUCCESS);\n+\n+            } catch (DBusException e) {\n+                logger.debug(\"Exception occurred when trying to write characteristic '{}': {}\",\n+                        characteristic.getUuid(), e.getMessage());\n+                notifyListeners(BluetoothEventType.CHARACTERISTIC_WRITE_COMPLETE, characteristic,\n+                        BluetoothCompletionStatus.ERROR);\n+            }\n+        });\n+        return true;\n+    }\n+\n+    @Override\n+    public void onDBusBlueZEvent(BlueZEvent event) {\n+        logger.debug(\"Unsupported event: {}\", event);\n+    }\n+\n+    @Override\n+    public void onServicesResolved(ServicesResolvedEvent event) {\n+        if (event.isResolved()) {\n+            notifyListeners(BluetoothEventType.SERVICES_DISCOVERED);\n+        }\n+    }\n+\n+    @Override\n+    public void onNameUpdate(NameEvent event) {\n+        BluetoothScanNotification notification = new BluetoothScanNotification();\n+        notification.setDeviceName(event.getName());\n+        notifyListeners(BluetoothEventType.SCAN_RECORD, notification);\n+    }\n+\n+    @Override\n+    public void onManufacturerDataUpdate(ManufacturerDataEvent event) {\n+        for (Map.Entry<Short, byte[]> entry : event.getData().entrySet()) {\n+            BluetoothScanNotification notification = new BluetoothScanNotification();\n+            byte[] data = new byte[entry.getValue().length + 2];\n+            data[0] = (byte) (entry.getKey() & 0xFF);\n+            data[1] = (byte) (entry.getKey() >>> 8);\n+\n+            System.arraycopy(entry.getValue(), 0, data, 2, entry.getValue().length);\n+\n+            if (logger.isDebugEnabled()) {\n+                logger.debug(\"Received manufacturer data for '{}': {}\", address, HexUtils.bytesToHex(data, \" \"));\n+            }\n+\n+            notification.setManufacturerData(data);\n+            notifyListeners(BluetoothEventType.SCAN_RECORD, notification);\n+        }\n+    }\n+\n+    @Override\n+    public void onTxPowerUpdate(TXPowerEvent event) {\n+        this.txPower = (int) event.getTxPower();\n+    }\n+\n+    @Override\n+    public void onCharacteristicNotify(CharacteristicUpdateEvent event) {\n+        // Here it is a bit special - as the event is linked to the DBUS path, not characteristic UUID.\n+        // So we need to find the characteristic by its DBUS path.\n+        BluetoothGattCharacteristic characteristic = getDBusBlueZCharacteristicByDBusPath(event.getDbusPath());\n+        if (characteristic == null) {\n+            logger.info(\"Received a notification for a characteristic not found on device.\");\n+            return;\n+        }\n+        BluetoothCharacteristic c = getCharacteristic(UUID.fromString(characteristic.getUuid()));\n+        if (c != null) {\n+            c.setValue(event.getData());\n+            notifyListeners(BluetoothEventType.CHARACTERISTIC_UPDATED, c, BluetoothCompletionStatus.SUCCESS);\n+            logger.debug(\"Has notified that a characteristic has been updated\");\n+        }\n+    }\n+\n+    @Override\n+    public void onRssiUpdate(RssiEvent event) {\n+        int rssiTmp = event.getRssi();\n+        this.rssi = rssiTmp;\n+        BluetoothScanNotification notification = new BluetoothScanNotification();\n+        notification.setRssi(rssiTmp);\n+        notifyListeners(BluetoothEventType.SCAN_RECORD, notification);\n+    }\n+\n+    @Override\n+    public void onConnectedStatusUpdate(ConnectedEvent event) {\n+        this.connectionState = event.isConnected() ? ConnectionState.CONNECTED : ConnectionState.DISCONNECTED;\n+        notifyListeners(BluetoothEventType.CONNECTION_STATE,\n+                new BluetoothConnectionStatusNotification(connectionState));\n+    }\n+\n+    @Override\n+    public boolean discoverServices() {\n+        BluetoothDevice dev = device;\n+        if (dev == null) {\n+            return false;\n+        }\n+        if (dev.getGattServices().size() > getServices().size()) {\n+\n+            for (BluetoothGattService dBusBlueZService : dev.getGattServices()) {\n+                BluetoothService service = new BluetoothService(UUID.fromString(dBusBlueZService.getUuid()),\n+                        dBusBlueZService.isPrimary());\n+\n+                for (BluetoothGattCharacteristic dBusBlueZCharacteristic : dBusBlueZService.getGattCharacteristics()) {\n+                    BluetoothCharacteristic characteristic = new BluetoothCharacteristic(\n+                            UUID.fromString(dBusBlueZCharacteristic.getUuid()), 0);\n+\n+                    for (BluetoothGattDescriptor dBusBlueZDescriptor : dBusBlueZCharacteristic.getGattDescriptors()) {\n+                        BluetoothDescriptor descriptor = new BluetoothDescriptor(characteristic,\n+                                UUID.fromString(dBusBlueZDescriptor.getUuid()));\n+                        characteristic.addDescriptor(descriptor);\n+                    }\n+\n+                    service.addCharacteristic(characteristic);\n+                }\n+", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTE2OTA3OQ=="}, "originalCommit": {"oid": "9c2c484c0a68abcdb7f6e511a0635e2dd9353821"}, "originalPosition": 408}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIwMjE3NTMwOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.bluetooth.bluez/src/main/java/org/openhab/binding/bluetooth/bluez/internal/BlueZBluetoothDevice.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QyMTo0NToxNVrOHnfSfQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QyMzoxOToyOFrOHng0nA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTE2OTE0OQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change", "url": "https://github.com/openhab/openhab-addons/pull/8819#discussion_r511169149", "createdAt": "2020-10-23T21:45:15Z", "author": {"login": "kaikreuzer"}, "path": "bundles/org.openhab.binding.bluetooth.bluez/src/main/java/org/openhab/binding/bluetooth/bluez/internal/BlueZBluetoothDevice.java", "diffHunk": "@@ -0,0 +1,474 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bluetooth.bluez.internal;\n+\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.UUID;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.bluez.exceptions.BluezFailedException;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.freedesktop.dbus.errors.NoReply;\n+import org.freedesktop.dbus.exceptions.DBusException;\n+import org.freedesktop.dbus.exceptions.DBusExecutionException;\n+import org.freedesktop.dbus.types.UInt16;\n+import org.openhab.binding.bluetooth.BaseBluetoothDevice;\n+import org.openhab.binding.bluetooth.BluetoothAddress;\n+import org.openhab.binding.bluetooth.BluetoothCharacteristic;\n+import org.openhab.binding.bluetooth.BluetoothCompletionStatus;\n+import org.openhab.binding.bluetooth.BluetoothDescriptor;\n+import org.openhab.binding.bluetooth.BluetoothService;\n+import org.openhab.binding.bluetooth.bluez.internal.events.BlueZEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.BlueZEventListener;\n+import org.openhab.binding.bluetooth.bluez.internal.events.CharacteristicUpdateEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.ConnectedEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.ManufacturerDataEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.NameEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.RssiEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.ServicesResolvedEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.TXPowerEvent;\n+import org.openhab.binding.bluetooth.notification.BluetoothConnectionStatusNotification;\n+import org.openhab.binding.bluetooth.notification.BluetoothScanNotification;\n+import org.openhab.core.common.ThreadPoolManager;\n+import org.openhab.core.util.HexUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.github.hypfvieh.bluetooth.wrapper.BluetoothDevice;\n+import com.github.hypfvieh.bluetooth.wrapper.BluetoothGattCharacteristic;\n+import com.github.hypfvieh.bluetooth.wrapper.BluetoothGattDescriptor;\n+import com.github.hypfvieh.bluetooth.wrapper.BluetoothGattService;\n+\n+/**\n+ * Implementation of BluetoothDevice for BlueZ via DBus-BlueZ API\n+ *\n+ * @author Kai Kreuzer - Initial contribution and API\n+ * @author Benjamin Lafois - Replaced tinyB with bluezDbus\n+ *\n+ */\n+@NonNullByDefault\n+public class BlueZBluetoothDevice extends BaseBluetoothDevice implements BlueZEventListener {\n+\n+    private final Logger logger = LoggerFactory.getLogger(BlueZBluetoothDevice.class);\n+\n+    private final ScheduledExecutorService scheduler = ThreadPoolManager.getScheduledPool(\"bluetooth\");\n+\n+    // Device from native lib\n+    private @Nullable BluetoothDevice device = null;\n+\n+    /**\n+     * Constructor\n+     *\n+     * @param adapter the bridge handler through which this device is connected\n+     * @param address the Bluetooth address of the device\n+     * @param name the name of the device\n+     */\n+    public BlueZBluetoothDevice(BlueZBridgeHandler adapter, BluetoothAddress address) {\n+        super(adapter, address);\n+        logger.debug(\"Creating DBusBlueZ device with address '{}'\", address);\n+    }\n+\n+    public synchronized void updateBlueZDevice(@Nullable BluetoothDevice blueZDevice) {\n+        if (this.device != null && this.device == blueZDevice) {\n+            return;\n+        }\n+        logger.debug(\"updateBlueZDevice({})\", blueZDevice);\n+\n+        this.device = blueZDevice;\n+\n+        if (blueZDevice == null) {\n+            return;\n+        }\n+\n+        Short rssi = blueZDevice.getRssi();\n+        if (rssi != null) {\n+            this.rssi = rssi.intValue();\n+        }\n+        this.name = blueZDevice.getName();\n+        Map<UInt16, byte[]> manData = blueZDevice.getManufacturerData();\n+        if (manData != null) {\n+            manData.entrySet().stream().map(Map.Entry::getKey).filter(Objects::nonNull).findFirst()\n+                    .ifPresent((UInt16 manufacturerId) ->\n+                    // Convert to unsigned int to match the convention in BluetoothCompanyIdentifiers\n+                    this.manufacturer = manufacturerId.intValue() & 0xFFFF);\n+        }\n+\n+        if (Boolean.TRUE.equals(blueZDevice.isConnected())) {\n+            setConnectionState(ConnectionState.CONNECTED);\n+        }\n+\n+        discoverServices();\n+    }\n+\n+    /**\n+     * Clean up and release memory.\n+     */\n+    @Override\n+    public void dispose() {\n+        BluetoothDevice dev = device;\n+        if (dev != null) {\n+            try {\n+                dev.getAdapter().removeDevice(dev.getRawDevice());\n+            } catch (DBusException ex) {\n+                if (ex.getMessage().contains(\"Does Not Exist\")) {\n+                    // this happens when the underlying device has already been removed\n+                    // but we don't have a way to check if that is the case beforehand so\n+                    // we will just eat the error here.\n+                } else {\n+                    logger.debug(\"Exception occurred when trying to remove inactive device '{}': {}\", address,\n+                            ex.getMessage());\n+                }\n+            } catch (RuntimeException ex) {\n+                // try to catch any other exceptions\n+                logger.debug(\"Exception occurred when trying to remove inactive device '{}': {}\", address,\n+                        ex.getMessage());\n+            }\n+        }\n+    }\n+\n+    private void setConnectionState(ConnectionState state) {\n+        if (this.connectionState != state) {\n+            this.connectionState = state;\n+            notifyListeners(BluetoothEventType.CONNECTION_STATE, new BluetoothConnectionStatusNotification(state));\n+        }\n+    }\n+\n+    @Override\n+    public boolean connect() {\n+        logger.debug(\"Connect({})\", device);\n+\n+        BluetoothDevice dev = device;\n+        if (dev != null) {\n+            if (Boolean.FALSE.equals(dev.isConnected())) {\n+                try {\n+                    boolean ret = dev.connect();\n+                    logger.debug(\"Connect result: {}\", ret);\n+                    return ret;\n+                } catch (NoReply e) {\n+                    // Have to double check because sometimes, exception but still worked\n+                    logger.debug(\"Got a timeout - but sometimes happen. Is Connected ? {}\", dev.isConnected());\n+                    if (Boolean.FALSE.equals(dev.isConnected())) {\n+\n+                        notifyListeners(BluetoothEventType.CONNECTION_STATE,\n+                                new BluetoothConnectionStatusNotification(ConnectionState.DISCONNECTED));\n+                        return false;\n+                    } else {\n+                        return true;\n+                    }\n+                } catch (DBusExecutionException e) {\n+                    // Catch \"software caused connection abort\"\n+                    return false;\n+                } catch (Exception e) {\n+                    logger.warn(\"error occured while trying to connect\", e);\n+                }\n+\n+            } else {\n+                logger.debug(\"Device was already connected\");\n+                // we might be stuck in another state atm so we need to trigger a connected in this case\n+                setConnectionState(ConnectionState.CONNECTED);\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    @Override\n+    public boolean disconnect() {\n+        BluetoothDevice dev = device;\n+        if (dev != null) {\n+            logger.debug(\"Disconnecting '{}'\", address);\n+            return dev.disconnect();\n+        }\n+        return false;\n+    }\n+\n+    private void ensureConnected() {\n+        BluetoothDevice dev = device;\n+        if (dev == null || !dev.isConnected()) {\n+            throw new IllegalStateException(\"DBusBlueZ device is not set or not connected\");\n+        }\n+    }\n+\n+    private @Nullable BluetoothGattCharacteristic getDBusBlueZCharacteristicByUUID(String uuid) {\n+        BluetoothDevice dev = device;\n+        if (dev == null) {\n+            return null;\n+        }\n+        for (BluetoothGattService service : dev.getGattServices()) {\n+            for (BluetoothGattCharacteristic c : service.getGattCharacteristics()) {\n+                if (c.getUuid().equalsIgnoreCase(uuid)) {\n+                    return c;\n+                }\n+            }\n+        }\n+        return null;\n+    }\n+\n+    private @Nullable BluetoothGattCharacteristic getDBusBlueZCharacteristicByDBusPath(String dBusPath) {\n+        BluetoothDevice dev = device;\n+        if (dev == null) {\n+            return null;\n+        }\n+        for (BluetoothGattService service : dev.getGattServices()) {\n+            if (dBusPath.startsWith(service.getDbusPath())) {\n+                for (BluetoothGattCharacteristic characteristic : service.getGattCharacteristics()) {\n+                    if (dBusPath.startsWith(characteristic.getDbusPath())) {\n+                        return characteristic;\n+                    }\n+                }\n+            }\n+        }\n+        return null;\n+    }\n+\n+    private @Nullable BluetoothGattDescriptor getDBusBlueZDescriptorByUUID(String uuid) {\n+        BluetoothDevice dev = device;\n+        if (dev == null) {\n+            return null;\n+        }\n+        for (BluetoothGattService service : dev.getGattServices()) {\n+            for (BluetoothGattCharacteristic c : service.getGattCharacteristics()) {\n+                for (BluetoothGattDescriptor d : c.getGattDescriptors()) {\n+                    if (d.getUuid().equalsIgnoreCase(uuid)) {\n+                        return d;\n+                    }\n+                }\n+            }\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public boolean enableNotifications(BluetoothCharacteristic characteristic) {\n+        ensureConnected();\n+\n+        BluetoothGattCharacteristic c = getDBusBlueZCharacteristicByUUID(characteristic.getUuid().toString());\n+        if (c != null) {\n+\n+            try {\n+                c.startNotify();\n+            } catch (DBusException e) {\n+                if (e.getMessage().contains(\"Already notifying\")) {\n+                    return false;\n+                } else if (e.getMessage().contains(\"In Progress\")) {\n+                    // let's retry in 10 seconds\n+                    scheduler.schedule(() -> enableNotifications(characteristic), 10, TimeUnit.SECONDS);\n+                } else {\n+                    logger.warn(\"Exception occurred while activating notifications on '{}'\", address, e);\n+                }\n+            }\n+            return true;\n+        } else {\n+            logger.warn(\"Characteristic '{}' is missing on device '{}'.\", characteristic.getUuid(), address);\n+            return false;\n+        }\n+    }\n+\n+    @Override\n+    public boolean writeCharacteristic(BluetoothCharacteristic characteristic) {\n+        logger.debug(\"writeCharacteristic()\");\n+\n+        ensureConnected();\n+\n+        BluetoothGattCharacteristic c = getDBusBlueZCharacteristicByUUID(characteristic.getUuid().toString());\n+        if (c == null) {\n+            logger.warn(\"Characteristic '{}' is missing on device '{}'.\", characteristic.getUuid(), address);\n+            return false;\n+        }\n+\n+        scheduler.submit(() -> {\n+            try {\n+                c.writeValue(characteristic.getByteValue(), null);\n+                notifyListeners(BluetoothEventType.CHARACTERISTIC_WRITE_COMPLETE, characteristic,\n+                        BluetoothCompletionStatus.SUCCESS);\n+\n+            } catch (DBusException e) {\n+                logger.debug(\"Exception occurred when trying to write characteristic '{}': {}\",\n+                        characteristic.getUuid(), e.getMessage());\n+                notifyListeners(BluetoothEventType.CHARACTERISTIC_WRITE_COMPLETE, characteristic,\n+                        BluetoothCompletionStatus.ERROR);\n+            }\n+        });\n+        return true;\n+    }\n+\n+    @Override\n+    public void onDBusBlueZEvent(BlueZEvent event) {\n+        logger.debug(\"Unsupported event: {}\", event);\n+    }\n+\n+    @Override\n+    public void onServicesResolved(ServicesResolvedEvent event) {\n+        if (event.isResolved()) {\n+            notifyListeners(BluetoothEventType.SERVICES_DISCOVERED);\n+        }\n+    }\n+\n+    @Override\n+    public void onNameUpdate(NameEvent event) {\n+        BluetoothScanNotification notification = new BluetoothScanNotification();\n+        notification.setDeviceName(event.getName());\n+        notifyListeners(BluetoothEventType.SCAN_RECORD, notification);\n+    }\n+\n+    @Override\n+    public void onManufacturerDataUpdate(ManufacturerDataEvent event) {\n+        for (Map.Entry<Short, byte[]> entry : event.getData().entrySet()) {\n+            BluetoothScanNotification notification = new BluetoothScanNotification();\n+            byte[] data = new byte[entry.getValue().length + 2];\n+            data[0] = (byte) (entry.getKey() & 0xFF);\n+            data[1] = (byte) (entry.getKey() >>> 8);\n+\n+            System.arraycopy(entry.getValue(), 0, data, 2, entry.getValue().length);\n+\n+            if (logger.isDebugEnabled()) {\n+                logger.debug(\"Received manufacturer data for '{}': {}\", address, HexUtils.bytesToHex(data, \" \"));\n+            }\n+\n+            notification.setManufacturerData(data);\n+            notifyListeners(BluetoothEventType.SCAN_RECORD, notification);\n+        }\n+    }\n+\n+    @Override\n+    public void onTxPowerUpdate(TXPowerEvent event) {\n+        this.txPower = (int) event.getTxPower();\n+    }\n+\n+    @Override\n+    public void onCharacteristicNotify(CharacteristicUpdateEvent event) {\n+        // Here it is a bit special - as the event is linked to the DBUS path, not characteristic UUID.\n+        // So we need to find the characteristic by its DBUS path.\n+        BluetoothGattCharacteristic characteristic = getDBusBlueZCharacteristicByDBusPath(event.getDbusPath());\n+        if (characteristic == null) {\n+            logger.info(\"Received a notification for a characteristic not found on device.\");\n+            return;\n+        }\n+        BluetoothCharacteristic c = getCharacteristic(UUID.fromString(characteristic.getUuid()));\n+        if (c != null) {\n+            c.setValue(event.getData());\n+            notifyListeners(BluetoothEventType.CHARACTERISTIC_UPDATED, c, BluetoothCompletionStatus.SUCCESS);\n+            logger.debug(\"Has notified that a characteristic has been updated\");\n+        }\n+    }\n+\n+    @Override\n+    public void onRssiUpdate(RssiEvent event) {\n+        int rssiTmp = event.getRssi();\n+        this.rssi = rssiTmp;\n+        BluetoothScanNotification notification = new BluetoothScanNotification();\n+        notification.setRssi(rssiTmp);\n+        notifyListeners(BluetoothEventType.SCAN_RECORD, notification);\n+    }\n+\n+    @Override\n+    public void onConnectedStatusUpdate(ConnectedEvent event) {\n+        this.connectionState = event.isConnected() ? ConnectionState.CONNECTED : ConnectionState.DISCONNECTED;\n+        notifyListeners(BluetoothEventType.CONNECTION_STATE,\n+                new BluetoothConnectionStatusNotification(connectionState));\n+    }\n+\n+    @Override\n+    public boolean discoverServices() {\n+        BluetoothDevice dev = device;\n+        if (dev == null) {\n+            return false;\n+        }\n+        if (dev.getGattServices().size() > getServices().size()) {\n+\n+            for (BluetoothGattService dBusBlueZService : dev.getGattServices()) {\n+                BluetoothService service = new BluetoothService(UUID.fromString(dBusBlueZService.getUuid()),\n+                        dBusBlueZService.isPrimary());\n+\n+                for (BluetoothGattCharacteristic dBusBlueZCharacteristic : dBusBlueZService.getGattCharacteristics()) {\n+                    BluetoothCharacteristic characteristic = new BluetoothCharacteristic(\n+                            UUID.fromString(dBusBlueZCharacteristic.getUuid()), 0);\n+\n+                    for (BluetoothGattDescriptor dBusBlueZDescriptor : dBusBlueZCharacteristic.getGattDescriptors()) {\n+                        BluetoothDescriptor descriptor = new BluetoothDescriptor(characteristic,\n+                                UUID.fromString(dBusBlueZDescriptor.getUuid()));\n+                        characteristic.addDescriptor(descriptor);\n+                    }\n+\n+                    service.addCharacteristic(characteristic);\n+                }\n+\n+                addService(service);\n+            }\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9c2c484c0a68abcdb7f6e511a0635e2dd9353821"}, "originalPosition": 411}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTE5NDI2OA==", "bodyText": "done", "url": "https://github.com/openhab/openhab-addons/pull/8819#discussion_r511194268", "createdAt": "2020-10-23T23:19:28Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.bluetooth.bluez/src/main/java/org/openhab/binding/bluetooth/bluez/internal/BlueZBluetoothDevice.java", "diffHunk": "@@ -0,0 +1,474 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bluetooth.bluez.internal;\n+\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.UUID;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.bluez.exceptions.BluezFailedException;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.freedesktop.dbus.errors.NoReply;\n+import org.freedesktop.dbus.exceptions.DBusException;\n+import org.freedesktop.dbus.exceptions.DBusExecutionException;\n+import org.freedesktop.dbus.types.UInt16;\n+import org.openhab.binding.bluetooth.BaseBluetoothDevice;\n+import org.openhab.binding.bluetooth.BluetoothAddress;\n+import org.openhab.binding.bluetooth.BluetoothCharacteristic;\n+import org.openhab.binding.bluetooth.BluetoothCompletionStatus;\n+import org.openhab.binding.bluetooth.BluetoothDescriptor;\n+import org.openhab.binding.bluetooth.BluetoothService;\n+import org.openhab.binding.bluetooth.bluez.internal.events.BlueZEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.BlueZEventListener;\n+import org.openhab.binding.bluetooth.bluez.internal.events.CharacteristicUpdateEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.ConnectedEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.ManufacturerDataEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.NameEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.RssiEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.ServicesResolvedEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.TXPowerEvent;\n+import org.openhab.binding.bluetooth.notification.BluetoothConnectionStatusNotification;\n+import org.openhab.binding.bluetooth.notification.BluetoothScanNotification;\n+import org.openhab.core.common.ThreadPoolManager;\n+import org.openhab.core.util.HexUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.github.hypfvieh.bluetooth.wrapper.BluetoothDevice;\n+import com.github.hypfvieh.bluetooth.wrapper.BluetoothGattCharacteristic;\n+import com.github.hypfvieh.bluetooth.wrapper.BluetoothGattDescriptor;\n+import com.github.hypfvieh.bluetooth.wrapper.BluetoothGattService;\n+\n+/**\n+ * Implementation of BluetoothDevice for BlueZ via DBus-BlueZ API\n+ *\n+ * @author Kai Kreuzer - Initial contribution and API\n+ * @author Benjamin Lafois - Replaced tinyB with bluezDbus\n+ *\n+ */\n+@NonNullByDefault\n+public class BlueZBluetoothDevice extends BaseBluetoothDevice implements BlueZEventListener {\n+\n+    private final Logger logger = LoggerFactory.getLogger(BlueZBluetoothDevice.class);\n+\n+    private final ScheduledExecutorService scheduler = ThreadPoolManager.getScheduledPool(\"bluetooth\");\n+\n+    // Device from native lib\n+    private @Nullable BluetoothDevice device = null;\n+\n+    /**\n+     * Constructor\n+     *\n+     * @param adapter the bridge handler through which this device is connected\n+     * @param address the Bluetooth address of the device\n+     * @param name the name of the device\n+     */\n+    public BlueZBluetoothDevice(BlueZBridgeHandler adapter, BluetoothAddress address) {\n+        super(adapter, address);\n+        logger.debug(\"Creating DBusBlueZ device with address '{}'\", address);\n+    }\n+\n+    public synchronized void updateBlueZDevice(@Nullable BluetoothDevice blueZDevice) {\n+        if (this.device != null && this.device == blueZDevice) {\n+            return;\n+        }\n+        logger.debug(\"updateBlueZDevice({})\", blueZDevice);\n+\n+        this.device = blueZDevice;\n+\n+        if (blueZDevice == null) {\n+            return;\n+        }\n+\n+        Short rssi = blueZDevice.getRssi();\n+        if (rssi != null) {\n+            this.rssi = rssi.intValue();\n+        }\n+        this.name = blueZDevice.getName();\n+        Map<UInt16, byte[]> manData = blueZDevice.getManufacturerData();\n+        if (manData != null) {\n+            manData.entrySet().stream().map(Map.Entry::getKey).filter(Objects::nonNull).findFirst()\n+                    .ifPresent((UInt16 manufacturerId) ->\n+                    // Convert to unsigned int to match the convention in BluetoothCompanyIdentifiers\n+                    this.manufacturer = manufacturerId.intValue() & 0xFFFF);\n+        }\n+\n+        if (Boolean.TRUE.equals(blueZDevice.isConnected())) {\n+            setConnectionState(ConnectionState.CONNECTED);\n+        }\n+\n+        discoverServices();\n+    }\n+\n+    /**\n+     * Clean up and release memory.\n+     */\n+    @Override\n+    public void dispose() {\n+        BluetoothDevice dev = device;\n+        if (dev != null) {\n+            try {\n+                dev.getAdapter().removeDevice(dev.getRawDevice());\n+            } catch (DBusException ex) {\n+                if (ex.getMessage().contains(\"Does Not Exist\")) {\n+                    // this happens when the underlying device has already been removed\n+                    // but we don't have a way to check if that is the case beforehand so\n+                    // we will just eat the error here.\n+                } else {\n+                    logger.debug(\"Exception occurred when trying to remove inactive device '{}': {}\", address,\n+                            ex.getMessage());\n+                }\n+            } catch (RuntimeException ex) {\n+                // try to catch any other exceptions\n+                logger.debug(\"Exception occurred when trying to remove inactive device '{}': {}\", address,\n+                        ex.getMessage());\n+            }\n+        }\n+    }\n+\n+    private void setConnectionState(ConnectionState state) {\n+        if (this.connectionState != state) {\n+            this.connectionState = state;\n+            notifyListeners(BluetoothEventType.CONNECTION_STATE, new BluetoothConnectionStatusNotification(state));\n+        }\n+    }\n+\n+    @Override\n+    public boolean connect() {\n+        logger.debug(\"Connect({})\", device);\n+\n+        BluetoothDevice dev = device;\n+        if (dev != null) {\n+            if (Boolean.FALSE.equals(dev.isConnected())) {\n+                try {\n+                    boolean ret = dev.connect();\n+                    logger.debug(\"Connect result: {}\", ret);\n+                    return ret;\n+                } catch (NoReply e) {\n+                    // Have to double check because sometimes, exception but still worked\n+                    logger.debug(\"Got a timeout - but sometimes happen. Is Connected ? {}\", dev.isConnected());\n+                    if (Boolean.FALSE.equals(dev.isConnected())) {\n+\n+                        notifyListeners(BluetoothEventType.CONNECTION_STATE,\n+                                new BluetoothConnectionStatusNotification(ConnectionState.DISCONNECTED));\n+                        return false;\n+                    } else {\n+                        return true;\n+                    }\n+                } catch (DBusExecutionException e) {\n+                    // Catch \"software caused connection abort\"\n+                    return false;\n+                } catch (Exception e) {\n+                    logger.warn(\"error occured while trying to connect\", e);\n+                }\n+\n+            } else {\n+                logger.debug(\"Device was already connected\");\n+                // we might be stuck in another state atm so we need to trigger a connected in this case\n+                setConnectionState(ConnectionState.CONNECTED);\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    @Override\n+    public boolean disconnect() {\n+        BluetoothDevice dev = device;\n+        if (dev != null) {\n+            logger.debug(\"Disconnecting '{}'\", address);\n+            return dev.disconnect();\n+        }\n+        return false;\n+    }\n+\n+    private void ensureConnected() {\n+        BluetoothDevice dev = device;\n+        if (dev == null || !dev.isConnected()) {\n+            throw new IllegalStateException(\"DBusBlueZ device is not set or not connected\");\n+        }\n+    }\n+\n+    private @Nullable BluetoothGattCharacteristic getDBusBlueZCharacteristicByUUID(String uuid) {\n+        BluetoothDevice dev = device;\n+        if (dev == null) {\n+            return null;\n+        }\n+        for (BluetoothGattService service : dev.getGattServices()) {\n+            for (BluetoothGattCharacteristic c : service.getGattCharacteristics()) {\n+                if (c.getUuid().equalsIgnoreCase(uuid)) {\n+                    return c;\n+                }\n+            }\n+        }\n+        return null;\n+    }\n+\n+    private @Nullable BluetoothGattCharacteristic getDBusBlueZCharacteristicByDBusPath(String dBusPath) {\n+        BluetoothDevice dev = device;\n+        if (dev == null) {\n+            return null;\n+        }\n+        for (BluetoothGattService service : dev.getGattServices()) {\n+            if (dBusPath.startsWith(service.getDbusPath())) {\n+                for (BluetoothGattCharacteristic characteristic : service.getGattCharacteristics()) {\n+                    if (dBusPath.startsWith(characteristic.getDbusPath())) {\n+                        return characteristic;\n+                    }\n+                }\n+            }\n+        }\n+        return null;\n+    }\n+\n+    private @Nullable BluetoothGattDescriptor getDBusBlueZDescriptorByUUID(String uuid) {\n+        BluetoothDevice dev = device;\n+        if (dev == null) {\n+            return null;\n+        }\n+        for (BluetoothGattService service : dev.getGattServices()) {\n+            for (BluetoothGattCharacteristic c : service.getGattCharacteristics()) {\n+                for (BluetoothGattDescriptor d : c.getGattDescriptors()) {\n+                    if (d.getUuid().equalsIgnoreCase(uuid)) {\n+                        return d;\n+                    }\n+                }\n+            }\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public boolean enableNotifications(BluetoothCharacteristic characteristic) {\n+        ensureConnected();\n+\n+        BluetoothGattCharacteristic c = getDBusBlueZCharacteristicByUUID(characteristic.getUuid().toString());\n+        if (c != null) {\n+\n+            try {\n+                c.startNotify();\n+            } catch (DBusException e) {\n+                if (e.getMessage().contains(\"Already notifying\")) {\n+                    return false;\n+                } else if (e.getMessage().contains(\"In Progress\")) {\n+                    // let's retry in 10 seconds\n+                    scheduler.schedule(() -> enableNotifications(characteristic), 10, TimeUnit.SECONDS);\n+                } else {\n+                    logger.warn(\"Exception occurred while activating notifications on '{}'\", address, e);\n+                }\n+            }\n+            return true;\n+        } else {\n+            logger.warn(\"Characteristic '{}' is missing on device '{}'.\", characteristic.getUuid(), address);\n+            return false;\n+        }\n+    }\n+\n+    @Override\n+    public boolean writeCharacteristic(BluetoothCharacteristic characteristic) {\n+        logger.debug(\"writeCharacteristic()\");\n+\n+        ensureConnected();\n+\n+        BluetoothGattCharacteristic c = getDBusBlueZCharacteristicByUUID(characteristic.getUuid().toString());\n+        if (c == null) {\n+            logger.warn(\"Characteristic '{}' is missing on device '{}'.\", characteristic.getUuid(), address);\n+            return false;\n+        }\n+\n+        scheduler.submit(() -> {\n+            try {\n+                c.writeValue(characteristic.getByteValue(), null);\n+                notifyListeners(BluetoothEventType.CHARACTERISTIC_WRITE_COMPLETE, characteristic,\n+                        BluetoothCompletionStatus.SUCCESS);\n+\n+            } catch (DBusException e) {\n+                logger.debug(\"Exception occurred when trying to write characteristic '{}': {}\",\n+                        characteristic.getUuid(), e.getMessage());\n+                notifyListeners(BluetoothEventType.CHARACTERISTIC_WRITE_COMPLETE, characteristic,\n+                        BluetoothCompletionStatus.ERROR);\n+            }\n+        });\n+        return true;\n+    }\n+\n+    @Override\n+    public void onDBusBlueZEvent(BlueZEvent event) {\n+        logger.debug(\"Unsupported event: {}\", event);\n+    }\n+\n+    @Override\n+    public void onServicesResolved(ServicesResolvedEvent event) {\n+        if (event.isResolved()) {\n+            notifyListeners(BluetoothEventType.SERVICES_DISCOVERED);\n+        }\n+    }\n+\n+    @Override\n+    public void onNameUpdate(NameEvent event) {\n+        BluetoothScanNotification notification = new BluetoothScanNotification();\n+        notification.setDeviceName(event.getName());\n+        notifyListeners(BluetoothEventType.SCAN_RECORD, notification);\n+    }\n+\n+    @Override\n+    public void onManufacturerDataUpdate(ManufacturerDataEvent event) {\n+        for (Map.Entry<Short, byte[]> entry : event.getData().entrySet()) {\n+            BluetoothScanNotification notification = new BluetoothScanNotification();\n+            byte[] data = new byte[entry.getValue().length + 2];\n+            data[0] = (byte) (entry.getKey() & 0xFF);\n+            data[1] = (byte) (entry.getKey() >>> 8);\n+\n+            System.arraycopy(entry.getValue(), 0, data, 2, entry.getValue().length);\n+\n+            if (logger.isDebugEnabled()) {\n+                logger.debug(\"Received manufacturer data for '{}': {}\", address, HexUtils.bytesToHex(data, \" \"));\n+            }\n+\n+            notification.setManufacturerData(data);\n+            notifyListeners(BluetoothEventType.SCAN_RECORD, notification);\n+        }\n+    }\n+\n+    @Override\n+    public void onTxPowerUpdate(TXPowerEvent event) {\n+        this.txPower = (int) event.getTxPower();\n+    }\n+\n+    @Override\n+    public void onCharacteristicNotify(CharacteristicUpdateEvent event) {\n+        // Here it is a bit special - as the event is linked to the DBUS path, not characteristic UUID.\n+        // So we need to find the characteristic by its DBUS path.\n+        BluetoothGattCharacteristic characteristic = getDBusBlueZCharacteristicByDBusPath(event.getDbusPath());\n+        if (characteristic == null) {\n+            logger.info(\"Received a notification for a characteristic not found on device.\");\n+            return;\n+        }\n+        BluetoothCharacteristic c = getCharacteristic(UUID.fromString(characteristic.getUuid()));\n+        if (c != null) {\n+            c.setValue(event.getData());\n+            notifyListeners(BluetoothEventType.CHARACTERISTIC_UPDATED, c, BluetoothCompletionStatus.SUCCESS);\n+            logger.debug(\"Has notified that a characteristic has been updated\");\n+        }\n+    }\n+\n+    @Override\n+    public void onRssiUpdate(RssiEvent event) {\n+        int rssiTmp = event.getRssi();\n+        this.rssi = rssiTmp;\n+        BluetoothScanNotification notification = new BluetoothScanNotification();\n+        notification.setRssi(rssiTmp);\n+        notifyListeners(BluetoothEventType.SCAN_RECORD, notification);\n+    }\n+\n+    @Override\n+    public void onConnectedStatusUpdate(ConnectedEvent event) {\n+        this.connectionState = event.isConnected() ? ConnectionState.CONNECTED : ConnectionState.DISCONNECTED;\n+        notifyListeners(BluetoothEventType.CONNECTION_STATE,\n+                new BluetoothConnectionStatusNotification(connectionState));\n+    }\n+\n+    @Override\n+    public boolean discoverServices() {\n+        BluetoothDevice dev = device;\n+        if (dev == null) {\n+            return false;\n+        }\n+        if (dev.getGattServices().size() > getServices().size()) {\n+\n+            for (BluetoothGattService dBusBlueZService : dev.getGattServices()) {\n+                BluetoothService service = new BluetoothService(UUID.fromString(dBusBlueZService.getUuid()),\n+                        dBusBlueZService.isPrimary());\n+\n+                for (BluetoothGattCharacteristic dBusBlueZCharacteristic : dBusBlueZService.getGattCharacteristics()) {\n+                    BluetoothCharacteristic characteristic = new BluetoothCharacteristic(\n+                            UUID.fromString(dBusBlueZCharacteristic.getUuid()), 0);\n+\n+                    for (BluetoothGattDescriptor dBusBlueZDescriptor : dBusBlueZCharacteristic.getGattDescriptors()) {\n+                        BluetoothDescriptor descriptor = new BluetoothDescriptor(characteristic,\n+                                UUID.fromString(dBusBlueZDescriptor.getUuid()));\n+                        characteristic.addDescriptor(descriptor);\n+                    }\n+\n+                    service.addCharacteristic(characteristic);\n+                }\n+\n+                addService(service);\n+            }\n+", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTE2OTE0OQ=="}, "originalCommit": {"oid": "9c2c484c0a68abcdb7f6e511a0635e2dd9353821"}, "originalPosition": 411}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIwMjE3NTk0OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.bluetooth.bluez/src/main/java/org/openhab/binding/bluetooth/bluez/internal/BlueZBluetoothDevice.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QyMTo0NTozM1rOHnfS6Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNFQwMDoxMTo1NFrOHnhbiQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTE2OTI1Nw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change", "url": "https://github.com/openhab/openhab-addons/pull/8819#discussion_r511169257", "createdAt": "2020-10-23T21:45:33Z", "author": {"login": "kaikreuzer"}, "path": "bundles/org.openhab.binding.bluetooth.bluez/src/main/java/org/openhab/binding/bluetooth/bluez/internal/BlueZBluetoothDevice.java", "diffHunk": "@@ -0,0 +1,474 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bluetooth.bluez.internal;\n+\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.UUID;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.bluez.exceptions.BluezFailedException;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.freedesktop.dbus.errors.NoReply;\n+import org.freedesktop.dbus.exceptions.DBusException;\n+import org.freedesktop.dbus.exceptions.DBusExecutionException;\n+import org.freedesktop.dbus.types.UInt16;\n+import org.openhab.binding.bluetooth.BaseBluetoothDevice;\n+import org.openhab.binding.bluetooth.BluetoothAddress;\n+import org.openhab.binding.bluetooth.BluetoothCharacteristic;\n+import org.openhab.binding.bluetooth.BluetoothCompletionStatus;\n+import org.openhab.binding.bluetooth.BluetoothDescriptor;\n+import org.openhab.binding.bluetooth.BluetoothService;\n+import org.openhab.binding.bluetooth.bluez.internal.events.BlueZEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.BlueZEventListener;\n+import org.openhab.binding.bluetooth.bluez.internal.events.CharacteristicUpdateEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.ConnectedEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.ManufacturerDataEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.NameEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.RssiEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.ServicesResolvedEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.TXPowerEvent;\n+import org.openhab.binding.bluetooth.notification.BluetoothConnectionStatusNotification;\n+import org.openhab.binding.bluetooth.notification.BluetoothScanNotification;\n+import org.openhab.core.common.ThreadPoolManager;\n+import org.openhab.core.util.HexUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.github.hypfvieh.bluetooth.wrapper.BluetoothDevice;\n+import com.github.hypfvieh.bluetooth.wrapper.BluetoothGattCharacteristic;\n+import com.github.hypfvieh.bluetooth.wrapper.BluetoothGattDescriptor;\n+import com.github.hypfvieh.bluetooth.wrapper.BluetoothGattService;\n+\n+/**\n+ * Implementation of BluetoothDevice for BlueZ via DBus-BlueZ API\n+ *\n+ * @author Kai Kreuzer - Initial contribution and API\n+ * @author Benjamin Lafois - Replaced tinyB with bluezDbus\n+ *\n+ */\n+@NonNullByDefault\n+public class BlueZBluetoothDevice extends BaseBluetoothDevice implements BlueZEventListener {\n+\n+    private final Logger logger = LoggerFactory.getLogger(BlueZBluetoothDevice.class);\n+\n+    private final ScheduledExecutorService scheduler = ThreadPoolManager.getScheduledPool(\"bluetooth\");\n+\n+    // Device from native lib\n+    private @Nullable BluetoothDevice device = null;\n+\n+    /**\n+     * Constructor\n+     *\n+     * @param adapter the bridge handler through which this device is connected\n+     * @param address the Bluetooth address of the device\n+     * @param name the name of the device\n+     */\n+    public BlueZBluetoothDevice(BlueZBridgeHandler adapter, BluetoothAddress address) {\n+        super(adapter, address);\n+        logger.debug(\"Creating DBusBlueZ device with address '{}'\", address);\n+    }\n+\n+    public synchronized void updateBlueZDevice(@Nullable BluetoothDevice blueZDevice) {\n+        if (this.device != null && this.device == blueZDevice) {\n+            return;\n+        }\n+        logger.debug(\"updateBlueZDevice({})\", blueZDevice);\n+\n+        this.device = blueZDevice;\n+\n+        if (blueZDevice == null) {\n+            return;\n+        }\n+\n+        Short rssi = blueZDevice.getRssi();\n+        if (rssi != null) {\n+            this.rssi = rssi.intValue();\n+        }\n+        this.name = blueZDevice.getName();\n+        Map<UInt16, byte[]> manData = blueZDevice.getManufacturerData();\n+        if (manData != null) {\n+            manData.entrySet().stream().map(Map.Entry::getKey).filter(Objects::nonNull).findFirst()\n+                    .ifPresent((UInt16 manufacturerId) ->\n+                    // Convert to unsigned int to match the convention in BluetoothCompanyIdentifiers\n+                    this.manufacturer = manufacturerId.intValue() & 0xFFFF);\n+        }\n+\n+        if (Boolean.TRUE.equals(blueZDevice.isConnected())) {\n+            setConnectionState(ConnectionState.CONNECTED);\n+        }\n+\n+        discoverServices();\n+    }\n+\n+    /**\n+     * Clean up and release memory.\n+     */\n+    @Override\n+    public void dispose() {\n+        BluetoothDevice dev = device;\n+        if (dev != null) {\n+            try {\n+                dev.getAdapter().removeDevice(dev.getRawDevice());\n+            } catch (DBusException ex) {\n+                if (ex.getMessage().contains(\"Does Not Exist\")) {\n+                    // this happens when the underlying device has already been removed\n+                    // but we don't have a way to check if that is the case beforehand so\n+                    // we will just eat the error here.\n+                } else {\n+                    logger.debug(\"Exception occurred when trying to remove inactive device '{}': {}\", address,\n+                            ex.getMessage());\n+                }\n+            } catch (RuntimeException ex) {\n+                // try to catch any other exceptions\n+                logger.debug(\"Exception occurred when trying to remove inactive device '{}': {}\", address,\n+                        ex.getMessage());\n+            }\n+        }\n+    }\n+\n+    private void setConnectionState(ConnectionState state) {\n+        if (this.connectionState != state) {\n+            this.connectionState = state;\n+            notifyListeners(BluetoothEventType.CONNECTION_STATE, new BluetoothConnectionStatusNotification(state));\n+        }\n+    }\n+\n+    @Override\n+    public boolean connect() {\n+        logger.debug(\"Connect({})\", device);\n+\n+        BluetoothDevice dev = device;\n+        if (dev != null) {\n+            if (Boolean.FALSE.equals(dev.isConnected())) {\n+                try {\n+                    boolean ret = dev.connect();\n+                    logger.debug(\"Connect result: {}\", ret);\n+                    return ret;\n+                } catch (NoReply e) {\n+                    // Have to double check because sometimes, exception but still worked\n+                    logger.debug(\"Got a timeout - but sometimes happen. Is Connected ? {}\", dev.isConnected());\n+                    if (Boolean.FALSE.equals(dev.isConnected())) {\n+\n+                        notifyListeners(BluetoothEventType.CONNECTION_STATE,\n+                                new BluetoothConnectionStatusNotification(ConnectionState.DISCONNECTED));\n+                        return false;\n+                    } else {\n+                        return true;\n+                    }\n+                } catch (DBusExecutionException e) {\n+                    // Catch \"software caused connection abort\"\n+                    return false;\n+                } catch (Exception e) {\n+                    logger.warn(\"error occured while trying to connect\", e);\n+                }\n+\n+            } else {\n+                logger.debug(\"Device was already connected\");\n+                // we might be stuck in another state atm so we need to trigger a connected in this case\n+                setConnectionState(ConnectionState.CONNECTED);\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    @Override\n+    public boolean disconnect() {\n+        BluetoothDevice dev = device;\n+        if (dev != null) {\n+            logger.debug(\"Disconnecting '{}'\", address);\n+            return dev.disconnect();\n+        }\n+        return false;\n+    }\n+\n+    private void ensureConnected() {\n+        BluetoothDevice dev = device;\n+        if (dev == null || !dev.isConnected()) {\n+            throw new IllegalStateException(\"DBusBlueZ device is not set or not connected\");\n+        }\n+    }\n+\n+    private @Nullable BluetoothGattCharacteristic getDBusBlueZCharacteristicByUUID(String uuid) {\n+        BluetoothDevice dev = device;\n+        if (dev == null) {\n+            return null;\n+        }\n+        for (BluetoothGattService service : dev.getGattServices()) {\n+            for (BluetoothGattCharacteristic c : service.getGattCharacteristics()) {\n+                if (c.getUuid().equalsIgnoreCase(uuid)) {\n+                    return c;\n+                }\n+            }\n+        }\n+        return null;\n+    }\n+\n+    private @Nullable BluetoothGattCharacteristic getDBusBlueZCharacteristicByDBusPath(String dBusPath) {\n+        BluetoothDevice dev = device;\n+        if (dev == null) {\n+            return null;\n+        }\n+        for (BluetoothGattService service : dev.getGattServices()) {\n+            if (dBusPath.startsWith(service.getDbusPath())) {\n+                for (BluetoothGattCharacteristic characteristic : service.getGattCharacteristics()) {\n+                    if (dBusPath.startsWith(characteristic.getDbusPath())) {\n+                        return characteristic;\n+                    }\n+                }\n+            }\n+        }\n+        return null;\n+    }\n+\n+    private @Nullable BluetoothGattDescriptor getDBusBlueZDescriptorByUUID(String uuid) {\n+        BluetoothDevice dev = device;\n+        if (dev == null) {\n+            return null;\n+        }\n+        for (BluetoothGattService service : dev.getGattServices()) {\n+            for (BluetoothGattCharacteristic c : service.getGattCharacteristics()) {\n+                for (BluetoothGattDescriptor d : c.getGattDescriptors()) {\n+                    if (d.getUuid().equalsIgnoreCase(uuid)) {\n+                        return d;\n+                    }\n+                }\n+            }\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public boolean enableNotifications(BluetoothCharacteristic characteristic) {\n+        ensureConnected();\n+\n+        BluetoothGattCharacteristic c = getDBusBlueZCharacteristicByUUID(characteristic.getUuid().toString());\n+        if (c != null) {\n+\n+            try {\n+                c.startNotify();\n+            } catch (DBusException e) {\n+                if (e.getMessage().contains(\"Already notifying\")) {\n+                    return false;\n+                } else if (e.getMessage().contains(\"In Progress\")) {\n+                    // let's retry in 10 seconds\n+                    scheduler.schedule(() -> enableNotifications(characteristic), 10, TimeUnit.SECONDS);\n+                } else {\n+                    logger.warn(\"Exception occurred while activating notifications on '{}'\", address, e);\n+                }\n+            }\n+            return true;\n+        } else {\n+            logger.warn(\"Characteristic '{}' is missing on device '{}'.\", characteristic.getUuid(), address);\n+            return false;\n+        }\n+    }\n+\n+    @Override\n+    public boolean writeCharacteristic(BluetoothCharacteristic characteristic) {\n+        logger.debug(\"writeCharacteristic()\");\n+\n+        ensureConnected();\n+\n+        BluetoothGattCharacteristic c = getDBusBlueZCharacteristicByUUID(characteristic.getUuid().toString());\n+        if (c == null) {\n+            logger.warn(\"Characteristic '{}' is missing on device '{}'.\", characteristic.getUuid(), address);\n+            return false;\n+        }\n+\n+        scheduler.submit(() -> {\n+            try {\n+                c.writeValue(characteristic.getByteValue(), null);\n+                notifyListeners(BluetoothEventType.CHARACTERISTIC_WRITE_COMPLETE, characteristic,\n+                        BluetoothCompletionStatus.SUCCESS);\n+\n+            } catch (DBusException e) {\n+                logger.debug(\"Exception occurred when trying to write characteristic '{}': {}\",\n+                        characteristic.getUuid(), e.getMessage());\n+                notifyListeners(BluetoothEventType.CHARACTERISTIC_WRITE_COMPLETE, characteristic,\n+                        BluetoothCompletionStatus.ERROR);\n+            }\n+        });\n+        return true;\n+    }\n+\n+    @Override\n+    public void onDBusBlueZEvent(BlueZEvent event) {\n+        logger.debug(\"Unsupported event: {}\", event);\n+    }\n+\n+    @Override\n+    public void onServicesResolved(ServicesResolvedEvent event) {\n+        if (event.isResolved()) {\n+            notifyListeners(BluetoothEventType.SERVICES_DISCOVERED);\n+        }\n+    }\n+\n+    @Override\n+    public void onNameUpdate(NameEvent event) {\n+        BluetoothScanNotification notification = new BluetoothScanNotification();\n+        notification.setDeviceName(event.getName());\n+        notifyListeners(BluetoothEventType.SCAN_RECORD, notification);\n+    }\n+\n+    @Override\n+    public void onManufacturerDataUpdate(ManufacturerDataEvent event) {\n+        for (Map.Entry<Short, byte[]> entry : event.getData().entrySet()) {\n+            BluetoothScanNotification notification = new BluetoothScanNotification();\n+            byte[] data = new byte[entry.getValue().length + 2];\n+            data[0] = (byte) (entry.getKey() & 0xFF);\n+            data[1] = (byte) (entry.getKey() >>> 8);\n+\n+            System.arraycopy(entry.getValue(), 0, data, 2, entry.getValue().length);\n+\n+            if (logger.isDebugEnabled()) {\n+                logger.debug(\"Received manufacturer data for '{}': {}\", address, HexUtils.bytesToHex(data, \" \"));\n+            }\n+\n+            notification.setManufacturerData(data);\n+            notifyListeners(BluetoothEventType.SCAN_RECORD, notification);\n+        }\n+    }\n+\n+    @Override\n+    public void onTxPowerUpdate(TXPowerEvent event) {\n+        this.txPower = (int) event.getTxPower();\n+    }\n+\n+    @Override\n+    public void onCharacteristicNotify(CharacteristicUpdateEvent event) {\n+        // Here it is a bit special - as the event is linked to the DBUS path, not characteristic UUID.\n+        // So we need to find the characteristic by its DBUS path.\n+        BluetoothGattCharacteristic characteristic = getDBusBlueZCharacteristicByDBusPath(event.getDbusPath());\n+        if (characteristic == null) {\n+            logger.info(\"Received a notification for a characteristic not found on device.\");\n+            return;\n+        }\n+        BluetoothCharacteristic c = getCharacteristic(UUID.fromString(characteristic.getUuid()));\n+        if (c != null) {\n+            c.setValue(event.getData());\n+            notifyListeners(BluetoothEventType.CHARACTERISTIC_UPDATED, c, BluetoothCompletionStatus.SUCCESS);\n+            logger.debug(\"Has notified that a characteristic has been updated\");\n+        }\n+    }\n+\n+    @Override\n+    public void onRssiUpdate(RssiEvent event) {\n+        int rssiTmp = event.getRssi();\n+        this.rssi = rssiTmp;\n+        BluetoothScanNotification notification = new BluetoothScanNotification();\n+        notification.setRssi(rssiTmp);\n+        notifyListeners(BluetoothEventType.SCAN_RECORD, notification);\n+    }\n+\n+    @Override\n+    public void onConnectedStatusUpdate(ConnectedEvent event) {\n+        this.connectionState = event.isConnected() ? ConnectionState.CONNECTED : ConnectionState.DISCONNECTED;\n+        notifyListeners(BluetoothEventType.CONNECTION_STATE,\n+                new BluetoothConnectionStatusNotification(connectionState));\n+    }\n+\n+    @Override\n+    public boolean discoverServices() {\n+        BluetoothDevice dev = device;\n+        if (dev == null) {\n+            return false;\n+        }\n+        if (dev.getGattServices().size() > getServices().size()) {\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9c2c484c0a68abcdb7f6e511a0635e2dd9353821"}, "originalPosition": 391}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTIwNDIzMw==", "bodyText": "done", "url": "https://github.com/openhab/openhab-addons/pull/8819#discussion_r511204233", "createdAt": "2020-10-24T00:11:54Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.bluetooth.bluez/src/main/java/org/openhab/binding/bluetooth/bluez/internal/BlueZBluetoothDevice.java", "diffHunk": "@@ -0,0 +1,474 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bluetooth.bluez.internal;\n+\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.UUID;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.bluez.exceptions.BluezFailedException;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.freedesktop.dbus.errors.NoReply;\n+import org.freedesktop.dbus.exceptions.DBusException;\n+import org.freedesktop.dbus.exceptions.DBusExecutionException;\n+import org.freedesktop.dbus.types.UInt16;\n+import org.openhab.binding.bluetooth.BaseBluetoothDevice;\n+import org.openhab.binding.bluetooth.BluetoothAddress;\n+import org.openhab.binding.bluetooth.BluetoothCharacteristic;\n+import org.openhab.binding.bluetooth.BluetoothCompletionStatus;\n+import org.openhab.binding.bluetooth.BluetoothDescriptor;\n+import org.openhab.binding.bluetooth.BluetoothService;\n+import org.openhab.binding.bluetooth.bluez.internal.events.BlueZEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.BlueZEventListener;\n+import org.openhab.binding.bluetooth.bluez.internal.events.CharacteristicUpdateEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.ConnectedEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.ManufacturerDataEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.NameEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.RssiEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.ServicesResolvedEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.TXPowerEvent;\n+import org.openhab.binding.bluetooth.notification.BluetoothConnectionStatusNotification;\n+import org.openhab.binding.bluetooth.notification.BluetoothScanNotification;\n+import org.openhab.core.common.ThreadPoolManager;\n+import org.openhab.core.util.HexUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.github.hypfvieh.bluetooth.wrapper.BluetoothDevice;\n+import com.github.hypfvieh.bluetooth.wrapper.BluetoothGattCharacteristic;\n+import com.github.hypfvieh.bluetooth.wrapper.BluetoothGattDescriptor;\n+import com.github.hypfvieh.bluetooth.wrapper.BluetoothGattService;\n+\n+/**\n+ * Implementation of BluetoothDevice for BlueZ via DBus-BlueZ API\n+ *\n+ * @author Kai Kreuzer - Initial contribution and API\n+ * @author Benjamin Lafois - Replaced tinyB with bluezDbus\n+ *\n+ */\n+@NonNullByDefault\n+public class BlueZBluetoothDevice extends BaseBluetoothDevice implements BlueZEventListener {\n+\n+    private final Logger logger = LoggerFactory.getLogger(BlueZBluetoothDevice.class);\n+\n+    private final ScheduledExecutorService scheduler = ThreadPoolManager.getScheduledPool(\"bluetooth\");\n+\n+    // Device from native lib\n+    private @Nullable BluetoothDevice device = null;\n+\n+    /**\n+     * Constructor\n+     *\n+     * @param adapter the bridge handler through which this device is connected\n+     * @param address the Bluetooth address of the device\n+     * @param name the name of the device\n+     */\n+    public BlueZBluetoothDevice(BlueZBridgeHandler adapter, BluetoothAddress address) {\n+        super(adapter, address);\n+        logger.debug(\"Creating DBusBlueZ device with address '{}'\", address);\n+    }\n+\n+    public synchronized void updateBlueZDevice(@Nullable BluetoothDevice blueZDevice) {\n+        if (this.device != null && this.device == blueZDevice) {\n+            return;\n+        }\n+        logger.debug(\"updateBlueZDevice({})\", blueZDevice);\n+\n+        this.device = blueZDevice;\n+\n+        if (blueZDevice == null) {\n+            return;\n+        }\n+\n+        Short rssi = blueZDevice.getRssi();\n+        if (rssi != null) {\n+            this.rssi = rssi.intValue();\n+        }\n+        this.name = blueZDevice.getName();\n+        Map<UInt16, byte[]> manData = blueZDevice.getManufacturerData();\n+        if (manData != null) {\n+            manData.entrySet().stream().map(Map.Entry::getKey).filter(Objects::nonNull).findFirst()\n+                    .ifPresent((UInt16 manufacturerId) ->\n+                    // Convert to unsigned int to match the convention in BluetoothCompanyIdentifiers\n+                    this.manufacturer = manufacturerId.intValue() & 0xFFFF);\n+        }\n+\n+        if (Boolean.TRUE.equals(blueZDevice.isConnected())) {\n+            setConnectionState(ConnectionState.CONNECTED);\n+        }\n+\n+        discoverServices();\n+    }\n+\n+    /**\n+     * Clean up and release memory.\n+     */\n+    @Override\n+    public void dispose() {\n+        BluetoothDevice dev = device;\n+        if (dev != null) {\n+            try {\n+                dev.getAdapter().removeDevice(dev.getRawDevice());\n+            } catch (DBusException ex) {\n+                if (ex.getMessage().contains(\"Does Not Exist\")) {\n+                    // this happens when the underlying device has already been removed\n+                    // but we don't have a way to check if that is the case beforehand so\n+                    // we will just eat the error here.\n+                } else {\n+                    logger.debug(\"Exception occurred when trying to remove inactive device '{}': {}\", address,\n+                            ex.getMessage());\n+                }\n+            } catch (RuntimeException ex) {\n+                // try to catch any other exceptions\n+                logger.debug(\"Exception occurred when trying to remove inactive device '{}': {}\", address,\n+                        ex.getMessage());\n+            }\n+        }\n+    }\n+\n+    private void setConnectionState(ConnectionState state) {\n+        if (this.connectionState != state) {\n+            this.connectionState = state;\n+            notifyListeners(BluetoothEventType.CONNECTION_STATE, new BluetoothConnectionStatusNotification(state));\n+        }\n+    }\n+\n+    @Override\n+    public boolean connect() {\n+        logger.debug(\"Connect({})\", device);\n+\n+        BluetoothDevice dev = device;\n+        if (dev != null) {\n+            if (Boolean.FALSE.equals(dev.isConnected())) {\n+                try {\n+                    boolean ret = dev.connect();\n+                    logger.debug(\"Connect result: {}\", ret);\n+                    return ret;\n+                } catch (NoReply e) {\n+                    // Have to double check because sometimes, exception but still worked\n+                    logger.debug(\"Got a timeout - but sometimes happen. Is Connected ? {}\", dev.isConnected());\n+                    if (Boolean.FALSE.equals(dev.isConnected())) {\n+\n+                        notifyListeners(BluetoothEventType.CONNECTION_STATE,\n+                                new BluetoothConnectionStatusNotification(ConnectionState.DISCONNECTED));\n+                        return false;\n+                    } else {\n+                        return true;\n+                    }\n+                } catch (DBusExecutionException e) {\n+                    // Catch \"software caused connection abort\"\n+                    return false;\n+                } catch (Exception e) {\n+                    logger.warn(\"error occured while trying to connect\", e);\n+                }\n+\n+            } else {\n+                logger.debug(\"Device was already connected\");\n+                // we might be stuck in another state atm so we need to trigger a connected in this case\n+                setConnectionState(ConnectionState.CONNECTED);\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    @Override\n+    public boolean disconnect() {\n+        BluetoothDevice dev = device;\n+        if (dev != null) {\n+            logger.debug(\"Disconnecting '{}'\", address);\n+            return dev.disconnect();\n+        }\n+        return false;\n+    }\n+\n+    private void ensureConnected() {\n+        BluetoothDevice dev = device;\n+        if (dev == null || !dev.isConnected()) {\n+            throw new IllegalStateException(\"DBusBlueZ device is not set or not connected\");\n+        }\n+    }\n+\n+    private @Nullable BluetoothGattCharacteristic getDBusBlueZCharacteristicByUUID(String uuid) {\n+        BluetoothDevice dev = device;\n+        if (dev == null) {\n+            return null;\n+        }\n+        for (BluetoothGattService service : dev.getGattServices()) {\n+            for (BluetoothGattCharacteristic c : service.getGattCharacteristics()) {\n+                if (c.getUuid().equalsIgnoreCase(uuid)) {\n+                    return c;\n+                }\n+            }\n+        }\n+        return null;\n+    }\n+\n+    private @Nullable BluetoothGattCharacteristic getDBusBlueZCharacteristicByDBusPath(String dBusPath) {\n+        BluetoothDevice dev = device;\n+        if (dev == null) {\n+            return null;\n+        }\n+        for (BluetoothGattService service : dev.getGattServices()) {\n+            if (dBusPath.startsWith(service.getDbusPath())) {\n+                for (BluetoothGattCharacteristic characteristic : service.getGattCharacteristics()) {\n+                    if (dBusPath.startsWith(characteristic.getDbusPath())) {\n+                        return characteristic;\n+                    }\n+                }\n+            }\n+        }\n+        return null;\n+    }\n+\n+    private @Nullable BluetoothGattDescriptor getDBusBlueZDescriptorByUUID(String uuid) {\n+        BluetoothDevice dev = device;\n+        if (dev == null) {\n+            return null;\n+        }\n+        for (BluetoothGattService service : dev.getGattServices()) {\n+            for (BluetoothGattCharacteristic c : service.getGattCharacteristics()) {\n+                for (BluetoothGattDescriptor d : c.getGattDescriptors()) {\n+                    if (d.getUuid().equalsIgnoreCase(uuid)) {\n+                        return d;\n+                    }\n+                }\n+            }\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public boolean enableNotifications(BluetoothCharacteristic characteristic) {\n+        ensureConnected();\n+\n+        BluetoothGattCharacteristic c = getDBusBlueZCharacteristicByUUID(characteristic.getUuid().toString());\n+        if (c != null) {\n+\n+            try {\n+                c.startNotify();\n+            } catch (DBusException e) {\n+                if (e.getMessage().contains(\"Already notifying\")) {\n+                    return false;\n+                } else if (e.getMessage().contains(\"In Progress\")) {\n+                    // let's retry in 10 seconds\n+                    scheduler.schedule(() -> enableNotifications(characteristic), 10, TimeUnit.SECONDS);\n+                } else {\n+                    logger.warn(\"Exception occurred while activating notifications on '{}'\", address, e);\n+                }\n+            }\n+            return true;\n+        } else {\n+            logger.warn(\"Characteristic '{}' is missing on device '{}'.\", characteristic.getUuid(), address);\n+            return false;\n+        }\n+    }\n+\n+    @Override\n+    public boolean writeCharacteristic(BluetoothCharacteristic characteristic) {\n+        logger.debug(\"writeCharacteristic()\");\n+\n+        ensureConnected();\n+\n+        BluetoothGattCharacteristic c = getDBusBlueZCharacteristicByUUID(characteristic.getUuid().toString());\n+        if (c == null) {\n+            logger.warn(\"Characteristic '{}' is missing on device '{}'.\", characteristic.getUuid(), address);\n+            return false;\n+        }\n+\n+        scheduler.submit(() -> {\n+            try {\n+                c.writeValue(characteristic.getByteValue(), null);\n+                notifyListeners(BluetoothEventType.CHARACTERISTIC_WRITE_COMPLETE, characteristic,\n+                        BluetoothCompletionStatus.SUCCESS);\n+\n+            } catch (DBusException e) {\n+                logger.debug(\"Exception occurred when trying to write characteristic '{}': {}\",\n+                        characteristic.getUuid(), e.getMessage());\n+                notifyListeners(BluetoothEventType.CHARACTERISTIC_WRITE_COMPLETE, characteristic,\n+                        BluetoothCompletionStatus.ERROR);\n+            }\n+        });\n+        return true;\n+    }\n+\n+    @Override\n+    public void onDBusBlueZEvent(BlueZEvent event) {\n+        logger.debug(\"Unsupported event: {}\", event);\n+    }\n+\n+    @Override\n+    public void onServicesResolved(ServicesResolvedEvent event) {\n+        if (event.isResolved()) {\n+            notifyListeners(BluetoothEventType.SERVICES_DISCOVERED);\n+        }\n+    }\n+\n+    @Override\n+    public void onNameUpdate(NameEvent event) {\n+        BluetoothScanNotification notification = new BluetoothScanNotification();\n+        notification.setDeviceName(event.getName());\n+        notifyListeners(BluetoothEventType.SCAN_RECORD, notification);\n+    }\n+\n+    @Override\n+    public void onManufacturerDataUpdate(ManufacturerDataEvent event) {\n+        for (Map.Entry<Short, byte[]> entry : event.getData().entrySet()) {\n+            BluetoothScanNotification notification = new BluetoothScanNotification();\n+            byte[] data = new byte[entry.getValue().length + 2];\n+            data[0] = (byte) (entry.getKey() & 0xFF);\n+            data[1] = (byte) (entry.getKey() >>> 8);\n+\n+            System.arraycopy(entry.getValue(), 0, data, 2, entry.getValue().length);\n+\n+            if (logger.isDebugEnabled()) {\n+                logger.debug(\"Received manufacturer data for '{}': {}\", address, HexUtils.bytesToHex(data, \" \"));\n+            }\n+\n+            notification.setManufacturerData(data);\n+            notifyListeners(BluetoothEventType.SCAN_RECORD, notification);\n+        }\n+    }\n+\n+    @Override\n+    public void onTxPowerUpdate(TXPowerEvent event) {\n+        this.txPower = (int) event.getTxPower();\n+    }\n+\n+    @Override\n+    public void onCharacteristicNotify(CharacteristicUpdateEvent event) {\n+        // Here it is a bit special - as the event is linked to the DBUS path, not characteristic UUID.\n+        // So we need to find the characteristic by its DBUS path.\n+        BluetoothGattCharacteristic characteristic = getDBusBlueZCharacteristicByDBusPath(event.getDbusPath());\n+        if (characteristic == null) {\n+            logger.info(\"Received a notification for a characteristic not found on device.\");\n+            return;\n+        }\n+        BluetoothCharacteristic c = getCharacteristic(UUID.fromString(characteristic.getUuid()));\n+        if (c != null) {\n+            c.setValue(event.getData());\n+            notifyListeners(BluetoothEventType.CHARACTERISTIC_UPDATED, c, BluetoothCompletionStatus.SUCCESS);\n+            logger.debug(\"Has notified that a characteristic has been updated\");\n+        }\n+    }\n+\n+    @Override\n+    public void onRssiUpdate(RssiEvent event) {\n+        int rssiTmp = event.getRssi();\n+        this.rssi = rssiTmp;\n+        BluetoothScanNotification notification = new BluetoothScanNotification();\n+        notification.setRssi(rssiTmp);\n+        notifyListeners(BluetoothEventType.SCAN_RECORD, notification);\n+    }\n+\n+    @Override\n+    public void onConnectedStatusUpdate(ConnectedEvent event) {\n+        this.connectionState = event.isConnected() ? ConnectionState.CONNECTED : ConnectionState.DISCONNECTED;\n+        notifyListeners(BluetoothEventType.CONNECTION_STATE,\n+                new BluetoothConnectionStatusNotification(connectionState));\n+    }\n+\n+    @Override\n+    public boolean discoverServices() {\n+        BluetoothDevice dev = device;\n+        if (dev == null) {\n+            return false;\n+        }\n+        if (dev.getGattServices().size() > getServices().size()) {\n+", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTE2OTI1Nw=="}, "originalCommit": {"oid": "9c2c484c0a68abcdb7f6e511a0635e2dd9353821"}, "originalPosition": 391}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIwMjE3NzU1OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.bluetooth.bluez/src/main/java/org/openhab/binding/bluetooth/bluez/internal/BlueZBridgeHandler.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QyMTo0NjoxOFrOHnfT8g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QyMTo0NjoxOFrOHnfT8g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTE2OTUyMg==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    logger.debug(\"Creating BlueZ adapter with address '{}'\", adapterAddress);\n          \n          \n            \n            \n          \n          \n            \n                    updateStatus(ThingStatus.UNKNOWN, ThingStatusDetail.CONFIGURATION_PENDING, \"Initializing\");\n          \n          \n            \n            \n          \n          \n            \n                    deviceManagerFactory.getPropertiesChangedHandler().addListener(this);\n          \n          \n            \n            \n          \n          \n            \n                    discoveryJob = scheduler.scheduleWithFixedDelay(this::initializeAndRefreshDevices, 5, 10, TimeUnit.SECONDS);\n          \n          \n            \n                    logger.debug(\"Creating BlueZ adapter with address '{}'\", adapterAddress);\n          \n          \n            \n                    updateStatus(ThingStatus.UNKNOWN);\n          \n          \n            \n                    deviceManagerFactory.getPropertiesChangedHandler().addListener(this);\n          \n          \n            \n                    discoveryJob = scheduler.scheduleWithFixedDelay(this::initializeAndRefreshDevices, 5, 10, TimeUnit.SECONDS);", "url": "https://github.com/openhab/openhab-addons/pull/8819#discussion_r511169522", "createdAt": "2020-10-23T21:46:18Z", "author": {"login": "kaikreuzer"}, "path": "bundles/org.openhab.binding.bluetooth.bluez/src/main/java/org/openhab/binding/bluetooth/bluez/internal/BlueZBridgeHandler.java", "diffHunk": "@@ -0,0 +1,241 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bluetooth.bluez.internal;\n+\n+import java.util.List;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.bluetooth.AbstractBluetoothBridgeHandler;\n+import org.openhab.binding.bluetooth.BluetoothAddress;\n+import org.openhab.binding.bluetooth.bluez.internal.events.AdapterDiscoveringChangedEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.AdapterPoweredChangedEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.BlueZEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.BlueZEventListener;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.github.hypfvieh.bluetooth.wrapper.BluetoothAdapter;\n+import com.github.hypfvieh.bluetooth.wrapper.BluetoothDevice;\n+\n+/**\n+ * The {@link BlueZBridgeHandler} is responsible for talking to the BlueZ stack, using DBus Unix Socket.\n+ * This Binding does not use any JNI.\n+ * It provides a private interface for {@link BlueZBluetoothDevice}s to access the stack and provides top\n+ * level adaptor functionality for scanning and arbitration.\n+ *\n+ * @author Kai Kreuzer - Initial contribution and API\n+ * @author Hilbrand Bouwkamp - Simplified calling scan and better handling manual scanning\n+ * @author Connor Petty - Simplified device scan logic\n+ * @author Benjamin Lafois - Replaced tinyB with bluezDbus\n+ *\n+ */\n+@NonNullByDefault\n+public class BlueZBridgeHandler extends AbstractBluetoothBridgeHandler<BlueZBluetoothDevice>\n+        implements BlueZEventListener {\n+\n+    private final Logger logger = LoggerFactory.getLogger(BlueZBridgeHandler.class);\n+\n+    // ADAPTER from BlueZ-DBus Library\n+    private @Nullable BluetoothAdapter adapter;\n+\n+    // Our BT address\n+    private @Nullable BluetoothAddress adapterAddress;\n+\n+    private @Nullable ScheduledFuture<?> discoveryJob;\n+\n+    private final DeviceManagerFactory deviceManagerFactory;\n+\n+    /**\n+     * Constructor\n+     *\n+     * @param bridge the bridge definition for this handler\n+     */\n+    public BlueZBridgeHandler(Bridge bridge, DeviceManagerFactory deviceManagerFactory) {\n+        super(bridge);\n+        this.deviceManagerFactory = deviceManagerFactory;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        super.initialize();\n+\n+        // Load configuration\n+        final BlueZAdapterConfiguration configuration = getConfigAs(BlueZAdapterConfiguration.class);\n+        String addr = configuration.address;\n+        if (addr != null) {\n+            this.adapterAddress = new BluetoothAddress(addr.toUpperCase());\n+        } else {\n+            // If configuration does not contain adapter address to use, exit with error.\n+            logger.info(\"Adapter MAC address not provided\");\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"address not set\");\n+            return;\n+        }\n+\n+        logger.debug(\"Creating BlueZ adapter with address '{}'\", adapterAddress);\n+\n+        updateStatus(ThingStatus.UNKNOWN, ThingStatusDetail.CONFIGURATION_PENDING, \"Initializing\");\n+\n+        deviceManagerFactory.getPropertiesChangedHandler().addListener(this);\n+\n+        discoveryJob = scheduler.scheduleWithFixedDelay(this::initializeAndRefreshDevices, 5, 10, TimeUnit.SECONDS);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9c2c484c0a68abcdb7f6e511a0635e2dd9353821"}, "originalPosition": 97}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIwMjE4MjE5OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.bluetooth.bluez/src/main/java/org/openhab/binding/bluetooth/bluez/internal/BlueZBridgeHandler.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QyMTo0ODozNlrOHnfWug==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNFQwNzozNTowOFrOHnpRbw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTE3MDIzNA==", "bodyText": "As far as I know, there isn't such a thing as duty cycle for BT - that's only a regulation on 868/900MHz. Better put detail to NONE.", "url": "https://github.com/openhab/openhab-addons/pull/8819#discussion_r511170234", "createdAt": "2020-10-23T21:48:36Z", "author": {"login": "kaikreuzer"}, "path": "bundles/org.openhab.binding.bluetooth.bluez/src/main/java/org/openhab/binding/bluetooth/bluez/internal/BlueZBridgeHandler.java", "diffHunk": "@@ -0,0 +1,241 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bluetooth.bluez.internal;\n+\n+import java.util.List;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.bluetooth.AbstractBluetoothBridgeHandler;\n+import org.openhab.binding.bluetooth.BluetoothAddress;\n+import org.openhab.binding.bluetooth.bluez.internal.events.AdapterDiscoveringChangedEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.AdapterPoweredChangedEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.BlueZEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.BlueZEventListener;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.github.hypfvieh.bluetooth.wrapper.BluetoothAdapter;\n+import com.github.hypfvieh.bluetooth.wrapper.BluetoothDevice;\n+\n+/**\n+ * The {@link BlueZBridgeHandler} is responsible for talking to the BlueZ stack, using DBus Unix Socket.\n+ * This Binding does not use any JNI.\n+ * It provides a private interface for {@link BlueZBluetoothDevice}s to access the stack and provides top\n+ * level adaptor functionality for scanning and arbitration.\n+ *\n+ * @author Kai Kreuzer - Initial contribution and API\n+ * @author Hilbrand Bouwkamp - Simplified calling scan and better handling manual scanning\n+ * @author Connor Petty - Simplified device scan logic\n+ * @author Benjamin Lafois - Replaced tinyB with bluezDbus\n+ *\n+ */\n+@NonNullByDefault\n+public class BlueZBridgeHandler extends AbstractBluetoothBridgeHandler<BlueZBluetoothDevice>\n+        implements BlueZEventListener {\n+\n+    private final Logger logger = LoggerFactory.getLogger(BlueZBridgeHandler.class);\n+\n+    // ADAPTER from BlueZ-DBus Library\n+    private @Nullable BluetoothAdapter adapter;\n+\n+    // Our BT address\n+    private @Nullable BluetoothAddress adapterAddress;\n+\n+    private @Nullable ScheduledFuture<?> discoveryJob;\n+\n+    private final DeviceManagerFactory deviceManagerFactory;\n+\n+    /**\n+     * Constructor\n+     *\n+     * @param bridge the bridge definition for this handler\n+     */\n+    public BlueZBridgeHandler(Bridge bridge, DeviceManagerFactory deviceManagerFactory) {\n+        super(bridge);\n+        this.deviceManagerFactory = deviceManagerFactory;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        super.initialize();\n+\n+        // Load configuration\n+        final BlueZAdapterConfiguration configuration = getConfigAs(BlueZAdapterConfiguration.class);\n+        String addr = configuration.address;\n+        if (addr != null) {\n+            this.adapterAddress = new BluetoothAddress(addr.toUpperCase());\n+        } else {\n+            // If configuration does not contain adapter address to use, exit with error.\n+            logger.info(\"Adapter MAC address not provided\");\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"address not set\");\n+            return;\n+        }\n+\n+        logger.debug(\"Creating BlueZ adapter with address '{}'\", adapterAddress);\n+\n+        updateStatus(ThingStatus.UNKNOWN, ThingStatusDetail.CONFIGURATION_PENDING, \"Initializing\");\n+\n+        deviceManagerFactory.getPropertiesChangedHandler().addListener(this);\n+\n+        discoveryJob = scheduler.scheduleWithFixedDelay(this::initializeAndRefreshDevices, 5, 10, TimeUnit.SECONDS);\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        deviceManagerFactory.getPropertiesChangedHandler().removeListener(this);\n+        logger.debug(\"Termination of DBus BlueZ handler\");\n+\n+        Future<?> job = discoveryJob;\n+        if (job != null) {\n+            job.cancel(false);\n+            discoveryJob = null;\n+        }\n+\n+        BluetoothAdapter localAdatper = this.adapter;\n+        if (localAdatper != null) {\n+            localAdatper.stopDiscovery();\n+            this.adapter = null;\n+        }\n+\n+        super.dispose();\n+    }\n+\n+    private @Nullable BluetoothAdapter prepareAdapter(DeviceManagerWrapper deviceManager) {\n+        // next lets check if we can find our adapter in the manager.\n+        BluetoothAdapter localAdapter = adapter;\n+        if (localAdapter == null) {\n+            BluetoothAddress localAddress = adapterAddress;\n+            if (localAddress != null) {\n+                localAdapter = adapter = deviceManager.getAdapter(localAddress);\n+            } else {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"No adapter address provided\");\n+                return null;\n+            }\n+        }\n+        if (localAdapter == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                    \"Native adapter could not be found for address '\" + adapterAddress + \"'\");\n+            return null;\n+        }\n+        // now lets confirm that the adapter is powered\n+        if (!localAdapter.isPowered()) {\n+            localAdapter.setPowered(true);\n+            // give the device some time to power on\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.DUTY_CYCLE,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9c2c484c0a68abcdb7f6e511a0635e2dd9353821"}, "originalPosition": 141}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTIwNDA2Mg==", "bodyText": "changed to NONE", "url": "https://github.com/openhab/openhab-addons/pull/8819#discussion_r511204062", "createdAt": "2020-10-24T00:11:17Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.bluetooth.bluez/src/main/java/org/openhab/binding/bluetooth/bluez/internal/BlueZBridgeHandler.java", "diffHunk": "@@ -0,0 +1,241 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bluetooth.bluez.internal;\n+\n+import java.util.List;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.bluetooth.AbstractBluetoothBridgeHandler;\n+import org.openhab.binding.bluetooth.BluetoothAddress;\n+import org.openhab.binding.bluetooth.bluez.internal.events.AdapterDiscoveringChangedEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.AdapterPoweredChangedEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.BlueZEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.BlueZEventListener;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.github.hypfvieh.bluetooth.wrapper.BluetoothAdapter;\n+import com.github.hypfvieh.bluetooth.wrapper.BluetoothDevice;\n+\n+/**\n+ * The {@link BlueZBridgeHandler} is responsible for talking to the BlueZ stack, using DBus Unix Socket.\n+ * This Binding does not use any JNI.\n+ * It provides a private interface for {@link BlueZBluetoothDevice}s to access the stack and provides top\n+ * level adaptor functionality for scanning and arbitration.\n+ *\n+ * @author Kai Kreuzer - Initial contribution and API\n+ * @author Hilbrand Bouwkamp - Simplified calling scan and better handling manual scanning\n+ * @author Connor Petty - Simplified device scan logic\n+ * @author Benjamin Lafois - Replaced tinyB with bluezDbus\n+ *\n+ */\n+@NonNullByDefault\n+public class BlueZBridgeHandler extends AbstractBluetoothBridgeHandler<BlueZBluetoothDevice>\n+        implements BlueZEventListener {\n+\n+    private final Logger logger = LoggerFactory.getLogger(BlueZBridgeHandler.class);\n+\n+    // ADAPTER from BlueZ-DBus Library\n+    private @Nullable BluetoothAdapter adapter;\n+\n+    // Our BT address\n+    private @Nullable BluetoothAddress adapterAddress;\n+\n+    private @Nullable ScheduledFuture<?> discoveryJob;\n+\n+    private final DeviceManagerFactory deviceManagerFactory;\n+\n+    /**\n+     * Constructor\n+     *\n+     * @param bridge the bridge definition for this handler\n+     */\n+    public BlueZBridgeHandler(Bridge bridge, DeviceManagerFactory deviceManagerFactory) {\n+        super(bridge);\n+        this.deviceManagerFactory = deviceManagerFactory;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        super.initialize();\n+\n+        // Load configuration\n+        final BlueZAdapterConfiguration configuration = getConfigAs(BlueZAdapterConfiguration.class);\n+        String addr = configuration.address;\n+        if (addr != null) {\n+            this.adapterAddress = new BluetoothAddress(addr.toUpperCase());\n+        } else {\n+            // If configuration does not contain adapter address to use, exit with error.\n+            logger.info(\"Adapter MAC address not provided\");\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"address not set\");\n+            return;\n+        }\n+\n+        logger.debug(\"Creating BlueZ adapter with address '{}'\", adapterAddress);\n+\n+        updateStatus(ThingStatus.UNKNOWN, ThingStatusDetail.CONFIGURATION_PENDING, \"Initializing\");\n+\n+        deviceManagerFactory.getPropertiesChangedHandler().addListener(this);\n+\n+        discoveryJob = scheduler.scheduleWithFixedDelay(this::initializeAndRefreshDevices, 5, 10, TimeUnit.SECONDS);\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        deviceManagerFactory.getPropertiesChangedHandler().removeListener(this);\n+        logger.debug(\"Termination of DBus BlueZ handler\");\n+\n+        Future<?> job = discoveryJob;\n+        if (job != null) {\n+            job.cancel(false);\n+            discoveryJob = null;\n+        }\n+\n+        BluetoothAdapter localAdatper = this.adapter;\n+        if (localAdatper != null) {\n+            localAdatper.stopDiscovery();\n+            this.adapter = null;\n+        }\n+\n+        super.dispose();\n+    }\n+\n+    private @Nullable BluetoothAdapter prepareAdapter(DeviceManagerWrapper deviceManager) {\n+        // next lets check if we can find our adapter in the manager.\n+        BluetoothAdapter localAdapter = adapter;\n+        if (localAdapter == null) {\n+            BluetoothAddress localAddress = adapterAddress;\n+            if (localAddress != null) {\n+                localAdapter = adapter = deviceManager.getAdapter(localAddress);\n+            } else {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"No adapter address provided\");\n+                return null;\n+            }\n+        }\n+        if (localAdapter == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                    \"Native adapter could not be found for address '\" + adapterAddress + \"'\");\n+            return null;\n+        }\n+        // now lets confirm that the adapter is powered\n+        if (!localAdapter.isPowered()) {\n+            localAdapter.setPowered(true);\n+            // give the device some time to power on\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.DUTY_CYCLE,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTE3MDIzNA=="}, "originalCommit": {"oid": "9c2c484c0a68abcdb7f6e511a0635e2dd9353821"}, "originalPosition": 141}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTMzMjcxOQ==", "bodyText": "@kaikreuzer it is not because of regulation, but with testing, what I've realized is that when you power on the device, if you immediately start the discovery, it might fail, so you need to give the adapter a little time to start up. But yes the \"DUTY_CYCLE\" is not the right reason.", "url": "https://github.com/openhab/openhab-addons/pull/8819#discussion_r511332719", "createdAt": "2020-10-24T07:35:08Z", "author": {"login": "blafois"}, "path": "bundles/org.openhab.binding.bluetooth.bluez/src/main/java/org/openhab/binding/bluetooth/bluez/internal/BlueZBridgeHandler.java", "diffHunk": "@@ -0,0 +1,241 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bluetooth.bluez.internal;\n+\n+import java.util.List;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.bluetooth.AbstractBluetoothBridgeHandler;\n+import org.openhab.binding.bluetooth.BluetoothAddress;\n+import org.openhab.binding.bluetooth.bluez.internal.events.AdapterDiscoveringChangedEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.AdapterPoweredChangedEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.BlueZEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.BlueZEventListener;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.github.hypfvieh.bluetooth.wrapper.BluetoothAdapter;\n+import com.github.hypfvieh.bluetooth.wrapper.BluetoothDevice;\n+\n+/**\n+ * The {@link BlueZBridgeHandler} is responsible for talking to the BlueZ stack, using DBus Unix Socket.\n+ * This Binding does not use any JNI.\n+ * It provides a private interface for {@link BlueZBluetoothDevice}s to access the stack and provides top\n+ * level adaptor functionality for scanning and arbitration.\n+ *\n+ * @author Kai Kreuzer - Initial contribution and API\n+ * @author Hilbrand Bouwkamp - Simplified calling scan and better handling manual scanning\n+ * @author Connor Petty - Simplified device scan logic\n+ * @author Benjamin Lafois - Replaced tinyB with bluezDbus\n+ *\n+ */\n+@NonNullByDefault\n+public class BlueZBridgeHandler extends AbstractBluetoothBridgeHandler<BlueZBluetoothDevice>\n+        implements BlueZEventListener {\n+\n+    private final Logger logger = LoggerFactory.getLogger(BlueZBridgeHandler.class);\n+\n+    // ADAPTER from BlueZ-DBus Library\n+    private @Nullable BluetoothAdapter adapter;\n+\n+    // Our BT address\n+    private @Nullable BluetoothAddress adapterAddress;\n+\n+    private @Nullable ScheduledFuture<?> discoveryJob;\n+\n+    private final DeviceManagerFactory deviceManagerFactory;\n+\n+    /**\n+     * Constructor\n+     *\n+     * @param bridge the bridge definition for this handler\n+     */\n+    public BlueZBridgeHandler(Bridge bridge, DeviceManagerFactory deviceManagerFactory) {\n+        super(bridge);\n+        this.deviceManagerFactory = deviceManagerFactory;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        super.initialize();\n+\n+        // Load configuration\n+        final BlueZAdapterConfiguration configuration = getConfigAs(BlueZAdapterConfiguration.class);\n+        String addr = configuration.address;\n+        if (addr != null) {\n+            this.adapterAddress = new BluetoothAddress(addr.toUpperCase());\n+        } else {\n+            // If configuration does not contain adapter address to use, exit with error.\n+            logger.info(\"Adapter MAC address not provided\");\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"address not set\");\n+            return;\n+        }\n+\n+        logger.debug(\"Creating BlueZ adapter with address '{}'\", adapterAddress);\n+\n+        updateStatus(ThingStatus.UNKNOWN, ThingStatusDetail.CONFIGURATION_PENDING, \"Initializing\");\n+\n+        deviceManagerFactory.getPropertiesChangedHandler().addListener(this);\n+\n+        discoveryJob = scheduler.scheduleWithFixedDelay(this::initializeAndRefreshDevices, 5, 10, TimeUnit.SECONDS);\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        deviceManagerFactory.getPropertiesChangedHandler().removeListener(this);\n+        logger.debug(\"Termination of DBus BlueZ handler\");\n+\n+        Future<?> job = discoveryJob;\n+        if (job != null) {\n+            job.cancel(false);\n+            discoveryJob = null;\n+        }\n+\n+        BluetoothAdapter localAdatper = this.adapter;\n+        if (localAdatper != null) {\n+            localAdatper.stopDiscovery();\n+            this.adapter = null;\n+        }\n+\n+        super.dispose();\n+    }\n+\n+    private @Nullable BluetoothAdapter prepareAdapter(DeviceManagerWrapper deviceManager) {\n+        // next lets check if we can find our adapter in the manager.\n+        BluetoothAdapter localAdapter = adapter;\n+        if (localAdapter == null) {\n+            BluetoothAddress localAddress = adapterAddress;\n+            if (localAddress != null) {\n+                localAdapter = adapter = deviceManager.getAdapter(localAddress);\n+            } else {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"No adapter address provided\");\n+                return null;\n+            }\n+        }\n+        if (localAdapter == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                    \"Native adapter could not be found for address '\" + adapterAddress + \"'\");\n+            return null;\n+        }\n+        // now lets confirm that the adapter is powered\n+        if (!localAdapter.isPowered()) {\n+            localAdapter.setPowered(true);\n+            // give the device some time to power on\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.DUTY_CYCLE,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTE3MDIzNA=="}, "originalCommit": {"oid": "9c2c484c0a68abcdb7f6e511a0635e2dd9353821"}, "originalPosition": 141}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIwMjE4ODc1OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.bluetooth.bluez/src/main/java/org/openhab/binding/bluetooth/bluez/internal/BlueZBridgeHandler.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QyMTo1MTo0MVrOHnfamw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNFQwNzozODoyMFrOHnpSXQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTE3MTIyNw==", "bodyText": "Why OFFLINE? If you can start discovery on it, it seems to be available, i.e. ONLINE?", "url": "https://github.com/openhab/openhab-addons/pull/8819#discussion_r511171227", "createdAt": "2020-10-23T21:51:41Z", "author": {"login": "kaikreuzer"}, "path": "bundles/org.openhab.binding.bluetooth.bluez/src/main/java/org/openhab/binding/bluetooth/bluez/internal/BlueZBridgeHandler.java", "diffHunk": "@@ -0,0 +1,241 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bluetooth.bluez.internal;\n+\n+import java.util.List;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.bluetooth.AbstractBluetoothBridgeHandler;\n+import org.openhab.binding.bluetooth.BluetoothAddress;\n+import org.openhab.binding.bluetooth.bluez.internal.events.AdapterDiscoveringChangedEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.AdapterPoweredChangedEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.BlueZEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.BlueZEventListener;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.github.hypfvieh.bluetooth.wrapper.BluetoothAdapter;\n+import com.github.hypfvieh.bluetooth.wrapper.BluetoothDevice;\n+\n+/**\n+ * The {@link BlueZBridgeHandler} is responsible for talking to the BlueZ stack, using DBus Unix Socket.\n+ * This Binding does not use any JNI.\n+ * It provides a private interface for {@link BlueZBluetoothDevice}s to access the stack and provides top\n+ * level adaptor functionality for scanning and arbitration.\n+ *\n+ * @author Kai Kreuzer - Initial contribution and API\n+ * @author Hilbrand Bouwkamp - Simplified calling scan and better handling manual scanning\n+ * @author Connor Petty - Simplified device scan logic\n+ * @author Benjamin Lafois - Replaced tinyB with bluezDbus\n+ *\n+ */\n+@NonNullByDefault\n+public class BlueZBridgeHandler extends AbstractBluetoothBridgeHandler<BlueZBluetoothDevice>\n+        implements BlueZEventListener {\n+\n+    private final Logger logger = LoggerFactory.getLogger(BlueZBridgeHandler.class);\n+\n+    // ADAPTER from BlueZ-DBus Library\n+    private @Nullable BluetoothAdapter adapter;\n+\n+    // Our BT address\n+    private @Nullable BluetoothAddress adapterAddress;\n+\n+    private @Nullable ScheduledFuture<?> discoveryJob;\n+\n+    private final DeviceManagerFactory deviceManagerFactory;\n+\n+    /**\n+     * Constructor\n+     *\n+     * @param bridge the bridge definition for this handler\n+     */\n+    public BlueZBridgeHandler(Bridge bridge, DeviceManagerFactory deviceManagerFactory) {\n+        super(bridge);\n+        this.deviceManagerFactory = deviceManagerFactory;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        super.initialize();\n+\n+        // Load configuration\n+        final BlueZAdapterConfiguration configuration = getConfigAs(BlueZAdapterConfiguration.class);\n+        String addr = configuration.address;\n+        if (addr != null) {\n+            this.adapterAddress = new BluetoothAddress(addr.toUpperCase());\n+        } else {\n+            // If configuration does not contain adapter address to use, exit with error.\n+            logger.info(\"Adapter MAC address not provided\");\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"address not set\");\n+            return;\n+        }\n+\n+        logger.debug(\"Creating BlueZ adapter with address '{}'\", adapterAddress);\n+\n+        updateStatus(ThingStatus.UNKNOWN, ThingStatusDetail.CONFIGURATION_PENDING, \"Initializing\");\n+\n+        deviceManagerFactory.getPropertiesChangedHandler().addListener(this);\n+\n+        discoveryJob = scheduler.scheduleWithFixedDelay(this::initializeAndRefreshDevices, 5, 10, TimeUnit.SECONDS);\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        deviceManagerFactory.getPropertiesChangedHandler().removeListener(this);\n+        logger.debug(\"Termination of DBus BlueZ handler\");\n+\n+        Future<?> job = discoveryJob;\n+        if (job != null) {\n+            job.cancel(false);\n+            discoveryJob = null;\n+        }\n+\n+        BluetoothAdapter localAdatper = this.adapter;\n+        if (localAdatper != null) {\n+            localAdatper.stopDiscovery();\n+            this.adapter = null;\n+        }\n+\n+        super.dispose();\n+    }\n+\n+    private @Nullable BluetoothAdapter prepareAdapter(DeviceManagerWrapper deviceManager) {\n+        // next lets check if we can find our adapter in the manager.\n+        BluetoothAdapter localAdapter = adapter;\n+        if (localAdapter == null) {\n+            BluetoothAddress localAddress = adapterAddress;\n+            if (localAddress != null) {\n+                localAdapter = adapter = deviceManager.getAdapter(localAddress);\n+            } else {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"No adapter address provided\");\n+                return null;\n+            }\n+        }\n+        if (localAdapter == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                    \"Native adapter could not be found for address '\" + adapterAddress + \"'\");\n+            return null;\n+        }\n+        // now lets confirm that the adapter is powered\n+        if (!localAdapter.isPowered()) {\n+            localAdapter.setPowered(true);\n+            // give the device some time to power on\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.DUTY_CYCLE,\n+                    \"Adapter is not powered, attempting to turn on...\");\n+            return null;\n+        }\n+\n+        // now lets make sure that discovery is turned on\n+        if (!Boolean.TRUE.equals(localAdapter.isDiscovering())) {\n+            // we will check for devices next time around\n+            localAdapter.startDiscovery();\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.DUTY_CYCLE, \"Starting discovery\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9c2c484c0a68abcdb7f6e511a0635e2dd9353821"}, "originalPosition": 150}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTE5NTg5OA==", "bodyText": "After looking at how startDiscovery was implemented, it looks like it already checks isDiscovering as part of it.\nI'll go ahead and simplify this logic then.", "url": "https://github.com/openhab/openhab-addons/pull/8819#discussion_r511195898", "createdAt": "2020-10-23T23:27:19Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.bluetooth.bluez/src/main/java/org/openhab/binding/bluetooth/bluez/internal/BlueZBridgeHandler.java", "diffHunk": "@@ -0,0 +1,241 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bluetooth.bluez.internal;\n+\n+import java.util.List;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.bluetooth.AbstractBluetoothBridgeHandler;\n+import org.openhab.binding.bluetooth.BluetoothAddress;\n+import org.openhab.binding.bluetooth.bluez.internal.events.AdapterDiscoveringChangedEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.AdapterPoweredChangedEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.BlueZEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.BlueZEventListener;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.github.hypfvieh.bluetooth.wrapper.BluetoothAdapter;\n+import com.github.hypfvieh.bluetooth.wrapper.BluetoothDevice;\n+\n+/**\n+ * The {@link BlueZBridgeHandler} is responsible for talking to the BlueZ stack, using DBus Unix Socket.\n+ * This Binding does not use any JNI.\n+ * It provides a private interface for {@link BlueZBluetoothDevice}s to access the stack and provides top\n+ * level adaptor functionality for scanning and arbitration.\n+ *\n+ * @author Kai Kreuzer - Initial contribution and API\n+ * @author Hilbrand Bouwkamp - Simplified calling scan and better handling manual scanning\n+ * @author Connor Petty - Simplified device scan logic\n+ * @author Benjamin Lafois - Replaced tinyB with bluezDbus\n+ *\n+ */\n+@NonNullByDefault\n+public class BlueZBridgeHandler extends AbstractBluetoothBridgeHandler<BlueZBluetoothDevice>\n+        implements BlueZEventListener {\n+\n+    private final Logger logger = LoggerFactory.getLogger(BlueZBridgeHandler.class);\n+\n+    // ADAPTER from BlueZ-DBus Library\n+    private @Nullable BluetoothAdapter adapter;\n+\n+    // Our BT address\n+    private @Nullable BluetoothAddress adapterAddress;\n+\n+    private @Nullable ScheduledFuture<?> discoveryJob;\n+\n+    private final DeviceManagerFactory deviceManagerFactory;\n+\n+    /**\n+     * Constructor\n+     *\n+     * @param bridge the bridge definition for this handler\n+     */\n+    public BlueZBridgeHandler(Bridge bridge, DeviceManagerFactory deviceManagerFactory) {\n+        super(bridge);\n+        this.deviceManagerFactory = deviceManagerFactory;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        super.initialize();\n+\n+        // Load configuration\n+        final BlueZAdapterConfiguration configuration = getConfigAs(BlueZAdapterConfiguration.class);\n+        String addr = configuration.address;\n+        if (addr != null) {\n+            this.adapterAddress = new BluetoothAddress(addr.toUpperCase());\n+        } else {\n+            // If configuration does not contain adapter address to use, exit with error.\n+            logger.info(\"Adapter MAC address not provided\");\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"address not set\");\n+            return;\n+        }\n+\n+        logger.debug(\"Creating BlueZ adapter with address '{}'\", adapterAddress);\n+\n+        updateStatus(ThingStatus.UNKNOWN, ThingStatusDetail.CONFIGURATION_PENDING, \"Initializing\");\n+\n+        deviceManagerFactory.getPropertiesChangedHandler().addListener(this);\n+\n+        discoveryJob = scheduler.scheduleWithFixedDelay(this::initializeAndRefreshDevices, 5, 10, TimeUnit.SECONDS);\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        deviceManagerFactory.getPropertiesChangedHandler().removeListener(this);\n+        logger.debug(\"Termination of DBus BlueZ handler\");\n+\n+        Future<?> job = discoveryJob;\n+        if (job != null) {\n+            job.cancel(false);\n+            discoveryJob = null;\n+        }\n+\n+        BluetoothAdapter localAdatper = this.adapter;\n+        if (localAdatper != null) {\n+            localAdatper.stopDiscovery();\n+            this.adapter = null;\n+        }\n+\n+        super.dispose();\n+    }\n+\n+    private @Nullable BluetoothAdapter prepareAdapter(DeviceManagerWrapper deviceManager) {\n+        // next lets check if we can find our adapter in the manager.\n+        BluetoothAdapter localAdapter = adapter;\n+        if (localAdapter == null) {\n+            BluetoothAddress localAddress = adapterAddress;\n+            if (localAddress != null) {\n+                localAdapter = adapter = deviceManager.getAdapter(localAddress);\n+            } else {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"No adapter address provided\");\n+                return null;\n+            }\n+        }\n+        if (localAdapter == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                    \"Native adapter could not be found for address '\" + adapterAddress + \"'\");\n+            return null;\n+        }\n+        // now lets confirm that the adapter is powered\n+        if (!localAdapter.isPowered()) {\n+            localAdapter.setPowered(true);\n+            // give the device some time to power on\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.DUTY_CYCLE,\n+                    \"Adapter is not powered, attempting to turn on...\");\n+            return null;\n+        }\n+\n+        // now lets make sure that discovery is turned on\n+        if (!Boolean.TRUE.equals(localAdapter.isDiscovering())) {\n+            // we will check for devices next time around\n+            localAdapter.startDiscovery();\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.DUTY_CYCLE, \"Starting discovery\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTE3MTIyNw=="}, "originalCommit": {"oid": "9c2c484c0a68abcdb7f6e511a0635e2dd9353821"}, "originalPosition": 150}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTMzMjk1Nw==", "bodyText": "I implemented this months ago - but if my memory is good - if you turn it ONLINE immediately, the various things depending on it will immediately try to connect, which will fail because the devices needs to be discovered before it's possible to connect. But I might be wrong, and I'll retest it when we will be done if all changes !", "url": "https://github.com/openhab/openhab-addons/pull/8819#discussion_r511332957", "createdAt": "2020-10-24T07:38:20Z", "author": {"login": "blafois"}, "path": "bundles/org.openhab.binding.bluetooth.bluez/src/main/java/org/openhab/binding/bluetooth/bluez/internal/BlueZBridgeHandler.java", "diffHunk": "@@ -0,0 +1,241 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bluetooth.bluez.internal;\n+\n+import java.util.List;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.bluetooth.AbstractBluetoothBridgeHandler;\n+import org.openhab.binding.bluetooth.BluetoothAddress;\n+import org.openhab.binding.bluetooth.bluez.internal.events.AdapterDiscoveringChangedEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.AdapterPoweredChangedEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.BlueZEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.BlueZEventListener;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.github.hypfvieh.bluetooth.wrapper.BluetoothAdapter;\n+import com.github.hypfvieh.bluetooth.wrapper.BluetoothDevice;\n+\n+/**\n+ * The {@link BlueZBridgeHandler} is responsible for talking to the BlueZ stack, using DBus Unix Socket.\n+ * This Binding does not use any JNI.\n+ * It provides a private interface for {@link BlueZBluetoothDevice}s to access the stack and provides top\n+ * level adaptor functionality for scanning and arbitration.\n+ *\n+ * @author Kai Kreuzer - Initial contribution and API\n+ * @author Hilbrand Bouwkamp - Simplified calling scan and better handling manual scanning\n+ * @author Connor Petty - Simplified device scan logic\n+ * @author Benjamin Lafois - Replaced tinyB with bluezDbus\n+ *\n+ */\n+@NonNullByDefault\n+public class BlueZBridgeHandler extends AbstractBluetoothBridgeHandler<BlueZBluetoothDevice>\n+        implements BlueZEventListener {\n+\n+    private final Logger logger = LoggerFactory.getLogger(BlueZBridgeHandler.class);\n+\n+    // ADAPTER from BlueZ-DBus Library\n+    private @Nullable BluetoothAdapter adapter;\n+\n+    // Our BT address\n+    private @Nullable BluetoothAddress adapterAddress;\n+\n+    private @Nullable ScheduledFuture<?> discoveryJob;\n+\n+    private final DeviceManagerFactory deviceManagerFactory;\n+\n+    /**\n+     * Constructor\n+     *\n+     * @param bridge the bridge definition for this handler\n+     */\n+    public BlueZBridgeHandler(Bridge bridge, DeviceManagerFactory deviceManagerFactory) {\n+        super(bridge);\n+        this.deviceManagerFactory = deviceManagerFactory;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        super.initialize();\n+\n+        // Load configuration\n+        final BlueZAdapterConfiguration configuration = getConfigAs(BlueZAdapterConfiguration.class);\n+        String addr = configuration.address;\n+        if (addr != null) {\n+            this.adapterAddress = new BluetoothAddress(addr.toUpperCase());\n+        } else {\n+            // If configuration does not contain adapter address to use, exit with error.\n+            logger.info(\"Adapter MAC address not provided\");\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"address not set\");\n+            return;\n+        }\n+\n+        logger.debug(\"Creating BlueZ adapter with address '{}'\", adapterAddress);\n+\n+        updateStatus(ThingStatus.UNKNOWN, ThingStatusDetail.CONFIGURATION_PENDING, \"Initializing\");\n+\n+        deviceManagerFactory.getPropertiesChangedHandler().addListener(this);\n+\n+        discoveryJob = scheduler.scheduleWithFixedDelay(this::initializeAndRefreshDevices, 5, 10, TimeUnit.SECONDS);\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        deviceManagerFactory.getPropertiesChangedHandler().removeListener(this);\n+        logger.debug(\"Termination of DBus BlueZ handler\");\n+\n+        Future<?> job = discoveryJob;\n+        if (job != null) {\n+            job.cancel(false);\n+            discoveryJob = null;\n+        }\n+\n+        BluetoothAdapter localAdatper = this.adapter;\n+        if (localAdatper != null) {\n+            localAdatper.stopDiscovery();\n+            this.adapter = null;\n+        }\n+\n+        super.dispose();\n+    }\n+\n+    private @Nullable BluetoothAdapter prepareAdapter(DeviceManagerWrapper deviceManager) {\n+        // next lets check if we can find our adapter in the manager.\n+        BluetoothAdapter localAdapter = adapter;\n+        if (localAdapter == null) {\n+            BluetoothAddress localAddress = adapterAddress;\n+            if (localAddress != null) {\n+                localAdapter = adapter = deviceManager.getAdapter(localAddress);\n+            } else {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"No adapter address provided\");\n+                return null;\n+            }\n+        }\n+        if (localAdapter == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                    \"Native adapter could not be found for address '\" + adapterAddress + \"'\");\n+            return null;\n+        }\n+        // now lets confirm that the adapter is powered\n+        if (!localAdapter.isPowered()) {\n+            localAdapter.setPowered(true);\n+            // give the device some time to power on\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.DUTY_CYCLE,\n+                    \"Adapter is not powered, attempting to turn on...\");\n+            return null;\n+        }\n+\n+        // now lets make sure that discovery is turned on\n+        if (!Boolean.TRUE.equals(localAdapter.isDiscovering())) {\n+            // we will check for devices next time around\n+            localAdapter.startDiscovery();\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.DUTY_CYCLE, \"Starting discovery\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTE3MTIyNw=="}, "originalCommit": {"oid": "9c2c484c0a68abcdb7f6e511a0635e2dd9353821"}, "originalPosition": 150}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIwMjE4OTI3OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.bluetooth.bluez/src/main/java/org/openhab/binding/bluetooth/bluez/internal/BlueZBridgeHandler.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QyMTo1MTo1NlrOHnfa8g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QyMzoyODoyOVrOHng74g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTE3MTMxNA==", "bodyText": "can this line be removed?", "url": "https://github.com/openhab/openhab-addons/pull/8819#discussion_r511171314", "createdAt": "2020-10-23T21:51:56Z", "author": {"login": "kaikreuzer"}, "path": "bundles/org.openhab.binding.bluetooth.bluez/src/main/java/org/openhab/binding/bluetooth/bluez/internal/BlueZBridgeHandler.java", "diffHunk": "@@ -0,0 +1,241 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bluetooth.bluez.internal;\n+\n+import java.util.List;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.bluetooth.AbstractBluetoothBridgeHandler;\n+import org.openhab.binding.bluetooth.BluetoothAddress;\n+import org.openhab.binding.bluetooth.bluez.internal.events.AdapterDiscoveringChangedEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.AdapterPoweredChangedEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.BlueZEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.BlueZEventListener;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.github.hypfvieh.bluetooth.wrapper.BluetoothAdapter;\n+import com.github.hypfvieh.bluetooth.wrapper.BluetoothDevice;\n+\n+/**\n+ * The {@link BlueZBridgeHandler} is responsible for talking to the BlueZ stack, using DBus Unix Socket.\n+ * This Binding does not use any JNI.\n+ * It provides a private interface for {@link BlueZBluetoothDevice}s to access the stack and provides top\n+ * level adaptor functionality for scanning and arbitration.\n+ *\n+ * @author Kai Kreuzer - Initial contribution and API\n+ * @author Hilbrand Bouwkamp - Simplified calling scan and better handling manual scanning\n+ * @author Connor Petty - Simplified device scan logic\n+ * @author Benjamin Lafois - Replaced tinyB with bluezDbus\n+ *\n+ */\n+@NonNullByDefault\n+public class BlueZBridgeHandler extends AbstractBluetoothBridgeHandler<BlueZBluetoothDevice>\n+        implements BlueZEventListener {\n+\n+    private final Logger logger = LoggerFactory.getLogger(BlueZBridgeHandler.class);\n+\n+    // ADAPTER from BlueZ-DBus Library\n+    private @Nullable BluetoothAdapter adapter;\n+\n+    // Our BT address\n+    private @Nullable BluetoothAddress adapterAddress;\n+\n+    private @Nullable ScheduledFuture<?> discoveryJob;\n+\n+    private final DeviceManagerFactory deviceManagerFactory;\n+\n+    /**\n+     * Constructor\n+     *\n+     * @param bridge the bridge definition for this handler\n+     */\n+    public BlueZBridgeHandler(Bridge bridge, DeviceManagerFactory deviceManagerFactory) {\n+        super(bridge);\n+        this.deviceManagerFactory = deviceManagerFactory;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        super.initialize();\n+\n+        // Load configuration\n+        final BlueZAdapterConfiguration configuration = getConfigAs(BlueZAdapterConfiguration.class);\n+        String addr = configuration.address;\n+        if (addr != null) {\n+            this.adapterAddress = new BluetoothAddress(addr.toUpperCase());\n+        } else {\n+            // If configuration does not contain adapter address to use, exit with error.\n+            logger.info(\"Adapter MAC address not provided\");\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"address not set\");\n+            return;\n+        }\n+\n+        logger.debug(\"Creating BlueZ adapter with address '{}'\", adapterAddress);\n+\n+        updateStatus(ThingStatus.UNKNOWN, ThingStatusDetail.CONFIGURATION_PENDING, \"Initializing\");\n+\n+        deviceManagerFactory.getPropertiesChangedHandler().addListener(this);\n+\n+        discoveryJob = scheduler.scheduleWithFixedDelay(this::initializeAndRefreshDevices, 5, 10, TimeUnit.SECONDS);\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        deviceManagerFactory.getPropertiesChangedHandler().removeListener(this);\n+        logger.debug(\"Termination of DBus BlueZ handler\");\n+\n+        Future<?> job = discoveryJob;\n+        if (job != null) {\n+            job.cancel(false);\n+            discoveryJob = null;\n+        }\n+\n+        BluetoothAdapter localAdatper = this.adapter;\n+        if (localAdatper != null) {\n+            localAdatper.stopDiscovery();\n+            this.adapter = null;\n+        }\n+\n+        super.dispose();\n+    }\n+\n+    private @Nullable BluetoothAdapter prepareAdapter(DeviceManagerWrapper deviceManager) {\n+        // next lets check if we can find our adapter in the manager.\n+        BluetoothAdapter localAdapter = adapter;\n+        if (localAdapter == null) {\n+            BluetoothAddress localAddress = adapterAddress;\n+            if (localAddress != null) {\n+                localAdapter = adapter = deviceManager.getAdapter(localAddress);\n+            } else {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"No adapter address provided\");\n+                return null;\n+            }\n+        }\n+        if (localAdapter == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                    \"Native adapter could not be found for address '\" + adapterAddress + \"'\");\n+            return null;\n+        }\n+        // now lets confirm that the adapter is powered\n+        if (!localAdapter.isPowered()) {\n+            localAdapter.setPowered(true);\n+            // give the device some time to power on\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.DUTY_CYCLE,\n+                    \"Adapter is not powered, attempting to turn on...\");\n+            return null;\n+        }\n+\n+        // now lets make sure that discovery is turned on\n+        if (!Boolean.TRUE.equals(localAdapter.isDiscovering())) {\n+            // we will check for devices next time around\n+            localAdapter.startDiscovery();\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.DUTY_CYCLE, \"Starting discovery\");\n+            return null;\n+        }\n+        return localAdapter;\n+    }\n+\n+    private void initializeAndRefreshDevices() {\n+        logger.debug(\"initializeAndRefreshDevice()\");\n+\n+        try {\n+            // first check if the device manager is ready\n+            DeviceManagerWrapper deviceManager = deviceManagerFactory.getDeviceManager();\n+            if (deviceManager == null) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        \"Bluez DeviceManager not available yet.\");\n+                return;\n+            }\n+\n+            BluetoothAdapter adapter = prepareAdapter(deviceManager);\n+            if (adapter == null) {\n+                // adapter isn't prepared yet\n+                return;\n+            }\n+\n+            // now lets refresh devices\n+            List<BluetoothDevice> bluezDevices = deviceManager.getDevices(adapter);\n+            logger.debug(\"Found {} Bluetooth devices.\", bluezDevices.size());\n+            for (BluetoothDevice bluezDevice : bluezDevices) {\n+                // logger.debug(\"discovered device {}\", bluezDevice);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9c2c484c0a68abcdb7f6e511a0635e2dd9353821"}, "originalPosition": 178}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTE5NjEzMA==", "bodyText": "indeed it can", "url": "https://github.com/openhab/openhab-addons/pull/8819#discussion_r511196130", "createdAt": "2020-10-23T23:28:29Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.bluetooth.bluez/src/main/java/org/openhab/binding/bluetooth/bluez/internal/BlueZBridgeHandler.java", "diffHunk": "@@ -0,0 +1,241 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bluetooth.bluez.internal;\n+\n+import java.util.List;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.bluetooth.AbstractBluetoothBridgeHandler;\n+import org.openhab.binding.bluetooth.BluetoothAddress;\n+import org.openhab.binding.bluetooth.bluez.internal.events.AdapterDiscoveringChangedEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.AdapterPoweredChangedEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.BlueZEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.BlueZEventListener;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.github.hypfvieh.bluetooth.wrapper.BluetoothAdapter;\n+import com.github.hypfvieh.bluetooth.wrapper.BluetoothDevice;\n+\n+/**\n+ * The {@link BlueZBridgeHandler} is responsible for talking to the BlueZ stack, using DBus Unix Socket.\n+ * This Binding does not use any JNI.\n+ * It provides a private interface for {@link BlueZBluetoothDevice}s to access the stack and provides top\n+ * level adaptor functionality for scanning and arbitration.\n+ *\n+ * @author Kai Kreuzer - Initial contribution and API\n+ * @author Hilbrand Bouwkamp - Simplified calling scan and better handling manual scanning\n+ * @author Connor Petty - Simplified device scan logic\n+ * @author Benjamin Lafois - Replaced tinyB with bluezDbus\n+ *\n+ */\n+@NonNullByDefault\n+public class BlueZBridgeHandler extends AbstractBluetoothBridgeHandler<BlueZBluetoothDevice>\n+        implements BlueZEventListener {\n+\n+    private final Logger logger = LoggerFactory.getLogger(BlueZBridgeHandler.class);\n+\n+    // ADAPTER from BlueZ-DBus Library\n+    private @Nullable BluetoothAdapter adapter;\n+\n+    // Our BT address\n+    private @Nullable BluetoothAddress adapterAddress;\n+\n+    private @Nullable ScheduledFuture<?> discoveryJob;\n+\n+    private final DeviceManagerFactory deviceManagerFactory;\n+\n+    /**\n+     * Constructor\n+     *\n+     * @param bridge the bridge definition for this handler\n+     */\n+    public BlueZBridgeHandler(Bridge bridge, DeviceManagerFactory deviceManagerFactory) {\n+        super(bridge);\n+        this.deviceManagerFactory = deviceManagerFactory;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        super.initialize();\n+\n+        // Load configuration\n+        final BlueZAdapterConfiguration configuration = getConfigAs(BlueZAdapterConfiguration.class);\n+        String addr = configuration.address;\n+        if (addr != null) {\n+            this.adapterAddress = new BluetoothAddress(addr.toUpperCase());\n+        } else {\n+            // If configuration does not contain adapter address to use, exit with error.\n+            logger.info(\"Adapter MAC address not provided\");\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"address not set\");\n+            return;\n+        }\n+\n+        logger.debug(\"Creating BlueZ adapter with address '{}'\", adapterAddress);\n+\n+        updateStatus(ThingStatus.UNKNOWN, ThingStatusDetail.CONFIGURATION_PENDING, \"Initializing\");\n+\n+        deviceManagerFactory.getPropertiesChangedHandler().addListener(this);\n+\n+        discoveryJob = scheduler.scheduleWithFixedDelay(this::initializeAndRefreshDevices, 5, 10, TimeUnit.SECONDS);\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        deviceManagerFactory.getPropertiesChangedHandler().removeListener(this);\n+        logger.debug(\"Termination of DBus BlueZ handler\");\n+\n+        Future<?> job = discoveryJob;\n+        if (job != null) {\n+            job.cancel(false);\n+            discoveryJob = null;\n+        }\n+\n+        BluetoothAdapter localAdatper = this.adapter;\n+        if (localAdatper != null) {\n+            localAdatper.stopDiscovery();\n+            this.adapter = null;\n+        }\n+\n+        super.dispose();\n+    }\n+\n+    private @Nullable BluetoothAdapter prepareAdapter(DeviceManagerWrapper deviceManager) {\n+        // next lets check if we can find our adapter in the manager.\n+        BluetoothAdapter localAdapter = adapter;\n+        if (localAdapter == null) {\n+            BluetoothAddress localAddress = adapterAddress;\n+            if (localAddress != null) {\n+                localAdapter = adapter = deviceManager.getAdapter(localAddress);\n+            } else {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"No adapter address provided\");\n+                return null;\n+            }\n+        }\n+        if (localAdapter == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                    \"Native adapter could not be found for address '\" + adapterAddress + \"'\");\n+            return null;\n+        }\n+        // now lets confirm that the adapter is powered\n+        if (!localAdapter.isPowered()) {\n+            localAdapter.setPowered(true);\n+            // give the device some time to power on\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.DUTY_CYCLE,\n+                    \"Adapter is not powered, attempting to turn on...\");\n+            return null;\n+        }\n+\n+        // now lets make sure that discovery is turned on\n+        if (!Boolean.TRUE.equals(localAdapter.isDiscovering())) {\n+            // we will check for devices next time around\n+            localAdapter.startDiscovery();\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.DUTY_CYCLE, \"Starting discovery\");\n+            return null;\n+        }\n+        return localAdapter;\n+    }\n+\n+    private void initializeAndRefreshDevices() {\n+        logger.debug(\"initializeAndRefreshDevice()\");\n+\n+        try {\n+            // first check if the device manager is ready\n+            DeviceManagerWrapper deviceManager = deviceManagerFactory.getDeviceManager();\n+            if (deviceManager == null) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        \"Bluez DeviceManager not available yet.\");\n+                return;\n+            }\n+\n+            BluetoothAdapter adapter = prepareAdapter(deviceManager);\n+            if (adapter == null) {\n+                // adapter isn't prepared yet\n+                return;\n+            }\n+\n+            // now lets refresh devices\n+            List<BluetoothDevice> bluezDevices = deviceManager.getDevices(adapter);\n+            logger.debug(\"Found {} Bluetooth devices.\", bluezDevices.size());\n+            for (BluetoothDevice bluezDevice : bluezDevices) {\n+                // logger.debug(\"discovered device {}\", bluezDevice);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTE3MTMxNA=="}, "originalCommit": {"oid": "9c2c484c0a68abcdb7f6e511a0635e2dd9353821"}, "originalPosition": 178}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIwMjE5Njc2OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.bluetooth.bluez/src/main/java/org/openhab/binding/bluetooth/bluez/internal/events/CharacteristicUpdateEvent.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QyMTo1NToxMFrOHnffVg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNFQwMDowODowNFrOHnhYOw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTE3MjQzOA==", "bodyText": "Could you please add a one line JavaDoc description here and in all the classes below with the same empty JavaDoc header?", "url": "https://github.com/openhab/openhab-addons/pull/8819#discussion_r511172438", "createdAt": "2020-10-23T21:55:10Z", "author": {"login": "kaikreuzer"}, "path": "bundles/org.openhab.binding.bluetooth.bluez/src/main/java/org/openhab/binding/bluetooth/bluez/internal/events/CharacteristicUpdateEvent.java", "diffHunk": "@@ -0,0 +1,40 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bluetooth.bluez.internal.events;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+\n+/**\n+ *", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9c2c484c0a68abcdb7f6e511a0635e2dd9353821"}, "originalPosition": 18}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTIwMzM4Nw==", "bodyText": "done", "url": "https://github.com/openhab/openhab-addons/pull/8819#discussion_r511203387", "createdAt": "2020-10-24T00:08:04Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.bluetooth.bluez/src/main/java/org/openhab/binding/bluetooth/bluez/internal/events/CharacteristicUpdateEvent.java", "diffHunk": "@@ -0,0 +1,40 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bluetooth.bluez.internal.events;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+\n+/**\n+ *", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTE3MjQzOA=="}, "originalCommit": {"oid": "9c2c484c0a68abcdb7f6e511a0635e2dd9353821"}, "originalPosition": 18}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIwMzIxMjA0OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.bluetooth.bluez/src/main/java/org/openhab/binding/bluetooth/bluez/internal/BlueZBridgeHandler.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNFQwODoxNDozMVrOHnpd5g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNFQxNjozNDoyNlrOHny3yA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTMzNTkxMA==", "bodyText": "It seems you had missed this change - CONFIGURATION_PENDING is not a valid status detail here.\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    updateStatus(ThingStatus.UNKNOWN, ThingStatusDetail.CONFIGURATION_PENDING, \"Initializing\");\n          \n          \n            \n                    updateStatus(ThingStatus.UNKNOWN, ThingStatusDetail.NONE, \"Initializing\");", "url": "https://github.com/openhab/openhab-addons/pull/8819#discussion_r511335910", "createdAt": "2020-10-24T08:14:31Z", "author": {"login": "kaikreuzer"}, "path": "bundles/org.openhab.binding.bluetooth.bluez/src/main/java/org/openhab/binding/bluetooth/bluez/internal/BlueZBridgeHandler.java", "diffHunk": "@@ -0,0 +1,234 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bluetooth.bluez.internal;\n+\n+import java.util.List;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.bluetooth.AbstractBluetoothBridgeHandler;\n+import org.openhab.binding.bluetooth.BluetoothAddress;\n+import org.openhab.binding.bluetooth.bluez.internal.events.AdapterDiscoveringChangedEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.AdapterPoweredChangedEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.BlueZEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.BlueZEventListener;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.github.hypfvieh.bluetooth.wrapper.BluetoothAdapter;\n+import com.github.hypfvieh.bluetooth.wrapper.BluetoothDevice;\n+\n+/**\n+ * The {@link BlueZBridgeHandler} is responsible for talking to the BlueZ stack, using DBus Unix Socket.\n+ * This Binding does not use any JNI.\n+ * It provides a private interface for {@link BlueZBluetoothDevice}s to access the stack and provides top\n+ * level adaptor functionality for scanning and arbitration.\n+ *\n+ * @author Kai Kreuzer - Initial contribution and API\n+ * @author Hilbrand Bouwkamp - Simplified calling scan and better handling manual scanning\n+ * @author Connor Petty - Simplified device scan logic\n+ * @author Benjamin Lafois - Replaced tinyB with bluezDbus\n+ *\n+ */\n+@NonNullByDefault\n+public class BlueZBridgeHandler extends AbstractBluetoothBridgeHandler<BlueZBluetoothDevice>\n+        implements BlueZEventListener {\n+\n+    private final Logger logger = LoggerFactory.getLogger(BlueZBridgeHandler.class);\n+\n+    // ADAPTER from BlueZ-DBus Library\n+    private @Nullable BluetoothAdapter adapter;\n+\n+    // Our BT address\n+    private @Nullable BluetoothAddress adapterAddress;\n+\n+    private @Nullable ScheduledFuture<?> discoveryJob;\n+\n+    private final DeviceManagerFactory deviceManagerFactory;\n+\n+    /**\n+     * Constructor\n+     *\n+     * @param bridge the bridge definition for this handler\n+     */\n+    public BlueZBridgeHandler(Bridge bridge, DeviceManagerFactory deviceManagerFactory) {\n+        super(bridge);\n+        this.deviceManagerFactory = deviceManagerFactory;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        super.initialize();\n+\n+        // Load configuration\n+        final BlueZAdapterConfiguration configuration = getConfigAs(BlueZAdapterConfiguration.class);\n+        String addr = configuration.address;\n+        if (addr != null) {\n+            this.adapterAddress = new BluetoothAddress(addr.toUpperCase());\n+        } else {\n+            // If configuration does not contain adapter address to use, exit with error.\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"address not set\");\n+            return;\n+        }\n+\n+        logger.debug(\"Creating BlueZ adapter with address '{}'\", adapterAddress);\n+        updateStatus(ThingStatus.UNKNOWN, ThingStatusDetail.CONFIGURATION_PENDING, \"Initializing\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "00984dbaccb9f9fa3e6fd380ee55bdd7d5ba65d9"}, "originalPosition": 91}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTQ4OTk5Mg==", "bodyText": "done", "url": "https://github.com/openhab/openhab-addons/pull/8819#discussion_r511489992", "createdAt": "2020-10-24T16:34:26Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.bluetooth.bluez/src/main/java/org/openhab/binding/bluetooth/bluez/internal/BlueZBridgeHandler.java", "diffHunk": "@@ -0,0 +1,234 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bluetooth.bluez.internal;\n+\n+import java.util.List;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.bluetooth.AbstractBluetoothBridgeHandler;\n+import org.openhab.binding.bluetooth.BluetoothAddress;\n+import org.openhab.binding.bluetooth.bluez.internal.events.AdapterDiscoveringChangedEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.AdapterPoweredChangedEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.BlueZEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.BlueZEventListener;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.github.hypfvieh.bluetooth.wrapper.BluetoothAdapter;\n+import com.github.hypfvieh.bluetooth.wrapper.BluetoothDevice;\n+\n+/**\n+ * The {@link BlueZBridgeHandler} is responsible for talking to the BlueZ stack, using DBus Unix Socket.\n+ * This Binding does not use any JNI.\n+ * It provides a private interface for {@link BlueZBluetoothDevice}s to access the stack and provides top\n+ * level adaptor functionality for scanning and arbitration.\n+ *\n+ * @author Kai Kreuzer - Initial contribution and API\n+ * @author Hilbrand Bouwkamp - Simplified calling scan and better handling manual scanning\n+ * @author Connor Petty - Simplified device scan logic\n+ * @author Benjamin Lafois - Replaced tinyB with bluezDbus\n+ *\n+ */\n+@NonNullByDefault\n+public class BlueZBridgeHandler extends AbstractBluetoothBridgeHandler<BlueZBluetoothDevice>\n+        implements BlueZEventListener {\n+\n+    private final Logger logger = LoggerFactory.getLogger(BlueZBridgeHandler.class);\n+\n+    // ADAPTER from BlueZ-DBus Library\n+    private @Nullable BluetoothAdapter adapter;\n+\n+    // Our BT address\n+    private @Nullable BluetoothAddress adapterAddress;\n+\n+    private @Nullable ScheduledFuture<?> discoveryJob;\n+\n+    private final DeviceManagerFactory deviceManagerFactory;\n+\n+    /**\n+     * Constructor\n+     *\n+     * @param bridge the bridge definition for this handler\n+     */\n+    public BlueZBridgeHandler(Bridge bridge, DeviceManagerFactory deviceManagerFactory) {\n+        super(bridge);\n+        this.deviceManagerFactory = deviceManagerFactory;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        super.initialize();\n+\n+        // Load configuration\n+        final BlueZAdapterConfiguration configuration = getConfigAs(BlueZAdapterConfiguration.class);\n+        String addr = configuration.address;\n+        if (addr != null) {\n+            this.adapterAddress = new BluetoothAddress(addr.toUpperCase());\n+        } else {\n+            // If configuration does not contain adapter address to use, exit with error.\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"address not set\");\n+            return;\n+        }\n+\n+        logger.debug(\"Creating BlueZ adapter with address '{}'\", adapterAddress);\n+        updateStatus(ThingStatus.UNKNOWN, ThingStatusDetail.CONFIGURATION_PENDING, \"Initializing\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTMzNTkxMA=="}, "originalCommit": {"oid": "00984dbaccb9f9fa3e6fd380ee55bdd7d5ba65d9"}, "originalPosition": 91}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIwMzIxNjg3OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.bluetooth.bluez/src/main/java/org/openhab/binding/bluetooth/bluez/internal/BlueZBridgeHandler.java", "isResolved": true, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNFQwODoyMDo1OFrOHnpgGA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNVQwMDo0NDoyMFrOHn1Vxw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTMzNjQ3Mg==", "bodyText": "I'm still not clear why it is OFFLINE here.\nThe message \"starting discovery\" seems to suggest that we are still initializing, so I would simply stay in UNKNOWN status that moment (until we know if the outcome is successful or not).\nIf I misunderstand the message and the comment above (\"make sure that discovery is turned on\") is actually correct by saying that we have discovered a situation where we expect discovery being enabled, while it isn't and we consider this a \"permanent\" issue with the adapter, then OFFLINE is indeed the right choice.\nCould you help me understand which one is right here?", "url": "https://github.com/openhab/openhab-addons/pull/8819#discussion_r511336472", "createdAt": "2020-10-24T08:20:58Z", "author": {"login": "kaikreuzer"}, "path": "bundles/org.openhab.binding.bluetooth.bluez/src/main/java/org/openhab/binding/bluetooth/bluez/internal/BlueZBridgeHandler.java", "diffHunk": "@@ -0,0 +1,234 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bluetooth.bluez.internal;\n+\n+import java.util.List;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.bluetooth.AbstractBluetoothBridgeHandler;\n+import org.openhab.binding.bluetooth.BluetoothAddress;\n+import org.openhab.binding.bluetooth.bluez.internal.events.AdapterDiscoveringChangedEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.AdapterPoweredChangedEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.BlueZEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.BlueZEventListener;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.github.hypfvieh.bluetooth.wrapper.BluetoothAdapter;\n+import com.github.hypfvieh.bluetooth.wrapper.BluetoothDevice;\n+\n+/**\n+ * The {@link BlueZBridgeHandler} is responsible for talking to the BlueZ stack, using DBus Unix Socket.\n+ * This Binding does not use any JNI.\n+ * It provides a private interface for {@link BlueZBluetoothDevice}s to access the stack and provides top\n+ * level adaptor functionality for scanning and arbitration.\n+ *\n+ * @author Kai Kreuzer - Initial contribution and API\n+ * @author Hilbrand Bouwkamp - Simplified calling scan and better handling manual scanning\n+ * @author Connor Petty - Simplified device scan logic\n+ * @author Benjamin Lafois - Replaced tinyB with bluezDbus\n+ *\n+ */\n+@NonNullByDefault\n+public class BlueZBridgeHandler extends AbstractBluetoothBridgeHandler<BlueZBluetoothDevice>\n+        implements BlueZEventListener {\n+\n+    private final Logger logger = LoggerFactory.getLogger(BlueZBridgeHandler.class);\n+\n+    // ADAPTER from BlueZ-DBus Library\n+    private @Nullable BluetoothAdapter adapter;\n+\n+    // Our BT address\n+    private @Nullable BluetoothAddress adapterAddress;\n+\n+    private @Nullable ScheduledFuture<?> discoveryJob;\n+\n+    private final DeviceManagerFactory deviceManagerFactory;\n+\n+    /**\n+     * Constructor\n+     *\n+     * @param bridge the bridge definition for this handler\n+     */\n+    public BlueZBridgeHandler(Bridge bridge, DeviceManagerFactory deviceManagerFactory) {\n+        super(bridge);\n+        this.deviceManagerFactory = deviceManagerFactory;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        super.initialize();\n+\n+        // Load configuration\n+        final BlueZAdapterConfiguration configuration = getConfigAs(BlueZAdapterConfiguration.class);\n+        String addr = configuration.address;\n+        if (addr != null) {\n+            this.adapterAddress = new BluetoothAddress(addr.toUpperCase());\n+        } else {\n+            // If configuration does not contain adapter address to use, exit with error.\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"address not set\");\n+            return;\n+        }\n+\n+        logger.debug(\"Creating BlueZ adapter with address '{}'\", adapterAddress);\n+        updateStatus(ThingStatus.UNKNOWN, ThingStatusDetail.CONFIGURATION_PENDING, \"Initializing\");\n+        deviceManagerFactory.getPropertiesChangedHandler().addListener(this);\n+        discoveryJob = scheduler.scheduleWithFixedDelay(this::initializeAndRefreshDevices, 5, 10, TimeUnit.SECONDS);\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        deviceManagerFactory.getPropertiesChangedHandler().removeListener(this);\n+        logger.debug(\"Termination of DBus BlueZ handler\");\n+\n+        Future<?> job = discoveryJob;\n+        if (job != null) {\n+            job.cancel(false);\n+            discoveryJob = null;\n+        }\n+\n+        BluetoothAdapter localAdatper = this.adapter;\n+        if (localAdatper != null) {\n+            localAdatper.stopDiscovery();\n+            this.adapter = null;\n+        }\n+\n+        super.dispose();\n+    }\n+\n+    private @Nullable BluetoothAdapter prepareAdapter(DeviceManagerWrapper deviceManager) {\n+        // next lets check if we can find our adapter in the manager.\n+        BluetoothAdapter localAdapter = adapter;\n+        if (localAdapter == null) {\n+            BluetoothAddress localAddress = adapterAddress;\n+            if (localAddress != null) {\n+                localAdapter = adapter = deviceManager.getAdapter(localAddress);\n+            } else {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"No adapter address provided\");\n+                return null;\n+            }\n+        }\n+        if (localAdapter == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                    \"Native adapter could not be found for address '\" + adapterAddress + \"'\");\n+            return null;\n+        }\n+        // now lets confirm that the adapter is powered\n+        if (!localAdapter.isPowered()) {\n+            localAdapter.setPowered(true);\n+            // give the device some time to power on\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.NONE,\n+                    \"Adapter is not powered, attempting to turn on...\");\n+            return null;\n+        }\n+\n+        // now lets make sure that discovery is turned on\n+        if (!localAdapter.startDiscovery()) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.NONE, \"Starting discovery\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "00984dbaccb9f9fa3e6fd380ee55bdd7d5ba65d9"}, "originalPosition": 144}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTQ4OTQxMg==", "bodyText": "Sometimes bluez will turn off discovery as part of it's own error recovery system when it encounters strange bluetooth situations it doesn't know how to handle. (i.e. an advertisement packet that has incorrect length values, or a low level hardware error). Bluez won't turn discovery back on automatically so we just make sure we keep it on by starting it if it is turned off.\nNow turning on discovery might not work if the underlying hardware is not ready, in which case trying again later might prove effective, but there might be something wrong with the hardware as well in which case the OFFLINE seems appropriate. Since I can't tell whether a discovery failure is going to be temporary or permanent I think it would be safer just make the bridge OFFLINE until we can confirm that discovery is properly active.\nWDYT?", "url": "https://github.com/openhab/openhab-addons/pull/8819#discussion_r511489412", "createdAt": "2020-10-24T16:27:57Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.bluetooth.bluez/src/main/java/org/openhab/binding/bluetooth/bluez/internal/BlueZBridgeHandler.java", "diffHunk": "@@ -0,0 +1,234 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bluetooth.bluez.internal;\n+\n+import java.util.List;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.bluetooth.AbstractBluetoothBridgeHandler;\n+import org.openhab.binding.bluetooth.BluetoothAddress;\n+import org.openhab.binding.bluetooth.bluez.internal.events.AdapterDiscoveringChangedEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.AdapterPoweredChangedEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.BlueZEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.BlueZEventListener;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.github.hypfvieh.bluetooth.wrapper.BluetoothAdapter;\n+import com.github.hypfvieh.bluetooth.wrapper.BluetoothDevice;\n+\n+/**\n+ * The {@link BlueZBridgeHandler} is responsible for talking to the BlueZ stack, using DBus Unix Socket.\n+ * This Binding does not use any JNI.\n+ * It provides a private interface for {@link BlueZBluetoothDevice}s to access the stack and provides top\n+ * level adaptor functionality for scanning and arbitration.\n+ *\n+ * @author Kai Kreuzer - Initial contribution and API\n+ * @author Hilbrand Bouwkamp - Simplified calling scan and better handling manual scanning\n+ * @author Connor Petty - Simplified device scan logic\n+ * @author Benjamin Lafois - Replaced tinyB with bluezDbus\n+ *\n+ */\n+@NonNullByDefault\n+public class BlueZBridgeHandler extends AbstractBluetoothBridgeHandler<BlueZBluetoothDevice>\n+        implements BlueZEventListener {\n+\n+    private final Logger logger = LoggerFactory.getLogger(BlueZBridgeHandler.class);\n+\n+    // ADAPTER from BlueZ-DBus Library\n+    private @Nullable BluetoothAdapter adapter;\n+\n+    // Our BT address\n+    private @Nullable BluetoothAddress adapterAddress;\n+\n+    private @Nullable ScheduledFuture<?> discoveryJob;\n+\n+    private final DeviceManagerFactory deviceManagerFactory;\n+\n+    /**\n+     * Constructor\n+     *\n+     * @param bridge the bridge definition for this handler\n+     */\n+    public BlueZBridgeHandler(Bridge bridge, DeviceManagerFactory deviceManagerFactory) {\n+        super(bridge);\n+        this.deviceManagerFactory = deviceManagerFactory;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        super.initialize();\n+\n+        // Load configuration\n+        final BlueZAdapterConfiguration configuration = getConfigAs(BlueZAdapterConfiguration.class);\n+        String addr = configuration.address;\n+        if (addr != null) {\n+            this.adapterAddress = new BluetoothAddress(addr.toUpperCase());\n+        } else {\n+            // If configuration does not contain adapter address to use, exit with error.\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"address not set\");\n+            return;\n+        }\n+\n+        logger.debug(\"Creating BlueZ adapter with address '{}'\", adapterAddress);\n+        updateStatus(ThingStatus.UNKNOWN, ThingStatusDetail.CONFIGURATION_PENDING, \"Initializing\");\n+        deviceManagerFactory.getPropertiesChangedHandler().addListener(this);\n+        discoveryJob = scheduler.scheduleWithFixedDelay(this::initializeAndRefreshDevices, 5, 10, TimeUnit.SECONDS);\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        deviceManagerFactory.getPropertiesChangedHandler().removeListener(this);\n+        logger.debug(\"Termination of DBus BlueZ handler\");\n+\n+        Future<?> job = discoveryJob;\n+        if (job != null) {\n+            job.cancel(false);\n+            discoveryJob = null;\n+        }\n+\n+        BluetoothAdapter localAdatper = this.adapter;\n+        if (localAdatper != null) {\n+            localAdatper.stopDiscovery();\n+            this.adapter = null;\n+        }\n+\n+        super.dispose();\n+    }\n+\n+    private @Nullable BluetoothAdapter prepareAdapter(DeviceManagerWrapper deviceManager) {\n+        // next lets check if we can find our adapter in the manager.\n+        BluetoothAdapter localAdapter = adapter;\n+        if (localAdapter == null) {\n+            BluetoothAddress localAddress = adapterAddress;\n+            if (localAddress != null) {\n+                localAdapter = adapter = deviceManager.getAdapter(localAddress);\n+            } else {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"No adapter address provided\");\n+                return null;\n+            }\n+        }\n+        if (localAdapter == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                    \"Native adapter could not be found for address '\" + adapterAddress + \"'\");\n+            return null;\n+        }\n+        // now lets confirm that the adapter is powered\n+        if (!localAdapter.isPowered()) {\n+            localAdapter.setPowered(true);\n+            // give the device some time to power on\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.NONE,\n+                    \"Adapter is not powered, attempting to turn on...\");\n+            return null;\n+        }\n+\n+        // now lets make sure that discovery is turned on\n+        if (!localAdapter.startDiscovery()) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.NONE, \"Starting discovery\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTMzNjQ3Mg=="}, "originalCommit": {"oid": "00984dbaccb9f9fa3e6fd380ee55bdd7d5ba65d9"}, "originalPosition": 144}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTQ5ODY4Nw==", "bodyText": "@cpmeister is right that BlueZ for some reason stops discovering sometimes. sometimes, restarting discovery is not even sufficient which is the reason why I coded some adapter recycling. INITIALIZING would make sense if this piece of code would only be called upon binding startup, but if we look closely, the prepareAdapter method is also called on each \"refreshdevice\" iteration.\nWe could as such observe situation ONLINE->INITIALIZING->ONLINE. Otherwise it is ONLINE->OFFLINE->ONLINE\nIn any case, I'm fine with both solutions, as I don't think there is an impact ?", "url": "https://github.com/openhab/openhab-addons/pull/8819#discussion_r511498687", "createdAt": "2020-10-24T18:09:34Z", "author": {"login": "blafois"}, "path": "bundles/org.openhab.binding.bluetooth.bluez/src/main/java/org/openhab/binding/bluetooth/bluez/internal/BlueZBridgeHandler.java", "diffHunk": "@@ -0,0 +1,234 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bluetooth.bluez.internal;\n+\n+import java.util.List;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.bluetooth.AbstractBluetoothBridgeHandler;\n+import org.openhab.binding.bluetooth.BluetoothAddress;\n+import org.openhab.binding.bluetooth.bluez.internal.events.AdapterDiscoveringChangedEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.AdapterPoweredChangedEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.BlueZEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.BlueZEventListener;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.github.hypfvieh.bluetooth.wrapper.BluetoothAdapter;\n+import com.github.hypfvieh.bluetooth.wrapper.BluetoothDevice;\n+\n+/**\n+ * The {@link BlueZBridgeHandler} is responsible for talking to the BlueZ stack, using DBus Unix Socket.\n+ * This Binding does not use any JNI.\n+ * It provides a private interface for {@link BlueZBluetoothDevice}s to access the stack and provides top\n+ * level adaptor functionality for scanning and arbitration.\n+ *\n+ * @author Kai Kreuzer - Initial contribution and API\n+ * @author Hilbrand Bouwkamp - Simplified calling scan and better handling manual scanning\n+ * @author Connor Petty - Simplified device scan logic\n+ * @author Benjamin Lafois - Replaced tinyB with bluezDbus\n+ *\n+ */\n+@NonNullByDefault\n+public class BlueZBridgeHandler extends AbstractBluetoothBridgeHandler<BlueZBluetoothDevice>\n+        implements BlueZEventListener {\n+\n+    private final Logger logger = LoggerFactory.getLogger(BlueZBridgeHandler.class);\n+\n+    // ADAPTER from BlueZ-DBus Library\n+    private @Nullable BluetoothAdapter adapter;\n+\n+    // Our BT address\n+    private @Nullable BluetoothAddress adapterAddress;\n+\n+    private @Nullable ScheduledFuture<?> discoveryJob;\n+\n+    private final DeviceManagerFactory deviceManagerFactory;\n+\n+    /**\n+     * Constructor\n+     *\n+     * @param bridge the bridge definition for this handler\n+     */\n+    public BlueZBridgeHandler(Bridge bridge, DeviceManagerFactory deviceManagerFactory) {\n+        super(bridge);\n+        this.deviceManagerFactory = deviceManagerFactory;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        super.initialize();\n+\n+        // Load configuration\n+        final BlueZAdapterConfiguration configuration = getConfigAs(BlueZAdapterConfiguration.class);\n+        String addr = configuration.address;\n+        if (addr != null) {\n+            this.adapterAddress = new BluetoothAddress(addr.toUpperCase());\n+        } else {\n+            // If configuration does not contain adapter address to use, exit with error.\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"address not set\");\n+            return;\n+        }\n+\n+        logger.debug(\"Creating BlueZ adapter with address '{}'\", adapterAddress);\n+        updateStatus(ThingStatus.UNKNOWN, ThingStatusDetail.CONFIGURATION_PENDING, \"Initializing\");\n+        deviceManagerFactory.getPropertiesChangedHandler().addListener(this);\n+        discoveryJob = scheduler.scheduleWithFixedDelay(this::initializeAndRefreshDevices, 5, 10, TimeUnit.SECONDS);\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        deviceManagerFactory.getPropertiesChangedHandler().removeListener(this);\n+        logger.debug(\"Termination of DBus BlueZ handler\");\n+\n+        Future<?> job = discoveryJob;\n+        if (job != null) {\n+            job.cancel(false);\n+            discoveryJob = null;\n+        }\n+\n+        BluetoothAdapter localAdatper = this.adapter;\n+        if (localAdatper != null) {\n+            localAdatper.stopDiscovery();\n+            this.adapter = null;\n+        }\n+\n+        super.dispose();\n+    }\n+\n+    private @Nullable BluetoothAdapter prepareAdapter(DeviceManagerWrapper deviceManager) {\n+        // next lets check if we can find our adapter in the manager.\n+        BluetoothAdapter localAdapter = adapter;\n+        if (localAdapter == null) {\n+            BluetoothAddress localAddress = adapterAddress;\n+            if (localAddress != null) {\n+                localAdapter = adapter = deviceManager.getAdapter(localAddress);\n+            } else {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"No adapter address provided\");\n+                return null;\n+            }\n+        }\n+        if (localAdapter == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                    \"Native adapter could not be found for address '\" + adapterAddress + \"'\");\n+            return null;\n+        }\n+        // now lets confirm that the adapter is powered\n+        if (!localAdapter.isPowered()) {\n+            localAdapter.setPowered(true);\n+            // give the device some time to power on\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.NONE,\n+                    \"Adapter is not powered, attempting to turn on...\");\n+            return null;\n+        }\n+\n+        // now lets make sure that discovery is turned on\n+        if (!localAdapter.startDiscovery()) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.NONE, \"Starting discovery\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTMzNjQ3Mg=="}, "originalCommit": {"oid": "00984dbaccb9f9fa3e6fd380ee55bdd7d5ba65d9"}, "originalPosition": 144}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTUxMTk5NQ==", "bodyText": "Ok, thanks for your explanation! So how about adapting the message to:\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.NONE, \"Starting discovery\");\n          \n          \n            \n                        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.NONE, \"Trying to start discovery\");", "url": "https://github.com/openhab/openhab-addons/pull/8819#discussion_r511511995", "createdAt": "2020-10-24T20:38:36Z", "author": {"login": "kaikreuzer"}, "path": "bundles/org.openhab.binding.bluetooth.bluez/src/main/java/org/openhab/binding/bluetooth/bluez/internal/BlueZBridgeHandler.java", "diffHunk": "@@ -0,0 +1,234 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bluetooth.bluez.internal;\n+\n+import java.util.List;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.bluetooth.AbstractBluetoothBridgeHandler;\n+import org.openhab.binding.bluetooth.BluetoothAddress;\n+import org.openhab.binding.bluetooth.bluez.internal.events.AdapterDiscoveringChangedEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.AdapterPoweredChangedEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.BlueZEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.BlueZEventListener;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.github.hypfvieh.bluetooth.wrapper.BluetoothAdapter;\n+import com.github.hypfvieh.bluetooth.wrapper.BluetoothDevice;\n+\n+/**\n+ * The {@link BlueZBridgeHandler} is responsible for talking to the BlueZ stack, using DBus Unix Socket.\n+ * This Binding does not use any JNI.\n+ * It provides a private interface for {@link BlueZBluetoothDevice}s to access the stack and provides top\n+ * level adaptor functionality for scanning and arbitration.\n+ *\n+ * @author Kai Kreuzer - Initial contribution and API\n+ * @author Hilbrand Bouwkamp - Simplified calling scan and better handling manual scanning\n+ * @author Connor Petty - Simplified device scan logic\n+ * @author Benjamin Lafois - Replaced tinyB with bluezDbus\n+ *\n+ */\n+@NonNullByDefault\n+public class BlueZBridgeHandler extends AbstractBluetoothBridgeHandler<BlueZBluetoothDevice>\n+        implements BlueZEventListener {\n+\n+    private final Logger logger = LoggerFactory.getLogger(BlueZBridgeHandler.class);\n+\n+    // ADAPTER from BlueZ-DBus Library\n+    private @Nullable BluetoothAdapter adapter;\n+\n+    // Our BT address\n+    private @Nullable BluetoothAddress adapterAddress;\n+\n+    private @Nullable ScheduledFuture<?> discoveryJob;\n+\n+    private final DeviceManagerFactory deviceManagerFactory;\n+\n+    /**\n+     * Constructor\n+     *\n+     * @param bridge the bridge definition for this handler\n+     */\n+    public BlueZBridgeHandler(Bridge bridge, DeviceManagerFactory deviceManagerFactory) {\n+        super(bridge);\n+        this.deviceManagerFactory = deviceManagerFactory;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        super.initialize();\n+\n+        // Load configuration\n+        final BlueZAdapterConfiguration configuration = getConfigAs(BlueZAdapterConfiguration.class);\n+        String addr = configuration.address;\n+        if (addr != null) {\n+            this.adapterAddress = new BluetoothAddress(addr.toUpperCase());\n+        } else {\n+            // If configuration does not contain adapter address to use, exit with error.\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"address not set\");\n+            return;\n+        }\n+\n+        logger.debug(\"Creating BlueZ adapter with address '{}'\", adapterAddress);\n+        updateStatus(ThingStatus.UNKNOWN, ThingStatusDetail.CONFIGURATION_PENDING, \"Initializing\");\n+        deviceManagerFactory.getPropertiesChangedHandler().addListener(this);\n+        discoveryJob = scheduler.scheduleWithFixedDelay(this::initializeAndRefreshDevices, 5, 10, TimeUnit.SECONDS);\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        deviceManagerFactory.getPropertiesChangedHandler().removeListener(this);\n+        logger.debug(\"Termination of DBus BlueZ handler\");\n+\n+        Future<?> job = discoveryJob;\n+        if (job != null) {\n+            job.cancel(false);\n+            discoveryJob = null;\n+        }\n+\n+        BluetoothAdapter localAdatper = this.adapter;\n+        if (localAdatper != null) {\n+            localAdatper.stopDiscovery();\n+            this.adapter = null;\n+        }\n+\n+        super.dispose();\n+    }\n+\n+    private @Nullable BluetoothAdapter prepareAdapter(DeviceManagerWrapper deviceManager) {\n+        // next lets check if we can find our adapter in the manager.\n+        BluetoothAdapter localAdapter = adapter;\n+        if (localAdapter == null) {\n+            BluetoothAddress localAddress = adapterAddress;\n+            if (localAddress != null) {\n+                localAdapter = adapter = deviceManager.getAdapter(localAddress);\n+            } else {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"No adapter address provided\");\n+                return null;\n+            }\n+        }\n+        if (localAdapter == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                    \"Native adapter could not be found for address '\" + adapterAddress + \"'\");\n+            return null;\n+        }\n+        // now lets confirm that the adapter is powered\n+        if (!localAdapter.isPowered()) {\n+            localAdapter.setPowered(true);\n+            // give the device some time to power on\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.NONE,\n+                    \"Adapter is not powered, attempting to turn on...\");\n+            return null;\n+        }\n+\n+        // now lets make sure that discovery is turned on\n+        if (!localAdapter.startDiscovery()) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.NONE, \"Starting discovery\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTMzNjQ3Mg=="}, "originalCommit": {"oid": "00984dbaccb9f9fa3e6fd380ee55bdd7d5ba65d9"}, "originalPosition": 144}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTUzMDQzOQ==", "bodyText": "done", "url": "https://github.com/openhab/openhab-addons/pull/8819#discussion_r511530439", "createdAt": "2020-10-25T00:44:20Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.bluetooth.bluez/src/main/java/org/openhab/binding/bluetooth/bluez/internal/BlueZBridgeHandler.java", "diffHunk": "@@ -0,0 +1,234 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bluetooth.bluez.internal;\n+\n+import java.util.List;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.bluetooth.AbstractBluetoothBridgeHandler;\n+import org.openhab.binding.bluetooth.BluetoothAddress;\n+import org.openhab.binding.bluetooth.bluez.internal.events.AdapterDiscoveringChangedEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.AdapterPoweredChangedEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.BlueZEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.BlueZEventListener;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.github.hypfvieh.bluetooth.wrapper.BluetoothAdapter;\n+import com.github.hypfvieh.bluetooth.wrapper.BluetoothDevice;\n+\n+/**\n+ * The {@link BlueZBridgeHandler} is responsible for talking to the BlueZ stack, using DBus Unix Socket.\n+ * This Binding does not use any JNI.\n+ * It provides a private interface for {@link BlueZBluetoothDevice}s to access the stack and provides top\n+ * level adaptor functionality for scanning and arbitration.\n+ *\n+ * @author Kai Kreuzer - Initial contribution and API\n+ * @author Hilbrand Bouwkamp - Simplified calling scan and better handling manual scanning\n+ * @author Connor Petty - Simplified device scan logic\n+ * @author Benjamin Lafois - Replaced tinyB with bluezDbus\n+ *\n+ */\n+@NonNullByDefault\n+public class BlueZBridgeHandler extends AbstractBluetoothBridgeHandler<BlueZBluetoothDevice>\n+        implements BlueZEventListener {\n+\n+    private final Logger logger = LoggerFactory.getLogger(BlueZBridgeHandler.class);\n+\n+    // ADAPTER from BlueZ-DBus Library\n+    private @Nullable BluetoothAdapter adapter;\n+\n+    // Our BT address\n+    private @Nullable BluetoothAddress adapterAddress;\n+\n+    private @Nullable ScheduledFuture<?> discoveryJob;\n+\n+    private final DeviceManagerFactory deviceManagerFactory;\n+\n+    /**\n+     * Constructor\n+     *\n+     * @param bridge the bridge definition for this handler\n+     */\n+    public BlueZBridgeHandler(Bridge bridge, DeviceManagerFactory deviceManagerFactory) {\n+        super(bridge);\n+        this.deviceManagerFactory = deviceManagerFactory;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        super.initialize();\n+\n+        // Load configuration\n+        final BlueZAdapterConfiguration configuration = getConfigAs(BlueZAdapterConfiguration.class);\n+        String addr = configuration.address;\n+        if (addr != null) {\n+            this.adapterAddress = new BluetoothAddress(addr.toUpperCase());\n+        } else {\n+            // If configuration does not contain adapter address to use, exit with error.\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"address not set\");\n+            return;\n+        }\n+\n+        logger.debug(\"Creating BlueZ adapter with address '{}'\", adapterAddress);\n+        updateStatus(ThingStatus.UNKNOWN, ThingStatusDetail.CONFIGURATION_PENDING, \"Initializing\");\n+        deviceManagerFactory.getPropertiesChangedHandler().addListener(this);\n+        discoveryJob = scheduler.scheduleWithFixedDelay(this::initializeAndRefreshDevices, 5, 10, TimeUnit.SECONDS);\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        deviceManagerFactory.getPropertiesChangedHandler().removeListener(this);\n+        logger.debug(\"Termination of DBus BlueZ handler\");\n+\n+        Future<?> job = discoveryJob;\n+        if (job != null) {\n+            job.cancel(false);\n+            discoveryJob = null;\n+        }\n+\n+        BluetoothAdapter localAdatper = this.adapter;\n+        if (localAdatper != null) {\n+            localAdatper.stopDiscovery();\n+            this.adapter = null;\n+        }\n+\n+        super.dispose();\n+    }\n+\n+    private @Nullable BluetoothAdapter prepareAdapter(DeviceManagerWrapper deviceManager) {\n+        // next lets check if we can find our adapter in the manager.\n+        BluetoothAdapter localAdapter = adapter;\n+        if (localAdapter == null) {\n+            BluetoothAddress localAddress = adapterAddress;\n+            if (localAddress != null) {\n+                localAdapter = adapter = deviceManager.getAdapter(localAddress);\n+            } else {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"No adapter address provided\");\n+                return null;\n+            }\n+        }\n+        if (localAdapter == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                    \"Native adapter could not be found for address '\" + adapterAddress + \"'\");\n+            return null;\n+        }\n+        // now lets confirm that the adapter is powered\n+        if (!localAdapter.isPowered()) {\n+            localAdapter.setPowered(true);\n+            // give the device some time to power on\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.NONE,\n+                    \"Adapter is not powered, attempting to turn on...\");\n+            return null;\n+        }\n+\n+        // now lets make sure that discovery is turned on\n+        if (!localAdapter.startDiscovery()) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.NONE, \"Starting discovery\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTMzNjQ3Mg=="}, "originalCommit": {"oid": "00984dbaccb9f9fa3e6fd380ee55bdd7d5ba65d9"}, "originalPosition": 144}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4115, "cost": 1, "resetAt": "2021-11-13T12:10:21Z"}}}