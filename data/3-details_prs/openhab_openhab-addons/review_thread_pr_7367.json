{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDAzMDQ2Nzc4", "number": 7367, "reviewThreads": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQwOTowMToyM1rODxjLZQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQyMDowOToyMFrODxzdOQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUzMjgzMTczOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.chromecast/src/main/java/org/openhab/binding/chromecast/internal/utils/ByteArrayFileCache.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQwOTowMToyM1rOGFFAhQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQwOTowMToyM1rOGFFAhQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzk3ODExNw==", "bodyText": "Similar to the Google TTS add-on, you can simplify the conversion to hexadecimal and left padding the 0's using\nString fileNameHash = String.format(\"%032x\", bigInt);", "url": "https://github.com/openhab/openhab-addons/pull/7367#discussion_r407978117", "createdAt": "2020-04-14T09:01:23Z", "author": {"login": "wborn"}, "path": "bundles/org.openhab.binding.chromecast/src/main/java/org/openhab/binding/chromecast/internal/utils/ByteArrayFileCache.java", "diffHunk": "@@ -0,0 +1,307 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.chromecast.internal.utils;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.math.BigInteger;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.security.MessageDigest;\n+import java.security.NoSuchAlgorithmException;\n+import java.util.Arrays;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.config.core.ConfigConstants;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * This is a simple file based cache implementation.\n+ *\n+ * @author Christoph Weitkamp - Initial contribution\n+ */\n+@NonNullByDefault\n+public class ByteArrayFileCache {\n+\n+    private final Logger logger = LoggerFactory.getLogger(ByteArrayFileCache.class);\n+\n+    private static final String MD5_ALGORITHM = \"MD5\";\n+\n+    static final String CACHE_FOLDER_NAME = \"cache\";\n+    private static final char EXTENSION_SEPARATOR = '.';\n+    private static final char UNIX_SEPARATOR = '/';\n+    private static final char WINDOWS_SEPARATOR = '\\\\';\n+\n+    private final File cacheFolder;\n+\n+    static final long ONE_DAY_IN_MILLIS = TimeUnit.DAYS.toMillis(1);\n+    private int expiry = 0;\n+\n+    private static final Map<String, File> FILES_IN_CACHE = new ConcurrentHashMap<>();\n+\n+    /**\n+     * Creates a new {@link ByteArrayFileCache} instance for a service. Creates a <code>cache</code> folder under\n+     * <code>$userdata/cache/$servicePID</code>.\n+     *\n+     * @param servicePID PID of the service\n+     */\n+    public ByteArrayFileCache(String servicePID) {\n+        // TODO track and limit folder size\n+        // TODO support user specific folder\n+        cacheFolder = new File(new File(ConfigConstants.getUserDataFolder(), CACHE_FOLDER_NAME), servicePID);\n+        if (!cacheFolder.exists()) {\n+            logger.debug(\"Creating cache folder '{}'\", cacheFolder.getAbsolutePath());\n+            cacheFolder.mkdirs();\n+        }\n+        logger.debug(\"Using cache folder '{}'\", cacheFolder.getAbsolutePath());\n+    }\n+\n+    /**\n+     * Creates a new {@link ByteArrayFileCache} instance for a service. Creates a <code>cache</code> folder under\n+     * <code>$userdata/cache/$servicePID/</code>.\n+     *\n+     * @param servicePID PID of the service\n+     * @param int the days for how long the files stay in the cache valid. Must be positive. 0 to\n+     *            disables this functionality.\n+     */\n+    public ByteArrayFileCache(String servicePID, int expiry) {\n+        this(servicePID);\n+        if (expiry < 0) {\n+            throw new IllegalArgumentException(\"Cache expiration time must be greater than or equal to 0\");\n+        }\n+        this.expiry = expiry;\n+    }\n+\n+    /**\n+     * Adds a file to the cache. If the cache previously contained a file for the key, the old file is replaced by the\n+     * new content.\n+     *\n+     * @param key the key with which the file is to be associated\n+     * @param content the content for the file to be associated with the specified key\n+     */\n+    public void put(String key, byte[] content) {\n+        writeFile(getUniqueFile(key), content);\n+    }\n+\n+    /**\n+     * Adds a file to the cache.\n+     *\n+     * @param key the key with which the file is to be associated\n+     * @param content the content for the file to be associated with the specified key\n+     */\n+    public void putIfAbsent(String key, byte[] content) {\n+        File fileInCache = getUniqueFile(key);\n+        if (fileInCache.exists()) {\n+            logger.debug(\"File '{}' present in cache\", fileInCache.getName());\n+            // update time of last use\n+            fileInCache.setLastModified(System.currentTimeMillis());\n+        } else {\n+            writeFile(fileInCache, content);\n+        }\n+    }\n+\n+    /**\n+     * Adds a file to the cache and returns the content of the file.\n+     *\n+     * @param key the key with which the file is to be associated\n+     * @param content the content for the file to be associated with the specified key\n+     * @return the content of the file associated with the given key\n+     */\n+    public byte[] putIfAbsentAndGet(String key, byte[] content) {\n+        putIfAbsent(key, content);\n+\n+        return content;\n+    }\n+\n+    /**\n+     * Writes the given content to the given {@link File}.\n+     *\n+     * @param fileInCache the {@link File}\n+     * @param content the content to be written\n+     */\n+    private void writeFile(File fileInCache, byte[] content) {\n+        logger.debug(\"Caching file '{}'\", fileInCache.getName());\n+        try {\n+            Files.write(fileInCache.toPath(), content);\n+        } catch (IOException e) {\n+            logger.warn(\"Could not write file '{}'\u00a0to cache\", fileInCache.getName(), e);\n+        }\n+    }\n+\n+    /**\n+     * Checks if the key is present in the cache.\n+     *\n+     * @param key the key whose presence in the cache is to be tested\n+     * @return true if the cache contains a file for the specified key\n+     */\n+    public boolean containsKey(String key) {\n+        return getUniqueFile(key).exists();\n+    }\n+\n+    /**\n+     * Removes the file associated with the given key from the cache.\n+     *\n+     * @param key the key whose associated file is to be removed\n+     */\n+    public void remove(String key) {\n+        deleteFile(getUniqueFile(key));\n+    }\n+\n+    /**\n+     * Deletes the given {@link File}.\n+     *\n+     * @param fileInCache the {@link File}\n+     */\n+    private void deleteFile(File fileInCache) {\n+        if (fileInCache.exists()) {\n+            logger.debug(\"Deleting file '{}' from cache\", fileInCache.getName());\n+            fileInCache.delete();\n+        } else {\n+            logger.debug(\"File '{}' not found in cache\", fileInCache.getName());\n+        }\n+    }\n+\n+    /**\n+     * Removes all files from the cache.\n+     */\n+    public void clear() {\n+        File[] filesInCache = cacheFolder.listFiles();\n+        if (filesInCache != null && filesInCache.length > 0) {\n+            logger.debug(\"Deleting all files from cache\");\n+            Arrays.stream(filesInCache).forEach(File::delete);\n+        }\n+    }\n+\n+    /**\n+     * Removes expired files from the cache.\n+     */\n+    public void clearExpired() {\n+        // exit if expiry is set to 0 (disabled)\n+        if (expiry <= 0) {\n+            return;\n+        }\n+        File[] filesInCache = cacheFolder.listFiles();\n+        if (filesInCache != null && filesInCache.length > 0) {\n+            logger.debug(\"Deleting expired files from cache\");\n+            Arrays.stream(filesInCache).filter(file -> isExpired(file)).forEach(File::delete);\n+        }\n+    }\n+\n+    /**\n+     * Checks if the given {@link File} is expired.\n+     *\n+     * @param fileInCache the {@link File}\n+     * @return <code>true</code> if the file is expired, <code>false</code> otherwise\n+     */\n+    private boolean isExpired(File fileInCache) {\n+        // exit if expiry is set to 0 (disabled)\n+        if (expiry <= 0) {\n+            return false;\n+        }\n+        return expiry * ONE_DAY_IN_MILLIS < System.currentTimeMillis() - fileInCache.lastModified();\n+    }\n+\n+    /**\n+     * Returns the content of the file associated with the given key, if it is present.\n+     *\n+     * @param key the key whose associated file is to be returned\n+     * @return the content of the file associated with the given key\n+     */\n+    public byte[] get(String key) {\n+        return readFile(getUniqueFile(key));\n+    }\n+\n+    /**\n+     * Reads the content from the given {@link File}, if it is present.\n+     *\n+     * @param fileInCache the {@link File}\n+     * @return the content of the file\n+     */\n+    private byte[] readFile(File fileInCache) {\n+        if (fileInCache.exists()) {\n+            logger.debug(\"Reading file '{}' from cache\", fileInCache.getName());\n+            // update time of last use\n+            fileInCache.setLastModified(System.currentTimeMillis());\n+            try {\n+                return Files.readAllBytes(fileInCache.toPath());\n+            } catch (IOException e) {\n+                logger.warn(\"Could not read file '{}'\u00a0from cache\", fileInCache.getName(), e);\n+            }\n+        } else {\n+            logger.debug(\"File '{}' not found in cache\", fileInCache.getName());\n+        }\n+        return new byte[0];\n+    }\n+\n+    /**\n+     * Creates a unique {@link File} from the key with which the file is to be associated.\n+     *\n+     * @param key the key with which the file is to be associated\n+     * @return unique file for the file associated with the given key\n+     */\n+    File getUniqueFile(String key) {\n+        String uniqueFileName = getUniqueFileName(key);\n+        if (FILES_IN_CACHE.containsKey(uniqueFileName)) {\n+            return FILES_IN_CACHE.get(uniqueFileName);\n+        } else {\n+            String fileExtension = getFileExtension(key);\n+            File fileInCache = new File(cacheFolder,\n+                    uniqueFileName + (fileExtension == null ? \"\" : EXTENSION_SEPARATOR + fileExtension));\n+            FILES_IN_CACHE.put(uniqueFileName, fileInCache);\n+            return fileInCache;\n+        }\n+    }\n+\n+    /**\n+     * Gets the extension of a file name.\n+     *\n+     * @param fileName the file name to retrieve the extension of\n+     * @return the extension of the file or null if none exists\n+     */\n+    @Nullable\n+    String getFileExtension(String fileName) {\n+        int extensionPos = fileName.lastIndexOf(EXTENSION_SEPARATOR);\n+        int lastSeparatorPos = Math.max(fileName.lastIndexOf(UNIX_SEPARATOR), fileName.lastIndexOf(WINDOWS_SEPARATOR));\n+        return lastSeparatorPos > extensionPos ? null : fileName.substring(extensionPos + 1).replaceFirst(\"\\\\?.*$\", \"\");\n+    }\n+\n+    /**\n+     * Creates a unique file name from the key with which the file is to be associated.\n+     *\n+     * @param key the key with which the file is to be associated\n+     * @return unique file name for the file associated with the given key\n+     */\n+    String getUniqueFileName(String key) {\n+        try {\n+            MessageDigest md = MessageDigest.getInstance(MD5_ALGORITHM);\n+            byte[] bytesOfKey = key.getBytes(StandardCharsets.UTF_8);\n+            byte[] md5Hash = md.digest(bytesOfKey);\n+            BigInteger bigInt = new BigInteger(1, md5Hash);\n+            String fileNameHash = bigInt.toString(16);\n+            // We need to zero pad it if you actually want the full 32 chars\n+            while (fileNameHash.length() < 32) {\n+                fileNameHash = \"0\" + fileNameHash;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6842ab3408206f7aadbc5a3770c8367a8ca328b8"}, "originalPosition": 298}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUzNDQ0ODA4OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.chromecast/src/main/resources/ESH-INF/i18n/chromecast_de.properties", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQxNTozNjo1N1rOGFUsHg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQxNTozNjo1N1rOGFUsHg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODIzNTAzOA==", "bodyText": "I should change this mistake too.", "url": "https://github.com/openhab/openhab-addons/pull/7367#discussion_r408235038", "createdAt": "2020-04-14T15:36:57Z", "author": {"login": "cweitkamp"}, "path": "bundles/org.openhab.binding.chromecast/src/main/resources/ESH-INF/i18n/chromecast_de.properties", "diffHunk": "@@ -17,6 +17,8 @@ thing-type.config.chromecast.device.ipAddress.label = IP-Adresse\n thing-type.config.chromecast.device.ipAddress.description = Lokale IP-Adresse oder Hostname des Chromecast Ger\ufffdtes.\n thing-type.config.chromecast.device.port.label = Port\n thing-type.config.chromecast.device.port.description = Port des Chromecast Ger\ufffdtes.\n+thing-type.config.chromecast.device.refreshRate.label = Aktualisierungsintervall\n+thing-type.config.chromecast.device.refreshRate.description = Intervall zur Aktualisierung des Chromecast Ger\ufffdtes.\n \n # channel types\n channel-type.kodi.stop.label = Stop", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ec4c562f2e68eceb4e323a7ef29744e7e523c086"}, "originalPosition": 8}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUzNTAwODE3OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.chromecast/src/main/java/org/openhab/binding/chromecast/internal/ChromecastAudioSink.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQxNzo1MTo1OVrOGFaNGg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQxNzo1MTo1OVrOGFaNGg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODMyNTQwMg==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private @Nullable final String callbackUrl;\n          \n          \n            \n                private final @Nullable String callbackUrl;", "url": "https://github.com/openhab/openhab-addons/pull/7367#discussion_r408325402", "createdAt": "2020-04-14T17:51:59Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.chromecast/src/main/java/org/openhab/binding/chromecast/internal/ChromecastAudioSink.java", "diffHunk": "@@ -25,30 +25,36 @@\n import org.slf4j.LoggerFactory;\n \n /**\n- * Handles the AudioSink portion of the Chromecast plugin. Note that we store volume in\n+ * Handles the AudioSink portion of the Chromecast add-on.\n  *\n  * @author Jason Holmes - Initial contribution\n  */\n+@NonNullByDefault\n public class ChromecastAudioSink {\n-    private final Logger logger = LoggerFactory.getLogger(getClass());\n+    private final Logger logger = LoggerFactory.getLogger(ChromecastAudioSink.class);\n+\n+    private static final String MIME_TYPE_AUDIO_WAV = \"audio/wav\";\n+    private static final String MIME_TYPE_AUDIO_MPEG = \"audio/mpeg\";\n+\n     private final ChromecastCommander commander;\n     private final AudioHTTPServer audioHTTPServer;\n-    private final String callbackUrl;\n+    private @Nullable final String callbackUrl;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cda5702bde5734236034eb2f0864200e6211afbe"}, "originalPosition": 31}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUzNTAyMTIzOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.chromecast/src/main/java/org/openhab/binding/chromecast/internal/ChromecastAudioSink.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQxNzo1NToxN1rOGFaVjA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQxNzo1NToxN1rOGFaVjA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODMyNzU2NA==", "bodyText": "This is out of scope of this PR but just wanted to point out that this code doesn't take into account other audio formats.", "url": "https://github.com/openhab/openhab-addons/pull/7367#discussion_r408327564", "createdAt": "2020-04-14T17:55:17Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.chromecast/src/main/java/org/openhab/binding/chromecast/internal/ChromecastAudioSink.java", "diffHunk": "@@ -68,11 +74,8 @@ public void process(AudioStream audioStream) throws UnsupportedAudioFormatExcept\n                     return;\n                 }\n             }\n-\n-            String mimeType = Objects.equals(audioStream.getFormat().getCodec(), AudioFormat.CODEC_MP3) ? \"audio/mpeg\"\n-                    : \"audio/wav\";\n-\n-            commander.playMedia(\"Notification\", url, mimeType);\n+            commander.playMedia(\"Notification\", url,\n+                    AudioFormat.MP3.isCompatible(audioStream.getFormat()) ? MIME_TYPE_AUDIO_MPEG : MIME_TYPE_AUDIO_WAV);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cda5702bde5734236034eb2f0864200e6211afbe"}, "originalPosition": 64}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUzNTQwMzg2OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.chromecast/src/main/java/org/openhab/binding/chromecast/internal/ChromecastCommander.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQxOTo0MToyOFrOGFeFsw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNlQxMDoxNTo1MFrOGGecRw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODM4OTA0Mw==", "bodyText": "Are title and mimeType supposed to be nullable?", "url": "https://github.com/openhab/openhab-addons/pull/7367#discussion_r408389043", "createdAt": "2020-04-14T19:41:28Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.chromecast/src/main/java/org/openhab/binding/chromecast/internal/ChromecastCommander.java", "diffHunk": "@@ -219,7 +219,7 @@ private void handleMute(final Command command) {\n         }\n     }\n \n-    void playMedia(String title, String url, String mimeType) {\n+    void playMedia(@Nullable String title, @Nullable String url, @Nullable String mimeType) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cda5702bde5734236034eb2f0864200e6211afbe"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTQ0MzM5OQ==", "bodyText": "openhab-addons/bundles/org.openhab.binding.chromecast/src/main/java/org/openhab/binding/chromecast/internal/ChromecastCommander.java\n    \n    \n        Lines 129 to 133\n      in\n      55d8f0f\n    \n    \n    \n    \n\n        \n          \n           private void handlePlayUri(Command command) { \n        \n\n        \n          \n               if (command instanceof StringType) { \n        \n\n        \n          \n                   playMedia(null, command.toString(), null); \n        \n\n        \n          \n               } \n        \n\n        \n          \n           }", "url": "https://github.com/openhab/openhab-addons/pull/7367#discussion_r409443399", "createdAt": "2020-04-16T10:15:50Z", "author": {"login": "cweitkamp"}, "path": "bundles/org.openhab.binding.chromecast/src/main/java/org/openhab/binding/chromecast/internal/ChromecastCommander.java", "diffHunk": "@@ -219,7 +219,7 @@ private void handleMute(final Command command) {\n         }\n     }\n \n-    void playMedia(String title, String url, String mimeType) {\n+    void playMedia(@Nullable String title, @Nullable String url, @Nullable String mimeType) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODM4OTA0Mw=="}, "originalCommit": {"oid": "cda5702bde5734236034eb2f0864200e6211afbe"}, "originalPosition": 37}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUzNTQyNTM0OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.chromecast/src/main/java/org/openhab/binding/chromecast/internal/ChromecastStatusUpdater.java", "isResolved": true, "comments": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQxOTo0ODowMFrOGFeTag==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNlQxODo1Njo0OFrOGGy_0w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODM5MjU1NA==", "bodyText": "Is image cache thread-safe?", "url": "https://github.com/openhab/openhab-addons/pull/7367#discussion_r408392554", "createdAt": "2020-04-14T19:48:00Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.chromecast/src/main/java/org/openhab/binding/chromecast/internal/ChromecastStatusUpdater.java", "diffHunk": "@@ -245,21 +246,39 @@ private void updateImage(Map<String, Object> metadata) {\n             }\n         }\n \n-        // Poor man's cache. If the imageSrc is the same, don't update them.\n-        if (Objects.equals(this.imageSrc, imageSrc)) {\n-            return;\n-        } else {\n-            this.imageSrc = imageSrc;\n-        }\n-\n         if (callback.isLinked(CHANNEL_IMAGE_SRC)) {\n-            callback.updateState(CHANNEL_IMAGE_SRC, imageSrc == null ? UNDEF : new StringType(imageSrc));\n+            callback.updateState(CHANNEL_IMAGE_SRC, imageSrc == null ? UnDefType.UNDEF : new StringType(imageSrc));\n         }\n \n         if (callback.isLinked(CHANNEL_IMAGE)) {\n-            State image = imageSrc == null ? UNDEF : HttpUtil.downloadImage(imageSrc);\n-            callback.updateState(CHANNEL_IMAGE, image == null ? UNDEF : image);\n+            State image = imageSrc == null ? UnDefType.UNDEF : downloadImageFromCache(imageSrc);\n+            callback.updateState(CHANNEL_IMAGE, image == null ? UnDefType.UNDEF : image);\n+        }\n+    }\n+\n+    private @Nullable RawType downloadImage(String url) {\n+        logger.debug(\"Trying to download the content of URL '{}'\", url);\n+        RawType downloadedImage = HttpUtil.downloadImage(url);\n+        if (downloadedImage == null) {\n+            logger.debug(\"Failed to download the content of URL '{}'\", url);\n+        }\n+        return downloadedImage;\n+    }\n+\n+    private @Nullable RawType downloadImageFromCache(String url) {\n+        if (IMAGE_CACHE.containsKey(url)) {\n+            byte[] bytes = IMAGE_CACHE.get(url);\n+            String contentType = HttpUtil.guessContentTypeFromData(bytes);\n+            return new RawType(bytes,\n+                    contentType == null || contentType.isEmpty() ? RawType.DEFAULT_MIME_TYPE : contentType);\n+        } else {\n+            RawType image = downloadImage(url);\n+            if (image != null) {\n+                IMAGE_CACHE.put(url, image.getBytes());\n+                return image;\n+            }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cda5702bde5734236034eb2f0864200e6211afbe"}, "originalPosition": 224}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTQ0NDM0NQ==", "bodyText": "No, I do not think so.", "url": "https://github.com/openhab/openhab-addons/pull/7367#discussion_r409444345", "createdAt": "2020-04-16T10:17:31Z", "author": {"login": "cweitkamp"}, "path": "bundles/org.openhab.binding.chromecast/src/main/java/org/openhab/binding/chromecast/internal/ChromecastStatusUpdater.java", "diffHunk": "@@ -245,21 +246,39 @@ private void updateImage(Map<String, Object> metadata) {\n             }\n         }\n \n-        // Poor man's cache. If the imageSrc is the same, don't update them.\n-        if (Objects.equals(this.imageSrc, imageSrc)) {\n-            return;\n-        } else {\n-            this.imageSrc = imageSrc;\n-        }\n-\n         if (callback.isLinked(CHANNEL_IMAGE_SRC)) {\n-            callback.updateState(CHANNEL_IMAGE_SRC, imageSrc == null ? UNDEF : new StringType(imageSrc));\n+            callback.updateState(CHANNEL_IMAGE_SRC, imageSrc == null ? UnDefType.UNDEF : new StringType(imageSrc));\n         }\n \n         if (callback.isLinked(CHANNEL_IMAGE)) {\n-            State image = imageSrc == null ? UNDEF : HttpUtil.downloadImage(imageSrc);\n-            callback.updateState(CHANNEL_IMAGE, image == null ? UNDEF : image);\n+            State image = imageSrc == null ? UnDefType.UNDEF : downloadImageFromCache(imageSrc);\n+            callback.updateState(CHANNEL_IMAGE, image == null ? UnDefType.UNDEF : image);\n+        }\n+    }\n+\n+    private @Nullable RawType downloadImage(String url) {\n+        logger.debug(\"Trying to download the content of URL '{}'\", url);\n+        RawType downloadedImage = HttpUtil.downloadImage(url);\n+        if (downloadedImage == null) {\n+            logger.debug(\"Failed to download the content of URL '{}'\", url);\n+        }\n+        return downloadedImage;\n+    }\n+\n+    private @Nullable RawType downloadImageFromCache(String url) {\n+        if (IMAGE_CACHE.containsKey(url)) {\n+            byte[] bytes = IMAGE_CACHE.get(url);\n+            String contentType = HttpUtil.guessContentTypeFromData(bytes);\n+            return new RawType(bytes,\n+                    contentType == null || contentType.isEmpty() ? RawType.DEFAULT_MIME_TYPE : contentType);\n+        } else {\n+            RawType image = downloadImage(url);\n+            if (image != null) {\n+                IMAGE_CACHE.put(url, image.getBytes());\n+                return image;\n+            }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODM5MjU1NA=="}, "originalCommit": {"oid": "cda5702bde5734236034eb2f0864200e6211afbe"}, "originalPosition": 224}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTcxMDE1NA==", "bodyText": "Should it be thread-safe?", "url": "https://github.com/openhab/openhab-addons/pull/7367#discussion_r409710154", "createdAt": "2020-04-16T16:59:46Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.chromecast/src/main/java/org/openhab/binding/chromecast/internal/ChromecastStatusUpdater.java", "diffHunk": "@@ -245,21 +246,39 @@ private void updateImage(Map<String, Object> metadata) {\n             }\n         }\n \n-        // Poor man's cache. If the imageSrc is the same, don't update them.\n-        if (Objects.equals(this.imageSrc, imageSrc)) {\n-            return;\n-        } else {\n-            this.imageSrc = imageSrc;\n-        }\n-\n         if (callback.isLinked(CHANNEL_IMAGE_SRC)) {\n-            callback.updateState(CHANNEL_IMAGE_SRC, imageSrc == null ? UNDEF : new StringType(imageSrc));\n+            callback.updateState(CHANNEL_IMAGE_SRC, imageSrc == null ? UnDefType.UNDEF : new StringType(imageSrc));\n         }\n \n         if (callback.isLinked(CHANNEL_IMAGE)) {\n-            State image = imageSrc == null ? UNDEF : HttpUtil.downloadImage(imageSrc);\n-            callback.updateState(CHANNEL_IMAGE, image == null ? UNDEF : image);\n+            State image = imageSrc == null ? UnDefType.UNDEF : downloadImageFromCache(imageSrc);\n+            callback.updateState(CHANNEL_IMAGE, image == null ? UnDefType.UNDEF : image);\n+        }\n+    }\n+\n+    private @Nullable RawType downloadImage(String url) {\n+        logger.debug(\"Trying to download the content of URL '{}'\", url);\n+        RawType downloadedImage = HttpUtil.downloadImage(url);\n+        if (downloadedImage == null) {\n+            logger.debug(\"Failed to download the content of URL '{}'\", url);\n+        }\n+        return downloadedImage;\n+    }\n+\n+    private @Nullable RawType downloadImageFromCache(String url) {\n+        if (IMAGE_CACHE.containsKey(url)) {\n+            byte[] bytes = IMAGE_CACHE.get(url);\n+            String contentType = HttpUtil.guessContentTypeFromData(bytes);\n+            return new RawType(bytes,\n+                    contentType == null || contentType.isEmpty() ? RawType.DEFAULT_MIME_TYPE : contentType);\n+        } else {\n+            RawType image = downloadImage(url);\n+            if (image != null) {\n+                IMAGE_CACHE.put(url, image.getBytes());\n+                return image;\n+            }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODM5MjU1NA=="}, "originalCommit": {"oid": "cda5702bde5734236034eb2f0864200e6211afbe"}, "originalPosition": 224}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTc2ODM2OQ==", "bodyText": "No, I do not think so \ud83d\ude09. I am using this implementation in four different bindings and never faced an issue related to the cached data. In general it has to handle one channel (approximately one image every three to four minutes).", "url": "https://github.com/openhab/openhab-addons/pull/7367#discussion_r409768369", "createdAt": "2020-04-16T18:36:09Z", "author": {"login": "cweitkamp"}, "path": "bundles/org.openhab.binding.chromecast/src/main/java/org/openhab/binding/chromecast/internal/ChromecastStatusUpdater.java", "diffHunk": "@@ -245,21 +246,39 @@ private void updateImage(Map<String, Object> metadata) {\n             }\n         }\n \n-        // Poor man's cache. If the imageSrc is the same, don't update them.\n-        if (Objects.equals(this.imageSrc, imageSrc)) {\n-            return;\n-        } else {\n-            this.imageSrc = imageSrc;\n-        }\n-\n         if (callback.isLinked(CHANNEL_IMAGE_SRC)) {\n-            callback.updateState(CHANNEL_IMAGE_SRC, imageSrc == null ? UNDEF : new StringType(imageSrc));\n+            callback.updateState(CHANNEL_IMAGE_SRC, imageSrc == null ? UnDefType.UNDEF : new StringType(imageSrc));\n         }\n \n         if (callback.isLinked(CHANNEL_IMAGE)) {\n-            State image = imageSrc == null ? UNDEF : HttpUtil.downloadImage(imageSrc);\n-            callback.updateState(CHANNEL_IMAGE, image == null ? UNDEF : image);\n+            State image = imageSrc == null ? UnDefType.UNDEF : downloadImageFromCache(imageSrc);\n+            callback.updateState(CHANNEL_IMAGE, image == null ? UnDefType.UNDEF : image);\n+        }\n+    }\n+\n+    private @Nullable RawType downloadImage(String url) {\n+        logger.debug(\"Trying to download the content of URL '{}'\", url);\n+        RawType downloadedImage = HttpUtil.downloadImage(url);\n+        if (downloadedImage == null) {\n+            logger.debug(\"Failed to download the content of URL '{}'\", url);\n+        }\n+        return downloadedImage;\n+    }\n+\n+    private @Nullable RawType downloadImageFromCache(String url) {\n+        if (IMAGE_CACHE.containsKey(url)) {\n+            byte[] bytes = IMAGE_CACHE.get(url);\n+            String contentType = HttpUtil.guessContentTypeFromData(bytes);\n+            return new RawType(bytes,\n+                    contentType == null || contentType.isEmpty() ? RawType.DEFAULT_MIME_TYPE : contentType);\n+        } else {\n+            RawType image = downloadImage(url);\n+            if (image != null) {\n+                IMAGE_CACHE.put(url, image.getBytes());\n+                return image;\n+            }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODM5MjU1NA=="}, "originalCommit": {"oid": "cda5702bde5734236034eb2f0864200e6211afbe"}, "originalPosition": 224}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTc3MDMwMQ==", "bodyText": "Maybe we should consider adding this to the into the 3.0 core if it used in so many places...", "url": "https://github.com/openhab/openhab-addons/pull/7367#discussion_r409770301", "createdAt": "2020-04-16T18:39:21Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.chromecast/src/main/java/org/openhab/binding/chromecast/internal/ChromecastStatusUpdater.java", "diffHunk": "@@ -245,21 +246,39 @@ private void updateImage(Map<String, Object> metadata) {\n             }\n         }\n \n-        // Poor man's cache. If the imageSrc is the same, don't update them.\n-        if (Objects.equals(this.imageSrc, imageSrc)) {\n-            return;\n-        } else {\n-            this.imageSrc = imageSrc;\n-        }\n-\n         if (callback.isLinked(CHANNEL_IMAGE_SRC)) {\n-            callback.updateState(CHANNEL_IMAGE_SRC, imageSrc == null ? UNDEF : new StringType(imageSrc));\n+            callback.updateState(CHANNEL_IMAGE_SRC, imageSrc == null ? UnDefType.UNDEF : new StringType(imageSrc));\n         }\n \n         if (callback.isLinked(CHANNEL_IMAGE)) {\n-            State image = imageSrc == null ? UNDEF : HttpUtil.downloadImage(imageSrc);\n-            callback.updateState(CHANNEL_IMAGE, image == null ? UNDEF : image);\n+            State image = imageSrc == null ? UnDefType.UNDEF : downloadImageFromCache(imageSrc);\n+            callback.updateState(CHANNEL_IMAGE, image == null ? UnDefType.UNDEF : image);\n+        }\n+    }\n+\n+    private @Nullable RawType downloadImage(String url) {\n+        logger.debug(\"Trying to download the content of URL '{}'\", url);\n+        RawType downloadedImage = HttpUtil.downloadImage(url);\n+        if (downloadedImage == null) {\n+            logger.debug(\"Failed to download the content of URL '{}'\", url);\n+        }\n+        return downloadedImage;\n+    }\n+\n+    private @Nullable RawType downloadImageFromCache(String url) {\n+        if (IMAGE_CACHE.containsKey(url)) {\n+            byte[] bytes = IMAGE_CACHE.get(url);\n+            String contentType = HttpUtil.guessContentTypeFromData(bytes);\n+            return new RawType(bytes,\n+                    contentType == null || contentType.isEmpty() ? RawType.DEFAULT_MIME_TYPE : contentType);\n+        } else {\n+            RawType image = downloadImage(url);\n+            if (image != null) {\n+                IMAGE_CACHE.put(url, image.getBytes());\n+                return image;\n+            }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODM5MjU1NA=="}, "originalCommit": {"oid": "cda5702bde5734236034eb2f0864200e6211afbe"}, "originalPosition": 224}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTc3NTU1Mg==", "bodyText": "I will add it to the list in #4736. I tried it once but it did not work out nicely. My current implementation uses ConfigConstants.getUserDataFolder() which is not available in package org.openhab.core.cache. I have to solve one of the todos first. There are even bigger plans for it (see e.g. eclipse-archived/smarthome#6041) to make it configurable and it could be used for voice add-ons to cache similar speech data.", "url": "https://github.com/openhab/openhab-addons/pull/7367#discussion_r409775552", "createdAt": "2020-04-16T18:48:30Z", "author": {"login": "cweitkamp"}, "path": "bundles/org.openhab.binding.chromecast/src/main/java/org/openhab/binding/chromecast/internal/ChromecastStatusUpdater.java", "diffHunk": "@@ -245,21 +246,39 @@ private void updateImage(Map<String, Object> metadata) {\n             }\n         }\n \n-        // Poor man's cache. If the imageSrc is the same, don't update them.\n-        if (Objects.equals(this.imageSrc, imageSrc)) {\n-            return;\n-        } else {\n-            this.imageSrc = imageSrc;\n-        }\n-\n         if (callback.isLinked(CHANNEL_IMAGE_SRC)) {\n-            callback.updateState(CHANNEL_IMAGE_SRC, imageSrc == null ? UNDEF : new StringType(imageSrc));\n+            callback.updateState(CHANNEL_IMAGE_SRC, imageSrc == null ? UnDefType.UNDEF : new StringType(imageSrc));\n         }\n \n         if (callback.isLinked(CHANNEL_IMAGE)) {\n-            State image = imageSrc == null ? UNDEF : HttpUtil.downloadImage(imageSrc);\n-            callback.updateState(CHANNEL_IMAGE, image == null ? UNDEF : image);\n+            State image = imageSrc == null ? UnDefType.UNDEF : downloadImageFromCache(imageSrc);\n+            callback.updateState(CHANNEL_IMAGE, image == null ? UnDefType.UNDEF : image);\n+        }\n+    }\n+\n+    private @Nullable RawType downloadImage(String url) {\n+        logger.debug(\"Trying to download the content of URL '{}'\", url);\n+        RawType downloadedImage = HttpUtil.downloadImage(url);\n+        if (downloadedImage == null) {\n+            logger.debug(\"Failed to download the content of URL '{}'\", url);\n+        }\n+        return downloadedImage;\n+    }\n+\n+    private @Nullable RawType downloadImageFromCache(String url) {\n+        if (IMAGE_CACHE.containsKey(url)) {\n+            byte[] bytes = IMAGE_CACHE.get(url);\n+            String contentType = HttpUtil.guessContentTypeFromData(bytes);\n+            return new RawType(bytes,\n+                    contentType == null || contentType.isEmpty() ? RawType.DEFAULT_MIME_TYPE : contentType);\n+        } else {\n+            RawType image = downloadImage(url);\n+            if (image != null) {\n+                IMAGE_CACHE.put(url, image.getBytes());\n+                return image;\n+            }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODM5MjU1NA=="}, "originalCommit": {"oid": "cda5702bde5734236034eb2f0864200e6211afbe"}, "originalPosition": 224}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTc4MDE3OQ==", "bodyText": "Sounds good to me", "url": "https://github.com/openhab/openhab-addons/pull/7367#discussion_r409780179", "createdAt": "2020-04-16T18:56:48Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.chromecast/src/main/java/org/openhab/binding/chromecast/internal/ChromecastStatusUpdater.java", "diffHunk": "@@ -245,21 +246,39 @@ private void updateImage(Map<String, Object> metadata) {\n             }\n         }\n \n-        // Poor man's cache. If the imageSrc is the same, don't update them.\n-        if (Objects.equals(this.imageSrc, imageSrc)) {\n-            return;\n-        } else {\n-            this.imageSrc = imageSrc;\n-        }\n-\n         if (callback.isLinked(CHANNEL_IMAGE_SRC)) {\n-            callback.updateState(CHANNEL_IMAGE_SRC, imageSrc == null ? UNDEF : new StringType(imageSrc));\n+            callback.updateState(CHANNEL_IMAGE_SRC, imageSrc == null ? UnDefType.UNDEF : new StringType(imageSrc));\n         }\n \n         if (callback.isLinked(CHANNEL_IMAGE)) {\n-            State image = imageSrc == null ? UNDEF : HttpUtil.downloadImage(imageSrc);\n-            callback.updateState(CHANNEL_IMAGE, image == null ? UNDEF : image);\n+            State image = imageSrc == null ? UnDefType.UNDEF : downloadImageFromCache(imageSrc);\n+            callback.updateState(CHANNEL_IMAGE, image == null ? UnDefType.UNDEF : image);\n+        }\n+    }\n+\n+    private @Nullable RawType downloadImage(String url) {\n+        logger.debug(\"Trying to download the content of URL '{}'\", url);\n+        RawType downloadedImage = HttpUtil.downloadImage(url);\n+        if (downloadedImage == null) {\n+            logger.debug(\"Failed to download the content of URL '{}'\", url);\n+        }\n+        return downloadedImage;\n+    }\n+\n+    private @Nullable RawType downloadImageFromCache(String url) {\n+        if (IMAGE_CACHE.containsKey(url)) {\n+            byte[] bytes = IMAGE_CACHE.get(url);\n+            String contentType = HttpUtil.guessContentTypeFromData(bytes);\n+            return new RawType(bytes,\n+                    contentType == null || contentType.isEmpty() ? RawType.DEFAULT_MIME_TYPE : contentType);\n+        } else {\n+            RawType image = downloadImage(url);\n+            if (image != null) {\n+                IMAGE_CACHE.put(url, image.getBytes());\n+                return image;\n+            }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODM5MjU1NA=="}, "originalCommit": {"oid": "cda5702bde5734236034eb2f0864200e6211afbe"}, "originalPosition": 224}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUzNTQ1NzQ2OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.chromecast/src/main/java/org/openhab/binding/chromecast/internal/discovery/ChromecastDiscoveryParticipant.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQxOTo1NzoxN1rOGFenhg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQxOTo1NzoxN1rOGFenhg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODM5NzcwMg==", "bodyText": "If you are trying to prevent rehashes you need take into account the loadFactor.\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    final Map<String, Object> properties = new HashMap<>(3);\n          \n          \n            \n                    final Map<String, Object> properties = new HashMap<>(5);\n          \n      \n    \n    \n  \n\nAt 0.75 loadFactor an initial capacity of 5 is safe to hold 3 entries without rehashing.", "url": "https://github.com/openhab/openhab-addons/pull/7367#discussion_r408397702", "createdAt": "2020-04-14T19:57:17Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.chromecast/src/main/java/org/openhab/binding/chromecast/internal/discovery/ChromecastDiscoveryParticipant.java", "diffHunk": "@@ -54,13 +58,13 @@ public String getServiceType() {\n     }\n \n     @Override\n-    public DiscoveryResult createResult(ServiceInfo service) {\n+    public @Nullable DiscoveryResult createResult(ServiceInfo service) {\n         final ThingUID uid = getThingUID(service);\n         if (uid == null) {\n             return null;\n         }\n \n-        final Map<String, Object> properties = new HashMap<>(2);\n+        final Map<String, Object> properties = new HashMap<>(3);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cda5702bde5734236034eb2f0864200e6211afbe"}, "originalPosition": 37}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUzNTQ4NjA5OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.chromecast/src/main/java/org/openhab/binding/chromecast/internal/utils/ByteArrayFileCache.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQyMDowNTozNVrOGFe5lQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNlQxMDoyOTo1MFrOGGe8dw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQwMjMyNQ==", "bodyText": "Why can't you just throw an exception instead of making it seem like the cached file is empty to callers?", "url": "https://github.com/openhab/openhab-addons/pull/7367#discussion_r408402325", "createdAt": "2020-04-14T20:05:35Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.chromecast/src/main/java/org/openhab/binding/chromecast/internal/utils/ByteArrayFileCache.java", "diffHunk": "@@ -0,0 +1,299 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.chromecast.internal.utils;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.math.BigInteger;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.security.MessageDigest;\n+import java.security.NoSuchAlgorithmException;\n+import java.util.Arrays;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.config.core.ConfigConstants;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * This is a simple file based cache implementation.\n+ *\n+ * @author Christoph Weitkamp - Initial contribution\n+ */\n+@NonNullByDefault\n+public class ByteArrayFileCache {\n+\n+    private final Logger logger = LoggerFactory.getLogger(ByteArrayFileCache.class);\n+\n+    private static final String MD5_ALGORITHM = \"MD5\";\n+\n+    static final String CACHE_FOLDER_NAME = \"cache\";\n+    private static final char EXTENSION_SEPARATOR = '.';\n+    private static final char UNIX_SEPARATOR = '/';\n+    private static final char WINDOWS_SEPARATOR = '\\\\';\n+\n+    private final File cacheFolder;\n+\n+    static final long ONE_DAY_IN_MILLIS = TimeUnit.DAYS.toMillis(1);\n+    private int expiry = 0;\n+\n+    private static final Map<String, File> FILES_IN_CACHE = new ConcurrentHashMap<>();\n+\n+    /**\n+     * Creates a new {@link ByteArrayFileCache} instance for a service. Creates a <code>cache</code> folder under\n+     * <code>$userdata/cache/$servicePID</code>.\n+     *\n+     * @param servicePID PID of the service\n+     */\n+    public ByteArrayFileCache(String servicePID) {\n+        // TODO track and limit folder size\n+        // TODO support user specific folder\n+        cacheFolder = new File(new File(ConfigConstants.getUserDataFolder(), CACHE_FOLDER_NAME), servicePID);\n+        if (!cacheFolder.exists()) {\n+            logger.debug(\"Creating cache folder '{}'\", cacheFolder.getAbsolutePath());\n+            cacheFolder.mkdirs();\n+        }\n+        logger.debug(\"Using cache folder '{}'\", cacheFolder.getAbsolutePath());\n+    }\n+\n+    /**\n+     * Creates a new {@link ByteArrayFileCache} instance for a service. Creates a <code>cache</code> folder under\n+     * <code>$userdata/cache/$servicePID/</code>.\n+     *\n+     * @param servicePID PID of the service\n+     * @param int the days for how long the files stay in the cache valid. Must be positive. 0 to\n+     *            disables this functionality.\n+     */\n+    public ByteArrayFileCache(String servicePID, int expiry) {\n+        this(servicePID);\n+        if (expiry < 0) {\n+            throw new IllegalArgumentException(\"Cache expiration time must be greater than or equal to 0\");\n+        }\n+        this.expiry = expiry;\n+    }\n+\n+    /**\n+     * Adds a file to the cache. If the cache previously contained a file for the key, the old file is replaced by the\n+     * new content.\n+     *\n+     * @param key the key with which the file is to be associated\n+     * @param content the content for the file to be associated with the specified key\n+     */\n+    public void put(String key, byte[] content) {\n+        writeFile(getUniqueFile(key), content);\n+    }\n+\n+    /**\n+     * Adds a file to the cache.\n+     *\n+     * @param key the key with which the file is to be associated\n+     * @param content the content for the file to be associated with the specified key\n+     */\n+    public void putIfAbsent(String key, byte[] content) {\n+        File fileInCache = getUniqueFile(key);\n+        if (fileInCache.exists()) {\n+            logger.debug(\"File '{}' present in cache\", fileInCache.getName());\n+            // update time of last use\n+            fileInCache.setLastModified(System.currentTimeMillis());\n+        } else {\n+            writeFile(fileInCache, content);\n+        }\n+    }\n+\n+    /**\n+     * Adds a file to the cache and returns the content of the file.\n+     *\n+     * @param key the key with which the file is to be associated\n+     * @param content the content for the file to be associated with the specified key\n+     * @return the content of the file associated with the given key\n+     */\n+    public byte[] putIfAbsentAndGet(String key, byte[] content) {\n+        putIfAbsent(key, content);\n+\n+        return content;\n+    }\n+\n+    /**\n+     * Writes the given content to the given {@link File}.\n+     *\n+     * @param fileInCache the {@link File}\n+     * @param content the content to be written\n+     */\n+    private void writeFile(File fileInCache, byte[] content) {\n+        logger.debug(\"Caching file '{}'\", fileInCache.getName());\n+        try {\n+            Files.write(fileInCache.toPath(), content);\n+        } catch (IOException e) {\n+            logger.warn(\"Could not write file '{}'\u00a0to cache\", fileInCache.getName(), e);\n+        }\n+    }\n+\n+    /**\n+     * Checks if the key is present in the cache.\n+     *\n+     * @param key the key whose presence in the cache is to be tested\n+     * @return true if the cache contains a file for the specified key\n+     */\n+    public boolean containsKey(String key) {\n+        return getUniqueFile(key).exists();\n+    }\n+\n+    /**\n+     * Removes the file associated with the given key from the cache.\n+     *\n+     * @param key the key whose associated file is to be removed\n+     */\n+    public void remove(String key) {\n+        deleteFile(getUniqueFile(key));\n+    }\n+\n+    /**\n+     * Deletes the given {@link File}.\n+     *\n+     * @param fileInCache the {@link File}\n+     */\n+    private void deleteFile(File fileInCache) {\n+        if (fileInCache.exists()) {\n+            logger.debug(\"Deleting file '{}' from cache\", fileInCache.getName());\n+            fileInCache.delete();\n+        } else {\n+            logger.debug(\"File '{}' not found in cache\", fileInCache.getName());\n+        }\n+    }\n+\n+    /**\n+     * Removes all files from the cache.\n+     */\n+    public void clear() {\n+        File[] filesInCache = cacheFolder.listFiles();\n+        if (filesInCache != null && filesInCache.length > 0) {\n+            logger.debug(\"Deleting all files from cache\");\n+            Arrays.stream(filesInCache).forEach(File::delete);\n+        }\n+    }\n+\n+    /**\n+     * Removes expired files from the cache.\n+     */\n+    public void clearExpired() {\n+        // exit if expiry is set to 0 (disabled)\n+        if (expiry <= 0) {\n+            return;\n+        }\n+        File[] filesInCache = cacheFolder.listFiles();\n+        if (filesInCache != null && filesInCache.length > 0) {\n+            logger.debug(\"Deleting expired files from cache\");\n+            Arrays.stream(filesInCache).filter(file -> isExpired(file)).forEach(File::delete);\n+        }\n+    }\n+\n+    /**\n+     * Checks if the given {@link File} is expired.\n+     *\n+     * @param fileInCache the {@link File}\n+     * @return <code>true</code> if the file is expired, <code>false</code> otherwise\n+     */\n+    private boolean isExpired(File fileInCache) {\n+        // exit if expiry is set to 0 (disabled)\n+        if (expiry <= 0) {\n+            return false;\n+        }\n+        return expiry * ONE_DAY_IN_MILLIS < System.currentTimeMillis() - fileInCache.lastModified();\n+    }\n+\n+    /**\n+     * Returns the content of the file associated with the given key, if it is present.\n+     *\n+     * @param key the key whose associated file is to be returned\n+     * @return the content of the file associated with the given key\n+     */\n+    public byte[] get(String key) {\n+        return readFile(getUniqueFile(key));\n+    }\n+\n+    /**\n+     * Reads the content from the given {@link File}, if it is present.\n+     *\n+     * @param fileInCache the {@link File}\n+     * @return the content of the file\n+     */\n+    private byte[] readFile(File fileInCache) {\n+        if (fileInCache.exists()) {\n+            logger.debug(\"Reading file '{}' from cache\", fileInCache.getName());\n+            // update time of last use\n+            fileInCache.setLastModified(System.currentTimeMillis());\n+            try {\n+                return Files.readAllBytes(fileInCache.toPath());\n+            } catch (IOException e) {\n+                logger.warn(\"Could not read file '{}'\u00a0from cache\", fileInCache.getName(), e);\n+            }\n+        } else {\n+            logger.debug(\"File '{}' not found in cache\", fileInCache.getName());\n+        }\n+        return new byte[0];", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cda5702bde5734236034eb2f0864200e6211afbe"}, "originalPosition": 248}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTQ1MTYzOQ==", "bodyText": "That is a good idea. Will implement it.", "url": "https://github.com/openhab/openhab-addons/pull/7367#discussion_r409451639", "createdAt": "2020-04-16T10:29:50Z", "author": {"login": "cweitkamp"}, "path": "bundles/org.openhab.binding.chromecast/src/main/java/org/openhab/binding/chromecast/internal/utils/ByteArrayFileCache.java", "diffHunk": "@@ -0,0 +1,299 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.chromecast.internal.utils;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.math.BigInteger;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.security.MessageDigest;\n+import java.security.NoSuchAlgorithmException;\n+import java.util.Arrays;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.config.core.ConfigConstants;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * This is a simple file based cache implementation.\n+ *\n+ * @author Christoph Weitkamp - Initial contribution\n+ */\n+@NonNullByDefault\n+public class ByteArrayFileCache {\n+\n+    private final Logger logger = LoggerFactory.getLogger(ByteArrayFileCache.class);\n+\n+    private static final String MD5_ALGORITHM = \"MD5\";\n+\n+    static final String CACHE_FOLDER_NAME = \"cache\";\n+    private static final char EXTENSION_SEPARATOR = '.';\n+    private static final char UNIX_SEPARATOR = '/';\n+    private static final char WINDOWS_SEPARATOR = '\\\\';\n+\n+    private final File cacheFolder;\n+\n+    static final long ONE_DAY_IN_MILLIS = TimeUnit.DAYS.toMillis(1);\n+    private int expiry = 0;\n+\n+    private static final Map<String, File> FILES_IN_CACHE = new ConcurrentHashMap<>();\n+\n+    /**\n+     * Creates a new {@link ByteArrayFileCache} instance for a service. Creates a <code>cache</code> folder under\n+     * <code>$userdata/cache/$servicePID</code>.\n+     *\n+     * @param servicePID PID of the service\n+     */\n+    public ByteArrayFileCache(String servicePID) {\n+        // TODO track and limit folder size\n+        // TODO support user specific folder\n+        cacheFolder = new File(new File(ConfigConstants.getUserDataFolder(), CACHE_FOLDER_NAME), servicePID);\n+        if (!cacheFolder.exists()) {\n+            logger.debug(\"Creating cache folder '{}'\", cacheFolder.getAbsolutePath());\n+            cacheFolder.mkdirs();\n+        }\n+        logger.debug(\"Using cache folder '{}'\", cacheFolder.getAbsolutePath());\n+    }\n+\n+    /**\n+     * Creates a new {@link ByteArrayFileCache} instance for a service. Creates a <code>cache</code> folder under\n+     * <code>$userdata/cache/$servicePID/</code>.\n+     *\n+     * @param servicePID PID of the service\n+     * @param int the days for how long the files stay in the cache valid. Must be positive. 0 to\n+     *            disables this functionality.\n+     */\n+    public ByteArrayFileCache(String servicePID, int expiry) {\n+        this(servicePID);\n+        if (expiry < 0) {\n+            throw new IllegalArgumentException(\"Cache expiration time must be greater than or equal to 0\");\n+        }\n+        this.expiry = expiry;\n+    }\n+\n+    /**\n+     * Adds a file to the cache. If the cache previously contained a file for the key, the old file is replaced by the\n+     * new content.\n+     *\n+     * @param key the key with which the file is to be associated\n+     * @param content the content for the file to be associated with the specified key\n+     */\n+    public void put(String key, byte[] content) {\n+        writeFile(getUniqueFile(key), content);\n+    }\n+\n+    /**\n+     * Adds a file to the cache.\n+     *\n+     * @param key the key with which the file is to be associated\n+     * @param content the content for the file to be associated with the specified key\n+     */\n+    public void putIfAbsent(String key, byte[] content) {\n+        File fileInCache = getUniqueFile(key);\n+        if (fileInCache.exists()) {\n+            logger.debug(\"File '{}' present in cache\", fileInCache.getName());\n+            // update time of last use\n+            fileInCache.setLastModified(System.currentTimeMillis());\n+        } else {\n+            writeFile(fileInCache, content);\n+        }\n+    }\n+\n+    /**\n+     * Adds a file to the cache and returns the content of the file.\n+     *\n+     * @param key the key with which the file is to be associated\n+     * @param content the content for the file to be associated with the specified key\n+     * @return the content of the file associated with the given key\n+     */\n+    public byte[] putIfAbsentAndGet(String key, byte[] content) {\n+        putIfAbsent(key, content);\n+\n+        return content;\n+    }\n+\n+    /**\n+     * Writes the given content to the given {@link File}.\n+     *\n+     * @param fileInCache the {@link File}\n+     * @param content the content to be written\n+     */\n+    private void writeFile(File fileInCache, byte[] content) {\n+        logger.debug(\"Caching file '{}'\", fileInCache.getName());\n+        try {\n+            Files.write(fileInCache.toPath(), content);\n+        } catch (IOException e) {\n+            logger.warn(\"Could not write file '{}'\u00a0to cache\", fileInCache.getName(), e);\n+        }\n+    }\n+\n+    /**\n+     * Checks if the key is present in the cache.\n+     *\n+     * @param key the key whose presence in the cache is to be tested\n+     * @return true if the cache contains a file for the specified key\n+     */\n+    public boolean containsKey(String key) {\n+        return getUniqueFile(key).exists();\n+    }\n+\n+    /**\n+     * Removes the file associated with the given key from the cache.\n+     *\n+     * @param key the key whose associated file is to be removed\n+     */\n+    public void remove(String key) {\n+        deleteFile(getUniqueFile(key));\n+    }\n+\n+    /**\n+     * Deletes the given {@link File}.\n+     *\n+     * @param fileInCache the {@link File}\n+     */\n+    private void deleteFile(File fileInCache) {\n+        if (fileInCache.exists()) {\n+            logger.debug(\"Deleting file '{}' from cache\", fileInCache.getName());\n+            fileInCache.delete();\n+        } else {\n+            logger.debug(\"File '{}' not found in cache\", fileInCache.getName());\n+        }\n+    }\n+\n+    /**\n+     * Removes all files from the cache.\n+     */\n+    public void clear() {\n+        File[] filesInCache = cacheFolder.listFiles();\n+        if (filesInCache != null && filesInCache.length > 0) {\n+            logger.debug(\"Deleting all files from cache\");\n+            Arrays.stream(filesInCache).forEach(File::delete);\n+        }\n+    }\n+\n+    /**\n+     * Removes expired files from the cache.\n+     */\n+    public void clearExpired() {\n+        // exit if expiry is set to 0 (disabled)\n+        if (expiry <= 0) {\n+            return;\n+        }\n+        File[] filesInCache = cacheFolder.listFiles();\n+        if (filesInCache != null && filesInCache.length > 0) {\n+            logger.debug(\"Deleting expired files from cache\");\n+            Arrays.stream(filesInCache).filter(file -> isExpired(file)).forEach(File::delete);\n+        }\n+    }\n+\n+    /**\n+     * Checks if the given {@link File} is expired.\n+     *\n+     * @param fileInCache the {@link File}\n+     * @return <code>true</code> if the file is expired, <code>false</code> otherwise\n+     */\n+    private boolean isExpired(File fileInCache) {\n+        // exit if expiry is set to 0 (disabled)\n+        if (expiry <= 0) {\n+            return false;\n+        }\n+        return expiry * ONE_DAY_IN_MILLIS < System.currentTimeMillis() - fileInCache.lastModified();\n+    }\n+\n+    /**\n+     * Returns the content of the file associated with the given key, if it is present.\n+     *\n+     * @param key the key whose associated file is to be returned\n+     * @return the content of the file associated with the given key\n+     */\n+    public byte[] get(String key) {\n+        return readFile(getUniqueFile(key));\n+    }\n+\n+    /**\n+     * Reads the content from the given {@link File}, if it is present.\n+     *\n+     * @param fileInCache the {@link File}\n+     * @return the content of the file\n+     */\n+    private byte[] readFile(File fileInCache) {\n+        if (fileInCache.exists()) {\n+            logger.debug(\"Reading file '{}' from cache\", fileInCache.getName());\n+            // update time of last use\n+            fileInCache.setLastModified(System.currentTimeMillis());\n+            try {\n+                return Files.readAllBytes(fileInCache.toPath());\n+            } catch (IOException e) {\n+                logger.warn(\"Could not read file '{}'\u00a0from cache\", fileInCache.getName(), e);\n+            }\n+        } else {\n+            logger.debug(\"File '{}' not found in cache\", fileInCache.getName());\n+        }\n+        return new byte[0];", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQwMjMyNQ=="}, "originalCommit": {"oid": "cda5702bde5734236034eb2f0864200e6211afbe"}, "originalPosition": 248}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUzNTQ5ODgxOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.chromecast/src/main/java/org/openhab/binding/chromecast/internal/utils/ByteArrayFileCache.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQyMDowOToyMFrOGFfBkg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNlQxOToxMjozMVrOGGzgww==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQwNDM3MA==", "bodyText": "Surely there are simpler ways to generate a unique file name than using an MD5 hash. Wouldn't the hashcode of the key suffice?", "url": "https://github.com/openhab/openhab-addons/pull/7367#discussion_r408404370", "createdAt": "2020-04-14T20:09:20Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.chromecast/src/main/java/org/openhab/binding/chromecast/internal/utils/ByteArrayFileCache.java", "diffHunk": "@@ -0,0 +1,299 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.chromecast.internal.utils;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.math.BigInteger;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.security.MessageDigest;\n+import java.security.NoSuchAlgorithmException;\n+import java.util.Arrays;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.config.core.ConfigConstants;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * This is a simple file based cache implementation.\n+ *\n+ * @author Christoph Weitkamp - Initial contribution\n+ */\n+@NonNullByDefault\n+public class ByteArrayFileCache {\n+\n+    private final Logger logger = LoggerFactory.getLogger(ByteArrayFileCache.class);\n+\n+    private static final String MD5_ALGORITHM = \"MD5\";\n+\n+    static final String CACHE_FOLDER_NAME = \"cache\";\n+    private static final char EXTENSION_SEPARATOR = '.';\n+    private static final char UNIX_SEPARATOR = '/';\n+    private static final char WINDOWS_SEPARATOR = '\\\\';\n+\n+    private final File cacheFolder;\n+\n+    static final long ONE_DAY_IN_MILLIS = TimeUnit.DAYS.toMillis(1);\n+    private int expiry = 0;\n+\n+    private static final Map<String, File> FILES_IN_CACHE = new ConcurrentHashMap<>();\n+\n+    /**\n+     * Creates a new {@link ByteArrayFileCache} instance for a service. Creates a <code>cache</code> folder under\n+     * <code>$userdata/cache/$servicePID</code>.\n+     *\n+     * @param servicePID PID of the service\n+     */\n+    public ByteArrayFileCache(String servicePID) {\n+        // TODO track and limit folder size\n+        // TODO support user specific folder\n+        cacheFolder = new File(new File(ConfigConstants.getUserDataFolder(), CACHE_FOLDER_NAME), servicePID);\n+        if (!cacheFolder.exists()) {\n+            logger.debug(\"Creating cache folder '{}'\", cacheFolder.getAbsolutePath());\n+            cacheFolder.mkdirs();\n+        }\n+        logger.debug(\"Using cache folder '{}'\", cacheFolder.getAbsolutePath());\n+    }\n+\n+    /**\n+     * Creates a new {@link ByteArrayFileCache} instance for a service. Creates a <code>cache</code> folder under\n+     * <code>$userdata/cache/$servicePID/</code>.\n+     *\n+     * @param servicePID PID of the service\n+     * @param int the days for how long the files stay in the cache valid. Must be positive. 0 to\n+     *            disables this functionality.\n+     */\n+    public ByteArrayFileCache(String servicePID, int expiry) {\n+        this(servicePID);\n+        if (expiry < 0) {\n+            throw new IllegalArgumentException(\"Cache expiration time must be greater than or equal to 0\");\n+        }\n+        this.expiry = expiry;\n+    }\n+\n+    /**\n+     * Adds a file to the cache. If the cache previously contained a file for the key, the old file is replaced by the\n+     * new content.\n+     *\n+     * @param key the key with which the file is to be associated\n+     * @param content the content for the file to be associated with the specified key\n+     */\n+    public void put(String key, byte[] content) {\n+        writeFile(getUniqueFile(key), content);\n+    }\n+\n+    /**\n+     * Adds a file to the cache.\n+     *\n+     * @param key the key with which the file is to be associated\n+     * @param content the content for the file to be associated with the specified key\n+     */\n+    public void putIfAbsent(String key, byte[] content) {\n+        File fileInCache = getUniqueFile(key);\n+        if (fileInCache.exists()) {\n+            logger.debug(\"File '{}' present in cache\", fileInCache.getName());\n+            // update time of last use\n+            fileInCache.setLastModified(System.currentTimeMillis());\n+        } else {\n+            writeFile(fileInCache, content);\n+        }\n+    }\n+\n+    /**\n+     * Adds a file to the cache and returns the content of the file.\n+     *\n+     * @param key the key with which the file is to be associated\n+     * @param content the content for the file to be associated with the specified key\n+     * @return the content of the file associated with the given key\n+     */\n+    public byte[] putIfAbsentAndGet(String key, byte[] content) {\n+        putIfAbsent(key, content);\n+\n+        return content;\n+    }\n+\n+    /**\n+     * Writes the given content to the given {@link File}.\n+     *\n+     * @param fileInCache the {@link File}\n+     * @param content the content to be written\n+     */\n+    private void writeFile(File fileInCache, byte[] content) {\n+        logger.debug(\"Caching file '{}'\", fileInCache.getName());\n+        try {\n+            Files.write(fileInCache.toPath(), content);\n+        } catch (IOException e) {\n+            logger.warn(\"Could not write file '{}'\u00a0to cache\", fileInCache.getName(), e);\n+        }\n+    }\n+\n+    /**\n+     * Checks if the key is present in the cache.\n+     *\n+     * @param key the key whose presence in the cache is to be tested\n+     * @return true if the cache contains a file for the specified key\n+     */\n+    public boolean containsKey(String key) {\n+        return getUniqueFile(key).exists();\n+    }\n+\n+    /**\n+     * Removes the file associated with the given key from the cache.\n+     *\n+     * @param key the key whose associated file is to be removed\n+     */\n+    public void remove(String key) {\n+        deleteFile(getUniqueFile(key));\n+    }\n+\n+    /**\n+     * Deletes the given {@link File}.\n+     *\n+     * @param fileInCache the {@link File}\n+     */\n+    private void deleteFile(File fileInCache) {\n+        if (fileInCache.exists()) {\n+            logger.debug(\"Deleting file '{}' from cache\", fileInCache.getName());\n+            fileInCache.delete();\n+        } else {\n+            logger.debug(\"File '{}' not found in cache\", fileInCache.getName());\n+        }\n+    }\n+\n+    /**\n+     * Removes all files from the cache.\n+     */\n+    public void clear() {\n+        File[] filesInCache = cacheFolder.listFiles();\n+        if (filesInCache != null && filesInCache.length > 0) {\n+            logger.debug(\"Deleting all files from cache\");\n+            Arrays.stream(filesInCache).forEach(File::delete);\n+        }\n+    }\n+\n+    /**\n+     * Removes expired files from the cache.\n+     */\n+    public void clearExpired() {\n+        // exit if expiry is set to 0 (disabled)\n+        if (expiry <= 0) {\n+            return;\n+        }\n+        File[] filesInCache = cacheFolder.listFiles();\n+        if (filesInCache != null && filesInCache.length > 0) {\n+            logger.debug(\"Deleting expired files from cache\");\n+            Arrays.stream(filesInCache).filter(file -> isExpired(file)).forEach(File::delete);\n+        }\n+    }\n+\n+    /**\n+     * Checks if the given {@link File} is expired.\n+     *\n+     * @param fileInCache the {@link File}\n+     * @return <code>true</code> if the file is expired, <code>false</code> otherwise\n+     */\n+    private boolean isExpired(File fileInCache) {\n+        // exit if expiry is set to 0 (disabled)\n+        if (expiry <= 0) {\n+            return false;\n+        }\n+        return expiry * ONE_DAY_IN_MILLIS < System.currentTimeMillis() - fileInCache.lastModified();\n+    }\n+\n+    /**\n+     * Returns the content of the file associated with the given key, if it is present.\n+     *\n+     * @param key the key whose associated file is to be returned\n+     * @return the content of the file associated with the given key\n+     */\n+    public byte[] get(String key) {\n+        return readFile(getUniqueFile(key));\n+    }\n+\n+    /**\n+     * Reads the content from the given {@link File}, if it is present.\n+     *\n+     * @param fileInCache the {@link File}\n+     * @return the content of the file\n+     */\n+    private byte[] readFile(File fileInCache) {\n+        if (fileInCache.exists()) {\n+            logger.debug(\"Reading file '{}' from cache\", fileInCache.getName());\n+            // update time of last use\n+            fileInCache.setLastModified(System.currentTimeMillis());\n+            try {\n+                return Files.readAllBytes(fileInCache.toPath());\n+            } catch (IOException e) {\n+                logger.warn(\"Could not read file '{}'\u00a0from cache\", fileInCache.getName(), e);\n+            }\n+        } else {\n+            logger.debug(\"File '{}' not found in cache\", fileInCache.getName());\n+        }\n+        return new byte[0];\n+    }\n+\n+    /**\n+     * Creates a unique {@link File} from the key with which the file is to be associated.\n+     *\n+     * @param key the key with which the file is to be associated\n+     * @return unique file for the file associated with the given key\n+     */\n+    File getUniqueFile(String key) {\n+        String uniqueFileName = getUniqueFileName(key);\n+        if (FILES_IN_CACHE.containsKey(uniqueFileName)) {\n+            return FILES_IN_CACHE.get(uniqueFileName);\n+        } else {\n+            String fileExtension = getFileExtension(key);\n+            File fileInCache = new File(cacheFolder,\n+                    uniqueFileName + (fileExtension == null ? \"\" : EXTENSION_SEPARATOR + fileExtension));\n+            FILES_IN_CACHE.put(uniqueFileName, fileInCache);\n+            return fileInCache;\n+        }\n+    }\n+\n+    /**\n+     * Gets the extension of a file name.\n+     *\n+     * @param fileName the file name to retrieve the extension of\n+     * @return the extension of the file or null if none exists\n+     */\n+    @Nullable\n+    String getFileExtension(String fileName) {\n+        int extensionPos = fileName.lastIndexOf(EXTENSION_SEPARATOR);\n+        int lastSeparatorPos = Math.max(fileName.lastIndexOf(UNIX_SEPARATOR), fileName.lastIndexOf(WINDOWS_SEPARATOR));\n+        return lastSeparatorPos > extensionPos ? null : fileName.substring(extensionPos + 1).replaceFirst(\"\\\\?.*$\", \"\");\n+    }\n+\n+    /**\n+     * Creates a unique file name from the key with which the file is to be associated.\n+     *\n+     * @param key the key with which the file is to be associated\n+     * @return unique file name for the file associated with the given key\n+     */\n+    String getUniqueFileName(String key) {\n+        try {\n+            final MessageDigest md = MessageDigest.getInstance(MD5_ALGORITHM);\n+            return String.format(\"%032x\", new BigInteger(1, md.digest(key.getBytes(StandardCharsets.UTF_8))));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cda5702bde5734236034eb2f0864200e6211afbe"}, "originalPosition": 292}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTc3MTgwOA==", "bodyText": "Since you use this code in other bindings I'm assuming that it wouldn't be worth changing this...", "url": "https://github.com/openhab/openhab-addons/pull/7367#discussion_r409771808", "createdAt": "2020-04-16T18:41:53Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.chromecast/src/main/java/org/openhab/binding/chromecast/internal/utils/ByteArrayFileCache.java", "diffHunk": "@@ -0,0 +1,299 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.chromecast.internal.utils;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.math.BigInteger;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.security.MessageDigest;\n+import java.security.NoSuchAlgorithmException;\n+import java.util.Arrays;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.config.core.ConfigConstants;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * This is a simple file based cache implementation.\n+ *\n+ * @author Christoph Weitkamp - Initial contribution\n+ */\n+@NonNullByDefault\n+public class ByteArrayFileCache {\n+\n+    private final Logger logger = LoggerFactory.getLogger(ByteArrayFileCache.class);\n+\n+    private static final String MD5_ALGORITHM = \"MD5\";\n+\n+    static final String CACHE_FOLDER_NAME = \"cache\";\n+    private static final char EXTENSION_SEPARATOR = '.';\n+    private static final char UNIX_SEPARATOR = '/';\n+    private static final char WINDOWS_SEPARATOR = '\\\\';\n+\n+    private final File cacheFolder;\n+\n+    static final long ONE_DAY_IN_MILLIS = TimeUnit.DAYS.toMillis(1);\n+    private int expiry = 0;\n+\n+    private static final Map<String, File> FILES_IN_CACHE = new ConcurrentHashMap<>();\n+\n+    /**\n+     * Creates a new {@link ByteArrayFileCache} instance for a service. Creates a <code>cache</code> folder under\n+     * <code>$userdata/cache/$servicePID</code>.\n+     *\n+     * @param servicePID PID of the service\n+     */\n+    public ByteArrayFileCache(String servicePID) {\n+        // TODO track and limit folder size\n+        // TODO support user specific folder\n+        cacheFolder = new File(new File(ConfigConstants.getUserDataFolder(), CACHE_FOLDER_NAME), servicePID);\n+        if (!cacheFolder.exists()) {\n+            logger.debug(\"Creating cache folder '{}'\", cacheFolder.getAbsolutePath());\n+            cacheFolder.mkdirs();\n+        }\n+        logger.debug(\"Using cache folder '{}'\", cacheFolder.getAbsolutePath());\n+    }\n+\n+    /**\n+     * Creates a new {@link ByteArrayFileCache} instance for a service. Creates a <code>cache</code> folder under\n+     * <code>$userdata/cache/$servicePID/</code>.\n+     *\n+     * @param servicePID PID of the service\n+     * @param int the days for how long the files stay in the cache valid. Must be positive. 0 to\n+     *            disables this functionality.\n+     */\n+    public ByteArrayFileCache(String servicePID, int expiry) {\n+        this(servicePID);\n+        if (expiry < 0) {\n+            throw new IllegalArgumentException(\"Cache expiration time must be greater than or equal to 0\");\n+        }\n+        this.expiry = expiry;\n+    }\n+\n+    /**\n+     * Adds a file to the cache. If the cache previously contained a file for the key, the old file is replaced by the\n+     * new content.\n+     *\n+     * @param key the key with which the file is to be associated\n+     * @param content the content for the file to be associated with the specified key\n+     */\n+    public void put(String key, byte[] content) {\n+        writeFile(getUniqueFile(key), content);\n+    }\n+\n+    /**\n+     * Adds a file to the cache.\n+     *\n+     * @param key the key with which the file is to be associated\n+     * @param content the content for the file to be associated with the specified key\n+     */\n+    public void putIfAbsent(String key, byte[] content) {\n+        File fileInCache = getUniqueFile(key);\n+        if (fileInCache.exists()) {\n+            logger.debug(\"File '{}' present in cache\", fileInCache.getName());\n+            // update time of last use\n+            fileInCache.setLastModified(System.currentTimeMillis());\n+        } else {\n+            writeFile(fileInCache, content);\n+        }\n+    }\n+\n+    /**\n+     * Adds a file to the cache and returns the content of the file.\n+     *\n+     * @param key the key with which the file is to be associated\n+     * @param content the content for the file to be associated with the specified key\n+     * @return the content of the file associated with the given key\n+     */\n+    public byte[] putIfAbsentAndGet(String key, byte[] content) {\n+        putIfAbsent(key, content);\n+\n+        return content;\n+    }\n+\n+    /**\n+     * Writes the given content to the given {@link File}.\n+     *\n+     * @param fileInCache the {@link File}\n+     * @param content the content to be written\n+     */\n+    private void writeFile(File fileInCache, byte[] content) {\n+        logger.debug(\"Caching file '{}'\", fileInCache.getName());\n+        try {\n+            Files.write(fileInCache.toPath(), content);\n+        } catch (IOException e) {\n+            logger.warn(\"Could not write file '{}'\u00a0to cache\", fileInCache.getName(), e);\n+        }\n+    }\n+\n+    /**\n+     * Checks if the key is present in the cache.\n+     *\n+     * @param key the key whose presence in the cache is to be tested\n+     * @return true if the cache contains a file for the specified key\n+     */\n+    public boolean containsKey(String key) {\n+        return getUniqueFile(key).exists();\n+    }\n+\n+    /**\n+     * Removes the file associated with the given key from the cache.\n+     *\n+     * @param key the key whose associated file is to be removed\n+     */\n+    public void remove(String key) {\n+        deleteFile(getUniqueFile(key));\n+    }\n+\n+    /**\n+     * Deletes the given {@link File}.\n+     *\n+     * @param fileInCache the {@link File}\n+     */\n+    private void deleteFile(File fileInCache) {\n+        if (fileInCache.exists()) {\n+            logger.debug(\"Deleting file '{}' from cache\", fileInCache.getName());\n+            fileInCache.delete();\n+        } else {\n+            logger.debug(\"File '{}' not found in cache\", fileInCache.getName());\n+        }\n+    }\n+\n+    /**\n+     * Removes all files from the cache.\n+     */\n+    public void clear() {\n+        File[] filesInCache = cacheFolder.listFiles();\n+        if (filesInCache != null && filesInCache.length > 0) {\n+            logger.debug(\"Deleting all files from cache\");\n+            Arrays.stream(filesInCache).forEach(File::delete);\n+        }\n+    }\n+\n+    /**\n+     * Removes expired files from the cache.\n+     */\n+    public void clearExpired() {\n+        // exit if expiry is set to 0 (disabled)\n+        if (expiry <= 0) {\n+            return;\n+        }\n+        File[] filesInCache = cacheFolder.listFiles();\n+        if (filesInCache != null && filesInCache.length > 0) {\n+            logger.debug(\"Deleting expired files from cache\");\n+            Arrays.stream(filesInCache).filter(file -> isExpired(file)).forEach(File::delete);\n+        }\n+    }\n+\n+    /**\n+     * Checks if the given {@link File} is expired.\n+     *\n+     * @param fileInCache the {@link File}\n+     * @return <code>true</code> if the file is expired, <code>false</code> otherwise\n+     */\n+    private boolean isExpired(File fileInCache) {\n+        // exit if expiry is set to 0 (disabled)\n+        if (expiry <= 0) {\n+            return false;\n+        }\n+        return expiry * ONE_DAY_IN_MILLIS < System.currentTimeMillis() - fileInCache.lastModified();\n+    }\n+\n+    /**\n+     * Returns the content of the file associated with the given key, if it is present.\n+     *\n+     * @param key the key whose associated file is to be returned\n+     * @return the content of the file associated with the given key\n+     */\n+    public byte[] get(String key) {\n+        return readFile(getUniqueFile(key));\n+    }\n+\n+    /**\n+     * Reads the content from the given {@link File}, if it is present.\n+     *\n+     * @param fileInCache the {@link File}\n+     * @return the content of the file\n+     */\n+    private byte[] readFile(File fileInCache) {\n+        if (fileInCache.exists()) {\n+            logger.debug(\"Reading file '{}' from cache\", fileInCache.getName());\n+            // update time of last use\n+            fileInCache.setLastModified(System.currentTimeMillis());\n+            try {\n+                return Files.readAllBytes(fileInCache.toPath());\n+            } catch (IOException e) {\n+                logger.warn(\"Could not read file '{}'\u00a0from cache\", fileInCache.getName(), e);\n+            }\n+        } else {\n+            logger.debug(\"File '{}' not found in cache\", fileInCache.getName());\n+        }\n+        return new byte[0];\n+    }\n+\n+    /**\n+     * Creates a unique {@link File} from the key with which the file is to be associated.\n+     *\n+     * @param key the key with which the file is to be associated\n+     * @return unique file for the file associated with the given key\n+     */\n+    File getUniqueFile(String key) {\n+        String uniqueFileName = getUniqueFileName(key);\n+        if (FILES_IN_CACHE.containsKey(uniqueFileName)) {\n+            return FILES_IN_CACHE.get(uniqueFileName);\n+        } else {\n+            String fileExtension = getFileExtension(key);\n+            File fileInCache = new File(cacheFolder,\n+                    uniqueFileName + (fileExtension == null ? \"\" : EXTENSION_SEPARATOR + fileExtension));\n+            FILES_IN_CACHE.put(uniqueFileName, fileInCache);\n+            return fileInCache;\n+        }\n+    }\n+\n+    /**\n+     * Gets the extension of a file name.\n+     *\n+     * @param fileName the file name to retrieve the extension of\n+     * @return the extension of the file or null if none exists\n+     */\n+    @Nullable\n+    String getFileExtension(String fileName) {\n+        int extensionPos = fileName.lastIndexOf(EXTENSION_SEPARATOR);\n+        int lastSeparatorPos = Math.max(fileName.lastIndexOf(UNIX_SEPARATOR), fileName.lastIndexOf(WINDOWS_SEPARATOR));\n+        return lastSeparatorPos > extensionPos ? null : fileName.substring(extensionPos + 1).replaceFirst(\"\\\\?.*$\", \"\");\n+    }\n+\n+    /**\n+     * Creates a unique file name from the key with which the file is to be associated.\n+     *\n+     * @param key the key with which the file is to be associated\n+     * @return unique file name for the file associated with the given key\n+     */\n+    String getUniqueFileName(String key) {\n+        try {\n+            final MessageDigest md = MessageDigest.getInstance(MD5_ALGORITHM);\n+            return String.format(\"%032x\", new BigInteger(1, md.digest(key.getBytes(StandardCharsets.UTF_8))));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQwNDM3MA=="}, "originalCommit": {"oid": "cda5702bde5734236034eb2f0864200e6211afbe"}, "originalPosition": 292}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTc4ODYxMQ==", "bodyText": "Changing it here should be okay. But changing it in other bindings will result in \"data loss\" (data ist still there but not taken into account anymore). I am pretty sure there is no better way than using String.hashCode() method at all.", "url": "https://github.com/openhab/openhab-addons/pull/7367#discussion_r409788611", "createdAt": "2020-04-16T19:12:31Z", "author": {"login": "cweitkamp"}, "path": "bundles/org.openhab.binding.chromecast/src/main/java/org/openhab/binding/chromecast/internal/utils/ByteArrayFileCache.java", "diffHunk": "@@ -0,0 +1,299 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.chromecast.internal.utils;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.math.BigInteger;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.security.MessageDigest;\n+import java.security.NoSuchAlgorithmException;\n+import java.util.Arrays;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.config.core.ConfigConstants;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * This is a simple file based cache implementation.\n+ *\n+ * @author Christoph Weitkamp - Initial contribution\n+ */\n+@NonNullByDefault\n+public class ByteArrayFileCache {\n+\n+    private final Logger logger = LoggerFactory.getLogger(ByteArrayFileCache.class);\n+\n+    private static final String MD5_ALGORITHM = \"MD5\";\n+\n+    static final String CACHE_FOLDER_NAME = \"cache\";\n+    private static final char EXTENSION_SEPARATOR = '.';\n+    private static final char UNIX_SEPARATOR = '/';\n+    private static final char WINDOWS_SEPARATOR = '\\\\';\n+\n+    private final File cacheFolder;\n+\n+    static final long ONE_DAY_IN_MILLIS = TimeUnit.DAYS.toMillis(1);\n+    private int expiry = 0;\n+\n+    private static final Map<String, File> FILES_IN_CACHE = new ConcurrentHashMap<>();\n+\n+    /**\n+     * Creates a new {@link ByteArrayFileCache} instance for a service. Creates a <code>cache</code> folder under\n+     * <code>$userdata/cache/$servicePID</code>.\n+     *\n+     * @param servicePID PID of the service\n+     */\n+    public ByteArrayFileCache(String servicePID) {\n+        // TODO track and limit folder size\n+        // TODO support user specific folder\n+        cacheFolder = new File(new File(ConfigConstants.getUserDataFolder(), CACHE_FOLDER_NAME), servicePID);\n+        if (!cacheFolder.exists()) {\n+            logger.debug(\"Creating cache folder '{}'\", cacheFolder.getAbsolutePath());\n+            cacheFolder.mkdirs();\n+        }\n+        logger.debug(\"Using cache folder '{}'\", cacheFolder.getAbsolutePath());\n+    }\n+\n+    /**\n+     * Creates a new {@link ByteArrayFileCache} instance for a service. Creates a <code>cache</code> folder under\n+     * <code>$userdata/cache/$servicePID/</code>.\n+     *\n+     * @param servicePID PID of the service\n+     * @param int the days for how long the files stay in the cache valid. Must be positive. 0 to\n+     *            disables this functionality.\n+     */\n+    public ByteArrayFileCache(String servicePID, int expiry) {\n+        this(servicePID);\n+        if (expiry < 0) {\n+            throw new IllegalArgumentException(\"Cache expiration time must be greater than or equal to 0\");\n+        }\n+        this.expiry = expiry;\n+    }\n+\n+    /**\n+     * Adds a file to the cache. If the cache previously contained a file for the key, the old file is replaced by the\n+     * new content.\n+     *\n+     * @param key the key with which the file is to be associated\n+     * @param content the content for the file to be associated with the specified key\n+     */\n+    public void put(String key, byte[] content) {\n+        writeFile(getUniqueFile(key), content);\n+    }\n+\n+    /**\n+     * Adds a file to the cache.\n+     *\n+     * @param key the key with which the file is to be associated\n+     * @param content the content for the file to be associated with the specified key\n+     */\n+    public void putIfAbsent(String key, byte[] content) {\n+        File fileInCache = getUniqueFile(key);\n+        if (fileInCache.exists()) {\n+            logger.debug(\"File '{}' present in cache\", fileInCache.getName());\n+            // update time of last use\n+            fileInCache.setLastModified(System.currentTimeMillis());\n+        } else {\n+            writeFile(fileInCache, content);\n+        }\n+    }\n+\n+    /**\n+     * Adds a file to the cache and returns the content of the file.\n+     *\n+     * @param key the key with which the file is to be associated\n+     * @param content the content for the file to be associated with the specified key\n+     * @return the content of the file associated with the given key\n+     */\n+    public byte[] putIfAbsentAndGet(String key, byte[] content) {\n+        putIfAbsent(key, content);\n+\n+        return content;\n+    }\n+\n+    /**\n+     * Writes the given content to the given {@link File}.\n+     *\n+     * @param fileInCache the {@link File}\n+     * @param content the content to be written\n+     */\n+    private void writeFile(File fileInCache, byte[] content) {\n+        logger.debug(\"Caching file '{}'\", fileInCache.getName());\n+        try {\n+            Files.write(fileInCache.toPath(), content);\n+        } catch (IOException e) {\n+            logger.warn(\"Could not write file '{}'\u00a0to cache\", fileInCache.getName(), e);\n+        }\n+    }\n+\n+    /**\n+     * Checks if the key is present in the cache.\n+     *\n+     * @param key the key whose presence in the cache is to be tested\n+     * @return true if the cache contains a file for the specified key\n+     */\n+    public boolean containsKey(String key) {\n+        return getUniqueFile(key).exists();\n+    }\n+\n+    /**\n+     * Removes the file associated with the given key from the cache.\n+     *\n+     * @param key the key whose associated file is to be removed\n+     */\n+    public void remove(String key) {\n+        deleteFile(getUniqueFile(key));\n+    }\n+\n+    /**\n+     * Deletes the given {@link File}.\n+     *\n+     * @param fileInCache the {@link File}\n+     */\n+    private void deleteFile(File fileInCache) {\n+        if (fileInCache.exists()) {\n+            logger.debug(\"Deleting file '{}' from cache\", fileInCache.getName());\n+            fileInCache.delete();\n+        } else {\n+            logger.debug(\"File '{}' not found in cache\", fileInCache.getName());\n+        }\n+    }\n+\n+    /**\n+     * Removes all files from the cache.\n+     */\n+    public void clear() {\n+        File[] filesInCache = cacheFolder.listFiles();\n+        if (filesInCache != null && filesInCache.length > 0) {\n+            logger.debug(\"Deleting all files from cache\");\n+            Arrays.stream(filesInCache).forEach(File::delete);\n+        }\n+    }\n+\n+    /**\n+     * Removes expired files from the cache.\n+     */\n+    public void clearExpired() {\n+        // exit if expiry is set to 0 (disabled)\n+        if (expiry <= 0) {\n+            return;\n+        }\n+        File[] filesInCache = cacheFolder.listFiles();\n+        if (filesInCache != null && filesInCache.length > 0) {\n+            logger.debug(\"Deleting expired files from cache\");\n+            Arrays.stream(filesInCache).filter(file -> isExpired(file)).forEach(File::delete);\n+        }\n+    }\n+\n+    /**\n+     * Checks if the given {@link File} is expired.\n+     *\n+     * @param fileInCache the {@link File}\n+     * @return <code>true</code> if the file is expired, <code>false</code> otherwise\n+     */\n+    private boolean isExpired(File fileInCache) {\n+        // exit if expiry is set to 0 (disabled)\n+        if (expiry <= 0) {\n+            return false;\n+        }\n+        return expiry * ONE_DAY_IN_MILLIS < System.currentTimeMillis() - fileInCache.lastModified();\n+    }\n+\n+    /**\n+     * Returns the content of the file associated with the given key, if it is present.\n+     *\n+     * @param key the key whose associated file is to be returned\n+     * @return the content of the file associated with the given key\n+     */\n+    public byte[] get(String key) {\n+        return readFile(getUniqueFile(key));\n+    }\n+\n+    /**\n+     * Reads the content from the given {@link File}, if it is present.\n+     *\n+     * @param fileInCache the {@link File}\n+     * @return the content of the file\n+     */\n+    private byte[] readFile(File fileInCache) {\n+        if (fileInCache.exists()) {\n+            logger.debug(\"Reading file '{}' from cache\", fileInCache.getName());\n+            // update time of last use\n+            fileInCache.setLastModified(System.currentTimeMillis());\n+            try {\n+                return Files.readAllBytes(fileInCache.toPath());\n+            } catch (IOException e) {\n+                logger.warn(\"Could not read file '{}'\u00a0from cache\", fileInCache.getName(), e);\n+            }\n+        } else {\n+            logger.debug(\"File '{}' not found in cache\", fileInCache.getName());\n+        }\n+        return new byte[0];\n+    }\n+\n+    /**\n+     * Creates a unique {@link File} from the key with which the file is to be associated.\n+     *\n+     * @param key the key with which the file is to be associated\n+     * @return unique file for the file associated with the given key\n+     */\n+    File getUniqueFile(String key) {\n+        String uniqueFileName = getUniqueFileName(key);\n+        if (FILES_IN_CACHE.containsKey(uniqueFileName)) {\n+            return FILES_IN_CACHE.get(uniqueFileName);\n+        } else {\n+            String fileExtension = getFileExtension(key);\n+            File fileInCache = new File(cacheFolder,\n+                    uniqueFileName + (fileExtension == null ? \"\" : EXTENSION_SEPARATOR + fileExtension));\n+            FILES_IN_CACHE.put(uniqueFileName, fileInCache);\n+            return fileInCache;\n+        }\n+    }\n+\n+    /**\n+     * Gets the extension of a file name.\n+     *\n+     * @param fileName the file name to retrieve the extension of\n+     * @return the extension of the file or null if none exists\n+     */\n+    @Nullable\n+    String getFileExtension(String fileName) {\n+        int extensionPos = fileName.lastIndexOf(EXTENSION_SEPARATOR);\n+        int lastSeparatorPos = Math.max(fileName.lastIndexOf(UNIX_SEPARATOR), fileName.lastIndexOf(WINDOWS_SEPARATOR));\n+        return lastSeparatorPos > extensionPos ? null : fileName.substring(extensionPos + 1).replaceFirst(\"\\\\?.*$\", \"\");\n+    }\n+\n+    /**\n+     * Creates a unique file name from the key with which the file is to be associated.\n+     *\n+     * @param key the key with which the file is to be associated\n+     * @return unique file name for the file associated with the given key\n+     */\n+    String getUniqueFileName(String key) {\n+        try {\n+            final MessageDigest md = MessageDigest.getInstance(MD5_ALGORITHM);\n+            return String.format(\"%032x\", new BigInteger(1, md.digest(key.getBytes(StandardCharsets.UTF_8))));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQwNDM3MA=="}, "originalCommit": {"oid": "cda5702bde5734236034eb2f0864200e6211afbe"}, "originalPosition": 292}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 240, "cost": 1, "resetAt": "2021-11-12T20:44:06Z"}}}